# AMD_COPYRIGHT
import cython
import ctypes
import enum
cimport hip._hip_helpers
HIP_VERSION_MAJOR = chip.HIP_VERSION_MAJOR

HIP_VERSION_MINOR = chip.HIP_VERSION_MINOR

HIP_VERSION_PATCH = chip.HIP_VERSION_PATCH

HIP_VERSION_GITHASH = chip.HIP_VERSION_GITHASH

HIP_VERSION_BUILD_ID = chip.HIP_VERSION_BUILD_ID

HIP_VERSION_BUILD_NAME = chip.HIP_VERSION_BUILD_NAME

HIP_VERSION = chip.HIP_VERSION

HIP_TRSA_OVERRIDE_FORMAT = chip.HIP_TRSA_OVERRIDE_FORMAT

HIP_TRSF_READ_AS_INTEGER = chip.HIP_TRSF_READ_AS_INTEGER

HIP_TRSF_NORMALIZED_COORDINATES = chip.HIP_TRSF_NORMALIZED_COORDINATES

HIP_TRSF_SRGB = chip.HIP_TRSF_SRGB

hipTextureType1D = chip.hipTextureType1D

hipTextureType2D = chip.hipTextureType2D

hipTextureType3D = chip.hipTextureType3D

hipTextureTypeCubemap = chip.hipTextureTypeCubemap

hipTextureType1DLayered = chip.hipTextureType1DLayered

hipTextureType2DLayered = chip.hipTextureType2DLayered

hipTextureTypeCubemapLayered = chip.hipTextureTypeCubemapLayered

HIP_IMAGE_OBJECT_SIZE_DWORD = chip.HIP_IMAGE_OBJECT_SIZE_DWORD

HIP_SAMPLER_OBJECT_SIZE_DWORD = chip.HIP_SAMPLER_OBJECT_SIZE_DWORD

HIP_SAMPLER_OBJECT_OFFSET_DWORD = chip.HIP_SAMPLER_OBJECT_OFFSET_DWORD

HIP_TEXTURE_OBJECT_SIZE_DWORD = chip.HIP_TEXTURE_OBJECT_SIZE_DWORD

HIP_LAUNCH_PARAM_BUFFER_POINTER = chip.HIP_LAUNCH_PARAM_BUFFER_POINTER

HIP_LAUNCH_PARAM_BUFFER_SIZE = chip.HIP_LAUNCH_PARAM_BUFFER_SIZE

HIP_LAUNCH_PARAM_END = chip.HIP_LAUNCH_PARAM_END

hipIpcMemLazyEnablePeerAccess = chip.hipIpcMemLazyEnablePeerAccess

HIP_IPC_HANDLE_SIZE = chip.HIP_IPC_HANDLE_SIZE

hipStreamDefault = chip.hipStreamDefault

hipStreamNonBlocking = chip.hipStreamNonBlocking

hipEventDefault = chip.hipEventDefault

hipEventBlockingSync = chip.hipEventBlockingSync

hipEventDisableTiming = chip.hipEventDisableTiming

hipEventInterprocess = chip.hipEventInterprocess

hipEventReleaseToDevice = chip.hipEventReleaseToDevice

hipEventReleaseToSystem = chip.hipEventReleaseToSystem

hipHostMallocDefault = chip.hipHostMallocDefault

hipHostMallocPortable = chip.hipHostMallocPortable

hipHostMallocMapped = chip.hipHostMallocMapped

hipHostMallocWriteCombined = chip.hipHostMallocWriteCombined

hipHostMallocNumaUser = chip.hipHostMallocNumaUser

hipHostMallocCoherent = chip.hipHostMallocCoherent

hipHostMallocNonCoherent = chip.hipHostMallocNonCoherent

hipMemAttachGlobal = chip.hipMemAttachGlobal

hipMemAttachHost = chip.hipMemAttachHost

hipMemAttachSingle = chip.hipMemAttachSingle

hipDeviceMallocDefault = chip.hipDeviceMallocDefault

hipDeviceMallocFinegrained = chip.hipDeviceMallocFinegrained

hipMallocSignalMemory = chip.hipMallocSignalMemory

hipHostRegisterDefault = chip.hipHostRegisterDefault

hipHostRegisterPortable = chip.hipHostRegisterPortable

hipHostRegisterMapped = chip.hipHostRegisterMapped

hipHostRegisterIoMemory = chip.hipHostRegisterIoMemory

hipExtHostRegisterCoarseGrained = chip.hipExtHostRegisterCoarseGrained

hipDeviceScheduleAuto = chip.hipDeviceScheduleAuto

hipDeviceScheduleSpin = chip.hipDeviceScheduleSpin

hipDeviceScheduleYield = chip.hipDeviceScheduleYield

hipDeviceScheduleBlockingSync = chip.hipDeviceScheduleBlockingSync

hipDeviceScheduleMask = chip.hipDeviceScheduleMask

hipDeviceMapHost = chip.hipDeviceMapHost

hipDeviceLmemResizeToMax = chip.hipDeviceLmemResizeToMax

hipArrayDefault = chip.hipArrayDefault

hipArrayLayered = chip.hipArrayLayered

hipArraySurfaceLoadStore = chip.hipArraySurfaceLoadStore

hipArrayCubemap = chip.hipArrayCubemap

hipArrayTextureGather = chip.hipArrayTextureGather

hipOccupancyDefault = chip.hipOccupancyDefault

hipCooperativeLaunchMultiDeviceNoPreSync = chip.hipCooperativeLaunchMultiDeviceNoPreSync

hipCooperativeLaunchMultiDeviceNoPostSync = chip.hipCooperativeLaunchMultiDeviceNoPostSync

hipCpuDeviceId = chip.hipCpuDeviceId

hipInvalidDeviceId = chip.hipInvalidDeviceId

hipExtAnyOrderLaunch = chip.hipExtAnyOrderLaunch

hipStreamWaitValueGte = chip.hipStreamWaitValueGte

hipStreamWaitValueEq = chip.hipStreamWaitValueEq

hipStreamWaitValueAnd = chip.hipStreamWaitValueAnd

hipStreamWaitValueNor = chip.hipStreamWaitValueNor

HIP_SUCCESS = chip.HIP_SUCCESS
HIP_ERROR_INVALID_VALUE = chip.HIP_ERROR_INVALID_VALUE
HIP_ERROR_NOT_INITIALIZED = chip.HIP_ERROR_NOT_INITIALIZED
HIP_ERROR_LAUNCH_OUT_OF_RESOURCES = chip.HIP_ERROR_LAUNCH_OUT_OF_RESOURCES

cdef class hipDeviceArch_t:
    # members declared in pxd file

    def __cinit__(self):
        self._ptr = NULL
        self.ptr_owner = False
        self._py_buffer_acquired = False

    @staticmethod
    cdef hipDeviceArch_t from_ptr(chip.hipDeviceArch_t* ptr, bint owner=False):
        """Factory function to create ``hipDeviceArch_t`` objects from
        given ``chip.hipDeviceArch_t`` pointer.

        Setting ``owner`` flag to ``True`` causes
        the extension type to ``free`` the structure pointed to by ``ptr``
        when the wrapper object is deallocated.
        """
        # Fast call to __new__() that bypasses the __init__() constructor.
        cdef hipDeviceArch_t wrapper = hipDeviceArch_t.__new__(hipDeviceArch_t)
        wrapper._ptr = ptr
        wrapper.ptr_owner = owner
        return wrapper

    @staticmethod
    cdef hipDeviceArch_t from_pyobj(object pyobj):
        """Derives a hipDeviceArch_t from a Python object.

        Derives a hipDeviceArch_t from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``hipDeviceArch_t`` reference, this method
        returns it directly. No new ``hipDeviceArch_t`` is created in this case.

        Args:
            pyobj (object): Must be either ``None``, a simple, contiguous buffer according to the buffer protocol,
                            or of type ``hipDeviceArch_t``, ``int``, or ``ctypes.c_void_p``

        Note:
            This routine does not perform a copy but returns the original ``pyobj``
            if ``pyobj`` is an instance of hipDeviceArch_t!
        """
        cdef hipDeviceArch_t wrapper = hipDeviceArch_t.__new__(hipDeviceArch_t)
        cdef dict cuda_array_interface = getattr(pyobj, "__cuda_array_interface__", None)

        if pyobj is None:
            wrapper._ptr = NULL
        elif isinstance(pyobj,hipDeviceArch_t):
            return pyobj
        elif isinstance(pyobj,int):
            wrapper._ptr = <chip.hipDeviceArch_t*>cpython.long.PyLong_AsVoidPtr(pyobj)
        elif isinstance(pyobj,ctypes.c_void_p):
            wrapper._ptr = <chip.hipDeviceArch_t*>cpython.long.PyLong_AsVoidPtr(pyobj.value) if pyobj.value != None else NULL
        elif cuda_array_interface != None:
            if not "data" in cuda_array_interface:
                raise ValueError("input object has '__cuda_array_interface__' attribute but the dict has no 'data' key")
            ptr_as_int = cuda_array_interface["data"][0]
            wrapper._ptr = <chip.hipDeviceArch_t*>cpython.long.PyLong_AsVoidPtr(ptr_as_int)
        elif cpython.buffer.PyObject_CheckBuffer(pyobj):
            err = cpython.buffer.PyObject_GetBuffer( 
                pyobj,
                &wrapper._py_buffer, 
                cpython.buffer.PyBUF_SIMPLE | cpython.buffer.PyBUF_ANY_CONTIGUOUS
            )
            if err == -1:
                raise RuntimeError("failed to create simple, contiguous Py_buffer from Python object")
            wrapper._py_buffer_acquired = True
            wrapper._ptr = <chip.hipDeviceArch_t*>wrapper._py_buffer.buf
        else:
            raise TypeError(f"unsupported input type: '{str(type(pyobj))}'")
        return wrapper
    def __dealloc__(self):
        # Release the buffer handle
        if self._py_buffer_acquired is True:
            cpython.buffer.PyBuffer_Release(&self._py_buffer)
        # De-allocate if not null and flag is set
        if self._ptr is not NULL and self.ptr_owner is True:
            stdlib.free(self._ptr)
            self._ptr = NULL
    @staticmethod
    cdef __allocate(chip.hipDeviceArch_t** ptr):
        ptr[0] = <chip.hipDeviceArch_t*>stdlib.malloc(sizeof(chip.hipDeviceArch_t))

        if ptr[0] is NULL:
            raise MemoryError
        # TODO init values, if present

    @staticmethod
    cdef hipDeviceArch_t new():
        """Factory function to create hipDeviceArch_t objects with
        newly allocated chip.hipDeviceArch_t"""
        cdef chip.hipDeviceArch_t* ptr
        hipDeviceArch_t.__allocate(&ptr)
        return hipDeviceArch_t.from_ptr(ptr, owner=True)
   
    def __init__(self,*args,**kwargs):
        hipDeviceArch_t.__allocate(&self._ptr)
        self.ptr_owner = True
        attribs = self.PROPERTIES()
        used_attribs = set()
        if len(args) > len(attribs):
            raise ValueError("More positional arguments specified than this type has properties.")
        for i,v in enumerate(args):
            setattr(self,attribs[i],v)
            used_attribs.add(attribs[i])
        valid_names = ", ".join(["'"+p+"'" for p in attribs])
        for k,v in kwargs.items():
            if k in used_attribs:
                raise KeyError(f"argument '{k}' has already been specified as positional argument.")
            elif k not in attribs:
                raise KeyError(f"'{k}' is no valid property name. Valid names: {valid_names}")
            setattr(self,k,v)
    
    def __int__(self):
        """Returns the data's address as long integer."""
        return cpython.long.PyLong_FromVoidPtr(self._ptr)
    def __repr__(self):
        return f"<hipDeviceArch_t object, self.ptr={int(self)}>"
    def as_c_void_p(self):
        """Returns the data's address as `ctypes.c_void_p`"""
        return ctypes.c_void_p(int(self))
    def get_hasGlobalInt32Atomics(self, i):
        """Get value ``hasGlobalInt32Atomics`` of ``self._ptr[i]``.
        """
        return self._ptr[i].hasGlobalInt32Atomics
    def set_hasGlobalInt32Atomics(self, i, unsigned int value):
        """Set value ``hasGlobalInt32Atomics`` of ``self._ptr[i]``.
        """
        self._ptr[i].hasGlobalInt32Atomics = value
    @property
    def hasGlobalInt32Atomics(self):
        return self.get_hasGlobalInt32Atomics(0)
    @hasGlobalInt32Atomics.setter
    def hasGlobalInt32Atomics(self, unsigned int value):
        self.set_hasGlobalInt32Atomics(0,value)

    def get_hasGlobalFloatAtomicExch(self, i):
        """Get value ``hasGlobalFloatAtomicExch`` of ``self._ptr[i]``.
        """
        return self._ptr[i].hasGlobalFloatAtomicExch
    def set_hasGlobalFloatAtomicExch(self, i, unsigned int value):
        """Set value ``hasGlobalFloatAtomicExch`` of ``self._ptr[i]``.
        """
        self._ptr[i].hasGlobalFloatAtomicExch = value
    @property
    def hasGlobalFloatAtomicExch(self):
        return self.get_hasGlobalFloatAtomicExch(0)
    @hasGlobalFloatAtomicExch.setter
    def hasGlobalFloatAtomicExch(self, unsigned int value):
        self.set_hasGlobalFloatAtomicExch(0,value)

    def get_hasSharedInt32Atomics(self, i):
        """Get value ``hasSharedInt32Atomics`` of ``self._ptr[i]``.
        """
        return self._ptr[i].hasSharedInt32Atomics
    def set_hasSharedInt32Atomics(self, i, unsigned int value):
        """Set value ``hasSharedInt32Atomics`` of ``self._ptr[i]``.
        """
        self._ptr[i].hasSharedInt32Atomics = value
    @property
    def hasSharedInt32Atomics(self):
        return self.get_hasSharedInt32Atomics(0)
    @hasSharedInt32Atomics.setter
    def hasSharedInt32Atomics(self, unsigned int value):
        self.set_hasSharedInt32Atomics(0,value)

    def get_hasSharedFloatAtomicExch(self, i):
        """Get value ``hasSharedFloatAtomicExch`` of ``self._ptr[i]``.
        """
        return self._ptr[i].hasSharedFloatAtomicExch
    def set_hasSharedFloatAtomicExch(self, i, unsigned int value):
        """Set value ``hasSharedFloatAtomicExch`` of ``self._ptr[i]``.
        """
        self._ptr[i].hasSharedFloatAtomicExch = value
    @property
    def hasSharedFloatAtomicExch(self):
        return self.get_hasSharedFloatAtomicExch(0)
    @hasSharedFloatAtomicExch.setter
    def hasSharedFloatAtomicExch(self, unsigned int value):
        self.set_hasSharedFloatAtomicExch(0,value)

    def get_hasFloatAtomicAdd(self, i):
        """Get value ``hasFloatAtomicAdd`` of ``self._ptr[i]``.
        """
        return self._ptr[i].hasFloatAtomicAdd
    def set_hasFloatAtomicAdd(self, i, unsigned int value):
        """Set value ``hasFloatAtomicAdd`` of ``self._ptr[i]``.
        """
        self._ptr[i].hasFloatAtomicAdd = value
    @property
    def hasFloatAtomicAdd(self):
        return self.get_hasFloatAtomicAdd(0)
    @hasFloatAtomicAdd.setter
    def hasFloatAtomicAdd(self, unsigned int value):
        self.set_hasFloatAtomicAdd(0,value)

    def get_hasGlobalInt64Atomics(self, i):
        """Get value ``hasGlobalInt64Atomics`` of ``self._ptr[i]``.
        """
        return self._ptr[i].hasGlobalInt64Atomics
    def set_hasGlobalInt64Atomics(self, i, unsigned int value):
        """Set value ``hasGlobalInt64Atomics`` of ``self._ptr[i]``.
        """
        self._ptr[i].hasGlobalInt64Atomics = value
    @property
    def hasGlobalInt64Atomics(self):
        return self.get_hasGlobalInt64Atomics(0)
    @hasGlobalInt64Atomics.setter
    def hasGlobalInt64Atomics(self, unsigned int value):
        self.set_hasGlobalInt64Atomics(0,value)

    def get_hasSharedInt64Atomics(self, i):
        """Get value ``hasSharedInt64Atomics`` of ``self._ptr[i]``.
        """
        return self._ptr[i].hasSharedInt64Atomics
    def set_hasSharedInt64Atomics(self, i, unsigned int value):
        """Set value ``hasSharedInt64Atomics`` of ``self._ptr[i]``.
        """
        self._ptr[i].hasSharedInt64Atomics = value
    @property
    def hasSharedInt64Atomics(self):
        return self.get_hasSharedInt64Atomics(0)
    @hasSharedInt64Atomics.setter
    def hasSharedInt64Atomics(self, unsigned int value):
        self.set_hasSharedInt64Atomics(0,value)

    def get_hasDoubles(self, i):
        """Get value ``hasDoubles`` of ``self._ptr[i]``.
        """
        return self._ptr[i].hasDoubles
    def set_hasDoubles(self, i, unsigned int value):
        """Set value ``hasDoubles`` of ``self._ptr[i]``.
        """
        self._ptr[i].hasDoubles = value
    @property
    def hasDoubles(self):
        return self.get_hasDoubles(0)
    @hasDoubles.setter
    def hasDoubles(self, unsigned int value):
        self.set_hasDoubles(0,value)

    def get_hasWarpVote(self, i):
        """Get value ``hasWarpVote`` of ``self._ptr[i]``.
        """
        return self._ptr[i].hasWarpVote
    def set_hasWarpVote(self, i, unsigned int value):
        """Set value ``hasWarpVote`` of ``self._ptr[i]``.
        """
        self._ptr[i].hasWarpVote = value
    @property
    def hasWarpVote(self):
        return self.get_hasWarpVote(0)
    @hasWarpVote.setter
    def hasWarpVote(self, unsigned int value):
        self.set_hasWarpVote(0,value)

    def get_hasWarpBallot(self, i):
        """Get value ``hasWarpBallot`` of ``self._ptr[i]``.
        """
        return self._ptr[i].hasWarpBallot
    def set_hasWarpBallot(self, i, unsigned int value):
        """Set value ``hasWarpBallot`` of ``self._ptr[i]``.
        """
        self._ptr[i].hasWarpBallot = value
    @property
    def hasWarpBallot(self):
        return self.get_hasWarpBallot(0)
    @hasWarpBallot.setter
    def hasWarpBallot(self, unsigned int value):
        self.set_hasWarpBallot(0,value)

    def get_hasWarpShuffle(self, i):
        """Get value ``hasWarpShuffle`` of ``self._ptr[i]``.
        """
        return self._ptr[i].hasWarpShuffle
    def set_hasWarpShuffle(self, i, unsigned int value):
        """Set value ``hasWarpShuffle`` of ``self._ptr[i]``.
        """
        self._ptr[i].hasWarpShuffle = value
    @property
    def hasWarpShuffle(self):
        return self.get_hasWarpShuffle(0)
    @hasWarpShuffle.setter
    def hasWarpShuffle(self, unsigned int value):
        self.set_hasWarpShuffle(0,value)

    def get_hasFunnelShift(self, i):
        """Get value ``hasFunnelShift`` of ``self._ptr[i]``.
        """
        return self._ptr[i].hasFunnelShift
    def set_hasFunnelShift(self, i, unsigned int value):
        """Set value ``hasFunnelShift`` of ``self._ptr[i]``.
        """
        self._ptr[i].hasFunnelShift = value
    @property
    def hasFunnelShift(self):
        return self.get_hasFunnelShift(0)
    @hasFunnelShift.setter
    def hasFunnelShift(self, unsigned int value):
        self.set_hasFunnelShift(0,value)

    def get_hasThreadFenceSystem(self, i):
        """Get value ``hasThreadFenceSystem`` of ``self._ptr[i]``.
        """
        return self._ptr[i].hasThreadFenceSystem
    def set_hasThreadFenceSystem(self, i, unsigned int value):
        """Set value ``hasThreadFenceSystem`` of ``self._ptr[i]``.
        """
        self._ptr[i].hasThreadFenceSystem = value
    @property
    def hasThreadFenceSystem(self):
        return self.get_hasThreadFenceSystem(0)
    @hasThreadFenceSystem.setter
    def hasThreadFenceSystem(self, unsigned int value):
        self.set_hasThreadFenceSystem(0,value)

    def get_hasSyncThreadsExt(self, i):
        """Get value ``hasSyncThreadsExt`` of ``self._ptr[i]``.
        """
        return self._ptr[i].hasSyncThreadsExt
    def set_hasSyncThreadsExt(self, i, unsigned int value):
        """Set value ``hasSyncThreadsExt`` of ``self._ptr[i]``.
        """
        self._ptr[i].hasSyncThreadsExt = value
    @property
    def hasSyncThreadsExt(self):
        return self.get_hasSyncThreadsExt(0)
    @hasSyncThreadsExt.setter
    def hasSyncThreadsExt(self, unsigned int value):
        self.set_hasSyncThreadsExt(0,value)

    def get_hasSurfaceFuncs(self, i):
        """Get value ``hasSurfaceFuncs`` of ``self._ptr[i]``.
        """
        return self._ptr[i].hasSurfaceFuncs
    def set_hasSurfaceFuncs(self, i, unsigned int value):
        """Set value ``hasSurfaceFuncs`` of ``self._ptr[i]``.
        """
        self._ptr[i].hasSurfaceFuncs = value
    @property
    def hasSurfaceFuncs(self):
        return self.get_hasSurfaceFuncs(0)
    @hasSurfaceFuncs.setter
    def hasSurfaceFuncs(self, unsigned int value):
        self.set_hasSurfaceFuncs(0,value)

    def get_has3dGrid(self, i):
        """Get value ``has3dGrid`` of ``self._ptr[i]``.
        """
        return self._ptr[i].has3dGrid
    def set_has3dGrid(self, i, unsigned int value):
        """Set value ``has3dGrid`` of ``self._ptr[i]``.
        """
        self._ptr[i].has3dGrid = value
    @property
    def has3dGrid(self):
        return self.get_has3dGrid(0)
    @has3dGrid.setter
    def has3dGrid(self, unsigned int value):
        self.set_has3dGrid(0,value)

    def get_hasDynamicParallelism(self, i):
        """Get value ``hasDynamicParallelism`` of ``self._ptr[i]``.
        """
        return self._ptr[i].hasDynamicParallelism
    def set_hasDynamicParallelism(self, i, unsigned int value):
        """Set value ``hasDynamicParallelism`` of ``self._ptr[i]``.
        """
        self._ptr[i].hasDynamicParallelism = value
    @property
    def hasDynamicParallelism(self):
        return self.get_hasDynamicParallelism(0)
    @hasDynamicParallelism.setter
    def hasDynamicParallelism(self, unsigned int value):
        self.set_hasDynamicParallelism(0,value)

    @staticmethod
    def PROPERTIES():
        return ["hasGlobalInt32Atomics","hasGlobalFloatAtomicExch","hasSharedInt32Atomics","hasSharedFloatAtomicExch","hasFloatAtomicAdd","hasGlobalInt64Atomics","hasSharedInt64Atomics","hasDoubles","hasWarpVote","hasWarpBallot","hasWarpShuffle","hasFunnelShift","hasThreadFenceSystem","hasSyncThreadsExt","hasSurfaceFuncs","has3dGrid","hasDynamicParallelism"]

    def __contains__(self,item):
        properties = self.PROPERTIES()
        return item in properties

    def __getitem__(self,item):
        properties = self.PROPERTIES()
        if isinstance(item,int):
            if item < 0 or item >= len(properties):
                raise IndexError()
            return getattr(self,properties[item])
        raise ValueError("'item' type must be 'int'")


cdef class hipUUID_t:
    # members declared in pxd file

    def __cinit__(self):
        self._ptr = NULL
        self.ptr_owner = False
        self._py_buffer_acquired = False

    @staticmethod
    cdef hipUUID_t from_ptr(chip.hipUUID_t* ptr, bint owner=False):
        """Factory function to create ``hipUUID_t`` objects from
        given ``chip.hipUUID_t`` pointer.

        Setting ``owner`` flag to ``True`` causes
        the extension type to ``free`` the structure pointed to by ``ptr``
        when the wrapper object is deallocated.
        """
        # Fast call to __new__() that bypasses the __init__() constructor.
        cdef hipUUID_t wrapper = hipUUID_t.__new__(hipUUID_t)
        wrapper._ptr = ptr
        wrapper.ptr_owner = owner
        return wrapper

    @staticmethod
    cdef hipUUID_t from_pyobj(object pyobj):
        """Derives a hipUUID_t from a Python object.

        Derives a hipUUID_t from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``hipUUID_t`` reference, this method
        returns it directly. No new ``hipUUID_t`` is created in this case.

        Args:
            pyobj (object): Must be either ``None``, a simple, contiguous buffer according to the buffer protocol,
                            or of type ``hipUUID_t``, ``int``, or ``ctypes.c_void_p``

        Note:
            This routine does not perform a copy but returns the original ``pyobj``
            if ``pyobj`` is an instance of hipUUID_t!
        """
        cdef hipUUID_t wrapper = hipUUID_t.__new__(hipUUID_t)
        cdef dict cuda_array_interface = getattr(pyobj, "__cuda_array_interface__", None)

        if pyobj is None:
            wrapper._ptr = NULL
        elif isinstance(pyobj,hipUUID_t):
            return pyobj
        elif isinstance(pyobj,int):
            wrapper._ptr = <chip.hipUUID_t*>cpython.long.PyLong_AsVoidPtr(pyobj)
        elif isinstance(pyobj,ctypes.c_void_p):
            wrapper._ptr = <chip.hipUUID_t*>cpython.long.PyLong_AsVoidPtr(pyobj.value) if pyobj.value != None else NULL
        elif cuda_array_interface != None:
            if not "data" in cuda_array_interface:
                raise ValueError("input object has '__cuda_array_interface__' attribute but the dict has no 'data' key")
            ptr_as_int = cuda_array_interface["data"][0]
            wrapper._ptr = <chip.hipUUID_t*>cpython.long.PyLong_AsVoidPtr(ptr_as_int)
        elif cpython.buffer.PyObject_CheckBuffer(pyobj):
            err = cpython.buffer.PyObject_GetBuffer( 
                pyobj,
                &wrapper._py_buffer, 
                cpython.buffer.PyBUF_SIMPLE | cpython.buffer.PyBUF_ANY_CONTIGUOUS
            )
            if err == -1:
                raise RuntimeError("failed to create simple, contiguous Py_buffer from Python object")
            wrapper._py_buffer_acquired = True
            wrapper._ptr = <chip.hipUUID_t*>wrapper._py_buffer.buf
        else:
            raise TypeError(f"unsupported input type: '{str(type(pyobj))}'")
        return wrapper
    def __dealloc__(self):
        # Release the buffer handle
        if self._py_buffer_acquired is True:
            cpython.buffer.PyBuffer_Release(&self._py_buffer)
        # De-allocate if not null and flag is set
        if self._ptr is not NULL and self.ptr_owner is True:
            stdlib.free(self._ptr)
            self._ptr = NULL
    @staticmethod
    cdef __allocate(chip.hipUUID_t** ptr):
        ptr[0] = <chip.hipUUID_t*>stdlib.malloc(sizeof(chip.hipUUID_t))

        if ptr[0] is NULL:
            raise MemoryError
        # TODO init values, if present

    @staticmethod
    cdef hipUUID_t new():
        """Factory function to create hipUUID_t objects with
        newly allocated chip.hipUUID_t"""
        cdef chip.hipUUID_t* ptr
        hipUUID_t.__allocate(&ptr)
        return hipUUID_t.from_ptr(ptr, owner=True)
   
    def __init__(self,*args,**kwargs):
        hipUUID_t.__allocate(&self._ptr)
        self.ptr_owner = True
        attribs = self.PROPERTIES()
        used_attribs = set()
        if len(args) > len(attribs):
            raise ValueError("More positional arguments specified than this type has properties.")
        for i,v in enumerate(args):
            setattr(self,attribs[i],v)
            used_attribs.add(attribs[i])
        valid_names = ", ".join(["'"+p+"'" for p in attribs])
        for k,v in kwargs.items():
            if k in used_attribs:
                raise KeyError(f"argument '{k}' has already been specified as positional argument.")
            elif k not in attribs:
                raise KeyError(f"'{k}' is no valid property name. Valid names: {valid_names}")
            setattr(self,k,v)
    
    def __int__(self):
        """Returns the data's address as long integer."""
        return cpython.long.PyLong_FromVoidPtr(self._ptr)
    def __repr__(self):
        return f"<hipUUID_t object, self.ptr={int(self)}>"
    def as_c_void_p(self):
        """Returns the data's address as `ctypes.c_void_p`"""
        return ctypes.c_void_p(int(self))
    def get_bytes(self, i):
        """Get value of ``bytes`` of ``self._ptr[i]``.
        """
        return self._ptr[i].bytes
    # TODO add setters
    #def set_bytes(self, i, char[16] value):
    #    """Set value ``bytes`` of ``self._ptr[i]``.
    #    """
    #    self._ptr[i].bytes = value
    @property
    def bytes(self):
        return self.get_bytes(0)
    # TODO add setters
    #@bytes.setter
    #def bytes(self, char[16] value):
    #    self.set_bytes(0,value)

    @staticmethod
    def PROPERTIES():
        return ["bytes"]

    def __contains__(self,item):
        properties = self.PROPERTIES()
        return item in properties

    def __getitem__(self,item):
        properties = self.PROPERTIES()
        if isinstance(item,int):
            if item < 0 or item >= len(properties):
                raise IndexError()
            return getattr(self,properties[item])
        raise ValueError("'item' type must be 'int'")


hipUUID = hipUUID_t

cdef class hipDeviceProp_t:
    # members declared in pxd file

    def __cinit__(self):
        self._ptr = NULL
        self.ptr_owner = False
        self._py_buffer_acquired = False

    @staticmethod
    cdef hipDeviceProp_t from_ptr(chip.hipDeviceProp_t* ptr, bint owner=False):
        """Factory function to create ``hipDeviceProp_t`` objects from
        given ``chip.hipDeviceProp_t`` pointer.

        Setting ``owner`` flag to ``True`` causes
        the extension type to ``free`` the structure pointed to by ``ptr``
        when the wrapper object is deallocated.
        """
        # Fast call to __new__() that bypasses the __init__() constructor.
        cdef hipDeviceProp_t wrapper = hipDeviceProp_t.__new__(hipDeviceProp_t)
        wrapper._ptr = ptr
        wrapper.ptr_owner = owner
        return wrapper

    @staticmethod
    cdef hipDeviceProp_t from_pyobj(object pyobj):
        """Derives a hipDeviceProp_t from a Python object.

        Derives a hipDeviceProp_t from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``hipDeviceProp_t`` reference, this method
        returns it directly. No new ``hipDeviceProp_t`` is created in this case.

        Args:
            pyobj (object): Must be either ``None``, a simple, contiguous buffer according to the buffer protocol,
                            or of type ``hipDeviceProp_t``, ``int``, or ``ctypes.c_void_p``

        Note:
            This routine does not perform a copy but returns the original ``pyobj``
            if ``pyobj`` is an instance of hipDeviceProp_t!
        """
        cdef hipDeviceProp_t wrapper = hipDeviceProp_t.__new__(hipDeviceProp_t)
        cdef dict cuda_array_interface = getattr(pyobj, "__cuda_array_interface__", None)

        if pyobj is None:
            wrapper._ptr = NULL
        elif isinstance(pyobj,hipDeviceProp_t):
            return pyobj
        elif isinstance(pyobj,int):
            wrapper._ptr = <chip.hipDeviceProp_t*>cpython.long.PyLong_AsVoidPtr(pyobj)
        elif isinstance(pyobj,ctypes.c_void_p):
            wrapper._ptr = <chip.hipDeviceProp_t*>cpython.long.PyLong_AsVoidPtr(pyobj.value) if pyobj.value != None else NULL
        elif cuda_array_interface != None:
            if not "data" in cuda_array_interface:
                raise ValueError("input object has '__cuda_array_interface__' attribute but the dict has no 'data' key")
            ptr_as_int = cuda_array_interface["data"][0]
            wrapper._ptr = <chip.hipDeviceProp_t*>cpython.long.PyLong_AsVoidPtr(ptr_as_int)
        elif cpython.buffer.PyObject_CheckBuffer(pyobj):
            err = cpython.buffer.PyObject_GetBuffer( 
                pyobj,
                &wrapper._py_buffer, 
                cpython.buffer.PyBUF_SIMPLE | cpython.buffer.PyBUF_ANY_CONTIGUOUS
            )
            if err == -1:
                raise RuntimeError("failed to create simple, contiguous Py_buffer from Python object")
            wrapper._py_buffer_acquired = True
            wrapper._ptr = <chip.hipDeviceProp_t*>wrapper._py_buffer.buf
        else:
            raise TypeError(f"unsupported input type: '{str(type(pyobj))}'")
        return wrapper
    def __dealloc__(self):
        # Release the buffer handle
        if self._py_buffer_acquired is True:
            cpython.buffer.PyBuffer_Release(&self._py_buffer)
        # De-allocate if not null and flag is set
        if self._ptr is not NULL and self.ptr_owner is True:
            stdlib.free(self._ptr)
            self._ptr = NULL
    @staticmethod
    cdef __allocate(chip.hipDeviceProp_t** ptr):
        ptr[0] = <chip.hipDeviceProp_t*>stdlib.malloc(sizeof(chip.hipDeviceProp_t))

        if ptr[0] is NULL:
            raise MemoryError
        # TODO init values, if present

    @staticmethod
    cdef hipDeviceProp_t new():
        """Factory function to create hipDeviceProp_t objects with
        newly allocated chip.hipDeviceProp_t"""
        cdef chip.hipDeviceProp_t* ptr
        hipDeviceProp_t.__allocate(&ptr)
        return hipDeviceProp_t.from_ptr(ptr, owner=True)
   
    def __init__(self,*args,**kwargs):
        hipDeviceProp_t.__allocate(&self._ptr)
        self.ptr_owner = True
        attribs = self.PROPERTIES()
        used_attribs = set()
        if len(args) > len(attribs):
            raise ValueError("More positional arguments specified than this type has properties.")
        for i,v in enumerate(args):
            setattr(self,attribs[i],v)
            used_attribs.add(attribs[i])
        valid_names = ", ".join(["'"+p+"'" for p in attribs])
        for k,v in kwargs.items():
            if k in used_attribs:
                raise KeyError(f"argument '{k}' has already been specified as positional argument.")
            elif k not in attribs:
                raise KeyError(f"'{k}' is no valid property name. Valid names: {valid_names}")
            setattr(self,k,v)
    
    def __int__(self):
        """Returns the data's address as long integer."""
        return cpython.long.PyLong_FromVoidPtr(self._ptr)
    def __repr__(self):
        return f"<hipDeviceProp_t object, self.ptr={int(self)}>"
    def as_c_void_p(self):
        """Returns the data's address as `ctypes.c_void_p`"""
        return ctypes.c_void_p(int(self))
    def get_name(self, i):
        """Get value of ``name`` of ``self._ptr[i]``.
        """
        return self._ptr[i].name
    # TODO add setters
    #def set_name(self, i, char[256] value):
    #    """Set value ``name`` of ``self._ptr[i]``.
    #    """
    #    self._ptr[i].name = value
    @property
    def name(self):
        return self.get_name(0)
    # TODO add setters
    #@name.setter
    #def name(self, char[256] value):
    #    self.set_name(0,value)

    def get_totalGlobalMem(self, i):
        """Get value ``totalGlobalMem`` of ``self._ptr[i]``.
        """
        return self._ptr[i].totalGlobalMem
    def set_totalGlobalMem(self, i, unsigned long value):
        """Set value ``totalGlobalMem`` of ``self._ptr[i]``.
        """
        self._ptr[i].totalGlobalMem = value
    @property
    def totalGlobalMem(self):
        return self.get_totalGlobalMem(0)
    @totalGlobalMem.setter
    def totalGlobalMem(self, unsigned long value):
        self.set_totalGlobalMem(0,value)

    def get_sharedMemPerBlock(self, i):
        """Get value ``sharedMemPerBlock`` of ``self._ptr[i]``.
        """
        return self._ptr[i].sharedMemPerBlock
    def set_sharedMemPerBlock(self, i, unsigned long value):
        """Set value ``sharedMemPerBlock`` of ``self._ptr[i]``.
        """
        self._ptr[i].sharedMemPerBlock = value
    @property
    def sharedMemPerBlock(self):
        return self.get_sharedMemPerBlock(0)
    @sharedMemPerBlock.setter
    def sharedMemPerBlock(self, unsigned long value):
        self.set_sharedMemPerBlock(0,value)

    def get_regsPerBlock(self, i):
        """Get value ``regsPerBlock`` of ``self._ptr[i]``.
        """
        return self._ptr[i].regsPerBlock
    def set_regsPerBlock(self, i, int value):
        """Set value ``regsPerBlock`` of ``self._ptr[i]``.
        """
        self._ptr[i].regsPerBlock = value
    @property
    def regsPerBlock(self):
        return self.get_regsPerBlock(0)
    @regsPerBlock.setter
    def regsPerBlock(self, int value):
        self.set_regsPerBlock(0,value)

    def get_warpSize(self, i):
        """Get value ``warpSize`` of ``self._ptr[i]``.
        """
        return self._ptr[i].warpSize
    def set_warpSize(self, i, int value):
        """Set value ``warpSize`` of ``self._ptr[i]``.
        """
        self._ptr[i].warpSize = value
    @property
    def warpSize(self):
        return self.get_warpSize(0)
    @warpSize.setter
    def warpSize(self, int value):
        self.set_warpSize(0,value)

    def get_maxThreadsPerBlock(self, i):
        """Get value ``maxThreadsPerBlock`` of ``self._ptr[i]``.
        """
        return self._ptr[i].maxThreadsPerBlock
    def set_maxThreadsPerBlock(self, i, int value):
        """Set value ``maxThreadsPerBlock`` of ``self._ptr[i]``.
        """
        self._ptr[i].maxThreadsPerBlock = value
    @property
    def maxThreadsPerBlock(self):
        return self.get_maxThreadsPerBlock(0)
    @maxThreadsPerBlock.setter
    def maxThreadsPerBlock(self, int value):
        self.set_maxThreadsPerBlock(0,value)

    def get_maxThreadsDim(self, i):
        """Get value of ``maxThreadsDim`` of ``self._ptr[i]``.
        """
        return self._ptr[i].maxThreadsDim
    # TODO add setters
    #def set_maxThreadsDim(self, i, int[3] value):
    #    """Set value ``maxThreadsDim`` of ``self._ptr[i]``.
    #    """
    #    self._ptr[i].maxThreadsDim = value
    @property
    def maxThreadsDim(self):
        return self.get_maxThreadsDim(0)
    # TODO add setters
    #@maxThreadsDim.setter
    #def maxThreadsDim(self, int[3] value):
    #    self.set_maxThreadsDim(0,value)

    def get_maxGridSize(self, i):
        """Get value of ``maxGridSize`` of ``self._ptr[i]``.
        """
        return self._ptr[i].maxGridSize
    # TODO add setters
    #def set_maxGridSize(self, i, int[3] value):
    #    """Set value ``maxGridSize`` of ``self._ptr[i]``.
    #    """
    #    self._ptr[i].maxGridSize = value
    @property
    def maxGridSize(self):
        return self.get_maxGridSize(0)
    # TODO add setters
    #@maxGridSize.setter
    #def maxGridSize(self, int[3] value):
    #    self.set_maxGridSize(0,value)

    def get_clockRate(self, i):
        """Get value ``clockRate`` of ``self._ptr[i]``.
        """
        return self._ptr[i].clockRate
    def set_clockRate(self, i, int value):
        """Set value ``clockRate`` of ``self._ptr[i]``.
        """
        self._ptr[i].clockRate = value
    @property
    def clockRate(self):
        return self.get_clockRate(0)
    @clockRate.setter
    def clockRate(self, int value):
        self.set_clockRate(0,value)

    def get_memoryClockRate(self, i):
        """Get value ``memoryClockRate`` of ``self._ptr[i]``.
        """
        return self._ptr[i].memoryClockRate
    def set_memoryClockRate(self, i, int value):
        """Set value ``memoryClockRate`` of ``self._ptr[i]``.
        """
        self._ptr[i].memoryClockRate = value
    @property
    def memoryClockRate(self):
        return self.get_memoryClockRate(0)
    @memoryClockRate.setter
    def memoryClockRate(self, int value):
        self.set_memoryClockRate(0,value)

    def get_memoryBusWidth(self, i):
        """Get value ``memoryBusWidth`` of ``self._ptr[i]``.
        """
        return self._ptr[i].memoryBusWidth
    def set_memoryBusWidth(self, i, int value):
        """Set value ``memoryBusWidth`` of ``self._ptr[i]``.
        """
        self._ptr[i].memoryBusWidth = value
    @property
    def memoryBusWidth(self):
        return self.get_memoryBusWidth(0)
    @memoryBusWidth.setter
    def memoryBusWidth(self, int value):
        self.set_memoryBusWidth(0,value)

    def get_totalConstMem(self, i):
        """Get value ``totalConstMem`` of ``self._ptr[i]``.
        """
        return self._ptr[i].totalConstMem
    def set_totalConstMem(self, i, unsigned long value):
        """Set value ``totalConstMem`` of ``self._ptr[i]``.
        """
        self._ptr[i].totalConstMem = value
    @property
    def totalConstMem(self):
        return self.get_totalConstMem(0)
    @totalConstMem.setter
    def totalConstMem(self, unsigned long value):
        self.set_totalConstMem(0,value)

    def get_major(self, i):
        """Get value ``major`` of ``self._ptr[i]``.
        """
        return self._ptr[i].major
    def set_major(self, i, int value):
        """Set value ``major`` of ``self._ptr[i]``.
        """
        self._ptr[i].major = value
    @property
    def major(self):
        return self.get_major(0)
    @major.setter
    def major(self, int value):
        self.set_major(0,value)

    def get_minor(self, i):
        """Get value ``minor`` of ``self._ptr[i]``.
        """
        return self._ptr[i].minor
    def set_minor(self, i, int value):
        """Set value ``minor`` of ``self._ptr[i]``.
        """
        self._ptr[i].minor = value
    @property
    def minor(self):
        return self.get_minor(0)
    @minor.setter
    def minor(self, int value):
        self.set_minor(0,value)

    def get_multiProcessorCount(self, i):
        """Get value ``multiProcessorCount`` of ``self._ptr[i]``.
        """
        return self._ptr[i].multiProcessorCount
    def set_multiProcessorCount(self, i, int value):
        """Set value ``multiProcessorCount`` of ``self._ptr[i]``.
        """
        self._ptr[i].multiProcessorCount = value
    @property
    def multiProcessorCount(self):
        return self.get_multiProcessorCount(0)
    @multiProcessorCount.setter
    def multiProcessorCount(self, int value):
        self.set_multiProcessorCount(0,value)

    def get_l2CacheSize(self, i):
        """Get value ``l2CacheSize`` of ``self._ptr[i]``.
        """
        return self._ptr[i].l2CacheSize
    def set_l2CacheSize(self, i, int value):
        """Set value ``l2CacheSize`` of ``self._ptr[i]``.
        """
        self._ptr[i].l2CacheSize = value
    @property
    def l2CacheSize(self):
        return self.get_l2CacheSize(0)
    @l2CacheSize.setter
    def l2CacheSize(self, int value):
        self.set_l2CacheSize(0,value)

    def get_maxThreadsPerMultiProcessor(self, i):
        """Get value ``maxThreadsPerMultiProcessor`` of ``self._ptr[i]``.
        """
        return self._ptr[i].maxThreadsPerMultiProcessor
    def set_maxThreadsPerMultiProcessor(self, i, int value):
        """Set value ``maxThreadsPerMultiProcessor`` of ``self._ptr[i]``.
        """
        self._ptr[i].maxThreadsPerMultiProcessor = value
    @property
    def maxThreadsPerMultiProcessor(self):
        return self.get_maxThreadsPerMultiProcessor(0)
    @maxThreadsPerMultiProcessor.setter
    def maxThreadsPerMultiProcessor(self, int value):
        self.set_maxThreadsPerMultiProcessor(0,value)

    def get_computeMode(self, i):
        """Get value ``computeMode`` of ``self._ptr[i]``.
        """
        return self._ptr[i].computeMode
    def set_computeMode(self, i, int value):
        """Set value ``computeMode`` of ``self._ptr[i]``.
        """
        self._ptr[i].computeMode = value
    @property
    def computeMode(self):
        return self.get_computeMode(0)
    @computeMode.setter
    def computeMode(self, int value):
        self.set_computeMode(0,value)

    def get_clockInstructionRate(self, i):
        """Get value ``clockInstructionRate`` of ``self._ptr[i]``.
        """
        return self._ptr[i].clockInstructionRate
    def set_clockInstructionRate(self, i, int value):
        """Set value ``clockInstructionRate`` of ``self._ptr[i]``.
        """
        self._ptr[i].clockInstructionRate = value
    @property
    def clockInstructionRate(self):
        return self.get_clockInstructionRate(0)
    @clockInstructionRate.setter
    def clockInstructionRate(self, int value):
        self.set_clockInstructionRate(0,value)

    def get_arch(self, i):
        """Get value of ``arch`` of ``self._ptr[i]``.
        """
        return hipDeviceArch_t.from_ptr(&self._ptr[i].arch)
    @property
    def arch(self):
        return self.get_arch(0)

    def get_concurrentKernels(self, i):
        """Get value ``concurrentKernels`` of ``self._ptr[i]``.
        """
        return self._ptr[i].concurrentKernels
    def set_concurrentKernels(self, i, int value):
        """Set value ``concurrentKernels`` of ``self._ptr[i]``.
        """
        self._ptr[i].concurrentKernels = value
    @property
    def concurrentKernels(self):
        return self.get_concurrentKernels(0)
    @concurrentKernels.setter
    def concurrentKernels(self, int value):
        self.set_concurrentKernels(0,value)

    def get_pciDomainID(self, i):
        """Get value ``pciDomainID`` of ``self._ptr[i]``.
        """
        return self._ptr[i].pciDomainID
    def set_pciDomainID(self, i, int value):
        """Set value ``pciDomainID`` of ``self._ptr[i]``.
        """
        self._ptr[i].pciDomainID = value
    @property
    def pciDomainID(self):
        return self.get_pciDomainID(0)
    @pciDomainID.setter
    def pciDomainID(self, int value):
        self.set_pciDomainID(0,value)

    def get_pciBusID(self, i):
        """Get value ``pciBusID`` of ``self._ptr[i]``.
        """
        return self._ptr[i].pciBusID
    def set_pciBusID(self, i, int value):
        """Set value ``pciBusID`` of ``self._ptr[i]``.
        """
        self._ptr[i].pciBusID = value
    @property
    def pciBusID(self):
        return self.get_pciBusID(0)
    @pciBusID.setter
    def pciBusID(self, int value):
        self.set_pciBusID(0,value)

    def get_pciDeviceID(self, i):
        """Get value ``pciDeviceID`` of ``self._ptr[i]``.
        """
        return self._ptr[i].pciDeviceID
    def set_pciDeviceID(self, i, int value):
        """Set value ``pciDeviceID`` of ``self._ptr[i]``.
        """
        self._ptr[i].pciDeviceID = value
    @property
    def pciDeviceID(self):
        return self.get_pciDeviceID(0)
    @pciDeviceID.setter
    def pciDeviceID(self, int value):
        self.set_pciDeviceID(0,value)

    def get_maxSharedMemoryPerMultiProcessor(self, i):
        """Get value ``maxSharedMemoryPerMultiProcessor`` of ``self._ptr[i]``.
        """
        return self._ptr[i].maxSharedMemoryPerMultiProcessor
    def set_maxSharedMemoryPerMultiProcessor(self, i, unsigned long value):
        """Set value ``maxSharedMemoryPerMultiProcessor`` of ``self._ptr[i]``.
        """
        self._ptr[i].maxSharedMemoryPerMultiProcessor = value
    @property
    def maxSharedMemoryPerMultiProcessor(self):
        return self.get_maxSharedMemoryPerMultiProcessor(0)
    @maxSharedMemoryPerMultiProcessor.setter
    def maxSharedMemoryPerMultiProcessor(self, unsigned long value):
        self.set_maxSharedMemoryPerMultiProcessor(0,value)

    def get_isMultiGpuBoard(self, i):
        """Get value ``isMultiGpuBoard`` of ``self._ptr[i]``.
        """
        return self._ptr[i].isMultiGpuBoard
    def set_isMultiGpuBoard(self, i, int value):
        """Set value ``isMultiGpuBoard`` of ``self._ptr[i]``.
        """
        self._ptr[i].isMultiGpuBoard = value
    @property
    def isMultiGpuBoard(self):
        return self.get_isMultiGpuBoard(0)
    @isMultiGpuBoard.setter
    def isMultiGpuBoard(self, int value):
        self.set_isMultiGpuBoard(0,value)

    def get_canMapHostMemory(self, i):
        """Get value ``canMapHostMemory`` of ``self._ptr[i]``.
        """
        return self._ptr[i].canMapHostMemory
    def set_canMapHostMemory(self, i, int value):
        """Set value ``canMapHostMemory`` of ``self._ptr[i]``.
        """
        self._ptr[i].canMapHostMemory = value
    @property
    def canMapHostMemory(self):
        return self.get_canMapHostMemory(0)
    @canMapHostMemory.setter
    def canMapHostMemory(self, int value):
        self.set_canMapHostMemory(0,value)

    def get_gcnArch(self, i):
        """Get value ``gcnArch`` of ``self._ptr[i]``.
        """
        return self._ptr[i].gcnArch
    def set_gcnArch(self, i, int value):
        """Set value ``gcnArch`` of ``self._ptr[i]``.
        """
        self._ptr[i].gcnArch = value
    @property
    def gcnArch(self):
        return self.get_gcnArch(0)
    @gcnArch.setter
    def gcnArch(self, int value):
        self.set_gcnArch(0,value)

    def get_gcnArchName(self, i):
        """Get value of ``gcnArchName`` of ``self._ptr[i]``.
        """
        return self._ptr[i].gcnArchName
    # TODO add setters
    #def set_gcnArchName(self, i, char[256] value):
    #    """Set value ``gcnArchName`` of ``self._ptr[i]``.
    #    """
    #    self._ptr[i].gcnArchName = value
    @property
    def gcnArchName(self):
        return self.get_gcnArchName(0)
    # TODO add setters
    #@gcnArchName.setter
    #def gcnArchName(self, char[256] value):
    #    self.set_gcnArchName(0,value)

    def get_integrated(self, i):
        """Get value ``integrated`` of ``self._ptr[i]``.
        """
        return self._ptr[i].integrated
    def set_integrated(self, i, int value):
        """Set value ``integrated`` of ``self._ptr[i]``.
        """
        self._ptr[i].integrated = value
    @property
    def integrated(self):
        return self.get_integrated(0)
    @integrated.setter
    def integrated(self, int value):
        self.set_integrated(0,value)

    def get_cooperativeLaunch(self, i):
        """Get value ``cooperativeLaunch`` of ``self._ptr[i]``.
        """
        return self._ptr[i].cooperativeLaunch
    def set_cooperativeLaunch(self, i, int value):
        """Set value ``cooperativeLaunch`` of ``self._ptr[i]``.
        """
        self._ptr[i].cooperativeLaunch = value
    @property
    def cooperativeLaunch(self):
        return self.get_cooperativeLaunch(0)
    @cooperativeLaunch.setter
    def cooperativeLaunch(self, int value):
        self.set_cooperativeLaunch(0,value)

    def get_cooperativeMultiDeviceLaunch(self, i):
        """Get value ``cooperativeMultiDeviceLaunch`` of ``self._ptr[i]``.
        """
        return self._ptr[i].cooperativeMultiDeviceLaunch
    def set_cooperativeMultiDeviceLaunch(self, i, int value):
        """Set value ``cooperativeMultiDeviceLaunch`` of ``self._ptr[i]``.
        """
        self._ptr[i].cooperativeMultiDeviceLaunch = value
    @property
    def cooperativeMultiDeviceLaunch(self):
        return self.get_cooperativeMultiDeviceLaunch(0)
    @cooperativeMultiDeviceLaunch.setter
    def cooperativeMultiDeviceLaunch(self, int value):
        self.set_cooperativeMultiDeviceLaunch(0,value)

    def get_maxTexture1DLinear(self, i):
        """Get value ``maxTexture1DLinear`` of ``self._ptr[i]``.
        """
        return self._ptr[i].maxTexture1DLinear
    def set_maxTexture1DLinear(self, i, int value):
        """Set value ``maxTexture1DLinear`` of ``self._ptr[i]``.
        """
        self._ptr[i].maxTexture1DLinear = value
    @property
    def maxTexture1DLinear(self):
        return self.get_maxTexture1DLinear(0)
    @maxTexture1DLinear.setter
    def maxTexture1DLinear(self, int value):
        self.set_maxTexture1DLinear(0,value)

    def get_maxTexture1D(self, i):
        """Get value ``maxTexture1D`` of ``self._ptr[i]``.
        """
        return self._ptr[i].maxTexture1D
    def set_maxTexture1D(self, i, int value):
        """Set value ``maxTexture1D`` of ``self._ptr[i]``.
        """
        self._ptr[i].maxTexture1D = value
    @property
    def maxTexture1D(self):
        return self.get_maxTexture1D(0)
    @maxTexture1D.setter
    def maxTexture1D(self, int value):
        self.set_maxTexture1D(0,value)

    def get_maxTexture2D(self, i):
        """Get value of ``maxTexture2D`` of ``self._ptr[i]``.
        """
        return self._ptr[i].maxTexture2D
    # TODO add setters
    #def set_maxTexture2D(self, i, int[2] value):
    #    """Set value ``maxTexture2D`` of ``self._ptr[i]``.
    #    """
    #    self._ptr[i].maxTexture2D = value
    @property
    def maxTexture2D(self):
        return self.get_maxTexture2D(0)
    # TODO add setters
    #@maxTexture2D.setter
    #def maxTexture2D(self, int[2] value):
    #    self.set_maxTexture2D(0,value)

    def get_maxTexture3D(self, i):
        """Get value of ``maxTexture3D`` of ``self._ptr[i]``.
        """
        return self._ptr[i].maxTexture3D
    # TODO add setters
    #def set_maxTexture3D(self, i, int[3] value):
    #    """Set value ``maxTexture3D`` of ``self._ptr[i]``.
    #    """
    #    self._ptr[i].maxTexture3D = value
    @property
    def maxTexture3D(self):
        return self.get_maxTexture3D(0)
    # TODO add setters
    #@maxTexture3D.setter
    #def maxTexture3D(self, int[3] value):
    #    self.set_maxTexture3D(0,value)

    def get_hdpMemFlushCntl(self, i):
        """Get value ``hdpMemFlushCntl`` of ``self._ptr[i]``.
        """
        return hip._util.types.ListOfUnsigned.from_ptr(self._ptr[i].hdpMemFlushCntl)
    def set_hdpMemFlushCntl(self, i, object value):
        """Set value ``hdpMemFlushCntl`` of ``self._ptr[i]``.

        Note:
            This can be dangerous if the pointer is from a python object
            that is later on garbage collected.
        """
        self._ptr[i].hdpMemFlushCntl = <unsigned int *>cpython.long.PyLong_AsVoidPtr(int(hip._util.types.ListOfUnsigned.from_pyobj(value)))
    @property
    def hdpMemFlushCntl(self):
        """
        Note:
            Setting this hdpMemFlushCntl can be dangerous if the underlying pointer is from a python object that
            is later on garbage collected.
        """
        return self.get_hdpMemFlushCntl(0)
    @hdpMemFlushCntl.setter
    def hdpMemFlushCntl(self, object value):
        self.set_hdpMemFlushCntl(0,value)

    def get_hdpRegFlushCntl(self, i):
        """Get value ``hdpRegFlushCntl`` of ``self._ptr[i]``.
        """
        return hip._util.types.ListOfUnsigned.from_ptr(self._ptr[i].hdpRegFlushCntl)
    def set_hdpRegFlushCntl(self, i, object value):
        """Set value ``hdpRegFlushCntl`` of ``self._ptr[i]``.

        Note:
            This can be dangerous if the pointer is from a python object
            that is later on garbage collected.
        """
        self._ptr[i].hdpRegFlushCntl = <unsigned int *>cpython.long.PyLong_AsVoidPtr(int(hip._util.types.ListOfUnsigned.from_pyobj(value)))
    @property
    def hdpRegFlushCntl(self):
        """
        Note:
            Setting this hdpRegFlushCntl can be dangerous if the underlying pointer is from a python object that
            is later on garbage collected.
        """
        return self.get_hdpRegFlushCntl(0)
    @hdpRegFlushCntl.setter
    def hdpRegFlushCntl(self, object value):
        self.set_hdpRegFlushCntl(0,value)

    def get_memPitch(self, i):
        """Get value ``memPitch`` of ``self._ptr[i]``.
        """
        return self._ptr[i].memPitch
    def set_memPitch(self, i, unsigned long value):
        """Set value ``memPitch`` of ``self._ptr[i]``.
        """
        self._ptr[i].memPitch = value
    @property
    def memPitch(self):
        return self.get_memPitch(0)
    @memPitch.setter
    def memPitch(self, unsigned long value):
        self.set_memPitch(0,value)

    def get_textureAlignment(self, i):
        """Get value ``textureAlignment`` of ``self._ptr[i]``.
        """
        return self._ptr[i].textureAlignment
    def set_textureAlignment(self, i, unsigned long value):
        """Set value ``textureAlignment`` of ``self._ptr[i]``.
        """
        self._ptr[i].textureAlignment = value
    @property
    def textureAlignment(self):
        return self.get_textureAlignment(0)
    @textureAlignment.setter
    def textureAlignment(self, unsigned long value):
        self.set_textureAlignment(0,value)

    def get_texturePitchAlignment(self, i):
        """Get value ``texturePitchAlignment`` of ``self._ptr[i]``.
        """
        return self._ptr[i].texturePitchAlignment
    def set_texturePitchAlignment(self, i, unsigned long value):
        """Set value ``texturePitchAlignment`` of ``self._ptr[i]``.
        """
        self._ptr[i].texturePitchAlignment = value
    @property
    def texturePitchAlignment(self):
        return self.get_texturePitchAlignment(0)
    @texturePitchAlignment.setter
    def texturePitchAlignment(self, unsigned long value):
        self.set_texturePitchAlignment(0,value)

    def get_kernelExecTimeoutEnabled(self, i):
        """Get value ``kernelExecTimeoutEnabled`` of ``self._ptr[i]``.
        """
        return self._ptr[i].kernelExecTimeoutEnabled
    def set_kernelExecTimeoutEnabled(self, i, int value):
        """Set value ``kernelExecTimeoutEnabled`` of ``self._ptr[i]``.
        """
        self._ptr[i].kernelExecTimeoutEnabled = value
    @property
    def kernelExecTimeoutEnabled(self):
        return self.get_kernelExecTimeoutEnabled(0)
    @kernelExecTimeoutEnabled.setter
    def kernelExecTimeoutEnabled(self, int value):
        self.set_kernelExecTimeoutEnabled(0,value)

    def get_ECCEnabled(self, i):
        """Get value ``ECCEnabled`` of ``self._ptr[i]``.
        """
        return self._ptr[i].ECCEnabled
    def set_ECCEnabled(self, i, int value):
        """Set value ``ECCEnabled`` of ``self._ptr[i]``.
        """
        self._ptr[i].ECCEnabled = value
    @property
    def ECCEnabled(self):
        return self.get_ECCEnabled(0)
    @ECCEnabled.setter
    def ECCEnabled(self, int value):
        self.set_ECCEnabled(0,value)

    def get_tccDriver(self, i):
        """Get value ``tccDriver`` of ``self._ptr[i]``.
        """
        return self._ptr[i].tccDriver
    def set_tccDriver(self, i, int value):
        """Set value ``tccDriver`` of ``self._ptr[i]``.
        """
        self._ptr[i].tccDriver = value
    @property
    def tccDriver(self):
        return self.get_tccDriver(0)
    @tccDriver.setter
    def tccDriver(self, int value):
        self.set_tccDriver(0,value)

    def get_cooperativeMultiDeviceUnmatchedFunc(self, i):
        """Get value ``cooperativeMultiDeviceUnmatchedFunc`` of ``self._ptr[i]``.
        """
        return self._ptr[i].cooperativeMultiDeviceUnmatchedFunc
    def set_cooperativeMultiDeviceUnmatchedFunc(self, i, int value):
        """Set value ``cooperativeMultiDeviceUnmatchedFunc`` of ``self._ptr[i]``.
        """
        self._ptr[i].cooperativeMultiDeviceUnmatchedFunc = value
    @property
    def cooperativeMultiDeviceUnmatchedFunc(self):
        return self.get_cooperativeMultiDeviceUnmatchedFunc(0)
    @cooperativeMultiDeviceUnmatchedFunc.setter
    def cooperativeMultiDeviceUnmatchedFunc(self, int value):
        self.set_cooperativeMultiDeviceUnmatchedFunc(0,value)

    def get_cooperativeMultiDeviceUnmatchedGridDim(self, i):
        """Get value ``cooperativeMultiDeviceUnmatchedGridDim`` of ``self._ptr[i]``.
        """
        return self._ptr[i].cooperativeMultiDeviceUnmatchedGridDim
    def set_cooperativeMultiDeviceUnmatchedGridDim(self, i, int value):
        """Set value ``cooperativeMultiDeviceUnmatchedGridDim`` of ``self._ptr[i]``.
        """
        self._ptr[i].cooperativeMultiDeviceUnmatchedGridDim = value
    @property
    def cooperativeMultiDeviceUnmatchedGridDim(self):
        return self.get_cooperativeMultiDeviceUnmatchedGridDim(0)
    @cooperativeMultiDeviceUnmatchedGridDim.setter
    def cooperativeMultiDeviceUnmatchedGridDim(self, int value):
        self.set_cooperativeMultiDeviceUnmatchedGridDim(0,value)

    def get_cooperativeMultiDeviceUnmatchedBlockDim(self, i):
        """Get value ``cooperativeMultiDeviceUnmatchedBlockDim`` of ``self._ptr[i]``.
        """
        return self._ptr[i].cooperativeMultiDeviceUnmatchedBlockDim
    def set_cooperativeMultiDeviceUnmatchedBlockDim(self, i, int value):
        """Set value ``cooperativeMultiDeviceUnmatchedBlockDim`` of ``self._ptr[i]``.
        """
        self._ptr[i].cooperativeMultiDeviceUnmatchedBlockDim = value
    @property
    def cooperativeMultiDeviceUnmatchedBlockDim(self):
        return self.get_cooperativeMultiDeviceUnmatchedBlockDim(0)
    @cooperativeMultiDeviceUnmatchedBlockDim.setter
    def cooperativeMultiDeviceUnmatchedBlockDim(self, int value):
        self.set_cooperativeMultiDeviceUnmatchedBlockDim(0,value)

    def get_cooperativeMultiDeviceUnmatchedSharedMem(self, i):
        """Get value ``cooperativeMultiDeviceUnmatchedSharedMem`` of ``self._ptr[i]``.
        """
        return self._ptr[i].cooperativeMultiDeviceUnmatchedSharedMem
    def set_cooperativeMultiDeviceUnmatchedSharedMem(self, i, int value):
        """Set value ``cooperativeMultiDeviceUnmatchedSharedMem`` of ``self._ptr[i]``.
        """
        self._ptr[i].cooperativeMultiDeviceUnmatchedSharedMem = value
    @property
    def cooperativeMultiDeviceUnmatchedSharedMem(self):
        return self.get_cooperativeMultiDeviceUnmatchedSharedMem(0)
    @cooperativeMultiDeviceUnmatchedSharedMem.setter
    def cooperativeMultiDeviceUnmatchedSharedMem(self, int value):
        self.set_cooperativeMultiDeviceUnmatchedSharedMem(0,value)

    def get_isLargeBar(self, i):
        """Get value ``isLargeBar`` of ``self._ptr[i]``.
        """
        return self._ptr[i].isLargeBar
    def set_isLargeBar(self, i, int value):
        """Set value ``isLargeBar`` of ``self._ptr[i]``.
        """
        self._ptr[i].isLargeBar = value
    @property
    def isLargeBar(self):
        return self.get_isLargeBar(0)
    @isLargeBar.setter
    def isLargeBar(self, int value):
        self.set_isLargeBar(0,value)

    def get_asicRevision(self, i):
        """Get value ``asicRevision`` of ``self._ptr[i]``.
        """
        return self._ptr[i].asicRevision
    def set_asicRevision(self, i, int value):
        """Set value ``asicRevision`` of ``self._ptr[i]``.
        """
        self._ptr[i].asicRevision = value
    @property
    def asicRevision(self):
        return self.get_asicRevision(0)
    @asicRevision.setter
    def asicRevision(self, int value):
        self.set_asicRevision(0,value)

    def get_managedMemory(self, i):
        """Get value ``managedMemory`` of ``self._ptr[i]``.
        """
        return self._ptr[i].managedMemory
    def set_managedMemory(self, i, int value):
        """Set value ``managedMemory`` of ``self._ptr[i]``.
        """
        self._ptr[i].managedMemory = value
    @property
    def managedMemory(self):
        return self.get_managedMemory(0)
    @managedMemory.setter
    def managedMemory(self, int value):
        self.set_managedMemory(0,value)

    def get_directManagedMemAccessFromHost(self, i):
        """Get value ``directManagedMemAccessFromHost`` of ``self._ptr[i]``.
        """
        return self._ptr[i].directManagedMemAccessFromHost
    def set_directManagedMemAccessFromHost(self, i, int value):
        """Set value ``directManagedMemAccessFromHost`` of ``self._ptr[i]``.
        """
        self._ptr[i].directManagedMemAccessFromHost = value
    @property
    def directManagedMemAccessFromHost(self):
        return self.get_directManagedMemAccessFromHost(0)
    @directManagedMemAccessFromHost.setter
    def directManagedMemAccessFromHost(self, int value):
        self.set_directManagedMemAccessFromHost(0,value)

    def get_concurrentManagedAccess(self, i):
        """Get value ``concurrentManagedAccess`` of ``self._ptr[i]``.
        """
        return self._ptr[i].concurrentManagedAccess
    def set_concurrentManagedAccess(self, i, int value):
        """Set value ``concurrentManagedAccess`` of ``self._ptr[i]``.
        """
        self._ptr[i].concurrentManagedAccess = value
    @property
    def concurrentManagedAccess(self):
        return self.get_concurrentManagedAccess(0)
    @concurrentManagedAccess.setter
    def concurrentManagedAccess(self, int value):
        self.set_concurrentManagedAccess(0,value)

    def get_pageableMemoryAccess(self, i):
        """Get value ``pageableMemoryAccess`` of ``self._ptr[i]``.
        """
        return self._ptr[i].pageableMemoryAccess
    def set_pageableMemoryAccess(self, i, int value):
        """Set value ``pageableMemoryAccess`` of ``self._ptr[i]``.
        """
        self._ptr[i].pageableMemoryAccess = value
    @property
    def pageableMemoryAccess(self):
        return self.get_pageableMemoryAccess(0)
    @pageableMemoryAccess.setter
    def pageableMemoryAccess(self, int value):
        self.set_pageableMemoryAccess(0,value)

    def get_pageableMemoryAccessUsesHostPageTables(self, i):
        """Get value ``pageableMemoryAccessUsesHostPageTables`` of ``self._ptr[i]``.
        """
        return self._ptr[i].pageableMemoryAccessUsesHostPageTables
    def set_pageableMemoryAccessUsesHostPageTables(self, i, int value):
        """Set value ``pageableMemoryAccessUsesHostPageTables`` of ``self._ptr[i]``.
        """
        self._ptr[i].pageableMemoryAccessUsesHostPageTables = value
    @property
    def pageableMemoryAccessUsesHostPageTables(self):
        return self.get_pageableMemoryAccessUsesHostPageTables(0)
    @pageableMemoryAccessUsesHostPageTables.setter
    def pageableMemoryAccessUsesHostPageTables(self, int value):
        self.set_pageableMemoryAccessUsesHostPageTables(0,value)

    @staticmethod
    def PROPERTIES():
        return ["name","totalGlobalMem","sharedMemPerBlock","regsPerBlock","warpSize","maxThreadsPerBlock","maxThreadsDim","maxGridSize","clockRate","memoryClockRate","memoryBusWidth","totalConstMem","major","minor","multiProcessorCount","l2CacheSize","maxThreadsPerMultiProcessor","computeMode","clockInstructionRate","arch","concurrentKernels","pciDomainID","pciBusID","pciDeviceID","maxSharedMemoryPerMultiProcessor","isMultiGpuBoard","canMapHostMemory","gcnArch","gcnArchName","integrated","cooperativeLaunch","cooperativeMultiDeviceLaunch","maxTexture1DLinear","maxTexture1D","maxTexture2D","maxTexture3D","hdpMemFlushCntl","hdpRegFlushCntl","memPitch","textureAlignment","texturePitchAlignment","kernelExecTimeoutEnabled","ECCEnabled","tccDriver","cooperativeMultiDeviceUnmatchedFunc","cooperativeMultiDeviceUnmatchedGridDim","cooperativeMultiDeviceUnmatchedBlockDim","cooperativeMultiDeviceUnmatchedSharedMem","isLargeBar","asicRevision","managedMemory","directManagedMemAccessFromHost","concurrentManagedAccess","pageableMemoryAccess","pageableMemoryAccessUsesHostPageTables"]

    def __contains__(self,item):
        properties = self.PROPERTIES()
        return item in properties

    def __getitem__(self,item):
        properties = self.PROPERTIES()
        if isinstance(item,int):
            if item < 0 or item >= len(properties):
                raise IndexError()
            return getattr(self,properties[item])
        raise ValueError("'item' type must be 'int'")


class _hipMemoryType__Base(enum.IntEnum):
    """Empty enum base class that allows subclassing.
    """
    pass
class hipMemoryType(_hipMemoryType__Base):
    hipMemoryTypeHost = chip.hipMemoryTypeHost
    hipMemoryTypeDevice = chip.hipMemoryTypeDevice
    hipMemoryTypeArray = chip.hipMemoryTypeArray
    hipMemoryTypeUnified = chip.hipMemoryTypeUnified
    hipMemoryTypeManaged = chip.hipMemoryTypeManaged
    @staticmethod
    def ctypes_type():
        """The type of the enum constants as ctypes type."""
        return ctypes.c_uint 


cdef class hipPointerAttribute_t:
    # members declared in pxd file

    def __cinit__(self):
        self._ptr = NULL
        self.ptr_owner = False
        self._py_buffer_acquired = False

    @staticmethod
    cdef hipPointerAttribute_t from_ptr(chip.hipPointerAttribute_t* ptr, bint owner=False):
        """Factory function to create ``hipPointerAttribute_t`` objects from
        given ``chip.hipPointerAttribute_t`` pointer.

        Setting ``owner`` flag to ``True`` causes
        the extension type to ``free`` the structure pointed to by ``ptr``
        when the wrapper object is deallocated.
        """
        # Fast call to __new__() that bypasses the __init__() constructor.
        cdef hipPointerAttribute_t wrapper = hipPointerAttribute_t.__new__(hipPointerAttribute_t)
        wrapper._ptr = ptr
        wrapper.ptr_owner = owner
        return wrapper

    @staticmethod
    cdef hipPointerAttribute_t from_pyobj(object pyobj):
        """Derives a hipPointerAttribute_t from a Python object.

        Derives a hipPointerAttribute_t from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``hipPointerAttribute_t`` reference, this method
        returns it directly. No new ``hipPointerAttribute_t`` is created in this case.

        Args:
            pyobj (object): Must be either ``None``, a simple, contiguous buffer according to the buffer protocol,
                            or of type ``hipPointerAttribute_t``, ``int``, or ``ctypes.c_void_p``

        Note:
            This routine does not perform a copy but returns the original ``pyobj``
            if ``pyobj`` is an instance of hipPointerAttribute_t!
        """
        cdef hipPointerAttribute_t wrapper = hipPointerAttribute_t.__new__(hipPointerAttribute_t)
        cdef dict cuda_array_interface = getattr(pyobj, "__cuda_array_interface__", None)

        if pyobj is None:
            wrapper._ptr = NULL
        elif isinstance(pyobj,hipPointerAttribute_t):
            return pyobj
        elif isinstance(pyobj,int):
            wrapper._ptr = <chip.hipPointerAttribute_t*>cpython.long.PyLong_AsVoidPtr(pyobj)
        elif isinstance(pyobj,ctypes.c_void_p):
            wrapper._ptr = <chip.hipPointerAttribute_t*>cpython.long.PyLong_AsVoidPtr(pyobj.value) if pyobj.value != None else NULL
        elif cuda_array_interface != None:
            if not "data" in cuda_array_interface:
                raise ValueError("input object has '__cuda_array_interface__' attribute but the dict has no 'data' key")
            ptr_as_int = cuda_array_interface["data"][0]
            wrapper._ptr = <chip.hipPointerAttribute_t*>cpython.long.PyLong_AsVoidPtr(ptr_as_int)
        elif cpython.buffer.PyObject_CheckBuffer(pyobj):
            err = cpython.buffer.PyObject_GetBuffer( 
                pyobj,
                &wrapper._py_buffer, 
                cpython.buffer.PyBUF_SIMPLE | cpython.buffer.PyBUF_ANY_CONTIGUOUS
            )
            if err == -1:
                raise RuntimeError("failed to create simple, contiguous Py_buffer from Python object")
            wrapper._py_buffer_acquired = True
            wrapper._ptr = <chip.hipPointerAttribute_t*>wrapper._py_buffer.buf
        else:
            raise TypeError(f"unsupported input type: '{str(type(pyobj))}'")
        return wrapper
    def __dealloc__(self):
        # Release the buffer handle
        if self._py_buffer_acquired is True:
            cpython.buffer.PyBuffer_Release(&self._py_buffer)
        # De-allocate if not null and flag is set
        if self._ptr is not NULL and self.ptr_owner is True:
            stdlib.free(self._ptr)
            self._ptr = NULL
    @staticmethod
    cdef __allocate(chip.hipPointerAttribute_t** ptr):
        ptr[0] = <chip.hipPointerAttribute_t*>stdlib.malloc(sizeof(chip.hipPointerAttribute_t))

        if ptr[0] is NULL:
            raise MemoryError
        # TODO init values, if present

    @staticmethod
    cdef hipPointerAttribute_t new():
        """Factory function to create hipPointerAttribute_t objects with
        newly allocated chip.hipPointerAttribute_t"""
        cdef chip.hipPointerAttribute_t* ptr
        hipPointerAttribute_t.__allocate(&ptr)
        return hipPointerAttribute_t.from_ptr(ptr, owner=True)
   
    def __init__(self,*args,**kwargs):
        hipPointerAttribute_t.__allocate(&self._ptr)
        self.ptr_owner = True
        attribs = self.PROPERTIES()
        used_attribs = set()
        if len(args) > len(attribs):
            raise ValueError("More positional arguments specified than this type has properties.")
        for i,v in enumerate(args):
            setattr(self,attribs[i],v)
            used_attribs.add(attribs[i])
        valid_names = ", ".join(["'"+p+"'" for p in attribs])
        for k,v in kwargs.items():
            if k in used_attribs:
                raise KeyError(f"argument '{k}' has already been specified as positional argument.")
            elif k not in attribs:
                raise KeyError(f"'{k}' is no valid property name. Valid names: {valid_names}")
            setattr(self,k,v)
    
    def __int__(self):
        """Returns the data's address as long integer."""
        return cpython.long.PyLong_FromVoidPtr(self._ptr)
    def __repr__(self):
        return f"<hipPointerAttribute_t object, self.ptr={int(self)}>"
    def as_c_void_p(self):
        """Returns the data's address as `ctypes.c_void_p`"""
        return ctypes.c_void_p(int(self))
    def get_memoryType(self, i):
        """Get value of ``memoryType`` of ``self._ptr[i]``.
        """
        return hipMemoryType(self._ptr[i].memoryType)
    def set_memoryType(self, i, value):
        """Set value ``memoryType`` of ``self._ptr[i]``.
        """
        if not isinstance(value, hipMemoryType):
            raise TypeError("'value' must be of type 'hipMemoryType'")
        self._ptr[i].memoryType = value.value
    @property
    def memoryType(self):
        return self.get_memoryType(0)
    @memoryType.setter
    def memoryType(self, value):
        self.set_memoryType(0,value)

    def get_device(self, i):
        """Get value ``device`` of ``self._ptr[i]``.
        """
        return self._ptr[i].device
    def set_device(self, i, int value):
        """Set value ``device`` of ``self._ptr[i]``.
        """
        self._ptr[i].device = value
    @property
    def device(self):
        return self.get_device(0)
    @device.setter
    def device(self, int value):
        self.set_device(0,value)

    def get_devicePointer(self, i):
        """Get value ``devicePointer`` of ``self._ptr[i]``.
        """
        return hip._util.types.DataHandle.from_ptr(self._ptr[i].devicePointer)
    def set_devicePointer(self, i, object value):
        """Set value ``devicePointer`` of ``self._ptr[i]``.

        Note:
            This can be dangerous if the pointer is from a python object
            that is later on garbage collected.
        """
        self._ptr[i].devicePointer = <void *>cpython.long.PyLong_AsVoidPtr(int(hip._util.types.DataHandle.from_pyobj(value)))
    @property
    def devicePointer(self):
        """
        Note:
            Setting this devicePointer can be dangerous if the underlying pointer is from a python object that
            is later on garbage collected.
        """
        return self.get_devicePointer(0)
    @devicePointer.setter
    def devicePointer(self, object value):
        self.set_devicePointer(0,value)

    def get_hostPointer(self, i):
        """Get value ``hostPointer`` of ``self._ptr[i]``.
        """
        return hip._util.types.DataHandle.from_ptr(self._ptr[i].hostPointer)
    def set_hostPointer(self, i, object value):
        """Set value ``hostPointer`` of ``self._ptr[i]``.

        Note:
            This can be dangerous if the pointer is from a python object
            that is later on garbage collected.
        """
        self._ptr[i].hostPointer = <void *>cpython.long.PyLong_AsVoidPtr(int(hip._util.types.DataHandle.from_pyobj(value)))
    @property
    def hostPointer(self):
        """
        Note:
            Setting this hostPointer can be dangerous if the underlying pointer is from a python object that
            is later on garbage collected.
        """
        return self.get_hostPointer(0)
    @hostPointer.setter
    def hostPointer(self, object value):
        self.set_hostPointer(0,value)

    def get_isManaged(self, i):
        """Get value ``isManaged`` of ``self._ptr[i]``.
        """
        return self._ptr[i].isManaged
    def set_isManaged(self, i, int value):
        """Set value ``isManaged`` of ``self._ptr[i]``.
        """
        self._ptr[i].isManaged = value
    @property
    def isManaged(self):
        return self.get_isManaged(0)
    @isManaged.setter
    def isManaged(self, int value):
        self.set_isManaged(0,value)

    def get_allocationFlags(self, i):
        """Get value ``allocationFlags`` of ``self._ptr[i]``.
        """
        return self._ptr[i].allocationFlags
    def set_allocationFlags(self, i, unsigned int value):
        """Set value ``allocationFlags`` of ``self._ptr[i]``.
        """
        self._ptr[i].allocationFlags = value
    @property
    def allocationFlags(self):
        return self.get_allocationFlags(0)
    @allocationFlags.setter
    def allocationFlags(self, unsigned int value):
        self.set_allocationFlags(0,value)

    @staticmethod
    def PROPERTIES():
        return ["memoryType","device","devicePointer","hostPointer","isManaged","allocationFlags"]

    def __contains__(self,item):
        properties = self.PROPERTIES()
        return item in properties

    def __getitem__(self,item):
        properties = self.PROPERTIES()
        if isinstance(item,int):
            if item < 0 or item >= len(properties):
                raise IndexError()
            return getattr(self,properties[item])
        raise ValueError("'item' type must be 'int'")


class _hipError_t__Base(enum.IntEnum):
    """Empty enum base class that allows subclassing.
    """
    pass
class hipError_t(_hipError_t__Base):
    hipSuccess = chip.hipSuccess
    hipErrorInvalidValue = chip.hipErrorInvalidValue
    hipErrorOutOfMemory = chip.hipErrorOutOfMemory
    hipErrorMemoryAllocation = chip.hipErrorMemoryAllocation
    hipErrorNotInitialized = chip.hipErrorNotInitialized
    hipErrorInitializationError = chip.hipErrorInitializationError
    hipErrorDeinitialized = chip.hipErrorDeinitialized
    hipErrorProfilerDisabled = chip.hipErrorProfilerDisabled
    hipErrorProfilerNotInitialized = chip.hipErrorProfilerNotInitialized
    hipErrorProfilerAlreadyStarted = chip.hipErrorProfilerAlreadyStarted
    hipErrorProfilerAlreadyStopped = chip.hipErrorProfilerAlreadyStopped
    hipErrorInvalidConfiguration = chip.hipErrorInvalidConfiguration
    hipErrorInvalidPitchValue = chip.hipErrorInvalidPitchValue
    hipErrorInvalidSymbol = chip.hipErrorInvalidSymbol
    hipErrorInvalidDevicePointer = chip.hipErrorInvalidDevicePointer
    hipErrorInvalidMemcpyDirection = chip.hipErrorInvalidMemcpyDirection
    hipErrorInsufficientDriver = chip.hipErrorInsufficientDriver
    hipErrorMissingConfiguration = chip.hipErrorMissingConfiguration
    hipErrorPriorLaunchFailure = chip.hipErrorPriorLaunchFailure
    hipErrorInvalidDeviceFunction = chip.hipErrorInvalidDeviceFunction
    hipErrorNoDevice = chip.hipErrorNoDevice
    hipErrorInvalidDevice = chip.hipErrorInvalidDevice
    hipErrorInvalidImage = chip.hipErrorInvalidImage
    hipErrorInvalidContext = chip.hipErrorInvalidContext
    hipErrorContextAlreadyCurrent = chip.hipErrorContextAlreadyCurrent
    hipErrorMapFailed = chip.hipErrorMapFailed
    hipErrorMapBufferObjectFailed = chip.hipErrorMapBufferObjectFailed
    hipErrorUnmapFailed = chip.hipErrorUnmapFailed
    hipErrorArrayIsMapped = chip.hipErrorArrayIsMapped
    hipErrorAlreadyMapped = chip.hipErrorAlreadyMapped
    hipErrorNoBinaryForGpu = chip.hipErrorNoBinaryForGpu
    hipErrorAlreadyAcquired = chip.hipErrorAlreadyAcquired
    hipErrorNotMapped = chip.hipErrorNotMapped
    hipErrorNotMappedAsArray = chip.hipErrorNotMappedAsArray
    hipErrorNotMappedAsPointer = chip.hipErrorNotMappedAsPointer
    hipErrorECCNotCorrectable = chip.hipErrorECCNotCorrectable
    hipErrorUnsupportedLimit = chip.hipErrorUnsupportedLimit
    hipErrorContextAlreadyInUse = chip.hipErrorContextAlreadyInUse
    hipErrorPeerAccessUnsupported = chip.hipErrorPeerAccessUnsupported
    hipErrorInvalidKernelFile = chip.hipErrorInvalidKernelFile
    hipErrorInvalidGraphicsContext = chip.hipErrorInvalidGraphicsContext
    hipErrorInvalidSource = chip.hipErrorInvalidSource
    hipErrorFileNotFound = chip.hipErrorFileNotFound
    hipErrorSharedObjectSymbolNotFound = chip.hipErrorSharedObjectSymbolNotFound
    hipErrorSharedObjectInitFailed = chip.hipErrorSharedObjectInitFailed
    hipErrorOperatingSystem = chip.hipErrorOperatingSystem
    hipErrorInvalidHandle = chip.hipErrorInvalidHandle
    hipErrorInvalidResourceHandle = chip.hipErrorInvalidResourceHandle
    hipErrorIllegalState = chip.hipErrorIllegalState
    hipErrorNotFound = chip.hipErrorNotFound
    hipErrorNotReady = chip.hipErrorNotReady
    hipErrorIllegalAddress = chip.hipErrorIllegalAddress
    hipErrorLaunchOutOfResources = chip.hipErrorLaunchOutOfResources
    hipErrorLaunchTimeOut = chip.hipErrorLaunchTimeOut
    hipErrorPeerAccessAlreadyEnabled = chip.hipErrorPeerAccessAlreadyEnabled
    hipErrorPeerAccessNotEnabled = chip.hipErrorPeerAccessNotEnabled
    hipErrorSetOnActiveProcess = chip.hipErrorSetOnActiveProcess
    hipErrorContextIsDestroyed = chip.hipErrorContextIsDestroyed
    hipErrorAssert = chip.hipErrorAssert
    hipErrorHostMemoryAlreadyRegistered = chip.hipErrorHostMemoryAlreadyRegistered
    hipErrorHostMemoryNotRegistered = chip.hipErrorHostMemoryNotRegistered
    hipErrorLaunchFailure = chip.hipErrorLaunchFailure
    hipErrorCooperativeLaunchTooLarge = chip.hipErrorCooperativeLaunchTooLarge
    hipErrorNotSupported = chip.hipErrorNotSupported
    hipErrorStreamCaptureUnsupported = chip.hipErrorStreamCaptureUnsupported
    hipErrorStreamCaptureInvalidated = chip.hipErrorStreamCaptureInvalidated
    hipErrorStreamCaptureMerge = chip.hipErrorStreamCaptureMerge
    hipErrorStreamCaptureUnmatched = chip.hipErrorStreamCaptureUnmatched
    hipErrorStreamCaptureUnjoined = chip.hipErrorStreamCaptureUnjoined
    hipErrorStreamCaptureIsolation = chip.hipErrorStreamCaptureIsolation
    hipErrorStreamCaptureImplicit = chip.hipErrorStreamCaptureImplicit
    hipErrorCapturedEvent = chip.hipErrorCapturedEvent
    hipErrorStreamCaptureWrongThread = chip.hipErrorStreamCaptureWrongThread
    hipErrorGraphExecUpdateFailure = chip.hipErrorGraphExecUpdateFailure
    hipErrorUnknown = chip.hipErrorUnknown
    hipErrorRuntimeMemory = chip.hipErrorRuntimeMemory
    hipErrorRuntimeOther = chip.hipErrorRuntimeOther
    hipErrorTbd = chip.hipErrorTbd
    @staticmethod
    def ctypes_type():
        """The type of the enum constants as ctypes type."""
        return ctypes.c_uint 


class _hipDeviceAttribute_t__Base(enum.IntEnum):
    """Empty enum base class that allows subclassing.
    """
    pass
class hipDeviceAttribute_t(_hipDeviceAttribute_t__Base):
    hipDeviceAttributeCudaCompatibleBegin = chip.hipDeviceAttributeCudaCompatibleBegin
    hipDeviceAttributeEccEnabled = chip.hipDeviceAttributeEccEnabled
    hipDeviceAttributeAccessPolicyMaxWindowSize = chip.hipDeviceAttributeAccessPolicyMaxWindowSize
    hipDeviceAttributeAsyncEngineCount = chip.hipDeviceAttributeAsyncEngineCount
    hipDeviceAttributeCanMapHostMemory = chip.hipDeviceAttributeCanMapHostMemory
    hipDeviceAttributeCanUseHostPointerForRegisteredMem = chip.hipDeviceAttributeCanUseHostPointerForRegisteredMem
    hipDeviceAttributeClockRate = chip.hipDeviceAttributeClockRate
    hipDeviceAttributeComputeMode = chip.hipDeviceAttributeComputeMode
    hipDeviceAttributeComputePreemptionSupported = chip.hipDeviceAttributeComputePreemptionSupported
    hipDeviceAttributeConcurrentKernels = chip.hipDeviceAttributeConcurrentKernels
    hipDeviceAttributeConcurrentManagedAccess = chip.hipDeviceAttributeConcurrentManagedAccess
    hipDeviceAttributeCooperativeLaunch = chip.hipDeviceAttributeCooperativeLaunch
    hipDeviceAttributeCooperativeMultiDeviceLaunch = chip.hipDeviceAttributeCooperativeMultiDeviceLaunch
    hipDeviceAttributeDeviceOverlap = chip.hipDeviceAttributeDeviceOverlap
    hipDeviceAttributeDirectManagedMemAccessFromHost = chip.hipDeviceAttributeDirectManagedMemAccessFromHost
    hipDeviceAttributeGlobalL1CacheSupported = chip.hipDeviceAttributeGlobalL1CacheSupported
    hipDeviceAttributeHostNativeAtomicSupported = chip.hipDeviceAttributeHostNativeAtomicSupported
    hipDeviceAttributeIntegrated = chip.hipDeviceAttributeIntegrated
    hipDeviceAttributeIsMultiGpuBoard = chip.hipDeviceAttributeIsMultiGpuBoard
    hipDeviceAttributeKernelExecTimeout = chip.hipDeviceAttributeKernelExecTimeout
    hipDeviceAttributeL2CacheSize = chip.hipDeviceAttributeL2CacheSize
    hipDeviceAttributeLocalL1CacheSupported = chip.hipDeviceAttributeLocalL1CacheSupported
    hipDeviceAttributeLuid = chip.hipDeviceAttributeLuid
    hipDeviceAttributeLuidDeviceNodeMask = chip.hipDeviceAttributeLuidDeviceNodeMask
    hipDeviceAttributeComputeCapabilityMajor = chip.hipDeviceAttributeComputeCapabilityMajor
    hipDeviceAttributeManagedMemory = chip.hipDeviceAttributeManagedMemory
    hipDeviceAttributeMaxBlocksPerMultiProcessor = chip.hipDeviceAttributeMaxBlocksPerMultiProcessor
    hipDeviceAttributeMaxBlockDimX = chip.hipDeviceAttributeMaxBlockDimX
    hipDeviceAttributeMaxBlockDimY = chip.hipDeviceAttributeMaxBlockDimY
    hipDeviceAttributeMaxBlockDimZ = chip.hipDeviceAttributeMaxBlockDimZ
    hipDeviceAttributeMaxGridDimX = chip.hipDeviceAttributeMaxGridDimX
    hipDeviceAttributeMaxGridDimY = chip.hipDeviceAttributeMaxGridDimY
    hipDeviceAttributeMaxGridDimZ = chip.hipDeviceAttributeMaxGridDimZ
    hipDeviceAttributeMaxSurface1D = chip.hipDeviceAttributeMaxSurface1D
    hipDeviceAttributeMaxSurface1DLayered = chip.hipDeviceAttributeMaxSurface1DLayered
    hipDeviceAttributeMaxSurface2D = chip.hipDeviceAttributeMaxSurface2D
    hipDeviceAttributeMaxSurface2DLayered = chip.hipDeviceAttributeMaxSurface2DLayered
    hipDeviceAttributeMaxSurface3D = chip.hipDeviceAttributeMaxSurface3D
    hipDeviceAttributeMaxSurfaceCubemap = chip.hipDeviceAttributeMaxSurfaceCubemap
    hipDeviceAttributeMaxSurfaceCubemapLayered = chip.hipDeviceAttributeMaxSurfaceCubemapLayered
    hipDeviceAttributeMaxTexture1DWidth = chip.hipDeviceAttributeMaxTexture1DWidth
    hipDeviceAttributeMaxTexture1DLayered = chip.hipDeviceAttributeMaxTexture1DLayered
    hipDeviceAttributeMaxTexture1DLinear = chip.hipDeviceAttributeMaxTexture1DLinear
    hipDeviceAttributeMaxTexture1DMipmap = chip.hipDeviceAttributeMaxTexture1DMipmap
    hipDeviceAttributeMaxTexture2DWidth = chip.hipDeviceAttributeMaxTexture2DWidth
    hipDeviceAttributeMaxTexture2DHeight = chip.hipDeviceAttributeMaxTexture2DHeight
    hipDeviceAttributeMaxTexture2DGather = chip.hipDeviceAttributeMaxTexture2DGather
    hipDeviceAttributeMaxTexture2DLayered = chip.hipDeviceAttributeMaxTexture2DLayered
    hipDeviceAttributeMaxTexture2DLinear = chip.hipDeviceAttributeMaxTexture2DLinear
    hipDeviceAttributeMaxTexture2DMipmap = chip.hipDeviceAttributeMaxTexture2DMipmap
    hipDeviceAttributeMaxTexture3DWidth = chip.hipDeviceAttributeMaxTexture3DWidth
    hipDeviceAttributeMaxTexture3DHeight = chip.hipDeviceAttributeMaxTexture3DHeight
    hipDeviceAttributeMaxTexture3DDepth = chip.hipDeviceAttributeMaxTexture3DDepth
    hipDeviceAttributeMaxTexture3DAlt = chip.hipDeviceAttributeMaxTexture3DAlt
    hipDeviceAttributeMaxTextureCubemap = chip.hipDeviceAttributeMaxTextureCubemap
    hipDeviceAttributeMaxTextureCubemapLayered = chip.hipDeviceAttributeMaxTextureCubemapLayered
    hipDeviceAttributeMaxThreadsDim = chip.hipDeviceAttributeMaxThreadsDim
    hipDeviceAttributeMaxThreadsPerBlock = chip.hipDeviceAttributeMaxThreadsPerBlock
    hipDeviceAttributeMaxThreadsPerMultiProcessor = chip.hipDeviceAttributeMaxThreadsPerMultiProcessor
    hipDeviceAttributeMaxPitch = chip.hipDeviceAttributeMaxPitch
    hipDeviceAttributeMemoryBusWidth = chip.hipDeviceAttributeMemoryBusWidth
    hipDeviceAttributeMemoryClockRate = chip.hipDeviceAttributeMemoryClockRate
    hipDeviceAttributeComputeCapabilityMinor = chip.hipDeviceAttributeComputeCapabilityMinor
    hipDeviceAttributeMultiGpuBoardGroupID = chip.hipDeviceAttributeMultiGpuBoardGroupID
    hipDeviceAttributeMultiprocessorCount = chip.hipDeviceAttributeMultiprocessorCount
    hipDeviceAttributeName = chip.hipDeviceAttributeName
    hipDeviceAttributePageableMemoryAccess = chip.hipDeviceAttributePageableMemoryAccess
    hipDeviceAttributePageableMemoryAccessUsesHostPageTables = chip.hipDeviceAttributePageableMemoryAccessUsesHostPageTables
    hipDeviceAttributePciBusId = chip.hipDeviceAttributePciBusId
    hipDeviceAttributePciDeviceId = chip.hipDeviceAttributePciDeviceId
    hipDeviceAttributePciDomainID = chip.hipDeviceAttributePciDomainID
    hipDeviceAttributePersistingL2CacheMaxSize = chip.hipDeviceAttributePersistingL2CacheMaxSize
    hipDeviceAttributeMaxRegistersPerBlock = chip.hipDeviceAttributeMaxRegistersPerBlock
    hipDeviceAttributeMaxRegistersPerMultiprocessor = chip.hipDeviceAttributeMaxRegistersPerMultiprocessor
    hipDeviceAttributeReservedSharedMemPerBlock = chip.hipDeviceAttributeReservedSharedMemPerBlock
    hipDeviceAttributeMaxSharedMemoryPerBlock = chip.hipDeviceAttributeMaxSharedMemoryPerBlock
    hipDeviceAttributeSharedMemPerBlockOptin = chip.hipDeviceAttributeSharedMemPerBlockOptin
    hipDeviceAttributeSharedMemPerMultiprocessor = chip.hipDeviceAttributeSharedMemPerMultiprocessor
    hipDeviceAttributeSingleToDoublePrecisionPerfRatio = chip.hipDeviceAttributeSingleToDoublePrecisionPerfRatio
    hipDeviceAttributeStreamPrioritiesSupported = chip.hipDeviceAttributeStreamPrioritiesSupported
    hipDeviceAttributeSurfaceAlignment = chip.hipDeviceAttributeSurfaceAlignment
    hipDeviceAttributeTccDriver = chip.hipDeviceAttributeTccDriver
    hipDeviceAttributeTextureAlignment = chip.hipDeviceAttributeTextureAlignment
    hipDeviceAttributeTexturePitchAlignment = chip.hipDeviceAttributeTexturePitchAlignment
    hipDeviceAttributeTotalConstantMemory = chip.hipDeviceAttributeTotalConstantMemory
    hipDeviceAttributeTotalGlobalMem = chip.hipDeviceAttributeTotalGlobalMem
    hipDeviceAttributeUnifiedAddressing = chip.hipDeviceAttributeUnifiedAddressing
    hipDeviceAttributeUuid = chip.hipDeviceAttributeUuid
    hipDeviceAttributeWarpSize = chip.hipDeviceAttributeWarpSize
    hipDeviceAttributeMemoryPoolsSupported = chip.hipDeviceAttributeMemoryPoolsSupported
    hipDeviceAttributeVirtualMemoryManagementSupported = chip.hipDeviceAttributeVirtualMemoryManagementSupported
    hipDeviceAttributeCudaCompatibleEnd = chip.hipDeviceAttributeCudaCompatibleEnd
    hipDeviceAttributeAmdSpecificBegin = chip.hipDeviceAttributeAmdSpecificBegin
    hipDeviceAttributeClockInstructionRate = chip.hipDeviceAttributeClockInstructionRate
    hipDeviceAttributeArch = chip.hipDeviceAttributeArch
    hipDeviceAttributeMaxSharedMemoryPerMultiprocessor = chip.hipDeviceAttributeMaxSharedMemoryPerMultiprocessor
    hipDeviceAttributeGcnArch = chip.hipDeviceAttributeGcnArch
    hipDeviceAttributeGcnArchName = chip.hipDeviceAttributeGcnArchName
    hipDeviceAttributeHdpMemFlushCntl = chip.hipDeviceAttributeHdpMemFlushCntl
    hipDeviceAttributeHdpRegFlushCntl = chip.hipDeviceAttributeHdpRegFlushCntl
    hipDeviceAttributeCooperativeMultiDeviceUnmatchedFunc = chip.hipDeviceAttributeCooperativeMultiDeviceUnmatchedFunc
    hipDeviceAttributeCooperativeMultiDeviceUnmatchedGridDim = chip.hipDeviceAttributeCooperativeMultiDeviceUnmatchedGridDim
    hipDeviceAttributeCooperativeMultiDeviceUnmatchedBlockDim = chip.hipDeviceAttributeCooperativeMultiDeviceUnmatchedBlockDim
    hipDeviceAttributeCooperativeMultiDeviceUnmatchedSharedMem = chip.hipDeviceAttributeCooperativeMultiDeviceUnmatchedSharedMem
    hipDeviceAttributeIsLargeBar = chip.hipDeviceAttributeIsLargeBar
    hipDeviceAttributeAsicRevision = chip.hipDeviceAttributeAsicRevision
    hipDeviceAttributeCanUseStreamWaitValue = chip.hipDeviceAttributeCanUseStreamWaitValue
    hipDeviceAttributeImageSupport = chip.hipDeviceAttributeImageSupport
    hipDeviceAttributePhysicalMultiProcessorCount = chip.hipDeviceAttributePhysicalMultiProcessorCount
    hipDeviceAttributeFineGrainSupport = chip.hipDeviceAttributeFineGrainSupport
    hipDeviceAttributeWallClockRate = chip.hipDeviceAttributeWallClockRate
    hipDeviceAttributeAmdSpecificEnd = chip.hipDeviceAttributeAmdSpecificEnd
    hipDeviceAttributeVendorSpecificBegin = chip.hipDeviceAttributeVendorSpecificBegin
    @staticmethod
    def ctypes_type():
        """The type of the enum constants as ctypes type."""
        return ctypes.c_uint 


class _hipComputeMode__Base(enum.IntEnum):
    """Empty enum base class that allows subclassing.
    """
    pass
class hipComputeMode(_hipComputeMode__Base):
    hipComputeModeDefault = chip.hipComputeModeDefault
    hipComputeModeExclusive = chip.hipComputeModeExclusive
    hipComputeModeProhibited = chip.hipComputeModeProhibited
    hipComputeModeExclusiveProcess = chip.hipComputeModeExclusiveProcess
    @staticmethod
    def ctypes_type():
        """The type of the enum constants as ctypes type."""
        return ctypes.c_uint 


class _hipChannelFormatKind__Base(enum.IntEnum):
    """Empty enum base class that allows subclassing.
    """
    pass
class hipChannelFormatKind(_hipChannelFormatKind__Base):
    hipChannelFormatKindSigned = chip.hipChannelFormatKindSigned
    hipChannelFormatKindUnsigned = chip.hipChannelFormatKindUnsigned
    hipChannelFormatKindFloat = chip.hipChannelFormatKindFloat
    hipChannelFormatKindNone = chip.hipChannelFormatKindNone
    @staticmethod
    def ctypes_type():
        """The type of the enum constants as ctypes type."""
        return ctypes.c_uint 


cdef class hipChannelFormatDesc:
    # members declared in pxd file

    def __cinit__(self):
        self._ptr = NULL
        self.ptr_owner = False
        self._py_buffer_acquired = False

    @staticmethod
    cdef hipChannelFormatDesc from_ptr(chip.hipChannelFormatDesc* ptr, bint owner=False):
        """Factory function to create ``hipChannelFormatDesc`` objects from
        given ``chip.hipChannelFormatDesc`` pointer.

        Setting ``owner`` flag to ``True`` causes
        the extension type to ``free`` the structure pointed to by ``ptr``
        when the wrapper object is deallocated.
        """
        # Fast call to __new__() that bypasses the __init__() constructor.
        cdef hipChannelFormatDesc wrapper = hipChannelFormatDesc.__new__(hipChannelFormatDesc)
        wrapper._ptr = ptr
        wrapper.ptr_owner = owner
        return wrapper

    @staticmethod
    cdef hipChannelFormatDesc from_pyobj(object pyobj):
        """Derives a hipChannelFormatDesc from a Python object.

        Derives a hipChannelFormatDesc from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``hipChannelFormatDesc`` reference, this method
        returns it directly. No new ``hipChannelFormatDesc`` is created in this case.

        Args:
            pyobj (object): Must be either ``None``, a simple, contiguous buffer according to the buffer protocol,
                            or of type ``hipChannelFormatDesc``, ``int``, or ``ctypes.c_void_p``

        Note:
            This routine does not perform a copy but returns the original ``pyobj``
            if ``pyobj`` is an instance of hipChannelFormatDesc!
        """
        cdef hipChannelFormatDesc wrapper = hipChannelFormatDesc.__new__(hipChannelFormatDesc)
        cdef dict cuda_array_interface = getattr(pyobj, "__cuda_array_interface__", None)

        if pyobj is None:
            wrapper._ptr = NULL
        elif isinstance(pyobj,hipChannelFormatDesc):
            return pyobj
        elif isinstance(pyobj,int):
            wrapper._ptr = <chip.hipChannelFormatDesc*>cpython.long.PyLong_AsVoidPtr(pyobj)
        elif isinstance(pyobj,ctypes.c_void_p):
            wrapper._ptr = <chip.hipChannelFormatDesc*>cpython.long.PyLong_AsVoidPtr(pyobj.value) if pyobj.value != None else NULL
        elif cuda_array_interface != None:
            if not "data" in cuda_array_interface:
                raise ValueError("input object has '__cuda_array_interface__' attribute but the dict has no 'data' key")
            ptr_as_int = cuda_array_interface["data"][0]
            wrapper._ptr = <chip.hipChannelFormatDesc*>cpython.long.PyLong_AsVoidPtr(ptr_as_int)
        elif cpython.buffer.PyObject_CheckBuffer(pyobj):
            err = cpython.buffer.PyObject_GetBuffer( 
                pyobj,
                &wrapper._py_buffer, 
                cpython.buffer.PyBUF_SIMPLE | cpython.buffer.PyBUF_ANY_CONTIGUOUS
            )
            if err == -1:
                raise RuntimeError("failed to create simple, contiguous Py_buffer from Python object")
            wrapper._py_buffer_acquired = True
            wrapper._ptr = <chip.hipChannelFormatDesc*>wrapper._py_buffer.buf
        else:
            raise TypeError(f"unsupported input type: '{str(type(pyobj))}'")
        return wrapper
    def __dealloc__(self):
        # Release the buffer handle
        if self._py_buffer_acquired is True:
            cpython.buffer.PyBuffer_Release(&self._py_buffer)
        # De-allocate if not null and flag is set
        if self._ptr is not NULL and self.ptr_owner is True:
            stdlib.free(self._ptr)
            self._ptr = NULL
    @staticmethod
    cdef __allocate(chip.hipChannelFormatDesc** ptr):
        ptr[0] = <chip.hipChannelFormatDesc*>stdlib.malloc(sizeof(chip.hipChannelFormatDesc))

        if ptr[0] is NULL:
            raise MemoryError
        # TODO init values, if present

    @staticmethod
    cdef hipChannelFormatDesc new():
        """Factory function to create hipChannelFormatDesc objects with
        newly allocated chip.hipChannelFormatDesc"""
        cdef chip.hipChannelFormatDesc* ptr
        hipChannelFormatDesc.__allocate(&ptr)
        return hipChannelFormatDesc.from_ptr(ptr, owner=True)
   
    def __init__(self,*args,**kwargs):
        hipChannelFormatDesc.__allocate(&self._ptr)
        self.ptr_owner = True
        attribs = self.PROPERTIES()
        used_attribs = set()
        if len(args) > len(attribs):
            raise ValueError("More positional arguments specified than this type has properties.")
        for i,v in enumerate(args):
            setattr(self,attribs[i],v)
            used_attribs.add(attribs[i])
        valid_names = ", ".join(["'"+p+"'" for p in attribs])
        for k,v in kwargs.items():
            if k in used_attribs:
                raise KeyError(f"argument '{k}' has already been specified as positional argument.")
            elif k not in attribs:
                raise KeyError(f"'{k}' is no valid property name. Valid names: {valid_names}")
            setattr(self,k,v)
    
    def __int__(self):
        """Returns the data's address as long integer."""
        return cpython.long.PyLong_FromVoidPtr(self._ptr)
    def __repr__(self):
        return f"<hipChannelFormatDesc object, self.ptr={int(self)}>"
    def as_c_void_p(self):
        """Returns the data's address as `ctypes.c_void_p`"""
        return ctypes.c_void_p(int(self))
    def get_x(self, i):
        """Get value ``x`` of ``self._ptr[i]``.
        """
        return self._ptr[i].x
    def set_x(self, i, int value):
        """Set value ``x`` of ``self._ptr[i]``.
        """
        self._ptr[i].x = value
    @property
    def x(self):
        return self.get_x(0)
    @x.setter
    def x(self, int value):
        self.set_x(0,value)

    def get_y(self, i):
        """Get value ``y`` of ``self._ptr[i]``.
        """
        return self._ptr[i].y
    def set_y(self, i, int value):
        """Set value ``y`` of ``self._ptr[i]``.
        """
        self._ptr[i].y = value
    @property
    def y(self):
        return self.get_y(0)
    @y.setter
    def y(self, int value):
        self.set_y(0,value)

    def get_z(self, i):
        """Get value ``z`` of ``self._ptr[i]``.
        """
        return self._ptr[i].z
    def set_z(self, i, int value):
        """Set value ``z`` of ``self._ptr[i]``.
        """
        self._ptr[i].z = value
    @property
    def z(self):
        return self.get_z(0)
    @z.setter
    def z(self, int value):
        self.set_z(0,value)

    def get_w(self, i):
        """Get value ``w`` of ``self._ptr[i]``.
        """
        return self._ptr[i].w
    def set_w(self, i, int value):
        """Set value ``w`` of ``self._ptr[i]``.
        """
        self._ptr[i].w = value
    @property
    def w(self):
        return self.get_w(0)
    @w.setter
    def w(self, int value):
        self.set_w(0,value)

    def get_f(self, i):
        """Get value of ``f`` of ``self._ptr[i]``.
        """
        return hipChannelFormatKind(self._ptr[i].f)
    def set_f(self, i, value):
        """Set value ``f`` of ``self._ptr[i]``.
        """
        if not isinstance(value, hipChannelFormatKind):
            raise TypeError("'value' must be of type 'hipChannelFormatKind'")
        self._ptr[i].f = value.value
    @property
    def f(self):
        return self.get_f(0)
    @f.setter
    def f(self, value):
        self.set_f(0,value)

    @staticmethod
    def PROPERTIES():
        return ["x","y","z","w","f"]

    def __contains__(self,item):
        properties = self.PROPERTIES()
        return item in properties

    def __getitem__(self,item):
        properties = self.PROPERTIES()
        if isinstance(item,int):
            if item < 0 or item >= len(properties):
                raise IndexError()
            return getattr(self,properties[item])
        raise ValueError("'item' type must be 'int'")


class _hipArray_Format__Base(enum.IntEnum):
    """Empty enum base class that allows subclassing.
    """
    pass
class hipArray_Format(_hipArray_Format__Base):
    HIP_AD_FORMAT_UNSIGNED_INT8 = chip.HIP_AD_FORMAT_UNSIGNED_INT8
    HIP_AD_FORMAT_UNSIGNED_INT16 = chip.HIP_AD_FORMAT_UNSIGNED_INT16
    HIP_AD_FORMAT_UNSIGNED_INT32 = chip.HIP_AD_FORMAT_UNSIGNED_INT32
    HIP_AD_FORMAT_SIGNED_INT8 = chip.HIP_AD_FORMAT_SIGNED_INT8
    HIP_AD_FORMAT_SIGNED_INT16 = chip.HIP_AD_FORMAT_SIGNED_INT16
    HIP_AD_FORMAT_SIGNED_INT32 = chip.HIP_AD_FORMAT_SIGNED_INT32
    HIP_AD_FORMAT_HALF = chip.HIP_AD_FORMAT_HALF
    HIP_AD_FORMAT_FLOAT = chip.HIP_AD_FORMAT_FLOAT
    @staticmethod
    def ctypes_type():
        """The type of the enum constants as ctypes type."""
        return ctypes.c_uint 


cdef class HIP_ARRAY_DESCRIPTOR:
    # members declared in pxd file

    def __cinit__(self):
        self._ptr = NULL
        self.ptr_owner = False
        self._py_buffer_acquired = False

    @staticmethod
    cdef HIP_ARRAY_DESCRIPTOR from_ptr(chip.HIP_ARRAY_DESCRIPTOR* ptr, bint owner=False):
        """Factory function to create ``HIP_ARRAY_DESCRIPTOR`` objects from
        given ``chip.HIP_ARRAY_DESCRIPTOR`` pointer.

        Setting ``owner`` flag to ``True`` causes
        the extension type to ``free`` the structure pointed to by ``ptr``
        when the wrapper object is deallocated.
        """
        # Fast call to __new__() that bypasses the __init__() constructor.
        cdef HIP_ARRAY_DESCRIPTOR wrapper = HIP_ARRAY_DESCRIPTOR.__new__(HIP_ARRAY_DESCRIPTOR)
        wrapper._ptr = ptr
        wrapper.ptr_owner = owner
        return wrapper

    @staticmethod
    cdef HIP_ARRAY_DESCRIPTOR from_pyobj(object pyobj):
        """Derives a HIP_ARRAY_DESCRIPTOR from a Python object.

        Derives a HIP_ARRAY_DESCRIPTOR from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``HIP_ARRAY_DESCRIPTOR`` reference, this method
        returns it directly. No new ``HIP_ARRAY_DESCRIPTOR`` is created in this case.

        Args:
            pyobj (object): Must be either ``None``, a simple, contiguous buffer according to the buffer protocol,
                            or of type ``HIP_ARRAY_DESCRIPTOR``, ``int``, or ``ctypes.c_void_p``

        Note:
            This routine does not perform a copy but returns the original ``pyobj``
            if ``pyobj`` is an instance of HIP_ARRAY_DESCRIPTOR!
        """
        cdef HIP_ARRAY_DESCRIPTOR wrapper = HIP_ARRAY_DESCRIPTOR.__new__(HIP_ARRAY_DESCRIPTOR)
        cdef dict cuda_array_interface = getattr(pyobj, "__cuda_array_interface__", None)

        if pyobj is None:
            wrapper._ptr = NULL
        elif isinstance(pyobj,HIP_ARRAY_DESCRIPTOR):
            return pyobj
        elif isinstance(pyobj,int):
            wrapper._ptr = <chip.HIP_ARRAY_DESCRIPTOR*>cpython.long.PyLong_AsVoidPtr(pyobj)
        elif isinstance(pyobj,ctypes.c_void_p):
            wrapper._ptr = <chip.HIP_ARRAY_DESCRIPTOR*>cpython.long.PyLong_AsVoidPtr(pyobj.value) if pyobj.value != None else NULL
        elif cuda_array_interface != None:
            if not "data" in cuda_array_interface:
                raise ValueError("input object has '__cuda_array_interface__' attribute but the dict has no 'data' key")
            ptr_as_int = cuda_array_interface["data"][0]
            wrapper._ptr = <chip.HIP_ARRAY_DESCRIPTOR*>cpython.long.PyLong_AsVoidPtr(ptr_as_int)
        elif cpython.buffer.PyObject_CheckBuffer(pyobj):
            err = cpython.buffer.PyObject_GetBuffer( 
                pyobj,
                &wrapper._py_buffer, 
                cpython.buffer.PyBUF_SIMPLE | cpython.buffer.PyBUF_ANY_CONTIGUOUS
            )
            if err == -1:
                raise RuntimeError("failed to create simple, contiguous Py_buffer from Python object")
            wrapper._py_buffer_acquired = True
            wrapper._ptr = <chip.HIP_ARRAY_DESCRIPTOR*>wrapper._py_buffer.buf
        else:
            raise TypeError(f"unsupported input type: '{str(type(pyobj))}'")
        return wrapper
    def __dealloc__(self):
        # Release the buffer handle
        if self._py_buffer_acquired is True:
            cpython.buffer.PyBuffer_Release(&self._py_buffer)
        # De-allocate if not null and flag is set
        if self._ptr is not NULL and self.ptr_owner is True:
            stdlib.free(self._ptr)
            self._ptr = NULL
    @staticmethod
    cdef __allocate(chip.HIP_ARRAY_DESCRIPTOR** ptr):
        ptr[0] = <chip.HIP_ARRAY_DESCRIPTOR*>stdlib.malloc(sizeof(chip.HIP_ARRAY_DESCRIPTOR))

        if ptr[0] is NULL:
            raise MemoryError
        # TODO init values, if present

    @staticmethod
    cdef HIP_ARRAY_DESCRIPTOR new():
        """Factory function to create HIP_ARRAY_DESCRIPTOR objects with
        newly allocated chip.HIP_ARRAY_DESCRIPTOR"""
        cdef chip.HIP_ARRAY_DESCRIPTOR* ptr
        HIP_ARRAY_DESCRIPTOR.__allocate(&ptr)
        return HIP_ARRAY_DESCRIPTOR.from_ptr(ptr, owner=True)
   
    def __init__(self,*args,**kwargs):
        HIP_ARRAY_DESCRIPTOR.__allocate(&self._ptr)
        self.ptr_owner = True
        attribs = self.PROPERTIES()
        used_attribs = set()
        if len(args) > len(attribs):
            raise ValueError("More positional arguments specified than this type has properties.")
        for i,v in enumerate(args):
            setattr(self,attribs[i],v)
            used_attribs.add(attribs[i])
        valid_names = ", ".join(["'"+p+"'" for p in attribs])
        for k,v in kwargs.items():
            if k in used_attribs:
                raise KeyError(f"argument '{k}' has already been specified as positional argument.")
            elif k not in attribs:
                raise KeyError(f"'{k}' is no valid property name. Valid names: {valid_names}")
            setattr(self,k,v)
    
    def __int__(self):
        """Returns the data's address as long integer."""
        return cpython.long.PyLong_FromVoidPtr(self._ptr)
    def __repr__(self):
        return f"<HIP_ARRAY_DESCRIPTOR object, self.ptr={int(self)}>"
    def as_c_void_p(self):
        """Returns the data's address as `ctypes.c_void_p`"""
        return ctypes.c_void_p(int(self))
    def get_Width(self, i):
        """Get value ``Width`` of ``self._ptr[i]``.
        """
        return self._ptr[i].Width
    def set_Width(self, i, unsigned long value):
        """Set value ``Width`` of ``self._ptr[i]``.
        """
        self._ptr[i].Width = value
    @property
    def Width(self):
        return self.get_Width(0)
    @Width.setter
    def Width(self, unsigned long value):
        self.set_Width(0,value)

    def get_Height(self, i):
        """Get value ``Height`` of ``self._ptr[i]``.
        """
        return self._ptr[i].Height
    def set_Height(self, i, unsigned long value):
        """Set value ``Height`` of ``self._ptr[i]``.
        """
        self._ptr[i].Height = value
    @property
    def Height(self):
        return self.get_Height(0)
    @Height.setter
    def Height(self, unsigned long value):
        self.set_Height(0,value)

    def get_Format(self, i):
        """Get value of ``Format`` of ``self._ptr[i]``.
        """
        return hipArray_Format(self._ptr[i].Format)
    def set_Format(self, i, value):
        """Set value ``Format`` of ``self._ptr[i]``.
        """
        if not isinstance(value, hipArray_Format):
            raise TypeError("'value' must be of type 'hipArray_Format'")
        self._ptr[i].Format = value.value
    @property
    def Format(self):
        return self.get_Format(0)
    @Format.setter
    def Format(self, value):
        self.set_Format(0,value)

    def get_NumChannels(self, i):
        """Get value ``NumChannels`` of ``self._ptr[i]``.
        """
        return self._ptr[i].NumChannels
    def set_NumChannels(self, i, unsigned int value):
        """Set value ``NumChannels`` of ``self._ptr[i]``.
        """
        self._ptr[i].NumChannels = value
    @property
    def NumChannels(self):
        return self.get_NumChannels(0)
    @NumChannels.setter
    def NumChannels(self, unsigned int value):
        self.set_NumChannels(0,value)

    @staticmethod
    def PROPERTIES():
        return ["Width","Height","Format","NumChannels"]

    def __contains__(self,item):
        properties = self.PROPERTIES()
        return item in properties

    def __getitem__(self,item):
        properties = self.PROPERTIES()
        if isinstance(item,int):
            if item < 0 or item >= len(properties):
                raise IndexError()
            return getattr(self,properties[item])
        raise ValueError("'item' type must be 'int'")


cdef class HIP_ARRAY3D_DESCRIPTOR:
    # members declared in pxd file

    def __cinit__(self):
        self._ptr = NULL
        self.ptr_owner = False
        self._py_buffer_acquired = False

    @staticmethod
    cdef HIP_ARRAY3D_DESCRIPTOR from_ptr(chip.HIP_ARRAY3D_DESCRIPTOR* ptr, bint owner=False):
        """Factory function to create ``HIP_ARRAY3D_DESCRIPTOR`` objects from
        given ``chip.HIP_ARRAY3D_DESCRIPTOR`` pointer.

        Setting ``owner`` flag to ``True`` causes
        the extension type to ``free`` the structure pointed to by ``ptr``
        when the wrapper object is deallocated.
        """
        # Fast call to __new__() that bypasses the __init__() constructor.
        cdef HIP_ARRAY3D_DESCRIPTOR wrapper = HIP_ARRAY3D_DESCRIPTOR.__new__(HIP_ARRAY3D_DESCRIPTOR)
        wrapper._ptr = ptr
        wrapper.ptr_owner = owner
        return wrapper

    @staticmethod
    cdef HIP_ARRAY3D_DESCRIPTOR from_pyobj(object pyobj):
        """Derives a HIP_ARRAY3D_DESCRIPTOR from a Python object.

        Derives a HIP_ARRAY3D_DESCRIPTOR from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``HIP_ARRAY3D_DESCRIPTOR`` reference, this method
        returns it directly. No new ``HIP_ARRAY3D_DESCRIPTOR`` is created in this case.

        Args:
            pyobj (object): Must be either ``None``, a simple, contiguous buffer according to the buffer protocol,
                            or of type ``HIP_ARRAY3D_DESCRIPTOR``, ``int``, or ``ctypes.c_void_p``

        Note:
            This routine does not perform a copy but returns the original ``pyobj``
            if ``pyobj`` is an instance of HIP_ARRAY3D_DESCRIPTOR!
        """
        cdef HIP_ARRAY3D_DESCRIPTOR wrapper = HIP_ARRAY3D_DESCRIPTOR.__new__(HIP_ARRAY3D_DESCRIPTOR)
        cdef dict cuda_array_interface = getattr(pyobj, "__cuda_array_interface__", None)

        if pyobj is None:
            wrapper._ptr = NULL
        elif isinstance(pyobj,HIP_ARRAY3D_DESCRIPTOR):
            return pyobj
        elif isinstance(pyobj,int):
            wrapper._ptr = <chip.HIP_ARRAY3D_DESCRIPTOR*>cpython.long.PyLong_AsVoidPtr(pyobj)
        elif isinstance(pyobj,ctypes.c_void_p):
            wrapper._ptr = <chip.HIP_ARRAY3D_DESCRIPTOR*>cpython.long.PyLong_AsVoidPtr(pyobj.value) if pyobj.value != None else NULL
        elif cuda_array_interface != None:
            if not "data" in cuda_array_interface:
                raise ValueError("input object has '__cuda_array_interface__' attribute but the dict has no 'data' key")
            ptr_as_int = cuda_array_interface["data"][0]
            wrapper._ptr = <chip.HIP_ARRAY3D_DESCRIPTOR*>cpython.long.PyLong_AsVoidPtr(ptr_as_int)
        elif cpython.buffer.PyObject_CheckBuffer(pyobj):
            err = cpython.buffer.PyObject_GetBuffer( 
                pyobj,
                &wrapper._py_buffer, 
                cpython.buffer.PyBUF_SIMPLE | cpython.buffer.PyBUF_ANY_CONTIGUOUS
            )
            if err == -1:
                raise RuntimeError("failed to create simple, contiguous Py_buffer from Python object")
            wrapper._py_buffer_acquired = True
            wrapper._ptr = <chip.HIP_ARRAY3D_DESCRIPTOR*>wrapper._py_buffer.buf
        else:
            raise TypeError(f"unsupported input type: '{str(type(pyobj))}'")
        return wrapper
    def __dealloc__(self):
        # Release the buffer handle
        if self._py_buffer_acquired is True:
            cpython.buffer.PyBuffer_Release(&self._py_buffer)
        # De-allocate if not null and flag is set
        if self._ptr is not NULL and self.ptr_owner is True:
            stdlib.free(self._ptr)
            self._ptr = NULL
    @staticmethod
    cdef __allocate(chip.HIP_ARRAY3D_DESCRIPTOR** ptr):
        ptr[0] = <chip.HIP_ARRAY3D_DESCRIPTOR*>stdlib.malloc(sizeof(chip.HIP_ARRAY3D_DESCRIPTOR))

        if ptr[0] is NULL:
            raise MemoryError
        # TODO init values, if present

    @staticmethod
    cdef HIP_ARRAY3D_DESCRIPTOR new():
        """Factory function to create HIP_ARRAY3D_DESCRIPTOR objects with
        newly allocated chip.HIP_ARRAY3D_DESCRIPTOR"""
        cdef chip.HIP_ARRAY3D_DESCRIPTOR* ptr
        HIP_ARRAY3D_DESCRIPTOR.__allocate(&ptr)
        return HIP_ARRAY3D_DESCRIPTOR.from_ptr(ptr, owner=True)
   
    def __init__(self,*args,**kwargs):
        HIP_ARRAY3D_DESCRIPTOR.__allocate(&self._ptr)
        self.ptr_owner = True
        attribs = self.PROPERTIES()
        used_attribs = set()
        if len(args) > len(attribs):
            raise ValueError("More positional arguments specified than this type has properties.")
        for i,v in enumerate(args):
            setattr(self,attribs[i],v)
            used_attribs.add(attribs[i])
        valid_names = ", ".join(["'"+p+"'" for p in attribs])
        for k,v in kwargs.items():
            if k in used_attribs:
                raise KeyError(f"argument '{k}' has already been specified as positional argument.")
            elif k not in attribs:
                raise KeyError(f"'{k}' is no valid property name. Valid names: {valid_names}")
            setattr(self,k,v)
    
    def __int__(self):
        """Returns the data's address as long integer."""
        return cpython.long.PyLong_FromVoidPtr(self._ptr)
    def __repr__(self):
        return f"<HIP_ARRAY3D_DESCRIPTOR object, self.ptr={int(self)}>"
    def as_c_void_p(self):
        """Returns the data's address as `ctypes.c_void_p`"""
        return ctypes.c_void_p(int(self))
    def get_Width(self, i):
        """Get value ``Width`` of ``self._ptr[i]``.
        """
        return self._ptr[i].Width
    def set_Width(self, i, unsigned long value):
        """Set value ``Width`` of ``self._ptr[i]``.
        """
        self._ptr[i].Width = value
    @property
    def Width(self):
        return self.get_Width(0)
    @Width.setter
    def Width(self, unsigned long value):
        self.set_Width(0,value)

    def get_Height(self, i):
        """Get value ``Height`` of ``self._ptr[i]``.
        """
        return self._ptr[i].Height
    def set_Height(self, i, unsigned long value):
        """Set value ``Height`` of ``self._ptr[i]``.
        """
        self._ptr[i].Height = value
    @property
    def Height(self):
        return self.get_Height(0)
    @Height.setter
    def Height(self, unsigned long value):
        self.set_Height(0,value)

    def get_Depth(self, i):
        """Get value ``Depth`` of ``self._ptr[i]``.
        """
        return self._ptr[i].Depth
    def set_Depth(self, i, unsigned long value):
        """Set value ``Depth`` of ``self._ptr[i]``.
        """
        self._ptr[i].Depth = value
    @property
    def Depth(self):
        return self.get_Depth(0)
    @Depth.setter
    def Depth(self, unsigned long value):
        self.set_Depth(0,value)

    def get_Format(self, i):
        """Get value of ``Format`` of ``self._ptr[i]``.
        """
        return hipArray_Format(self._ptr[i].Format)
    def set_Format(self, i, value):
        """Set value ``Format`` of ``self._ptr[i]``.
        """
        if not isinstance(value, hipArray_Format):
            raise TypeError("'value' must be of type 'hipArray_Format'")
        self._ptr[i].Format = value.value
    @property
    def Format(self):
        return self.get_Format(0)
    @Format.setter
    def Format(self, value):
        self.set_Format(0,value)

    def get_NumChannels(self, i):
        """Get value ``NumChannels`` of ``self._ptr[i]``.
        """
        return self._ptr[i].NumChannels
    def set_NumChannels(self, i, unsigned int value):
        """Set value ``NumChannels`` of ``self._ptr[i]``.
        """
        self._ptr[i].NumChannels = value
    @property
    def NumChannels(self):
        return self.get_NumChannels(0)
    @NumChannels.setter
    def NumChannels(self, unsigned int value):
        self.set_NumChannels(0,value)

    def get_Flags(self, i):
        """Get value ``Flags`` of ``self._ptr[i]``.
        """
        return self._ptr[i].Flags
    def set_Flags(self, i, unsigned int value):
        """Set value ``Flags`` of ``self._ptr[i]``.
        """
        self._ptr[i].Flags = value
    @property
    def Flags(self):
        return self.get_Flags(0)
    @Flags.setter
    def Flags(self, unsigned int value):
        self.set_Flags(0,value)

    @staticmethod
    def PROPERTIES():
        return ["Width","Height","Depth","Format","NumChannels","Flags"]

    def __contains__(self,item):
        properties = self.PROPERTIES()
        return item in properties

    def __getitem__(self,item):
        properties = self.PROPERTIES()
        if isinstance(item,int):
            if item < 0 or item >= len(properties):
                raise IndexError()
            return getattr(self,properties[item])
        raise ValueError("'item' type must be 'int'")


cdef class hipArray:
    # members declared in pxd file

    def __cinit__(self):
        self._ptr = NULL
        self.ptr_owner = False
        self._py_buffer_acquired = False

    @staticmethod
    cdef hipArray from_ptr(chip.hipArray* ptr, bint owner=False):
        """Factory function to create ``hipArray`` objects from
        given ``chip.hipArray`` pointer.

        Setting ``owner`` flag to ``True`` causes
        the extension type to ``free`` the structure pointed to by ``ptr``
        when the wrapper object is deallocated.
        """
        # Fast call to __new__() that bypasses the __init__() constructor.
        cdef hipArray wrapper = hipArray.__new__(hipArray)
        wrapper._ptr = ptr
        wrapper.ptr_owner = owner
        return wrapper

    @staticmethod
    cdef hipArray from_pyobj(object pyobj):
        """Derives a hipArray from a Python object.

        Derives a hipArray from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``hipArray`` reference, this method
        returns it directly. No new ``hipArray`` is created in this case.

        Args:
            pyobj (object): Must be either ``None``, a simple, contiguous buffer according to the buffer protocol,
                            or of type ``hipArray``, ``int``, or ``ctypes.c_void_p``

        Note:
            This routine does not perform a copy but returns the original ``pyobj``
            if ``pyobj`` is an instance of hipArray!
        """
        cdef hipArray wrapper = hipArray.__new__(hipArray)
        cdef dict cuda_array_interface = getattr(pyobj, "__cuda_array_interface__", None)

        if pyobj is None:
            wrapper._ptr = NULL
        elif isinstance(pyobj,hipArray):
            return pyobj
        elif isinstance(pyobj,int):
            wrapper._ptr = <chip.hipArray*>cpython.long.PyLong_AsVoidPtr(pyobj)
        elif isinstance(pyobj,ctypes.c_void_p):
            wrapper._ptr = <chip.hipArray*>cpython.long.PyLong_AsVoidPtr(pyobj.value) if pyobj.value != None else NULL
        elif cuda_array_interface != None:
            if not "data" in cuda_array_interface:
                raise ValueError("input object has '__cuda_array_interface__' attribute but the dict has no 'data' key")
            ptr_as_int = cuda_array_interface["data"][0]
            wrapper._ptr = <chip.hipArray*>cpython.long.PyLong_AsVoidPtr(ptr_as_int)
        elif cpython.buffer.PyObject_CheckBuffer(pyobj):
            err = cpython.buffer.PyObject_GetBuffer( 
                pyobj,
                &wrapper._py_buffer, 
                cpython.buffer.PyBUF_SIMPLE | cpython.buffer.PyBUF_ANY_CONTIGUOUS
            )
            if err == -1:
                raise RuntimeError("failed to create simple, contiguous Py_buffer from Python object")
            wrapper._py_buffer_acquired = True
            wrapper._ptr = <chip.hipArray*>wrapper._py_buffer.buf
        else:
            raise TypeError(f"unsupported input type: '{str(type(pyobj))}'")
        return wrapper
    def __dealloc__(self):
        # Release the buffer handle
        if self._py_buffer_acquired is True:
            cpython.buffer.PyBuffer_Release(&self._py_buffer)
        # De-allocate if not null and flag is set
        if self._ptr is not NULL and self.ptr_owner is True:
            stdlib.free(self._ptr)
            self._ptr = NULL
    @staticmethod
    cdef __allocate(chip.hipArray** ptr):
        ptr[0] = <chip.hipArray*>stdlib.malloc(sizeof(chip.hipArray))

        if ptr[0] is NULL:
            raise MemoryError
        # TODO init values, if present

    @staticmethod
    cdef hipArray new():
        """Factory function to create hipArray objects with
        newly allocated chip.hipArray"""
        cdef chip.hipArray* ptr
        hipArray.__allocate(&ptr)
        return hipArray.from_ptr(ptr, owner=True)
   
    def __init__(self,*args,**kwargs):
        hipArray.__allocate(&self._ptr)
        self.ptr_owner = True
        attribs = self.PROPERTIES()
        used_attribs = set()
        if len(args) > len(attribs):
            raise ValueError("More positional arguments specified than this type has properties.")
        for i,v in enumerate(args):
            setattr(self,attribs[i],v)
            used_attribs.add(attribs[i])
        valid_names = ", ".join(["'"+p+"'" for p in attribs])
        for k,v in kwargs.items():
            if k in used_attribs:
                raise KeyError(f"argument '{k}' has already been specified as positional argument.")
            elif k not in attribs:
                raise KeyError(f"'{k}' is no valid property name. Valid names: {valid_names}")
            setattr(self,k,v)
    
    def __int__(self):
        """Returns the data's address as long integer."""
        return cpython.long.PyLong_FromVoidPtr(self._ptr)
    def __repr__(self):
        return f"<hipArray object, self.ptr={int(self)}>"
    def as_c_void_p(self):
        """Returns the data's address as `ctypes.c_void_p`"""
        return ctypes.c_void_p(int(self))
    def get_data(self, i):
        """Get value ``data`` of ``self._ptr[i]``.
        """
        return hip._util.types.DataHandle.from_ptr(self._ptr[i].data)
    def set_data(self, i, object value):
        """Set value ``data`` of ``self._ptr[i]``.

        Note:
            This can be dangerous if the pointer is from a python object
            that is later on garbage collected.
        """
        self._ptr[i].data = <void *>cpython.long.PyLong_AsVoidPtr(int(hip._util.types.DataHandle.from_pyobj(value)))
    @property
    def data(self):
        """
        Note:
            Setting this data can be dangerous if the underlying pointer is from a python object that
            is later on garbage collected.
        """
        return self.get_data(0)
    @data.setter
    def data(self, object value):
        self.set_data(0,value)

    def get_desc(self, i):
        """Get value of ``desc`` of ``self._ptr[i]``.
        """
        return hipChannelFormatDesc.from_ptr(&self._ptr[i].desc)
    @property
    def desc(self):
        return self.get_desc(0)

    def get_type(self, i):
        """Get value ``type`` of ``self._ptr[i]``.
        """
        return self._ptr[i].type
    def set_type(self, i, unsigned int value):
        """Set value ``type`` of ``self._ptr[i]``.
        """
        self._ptr[i].type = value
    @property
    def type(self):
        return self.get_type(0)
    @type.setter
    def type(self, unsigned int value):
        self.set_type(0,value)

    def get_width(self, i):
        """Get value ``width`` of ``self._ptr[i]``.
        """
        return self._ptr[i].width
    def set_width(self, i, unsigned int value):
        """Set value ``width`` of ``self._ptr[i]``.
        """
        self._ptr[i].width = value
    @property
    def width(self):
        return self.get_width(0)
    @width.setter
    def width(self, unsigned int value):
        self.set_width(0,value)

    def get_height(self, i):
        """Get value ``height`` of ``self._ptr[i]``.
        """
        return self._ptr[i].height
    def set_height(self, i, unsigned int value):
        """Set value ``height`` of ``self._ptr[i]``.
        """
        self._ptr[i].height = value
    @property
    def height(self):
        return self.get_height(0)
    @height.setter
    def height(self, unsigned int value):
        self.set_height(0,value)

    def get_depth(self, i):
        """Get value ``depth`` of ``self._ptr[i]``.
        """
        return self._ptr[i].depth
    def set_depth(self, i, unsigned int value):
        """Set value ``depth`` of ``self._ptr[i]``.
        """
        self._ptr[i].depth = value
    @property
    def depth(self):
        return self.get_depth(0)
    @depth.setter
    def depth(self, unsigned int value):
        self.set_depth(0,value)

    def get_Format(self, i):
        """Get value of ``Format`` of ``self._ptr[i]``.
        """
        return hipArray_Format(self._ptr[i].Format)
    def set_Format(self, i, value):
        """Set value ``Format`` of ``self._ptr[i]``.
        """
        if not isinstance(value, hipArray_Format):
            raise TypeError("'value' must be of type 'hipArray_Format'")
        self._ptr[i].Format = value.value
    @property
    def Format(self):
        return self.get_Format(0)
    @Format.setter
    def Format(self, value):
        self.set_Format(0,value)

    def get_NumChannels(self, i):
        """Get value ``NumChannels`` of ``self._ptr[i]``.
        """
        return self._ptr[i].NumChannels
    def set_NumChannels(self, i, unsigned int value):
        """Set value ``NumChannels`` of ``self._ptr[i]``.
        """
        self._ptr[i].NumChannels = value
    @property
    def NumChannels(self):
        return self.get_NumChannels(0)
    @NumChannels.setter
    def NumChannels(self, unsigned int value):
        self.set_NumChannels(0,value)

    def get_isDrv(self, i):
        """Get value ``isDrv`` of ``self._ptr[i]``.
        """
        return self._ptr[i].isDrv
    def set_isDrv(self, i, _Bool value):
        """Set value ``isDrv`` of ``self._ptr[i]``.
        """
        self._ptr[i].isDrv = value
    @property
    def isDrv(self):
        return self.get_isDrv(0)
    @isDrv.setter
    def isDrv(self, _Bool value):
        self.set_isDrv(0,value)

    def get_textureType(self, i):
        """Get value ``textureType`` of ``self._ptr[i]``.
        """
        return self._ptr[i].textureType
    def set_textureType(self, i, unsigned int value):
        """Set value ``textureType`` of ``self._ptr[i]``.
        """
        self._ptr[i].textureType = value
    @property
    def textureType(self):
        return self.get_textureType(0)
    @textureType.setter
    def textureType(self, unsigned int value):
        self.set_textureType(0,value)

    @staticmethod
    def PROPERTIES():
        return ["data","desc","type","width","height","depth","Format","NumChannels","isDrv","textureType"]

    def __contains__(self,item):
        properties = self.PROPERTIES()
        return item in properties

    def __getitem__(self,item):
        properties = self.PROPERTIES()
        if isinstance(item,int):
            if item < 0 or item >= len(properties):
                raise IndexError()
            return getattr(self,properties[item])
        raise ValueError("'item' type must be 'int'")


cdef class hip_Memcpy2D:
    # members declared in pxd file

    def __cinit__(self):
        self._ptr = NULL
        self.ptr_owner = False
        self._py_buffer_acquired = False

    @staticmethod
    cdef hip_Memcpy2D from_ptr(chip.hip_Memcpy2D* ptr, bint owner=False):
        """Factory function to create ``hip_Memcpy2D`` objects from
        given ``chip.hip_Memcpy2D`` pointer.

        Setting ``owner`` flag to ``True`` causes
        the extension type to ``free`` the structure pointed to by ``ptr``
        when the wrapper object is deallocated.
        """
        # Fast call to __new__() that bypasses the __init__() constructor.
        cdef hip_Memcpy2D wrapper = hip_Memcpy2D.__new__(hip_Memcpy2D)
        wrapper._ptr = ptr
        wrapper.ptr_owner = owner
        return wrapper

    @staticmethod
    cdef hip_Memcpy2D from_pyobj(object pyobj):
        """Derives a hip_Memcpy2D from a Python object.

        Derives a hip_Memcpy2D from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``hip_Memcpy2D`` reference, this method
        returns it directly. No new ``hip_Memcpy2D`` is created in this case.

        Args:
            pyobj (object): Must be either ``None``, a simple, contiguous buffer according to the buffer protocol,
                            or of type ``hip_Memcpy2D``, ``int``, or ``ctypes.c_void_p``

        Note:
            This routine does not perform a copy but returns the original ``pyobj``
            if ``pyobj`` is an instance of hip_Memcpy2D!
        """
        cdef hip_Memcpy2D wrapper = hip_Memcpy2D.__new__(hip_Memcpy2D)
        cdef dict cuda_array_interface = getattr(pyobj, "__cuda_array_interface__", None)

        if pyobj is None:
            wrapper._ptr = NULL
        elif isinstance(pyobj,hip_Memcpy2D):
            return pyobj
        elif isinstance(pyobj,int):
            wrapper._ptr = <chip.hip_Memcpy2D*>cpython.long.PyLong_AsVoidPtr(pyobj)
        elif isinstance(pyobj,ctypes.c_void_p):
            wrapper._ptr = <chip.hip_Memcpy2D*>cpython.long.PyLong_AsVoidPtr(pyobj.value) if pyobj.value != None else NULL
        elif cuda_array_interface != None:
            if not "data" in cuda_array_interface:
                raise ValueError("input object has '__cuda_array_interface__' attribute but the dict has no 'data' key")
            ptr_as_int = cuda_array_interface["data"][0]
            wrapper._ptr = <chip.hip_Memcpy2D*>cpython.long.PyLong_AsVoidPtr(ptr_as_int)
        elif cpython.buffer.PyObject_CheckBuffer(pyobj):
            err = cpython.buffer.PyObject_GetBuffer( 
                pyobj,
                &wrapper._py_buffer, 
                cpython.buffer.PyBUF_SIMPLE | cpython.buffer.PyBUF_ANY_CONTIGUOUS
            )
            if err == -1:
                raise RuntimeError("failed to create simple, contiguous Py_buffer from Python object")
            wrapper._py_buffer_acquired = True
            wrapper._ptr = <chip.hip_Memcpy2D*>wrapper._py_buffer.buf
        else:
            raise TypeError(f"unsupported input type: '{str(type(pyobj))}'")
        return wrapper
    def __dealloc__(self):
        # Release the buffer handle
        if self._py_buffer_acquired is True:
            cpython.buffer.PyBuffer_Release(&self._py_buffer)
        # De-allocate if not null and flag is set
        if self._ptr is not NULL and self.ptr_owner is True:
            stdlib.free(self._ptr)
            self._ptr = NULL
    @staticmethod
    cdef __allocate(chip.hip_Memcpy2D** ptr):
        ptr[0] = <chip.hip_Memcpy2D*>stdlib.malloc(sizeof(chip.hip_Memcpy2D))

        if ptr[0] is NULL:
            raise MemoryError
        # TODO init values, if present

    @staticmethod
    cdef hip_Memcpy2D new():
        """Factory function to create hip_Memcpy2D objects with
        newly allocated chip.hip_Memcpy2D"""
        cdef chip.hip_Memcpy2D* ptr
        hip_Memcpy2D.__allocate(&ptr)
        return hip_Memcpy2D.from_ptr(ptr, owner=True)
   
    # False
    # False
    def __init__(self,**kwargs):
        hip_Memcpy2D.__allocate(&self._ptr)
        self.ptr_owner = True
        attribs = self.PROPERTIES()
        used_attribs = set()
        valid_names = ", ".join(["'"+p+"'" for p in attribs])
        for k,v in kwargs.items():
            if k in used_attribs:
                raise KeyError(f"argument '{k}' has already been specified as positional argument.")
            elif k not in attribs:
                raise KeyError(f"'{k}' is no valid property name. Valid names: {valid_names}")
            setattr(self,k,v)
    
    def __int__(self):
        """Returns the data's address as long integer."""
        return cpython.long.PyLong_FromVoidPtr(self._ptr)
    def __repr__(self):
        return f"<hip_Memcpy2D object, self.ptr={int(self)}>"
    def as_c_void_p(self):
        """Returns the data's address as `ctypes.c_void_p`"""
        return ctypes.c_void_p(int(self))
    def get_srcXInBytes(self, i):
        """Get value ``srcXInBytes`` of ``self._ptr[i]``.
        """
        return self._ptr[i].srcXInBytes
    def set_srcXInBytes(self, i, unsigned long value):
        """Set value ``srcXInBytes`` of ``self._ptr[i]``.
        """
        self._ptr[i].srcXInBytes = value
    @property
    def srcXInBytes(self):
        return self.get_srcXInBytes(0)
    @srcXInBytes.setter
    def srcXInBytes(self, unsigned long value):
        self.set_srcXInBytes(0,value)

    def get_srcY(self, i):
        """Get value ``srcY`` of ``self._ptr[i]``.
        """
        return self._ptr[i].srcY
    def set_srcY(self, i, unsigned long value):
        """Set value ``srcY`` of ``self._ptr[i]``.
        """
        self._ptr[i].srcY = value
    @property
    def srcY(self):
        return self.get_srcY(0)
    @srcY.setter
    def srcY(self, unsigned long value):
        self.set_srcY(0,value)

    def get_srcMemoryType(self, i):
        """Get value of ``srcMemoryType`` of ``self._ptr[i]``.
        """
        return hipMemoryType(self._ptr[i].srcMemoryType)
    def set_srcMemoryType(self, i, value):
        """Set value ``srcMemoryType`` of ``self._ptr[i]``.
        """
        if not isinstance(value, hipMemoryType):
            raise TypeError("'value' must be of type 'hipMemoryType'")
        self._ptr[i].srcMemoryType = value.value
    @property
    def srcMemoryType(self):
        return self.get_srcMemoryType(0)
    @srcMemoryType.setter
    def srcMemoryType(self, value):
        self.set_srcMemoryType(0,value)

    def get_srcHost(self, i):
        """Get value ``srcHost`` of ``self._ptr[i]``.
        """
        return hip._util.types.DataHandle.from_ptr(self._ptr[i].srcHost)
    def set_srcHost(self, i, object value):
        """Set value ``srcHost`` of ``self._ptr[i]``.

        Note:
            This can be dangerous if the pointer is from a python object
            that is later on garbage collected.
        """
        self._ptr[i].srcHost = <const void *>cpython.long.PyLong_AsVoidPtr(int(hip._util.types.DataHandle.from_pyobj(value)))
    @property
    def srcHost(self):
        """
        Note:
            Setting this srcHost can be dangerous if the underlying pointer is from a python object that
            is later on garbage collected.
        """
        return self.get_srcHost(0)
    @srcHost.setter
    def srcHost(self, object value):
        self.set_srcHost(0,value)

    def get_srcDevice(self, i):
        """Get value ``srcDevice`` of ``self._ptr[i]``.
        """
        return hip._util.types.DataHandle.from_ptr(self._ptr[i].srcDevice)
    def set_srcDevice(self, i, object value):
        """Set value ``srcDevice`` of ``self._ptr[i]``.

        Note:
            This can be dangerous if the pointer is from a python object
            that is later on garbage collected.
        """
        self._ptr[i].srcDevice = <void *>cpython.long.PyLong_AsVoidPtr(int(hip._util.types.DataHandle.from_pyobj(value)))
    @property
    def srcDevice(self):
        """
        Note:
            Setting this srcDevice can be dangerous if the underlying pointer is from a python object that
            is later on garbage collected.
        """
        return self.get_srcDevice(0)
    @srcDevice.setter
    def srcDevice(self, object value):
        self.set_srcDevice(0,value)

    def get_srcPitch(self, i):
        """Get value ``srcPitch`` of ``self._ptr[i]``.
        """
        return self._ptr[i].srcPitch
    def set_srcPitch(self, i, unsigned long value):
        """Set value ``srcPitch`` of ``self._ptr[i]``.
        """
        self._ptr[i].srcPitch = value
    @property
    def srcPitch(self):
        return self.get_srcPitch(0)
    @srcPitch.setter
    def srcPitch(self, unsigned long value):
        self.set_srcPitch(0,value)

    def get_dstXInBytes(self, i):
        """Get value ``dstXInBytes`` of ``self._ptr[i]``.
        """
        return self._ptr[i].dstXInBytes
    def set_dstXInBytes(self, i, unsigned long value):
        """Set value ``dstXInBytes`` of ``self._ptr[i]``.
        """
        self._ptr[i].dstXInBytes = value
    @property
    def dstXInBytes(self):
        return self.get_dstXInBytes(0)
    @dstXInBytes.setter
    def dstXInBytes(self, unsigned long value):
        self.set_dstXInBytes(0,value)

    def get_dstY(self, i):
        """Get value ``dstY`` of ``self._ptr[i]``.
        """
        return self._ptr[i].dstY
    def set_dstY(self, i, unsigned long value):
        """Set value ``dstY`` of ``self._ptr[i]``.
        """
        self._ptr[i].dstY = value
    @property
    def dstY(self):
        return self.get_dstY(0)
    @dstY.setter
    def dstY(self, unsigned long value):
        self.set_dstY(0,value)

    def get_dstMemoryType(self, i):
        """Get value of ``dstMemoryType`` of ``self._ptr[i]``.
        """
        return hipMemoryType(self._ptr[i].dstMemoryType)
    def set_dstMemoryType(self, i, value):
        """Set value ``dstMemoryType`` of ``self._ptr[i]``.
        """
        if not isinstance(value, hipMemoryType):
            raise TypeError("'value' must be of type 'hipMemoryType'")
        self._ptr[i].dstMemoryType = value.value
    @property
    def dstMemoryType(self):
        return self.get_dstMemoryType(0)
    @dstMemoryType.setter
    def dstMemoryType(self, value):
        self.set_dstMemoryType(0,value)

    def get_dstHost(self, i):
        """Get value ``dstHost`` of ``self._ptr[i]``.
        """
        return hip._util.types.DataHandle.from_ptr(self._ptr[i].dstHost)
    def set_dstHost(self, i, object value):
        """Set value ``dstHost`` of ``self._ptr[i]``.

        Note:
            This can be dangerous if the pointer is from a python object
            that is later on garbage collected.
        """
        self._ptr[i].dstHost = <void *>cpython.long.PyLong_AsVoidPtr(int(hip._util.types.DataHandle.from_pyobj(value)))
    @property
    def dstHost(self):
        """
        Note:
            Setting this dstHost can be dangerous if the underlying pointer is from a python object that
            is later on garbage collected.
        """
        return self.get_dstHost(0)
    @dstHost.setter
    def dstHost(self, object value):
        self.set_dstHost(0,value)

    def get_dstDevice(self, i):
        """Get value ``dstDevice`` of ``self._ptr[i]``.
        """
        return hip._util.types.DataHandle.from_ptr(self._ptr[i].dstDevice)
    def set_dstDevice(self, i, object value):
        """Set value ``dstDevice`` of ``self._ptr[i]``.

        Note:
            This can be dangerous if the pointer is from a python object
            that is later on garbage collected.
        """
        self._ptr[i].dstDevice = <void *>cpython.long.PyLong_AsVoidPtr(int(hip._util.types.DataHandle.from_pyobj(value)))
    @property
    def dstDevice(self):
        """
        Note:
            Setting this dstDevice can be dangerous if the underlying pointer is from a python object that
            is later on garbage collected.
        """
        return self.get_dstDevice(0)
    @dstDevice.setter
    def dstDevice(self, object value):
        self.set_dstDevice(0,value)

    def get_dstPitch(self, i):
        """Get value ``dstPitch`` of ``self._ptr[i]``.
        """
        return self._ptr[i].dstPitch
    def set_dstPitch(self, i, unsigned long value):
        """Set value ``dstPitch`` of ``self._ptr[i]``.
        """
        self._ptr[i].dstPitch = value
    @property
    def dstPitch(self):
        return self.get_dstPitch(0)
    @dstPitch.setter
    def dstPitch(self, unsigned long value):
        self.set_dstPitch(0,value)

    def get_WidthInBytes(self, i):
        """Get value ``WidthInBytes`` of ``self._ptr[i]``.
        """
        return self._ptr[i].WidthInBytes
    def set_WidthInBytes(self, i, unsigned long value):
        """Set value ``WidthInBytes`` of ``self._ptr[i]``.
        """
        self._ptr[i].WidthInBytes = value
    @property
    def WidthInBytes(self):
        return self.get_WidthInBytes(0)
    @WidthInBytes.setter
    def WidthInBytes(self, unsigned long value):
        self.set_WidthInBytes(0,value)

    def get_Height(self, i):
        """Get value ``Height`` of ``self._ptr[i]``.
        """
        return self._ptr[i].Height
    def set_Height(self, i, unsigned long value):
        """Set value ``Height`` of ``self._ptr[i]``.
        """
        self._ptr[i].Height = value
    @property
    def Height(self):
        return self.get_Height(0)
    @Height.setter
    def Height(self, unsigned long value):
        self.set_Height(0,value)

    @staticmethod
    def PROPERTIES():
        return ["srcXInBytes","srcY","srcMemoryType","srcHost","srcDevice","srcPitch","dstXInBytes","dstY","dstMemoryType","dstHost","dstDevice","dstPitch","WidthInBytes","Height"]

    def __contains__(self,item):
        properties = self.PROPERTIES()
        return item in properties

    def __getitem__(self,item):
        properties = self.PROPERTIES()
        if isinstance(item,int):
            if item < 0 or item >= len(properties):
                raise IndexError()
            return getattr(self,properties[item])
        raise ValueError("'item' type must be 'int'")


hipArray_t = hipArray

hiparray = hipArray_t

hipArray_const_t = hipArray

cdef class hipMipmappedArray:
    # members declared in pxd file

    def __cinit__(self):
        self._ptr = NULL
        self.ptr_owner = False
        self._py_buffer_acquired = False

    @staticmethod
    cdef hipMipmappedArray from_ptr(chip.hipMipmappedArray* ptr, bint owner=False):
        """Factory function to create ``hipMipmappedArray`` objects from
        given ``chip.hipMipmappedArray`` pointer.

        Setting ``owner`` flag to ``True`` causes
        the extension type to ``free`` the structure pointed to by ``ptr``
        when the wrapper object is deallocated.
        """
        # Fast call to __new__() that bypasses the __init__() constructor.
        cdef hipMipmappedArray wrapper = hipMipmappedArray.__new__(hipMipmappedArray)
        wrapper._ptr = ptr
        wrapper.ptr_owner = owner
        return wrapper

    @staticmethod
    cdef hipMipmappedArray from_pyobj(object pyobj):
        """Derives a hipMipmappedArray from a Python object.

        Derives a hipMipmappedArray from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``hipMipmappedArray`` reference, this method
        returns it directly. No new ``hipMipmappedArray`` is created in this case.

        Args:
            pyobj (object): Must be either ``None``, a simple, contiguous buffer according to the buffer protocol,
                            or of type ``hipMipmappedArray``, ``int``, or ``ctypes.c_void_p``

        Note:
            This routine does not perform a copy but returns the original ``pyobj``
            if ``pyobj`` is an instance of hipMipmappedArray!
        """
        cdef hipMipmappedArray wrapper = hipMipmappedArray.__new__(hipMipmappedArray)
        cdef dict cuda_array_interface = getattr(pyobj, "__cuda_array_interface__", None)

        if pyobj is None:
            wrapper._ptr = NULL
        elif isinstance(pyobj,hipMipmappedArray):
            return pyobj
        elif isinstance(pyobj,int):
            wrapper._ptr = <chip.hipMipmappedArray*>cpython.long.PyLong_AsVoidPtr(pyobj)
        elif isinstance(pyobj,ctypes.c_void_p):
            wrapper._ptr = <chip.hipMipmappedArray*>cpython.long.PyLong_AsVoidPtr(pyobj.value) if pyobj.value != None else NULL
        elif cuda_array_interface != None:
            if not "data" in cuda_array_interface:
                raise ValueError("input object has '__cuda_array_interface__' attribute but the dict has no 'data' key")
            ptr_as_int = cuda_array_interface["data"][0]
            wrapper._ptr = <chip.hipMipmappedArray*>cpython.long.PyLong_AsVoidPtr(ptr_as_int)
        elif cpython.buffer.PyObject_CheckBuffer(pyobj):
            err = cpython.buffer.PyObject_GetBuffer( 
                pyobj,
                &wrapper._py_buffer, 
                cpython.buffer.PyBUF_SIMPLE | cpython.buffer.PyBUF_ANY_CONTIGUOUS
            )
            if err == -1:
                raise RuntimeError("failed to create simple, contiguous Py_buffer from Python object")
            wrapper._py_buffer_acquired = True
            wrapper._ptr = <chip.hipMipmappedArray*>wrapper._py_buffer.buf
        else:
            raise TypeError(f"unsupported input type: '{str(type(pyobj))}'")
        return wrapper
    def __dealloc__(self):
        # Release the buffer handle
        if self._py_buffer_acquired is True:
            cpython.buffer.PyBuffer_Release(&self._py_buffer)
        # De-allocate if not null and flag is set
        if self._ptr is not NULL and self.ptr_owner is True:
            stdlib.free(self._ptr)
            self._ptr = NULL
    @staticmethod
    cdef __allocate(chip.hipMipmappedArray** ptr):
        ptr[0] = <chip.hipMipmappedArray*>stdlib.malloc(sizeof(chip.hipMipmappedArray))

        if ptr[0] is NULL:
            raise MemoryError
        # TODO init values, if present

    @staticmethod
    cdef hipMipmappedArray new():
        """Factory function to create hipMipmappedArray objects with
        newly allocated chip.hipMipmappedArray"""
        cdef chip.hipMipmappedArray* ptr
        hipMipmappedArray.__allocate(&ptr)
        return hipMipmappedArray.from_ptr(ptr, owner=True)
   
    def __init__(self,*args,**kwargs):
        hipMipmappedArray.__allocate(&self._ptr)
        self.ptr_owner = True
        attribs = self.PROPERTIES()
        used_attribs = set()
        if len(args) > len(attribs):
            raise ValueError("More positional arguments specified than this type has properties.")
        for i,v in enumerate(args):
            setattr(self,attribs[i],v)
            used_attribs.add(attribs[i])
        valid_names = ", ".join(["'"+p+"'" for p in attribs])
        for k,v in kwargs.items():
            if k in used_attribs:
                raise KeyError(f"argument '{k}' has already been specified as positional argument.")
            elif k not in attribs:
                raise KeyError(f"'{k}' is no valid property name. Valid names: {valid_names}")
            setattr(self,k,v)
    
    def __int__(self):
        """Returns the data's address as long integer."""
        return cpython.long.PyLong_FromVoidPtr(self._ptr)
    def __repr__(self):
        return f"<hipMipmappedArray object, self.ptr={int(self)}>"
    def as_c_void_p(self):
        """Returns the data's address as `ctypes.c_void_p`"""
        return ctypes.c_void_p(int(self))
    def get_data(self, i):
        """Get value ``data`` of ``self._ptr[i]``.
        """
        return hip._util.types.DataHandle.from_ptr(self._ptr[i].data)
    def set_data(self, i, object value):
        """Set value ``data`` of ``self._ptr[i]``.

        Note:
            This can be dangerous if the pointer is from a python object
            that is later on garbage collected.
        """
        self._ptr[i].data = <void *>cpython.long.PyLong_AsVoidPtr(int(hip._util.types.DataHandle.from_pyobj(value)))
    @property
    def data(self):
        """
        Note:
            Setting this data can be dangerous if the underlying pointer is from a python object that
            is later on garbage collected.
        """
        return self.get_data(0)
    @data.setter
    def data(self, object value):
        self.set_data(0,value)

    def get_desc(self, i):
        """Get value of ``desc`` of ``self._ptr[i]``.
        """
        return hipChannelFormatDesc.from_ptr(&self._ptr[i].desc)
    @property
    def desc(self):
        return self.get_desc(0)

    def get_type(self, i):
        """Get value ``type`` of ``self._ptr[i]``.
        """
        return self._ptr[i].type
    def set_type(self, i, unsigned int value):
        """Set value ``type`` of ``self._ptr[i]``.
        """
        self._ptr[i].type = value
    @property
    def type(self):
        return self.get_type(0)
    @type.setter
    def type(self, unsigned int value):
        self.set_type(0,value)

    def get_width(self, i):
        """Get value ``width`` of ``self._ptr[i]``.
        """
        return self._ptr[i].width
    def set_width(self, i, unsigned int value):
        """Set value ``width`` of ``self._ptr[i]``.
        """
        self._ptr[i].width = value
    @property
    def width(self):
        return self.get_width(0)
    @width.setter
    def width(self, unsigned int value):
        self.set_width(0,value)

    def get_height(self, i):
        """Get value ``height`` of ``self._ptr[i]``.
        """
        return self._ptr[i].height
    def set_height(self, i, unsigned int value):
        """Set value ``height`` of ``self._ptr[i]``.
        """
        self._ptr[i].height = value
    @property
    def height(self):
        return self.get_height(0)
    @height.setter
    def height(self, unsigned int value):
        self.set_height(0,value)

    def get_depth(self, i):
        """Get value ``depth`` of ``self._ptr[i]``.
        """
        return self._ptr[i].depth
    def set_depth(self, i, unsigned int value):
        """Set value ``depth`` of ``self._ptr[i]``.
        """
        self._ptr[i].depth = value
    @property
    def depth(self):
        return self.get_depth(0)
    @depth.setter
    def depth(self, unsigned int value):
        self.set_depth(0,value)

    def get_min_mipmap_level(self, i):
        """Get value ``min_mipmap_level`` of ``self._ptr[i]``.
        """
        return self._ptr[i].min_mipmap_level
    def set_min_mipmap_level(self, i, unsigned int value):
        """Set value ``min_mipmap_level`` of ``self._ptr[i]``.
        """
        self._ptr[i].min_mipmap_level = value
    @property
    def min_mipmap_level(self):
        return self.get_min_mipmap_level(0)
    @min_mipmap_level.setter
    def min_mipmap_level(self, unsigned int value):
        self.set_min_mipmap_level(0,value)

    def get_max_mipmap_level(self, i):
        """Get value ``max_mipmap_level`` of ``self._ptr[i]``.
        """
        return self._ptr[i].max_mipmap_level
    def set_max_mipmap_level(self, i, unsigned int value):
        """Set value ``max_mipmap_level`` of ``self._ptr[i]``.
        """
        self._ptr[i].max_mipmap_level = value
    @property
    def max_mipmap_level(self):
        return self.get_max_mipmap_level(0)
    @max_mipmap_level.setter
    def max_mipmap_level(self, unsigned int value):
        self.set_max_mipmap_level(0,value)

    def get_flags(self, i):
        """Get value ``flags`` of ``self._ptr[i]``.
        """
        return self._ptr[i].flags
    def set_flags(self, i, unsigned int value):
        """Set value ``flags`` of ``self._ptr[i]``.
        """
        self._ptr[i].flags = value
    @property
    def flags(self):
        return self.get_flags(0)
    @flags.setter
    def flags(self, unsigned int value):
        self.set_flags(0,value)

    def get_format(self, i):
        """Get value of ``format`` of ``self._ptr[i]``.
        """
        return hipArray_Format(self._ptr[i].format)
    def set_format(self, i, value):
        """Set value ``format`` of ``self._ptr[i]``.
        """
        if not isinstance(value, hipArray_Format):
            raise TypeError("'value' must be of type 'hipArray_Format'")
        self._ptr[i].format = value.value
    @property
    def format(self):
        return self.get_format(0)
    @format.setter
    def format(self, value):
        self.set_format(0,value)

    @staticmethod
    def PROPERTIES():
        return ["data","desc","type","width","height","depth","min_mipmap_level","max_mipmap_level","flags","format"]

    def __contains__(self,item):
        properties = self.PROPERTIES()
        return item in properties

    def __getitem__(self,item):
        properties = self.PROPERTIES()
        if isinstance(item,int):
            if item < 0 or item >= len(properties):
                raise IndexError()
            return getattr(self,properties[item])
        raise ValueError("'item' type must be 'int'")


hipMipmappedArray_t = hipMipmappedArray

hipMipmappedArray_const_t = hipMipmappedArray

class _hipResourceType__Base(enum.IntEnum):
    """Empty enum base class that allows subclassing.
    """
    pass
class hipResourceType(_hipResourceType__Base):
    hipResourceTypeArray = chip.hipResourceTypeArray
    hipResourceTypeMipmappedArray = chip.hipResourceTypeMipmappedArray
    hipResourceTypeLinear = chip.hipResourceTypeLinear
    hipResourceTypePitch2D = chip.hipResourceTypePitch2D
    @staticmethod
    def ctypes_type():
        """The type of the enum constants as ctypes type."""
        return ctypes.c_uint 


class _HIPresourcetype_enum__Base(enum.IntEnum):
    """Empty enum base class that allows subclassing.
    """
    pass
class HIPresourcetype_enum(_HIPresourcetype_enum__Base):
    HIP_RESOURCE_TYPE_ARRAY = chip.HIP_RESOURCE_TYPE_ARRAY
    HIP_RESOURCE_TYPE_MIPMAPPED_ARRAY = chip.HIP_RESOURCE_TYPE_MIPMAPPED_ARRAY
    HIP_RESOURCE_TYPE_LINEAR = chip.HIP_RESOURCE_TYPE_LINEAR
    HIP_RESOURCE_TYPE_PITCH2D = chip.HIP_RESOURCE_TYPE_PITCH2D
    @staticmethod
    def ctypes_type():
        """The type of the enum constants as ctypes type."""
        return ctypes.c_uint 


HIPresourcetype = HIPresourcetype_enum

hipResourcetype = HIPresourcetype_enum

class _HIPaddress_mode_enum__Base(enum.IntEnum):
    """Empty enum base class that allows subclassing.
    """
    pass
class HIPaddress_mode_enum(_HIPaddress_mode_enum__Base):
    HIP_TR_ADDRESS_MODE_WRAP = chip.HIP_TR_ADDRESS_MODE_WRAP
    HIP_TR_ADDRESS_MODE_CLAMP = chip.HIP_TR_ADDRESS_MODE_CLAMP
    HIP_TR_ADDRESS_MODE_MIRROR = chip.HIP_TR_ADDRESS_MODE_MIRROR
    HIP_TR_ADDRESS_MODE_BORDER = chip.HIP_TR_ADDRESS_MODE_BORDER
    @staticmethod
    def ctypes_type():
        """The type of the enum constants as ctypes type."""
        return ctypes.c_uint 


HIPaddress_mode = HIPaddress_mode_enum

class _HIPfilter_mode_enum__Base(enum.IntEnum):
    """Empty enum base class that allows subclassing.
    """
    pass
class HIPfilter_mode_enum(_HIPfilter_mode_enum__Base):
    HIP_TR_FILTER_MODE_POINT = chip.HIP_TR_FILTER_MODE_POINT
    HIP_TR_FILTER_MODE_LINEAR = chip.HIP_TR_FILTER_MODE_LINEAR
    @staticmethod
    def ctypes_type():
        """The type of the enum constants as ctypes type."""
        return ctypes.c_uint 


HIPfilter_mode = HIPfilter_mode_enum

cdef class HIP_TEXTURE_DESC_st:
    # members declared in pxd file

    def __cinit__(self):
        self._ptr = NULL
        self.ptr_owner = False
        self._py_buffer_acquired = False

    @staticmethod
    cdef HIP_TEXTURE_DESC_st from_ptr(chip.HIP_TEXTURE_DESC_st* ptr, bint owner=False):
        """Factory function to create ``HIP_TEXTURE_DESC_st`` objects from
        given ``chip.HIP_TEXTURE_DESC_st`` pointer.

        Setting ``owner`` flag to ``True`` causes
        the extension type to ``free`` the structure pointed to by ``ptr``
        when the wrapper object is deallocated.
        """
        # Fast call to __new__() that bypasses the __init__() constructor.
        cdef HIP_TEXTURE_DESC_st wrapper = HIP_TEXTURE_DESC_st.__new__(HIP_TEXTURE_DESC_st)
        wrapper._ptr = ptr
        wrapper.ptr_owner = owner
        return wrapper

    @staticmethod
    cdef HIP_TEXTURE_DESC_st from_pyobj(object pyobj):
        """Derives a HIP_TEXTURE_DESC_st from a Python object.

        Derives a HIP_TEXTURE_DESC_st from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``HIP_TEXTURE_DESC_st`` reference, this method
        returns it directly. No new ``HIP_TEXTURE_DESC_st`` is created in this case.

        Args:
            pyobj (object): Must be either ``None``, a simple, contiguous buffer according to the buffer protocol,
                            or of type ``HIP_TEXTURE_DESC_st``, ``int``, or ``ctypes.c_void_p``

        Note:
            This routine does not perform a copy but returns the original ``pyobj``
            if ``pyobj`` is an instance of HIP_TEXTURE_DESC_st!
        """
        cdef HIP_TEXTURE_DESC_st wrapper = HIP_TEXTURE_DESC_st.__new__(HIP_TEXTURE_DESC_st)
        cdef dict cuda_array_interface = getattr(pyobj, "__cuda_array_interface__", None)

        if pyobj is None:
            wrapper._ptr = NULL
        elif isinstance(pyobj,HIP_TEXTURE_DESC_st):
            return pyobj
        elif isinstance(pyobj,int):
            wrapper._ptr = <chip.HIP_TEXTURE_DESC_st*>cpython.long.PyLong_AsVoidPtr(pyobj)
        elif isinstance(pyobj,ctypes.c_void_p):
            wrapper._ptr = <chip.HIP_TEXTURE_DESC_st*>cpython.long.PyLong_AsVoidPtr(pyobj.value) if pyobj.value != None else NULL
        elif cuda_array_interface != None:
            if not "data" in cuda_array_interface:
                raise ValueError("input object has '__cuda_array_interface__' attribute but the dict has no 'data' key")
            ptr_as_int = cuda_array_interface["data"][0]
            wrapper._ptr = <chip.HIP_TEXTURE_DESC_st*>cpython.long.PyLong_AsVoidPtr(ptr_as_int)
        elif cpython.buffer.PyObject_CheckBuffer(pyobj):
            err = cpython.buffer.PyObject_GetBuffer( 
                pyobj,
                &wrapper._py_buffer, 
                cpython.buffer.PyBUF_SIMPLE | cpython.buffer.PyBUF_ANY_CONTIGUOUS
            )
            if err == -1:
                raise RuntimeError("failed to create simple, contiguous Py_buffer from Python object")
            wrapper._py_buffer_acquired = True
            wrapper._ptr = <chip.HIP_TEXTURE_DESC_st*>wrapper._py_buffer.buf
        else:
            raise TypeError(f"unsupported input type: '{str(type(pyobj))}'")
        return wrapper
    def __dealloc__(self):
        # Release the buffer handle
        if self._py_buffer_acquired is True:
            cpython.buffer.PyBuffer_Release(&self._py_buffer)
        # De-allocate if not null and flag is set
        if self._ptr is not NULL and self.ptr_owner is True:
            stdlib.free(self._ptr)
            self._ptr = NULL
    @staticmethod
    cdef __allocate(chip.HIP_TEXTURE_DESC_st** ptr):
        ptr[0] = <chip.HIP_TEXTURE_DESC_st*>stdlib.malloc(sizeof(chip.HIP_TEXTURE_DESC_st))

        if ptr[0] is NULL:
            raise MemoryError
        # TODO init values, if present

    @staticmethod
    cdef HIP_TEXTURE_DESC_st new():
        """Factory function to create HIP_TEXTURE_DESC_st objects with
        newly allocated chip.HIP_TEXTURE_DESC_st"""
        cdef chip.HIP_TEXTURE_DESC_st* ptr
        HIP_TEXTURE_DESC_st.__allocate(&ptr)
        return HIP_TEXTURE_DESC_st.from_ptr(ptr, owner=True)
   
    # False
    # False
    def __init__(self,**kwargs):
        HIP_TEXTURE_DESC_st.__allocate(&self._ptr)
        self.ptr_owner = True
        attribs = self.PROPERTIES()
        used_attribs = set()
        valid_names = ", ".join(["'"+p+"'" for p in attribs])
        for k,v in kwargs.items():
            if k in used_attribs:
                raise KeyError(f"argument '{k}' has already been specified as positional argument.")
            elif k not in attribs:
                raise KeyError(f"'{k}' is no valid property name. Valid names: {valid_names}")
            setattr(self,k,v)
    
    def __int__(self):
        """Returns the data's address as long integer."""
        return cpython.long.PyLong_FromVoidPtr(self._ptr)
    def __repr__(self):
        return f"<HIP_TEXTURE_DESC_st object, self.ptr={int(self)}>"
    def as_c_void_p(self):
        """Returns the data's address as `ctypes.c_void_p`"""
        return ctypes.c_void_p(int(self))
    def get_filterMode(self, i):
        """Get value of ``filterMode`` of ``self._ptr[i]``.
        """
        return HIPfilter_mode_enum(self._ptr[i].filterMode)
    def set_filterMode(self, i, value):
        """Set value ``filterMode`` of ``self._ptr[i]``.
        """
        if not isinstance(value, HIPfilter_mode_enum):
            raise TypeError("'value' must be of type 'HIPfilter_mode_enum'")
        self._ptr[i].filterMode = value.value
    @property
    def filterMode(self):
        return self.get_filterMode(0)
    @filterMode.setter
    def filterMode(self, value):
        self.set_filterMode(0,value)

    def get_flags(self, i):
        """Get value ``flags`` of ``self._ptr[i]``.
        """
        return self._ptr[i].flags
    def set_flags(self, i, unsigned int value):
        """Set value ``flags`` of ``self._ptr[i]``.
        """
        self._ptr[i].flags = value
    @property
    def flags(self):
        return self.get_flags(0)
    @flags.setter
    def flags(self, unsigned int value):
        self.set_flags(0,value)

    def get_maxAnisotropy(self, i):
        """Get value ``maxAnisotropy`` of ``self._ptr[i]``.
        """
        return self._ptr[i].maxAnisotropy
    def set_maxAnisotropy(self, i, unsigned int value):
        """Set value ``maxAnisotropy`` of ``self._ptr[i]``.
        """
        self._ptr[i].maxAnisotropy = value
    @property
    def maxAnisotropy(self):
        return self.get_maxAnisotropy(0)
    @maxAnisotropy.setter
    def maxAnisotropy(self, unsigned int value):
        self.set_maxAnisotropy(0,value)

    def get_mipmapFilterMode(self, i):
        """Get value of ``mipmapFilterMode`` of ``self._ptr[i]``.
        """
        return HIPfilter_mode_enum(self._ptr[i].mipmapFilterMode)
    def set_mipmapFilterMode(self, i, value):
        """Set value ``mipmapFilterMode`` of ``self._ptr[i]``.
        """
        if not isinstance(value, HIPfilter_mode_enum):
            raise TypeError("'value' must be of type 'HIPfilter_mode_enum'")
        self._ptr[i].mipmapFilterMode = value.value
    @property
    def mipmapFilterMode(self):
        return self.get_mipmapFilterMode(0)
    @mipmapFilterMode.setter
    def mipmapFilterMode(self, value):
        self.set_mipmapFilterMode(0,value)

    def get_mipmapLevelBias(self, i):
        """Get value ``mipmapLevelBias`` of ``self._ptr[i]``.
        """
        return self._ptr[i].mipmapLevelBias
    def set_mipmapLevelBias(self, i, float value):
        """Set value ``mipmapLevelBias`` of ``self._ptr[i]``.
        """
        self._ptr[i].mipmapLevelBias = value
    @property
    def mipmapLevelBias(self):
        return self.get_mipmapLevelBias(0)
    @mipmapLevelBias.setter
    def mipmapLevelBias(self, float value):
        self.set_mipmapLevelBias(0,value)

    def get_minMipmapLevelClamp(self, i):
        """Get value ``minMipmapLevelClamp`` of ``self._ptr[i]``.
        """
        return self._ptr[i].minMipmapLevelClamp
    def set_minMipmapLevelClamp(self, i, float value):
        """Set value ``minMipmapLevelClamp`` of ``self._ptr[i]``.
        """
        self._ptr[i].minMipmapLevelClamp = value
    @property
    def minMipmapLevelClamp(self):
        return self.get_minMipmapLevelClamp(0)
    @minMipmapLevelClamp.setter
    def minMipmapLevelClamp(self, float value):
        self.set_minMipmapLevelClamp(0,value)

    def get_maxMipmapLevelClamp(self, i):
        """Get value ``maxMipmapLevelClamp`` of ``self._ptr[i]``.
        """
        return self._ptr[i].maxMipmapLevelClamp
    def set_maxMipmapLevelClamp(self, i, float value):
        """Set value ``maxMipmapLevelClamp`` of ``self._ptr[i]``.
        """
        self._ptr[i].maxMipmapLevelClamp = value
    @property
    def maxMipmapLevelClamp(self):
        return self.get_maxMipmapLevelClamp(0)
    @maxMipmapLevelClamp.setter
    def maxMipmapLevelClamp(self, float value):
        self.set_maxMipmapLevelClamp(0,value)

    def get_borderColor(self, i):
        """Get value of ``borderColor`` of ``self._ptr[i]``.
        """
        return self._ptr[i].borderColor
    # TODO add setters
    #def set_borderColor(self, i, float[4] value):
    #    """Set value ``borderColor`` of ``self._ptr[i]``.
    #    """
    #    self._ptr[i].borderColor = value
    @property
    def borderColor(self):
        return self.get_borderColor(0)
    # TODO add setters
    #@borderColor.setter
    #def borderColor(self, float[4] value):
    #    self.set_borderColor(0,value)

    def get_reserved(self, i):
        """Get value of ``reserved`` of ``self._ptr[i]``.
        """
        return self._ptr[i].reserved
    # TODO add setters
    #def set_reserved(self, i, int[12] value):
    #    """Set value ``reserved`` of ``self._ptr[i]``.
    #    """
    #    self._ptr[i].reserved = value
    @property
    def reserved(self):
        return self.get_reserved(0)
    # TODO add setters
    #@reserved.setter
    #def reserved(self, int[12] value):
    #    self.set_reserved(0,value)

    @staticmethod
    def PROPERTIES():
        return ["filterMode","flags","maxAnisotropy","mipmapFilterMode","mipmapLevelBias","minMipmapLevelClamp","maxMipmapLevelClamp","borderColor","reserved"]

    def __contains__(self,item):
        properties = self.PROPERTIES()
        return item in properties

    def __getitem__(self,item):
        properties = self.PROPERTIES()
        if isinstance(item,int):
            if item < 0 or item >= len(properties):
                raise IndexError()
            return getattr(self,properties[item])
        raise ValueError("'item' type must be 'int'")


HIP_TEXTURE_DESC = HIP_TEXTURE_DESC_st

class _hipResourceViewFormat__Base(enum.IntEnum):
    """Empty enum base class that allows subclassing.
    """
    pass
class hipResourceViewFormat(_hipResourceViewFormat__Base):
    hipResViewFormatNone = chip.hipResViewFormatNone
    hipResViewFormatUnsignedChar1 = chip.hipResViewFormatUnsignedChar1
    hipResViewFormatUnsignedChar2 = chip.hipResViewFormatUnsignedChar2
    hipResViewFormatUnsignedChar4 = chip.hipResViewFormatUnsignedChar4
    hipResViewFormatSignedChar1 = chip.hipResViewFormatSignedChar1
    hipResViewFormatSignedChar2 = chip.hipResViewFormatSignedChar2
    hipResViewFormatSignedChar4 = chip.hipResViewFormatSignedChar4
    hipResViewFormatUnsignedShort1 = chip.hipResViewFormatUnsignedShort1
    hipResViewFormatUnsignedShort2 = chip.hipResViewFormatUnsignedShort2
    hipResViewFormatUnsignedShort4 = chip.hipResViewFormatUnsignedShort4
    hipResViewFormatSignedShort1 = chip.hipResViewFormatSignedShort1
    hipResViewFormatSignedShort2 = chip.hipResViewFormatSignedShort2
    hipResViewFormatSignedShort4 = chip.hipResViewFormatSignedShort4
    hipResViewFormatUnsignedInt1 = chip.hipResViewFormatUnsignedInt1
    hipResViewFormatUnsignedInt2 = chip.hipResViewFormatUnsignedInt2
    hipResViewFormatUnsignedInt4 = chip.hipResViewFormatUnsignedInt4
    hipResViewFormatSignedInt1 = chip.hipResViewFormatSignedInt1
    hipResViewFormatSignedInt2 = chip.hipResViewFormatSignedInt2
    hipResViewFormatSignedInt4 = chip.hipResViewFormatSignedInt4
    hipResViewFormatHalf1 = chip.hipResViewFormatHalf1
    hipResViewFormatHalf2 = chip.hipResViewFormatHalf2
    hipResViewFormatHalf4 = chip.hipResViewFormatHalf4
    hipResViewFormatFloat1 = chip.hipResViewFormatFloat1
    hipResViewFormatFloat2 = chip.hipResViewFormatFloat2
    hipResViewFormatFloat4 = chip.hipResViewFormatFloat4
    hipResViewFormatUnsignedBlockCompressed1 = chip.hipResViewFormatUnsignedBlockCompressed1
    hipResViewFormatUnsignedBlockCompressed2 = chip.hipResViewFormatUnsignedBlockCompressed2
    hipResViewFormatUnsignedBlockCompressed3 = chip.hipResViewFormatUnsignedBlockCompressed3
    hipResViewFormatUnsignedBlockCompressed4 = chip.hipResViewFormatUnsignedBlockCompressed4
    hipResViewFormatSignedBlockCompressed4 = chip.hipResViewFormatSignedBlockCompressed4
    hipResViewFormatUnsignedBlockCompressed5 = chip.hipResViewFormatUnsignedBlockCompressed5
    hipResViewFormatSignedBlockCompressed5 = chip.hipResViewFormatSignedBlockCompressed5
    hipResViewFormatUnsignedBlockCompressed6H = chip.hipResViewFormatUnsignedBlockCompressed6H
    hipResViewFormatSignedBlockCompressed6H = chip.hipResViewFormatSignedBlockCompressed6H
    hipResViewFormatUnsignedBlockCompressed7 = chip.hipResViewFormatUnsignedBlockCompressed7
    @staticmethod
    def ctypes_type():
        """The type of the enum constants as ctypes type."""
        return ctypes.c_uint 


class _HIPresourceViewFormat_enum__Base(enum.IntEnum):
    """Empty enum base class that allows subclassing.
    """
    pass
class HIPresourceViewFormat_enum(_HIPresourceViewFormat_enum__Base):
    HIP_RES_VIEW_FORMAT_NONE = chip.HIP_RES_VIEW_FORMAT_NONE
    HIP_RES_VIEW_FORMAT_UINT_1X8 = chip.HIP_RES_VIEW_FORMAT_UINT_1X8
    HIP_RES_VIEW_FORMAT_UINT_2X8 = chip.HIP_RES_VIEW_FORMAT_UINT_2X8
    HIP_RES_VIEW_FORMAT_UINT_4X8 = chip.HIP_RES_VIEW_FORMAT_UINT_4X8
    HIP_RES_VIEW_FORMAT_SINT_1X8 = chip.HIP_RES_VIEW_FORMAT_SINT_1X8
    HIP_RES_VIEW_FORMAT_SINT_2X8 = chip.HIP_RES_VIEW_FORMAT_SINT_2X8
    HIP_RES_VIEW_FORMAT_SINT_4X8 = chip.HIP_RES_VIEW_FORMAT_SINT_4X8
    HIP_RES_VIEW_FORMAT_UINT_1X16 = chip.HIP_RES_VIEW_FORMAT_UINT_1X16
    HIP_RES_VIEW_FORMAT_UINT_2X16 = chip.HIP_RES_VIEW_FORMAT_UINT_2X16
    HIP_RES_VIEW_FORMAT_UINT_4X16 = chip.HIP_RES_VIEW_FORMAT_UINT_4X16
    HIP_RES_VIEW_FORMAT_SINT_1X16 = chip.HIP_RES_VIEW_FORMAT_SINT_1X16
    HIP_RES_VIEW_FORMAT_SINT_2X16 = chip.HIP_RES_VIEW_FORMAT_SINT_2X16
    HIP_RES_VIEW_FORMAT_SINT_4X16 = chip.HIP_RES_VIEW_FORMAT_SINT_4X16
    HIP_RES_VIEW_FORMAT_UINT_1X32 = chip.HIP_RES_VIEW_FORMAT_UINT_1X32
    HIP_RES_VIEW_FORMAT_UINT_2X32 = chip.HIP_RES_VIEW_FORMAT_UINT_2X32
    HIP_RES_VIEW_FORMAT_UINT_4X32 = chip.HIP_RES_VIEW_FORMAT_UINT_4X32
    HIP_RES_VIEW_FORMAT_SINT_1X32 = chip.HIP_RES_VIEW_FORMAT_SINT_1X32
    HIP_RES_VIEW_FORMAT_SINT_2X32 = chip.HIP_RES_VIEW_FORMAT_SINT_2X32
    HIP_RES_VIEW_FORMAT_SINT_4X32 = chip.HIP_RES_VIEW_FORMAT_SINT_4X32
    HIP_RES_VIEW_FORMAT_FLOAT_1X16 = chip.HIP_RES_VIEW_FORMAT_FLOAT_1X16
    HIP_RES_VIEW_FORMAT_FLOAT_2X16 = chip.HIP_RES_VIEW_FORMAT_FLOAT_2X16
    HIP_RES_VIEW_FORMAT_FLOAT_4X16 = chip.HIP_RES_VIEW_FORMAT_FLOAT_4X16
    HIP_RES_VIEW_FORMAT_FLOAT_1X32 = chip.HIP_RES_VIEW_FORMAT_FLOAT_1X32
    HIP_RES_VIEW_FORMAT_FLOAT_2X32 = chip.HIP_RES_VIEW_FORMAT_FLOAT_2X32
    HIP_RES_VIEW_FORMAT_FLOAT_4X32 = chip.HIP_RES_VIEW_FORMAT_FLOAT_4X32
    HIP_RES_VIEW_FORMAT_UNSIGNED_BC1 = chip.HIP_RES_VIEW_FORMAT_UNSIGNED_BC1
    HIP_RES_VIEW_FORMAT_UNSIGNED_BC2 = chip.HIP_RES_VIEW_FORMAT_UNSIGNED_BC2
    HIP_RES_VIEW_FORMAT_UNSIGNED_BC3 = chip.HIP_RES_VIEW_FORMAT_UNSIGNED_BC3
    HIP_RES_VIEW_FORMAT_UNSIGNED_BC4 = chip.HIP_RES_VIEW_FORMAT_UNSIGNED_BC4
    HIP_RES_VIEW_FORMAT_SIGNED_BC4 = chip.HIP_RES_VIEW_FORMAT_SIGNED_BC4
    HIP_RES_VIEW_FORMAT_UNSIGNED_BC5 = chip.HIP_RES_VIEW_FORMAT_UNSIGNED_BC5
    HIP_RES_VIEW_FORMAT_SIGNED_BC5 = chip.HIP_RES_VIEW_FORMAT_SIGNED_BC5
    HIP_RES_VIEW_FORMAT_UNSIGNED_BC6H = chip.HIP_RES_VIEW_FORMAT_UNSIGNED_BC6H
    HIP_RES_VIEW_FORMAT_SIGNED_BC6H = chip.HIP_RES_VIEW_FORMAT_SIGNED_BC6H
    HIP_RES_VIEW_FORMAT_UNSIGNED_BC7 = chip.HIP_RES_VIEW_FORMAT_UNSIGNED_BC7
    @staticmethod
    def ctypes_type():
        """The type of the enum constants as ctypes type."""
        return ctypes.c_uint 


HIPresourceViewFormat = HIPresourceViewFormat_enum

cdef class hipResourceDesc_union_0_struct_0:
    # members declared in pxd file

    def __cinit__(self):
        self._ptr = NULL
        self.ptr_owner = False
        self._py_buffer_acquired = False

    @staticmethod
    cdef hipResourceDesc_union_0_struct_0 from_ptr(chip.hipResourceDesc_union_0_struct_0* ptr, bint owner=False):
        """Factory function to create ``hipResourceDesc_union_0_struct_0`` objects from
        given ``chip.hipResourceDesc_union_0_struct_0`` pointer.

        Setting ``owner`` flag to ``True`` causes
        the extension type to ``free`` the structure pointed to by ``ptr``
        when the wrapper object is deallocated.
        """
        # Fast call to __new__() that bypasses the __init__() constructor.
        cdef hipResourceDesc_union_0_struct_0 wrapper = hipResourceDesc_union_0_struct_0.__new__(hipResourceDesc_union_0_struct_0)
        wrapper._ptr = ptr
        wrapper.ptr_owner = owner
        return wrapper

    @staticmethod
    cdef hipResourceDesc_union_0_struct_0 from_pyobj(object pyobj):
        """Derives a hipResourceDesc_union_0_struct_0 from a Python object.

        Derives a hipResourceDesc_union_0_struct_0 from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``hipResourceDesc_union_0_struct_0`` reference, this method
        returns it directly. No new ``hipResourceDesc_union_0_struct_0`` is created in this case.

        Args:
            pyobj (object): Must be either ``None``, a simple, contiguous buffer according to the buffer protocol,
                            or of type ``hipResourceDesc_union_0_struct_0``, ``int``, or ``ctypes.c_void_p``

        Note:
            This routine does not perform a copy but returns the original ``pyobj``
            if ``pyobj`` is an instance of hipResourceDesc_union_0_struct_0!
        """
        cdef hipResourceDesc_union_0_struct_0 wrapper = hipResourceDesc_union_0_struct_0.__new__(hipResourceDesc_union_0_struct_0)
        cdef dict cuda_array_interface = getattr(pyobj, "__cuda_array_interface__", None)

        if pyobj is None:
            wrapper._ptr = NULL
        elif isinstance(pyobj,hipResourceDesc_union_0_struct_0):
            return pyobj
        elif isinstance(pyobj,int):
            wrapper._ptr = <chip.hipResourceDesc_union_0_struct_0*>cpython.long.PyLong_AsVoidPtr(pyobj)
        elif isinstance(pyobj,ctypes.c_void_p):
            wrapper._ptr = <chip.hipResourceDesc_union_0_struct_0*>cpython.long.PyLong_AsVoidPtr(pyobj.value) if pyobj.value != None else NULL
        elif cuda_array_interface != None:
            if not "data" in cuda_array_interface:
                raise ValueError("input object has '__cuda_array_interface__' attribute but the dict has no 'data' key")
            ptr_as_int = cuda_array_interface["data"][0]
            wrapper._ptr = <chip.hipResourceDesc_union_0_struct_0*>cpython.long.PyLong_AsVoidPtr(ptr_as_int)
        elif cpython.buffer.PyObject_CheckBuffer(pyobj):
            err = cpython.buffer.PyObject_GetBuffer( 
                pyobj,
                &wrapper._py_buffer, 
                cpython.buffer.PyBUF_SIMPLE | cpython.buffer.PyBUF_ANY_CONTIGUOUS
            )
            if err == -1:
                raise RuntimeError("failed to create simple, contiguous Py_buffer from Python object")
            wrapper._py_buffer_acquired = True
            wrapper._ptr = <chip.hipResourceDesc_union_0_struct_0*>wrapper._py_buffer.buf
        else:
            raise TypeError(f"unsupported input type: '{str(type(pyobj))}'")
        return wrapper
    def __dealloc__(self):
        # Release the buffer handle
        if self._py_buffer_acquired is True:
            cpython.buffer.PyBuffer_Release(&self._py_buffer)
        # De-allocate if not null and flag is set
        if self._ptr is not NULL and self.ptr_owner is True:
            stdlib.free(self._ptr)
            self._ptr = NULL
    @staticmethod
    cdef __allocate(chip.hipResourceDesc_union_0_struct_0** ptr):
        ptr[0] = <chip.hipResourceDesc_union_0_struct_0*>stdlib.malloc(sizeof(chip.hipResourceDesc_union_0_struct_0))

        if ptr[0] is NULL:
            raise MemoryError
        # TODO init values, if present

    @staticmethod
    cdef hipResourceDesc_union_0_struct_0 new():
        """Factory function to create hipResourceDesc_union_0_struct_0 objects with
        newly allocated chip.hipResourceDesc_union_0_struct_0"""
        cdef chip.hipResourceDesc_union_0_struct_0* ptr
        hipResourceDesc_union_0_struct_0.__allocate(&ptr)
        return hipResourceDesc_union_0_struct_0.from_ptr(ptr, owner=True)
   
    # False
    # False
    def __init__(self,**kwargs):
        hipResourceDesc_union_0_struct_0.__allocate(&self._ptr)
        self.ptr_owner = True
        attribs = self.PROPERTIES()
        used_attribs = set()
        valid_names = ", ".join(["'"+p+"'" for p in attribs])
        for k,v in kwargs.items():
            if k in used_attribs:
                raise KeyError(f"argument '{k}' has already been specified as positional argument.")
            elif k not in attribs:
                raise KeyError(f"'{k}' is no valid property name. Valid names: {valid_names}")
            setattr(self,k,v)
    
    def __int__(self):
        """Returns the data's address as long integer."""
        return cpython.long.PyLong_FromVoidPtr(self._ptr)
    def __repr__(self):
        return f"<hipResourceDesc_union_0_struct_0 object, self.ptr={int(self)}>"
    def as_c_void_p(self):
        """Returns the data's address as `ctypes.c_void_p`"""
        return ctypes.c_void_p(int(self))
    @staticmethod
    def PROPERTIES():
        return []

    def __contains__(self,item):
        properties = self.PROPERTIES()
        return item in properties

    def __getitem__(self,item):
        properties = self.PROPERTIES()
        if isinstance(item,int):
            if item < 0 or item >= len(properties):
                raise IndexError()
            return getattr(self,properties[item])
        raise ValueError("'item' type must be 'int'")


cdef class hipResourceDesc_union_0_struct_1:
    # members declared in pxd file

    def __cinit__(self):
        self._ptr = NULL
        self.ptr_owner = False
        self._py_buffer_acquired = False

    @staticmethod
    cdef hipResourceDesc_union_0_struct_1 from_ptr(chip.hipResourceDesc_union_0_struct_1* ptr, bint owner=False):
        """Factory function to create ``hipResourceDesc_union_0_struct_1`` objects from
        given ``chip.hipResourceDesc_union_0_struct_1`` pointer.

        Setting ``owner`` flag to ``True`` causes
        the extension type to ``free`` the structure pointed to by ``ptr``
        when the wrapper object is deallocated.
        """
        # Fast call to __new__() that bypasses the __init__() constructor.
        cdef hipResourceDesc_union_0_struct_1 wrapper = hipResourceDesc_union_0_struct_1.__new__(hipResourceDesc_union_0_struct_1)
        wrapper._ptr = ptr
        wrapper.ptr_owner = owner
        return wrapper

    @staticmethod
    cdef hipResourceDesc_union_0_struct_1 from_pyobj(object pyobj):
        """Derives a hipResourceDesc_union_0_struct_1 from a Python object.

        Derives a hipResourceDesc_union_0_struct_1 from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``hipResourceDesc_union_0_struct_1`` reference, this method
        returns it directly. No new ``hipResourceDesc_union_0_struct_1`` is created in this case.

        Args:
            pyobj (object): Must be either ``None``, a simple, contiguous buffer according to the buffer protocol,
                            or of type ``hipResourceDesc_union_0_struct_1``, ``int``, or ``ctypes.c_void_p``

        Note:
            This routine does not perform a copy but returns the original ``pyobj``
            if ``pyobj`` is an instance of hipResourceDesc_union_0_struct_1!
        """
        cdef hipResourceDesc_union_0_struct_1 wrapper = hipResourceDesc_union_0_struct_1.__new__(hipResourceDesc_union_0_struct_1)
        cdef dict cuda_array_interface = getattr(pyobj, "__cuda_array_interface__", None)

        if pyobj is None:
            wrapper._ptr = NULL
        elif isinstance(pyobj,hipResourceDesc_union_0_struct_1):
            return pyobj
        elif isinstance(pyobj,int):
            wrapper._ptr = <chip.hipResourceDesc_union_0_struct_1*>cpython.long.PyLong_AsVoidPtr(pyobj)
        elif isinstance(pyobj,ctypes.c_void_p):
            wrapper._ptr = <chip.hipResourceDesc_union_0_struct_1*>cpython.long.PyLong_AsVoidPtr(pyobj.value) if pyobj.value != None else NULL
        elif cuda_array_interface != None:
            if not "data" in cuda_array_interface:
                raise ValueError("input object has '__cuda_array_interface__' attribute but the dict has no 'data' key")
            ptr_as_int = cuda_array_interface["data"][0]
            wrapper._ptr = <chip.hipResourceDesc_union_0_struct_1*>cpython.long.PyLong_AsVoidPtr(ptr_as_int)
        elif cpython.buffer.PyObject_CheckBuffer(pyobj):
            err = cpython.buffer.PyObject_GetBuffer( 
                pyobj,
                &wrapper._py_buffer, 
                cpython.buffer.PyBUF_SIMPLE | cpython.buffer.PyBUF_ANY_CONTIGUOUS
            )
            if err == -1:
                raise RuntimeError("failed to create simple, contiguous Py_buffer from Python object")
            wrapper._py_buffer_acquired = True
            wrapper._ptr = <chip.hipResourceDesc_union_0_struct_1*>wrapper._py_buffer.buf
        else:
            raise TypeError(f"unsupported input type: '{str(type(pyobj))}'")
        return wrapper
    def __dealloc__(self):
        # Release the buffer handle
        if self._py_buffer_acquired is True:
            cpython.buffer.PyBuffer_Release(&self._py_buffer)
        # De-allocate if not null and flag is set
        if self._ptr is not NULL and self.ptr_owner is True:
            stdlib.free(self._ptr)
            self._ptr = NULL
    @staticmethod
    cdef __allocate(chip.hipResourceDesc_union_0_struct_1** ptr):
        ptr[0] = <chip.hipResourceDesc_union_0_struct_1*>stdlib.malloc(sizeof(chip.hipResourceDesc_union_0_struct_1))

        if ptr[0] is NULL:
            raise MemoryError
        # TODO init values, if present

    @staticmethod
    cdef hipResourceDesc_union_0_struct_1 new():
        """Factory function to create hipResourceDesc_union_0_struct_1 objects with
        newly allocated chip.hipResourceDesc_union_0_struct_1"""
        cdef chip.hipResourceDesc_union_0_struct_1* ptr
        hipResourceDesc_union_0_struct_1.__allocate(&ptr)
        return hipResourceDesc_union_0_struct_1.from_ptr(ptr, owner=True)
   
    # False
    # False
    def __init__(self,**kwargs):
        hipResourceDesc_union_0_struct_1.__allocate(&self._ptr)
        self.ptr_owner = True
        attribs = self.PROPERTIES()
        used_attribs = set()
        valid_names = ", ".join(["'"+p+"'" for p in attribs])
        for k,v in kwargs.items():
            if k in used_attribs:
                raise KeyError(f"argument '{k}' has already been specified as positional argument.")
            elif k not in attribs:
                raise KeyError(f"'{k}' is no valid property name. Valid names: {valid_names}")
            setattr(self,k,v)
    
    def __int__(self):
        """Returns the data's address as long integer."""
        return cpython.long.PyLong_FromVoidPtr(self._ptr)
    def __repr__(self):
        return f"<hipResourceDesc_union_0_struct_1 object, self.ptr={int(self)}>"
    def as_c_void_p(self):
        """Returns the data's address as `ctypes.c_void_p`"""
        return ctypes.c_void_p(int(self))
    @staticmethod
    def PROPERTIES():
        return []

    def __contains__(self,item):
        properties = self.PROPERTIES()
        return item in properties

    def __getitem__(self,item):
        properties = self.PROPERTIES()
        if isinstance(item,int):
            if item < 0 or item >= len(properties):
                raise IndexError()
            return getattr(self,properties[item])
        raise ValueError("'item' type must be 'int'")


cdef class hipResourceDesc_union_0_struct_2:
    # members declared in pxd file

    def __cinit__(self):
        self._ptr = NULL
        self.ptr_owner = False
        self._py_buffer_acquired = False

    @staticmethod
    cdef hipResourceDesc_union_0_struct_2 from_ptr(chip.hipResourceDesc_union_0_struct_2* ptr, bint owner=False):
        """Factory function to create ``hipResourceDesc_union_0_struct_2`` objects from
        given ``chip.hipResourceDesc_union_0_struct_2`` pointer.

        Setting ``owner`` flag to ``True`` causes
        the extension type to ``free`` the structure pointed to by ``ptr``
        when the wrapper object is deallocated.
        """
        # Fast call to __new__() that bypasses the __init__() constructor.
        cdef hipResourceDesc_union_0_struct_2 wrapper = hipResourceDesc_union_0_struct_2.__new__(hipResourceDesc_union_0_struct_2)
        wrapper._ptr = ptr
        wrapper.ptr_owner = owner
        return wrapper

    @staticmethod
    cdef hipResourceDesc_union_0_struct_2 from_pyobj(object pyobj):
        """Derives a hipResourceDesc_union_0_struct_2 from a Python object.

        Derives a hipResourceDesc_union_0_struct_2 from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``hipResourceDesc_union_0_struct_2`` reference, this method
        returns it directly. No new ``hipResourceDesc_union_0_struct_2`` is created in this case.

        Args:
            pyobj (object): Must be either ``None``, a simple, contiguous buffer according to the buffer protocol,
                            or of type ``hipResourceDesc_union_0_struct_2``, ``int``, or ``ctypes.c_void_p``

        Note:
            This routine does not perform a copy but returns the original ``pyobj``
            if ``pyobj`` is an instance of hipResourceDesc_union_0_struct_2!
        """
        cdef hipResourceDesc_union_0_struct_2 wrapper = hipResourceDesc_union_0_struct_2.__new__(hipResourceDesc_union_0_struct_2)
        cdef dict cuda_array_interface = getattr(pyobj, "__cuda_array_interface__", None)

        if pyobj is None:
            wrapper._ptr = NULL
        elif isinstance(pyobj,hipResourceDesc_union_0_struct_2):
            return pyobj
        elif isinstance(pyobj,int):
            wrapper._ptr = <chip.hipResourceDesc_union_0_struct_2*>cpython.long.PyLong_AsVoidPtr(pyobj)
        elif isinstance(pyobj,ctypes.c_void_p):
            wrapper._ptr = <chip.hipResourceDesc_union_0_struct_2*>cpython.long.PyLong_AsVoidPtr(pyobj.value) if pyobj.value != None else NULL
        elif cuda_array_interface != None:
            if not "data" in cuda_array_interface:
                raise ValueError("input object has '__cuda_array_interface__' attribute but the dict has no 'data' key")
            ptr_as_int = cuda_array_interface["data"][0]
            wrapper._ptr = <chip.hipResourceDesc_union_0_struct_2*>cpython.long.PyLong_AsVoidPtr(ptr_as_int)
        elif cpython.buffer.PyObject_CheckBuffer(pyobj):
            err = cpython.buffer.PyObject_GetBuffer( 
                pyobj,
                &wrapper._py_buffer, 
                cpython.buffer.PyBUF_SIMPLE | cpython.buffer.PyBUF_ANY_CONTIGUOUS
            )
            if err == -1:
                raise RuntimeError("failed to create simple, contiguous Py_buffer from Python object")
            wrapper._py_buffer_acquired = True
            wrapper._ptr = <chip.hipResourceDesc_union_0_struct_2*>wrapper._py_buffer.buf
        else:
            raise TypeError(f"unsupported input type: '{str(type(pyobj))}'")
        return wrapper
    def __dealloc__(self):
        # Release the buffer handle
        if self._py_buffer_acquired is True:
            cpython.buffer.PyBuffer_Release(&self._py_buffer)
        # De-allocate if not null and flag is set
        if self._ptr is not NULL and self.ptr_owner is True:
            stdlib.free(self._ptr)
            self._ptr = NULL
    @staticmethod
    cdef __allocate(chip.hipResourceDesc_union_0_struct_2** ptr):
        ptr[0] = <chip.hipResourceDesc_union_0_struct_2*>stdlib.malloc(sizeof(chip.hipResourceDesc_union_0_struct_2))

        if ptr[0] is NULL:
            raise MemoryError
        # TODO init values, if present

    @staticmethod
    cdef hipResourceDesc_union_0_struct_2 new():
        """Factory function to create hipResourceDesc_union_0_struct_2 objects with
        newly allocated chip.hipResourceDesc_union_0_struct_2"""
        cdef chip.hipResourceDesc_union_0_struct_2* ptr
        hipResourceDesc_union_0_struct_2.__allocate(&ptr)
        return hipResourceDesc_union_0_struct_2.from_ptr(ptr, owner=True)
   
    def __init__(self,*args,**kwargs):
        hipResourceDesc_union_0_struct_2.__allocate(&self._ptr)
        self.ptr_owner = True
        attribs = self.PROPERTIES()
        used_attribs = set()
        if len(args) > len(attribs):
            raise ValueError("More positional arguments specified than this type has properties.")
        for i,v in enumerate(args):
            setattr(self,attribs[i],v)
            used_attribs.add(attribs[i])
        valid_names = ", ".join(["'"+p+"'" for p in attribs])
        for k,v in kwargs.items():
            if k in used_attribs:
                raise KeyError(f"argument '{k}' has already been specified as positional argument.")
            elif k not in attribs:
                raise KeyError(f"'{k}' is no valid property name. Valid names: {valid_names}")
            setattr(self,k,v)
    
    def __int__(self):
        """Returns the data's address as long integer."""
        return cpython.long.PyLong_FromVoidPtr(self._ptr)
    def __repr__(self):
        return f"<hipResourceDesc_union_0_struct_2 object, self.ptr={int(self)}>"
    def as_c_void_p(self):
        """Returns the data's address as `ctypes.c_void_p`"""
        return ctypes.c_void_p(int(self))
    def get_devPtr(self, i):
        """Get value ``devPtr`` of ``self._ptr[i]``.
        """
        return hip._util.types.DataHandle.from_ptr(self._ptr[i].devPtr)
    def set_devPtr(self, i, object value):
        """Set value ``devPtr`` of ``self._ptr[i]``.

        Note:
            This can be dangerous if the pointer is from a python object
            that is later on garbage collected.
        """
        self._ptr[i].devPtr = <void *>cpython.long.PyLong_AsVoidPtr(int(hip._util.types.DataHandle.from_pyobj(value)))
    @property
    def devPtr(self):
        """
        Note:
            Setting this devPtr can be dangerous if the underlying pointer is from a python object that
            is later on garbage collected.
        """
        return self.get_devPtr(0)
    @devPtr.setter
    def devPtr(self, object value):
        self.set_devPtr(0,value)

    def get_desc(self, i):
        """Get value of ``desc`` of ``self._ptr[i]``.
        """
        return hipChannelFormatDesc.from_ptr(&self._ptr[i].desc)
    @property
    def desc(self):
        return self.get_desc(0)

    def get_sizeInBytes(self, i):
        """Get value ``sizeInBytes`` of ``self._ptr[i]``.
        """
        return self._ptr[i].sizeInBytes
    def set_sizeInBytes(self, i, unsigned long value):
        """Set value ``sizeInBytes`` of ``self._ptr[i]``.
        """
        self._ptr[i].sizeInBytes = value
    @property
    def sizeInBytes(self):
        return self.get_sizeInBytes(0)
    @sizeInBytes.setter
    def sizeInBytes(self, unsigned long value):
        self.set_sizeInBytes(0,value)

    @staticmethod
    def PROPERTIES():
        return ["devPtr","desc","sizeInBytes"]

    def __contains__(self,item):
        properties = self.PROPERTIES()
        return item in properties

    def __getitem__(self,item):
        properties = self.PROPERTIES()
        if isinstance(item,int):
            if item < 0 or item >= len(properties):
                raise IndexError()
            return getattr(self,properties[item])
        raise ValueError("'item' type must be 'int'")


cdef class hipResourceDesc_union_0_struct_3:
    # members declared in pxd file

    def __cinit__(self):
        self._ptr = NULL
        self.ptr_owner = False
        self._py_buffer_acquired = False

    @staticmethod
    cdef hipResourceDesc_union_0_struct_3 from_ptr(chip.hipResourceDesc_union_0_struct_3* ptr, bint owner=False):
        """Factory function to create ``hipResourceDesc_union_0_struct_3`` objects from
        given ``chip.hipResourceDesc_union_0_struct_3`` pointer.

        Setting ``owner`` flag to ``True`` causes
        the extension type to ``free`` the structure pointed to by ``ptr``
        when the wrapper object is deallocated.
        """
        # Fast call to __new__() that bypasses the __init__() constructor.
        cdef hipResourceDesc_union_0_struct_3 wrapper = hipResourceDesc_union_0_struct_3.__new__(hipResourceDesc_union_0_struct_3)
        wrapper._ptr = ptr
        wrapper.ptr_owner = owner
        return wrapper

    @staticmethod
    cdef hipResourceDesc_union_0_struct_3 from_pyobj(object pyobj):
        """Derives a hipResourceDesc_union_0_struct_3 from a Python object.

        Derives a hipResourceDesc_union_0_struct_3 from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``hipResourceDesc_union_0_struct_3`` reference, this method
        returns it directly. No new ``hipResourceDesc_union_0_struct_3`` is created in this case.

        Args:
            pyobj (object): Must be either ``None``, a simple, contiguous buffer according to the buffer protocol,
                            or of type ``hipResourceDesc_union_0_struct_3``, ``int``, or ``ctypes.c_void_p``

        Note:
            This routine does not perform a copy but returns the original ``pyobj``
            if ``pyobj`` is an instance of hipResourceDesc_union_0_struct_3!
        """
        cdef hipResourceDesc_union_0_struct_3 wrapper = hipResourceDesc_union_0_struct_3.__new__(hipResourceDesc_union_0_struct_3)
        cdef dict cuda_array_interface = getattr(pyobj, "__cuda_array_interface__", None)

        if pyobj is None:
            wrapper._ptr = NULL
        elif isinstance(pyobj,hipResourceDesc_union_0_struct_3):
            return pyobj
        elif isinstance(pyobj,int):
            wrapper._ptr = <chip.hipResourceDesc_union_0_struct_3*>cpython.long.PyLong_AsVoidPtr(pyobj)
        elif isinstance(pyobj,ctypes.c_void_p):
            wrapper._ptr = <chip.hipResourceDesc_union_0_struct_3*>cpython.long.PyLong_AsVoidPtr(pyobj.value) if pyobj.value != None else NULL
        elif cuda_array_interface != None:
            if not "data" in cuda_array_interface:
                raise ValueError("input object has '__cuda_array_interface__' attribute but the dict has no 'data' key")
            ptr_as_int = cuda_array_interface["data"][0]
            wrapper._ptr = <chip.hipResourceDesc_union_0_struct_3*>cpython.long.PyLong_AsVoidPtr(ptr_as_int)
        elif cpython.buffer.PyObject_CheckBuffer(pyobj):
            err = cpython.buffer.PyObject_GetBuffer( 
                pyobj,
                &wrapper._py_buffer, 
                cpython.buffer.PyBUF_SIMPLE | cpython.buffer.PyBUF_ANY_CONTIGUOUS
            )
            if err == -1:
                raise RuntimeError("failed to create simple, contiguous Py_buffer from Python object")
            wrapper._py_buffer_acquired = True
            wrapper._ptr = <chip.hipResourceDesc_union_0_struct_3*>wrapper._py_buffer.buf
        else:
            raise TypeError(f"unsupported input type: '{str(type(pyobj))}'")
        return wrapper
    def __dealloc__(self):
        # Release the buffer handle
        if self._py_buffer_acquired is True:
            cpython.buffer.PyBuffer_Release(&self._py_buffer)
        # De-allocate if not null and flag is set
        if self._ptr is not NULL and self.ptr_owner is True:
            stdlib.free(self._ptr)
            self._ptr = NULL
    @staticmethod
    cdef __allocate(chip.hipResourceDesc_union_0_struct_3** ptr):
        ptr[0] = <chip.hipResourceDesc_union_0_struct_3*>stdlib.malloc(sizeof(chip.hipResourceDesc_union_0_struct_3))

        if ptr[0] is NULL:
            raise MemoryError
        # TODO init values, if present

    @staticmethod
    cdef hipResourceDesc_union_0_struct_3 new():
        """Factory function to create hipResourceDesc_union_0_struct_3 objects with
        newly allocated chip.hipResourceDesc_union_0_struct_3"""
        cdef chip.hipResourceDesc_union_0_struct_3* ptr
        hipResourceDesc_union_0_struct_3.__allocate(&ptr)
        return hipResourceDesc_union_0_struct_3.from_ptr(ptr, owner=True)
   
    def __init__(self,*args,**kwargs):
        hipResourceDesc_union_0_struct_3.__allocate(&self._ptr)
        self.ptr_owner = True
        attribs = self.PROPERTIES()
        used_attribs = set()
        if len(args) > len(attribs):
            raise ValueError("More positional arguments specified than this type has properties.")
        for i,v in enumerate(args):
            setattr(self,attribs[i],v)
            used_attribs.add(attribs[i])
        valid_names = ", ".join(["'"+p+"'" for p in attribs])
        for k,v in kwargs.items():
            if k in used_attribs:
                raise KeyError(f"argument '{k}' has already been specified as positional argument.")
            elif k not in attribs:
                raise KeyError(f"'{k}' is no valid property name. Valid names: {valid_names}")
            setattr(self,k,v)
    
    def __int__(self):
        """Returns the data's address as long integer."""
        return cpython.long.PyLong_FromVoidPtr(self._ptr)
    def __repr__(self):
        return f"<hipResourceDesc_union_0_struct_3 object, self.ptr={int(self)}>"
    def as_c_void_p(self):
        """Returns the data's address as `ctypes.c_void_p`"""
        return ctypes.c_void_p(int(self))
    def get_devPtr(self, i):
        """Get value ``devPtr`` of ``self._ptr[i]``.
        """
        return hip._util.types.DataHandle.from_ptr(self._ptr[i].devPtr)
    def set_devPtr(self, i, object value):
        """Set value ``devPtr`` of ``self._ptr[i]``.

        Note:
            This can be dangerous if the pointer is from a python object
            that is later on garbage collected.
        """
        self._ptr[i].devPtr = <void *>cpython.long.PyLong_AsVoidPtr(int(hip._util.types.DataHandle.from_pyobj(value)))
    @property
    def devPtr(self):
        """
        Note:
            Setting this devPtr can be dangerous if the underlying pointer is from a python object that
            is later on garbage collected.
        """
        return self.get_devPtr(0)
    @devPtr.setter
    def devPtr(self, object value):
        self.set_devPtr(0,value)

    def get_desc(self, i):
        """Get value of ``desc`` of ``self._ptr[i]``.
        """
        return hipChannelFormatDesc.from_ptr(&self._ptr[i].desc)
    @property
    def desc(self):
        return self.get_desc(0)

    def get_width(self, i):
        """Get value ``width`` of ``self._ptr[i]``.
        """
        return self._ptr[i].width
    def set_width(self, i, unsigned long value):
        """Set value ``width`` of ``self._ptr[i]``.
        """
        self._ptr[i].width = value
    @property
    def width(self):
        return self.get_width(0)
    @width.setter
    def width(self, unsigned long value):
        self.set_width(0,value)

    def get_height(self, i):
        """Get value ``height`` of ``self._ptr[i]``.
        """
        return self._ptr[i].height
    def set_height(self, i, unsigned long value):
        """Set value ``height`` of ``self._ptr[i]``.
        """
        self._ptr[i].height = value
    @property
    def height(self):
        return self.get_height(0)
    @height.setter
    def height(self, unsigned long value):
        self.set_height(0,value)

    def get_pitchInBytes(self, i):
        """Get value ``pitchInBytes`` of ``self._ptr[i]``.
        """
        return self._ptr[i].pitchInBytes
    def set_pitchInBytes(self, i, unsigned long value):
        """Set value ``pitchInBytes`` of ``self._ptr[i]``.
        """
        self._ptr[i].pitchInBytes = value
    @property
    def pitchInBytes(self):
        return self.get_pitchInBytes(0)
    @pitchInBytes.setter
    def pitchInBytes(self, unsigned long value):
        self.set_pitchInBytes(0,value)

    @staticmethod
    def PROPERTIES():
        return ["devPtr","desc","width","height","pitchInBytes"]

    def __contains__(self,item):
        properties = self.PROPERTIES()
        return item in properties

    def __getitem__(self,item):
        properties = self.PROPERTIES()
        if isinstance(item,int):
            if item < 0 or item >= len(properties):
                raise IndexError()
            return getattr(self,properties[item])
        raise ValueError("'item' type must be 'int'")


cdef class hipResourceDesc_union_0:
    # members declared in pxd file

    def __cinit__(self):
        self._ptr = NULL
        self.ptr_owner = False
        self._py_buffer_acquired = False

    @staticmethod
    cdef hipResourceDesc_union_0 from_ptr(chip.hipResourceDesc_union_0* ptr, bint owner=False):
        """Factory function to create ``hipResourceDesc_union_0`` objects from
        given ``chip.hipResourceDesc_union_0`` pointer.

        Setting ``owner`` flag to ``True`` causes
        the extension type to ``free`` the structure pointed to by ``ptr``
        when the wrapper object is deallocated.
        """
        # Fast call to __new__() that bypasses the __init__() constructor.
        cdef hipResourceDesc_union_0 wrapper = hipResourceDesc_union_0.__new__(hipResourceDesc_union_0)
        wrapper._ptr = ptr
        wrapper.ptr_owner = owner
        return wrapper

    @staticmethod
    cdef hipResourceDesc_union_0 from_pyobj(object pyobj):
        """Derives a hipResourceDesc_union_0 from a Python object.

        Derives a hipResourceDesc_union_0 from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``hipResourceDesc_union_0`` reference, this method
        returns it directly. No new ``hipResourceDesc_union_0`` is created in this case.

        Args:
            pyobj (object): Must be either ``None``, a simple, contiguous buffer according to the buffer protocol,
                            or of type ``hipResourceDesc_union_0``, ``int``, or ``ctypes.c_void_p``

        Note:
            This routine does not perform a copy but returns the original ``pyobj``
            if ``pyobj`` is an instance of hipResourceDesc_union_0!
        """
        cdef hipResourceDesc_union_0 wrapper = hipResourceDesc_union_0.__new__(hipResourceDesc_union_0)
        cdef dict cuda_array_interface = getattr(pyobj, "__cuda_array_interface__", None)

        if pyobj is None:
            wrapper._ptr = NULL
        elif isinstance(pyobj,hipResourceDesc_union_0):
            return pyobj
        elif isinstance(pyobj,int):
            wrapper._ptr = <chip.hipResourceDesc_union_0*>cpython.long.PyLong_AsVoidPtr(pyobj)
        elif isinstance(pyobj,ctypes.c_void_p):
            wrapper._ptr = <chip.hipResourceDesc_union_0*>cpython.long.PyLong_AsVoidPtr(pyobj.value) if pyobj.value != None else NULL
        elif cuda_array_interface != None:
            if not "data" in cuda_array_interface:
                raise ValueError("input object has '__cuda_array_interface__' attribute but the dict has no 'data' key")
            ptr_as_int = cuda_array_interface["data"][0]
            wrapper._ptr = <chip.hipResourceDesc_union_0*>cpython.long.PyLong_AsVoidPtr(ptr_as_int)
        elif cpython.buffer.PyObject_CheckBuffer(pyobj):
            err = cpython.buffer.PyObject_GetBuffer( 
                pyobj,
                &wrapper._py_buffer, 
                cpython.buffer.PyBUF_SIMPLE | cpython.buffer.PyBUF_ANY_CONTIGUOUS
            )
            if err == -1:
                raise RuntimeError("failed to create simple, contiguous Py_buffer from Python object")
            wrapper._py_buffer_acquired = True
            wrapper._ptr = <chip.hipResourceDesc_union_0*>wrapper._py_buffer.buf
        else:
            raise TypeError(f"unsupported input type: '{str(type(pyobj))}'")
        return wrapper
    def __dealloc__(self):
        # Release the buffer handle
        if self._py_buffer_acquired is True:
            cpython.buffer.PyBuffer_Release(&self._py_buffer)
        # De-allocate if not null and flag is set
        if self._ptr is not NULL and self.ptr_owner is True:
            stdlib.free(self._ptr)
            self._ptr = NULL
    @staticmethod
    cdef __allocate(chip.hipResourceDesc_union_0** ptr):
        ptr[0] = <chip.hipResourceDesc_union_0*>stdlib.malloc(sizeof(chip.hipResourceDesc_union_0))

        if ptr[0] is NULL:
            raise MemoryError
        # TODO init values, if present

    @staticmethod
    cdef hipResourceDesc_union_0 new():
        """Factory function to create hipResourceDesc_union_0 objects with
        newly allocated chip.hipResourceDesc_union_0"""
        cdef chip.hipResourceDesc_union_0* ptr
        hipResourceDesc_union_0.__allocate(&ptr)
        return hipResourceDesc_union_0.from_ptr(ptr, owner=True)
   
    # True
    # True
    def __init__(self,**kwargs):
        hipResourceDesc_union_0.__allocate(&self._ptr)
        self.ptr_owner = True
        attribs = self.PROPERTIES()
        used_attribs = set()
        if len(kwargs) > 1:
            raise ValueError("Not more than one attribute might specified for Python types derived from C union types.")
        valid_names = ", ".join(["'"+p+"'" for p in attribs])
        for k,v in kwargs.items():
            if k in used_attribs:
                raise KeyError(f"argument '{k}' has already been specified as positional argument.")
            elif k not in attribs:
                raise KeyError(f"'{k}' is no valid property name. Valid names: {valid_names}")
            setattr(self,k,v)
    
    def __int__(self):
        """Returns the data's address as long integer."""
        return cpython.long.PyLong_FromVoidPtr(self._ptr)
    def __repr__(self):
        return f"<hipResourceDesc_union_0 object, self.ptr={int(self)}>"
    def as_c_void_p(self):
        """Returns the data's address as `ctypes.c_void_p`"""
        return ctypes.c_void_p(int(self))
    def get_array(self, i):
        """Get value of ``array`` of ``self._ptr[i]``.
        """
        return hipResourceDesc_union_0_struct_0.from_ptr(&self._ptr[i].array)
    @property
    def array(self):
        return self.get_array(0)

    def get_mipmap(self, i):
        """Get value of ``mipmap`` of ``self._ptr[i]``.
        """
        return hipResourceDesc_union_0_struct_1.from_ptr(&self._ptr[i].mipmap)
    @property
    def mipmap(self):
        return self.get_mipmap(0)

    def get_linear(self, i):
        """Get value of ``linear`` of ``self._ptr[i]``.
        """
        return hipResourceDesc_union_0_struct_2.from_ptr(&self._ptr[i].linear)
    @property
    def linear(self):
        return self.get_linear(0)

    def get_pitch2D(self, i):
        """Get value of ``pitch2D`` of ``self._ptr[i]``.
        """
        return hipResourceDesc_union_0_struct_3.from_ptr(&self._ptr[i].pitch2D)
    @property
    def pitch2D(self):
        return self.get_pitch2D(0)

    @staticmethod
    def PROPERTIES():
        return ["array","mipmap","linear","pitch2D"]


cdef class hipResourceDesc:
    # members declared in pxd file

    def __cinit__(self):
        self._ptr = NULL
        self.ptr_owner = False
        self._py_buffer_acquired = False

    @staticmethod
    cdef hipResourceDesc from_ptr(chip.hipResourceDesc* ptr, bint owner=False):
        """Factory function to create ``hipResourceDesc`` objects from
        given ``chip.hipResourceDesc`` pointer.

        Setting ``owner`` flag to ``True`` causes
        the extension type to ``free`` the structure pointed to by ``ptr``
        when the wrapper object is deallocated.
        """
        # Fast call to __new__() that bypasses the __init__() constructor.
        cdef hipResourceDesc wrapper = hipResourceDesc.__new__(hipResourceDesc)
        wrapper._ptr = ptr
        wrapper.ptr_owner = owner
        return wrapper

    @staticmethod
    cdef hipResourceDesc from_pyobj(object pyobj):
        """Derives a hipResourceDesc from a Python object.

        Derives a hipResourceDesc from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``hipResourceDesc`` reference, this method
        returns it directly. No new ``hipResourceDesc`` is created in this case.

        Args:
            pyobj (object): Must be either ``None``, a simple, contiguous buffer according to the buffer protocol,
                            or of type ``hipResourceDesc``, ``int``, or ``ctypes.c_void_p``

        Note:
            This routine does not perform a copy but returns the original ``pyobj``
            if ``pyobj`` is an instance of hipResourceDesc!
        """
        cdef hipResourceDesc wrapper = hipResourceDesc.__new__(hipResourceDesc)
        cdef dict cuda_array_interface = getattr(pyobj, "__cuda_array_interface__", None)

        if pyobj is None:
            wrapper._ptr = NULL
        elif isinstance(pyobj,hipResourceDesc):
            return pyobj
        elif isinstance(pyobj,int):
            wrapper._ptr = <chip.hipResourceDesc*>cpython.long.PyLong_AsVoidPtr(pyobj)
        elif isinstance(pyobj,ctypes.c_void_p):
            wrapper._ptr = <chip.hipResourceDesc*>cpython.long.PyLong_AsVoidPtr(pyobj.value) if pyobj.value != None else NULL
        elif cuda_array_interface != None:
            if not "data" in cuda_array_interface:
                raise ValueError("input object has '__cuda_array_interface__' attribute but the dict has no 'data' key")
            ptr_as_int = cuda_array_interface["data"][0]
            wrapper._ptr = <chip.hipResourceDesc*>cpython.long.PyLong_AsVoidPtr(ptr_as_int)
        elif cpython.buffer.PyObject_CheckBuffer(pyobj):
            err = cpython.buffer.PyObject_GetBuffer( 
                pyobj,
                &wrapper._py_buffer, 
                cpython.buffer.PyBUF_SIMPLE | cpython.buffer.PyBUF_ANY_CONTIGUOUS
            )
            if err == -1:
                raise RuntimeError("failed to create simple, contiguous Py_buffer from Python object")
            wrapper._py_buffer_acquired = True
            wrapper._ptr = <chip.hipResourceDesc*>wrapper._py_buffer.buf
        else:
            raise TypeError(f"unsupported input type: '{str(type(pyobj))}'")
        return wrapper
    def __dealloc__(self):
        # Release the buffer handle
        if self._py_buffer_acquired is True:
            cpython.buffer.PyBuffer_Release(&self._py_buffer)
        # De-allocate if not null and flag is set
        if self._ptr is not NULL and self.ptr_owner is True:
            stdlib.free(self._ptr)
            self._ptr = NULL
    @staticmethod
    cdef __allocate(chip.hipResourceDesc** ptr):
        ptr[0] = <chip.hipResourceDesc*>stdlib.malloc(sizeof(chip.hipResourceDesc))

        if ptr[0] is NULL:
            raise MemoryError
        # TODO init values, if present

    @staticmethod
    cdef hipResourceDesc new():
        """Factory function to create hipResourceDesc objects with
        newly allocated chip.hipResourceDesc"""
        cdef chip.hipResourceDesc* ptr
        hipResourceDesc.__allocate(&ptr)
        return hipResourceDesc.from_ptr(ptr, owner=True)
   
    def __init__(self,*args,**kwargs):
        hipResourceDesc.__allocate(&self._ptr)
        self.ptr_owner = True
        attribs = self.PROPERTIES()
        used_attribs = set()
        if len(args) > len(attribs):
            raise ValueError("More positional arguments specified than this type has properties.")
        for i,v in enumerate(args):
            setattr(self,attribs[i],v)
            used_attribs.add(attribs[i])
        valid_names = ", ".join(["'"+p+"'" for p in attribs])
        for k,v in kwargs.items():
            if k in used_attribs:
                raise KeyError(f"argument '{k}' has already been specified as positional argument.")
            elif k not in attribs:
                raise KeyError(f"'{k}' is no valid property name. Valid names: {valid_names}")
            setattr(self,k,v)
    
    def __int__(self):
        """Returns the data's address as long integer."""
        return cpython.long.PyLong_FromVoidPtr(self._ptr)
    def __repr__(self):
        return f"<hipResourceDesc object, self.ptr={int(self)}>"
    def as_c_void_p(self):
        """Returns the data's address as `ctypes.c_void_p`"""
        return ctypes.c_void_p(int(self))
    def get_resType(self, i):
        """Get value of ``resType`` of ``self._ptr[i]``.
        """
        return hipResourceType(self._ptr[i].resType)
    def set_resType(self, i, value):
        """Set value ``resType`` of ``self._ptr[i]``.
        """
        if not isinstance(value, hipResourceType):
            raise TypeError("'value' must be of type 'hipResourceType'")
        self._ptr[i].resType = value.value
    @property
    def resType(self):
        return self.get_resType(0)
    @resType.setter
    def resType(self, value):
        self.set_resType(0,value)

    def get_res(self, i):
        """Get value of ``res`` of ``self._ptr[i]``.
        """
        return hipResourceDesc_union_0.from_ptr(&self._ptr[i].res)
    @property
    def res(self):
        return self.get_res(0)

    @staticmethod
    def PROPERTIES():
        return ["resType","res"]

    def __contains__(self,item):
        properties = self.PROPERTIES()
        return item in properties

    def __getitem__(self,item):
        properties = self.PROPERTIES()
        if isinstance(item,int):
            if item < 0 or item >= len(properties):
                raise IndexError()
            return getattr(self,properties[item])
        raise ValueError("'item' type must be 'int'")


cdef class HIP_RESOURCE_DESC_st_union_0_struct_0:
    # members declared in pxd file

    def __cinit__(self):
        self._ptr = NULL
        self.ptr_owner = False
        self._py_buffer_acquired = False

    @staticmethod
    cdef HIP_RESOURCE_DESC_st_union_0_struct_0 from_ptr(chip.HIP_RESOURCE_DESC_st_union_0_struct_0* ptr, bint owner=False):
        """Factory function to create ``HIP_RESOURCE_DESC_st_union_0_struct_0`` objects from
        given ``chip.HIP_RESOURCE_DESC_st_union_0_struct_0`` pointer.

        Setting ``owner`` flag to ``True`` causes
        the extension type to ``free`` the structure pointed to by ``ptr``
        when the wrapper object is deallocated.
        """
        # Fast call to __new__() that bypasses the __init__() constructor.
        cdef HIP_RESOURCE_DESC_st_union_0_struct_0 wrapper = HIP_RESOURCE_DESC_st_union_0_struct_0.__new__(HIP_RESOURCE_DESC_st_union_0_struct_0)
        wrapper._ptr = ptr
        wrapper.ptr_owner = owner
        return wrapper

    @staticmethod
    cdef HIP_RESOURCE_DESC_st_union_0_struct_0 from_pyobj(object pyobj):
        """Derives a HIP_RESOURCE_DESC_st_union_0_struct_0 from a Python object.

        Derives a HIP_RESOURCE_DESC_st_union_0_struct_0 from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``HIP_RESOURCE_DESC_st_union_0_struct_0`` reference, this method
        returns it directly. No new ``HIP_RESOURCE_DESC_st_union_0_struct_0`` is created in this case.

        Args:
            pyobj (object): Must be either ``None``, a simple, contiguous buffer according to the buffer protocol,
                            or of type ``HIP_RESOURCE_DESC_st_union_0_struct_0``, ``int``, or ``ctypes.c_void_p``

        Note:
            This routine does not perform a copy but returns the original ``pyobj``
            if ``pyobj`` is an instance of HIP_RESOURCE_DESC_st_union_0_struct_0!
        """
        cdef HIP_RESOURCE_DESC_st_union_0_struct_0 wrapper = HIP_RESOURCE_DESC_st_union_0_struct_0.__new__(HIP_RESOURCE_DESC_st_union_0_struct_0)
        cdef dict cuda_array_interface = getattr(pyobj, "__cuda_array_interface__", None)

        if pyobj is None:
            wrapper._ptr = NULL
        elif isinstance(pyobj,HIP_RESOURCE_DESC_st_union_0_struct_0):
            return pyobj
        elif isinstance(pyobj,int):
            wrapper._ptr = <chip.HIP_RESOURCE_DESC_st_union_0_struct_0*>cpython.long.PyLong_AsVoidPtr(pyobj)
        elif isinstance(pyobj,ctypes.c_void_p):
            wrapper._ptr = <chip.HIP_RESOURCE_DESC_st_union_0_struct_0*>cpython.long.PyLong_AsVoidPtr(pyobj.value) if pyobj.value != None else NULL
        elif cuda_array_interface != None:
            if not "data" in cuda_array_interface:
                raise ValueError("input object has '__cuda_array_interface__' attribute but the dict has no 'data' key")
            ptr_as_int = cuda_array_interface["data"][0]
            wrapper._ptr = <chip.HIP_RESOURCE_DESC_st_union_0_struct_0*>cpython.long.PyLong_AsVoidPtr(ptr_as_int)
        elif cpython.buffer.PyObject_CheckBuffer(pyobj):
            err = cpython.buffer.PyObject_GetBuffer( 
                pyobj,
                &wrapper._py_buffer, 
                cpython.buffer.PyBUF_SIMPLE | cpython.buffer.PyBUF_ANY_CONTIGUOUS
            )
            if err == -1:
                raise RuntimeError("failed to create simple, contiguous Py_buffer from Python object")
            wrapper._py_buffer_acquired = True
            wrapper._ptr = <chip.HIP_RESOURCE_DESC_st_union_0_struct_0*>wrapper._py_buffer.buf
        else:
            raise TypeError(f"unsupported input type: '{str(type(pyobj))}'")
        return wrapper
    def __dealloc__(self):
        # Release the buffer handle
        if self._py_buffer_acquired is True:
            cpython.buffer.PyBuffer_Release(&self._py_buffer)
        # De-allocate if not null and flag is set
        if self._ptr is not NULL and self.ptr_owner is True:
            stdlib.free(self._ptr)
            self._ptr = NULL
    @staticmethod
    cdef __allocate(chip.HIP_RESOURCE_DESC_st_union_0_struct_0** ptr):
        ptr[0] = <chip.HIP_RESOURCE_DESC_st_union_0_struct_0*>stdlib.malloc(sizeof(chip.HIP_RESOURCE_DESC_st_union_0_struct_0))

        if ptr[0] is NULL:
            raise MemoryError
        # TODO init values, if present

    @staticmethod
    cdef HIP_RESOURCE_DESC_st_union_0_struct_0 new():
        """Factory function to create HIP_RESOURCE_DESC_st_union_0_struct_0 objects with
        newly allocated chip.HIP_RESOURCE_DESC_st_union_0_struct_0"""
        cdef chip.HIP_RESOURCE_DESC_st_union_0_struct_0* ptr
        HIP_RESOURCE_DESC_st_union_0_struct_0.__allocate(&ptr)
        return HIP_RESOURCE_DESC_st_union_0_struct_0.from_ptr(ptr, owner=True)
   
    # False
    # False
    def __init__(self,**kwargs):
        HIP_RESOURCE_DESC_st_union_0_struct_0.__allocate(&self._ptr)
        self.ptr_owner = True
        attribs = self.PROPERTIES()
        used_attribs = set()
        valid_names = ", ".join(["'"+p+"'" for p in attribs])
        for k,v in kwargs.items():
            if k in used_attribs:
                raise KeyError(f"argument '{k}' has already been specified as positional argument.")
            elif k not in attribs:
                raise KeyError(f"'{k}' is no valid property name. Valid names: {valid_names}")
            setattr(self,k,v)
    
    def __int__(self):
        """Returns the data's address as long integer."""
        return cpython.long.PyLong_FromVoidPtr(self._ptr)
    def __repr__(self):
        return f"<HIP_RESOURCE_DESC_st_union_0_struct_0 object, self.ptr={int(self)}>"
    def as_c_void_p(self):
        """Returns the data's address as `ctypes.c_void_p`"""
        return ctypes.c_void_p(int(self))
    @staticmethod
    def PROPERTIES():
        return []

    def __contains__(self,item):
        properties = self.PROPERTIES()
        return item in properties

    def __getitem__(self,item):
        properties = self.PROPERTIES()
        if isinstance(item,int):
            if item < 0 or item >= len(properties):
                raise IndexError()
            return getattr(self,properties[item])
        raise ValueError("'item' type must be 'int'")


cdef class HIP_RESOURCE_DESC_st_union_0_struct_1:
    # members declared in pxd file

    def __cinit__(self):
        self._ptr = NULL
        self.ptr_owner = False
        self._py_buffer_acquired = False

    @staticmethod
    cdef HIP_RESOURCE_DESC_st_union_0_struct_1 from_ptr(chip.HIP_RESOURCE_DESC_st_union_0_struct_1* ptr, bint owner=False):
        """Factory function to create ``HIP_RESOURCE_DESC_st_union_0_struct_1`` objects from
        given ``chip.HIP_RESOURCE_DESC_st_union_0_struct_1`` pointer.

        Setting ``owner`` flag to ``True`` causes
        the extension type to ``free`` the structure pointed to by ``ptr``
        when the wrapper object is deallocated.
        """
        # Fast call to __new__() that bypasses the __init__() constructor.
        cdef HIP_RESOURCE_DESC_st_union_0_struct_1 wrapper = HIP_RESOURCE_DESC_st_union_0_struct_1.__new__(HIP_RESOURCE_DESC_st_union_0_struct_1)
        wrapper._ptr = ptr
        wrapper.ptr_owner = owner
        return wrapper

    @staticmethod
    cdef HIP_RESOURCE_DESC_st_union_0_struct_1 from_pyobj(object pyobj):
        """Derives a HIP_RESOURCE_DESC_st_union_0_struct_1 from a Python object.

        Derives a HIP_RESOURCE_DESC_st_union_0_struct_1 from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``HIP_RESOURCE_DESC_st_union_0_struct_1`` reference, this method
        returns it directly. No new ``HIP_RESOURCE_DESC_st_union_0_struct_1`` is created in this case.

        Args:
            pyobj (object): Must be either ``None``, a simple, contiguous buffer according to the buffer protocol,
                            or of type ``HIP_RESOURCE_DESC_st_union_0_struct_1``, ``int``, or ``ctypes.c_void_p``

        Note:
            This routine does not perform a copy but returns the original ``pyobj``
            if ``pyobj`` is an instance of HIP_RESOURCE_DESC_st_union_0_struct_1!
        """
        cdef HIP_RESOURCE_DESC_st_union_0_struct_1 wrapper = HIP_RESOURCE_DESC_st_union_0_struct_1.__new__(HIP_RESOURCE_DESC_st_union_0_struct_1)
        cdef dict cuda_array_interface = getattr(pyobj, "__cuda_array_interface__", None)

        if pyobj is None:
            wrapper._ptr = NULL
        elif isinstance(pyobj,HIP_RESOURCE_DESC_st_union_0_struct_1):
            return pyobj
        elif isinstance(pyobj,int):
            wrapper._ptr = <chip.HIP_RESOURCE_DESC_st_union_0_struct_1*>cpython.long.PyLong_AsVoidPtr(pyobj)
        elif isinstance(pyobj,ctypes.c_void_p):
            wrapper._ptr = <chip.HIP_RESOURCE_DESC_st_union_0_struct_1*>cpython.long.PyLong_AsVoidPtr(pyobj.value) if pyobj.value != None else NULL
        elif cuda_array_interface != None:
            if not "data" in cuda_array_interface:
                raise ValueError("input object has '__cuda_array_interface__' attribute but the dict has no 'data' key")
            ptr_as_int = cuda_array_interface["data"][0]
            wrapper._ptr = <chip.HIP_RESOURCE_DESC_st_union_0_struct_1*>cpython.long.PyLong_AsVoidPtr(ptr_as_int)
        elif cpython.buffer.PyObject_CheckBuffer(pyobj):
            err = cpython.buffer.PyObject_GetBuffer( 
                pyobj,
                &wrapper._py_buffer, 
                cpython.buffer.PyBUF_SIMPLE | cpython.buffer.PyBUF_ANY_CONTIGUOUS
            )
            if err == -1:
                raise RuntimeError("failed to create simple, contiguous Py_buffer from Python object")
            wrapper._py_buffer_acquired = True
            wrapper._ptr = <chip.HIP_RESOURCE_DESC_st_union_0_struct_1*>wrapper._py_buffer.buf
        else:
            raise TypeError(f"unsupported input type: '{str(type(pyobj))}'")
        return wrapper
    def __dealloc__(self):
        # Release the buffer handle
        if self._py_buffer_acquired is True:
            cpython.buffer.PyBuffer_Release(&self._py_buffer)
        # De-allocate if not null and flag is set
        if self._ptr is not NULL and self.ptr_owner is True:
            stdlib.free(self._ptr)
            self._ptr = NULL
    @staticmethod
    cdef __allocate(chip.HIP_RESOURCE_DESC_st_union_0_struct_1** ptr):
        ptr[0] = <chip.HIP_RESOURCE_DESC_st_union_0_struct_1*>stdlib.malloc(sizeof(chip.HIP_RESOURCE_DESC_st_union_0_struct_1))

        if ptr[0] is NULL:
            raise MemoryError
        # TODO init values, if present

    @staticmethod
    cdef HIP_RESOURCE_DESC_st_union_0_struct_1 new():
        """Factory function to create HIP_RESOURCE_DESC_st_union_0_struct_1 objects with
        newly allocated chip.HIP_RESOURCE_DESC_st_union_0_struct_1"""
        cdef chip.HIP_RESOURCE_DESC_st_union_0_struct_1* ptr
        HIP_RESOURCE_DESC_st_union_0_struct_1.__allocate(&ptr)
        return HIP_RESOURCE_DESC_st_union_0_struct_1.from_ptr(ptr, owner=True)
   
    # False
    # False
    def __init__(self,**kwargs):
        HIP_RESOURCE_DESC_st_union_0_struct_1.__allocate(&self._ptr)
        self.ptr_owner = True
        attribs = self.PROPERTIES()
        used_attribs = set()
        valid_names = ", ".join(["'"+p+"'" for p in attribs])
        for k,v in kwargs.items():
            if k in used_attribs:
                raise KeyError(f"argument '{k}' has already been specified as positional argument.")
            elif k not in attribs:
                raise KeyError(f"'{k}' is no valid property name. Valid names: {valid_names}")
            setattr(self,k,v)
    
    def __int__(self):
        """Returns the data's address as long integer."""
        return cpython.long.PyLong_FromVoidPtr(self._ptr)
    def __repr__(self):
        return f"<HIP_RESOURCE_DESC_st_union_0_struct_1 object, self.ptr={int(self)}>"
    def as_c_void_p(self):
        """Returns the data's address as `ctypes.c_void_p`"""
        return ctypes.c_void_p(int(self))
    @staticmethod
    def PROPERTIES():
        return []

    def __contains__(self,item):
        properties = self.PROPERTIES()
        return item in properties

    def __getitem__(self,item):
        properties = self.PROPERTIES()
        if isinstance(item,int):
            if item < 0 or item >= len(properties):
                raise IndexError()
            return getattr(self,properties[item])
        raise ValueError("'item' type must be 'int'")


cdef class HIP_RESOURCE_DESC_st_union_0_struct_2:
    # members declared in pxd file

    def __cinit__(self):
        self._ptr = NULL
        self.ptr_owner = False
        self._py_buffer_acquired = False

    @staticmethod
    cdef HIP_RESOURCE_DESC_st_union_0_struct_2 from_ptr(chip.HIP_RESOURCE_DESC_st_union_0_struct_2* ptr, bint owner=False):
        """Factory function to create ``HIP_RESOURCE_DESC_st_union_0_struct_2`` objects from
        given ``chip.HIP_RESOURCE_DESC_st_union_0_struct_2`` pointer.

        Setting ``owner`` flag to ``True`` causes
        the extension type to ``free`` the structure pointed to by ``ptr``
        when the wrapper object is deallocated.
        """
        # Fast call to __new__() that bypasses the __init__() constructor.
        cdef HIP_RESOURCE_DESC_st_union_0_struct_2 wrapper = HIP_RESOURCE_DESC_st_union_0_struct_2.__new__(HIP_RESOURCE_DESC_st_union_0_struct_2)
        wrapper._ptr = ptr
        wrapper.ptr_owner = owner
        return wrapper

    @staticmethod
    cdef HIP_RESOURCE_DESC_st_union_0_struct_2 from_pyobj(object pyobj):
        """Derives a HIP_RESOURCE_DESC_st_union_0_struct_2 from a Python object.

        Derives a HIP_RESOURCE_DESC_st_union_0_struct_2 from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``HIP_RESOURCE_DESC_st_union_0_struct_2`` reference, this method
        returns it directly. No new ``HIP_RESOURCE_DESC_st_union_0_struct_2`` is created in this case.

        Args:
            pyobj (object): Must be either ``None``, a simple, contiguous buffer according to the buffer protocol,
                            or of type ``HIP_RESOURCE_DESC_st_union_0_struct_2``, ``int``, or ``ctypes.c_void_p``

        Note:
            This routine does not perform a copy but returns the original ``pyobj``
            if ``pyobj`` is an instance of HIP_RESOURCE_DESC_st_union_0_struct_2!
        """
        cdef HIP_RESOURCE_DESC_st_union_0_struct_2 wrapper = HIP_RESOURCE_DESC_st_union_0_struct_2.__new__(HIP_RESOURCE_DESC_st_union_0_struct_2)
        cdef dict cuda_array_interface = getattr(pyobj, "__cuda_array_interface__", None)

        if pyobj is None:
            wrapper._ptr = NULL
        elif isinstance(pyobj,HIP_RESOURCE_DESC_st_union_0_struct_2):
            return pyobj
        elif isinstance(pyobj,int):
            wrapper._ptr = <chip.HIP_RESOURCE_DESC_st_union_0_struct_2*>cpython.long.PyLong_AsVoidPtr(pyobj)
        elif isinstance(pyobj,ctypes.c_void_p):
            wrapper._ptr = <chip.HIP_RESOURCE_DESC_st_union_0_struct_2*>cpython.long.PyLong_AsVoidPtr(pyobj.value) if pyobj.value != None else NULL
        elif cuda_array_interface != None:
            if not "data" in cuda_array_interface:
                raise ValueError("input object has '__cuda_array_interface__' attribute but the dict has no 'data' key")
            ptr_as_int = cuda_array_interface["data"][0]
            wrapper._ptr = <chip.HIP_RESOURCE_DESC_st_union_0_struct_2*>cpython.long.PyLong_AsVoidPtr(ptr_as_int)
        elif cpython.buffer.PyObject_CheckBuffer(pyobj):
            err = cpython.buffer.PyObject_GetBuffer( 
                pyobj,
                &wrapper._py_buffer, 
                cpython.buffer.PyBUF_SIMPLE | cpython.buffer.PyBUF_ANY_CONTIGUOUS
            )
            if err == -1:
                raise RuntimeError("failed to create simple, contiguous Py_buffer from Python object")
            wrapper._py_buffer_acquired = True
            wrapper._ptr = <chip.HIP_RESOURCE_DESC_st_union_0_struct_2*>wrapper._py_buffer.buf
        else:
            raise TypeError(f"unsupported input type: '{str(type(pyobj))}'")
        return wrapper
    def __dealloc__(self):
        # Release the buffer handle
        if self._py_buffer_acquired is True:
            cpython.buffer.PyBuffer_Release(&self._py_buffer)
        # De-allocate if not null and flag is set
        if self._ptr is not NULL and self.ptr_owner is True:
            stdlib.free(self._ptr)
            self._ptr = NULL
    @staticmethod
    cdef __allocate(chip.HIP_RESOURCE_DESC_st_union_0_struct_2** ptr):
        ptr[0] = <chip.HIP_RESOURCE_DESC_st_union_0_struct_2*>stdlib.malloc(sizeof(chip.HIP_RESOURCE_DESC_st_union_0_struct_2))

        if ptr[0] is NULL:
            raise MemoryError
        # TODO init values, if present

    @staticmethod
    cdef HIP_RESOURCE_DESC_st_union_0_struct_2 new():
        """Factory function to create HIP_RESOURCE_DESC_st_union_0_struct_2 objects with
        newly allocated chip.HIP_RESOURCE_DESC_st_union_0_struct_2"""
        cdef chip.HIP_RESOURCE_DESC_st_union_0_struct_2* ptr
        HIP_RESOURCE_DESC_st_union_0_struct_2.__allocate(&ptr)
        return HIP_RESOURCE_DESC_st_union_0_struct_2.from_ptr(ptr, owner=True)
   
    def __init__(self,*args,**kwargs):
        HIP_RESOURCE_DESC_st_union_0_struct_2.__allocate(&self._ptr)
        self.ptr_owner = True
        attribs = self.PROPERTIES()
        used_attribs = set()
        if len(args) > len(attribs):
            raise ValueError("More positional arguments specified than this type has properties.")
        for i,v in enumerate(args):
            setattr(self,attribs[i],v)
            used_attribs.add(attribs[i])
        valid_names = ", ".join(["'"+p+"'" for p in attribs])
        for k,v in kwargs.items():
            if k in used_attribs:
                raise KeyError(f"argument '{k}' has already been specified as positional argument.")
            elif k not in attribs:
                raise KeyError(f"'{k}' is no valid property name. Valid names: {valid_names}")
            setattr(self,k,v)
    
    def __int__(self):
        """Returns the data's address as long integer."""
        return cpython.long.PyLong_FromVoidPtr(self._ptr)
    def __repr__(self):
        return f"<HIP_RESOURCE_DESC_st_union_0_struct_2 object, self.ptr={int(self)}>"
    def as_c_void_p(self):
        """Returns the data's address as `ctypes.c_void_p`"""
        return ctypes.c_void_p(int(self))
    def get_devPtr(self, i):
        """Get value ``devPtr`` of ``self._ptr[i]``.
        """
        return hip._util.types.DataHandle.from_ptr(self._ptr[i].devPtr)
    def set_devPtr(self, i, object value):
        """Set value ``devPtr`` of ``self._ptr[i]``.

        Note:
            This can be dangerous if the pointer is from a python object
            that is later on garbage collected.
        """
        self._ptr[i].devPtr = <void *>cpython.long.PyLong_AsVoidPtr(int(hip._util.types.DataHandle.from_pyobj(value)))
    @property
    def devPtr(self):
        """
        Note:
            Setting this devPtr can be dangerous if the underlying pointer is from a python object that
            is later on garbage collected.
        """
        return self.get_devPtr(0)
    @devPtr.setter
    def devPtr(self, object value):
        self.set_devPtr(0,value)

    def get_format(self, i):
        """Get value of ``format`` of ``self._ptr[i]``.
        """
        return hipArray_Format(self._ptr[i].format)
    def set_format(self, i, value):
        """Set value ``format`` of ``self._ptr[i]``.
        """
        if not isinstance(value, hipArray_Format):
            raise TypeError("'value' must be of type 'hipArray_Format'")
        self._ptr[i].format = value.value
    @property
    def format(self):
        return self.get_format(0)
    @format.setter
    def format(self, value):
        self.set_format(0,value)

    def get_numChannels(self, i):
        """Get value ``numChannels`` of ``self._ptr[i]``.
        """
        return self._ptr[i].numChannels
    def set_numChannels(self, i, unsigned int value):
        """Set value ``numChannels`` of ``self._ptr[i]``.
        """
        self._ptr[i].numChannels = value
    @property
    def numChannels(self):
        return self.get_numChannels(0)
    @numChannels.setter
    def numChannels(self, unsigned int value):
        self.set_numChannels(0,value)

    def get_sizeInBytes(self, i):
        """Get value ``sizeInBytes`` of ``self._ptr[i]``.
        """
        return self._ptr[i].sizeInBytes
    def set_sizeInBytes(self, i, unsigned long value):
        """Set value ``sizeInBytes`` of ``self._ptr[i]``.
        """
        self._ptr[i].sizeInBytes = value
    @property
    def sizeInBytes(self):
        return self.get_sizeInBytes(0)
    @sizeInBytes.setter
    def sizeInBytes(self, unsigned long value):
        self.set_sizeInBytes(0,value)

    @staticmethod
    def PROPERTIES():
        return ["devPtr","format","numChannels","sizeInBytes"]

    def __contains__(self,item):
        properties = self.PROPERTIES()
        return item in properties

    def __getitem__(self,item):
        properties = self.PROPERTIES()
        if isinstance(item,int):
            if item < 0 or item >= len(properties):
                raise IndexError()
            return getattr(self,properties[item])
        raise ValueError("'item' type must be 'int'")


cdef class HIP_RESOURCE_DESC_st_union_0_struct_3:
    # members declared in pxd file

    def __cinit__(self):
        self._ptr = NULL
        self.ptr_owner = False
        self._py_buffer_acquired = False

    @staticmethod
    cdef HIP_RESOURCE_DESC_st_union_0_struct_3 from_ptr(chip.HIP_RESOURCE_DESC_st_union_0_struct_3* ptr, bint owner=False):
        """Factory function to create ``HIP_RESOURCE_DESC_st_union_0_struct_3`` objects from
        given ``chip.HIP_RESOURCE_DESC_st_union_0_struct_3`` pointer.

        Setting ``owner`` flag to ``True`` causes
        the extension type to ``free`` the structure pointed to by ``ptr``
        when the wrapper object is deallocated.
        """
        # Fast call to __new__() that bypasses the __init__() constructor.
        cdef HIP_RESOURCE_DESC_st_union_0_struct_3 wrapper = HIP_RESOURCE_DESC_st_union_0_struct_3.__new__(HIP_RESOURCE_DESC_st_union_0_struct_3)
        wrapper._ptr = ptr
        wrapper.ptr_owner = owner
        return wrapper

    @staticmethod
    cdef HIP_RESOURCE_DESC_st_union_0_struct_3 from_pyobj(object pyobj):
        """Derives a HIP_RESOURCE_DESC_st_union_0_struct_3 from a Python object.

        Derives a HIP_RESOURCE_DESC_st_union_0_struct_3 from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``HIP_RESOURCE_DESC_st_union_0_struct_3`` reference, this method
        returns it directly. No new ``HIP_RESOURCE_DESC_st_union_0_struct_3`` is created in this case.

        Args:
            pyobj (object): Must be either ``None``, a simple, contiguous buffer according to the buffer protocol,
                            or of type ``HIP_RESOURCE_DESC_st_union_0_struct_3``, ``int``, or ``ctypes.c_void_p``

        Note:
            This routine does not perform a copy but returns the original ``pyobj``
            if ``pyobj`` is an instance of HIP_RESOURCE_DESC_st_union_0_struct_3!
        """
        cdef HIP_RESOURCE_DESC_st_union_0_struct_3 wrapper = HIP_RESOURCE_DESC_st_union_0_struct_3.__new__(HIP_RESOURCE_DESC_st_union_0_struct_3)
        cdef dict cuda_array_interface = getattr(pyobj, "__cuda_array_interface__", None)

        if pyobj is None:
            wrapper._ptr = NULL
        elif isinstance(pyobj,HIP_RESOURCE_DESC_st_union_0_struct_3):
            return pyobj
        elif isinstance(pyobj,int):
            wrapper._ptr = <chip.HIP_RESOURCE_DESC_st_union_0_struct_3*>cpython.long.PyLong_AsVoidPtr(pyobj)
        elif isinstance(pyobj,ctypes.c_void_p):
            wrapper._ptr = <chip.HIP_RESOURCE_DESC_st_union_0_struct_3*>cpython.long.PyLong_AsVoidPtr(pyobj.value) if pyobj.value != None else NULL
        elif cuda_array_interface != None:
            if not "data" in cuda_array_interface:
                raise ValueError("input object has '__cuda_array_interface__' attribute but the dict has no 'data' key")
            ptr_as_int = cuda_array_interface["data"][0]
            wrapper._ptr = <chip.HIP_RESOURCE_DESC_st_union_0_struct_3*>cpython.long.PyLong_AsVoidPtr(ptr_as_int)
        elif cpython.buffer.PyObject_CheckBuffer(pyobj):
            err = cpython.buffer.PyObject_GetBuffer( 
                pyobj,
                &wrapper._py_buffer, 
                cpython.buffer.PyBUF_SIMPLE | cpython.buffer.PyBUF_ANY_CONTIGUOUS
            )
            if err == -1:
                raise RuntimeError("failed to create simple, contiguous Py_buffer from Python object")
            wrapper._py_buffer_acquired = True
            wrapper._ptr = <chip.HIP_RESOURCE_DESC_st_union_0_struct_3*>wrapper._py_buffer.buf
        else:
            raise TypeError(f"unsupported input type: '{str(type(pyobj))}'")
        return wrapper
    def __dealloc__(self):
        # Release the buffer handle
        if self._py_buffer_acquired is True:
            cpython.buffer.PyBuffer_Release(&self._py_buffer)
        # De-allocate if not null and flag is set
        if self._ptr is not NULL and self.ptr_owner is True:
            stdlib.free(self._ptr)
            self._ptr = NULL
    @staticmethod
    cdef __allocate(chip.HIP_RESOURCE_DESC_st_union_0_struct_3** ptr):
        ptr[0] = <chip.HIP_RESOURCE_DESC_st_union_0_struct_3*>stdlib.malloc(sizeof(chip.HIP_RESOURCE_DESC_st_union_0_struct_3))

        if ptr[0] is NULL:
            raise MemoryError
        # TODO init values, if present

    @staticmethod
    cdef HIP_RESOURCE_DESC_st_union_0_struct_3 new():
        """Factory function to create HIP_RESOURCE_DESC_st_union_0_struct_3 objects with
        newly allocated chip.HIP_RESOURCE_DESC_st_union_0_struct_3"""
        cdef chip.HIP_RESOURCE_DESC_st_union_0_struct_3* ptr
        HIP_RESOURCE_DESC_st_union_0_struct_3.__allocate(&ptr)
        return HIP_RESOURCE_DESC_st_union_0_struct_3.from_ptr(ptr, owner=True)
   
    def __init__(self,*args,**kwargs):
        HIP_RESOURCE_DESC_st_union_0_struct_3.__allocate(&self._ptr)
        self.ptr_owner = True
        attribs = self.PROPERTIES()
        used_attribs = set()
        if len(args) > len(attribs):
            raise ValueError("More positional arguments specified than this type has properties.")
        for i,v in enumerate(args):
            setattr(self,attribs[i],v)
            used_attribs.add(attribs[i])
        valid_names = ", ".join(["'"+p+"'" for p in attribs])
        for k,v in kwargs.items():
            if k in used_attribs:
                raise KeyError(f"argument '{k}' has already been specified as positional argument.")
            elif k not in attribs:
                raise KeyError(f"'{k}' is no valid property name. Valid names: {valid_names}")
            setattr(self,k,v)
    
    def __int__(self):
        """Returns the data's address as long integer."""
        return cpython.long.PyLong_FromVoidPtr(self._ptr)
    def __repr__(self):
        return f"<HIP_RESOURCE_DESC_st_union_0_struct_3 object, self.ptr={int(self)}>"
    def as_c_void_p(self):
        """Returns the data's address as `ctypes.c_void_p`"""
        return ctypes.c_void_p(int(self))
    def get_devPtr(self, i):
        """Get value ``devPtr`` of ``self._ptr[i]``.
        """
        return hip._util.types.DataHandle.from_ptr(self._ptr[i].devPtr)
    def set_devPtr(self, i, object value):
        """Set value ``devPtr`` of ``self._ptr[i]``.

        Note:
            This can be dangerous if the pointer is from a python object
            that is later on garbage collected.
        """
        self._ptr[i].devPtr = <void *>cpython.long.PyLong_AsVoidPtr(int(hip._util.types.DataHandle.from_pyobj(value)))
    @property
    def devPtr(self):
        """
        Note:
            Setting this devPtr can be dangerous if the underlying pointer is from a python object that
            is later on garbage collected.
        """
        return self.get_devPtr(0)
    @devPtr.setter
    def devPtr(self, object value):
        self.set_devPtr(0,value)

    def get_format(self, i):
        """Get value of ``format`` of ``self._ptr[i]``.
        """
        return hipArray_Format(self._ptr[i].format)
    def set_format(self, i, value):
        """Set value ``format`` of ``self._ptr[i]``.
        """
        if not isinstance(value, hipArray_Format):
            raise TypeError("'value' must be of type 'hipArray_Format'")
        self._ptr[i].format = value.value
    @property
    def format(self):
        return self.get_format(0)
    @format.setter
    def format(self, value):
        self.set_format(0,value)

    def get_numChannels(self, i):
        """Get value ``numChannels`` of ``self._ptr[i]``.
        """
        return self._ptr[i].numChannels
    def set_numChannels(self, i, unsigned int value):
        """Set value ``numChannels`` of ``self._ptr[i]``.
        """
        self._ptr[i].numChannels = value
    @property
    def numChannels(self):
        return self.get_numChannels(0)
    @numChannels.setter
    def numChannels(self, unsigned int value):
        self.set_numChannels(0,value)

    def get_width(self, i):
        """Get value ``width`` of ``self._ptr[i]``.
        """
        return self._ptr[i].width
    def set_width(self, i, unsigned long value):
        """Set value ``width`` of ``self._ptr[i]``.
        """
        self._ptr[i].width = value
    @property
    def width(self):
        return self.get_width(0)
    @width.setter
    def width(self, unsigned long value):
        self.set_width(0,value)

    def get_height(self, i):
        """Get value ``height`` of ``self._ptr[i]``.
        """
        return self._ptr[i].height
    def set_height(self, i, unsigned long value):
        """Set value ``height`` of ``self._ptr[i]``.
        """
        self._ptr[i].height = value
    @property
    def height(self):
        return self.get_height(0)
    @height.setter
    def height(self, unsigned long value):
        self.set_height(0,value)

    def get_pitchInBytes(self, i):
        """Get value ``pitchInBytes`` of ``self._ptr[i]``.
        """
        return self._ptr[i].pitchInBytes
    def set_pitchInBytes(self, i, unsigned long value):
        """Set value ``pitchInBytes`` of ``self._ptr[i]``.
        """
        self._ptr[i].pitchInBytes = value
    @property
    def pitchInBytes(self):
        return self.get_pitchInBytes(0)
    @pitchInBytes.setter
    def pitchInBytes(self, unsigned long value):
        self.set_pitchInBytes(0,value)

    @staticmethod
    def PROPERTIES():
        return ["devPtr","format","numChannels","width","height","pitchInBytes"]

    def __contains__(self,item):
        properties = self.PROPERTIES()
        return item in properties

    def __getitem__(self,item):
        properties = self.PROPERTIES()
        if isinstance(item,int):
            if item < 0 or item >= len(properties):
                raise IndexError()
            return getattr(self,properties[item])
        raise ValueError("'item' type must be 'int'")


cdef class HIP_RESOURCE_DESC_st_union_0_struct_4:
    # members declared in pxd file

    def __cinit__(self):
        self._ptr = NULL
        self.ptr_owner = False
        self._py_buffer_acquired = False

    @staticmethod
    cdef HIP_RESOURCE_DESC_st_union_0_struct_4 from_ptr(chip.HIP_RESOURCE_DESC_st_union_0_struct_4* ptr, bint owner=False):
        """Factory function to create ``HIP_RESOURCE_DESC_st_union_0_struct_4`` objects from
        given ``chip.HIP_RESOURCE_DESC_st_union_0_struct_4`` pointer.

        Setting ``owner`` flag to ``True`` causes
        the extension type to ``free`` the structure pointed to by ``ptr``
        when the wrapper object is deallocated.
        """
        # Fast call to __new__() that bypasses the __init__() constructor.
        cdef HIP_RESOURCE_DESC_st_union_0_struct_4 wrapper = HIP_RESOURCE_DESC_st_union_0_struct_4.__new__(HIP_RESOURCE_DESC_st_union_0_struct_4)
        wrapper._ptr = ptr
        wrapper.ptr_owner = owner
        return wrapper

    @staticmethod
    cdef HIP_RESOURCE_DESC_st_union_0_struct_4 from_pyobj(object pyobj):
        """Derives a HIP_RESOURCE_DESC_st_union_0_struct_4 from a Python object.

        Derives a HIP_RESOURCE_DESC_st_union_0_struct_4 from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``HIP_RESOURCE_DESC_st_union_0_struct_4`` reference, this method
        returns it directly. No new ``HIP_RESOURCE_DESC_st_union_0_struct_4`` is created in this case.

        Args:
            pyobj (object): Must be either ``None``, a simple, contiguous buffer according to the buffer protocol,
                            or of type ``HIP_RESOURCE_DESC_st_union_0_struct_4``, ``int``, or ``ctypes.c_void_p``

        Note:
            This routine does not perform a copy but returns the original ``pyobj``
            if ``pyobj`` is an instance of HIP_RESOURCE_DESC_st_union_0_struct_4!
        """
        cdef HIP_RESOURCE_DESC_st_union_0_struct_4 wrapper = HIP_RESOURCE_DESC_st_union_0_struct_4.__new__(HIP_RESOURCE_DESC_st_union_0_struct_4)
        cdef dict cuda_array_interface = getattr(pyobj, "__cuda_array_interface__", None)

        if pyobj is None:
            wrapper._ptr = NULL
        elif isinstance(pyobj,HIP_RESOURCE_DESC_st_union_0_struct_4):
            return pyobj
        elif isinstance(pyobj,int):
            wrapper._ptr = <chip.HIP_RESOURCE_DESC_st_union_0_struct_4*>cpython.long.PyLong_AsVoidPtr(pyobj)
        elif isinstance(pyobj,ctypes.c_void_p):
            wrapper._ptr = <chip.HIP_RESOURCE_DESC_st_union_0_struct_4*>cpython.long.PyLong_AsVoidPtr(pyobj.value) if pyobj.value != None else NULL
        elif cuda_array_interface != None:
            if not "data" in cuda_array_interface:
                raise ValueError("input object has '__cuda_array_interface__' attribute but the dict has no 'data' key")
            ptr_as_int = cuda_array_interface["data"][0]
            wrapper._ptr = <chip.HIP_RESOURCE_DESC_st_union_0_struct_4*>cpython.long.PyLong_AsVoidPtr(ptr_as_int)
        elif cpython.buffer.PyObject_CheckBuffer(pyobj):
            err = cpython.buffer.PyObject_GetBuffer( 
                pyobj,
                &wrapper._py_buffer, 
                cpython.buffer.PyBUF_SIMPLE | cpython.buffer.PyBUF_ANY_CONTIGUOUS
            )
            if err == -1:
                raise RuntimeError("failed to create simple, contiguous Py_buffer from Python object")
            wrapper._py_buffer_acquired = True
            wrapper._ptr = <chip.HIP_RESOURCE_DESC_st_union_0_struct_4*>wrapper._py_buffer.buf
        else:
            raise TypeError(f"unsupported input type: '{str(type(pyobj))}'")
        return wrapper
    def __dealloc__(self):
        # Release the buffer handle
        if self._py_buffer_acquired is True:
            cpython.buffer.PyBuffer_Release(&self._py_buffer)
        # De-allocate if not null and flag is set
        if self._ptr is not NULL and self.ptr_owner is True:
            stdlib.free(self._ptr)
            self._ptr = NULL
    @staticmethod
    cdef __allocate(chip.HIP_RESOURCE_DESC_st_union_0_struct_4** ptr):
        ptr[0] = <chip.HIP_RESOURCE_DESC_st_union_0_struct_4*>stdlib.malloc(sizeof(chip.HIP_RESOURCE_DESC_st_union_0_struct_4))

        if ptr[0] is NULL:
            raise MemoryError
        # TODO init values, if present

    @staticmethod
    cdef HIP_RESOURCE_DESC_st_union_0_struct_4 new():
        """Factory function to create HIP_RESOURCE_DESC_st_union_0_struct_4 objects with
        newly allocated chip.HIP_RESOURCE_DESC_st_union_0_struct_4"""
        cdef chip.HIP_RESOURCE_DESC_st_union_0_struct_4* ptr
        HIP_RESOURCE_DESC_st_union_0_struct_4.__allocate(&ptr)
        return HIP_RESOURCE_DESC_st_union_0_struct_4.from_ptr(ptr, owner=True)
   
    def __init__(self,*args,**kwargs):
        HIP_RESOURCE_DESC_st_union_0_struct_4.__allocate(&self._ptr)
        self.ptr_owner = True
        attribs = self.PROPERTIES()
        used_attribs = set()
        if len(args) > len(attribs):
            raise ValueError("More positional arguments specified than this type has properties.")
        for i,v in enumerate(args):
            setattr(self,attribs[i],v)
            used_attribs.add(attribs[i])
        valid_names = ", ".join(["'"+p+"'" for p in attribs])
        for k,v in kwargs.items():
            if k in used_attribs:
                raise KeyError(f"argument '{k}' has already been specified as positional argument.")
            elif k not in attribs:
                raise KeyError(f"'{k}' is no valid property name. Valid names: {valid_names}")
            setattr(self,k,v)
    
    def __int__(self):
        """Returns the data's address as long integer."""
        return cpython.long.PyLong_FromVoidPtr(self._ptr)
    def __repr__(self):
        return f"<HIP_RESOURCE_DESC_st_union_0_struct_4 object, self.ptr={int(self)}>"
    def as_c_void_p(self):
        """Returns the data's address as `ctypes.c_void_p`"""
        return ctypes.c_void_p(int(self))
    def get_reserved(self, i):
        """Get value of ``reserved`` of ``self._ptr[i]``.
        """
        return self._ptr[i].reserved
    # TODO add setters
    #def set_reserved(self, i, int[32] value):
    #    """Set value ``reserved`` of ``self._ptr[i]``.
    #    """
    #    self._ptr[i].reserved = value
    @property
    def reserved(self):
        return self.get_reserved(0)
    # TODO add setters
    #@reserved.setter
    #def reserved(self, int[32] value):
    #    self.set_reserved(0,value)

    @staticmethod
    def PROPERTIES():
        return ["reserved"]

    def __contains__(self,item):
        properties = self.PROPERTIES()
        return item in properties

    def __getitem__(self,item):
        properties = self.PROPERTIES()
        if isinstance(item,int):
            if item < 0 or item >= len(properties):
                raise IndexError()
            return getattr(self,properties[item])
        raise ValueError("'item' type must be 'int'")


cdef class HIP_RESOURCE_DESC_st_union_0:
    # members declared in pxd file

    def __cinit__(self):
        self._ptr = NULL
        self.ptr_owner = False
        self._py_buffer_acquired = False

    @staticmethod
    cdef HIP_RESOURCE_DESC_st_union_0 from_ptr(chip.HIP_RESOURCE_DESC_st_union_0* ptr, bint owner=False):
        """Factory function to create ``HIP_RESOURCE_DESC_st_union_0`` objects from
        given ``chip.HIP_RESOURCE_DESC_st_union_0`` pointer.

        Setting ``owner`` flag to ``True`` causes
        the extension type to ``free`` the structure pointed to by ``ptr``
        when the wrapper object is deallocated.
        """
        # Fast call to __new__() that bypasses the __init__() constructor.
        cdef HIP_RESOURCE_DESC_st_union_0 wrapper = HIP_RESOURCE_DESC_st_union_0.__new__(HIP_RESOURCE_DESC_st_union_0)
        wrapper._ptr = ptr
        wrapper.ptr_owner = owner
        return wrapper

    @staticmethod
    cdef HIP_RESOURCE_DESC_st_union_0 from_pyobj(object pyobj):
        """Derives a HIP_RESOURCE_DESC_st_union_0 from a Python object.

        Derives a HIP_RESOURCE_DESC_st_union_0 from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``HIP_RESOURCE_DESC_st_union_0`` reference, this method
        returns it directly. No new ``HIP_RESOURCE_DESC_st_union_0`` is created in this case.

        Args:
            pyobj (object): Must be either ``None``, a simple, contiguous buffer according to the buffer protocol,
                            or of type ``HIP_RESOURCE_DESC_st_union_0``, ``int``, or ``ctypes.c_void_p``

        Note:
            This routine does not perform a copy but returns the original ``pyobj``
            if ``pyobj`` is an instance of HIP_RESOURCE_DESC_st_union_0!
        """
        cdef HIP_RESOURCE_DESC_st_union_0 wrapper = HIP_RESOURCE_DESC_st_union_0.__new__(HIP_RESOURCE_DESC_st_union_0)
        cdef dict cuda_array_interface = getattr(pyobj, "__cuda_array_interface__", None)

        if pyobj is None:
            wrapper._ptr = NULL
        elif isinstance(pyobj,HIP_RESOURCE_DESC_st_union_0):
            return pyobj
        elif isinstance(pyobj,int):
            wrapper._ptr = <chip.HIP_RESOURCE_DESC_st_union_0*>cpython.long.PyLong_AsVoidPtr(pyobj)
        elif isinstance(pyobj,ctypes.c_void_p):
            wrapper._ptr = <chip.HIP_RESOURCE_DESC_st_union_0*>cpython.long.PyLong_AsVoidPtr(pyobj.value) if pyobj.value != None else NULL
        elif cuda_array_interface != None:
            if not "data" in cuda_array_interface:
                raise ValueError("input object has '__cuda_array_interface__' attribute but the dict has no 'data' key")
            ptr_as_int = cuda_array_interface["data"][0]
            wrapper._ptr = <chip.HIP_RESOURCE_DESC_st_union_0*>cpython.long.PyLong_AsVoidPtr(ptr_as_int)
        elif cpython.buffer.PyObject_CheckBuffer(pyobj):
            err = cpython.buffer.PyObject_GetBuffer( 
                pyobj,
                &wrapper._py_buffer, 
                cpython.buffer.PyBUF_SIMPLE | cpython.buffer.PyBUF_ANY_CONTIGUOUS
            )
            if err == -1:
                raise RuntimeError("failed to create simple, contiguous Py_buffer from Python object")
            wrapper._py_buffer_acquired = True
            wrapper._ptr = <chip.HIP_RESOURCE_DESC_st_union_0*>wrapper._py_buffer.buf
        else:
            raise TypeError(f"unsupported input type: '{str(type(pyobj))}'")
        return wrapper
    def __dealloc__(self):
        # Release the buffer handle
        if self._py_buffer_acquired is True:
            cpython.buffer.PyBuffer_Release(&self._py_buffer)
        # De-allocate if not null and flag is set
        if self._ptr is not NULL and self.ptr_owner is True:
            stdlib.free(self._ptr)
            self._ptr = NULL
    @staticmethod
    cdef __allocate(chip.HIP_RESOURCE_DESC_st_union_0** ptr):
        ptr[0] = <chip.HIP_RESOURCE_DESC_st_union_0*>stdlib.malloc(sizeof(chip.HIP_RESOURCE_DESC_st_union_0))

        if ptr[0] is NULL:
            raise MemoryError
        # TODO init values, if present

    @staticmethod
    cdef HIP_RESOURCE_DESC_st_union_0 new():
        """Factory function to create HIP_RESOURCE_DESC_st_union_0 objects with
        newly allocated chip.HIP_RESOURCE_DESC_st_union_0"""
        cdef chip.HIP_RESOURCE_DESC_st_union_0* ptr
        HIP_RESOURCE_DESC_st_union_0.__allocate(&ptr)
        return HIP_RESOURCE_DESC_st_union_0.from_ptr(ptr, owner=True)
   
    # True
    # True
    def __init__(self,**kwargs):
        HIP_RESOURCE_DESC_st_union_0.__allocate(&self._ptr)
        self.ptr_owner = True
        attribs = self.PROPERTIES()
        used_attribs = set()
        if len(kwargs) > 1:
            raise ValueError("Not more than one attribute might specified for Python types derived from C union types.")
        valid_names = ", ".join(["'"+p+"'" for p in attribs])
        for k,v in kwargs.items():
            if k in used_attribs:
                raise KeyError(f"argument '{k}' has already been specified as positional argument.")
            elif k not in attribs:
                raise KeyError(f"'{k}' is no valid property name. Valid names: {valid_names}")
            setattr(self,k,v)
    
    def __int__(self):
        """Returns the data's address as long integer."""
        return cpython.long.PyLong_FromVoidPtr(self._ptr)
    def __repr__(self):
        return f"<HIP_RESOURCE_DESC_st_union_0 object, self.ptr={int(self)}>"
    def as_c_void_p(self):
        """Returns the data's address as `ctypes.c_void_p`"""
        return ctypes.c_void_p(int(self))
    def get_array(self, i):
        """Get value of ``array`` of ``self._ptr[i]``.
        """
        return HIP_RESOURCE_DESC_st_union_0_struct_0.from_ptr(&self._ptr[i].array)
    @property
    def array(self):
        return self.get_array(0)

    def get_mipmap(self, i):
        """Get value of ``mipmap`` of ``self._ptr[i]``.
        """
        return HIP_RESOURCE_DESC_st_union_0_struct_1.from_ptr(&self._ptr[i].mipmap)
    @property
    def mipmap(self):
        return self.get_mipmap(0)

    def get_linear(self, i):
        """Get value of ``linear`` of ``self._ptr[i]``.
        """
        return HIP_RESOURCE_DESC_st_union_0_struct_2.from_ptr(&self._ptr[i].linear)
    @property
    def linear(self):
        return self.get_linear(0)

    def get_pitch2D(self, i):
        """Get value of ``pitch2D`` of ``self._ptr[i]``.
        """
        return HIP_RESOURCE_DESC_st_union_0_struct_3.from_ptr(&self._ptr[i].pitch2D)
    @property
    def pitch2D(self):
        return self.get_pitch2D(0)

    def get_reserved(self, i):
        """Get value of ``reserved`` of ``self._ptr[i]``.
        """
        return HIP_RESOURCE_DESC_st_union_0_struct_4.from_ptr(&self._ptr[i].reserved)
    @property
    def reserved(self):
        return self.get_reserved(0)

    @staticmethod
    def PROPERTIES():
        return ["array","mipmap","linear","pitch2D","reserved"]


cdef class HIP_RESOURCE_DESC_st:
    # members declared in pxd file

    def __cinit__(self):
        self._ptr = NULL
        self.ptr_owner = False
        self._py_buffer_acquired = False

    @staticmethod
    cdef HIP_RESOURCE_DESC_st from_ptr(chip.HIP_RESOURCE_DESC_st* ptr, bint owner=False):
        """Factory function to create ``HIP_RESOURCE_DESC_st`` objects from
        given ``chip.HIP_RESOURCE_DESC_st`` pointer.

        Setting ``owner`` flag to ``True`` causes
        the extension type to ``free`` the structure pointed to by ``ptr``
        when the wrapper object is deallocated.
        """
        # Fast call to __new__() that bypasses the __init__() constructor.
        cdef HIP_RESOURCE_DESC_st wrapper = HIP_RESOURCE_DESC_st.__new__(HIP_RESOURCE_DESC_st)
        wrapper._ptr = ptr
        wrapper.ptr_owner = owner
        return wrapper

    @staticmethod
    cdef HIP_RESOURCE_DESC_st from_pyobj(object pyobj):
        """Derives a HIP_RESOURCE_DESC_st from a Python object.

        Derives a HIP_RESOURCE_DESC_st from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``HIP_RESOURCE_DESC_st`` reference, this method
        returns it directly. No new ``HIP_RESOURCE_DESC_st`` is created in this case.

        Args:
            pyobj (object): Must be either ``None``, a simple, contiguous buffer according to the buffer protocol,
                            or of type ``HIP_RESOURCE_DESC_st``, ``int``, or ``ctypes.c_void_p``

        Note:
            This routine does not perform a copy but returns the original ``pyobj``
            if ``pyobj`` is an instance of HIP_RESOURCE_DESC_st!
        """
        cdef HIP_RESOURCE_DESC_st wrapper = HIP_RESOURCE_DESC_st.__new__(HIP_RESOURCE_DESC_st)
        cdef dict cuda_array_interface = getattr(pyobj, "__cuda_array_interface__", None)

        if pyobj is None:
            wrapper._ptr = NULL
        elif isinstance(pyobj,HIP_RESOURCE_DESC_st):
            return pyobj
        elif isinstance(pyobj,int):
            wrapper._ptr = <chip.HIP_RESOURCE_DESC_st*>cpython.long.PyLong_AsVoidPtr(pyobj)
        elif isinstance(pyobj,ctypes.c_void_p):
            wrapper._ptr = <chip.HIP_RESOURCE_DESC_st*>cpython.long.PyLong_AsVoidPtr(pyobj.value) if pyobj.value != None else NULL
        elif cuda_array_interface != None:
            if not "data" in cuda_array_interface:
                raise ValueError("input object has '__cuda_array_interface__' attribute but the dict has no 'data' key")
            ptr_as_int = cuda_array_interface["data"][0]
            wrapper._ptr = <chip.HIP_RESOURCE_DESC_st*>cpython.long.PyLong_AsVoidPtr(ptr_as_int)
        elif cpython.buffer.PyObject_CheckBuffer(pyobj):
            err = cpython.buffer.PyObject_GetBuffer( 
                pyobj,
                &wrapper._py_buffer, 
                cpython.buffer.PyBUF_SIMPLE | cpython.buffer.PyBUF_ANY_CONTIGUOUS
            )
            if err == -1:
                raise RuntimeError("failed to create simple, contiguous Py_buffer from Python object")
            wrapper._py_buffer_acquired = True
            wrapper._ptr = <chip.HIP_RESOURCE_DESC_st*>wrapper._py_buffer.buf
        else:
            raise TypeError(f"unsupported input type: '{str(type(pyobj))}'")
        return wrapper
    def __dealloc__(self):
        # Release the buffer handle
        if self._py_buffer_acquired is True:
            cpython.buffer.PyBuffer_Release(&self._py_buffer)
        # De-allocate if not null and flag is set
        if self._ptr is not NULL and self.ptr_owner is True:
            stdlib.free(self._ptr)
            self._ptr = NULL
    @staticmethod
    cdef __allocate(chip.HIP_RESOURCE_DESC_st** ptr):
        ptr[0] = <chip.HIP_RESOURCE_DESC_st*>stdlib.malloc(sizeof(chip.HIP_RESOURCE_DESC_st))

        if ptr[0] is NULL:
            raise MemoryError
        # TODO init values, if present

    @staticmethod
    cdef HIP_RESOURCE_DESC_st new():
        """Factory function to create HIP_RESOURCE_DESC_st objects with
        newly allocated chip.HIP_RESOURCE_DESC_st"""
        cdef chip.HIP_RESOURCE_DESC_st* ptr
        HIP_RESOURCE_DESC_st.__allocate(&ptr)
        return HIP_RESOURCE_DESC_st.from_ptr(ptr, owner=True)
   
    def __init__(self,*args,**kwargs):
        HIP_RESOURCE_DESC_st.__allocate(&self._ptr)
        self.ptr_owner = True
        attribs = self.PROPERTIES()
        used_attribs = set()
        if len(args) > len(attribs):
            raise ValueError("More positional arguments specified than this type has properties.")
        for i,v in enumerate(args):
            setattr(self,attribs[i],v)
            used_attribs.add(attribs[i])
        valid_names = ", ".join(["'"+p+"'" for p in attribs])
        for k,v in kwargs.items():
            if k in used_attribs:
                raise KeyError(f"argument '{k}' has already been specified as positional argument.")
            elif k not in attribs:
                raise KeyError(f"'{k}' is no valid property name. Valid names: {valid_names}")
            setattr(self,k,v)
    
    def __int__(self):
        """Returns the data's address as long integer."""
        return cpython.long.PyLong_FromVoidPtr(self._ptr)
    def __repr__(self):
        return f"<HIP_RESOURCE_DESC_st object, self.ptr={int(self)}>"
    def as_c_void_p(self):
        """Returns the data's address as `ctypes.c_void_p`"""
        return ctypes.c_void_p(int(self))
    def get_resType(self, i):
        """Get value of ``resType`` of ``self._ptr[i]``.
        """
        return HIPresourcetype_enum(self._ptr[i].resType)
    def set_resType(self, i, value):
        """Set value ``resType`` of ``self._ptr[i]``.
        """
        if not isinstance(value, HIPresourcetype_enum):
            raise TypeError("'value' must be of type 'HIPresourcetype_enum'")
        self._ptr[i].resType = value.value
    @property
    def resType(self):
        return self.get_resType(0)
    @resType.setter
    def resType(self, value):
        self.set_resType(0,value)

    def get_res(self, i):
        """Get value of ``res`` of ``self._ptr[i]``.
        """
        return HIP_RESOURCE_DESC_st_union_0.from_ptr(&self._ptr[i].res)
    @property
    def res(self):
        return self.get_res(0)

    def get_flags(self, i):
        """Get value ``flags`` of ``self._ptr[i]``.
        """
        return self._ptr[i].flags
    def set_flags(self, i, unsigned int value):
        """Set value ``flags`` of ``self._ptr[i]``.
        """
        self._ptr[i].flags = value
    @property
    def flags(self):
        return self.get_flags(0)
    @flags.setter
    def flags(self, unsigned int value):
        self.set_flags(0,value)

    @staticmethod
    def PROPERTIES():
        return ["resType","res","flags"]

    def __contains__(self,item):
        properties = self.PROPERTIES()
        return item in properties

    def __getitem__(self,item):
        properties = self.PROPERTIES()
        if isinstance(item,int):
            if item < 0 or item >= len(properties):
                raise IndexError()
            return getattr(self,properties[item])
        raise ValueError("'item' type must be 'int'")


HIP_RESOURCE_DESC = HIP_RESOURCE_DESC_st

cdef class hipResourceViewDesc:
    # members declared in pxd file

    def __cinit__(self):
        self._ptr = NULL
        self.ptr_owner = False
        self._py_buffer_acquired = False

    @staticmethod
    cdef hipResourceViewDesc from_ptr(chip.hipResourceViewDesc* ptr, bint owner=False):
        """Factory function to create ``hipResourceViewDesc`` objects from
        given ``chip.hipResourceViewDesc`` pointer.

        Setting ``owner`` flag to ``True`` causes
        the extension type to ``free`` the structure pointed to by ``ptr``
        when the wrapper object is deallocated.
        """
        # Fast call to __new__() that bypasses the __init__() constructor.
        cdef hipResourceViewDesc wrapper = hipResourceViewDesc.__new__(hipResourceViewDesc)
        wrapper._ptr = ptr
        wrapper.ptr_owner = owner
        return wrapper

    @staticmethod
    cdef hipResourceViewDesc from_pyobj(object pyobj):
        """Derives a hipResourceViewDesc from a Python object.

        Derives a hipResourceViewDesc from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``hipResourceViewDesc`` reference, this method
        returns it directly. No new ``hipResourceViewDesc`` is created in this case.

        Args:
            pyobj (object): Must be either ``None``, a simple, contiguous buffer according to the buffer protocol,
                            or of type ``hipResourceViewDesc``, ``int``, or ``ctypes.c_void_p``

        Note:
            This routine does not perform a copy but returns the original ``pyobj``
            if ``pyobj`` is an instance of hipResourceViewDesc!
        """
        cdef hipResourceViewDesc wrapper = hipResourceViewDesc.__new__(hipResourceViewDesc)
        cdef dict cuda_array_interface = getattr(pyobj, "__cuda_array_interface__", None)

        if pyobj is None:
            wrapper._ptr = NULL
        elif isinstance(pyobj,hipResourceViewDesc):
            return pyobj
        elif isinstance(pyobj,int):
            wrapper._ptr = <chip.hipResourceViewDesc*>cpython.long.PyLong_AsVoidPtr(pyobj)
        elif isinstance(pyobj,ctypes.c_void_p):
            wrapper._ptr = <chip.hipResourceViewDesc*>cpython.long.PyLong_AsVoidPtr(pyobj.value) if pyobj.value != None else NULL
        elif cuda_array_interface != None:
            if not "data" in cuda_array_interface:
                raise ValueError("input object has '__cuda_array_interface__' attribute but the dict has no 'data' key")
            ptr_as_int = cuda_array_interface["data"][0]
            wrapper._ptr = <chip.hipResourceViewDesc*>cpython.long.PyLong_AsVoidPtr(ptr_as_int)
        elif cpython.buffer.PyObject_CheckBuffer(pyobj):
            err = cpython.buffer.PyObject_GetBuffer( 
                pyobj,
                &wrapper._py_buffer, 
                cpython.buffer.PyBUF_SIMPLE | cpython.buffer.PyBUF_ANY_CONTIGUOUS
            )
            if err == -1:
                raise RuntimeError("failed to create simple, contiguous Py_buffer from Python object")
            wrapper._py_buffer_acquired = True
            wrapper._ptr = <chip.hipResourceViewDesc*>wrapper._py_buffer.buf
        else:
            raise TypeError(f"unsupported input type: '{str(type(pyobj))}'")
        return wrapper
    def __dealloc__(self):
        # Release the buffer handle
        if self._py_buffer_acquired is True:
            cpython.buffer.PyBuffer_Release(&self._py_buffer)
        # De-allocate if not null and flag is set
        if self._ptr is not NULL and self.ptr_owner is True:
            stdlib.free(self._ptr)
            self._ptr = NULL
    @staticmethod
    cdef __allocate(chip.hipResourceViewDesc** ptr):
        ptr[0] = <chip.hipResourceViewDesc*>stdlib.malloc(sizeof(chip.hipResourceViewDesc))

        if ptr[0] is NULL:
            raise MemoryError
        # TODO init values, if present

    @staticmethod
    cdef hipResourceViewDesc new():
        """Factory function to create hipResourceViewDesc objects with
        newly allocated chip.hipResourceViewDesc"""
        cdef chip.hipResourceViewDesc* ptr
        hipResourceViewDesc.__allocate(&ptr)
        return hipResourceViewDesc.from_ptr(ptr, owner=True)
   
    def __init__(self,*args,**kwargs):
        hipResourceViewDesc.__allocate(&self._ptr)
        self.ptr_owner = True
        attribs = self.PROPERTIES()
        used_attribs = set()
        if len(args) > len(attribs):
            raise ValueError("More positional arguments specified than this type has properties.")
        for i,v in enumerate(args):
            setattr(self,attribs[i],v)
            used_attribs.add(attribs[i])
        valid_names = ", ".join(["'"+p+"'" for p in attribs])
        for k,v in kwargs.items():
            if k in used_attribs:
                raise KeyError(f"argument '{k}' has already been specified as positional argument.")
            elif k not in attribs:
                raise KeyError(f"'{k}' is no valid property name. Valid names: {valid_names}")
            setattr(self,k,v)
    
    def __int__(self):
        """Returns the data's address as long integer."""
        return cpython.long.PyLong_FromVoidPtr(self._ptr)
    def __repr__(self):
        return f"<hipResourceViewDesc object, self.ptr={int(self)}>"
    def as_c_void_p(self):
        """Returns the data's address as `ctypes.c_void_p`"""
        return ctypes.c_void_p(int(self))
    def get_format(self, i):
        """Get value of ``format`` of ``self._ptr[i]``.
        """
        return hipResourceViewFormat(self._ptr[i].format)
    def set_format(self, i, value):
        """Set value ``format`` of ``self._ptr[i]``.
        """
        if not isinstance(value, hipResourceViewFormat):
            raise TypeError("'value' must be of type 'hipResourceViewFormat'")
        self._ptr[i].format = value.value
    @property
    def format(self):
        return self.get_format(0)
    @format.setter
    def format(self, value):
        self.set_format(0,value)

    def get_width(self, i):
        """Get value ``width`` of ``self._ptr[i]``.
        """
        return self._ptr[i].width
    def set_width(self, i, unsigned long value):
        """Set value ``width`` of ``self._ptr[i]``.
        """
        self._ptr[i].width = value
    @property
    def width(self):
        return self.get_width(0)
    @width.setter
    def width(self, unsigned long value):
        self.set_width(0,value)

    def get_height(self, i):
        """Get value ``height`` of ``self._ptr[i]``.
        """
        return self._ptr[i].height
    def set_height(self, i, unsigned long value):
        """Set value ``height`` of ``self._ptr[i]``.
        """
        self._ptr[i].height = value
    @property
    def height(self):
        return self.get_height(0)
    @height.setter
    def height(self, unsigned long value):
        self.set_height(0,value)

    def get_depth(self, i):
        """Get value ``depth`` of ``self._ptr[i]``.
        """
        return self._ptr[i].depth
    def set_depth(self, i, unsigned long value):
        """Set value ``depth`` of ``self._ptr[i]``.
        """
        self._ptr[i].depth = value
    @property
    def depth(self):
        return self.get_depth(0)
    @depth.setter
    def depth(self, unsigned long value):
        self.set_depth(0,value)

    def get_firstMipmapLevel(self, i):
        """Get value ``firstMipmapLevel`` of ``self._ptr[i]``.
        """
        return self._ptr[i].firstMipmapLevel
    def set_firstMipmapLevel(self, i, unsigned int value):
        """Set value ``firstMipmapLevel`` of ``self._ptr[i]``.
        """
        self._ptr[i].firstMipmapLevel = value
    @property
    def firstMipmapLevel(self):
        return self.get_firstMipmapLevel(0)
    @firstMipmapLevel.setter
    def firstMipmapLevel(self, unsigned int value):
        self.set_firstMipmapLevel(0,value)

    def get_lastMipmapLevel(self, i):
        """Get value ``lastMipmapLevel`` of ``self._ptr[i]``.
        """
        return self._ptr[i].lastMipmapLevel
    def set_lastMipmapLevel(self, i, unsigned int value):
        """Set value ``lastMipmapLevel`` of ``self._ptr[i]``.
        """
        self._ptr[i].lastMipmapLevel = value
    @property
    def lastMipmapLevel(self):
        return self.get_lastMipmapLevel(0)
    @lastMipmapLevel.setter
    def lastMipmapLevel(self, unsigned int value):
        self.set_lastMipmapLevel(0,value)

    def get_firstLayer(self, i):
        """Get value ``firstLayer`` of ``self._ptr[i]``.
        """
        return self._ptr[i].firstLayer
    def set_firstLayer(self, i, unsigned int value):
        """Set value ``firstLayer`` of ``self._ptr[i]``.
        """
        self._ptr[i].firstLayer = value
    @property
    def firstLayer(self):
        return self.get_firstLayer(0)
    @firstLayer.setter
    def firstLayer(self, unsigned int value):
        self.set_firstLayer(0,value)

    def get_lastLayer(self, i):
        """Get value ``lastLayer`` of ``self._ptr[i]``.
        """
        return self._ptr[i].lastLayer
    def set_lastLayer(self, i, unsigned int value):
        """Set value ``lastLayer`` of ``self._ptr[i]``.
        """
        self._ptr[i].lastLayer = value
    @property
    def lastLayer(self):
        return self.get_lastLayer(0)
    @lastLayer.setter
    def lastLayer(self, unsigned int value):
        self.set_lastLayer(0,value)

    @staticmethod
    def PROPERTIES():
        return ["format","width","height","depth","firstMipmapLevel","lastMipmapLevel","firstLayer","lastLayer"]

    def __contains__(self,item):
        properties = self.PROPERTIES()
        return item in properties

    def __getitem__(self,item):
        properties = self.PROPERTIES()
        if isinstance(item,int):
            if item < 0 or item >= len(properties):
                raise IndexError()
            return getattr(self,properties[item])
        raise ValueError("'item' type must be 'int'")


cdef class HIP_RESOURCE_VIEW_DESC_st:
    # members declared in pxd file

    def __cinit__(self):
        self._ptr = NULL
        self.ptr_owner = False
        self._py_buffer_acquired = False

    @staticmethod
    cdef HIP_RESOURCE_VIEW_DESC_st from_ptr(chip.HIP_RESOURCE_VIEW_DESC_st* ptr, bint owner=False):
        """Factory function to create ``HIP_RESOURCE_VIEW_DESC_st`` objects from
        given ``chip.HIP_RESOURCE_VIEW_DESC_st`` pointer.

        Setting ``owner`` flag to ``True`` causes
        the extension type to ``free`` the structure pointed to by ``ptr``
        when the wrapper object is deallocated.
        """
        # Fast call to __new__() that bypasses the __init__() constructor.
        cdef HIP_RESOURCE_VIEW_DESC_st wrapper = HIP_RESOURCE_VIEW_DESC_st.__new__(HIP_RESOURCE_VIEW_DESC_st)
        wrapper._ptr = ptr
        wrapper.ptr_owner = owner
        return wrapper

    @staticmethod
    cdef HIP_RESOURCE_VIEW_DESC_st from_pyobj(object pyobj):
        """Derives a HIP_RESOURCE_VIEW_DESC_st from a Python object.

        Derives a HIP_RESOURCE_VIEW_DESC_st from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``HIP_RESOURCE_VIEW_DESC_st`` reference, this method
        returns it directly. No new ``HIP_RESOURCE_VIEW_DESC_st`` is created in this case.

        Args:
            pyobj (object): Must be either ``None``, a simple, contiguous buffer according to the buffer protocol,
                            or of type ``HIP_RESOURCE_VIEW_DESC_st``, ``int``, or ``ctypes.c_void_p``

        Note:
            This routine does not perform a copy but returns the original ``pyobj``
            if ``pyobj`` is an instance of HIP_RESOURCE_VIEW_DESC_st!
        """
        cdef HIP_RESOURCE_VIEW_DESC_st wrapper = HIP_RESOURCE_VIEW_DESC_st.__new__(HIP_RESOURCE_VIEW_DESC_st)
        cdef dict cuda_array_interface = getattr(pyobj, "__cuda_array_interface__", None)

        if pyobj is None:
            wrapper._ptr = NULL
        elif isinstance(pyobj,HIP_RESOURCE_VIEW_DESC_st):
            return pyobj
        elif isinstance(pyobj,int):
            wrapper._ptr = <chip.HIP_RESOURCE_VIEW_DESC_st*>cpython.long.PyLong_AsVoidPtr(pyobj)
        elif isinstance(pyobj,ctypes.c_void_p):
            wrapper._ptr = <chip.HIP_RESOURCE_VIEW_DESC_st*>cpython.long.PyLong_AsVoidPtr(pyobj.value) if pyobj.value != None else NULL
        elif cuda_array_interface != None:
            if not "data" in cuda_array_interface:
                raise ValueError("input object has '__cuda_array_interface__' attribute but the dict has no 'data' key")
            ptr_as_int = cuda_array_interface["data"][0]
            wrapper._ptr = <chip.HIP_RESOURCE_VIEW_DESC_st*>cpython.long.PyLong_AsVoidPtr(ptr_as_int)
        elif cpython.buffer.PyObject_CheckBuffer(pyobj):
            err = cpython.buffer.PyObject_GetBuffer( 
                pyobj,
                &wrapper._py_buffer, 
                cpython.buffer.PyBUF_SIMPLE | cpython.buffer.PyBUF_ANY_CONTIGUOUS
            )
            if err == -1:
                raise RuntimeError("failed to create simple, contiguous Py_buffer from Python object")
            wrapper._py_buffer_acquired = True
            wrapper._ptr = <chip.HIP_RESOURCE_VIEW_DESC_st*>wrapper._py_buffer.buf
        else:
            raise TypeError(f"unsupported input type: '{str(type(pyobj))}'")
        return wrapper
    def __dealloc__(self):
        # Release the buffer handle
        if self._py_buffer_acquired is True:
            cpython.buffer.PyBuffer_Release(&self._py_buffer)
        # De-allocate if not null and flag is set
        if self._ptr is not NULL and self.ptr_owner is True:
            stdlib.free(self._ptr)
            self._ptr = NULL
    @staticmethod
    cdef __allocate(chip.HIP_RESOURCE_VIEW_DESC_st** ptr):
        ptr[0] = <chip.HIP_RESOURCE_VIEW_DESC_st*>stdlib.malloc(sizeof(chip.HIP_RESOURCE_VIEW_DESC_st))

        if ptr[0] is NULL:
            raise MemoryError
        # TODO init values, if present

    @staticmethod
    cdef HIP_RESOURCE_VIEW_DESC_st new():
        """Factory function to create HIP_RESOURCE_VIEW_DESC_st objects with
        newly allocated chip.HIP_RESOURCE_VIEW_DESC_st"""
        cdef chip.HIP_RESOURCE_VIEW_DESC_st* ptr
        HIP_RESOURCE_VIEW_DESC_st.__allocate(&ptr)
        return HIP_RESOURCE_VIEW_DESC_st.from_ptr(ptr, owner=True)
   
    def __init__(self,*args,**kwargs):
        HIP_RESOURCE_VIEW_DESC_st.__allocate(&self._ptr)
        self.ptr_owner = True
        attribs = self.PROPERTIES()
        used_attribs = set()
        if len(args) > len(attribs):
            raise ValueError("More positional arguments specified than this type has properties.")
        for i,v in enumerate(args):
            setattr(self,attribs[i],v)
            used_attribs.add(attribs[i])
        valid_names = ", ".join(["'"+p+"'" for p in attribs])
        for k,v in kwargs.items():
            if k in used_attribs:
                raise KeyError(f"argument '{k}' has already been specified as positional argument.")
            elif k not in attribs:
                raise KeyError(f"'{k}' is no valid property name. Valid names: {valid_names}")
            setattr(self,k,v)
    
    def __int__(self):
        """Returns the data's address as long integer."""
        return cpython.long.PyLong_FromVoidPtr(self._ptr)
    def __repr__(self):
        return f"<HIP_RESOURCE_VIEW_DESC_st object, self.ptr={int(self)}>"
    def as_c_void_p(self):
        """Returns the data's address as `ctypes.c_void_p`"""
        return ctypes.c_void_p(int(self))
    def get_format(self, i):
        """Get value of ``format`` of ``self._ptr[i]``.
        """
        return HIPresourceViewFormat_enum(self._ptr[i].format)
    def set_format(self, i, value):
        """Set value ``format`` of ``self._ptr[i]``.
        """
        if not isinstance(value, HIPresourceViewFormat_enum):
            raise TypeError("'value' must be of type 'HIPresourceViewFormat_enum'")
        self._ptr[i].format = value.value
    @property
    def format(self):
        return self.get_format(0)
    @format.setter
    def format(self, value):
        self.set_format(0,value)

    def get_width(self, i):
        """Get value ``width`` of ``self._ptr[i]``.
        """
        return self._ptr[i].width
    def set_width(self, i, unsigned long value):
        """Set value ``width`` of ``self._ptr[i]``.
        """
        self._ptr[i].width = value
    @property
    def width(self):
        return self.get_width(0)
    @width.setter
    def width(self, unsigned long value):
        self.set_width(0,value)

    def get_height(self, i):
        """Get value ``height`` of ``self._ptr[i]``.
        """
        return self._ptr[i].height
    def set_height(self, i, unsigned long value):
        """Set value ``height`` of ``self._ptr[i]``.
        """
        self._ptr[i].height = value
    @property
    def height(self):
        return self.get_height(0)
    @height.setter
    def height(self, unsigned long value):
        self.set_height(0,value)

    def get_depth(self, i):
        """Get value ``depth`` of ``self._ptr[i]``.
        """
        return self._ptr[i].depth
    def set_depth(self, i, unsigned long value):
        """Set value ``depth`` of ``self._ptr[i]``.
        """
        self._ptr[i].depth = value
    @property
    def depth(self):
        return self.get_depth(0)
    @depth.setter
    def depth(self, unsigned long value):
        self.set_depth(0,value)

    def get_firstMipmapLevel(self, i):
        """Get value ``firstMipmapLevel`` of ``self._ptr[i]``.
        """
        return self._ptr[i].firstMipmapLevel
    def set_firstMipmapLevel(self, i, unsigned int value):
        """Set value ``firstMipmapLevel`` of ``self._ptr[i]``.
        """
        self._ptr[i].firstMipmapLevel = value
    @property
    def firstMipmapLevel(self):
        return self.get_firstMipmapLevel(0)
    @firstMipmapLevel.setter
    def firstMipmapLevel(self, unsigned int value):
        self.set_firstMipmapLevel(0,value)

    def get_lastMipmapLevel(self, i):
        """Get value ``lastMipmapLevel`` of ``self._ptr[i]``.
        """
        return self._ptr[i].lastMipmapLevel
    def set_lastMipmapLevel(self, i, unsigned int value):
        """Set value ``lastMipmapLevel`` of ``self._ptr[i]``.
        """
        self._ptr[i].lastMipmapLevel = value
    @property
    def lastMipmapLevel(self):
        return self.get_lastMipmapLevel(0)
    @lastMipmapLevel.setter
    def lastMipmapLevel(self, unsigned int value):
        self.set_lastMipmapLevel(0,value)

    def get_firstLayer(self, i):
        """Get value ``firstLayer`` of ``self._ptr[i]``.
        """
        return self._ptr[i].firstLayer
    def set_firstLayer(self, i, unsigned int value):
        """Set value ``firstLayer`` of ``self._ptr[i]``.
        """
        self._ptr[i].firstLayer = value
    @property
    def firstLayer(self):
        return self.get_firstLayer(0)
    @firstLayer.setter
    def firstLayer(self, unsigned int value):
        self.set_firstLayer(0,value)

    def get_lastLayer(self, i):
        """Get value ``lastLayer`` of ``self._ptr[i]``.
        """
        return self._ptr[i].lastLayer
    def set_lastLayer(self, i, unsigned int value):
        """Set value ``lastLayer`` of ``self._ptr[i]``.
        """
        self._ptr[i].lastLayer = value
    @property
    def lastLayer(self):
        return self.get_lastLayer(0)
    @lastLayer.setter
    def lastLayer(self, unsigned int value):
        self.set_lastLayer(0,value)

    def get_reserved(self, i):
        """Get value of ``reserved`` of ``self._ptr[i]``.
        """
        return self._ptr[i].reserved
    # TODO add setters
    #def set_reserved(self, i, unsigned int[16] value):
    #    """Set value ``reserved`` of ``self._ptr[i]``.
    #    """
    #    self._ptr[i].reserved = value
    @property
    def reserved(self):
        return self.get_reserved(0)
    # TODO add setters
    #@reserved.setter
    #def reserved(self, unsigned int[16] value):
    #    self.set_reserved(0,value)

    @staticmethod
    def PROPERTIES():
        return ["format","width","height","depth","firstMipmapLevel","lastMipmapLevel","firstLayer","lastLayer","reserved"]

    def __contains__(self,item):
        properties = self.PROPERTIES()
        return item in properties

    def __getitem__(self,item):
        properties = self.PROPERTIES()
        if isinstance(item,int):
            if item < 0 or item >= len(properties):
                raise IndexError()
            return getattr(self,properties[item])
        raise ValueError("'item' type must be 'int'")


HIP_RESOURCE_VIEW_DESC = HIP_RESOURCE_VIEW_DESC_st

class _hipMemcpyKind__Base(enum.IntEnum):
    """Empty enum base class that allows subclassing.
    """
    pass
class hipMemcpyKind(_hipMemcpyKind__Base):
    hipMemcpyHostToHost = chip.hipMemcpyHostToHost
    hipMemcpyHostToDevice = chip.hipMemcpyHostToDevice
    hipMemcpyDeviceToHost = chip.hipMemcpyDeviceToHost
    hipMemcpyDeviceToDevice = chip.hipMemcpyDeviceToDevice
    hipMemcpyDefault = chip.hipMemcpyDefault
    @staticmethod
    def ctypes_type():
        """The type of the enum constants as ctypes type."""
        return ctypes.c_uint 


cdef class hipPitchedPtr:
    # members declared in pxd file

    def __cinit__(self):
        self._ptr = NULL
        self.ptr_owner = False
        self._py_buffer_acquired = False

    @staticmethod
    cdef hipPitchedPtr from_ptr(chip.hipPitchedPtr* ptr, bint owner=False):
        """Factory function to create ``hipPitchedPtr`` objects from
        given ``chip.hipPitchedPtr`` pointer.

        Setting ``owner`` flag to ``True`` causes
        the extension type to ``free`` the structure pointed to by ``ptr``
        when the wrapper object is deallocated.
        """
        # Fast call to __new__() that bypasses the __init__() constructor.
        cdef hipPitchedPtr wrapper = hipPitchedPtr.__new__(hipPitchedPtr)
        wrapper._ptr = ptr
        wrapper.ptr_owner = owner
        return wrapper

    @staticmethod
    cdef hipPitchedPtr from_pyobj(object pyobj):
        """Derives a hipPitchedPtr from a Python object.

        Derives a hipPitchedPtr from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``hipPitchedPtr`` reference, this method
        returns it directly. No new ``hipPitchedPtr`` is created in this case.

        Args:
            pyobj (object): Must be either ``None``, a simple, contiguous buffer according to the buffer protocol,
                            or of type ``hipPitchedPtr``, ``int``, or ``ctypes.c_void_p``

        Note:
            This routine does not perform a copy but returns the original ``pyobj``
            if ``pyobj`` is an instance of hipPitchedPtr!
        """
        cdef hipPitchedPtr wrapper = hipPitchedPtr.__new__(hipPitchedPtr)
        cdef dict cuda_array_interface = getattr(pyobj, "__cuda_array_interface__", None)

        if pyobj is None:
            wrapper._ptr = NULL
        elif isinstance(pyobj,hipPitchedPtr):
            return pyobj
        elif isinstance(pyobj,int):
            wrapper._ptr = <chip.hipPitchedPtr*>cpython.long.PyLong_AsVoidPtr(pyobj)
        elif isinstance(pyobj,ctypes.c_void_p):
            wrapper._ptr = <chip.hipPitchedPtr*>cpython.long.PyLong_AsVoidPtr(pyobj.value) if pyobj.value != None else NULL
        elif cuda_array_interface != None:
            if not "data" in cuda_array_interface:
                raise ValueError("input object has '__cuda_array_interface__' attribute but the dict has no 'data' key")
            ptr_as_int = cuda_array_interface["data"][0]
            wrapper._ptr = <chip.hipPitchedPtr*>cpython.long.PyLong_AsVoidPtr(ptr_as_int)
        elif cpython.buffer.PyObject_CheckBuffer(pyobj):
            err = cpython.buffer.PyObject_GetBuffer( 
                pyobj,
                &wrapper._py_buffer, 
                cpython.buffer.PyBUF_SIMPLE | cpython.buffer.PyBUF_ANY_CONTIGUOUS
            )
            if err == -1:
                raise RuntimeError("failed to create simple, contiguous Py_buffer from Python object")
            wrapper._py_buffer_acquired = True
            wrapper._ptr = <chip.hipPitchedPtr*>wrapper._py_buffer.buf
        else:
            raise TypeError(f"unsupported input type: '{str(type(pyobj))}'")
        return wrapper
    def __dealloc__(self):
        # Release the buffer handle
        if self._py_buffer_acquired is True:
            cpython.buffer.PyBuffer_Release(&self._py_buffer)
        # De-allocate if not null and flag is set
        if self._ptr is not NULL and self.ptr_owner is True:
            stdlib.free(self._ptr)
            self._ptr = NULL
    @staticmethod
    cdef __allocate(chip.hipPitchedPtr** ptr):
        ptr[0] = <chip.hipPitchedPtr*>stdlib.malloc(sizeof(chip.hipPitchedPtr))

        if ptr[0] is NULL:
            raise MemoryError
        # TODO init values, if present

    @staticmethod
    cdef hipPitchedPtr new():
        """Factory function to create hipPitchedPtr objects with
        newly allocated chip.hipPitchedPtr"""
        cdef chip.hipPitchedPtr* ptr
        hipPitchedPtr.__allocate(&ptr)
        return hipPitchedPtr.from_ptr(ptr, owner=True)
   
    def __init__(self,*args,**kwargs):
        hipPitchedPtr.__allocate(&self._ptr)
        self.ptr_owner = True
        attribs = self.PROPERTIES()
        used_attribs = set()
        if len(args) > len(attribs):
            raise ValueError("More positional arguments specified than this type has properties.")
        for i,v in enumerate(args):
            setattr(self,attribs[i],v)
            used_attribs.add(attribs[i])
        valid_names = ", ".join(["'"+p+"'" for p in attribs])
        for k,v in kwargs.items():
            if k in used_attribs:
                raise KeyError(f"argument '{k}' has already been specified as positional argument.")
            elif k not in attribs:
                raise KeyError(f"'{k}' is no valid property name. Valid names: {valid_names}")
            setattr(self,k,v)
    
    def __int__(self):
        """Returns the data's address as long integer."""
        return cpython.long.PyLong_FromVoidPtr(self._ptr)
    def __repr__(self):
        return f"<hipPitchedPtr object, self.ptr={int(self)}>"
    def as_c_void_p(self):
        """Returns the data's address as `ctypes.c_void_p`"""
        return ctypes.c_void_p(int(self))
    def get_ptr(self, i):
        """Get value ``ptr`` of ``self._ptr[i]``.
        """
        return hip._util.types.DataHandle.from_ptr(self._ptr[i].ptr)
    def set_ptr(self, i, object value):
        """Set value ``ptr`` of ``self._ptr[i]``.

        Note:
            This can be dangerous if the pointer is from a python object
            that is later on garbage collected.
        """
        self._ptr[i].ptr = <void *>cpython.long.PyLong_AsVoidPtr(int(hip._util.types.DataHandle.from_pyobj(value)))
    @property
    def ptr(self):
        """
        Note:
            Setting this ptr can be dangerous if the underlying pointer is from a python object that
            is later on garbage collected.
        """
        return self.get_ptr(0)
    @ptr.setter
    def ptr(self, object value):
        self.set_ptr(0,value)

    def get_pitch(self, i):
        """Get value ``pitch`` of ``self._ptr[i]``.
        """
        return self._ptr[i].pitch
    def set_pitch(self, i, unsigned long value):
        """Set value ``pitch`` of ``self._ptr[i]``.
        """
        self._ptr[i].pitch = value
    @property
    def pitch(self):
        return self.get_pitch(0)
    @pitch.setter
    def pitch(self, unsigned long value):
        self.set_pitch(0,value)

    def get_xsize(self, i):
        """Get value ``xsize`` of ``self._ptr[i]``.
        """
        return self._ptr[i].xsize
    def set_xsize(self, i, unsigned long value):
        """Set value ``xsize`` of ``self._ptr[i]``.
        """
        self._ptr[i].xsize = value
    @property
    def xsize(self):
        return self.get_xsize(0)
    @xsize.setter
    def xsize(self, unsigned long value):
        self.set_xsize(0,value)

    def get_ysize(self, i):
        """Get value ``ysize`` of ``self._ptr[i]``.
        """
        return self._ptr[i].ysize
    def set_ysize(self, i, unsigned long value):
        """Set value ``ysize`` of ``self._ptr[i]``.
        """
        self._ptr[i].ysize = value
    @property
    def ysize(self):
        return self.get_ysize(0)
    @ysize.setter
    def ysize(self, unsigned long value):
        self.set_ysize(0,value)

    @staticmethod
    def PROPERTIES():
        return ["ptr","pitch","xsize","ysize"]

    def __contains__(self,item):
        properties = self.PROPERTIES()
        return item in properties

    def __getitem__(self,item):
        properties = self.PROPERTIES()
        if isinstance(item,int):
            if item < 0 or item >= len(properties):
                raise IndexError()
            return getattr(self,properties[item])
        raise ValueError("'item' type must be 'int'")


cdef class hipExtent:
    # members declared in pxd file

    def __cinit__(self):
        self._ptr = NULL
        self.ptr_owner = False
        self._py_buffer_acquired = False

    @staticmethod
    cdef hipExtent from_ptr(chip.hipExtent* ptr, bint owner=False):
        """Factory function to create ``hipExtent`` objects from
        given ``chip.hipExtent`` pointer.

        Setting ``owner`` flag to ``True`` causes
        the extension type to ``free`` the structure pointed to by ``ptr``
        when the wrapper object is deallocated.
        """
        # Fast call to __new__() that bypasses the __init__() constructor.
        cdef hipExtent wrapper = hipExtent.__new__(hipExtent)
        wrapper._ptr = ptr
        wrapper.ptr_owner = owner
        return wrapper

    @staticmethod
    cdef hipExtent from_pyobj(object pyobj):
        """Derives a hipExtent from a Python object.

        Derives a hipExtent from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``hipExtent`` reference, this method
        returns it directly. No new ``hipExtent`` is created in this case.

        Args:
            pyobj (object): Must be either ``None``, a simple, contiguous buffer according to the buffer protocol,
                            or of type ``hipExtent``, ``int``, or ``ctypes.c_void_p``

        Note:
            This routine does not perform a copy but returns the original ``pyobj``
            if ``pyobj`` is an instance of hipExtent!
        """
        cdef hipExtent wrapper = hipExtent.__new__(hipExtent)
        cdef dict cuda_array_interface = getattr(pyobj, "__cuda_array_interface__", None)

        if pyobj is None:
            wrapper._ptr = NULL
        elif isinstance(pyobj,hipExtent):
            return pyobj
        elif isinstance(pyobj,int):
            wrapper._ptr = <chip.hipExtent*>cpython.long.PyLong_AsVoidPtr(pyobj)
        elif isinstance(pyobj,ctypes.c_void_p):
            wrapper._ptr = <chip.hipExtent*>cpython.long.PyLong_AsVoidPtr(pyobj.value) if pyobj.value != None else NULL
        elif cuda_array_interface != None:
            if not "data" in cuda_array_interface:
                raise ValueError("input object has '__cuda_array_interface__' attribute but the dict has no 'data' key")
            ptr_as_int = cuda_array_interface["data"][0]
            wrapper._ptr = <chip.hipExtent*>cpython.long.PyLong_AsVoidPtr(ptr_as_int)
        elif cpython.buffer.PyObject_CheckBuffer(pyobj):
            err = cpython.buffer.PyObject_GetBuffer( 
                pyobj,
                &wrapper._py_buffer, 
                cpython.buffer.PyBUF_SIMPLE | cpython.buffer.PyBUF_ANY_CONTIGUOUS
            )
            if err == -1:
                raise RuntimeError("failed to create simple, contiguous Py_buffer from Python object")
            wrapper._py_buffer_acquired = True
            wrapper._ptr = <chip.hipExtent*>wrapper._py_buffer.buf
        else:
            raise TypeError(f"unsupported input type: '{str(type(pyobj))}'")
        return wrapper
    def __dealloc__(self):
        # Release the buffer handle
        if self._py_buffer_acquired is True:
            cpython.buffer.PyBuffer_Release(&self._py_buffer)
        # De-allocate if not null and flag is set
        if self._ptr is not NULL and self.ptr_owner is True:
            stdlib.free(self._ptr)
            self._ptr = NULL
    @staticmethod
    cdef __allocate(chip.hipExtent** ptr):
        ptr[0] = <chip.hipExtent*>stdlib.malloc(sizeof(chip.hipExtent))

        if ptr[0] is NULL:
            raise MemoryError
        # TODO init values, if present

    @staticmethod
    cdef hipExtent new():
        """Factory function to create hipExtent objects with
        newly allocated chip.hipExtent"""
        cdef chip.hipExtent* ptr
        hipExtent.__allocate(&ptr)
        return hipExtent.from_ptr(ptr, owner=True)
   
    def __init__(self,*args,**kwargs):
        hipExtent.__allocate(&self._ptr)
        self.ptr_owner = True
        attribs = self.PROPERTIES()
        used_attribs = set()
        if len(args) > len(attribs):
            raise ValueError("More positional arguments specified than this type has properties.")
        for i,v in enumerate(args):
            setattr(self,attribs[i],v)
            used_attribs.add(attribs[i])
        valid_names = ", ".join(["'"+p+"'" for p in attribs])
        for k,v in kwargs.items():
            if k in used_attribs:
                raise KeyError(f"argument '{k}' has already been specified as positional argument.")
            elif k not in attribs:
                raise KeyError(f"'{k}' is no valid property name. Valid names: {valid_names}")
            setattr(self,k,v)
    
    def __int__(self):
        """Returns the data's address as long integer."""
        return cpython.long.PyLong_FromVoidPtr(self._ptr)
    def __repr__(self):
        return f"<hipExtent object, self.ptr={int(self)}>"
    def as_c_void_p(self):
        """Returns the data's address as `ctypes.c_void_p`"""
        return ctypes.c_void_p(int(self))
    def get_width(self, i):
        """Get value ``width`` of ``self._ptr[i]``.
        """
        return self._ptr[i].width
    def set_width(self, i, unsigned long value):
        """Set value ``width`` of ``self._ptr[i]``.
        """
        self._ptr[i].width = value
    @property
    def width(self):
        return self.get_width(0)
    @width.setter
    def width(self, unsigned long value):
        self.set_width(0,value)

    def get_height(self, i):
        """Get value ``height`` of ``self._ptr[i]``.
        """
        return self._ptr[i].height
    def set_height(self, i, unsigned long value):
        """Set value ``height`` of ``self._ptr[i]``.
        """
        self._ptr[i].height = value
    @property
    def height(self):
        return self.get_height(0)
    @height.setter
    def height(self, unsigned long value):
        self.set_height(0,value)

    def get_depth(self, i):
        """Get value ``depth`` of ``self._ptr[i]``.
        """
        return self._ptr[i].depth
    def set_depth(self, i, unsigned long value):
        """Set value ``depth`` of ``self._ptr[i]``.
        """
        self._ptr[i].depth = value
    @property
    def depth(self):
        return self.get_depth(0)
    @depth.setter
    def depth(self, unsigned long value):
        self.set_depth(0,value)

    @staticmethod
    def PROPERTIES():
        return ["width","height","depth"]

    def __contains__(self,item):
        properties = self.PROPERTIES()
        return item in properties

    def __getitem__(self,item):
        properties = self.PROPERTIES()
        if isinstance(item,int):
            if item < 0 or item >= len(properties):
                raise IndexError()
            return getattr(self,properties[item])
        raise ValueError("'item' type must be 'int'")


cdef class hipPos:
    # members declared in pxd file

    def __cinit__(self):
        self._ptr = NULL
        self.ptr_owner = False
        self._py_buffer_acquired = False

    @staticmethod
    cdef hipPos from_ptr(chip.hipPos* ptr, bint owner=False):
        """Factory function to create ``hipPos`` objects from
        given ``chip.hipPos`` pointer.

        Setting ``owner`` flag to ``True`` causes
        the extension type to ``free`` the structure pointed to by ``ptr``
        when the wrapper object is deallocated.
        """
        # Fast call to __new__() that bypasses the __init__() constructor.
        cdef hipPos wrapper = hipPos.__new__(hipPos)
        wrapper._ptr = ptr
        wrapper.ptr_owner = owner
        return wrapper

    @staticmethod
    cdef hipPos from_pyobj(object pyobj):
        """Derives a hipPos from a Python object.

        Derives a hipPos from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``hipPos`` reference, this method
        returns it directly. No new ``hipPos`` is created in this case.

        Args:
            pyobj (object): Must be either ``None``, a simple, contiguous buffer according to the buffer protocol,
                            or of type ``hipPos``, ``int``, or ``ctypes.c_void_p``

        Note:
            This routine does not perform a copy but returns the original ``pyobj``
            if ``pyobj`` is an instance of hipPos!
        """
        cdef hipPos wrapper = hipPos.__new__(hipPos)
        cdef dict cuda_array_interface = getattr(pyobj, "__cuda_array_interface__", None)

        if pyobj is None:
            wrapper._ptr = NULL
        elif isinstance(pyobj,hipPos):
            return pyobj
        elif isinstance(pyobj,int):
            wrapper._ptr = <chip.hipPos*>cpython.long.PyLong_AsVoidPtr(pyobj)
        elif isinstance(pyobj,ctypes.c_void_p):
            wrapper._ptr = <chip.hipPos*>cpython.long.PyLong_AsVoidPtr(pyobj.value) if pyobj.value != None else NULL
        elif cuda_array_interface != None:
            if not "data" in cuda_array_interface:
                raise ValueError("input object has '__cuda_array_interface__' attribute but the dict has no 'data' key")
            ptr_as_int = cuda_array_interface["data"][0]
            wrapper._ptr = <chip.hipPos*>cpython.long.PyLong_AsVoidPtr(ptr_as_int)
        elif cpython.buffer.PyObject_CheckBuffer(pyobj):
            err = cpython.buffer.PyObject_GetBuffer( 
                pyobj,
                &wrapper._py_buffer, 
                cpython.buffer.PyBUF_SIMPLE | cpython.buffer.PyBUF_ANY_CONTIGUOUS
            )
            if err == -1:
                raise RuntimeError("failed to create simple, contiguous Py_buffer from Python object")
            wrapper._py_buffer_acquired = True
            wrapper._ptr = <chip.hipPos*>wrapper._py_buffer.buf
        else:
            raise TypeError(f"unsupported input type: '{str(type(pyobj))}'")
        return wrapper
    def __dealloc__(self):
        # Release the buffer handle
        if self._py_buffer_acquired is True:
            cpython.buffer.PyBuffer_Release(&self._py_buffer)
        # De-allocate if not null and flag is set
        if self._ptr is not NULL and self.ptr_owner is True:
            stdlib.free(self._ptr)
            self._ptr = NULL
    @staticmethod
    cdef __allocate(chip.hipPos** ptr):
        ptr[0] = <chip.hipPos*>stdlib.malloc(sizeof(chip.hipPos))

        if ptr[0] is NULL:
            raise MemoryError
        # TODO init values, if present

    @staticmethod
    cdef hipPos new():
        """Factory function to create hipPos objects with
        newly allocated chip.hipPos"""
        cdef chip.hipPos* ptr
        hipPos.__allocate(&ptr)
        return hipPos.from_ptr(ptr, owner=True)
   
    def __init__(self,*args,**kwargs):
        hipPos.__allocate(&self._ptr)
        self.ptr_owner = True
        attribs = self.PROPERTIES()
        used_attribs = set()
        if len(args) > len(attribs):
            raise ValueError("More positional arguments specified than this type has properties.")
        for i,v in enumerate(args):
            setattr(self,attribs[i],v)
            used_attribs.add(attribs[i])
        valid_names = ", ".join(["'"+p+"'" for p in attribs])
        for k,v in kwargs.items():
            if k in used_attribs:
                raise KeyError(f"argument '{k}' has already been specified as positional argument.")
            elif k not in attribs:
                raise KeyError(f"'{k}' is no valid property name. Valid names: {valid_names}")
            setattr(self,k,v)
    
    def __int__(self):
        """Returns the data's address as long integer."""
        return cpython.long.PyLong_FromVoidPtr(self._ptr)
    def __repr__(self):
        return f"<hipPos object, self.ptr={int(self)}>"
    def as_c_void_p(self):
        """Returns the data's address as `ctypes.c_void_p`"""
        return ctypes.c_void_p(int(self))
    def get_x(self, i):
        """Get value ``x`` of ``self._ptr[i]``.
        """
        return self._ptr[i].x
    def set_x(self, i, unsigned long value):
        """Set value ``x`` of ``self._ptr[i]``.
        """
        self._ptr[i].x = value
    @property
    def x(self):
        return self.get_x(0)
    @x.setter
    def x(self, unsigned long value):
        self.set_x(0,value)

    def get_y(self, i):
        """Get value ``y`` of ``self._ptr[i]``.
        """
        return self._ptr[i].y
    def set_y(self, i, unsigned long value):
        """Set value ``y`` of ``self._ptr[i]``.
        """
        self._ptr[i].y = value
    @property
    def y(self):
        return self.get_y(0)
    @y.setter
    def y(self, unsigned long value):
        self.set_y(0,value)

    def get_z(self, i):
        """Get value ``z`` of ``self._ptr[i]``.
        """
        return self._ptr[i].z
    def set_z(self, i, unsigned long value):
        """Set value ``z`` of ``self._ptr[i]``.
        """
        self._ptr[i].z = value
    @property
    def z(self):
        return self.get_z(0)
    @z.setter
    def z(self, unsigned long value):
        self.set_z(0,value)

    @staticmethod
    def PROPERTIES():
        return ["x","y","z"]

    def __contains__(self,item):
        properties = self.PROPERTIES()
        return item in properties

    def __getitem__(self,item):
        properties = self.PROPERTIES()
        if isinstance(item,int):
            if item < 0 or item >= len(properties):
                raise IndexError()
            return getattr(self,properties[item])
        raise ValueError("'item' type must be 'int'")


cdef class hipMemcpy3DParms:
    # members declared in pxd file

    def __cinit__(self):
        self._ptr = NULL
        self.ptr_owner = False
        self._py_buffer_acquired = False

    @staticmethod
    cdef hipMemcpy3DParms from_ptr(chip.hipMemcpy3DParms* ptr, bint owner=False):
        """Factory function to create ``hipMemcpy3DParms`` objects from
        given ``chip.hipMemcpy3DParms`` pointer.

        Setting ``owner`` flag to ``True`` causes
        the extension type to ``free`` the structure pointed to by ``ptr``
        when the wrapper object is deallocated.
        """
        # Fast call to __new__() that bypasses the __init__() constructor.
        cdef hipMemcpy3DParms wrapper = hipMemcpy3DParms.__new__(hipMemcpy3DParms)
        wrapper._ptr = ptr
        wrapper.ptr_owner = owner
        return wrapper

    @staticmethod
    cdef hipMemcpy3DParms from_pyobj(object pyobj):
        """Derives a hipMemcpy3DParms from a Python object.

        Derives a hipMemcpy3DParms from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``hipMemcpy3DParms`` reference, this method
        returns it directly. No new ``hipMemcpy3DParms`` is created in this case.

        Args:
            pyobj (object): Must be either ``None``, a simple, contiguous buffer according to the buffer protocol,
                            or of type ``hipMemcpy3DParms``, ``int``, or ``ctypes.c_void_p``

        Note:
            This routine does not perform a copy but returns the original ``pyobj``
            if ``pyobj`` is an instance of hipMemcpy3DParms!
        """
        cdef hipMemcpy3DParms wrapper = hipMemcpy3DParms.__new__(hipMemcpy3DParms)
        cdef dict cuda_array_interface = getattr(pyobj, "__cuda_array_interface__", None)

        if pyobj is None:
            wrapper._ptr = NULL
        elif isinstance(pyobj,hipMemcpy3DParms):
            return pyobj
        elif isinstance(pyobj,int):
            wrapper._ptr = <chip.hipMemcpy3DParms*>cpython.long.PyLong_AsVoidPtr(pyobj)
        elif isinstance(pyobj,ctypes.c_void_p):
            wrapper._ptr = <chip.hipMemcpy3DParms*>cpython.long.PyLong_AsVoidPtr(pyobj.value) if pyobj.value != None else NULL
        elif cuda_array_interface != None:
            if not "data" in cuda_array_interface:
                raise ValueError("input object has '__cuda_array_interface__' attribute but the dict has no 'data' key")
            ptr_as_int = cuda_array_interface["data"][0]
            wrapper._ptr = <chip.hipMemcpy3DParms*>cpython.long.PyLong_AsVoidPtr(ptr_as_int)
        elif cpython.buffer.PyObject_CheckBuffer(pyobj):
            err = cpython.buffer.PyObject_GetBuffer( 
                pyobj,
                &wrapper._py_buffer, 
                cpython.buffer.PyBUF_SIMPLE | cpython.buffer.PyBUF_ANY_CONTIGUOUS
            )
            if err == -1:
                raise RuntimeError("failed to create simple, contiguous Py_buffer from Python object")
            wrapper._py_buffer_acquired = True
            wrapper._ptr = <chip.hipMemcpy3DParms*>wrapper._py_buffer.buf
        else:
            raise TypeError(f"unsupported input type: '{str(type(pyobj))}'")
        return wrapper
    def __dealloc__(self):
        # Release the buffer handle
        if self._py_buffer_acquired is True:
            cpython.buffer.PyBuffer_Release(&self._py_buffer)
        # De-allocate if not null and flag is set
        if self._ptr is not NULL and self.ptr_owner is True:
            stdlib.free(self._ptr)
            self._ptr = NULL
    @staticmethod
    cdef __allocate(chip.hipMemcpy3DParms** ptr):
        ptr[0] = <chip.hipMemcpy3DParms*>stdlib.malloc(sizeof(chip.hipMemcpy3DParms))

        if ptr[0] is NULL:
            raise MemoryError
        # TODO init values, if present

    @staticmethod
    cdef hipMemcpy3DParms new():
        """Factory function to create hipMemcpy3DParms objects with
        newly allocated chip.hipMemcpy3DParms"""
        cdef chip.hipMemcpy3DParms* ptr
        hipMemcpy3DParms.__allocate(&ptr)
        return hipMemcpy3DParms.from_ptr(ptr, owner=True)
   
    # False
    # False
    def __init__(self,**kwargs):
        hipMemcpy3DParms.__allocate(&self._ptr)
        self.ptr_owner = True
        attribs = self.PROPERTIES()
        used_attribs = set()
        valid_names = ", ".join(["'"+p+"'" for p in attribs])
        for k,v in kwargs.items():
            if k in used_attribs:
                raise KeyError(f"argument '{k}' has already been specified as positional argument.")
            elif k not in attribs:
                raise KeyError(f"'{k}' is no valid property name. Valid names: {valid_names}")
            setattr(self,k,v)
    
    def __int__(self):
        """Returns the data's address as long integer."""
        return cpython.long.PyLong_FromVoidPtr(self._ptr)
    def __repr__(self):
        return f"<hipMemcpy3DParms object, self.ptr={int(self)}>"
    def as_c_void_p(self):
        """Returns the data's address as `ctypes.c_void_p`"""
        return ctypes.c_void_p(int(self))
    def get_srcPos(self, i):
        """Get value of ``srcPos`` of ``self._ptr[i]``.
        """
        return hipPos.from_ptr(&self._ptr[i].srcPos)
    @property
    def srcPos(self):
        return self.get_srcPos(0)

    def get_srcPtr(self, i):
        """Get value of ``srcPtr`` of ``self._ptr[i]``.
        """
        return hipPitchedPtr.from_ptr(&self._ptr[i].srcPtr)
    @property
    def srcPtr(self):
        return self.get_srcPtr(0)

    def get_dstPos(self, i):
        """Get value of ``dstPos`` of ``self._ptr[i]``.
        """
        return hipPos.from_ptr(&self._ptr[i].dstPos)
    @property
    def dstPos(self):
        return self.get_dstPos(0)

    def get_dstPtr(self, i):
        """Get value of ``dstPtr`` of ``self._ptr[i]``.
        """
        return hipPitchedPtr.from_ptr(&self._ptr[i].dstPtr)
    @property
    def dstPtr(self):
        return self.get_dstPtr(0)

    def get_extent(self, i):
        """Get value of ``extent`` of ``self._ptr[i]``.
        """
        return hipExtent.from_ptr(&self._ptr[i].extent)
    @property
    def extent(self):
        return self.get_extent(0)

    def get_kind(self, i):
        """Get value of ``kind`` of ``self._ptr[i]``.
        """
        return hipMemcpyKind(self._ptr[i].kind)
    def set_kind(self, i, value):
        """Set value ``kind`` of ``self._ptr[i]``.
        """
        if not isinstance(value, hipMemcpyKind):
            raise TypeError("'value' must be of type 'hipMemcpyKind'")
        self._ptr[i].kind = value.value
    @property
    def kind(self):
        return self.get_kind(0)
    @kind.setter
    def kind(self, value):
        self.set_kind(0,value)

    @staticmethod
    def PROPERTIES():
        return ["srcPos","srcPtr","dstPos","dstPtr","extent","kind"]

    def __contains__(self,item):
        properties = self.PROPERTIES()
        return item in properties

    def __getitem__(self,item):
        properties = self.PROPERTIES()
        if isinstance(item,int):
            if item < 0 or item >= len(properties):
                raise IndexError()
            return getattr(self,properties[item])
        raise ValueError("'item' type must be 'int'")


cdef class HIP_MEMCPY3D:
    # members declared in pxd file

    def __cinit__(self):
        self._ptr = NULL
        self.ptr_owner = False
        self._py_buffer_acquired = False

    @staticmethod
    cdef HIP_MEMCPY3D from_ptr(chip.HIP_MEMCPY3D* ptr, bint owner=False):
        """Factory function to create ``HIP_MEMCPY3D`` objects from
        given ``chip.HIP_MEMCPY3D`` pointer.

        Setting ``owner`` flag to ``True`` causes
        the extension type to ``free`` the structure pointed to by ``ptr``
        when the wrapper object is deallocated.
        """
        # Fast call to __new__() that bypasses the __init__() constructor.
        cdef HIP_MEMCPY3D wrapper = HIP_MEMCPY3D.__new__(HIP_MEMCPY3D)
        wrapper._ptr = ptr
        wrapper.ptr_owner = owner
        return wrapper

    @staticmethod
    cdef HIP_MEMCPY3D from_pyobj(object pyobj):
        """Derives a HIP_MEMCPY3D from a Python object.

        Derives a HIP_MEMCPY3D from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``HIP_MEMCPY3D`` reference, this method
        returns it directly. No new ``HIP_MEMCPY3D`` is created in this case.

        Args:
            pyobj (object): Must be either ``None``, a simple, contiguous buffer according to the buffer protocol,
                            or of type ``HIP_MEMCPY3D``, ``int``, or ``ctypes.c_void_p``

        Note:
            This routine does not perform a copy but returns the original ``pyobj``
            if ``pyobj`` is an instance of HIP_MEMCPY3D!
        """
        cdef HIP_MEMCPY3D wrapper = HIP_MEMCPY3D.__new__(HIP_MEMCPY3D)
        cdef dict cuda_array_interface = getattr(pyobj, "__cuda_array_interface__", None)

        if pyobj is None:
            wrapper._ptr = NULL
        elif isinstance(pyobj,HIP_MEMCPY3D):
            return pyobj
        elif isinstance(pyobj,int):
            wrapper._ptr = <chip.HIP_MEMCPY3D*>cpython.long.PyLong_AsVoidPtr(pyobj)
        elif isinstance(pyobj,ctypes.c_void_p):
            wrapper._ptr = <chip.HIP_MEMCPY3D*>cpython.long.PyLong_AsVoidPtr(pyobj.value) if pyobj.value != None else NULL
        elif cuda_array_interface != None:
            if not "data" in cuda_array_interface:
                raise ValueError("input object has '__cuda_array_interface__' attribute but the dict has no 'data' key")
            ptr_as_int = cuda_array_interface["data"][0]
            wrapper._ptr = <chip.HIP_MEMCPY3D*>cpython.long.PyLong_AsVoidPtr(ptr_as_int)
        elif cpython.buffer.PyObject_CheckBuffer(pyobj):
            err = cpython.buffer.PyObject_GetBuffer( 
                pyobj,
                &wrapper._py_buffer, 
                cpython.buffer.PyBUF_SIMPLE | cpython.buffer.PyBUF_ANY_CONTIGUOUS
            )
            if err == -1:
                raise RuntimeError("failed to create simple, contiguous Py_buffer from Python object")
            wrapper._py_buffer_acquired = True
            wrapper._ptr = <chip.HIP_MEMCPY3D*>wrapper._py_buffer.buf
        else:
            raise TypeError(f"unsupported input type: '{str(type(pyobj))}'")
        return wrapper
    def __dealloc__(self):
        # Release the buffer handle
        if self._py_buffer_acquired is True:
            cpython.buffer.PyBuffer_Release(&self._py_buffer)
        # De-allocate if not null and flag is set
        if self._ptr is not NULL and self.ptr_owner is True:
            stdlib.free(self._ptr)
            self._ptr = NULL
    @staticmethod
    cdef __allocate(chip.HIP_MEMCPY3D** ptr):
        ptr[0] = <chip.HIP_MEMCPY3D*>stdlib.malloc(sizeof(chip.HIP_MEMCPY3D))

        if ptr[0] is NULL:
            raise MemoryError
        # TODO init values, if present

    @staticmethod
    cdef HIP_MEMCPY3D new():
        """Factory function to create HIP_MEMCPY3D objects with
        newly allocated chip.HIP_MEMCPY3D"""
        cdef chip.HIP_MEMCPY3D* ptr
        HIP_MEMCPY3D.__allocate(&ptr)
        return HIP_MEMCPY3D.from_ptr(ptr, owner=True)
   
    # False
    # False
    def __init__(self,**kwargs):
        HIP_MEMCPY3D.__allocate(&self._ptr)
        self.ptr_owner = True
        attribs = self.PROPERTIES()
        used_attribs = set()
        valid_names = ", ".join(["'"+p+"'" for p in attribs])
        for k,v in kwargs.items():
            if k in used_attribs:
                raise KeyError(f"argument '{k}' has already been specified as positional argument.")
            elif k not in attribs:
                raise KeyError(f"'{k}' is no valid property name. Valid names: {valid_names}")
            setattr(self,k,v)
    
    def __int__(self):
        """Returns the data's address as long integer."""
        return cpython.long.PyLong_FromVoidPtr(self._ptr)
    def __repr__(self):
        return f"<HIP_MEMCPY3D object, self.ptr={int(self)}>"
    def as_c_void_p(self):
        """Returns the data's address as `ctypes.c_void_p`"""
        return ctypes.c_void_p(int(self))
    def get_srcXInBytes(self, i):
        """Get value ``srcXInBytes`` of ``self._ptr[i]``.
        """
        return self._ptr[i].srcXInBytes
    def set_srcXInBytes(self, i, unsigned int value):
        """Set value ``srcXInBytes`` of ``self._ptr[i]``.
        """
        self._ptr[i].srcXInBytes = value
    @property
    def srcXInBytes(self):
        return self.get_srcXInBytes(0)
    @srcXInBytes.setter
    def srcXInBytes(self, unsigned int value):
        self.set_srcXInBytes(0,value)

    def get_srcY(self, i):
        """Get value ``srcY`` of ``self._ptr[i]``.
        """
        return self._ptr[i].srcY
    def set_srcY(self, i, unsigned int value):
        """Set value ``srcY`` of ``self._ptr[i]``.
        """
        self._ptr[i].srcY = value
    @property
    def srcY(self):
        return self.get_srcY(0)
    @srcY.setter
    def srcY(self, unsigned int value):
        self.set_srcY(0,value)

    def get_srcZ(self, i):
        """Get value ``srcZ`` of ``self._ptr[i]``.
        """
        return self._ptr[i].srcZ
    def set_srcZ(self, i, unsigned int value):
        """Set value ``srcZ`` of ``self._ptr[i]``.
        """
        self._ptr[i].srcZ = value
    @property
    def srcZ(self):
        return self.get_srcZ(0)
    @srcZ.setter
    def srcZ(self, unsigned int value):
        self.set_srcZ(0,value)

    def get_srcLOD(self, i):
        """Get value ``srcLOD`` of ``self._ptr[i]``.
        """
        return self._ptr[i].srcLOD
    def set_srcLOD(self, i, unsigned int value):
        """Set value ``srcLOD`` of ``self._ptr[i]``.
        """
        self._ptr[i].srcLOD = value
    @property
    def srcLOD(self):
        return self.get_srcLOD(0)
    @srcLOD.setter
    def srcLOD(self, unsigned int value):
        self.set_srcLOD(0,value)

    def get_srcMemoryType(self, i):
        """Get value of ``srcMemoryType`` of ``self._ptr[i]``.
        """
        return hipMemoryType(self._ptr[i].srcMemoryType)
    def set_srcMemoryType(self, i, value):
        """Set value ``srcMemoryType`` of ``self._ptr[i]``.
        """
        if not isinstance(value, hipMemoryType):
            raise TypeError("'value' must be of type 'hipMemoryType'")
        self._ptr[i].srcMemoryType = value.value
    @property
    def srcMemoryType(self):
        return self.get_srcMemoryType(0)
    @srcMemoryType.setter
    def srcMemoryType(self, value):
        self.set_srcMemoryType(0,value)

    def get_srcHost(self, i):
        """Get value ``srcHost`` of ``self._ptr[i]``.
        """
        return hip._util.types.DataHandle.from_ptr(self._ptr[i].srcHost)
    def set_srcHost(self, i, object value):
        """Set value ``srcHost`` of ``self._ptr[i]``.

        Note:
            This can be dangerous if the pointer is from a python object
            that is later on garbage collected.
        """
        self._ptr[i].srcHost = <const void *>cpython.long.PyLong_AsVoidPtr(int(hip._util.types.DataHandle.from_pyobj(value)))
    @property
    def srcHost(self):
        """
        Note:
            Setting this srcHost can be dangerous if the underlying pointer is from a python object that
            is later on garbage collected.
        """
        return self.get_srcHost(0)
    @srcHost.setter
    def srcHost(self, object value):
        self.set_srcHost(0,value)

    def get_srcDevice(self, i):
        """Get value ``srcDevice`` of ``self._ptr[i]``.
        """
        return hip._util.types.DataHandle.from_ptr(self._ptr[i].srcDevice)
    def set_srcDevice(self, i, object value):
        """Set value ``srcDevice`` of ``self._ptr[i]``.

        Note:
            This can be dangerous if the pointer is from a python object
            that is later on garbage collected.
        """
        self._ptr[i].srcDevice = <void *>cpython.long.PyLong_AsVoidPtr(int(hip._util.types.DataHandle.from_pyobj(value)))
    @property
    def srcDevice(self):
        """
        Note:
            Setting this srcDevice can be dangerous if the underlying pointer is from a python object that
            is later on garbage collected.
        """
        return self.get_srcDevice(0)
    @srcDevice.setter
    def srcDevice(self, object value):
        self.set_srcDevice(0,value)

    def get_srcPitch(self, i):
        """Get value ``srcPitch`` of ``self._ptr[i]``.
        """
        return self._ptr[i].srcPitch
    def set_srcPitch(self, i, unsigned int value):
        """Set value ``srcPitch`` of ``self._ptr[i]``.
        """
        self._ptr[i].srcPitch = value
    @property
    def srcPitch(self):
        return self.get_srcPitch(0)
    @srcPitch.setter
    def srcPitch(self, unsigned int value):
        self.set_srcPitch(0,value)

    def get_srcHeight(self, i):
        """Get value ``srcHeight`` of ``self._ptr[i]``.
        """
        return self._ptr[i].srcHeight
    def set_srcHeight(self, i, unsigned int value):
        """Set value ``srcHeight`` of ``self._ptr[i]``.
        """
        self._ptr[i].srcHeight = value
    @property
    def srcHeight(self):
        return self.get_srcHeight(0)
    @srcHeight.setter
    def srcHeight(self, unsigned int value):
        self.set_srcHeight(0,value)

    def get_dstXInBytes(self, i):
        """Get value ``dstXInBytes`` of ``self._ptr[i]``.
        """
        return self._ptr[i].dstXInBytes
    def set_dstXInBytes(self, i, unsigned int value):
        """Set value ``dstXInBytes`` of ``self._ptr[i]``.
        """
        self._ptr[i].dstXInBytes = value
    @property
    def dstXInBytes(self):
        return self.get_dstXInBytes(0)
    @dstXInBytes.setter
    def dstXInBytes(self, unsigned int value):
        self.set_dstXInBytes(0,value)

    def get_dstY(self, i):
        """Get value ``dstY`` of ``self._ptr[i]``.
        """
        return self._ptr[i].dstY
    def set_dstY(self, i, unsigned int value):
        """Set value ``dstY`` of ``self._ptr[i]``.
        """
        self._ptr[i].dstY = value
    @property
    def dstY(self):
        return self.get_dstY(0)
    @dstY.setter
    def dstY(self, unsigned int value):
        self.set_dstY(0,value)

    def get_dstZ(self, i):
        """Get value ``dstZ`` of ``self._ptr[i]``.
        """
        return self._ptr[i].dstZ
    def set_dstZ(self, i, unsigned int value):
        """Set value ``dstZ`` of ``self._ptr[i]``.
        """
        self._ptr[i].dstZ = value
    @property
    def dstZ(self):
        return self.get_dstZ(0)
    @dstZ.setter
    def dstZ(self, unsigned int value):
        self.set_dstZ(0,value)

    def get_dstLOD(self, i):
        """Get value ``dstLOD`` of ``self._ptr[i]``.
        """
        return self._ptr[i].dstLOD
    def set_dstLOD(self, i, unsigned int value):
        """Set value ``dstLOD`` of ``self._ptr[i]``.
        """
        self._ptr[i].dstLOD = value
    @property
    def dstLOD(self):
        return self.get_dstLOD(0)
    @dstLOD.setter
    def dstLOD(self, unsigned int value):
        self.set_dstLOD(0,value)

    def get_dstMemoryType(self, i):
        """Get value of ``dstMemoryType`` of ``self._ptr[i]``.
        """
        return hipMemoryType(self._ptr[i].dstMemoryType)
    def set_dstMemoryType(self, i, value):
        """Set value ``dstMemoryType`` of ``self._ptr[i]``.
        """
        if not isinstance(value, hipMemoryType):
            raise TypeError("'value' must be of type 'hipMemoryType'")
        self._ptr[i].dstMemoryType = value.value
    @property
    def dstMemoryType(self):
        return self.get_dstMemoryType(0)
    @dstMemoryType.setter
    def dstMemoryType(self, value):
        self.set_dstMemoryType(0,value)

    def get_dstHost(self, i):
        """Get value ``dstHost`` of ``self._ptr[i]``.
        """
        return hip._util.types.DataHandle.from_ptr(self._ptr[i].dstHost)
    def set_dstHost(self, i, object value):
        """Set value ``dstHost`` of ``self._ptr[i]``.

        Note:
            This can be dangerous if the pointer is from a python object
            that is later on garbage collected.
        """
        self._ptr[i].dstHost = <void *>cpython.long.PyLong_AsVoidPtr(int(hip._util.types.DataHandle.from_pyobj(value)))
    @property
    def dstHost(self):
        """
        Note:
            Setting this dstHost can be dangerous if the underlying pointer is from a python object that
            is later on garbage collected.
        """
        return self.get_dstHost(0)
    @dstHost.setter
    def dstHost(self, object value):
        self.set_dstHost(0,value)

    def get_dstDevice(self, i):
        """Get value ``dstDevice`` of ``self._ptr[i]``.
        """
        return hip._util.types.DataHandle.from_ptr(self._ptr[i].dstDevice)
    def set_dstDevice(self, i, object value):
        """Set value ``dstDevice`` of ``self._ptr[i]``.

        Note:
            This can be dangerous if the pointer is from a python object
            that is later on garbage collected.
        """
        self._ptr[i].dstDevice = <void *>cpython.long.PyLong_AsVoidPtr(int(hip._util.types.DataHandle.from_pyobj(value)))
    @property
    def dstDevice(self):
        """
        Note:
            Setting this dstDevice can be dangerous if the underlying pointer is from a python object that
            is later on garbage collected.
        """
        return self.get_dstDevice(0)
    @dstDevice.setter
    def dstDevice(self, object value):
        self.set_dstDevice(0,value)

    def get_dstPitch(self, i):
        """Get value ``dstPitch`` of ``self._ptr[i]``.
        """
        return self._ptr[i].dstPitch
    def set_dstPitch(self, i, unsigned int value):
        """Set value ``dstPitch`` of ``self._ptr[i]``.
        """
        self._ptr[i].dstPitch = value
    @property
    def dstPitch(self):
        return self.get_dstPitch(0)
    @dstPitch.setter
    def dstPitch(self, unsigned int value):
        self.set_dstPitch(0,value)

    def get_dstHeight(self, i):
        """Get value ``dstHeight`` of ``self._ptr[i]``.
        """
        return self._ptr[i].dstHeight
    def set_dstHeight(self, i, unsigned int value):
        """Set value ``dstHeight`` of ``self._ptr[i]``.
        """
        self._ptr[i].dstHeight = value
    @property
    def dstHeight(self):
        return self.get_dstHeight(0)
    @dstHeight.setter
    def dstHeight(self, unsigned int value):
        self.set_dstHeight(0,value)

    def get_WidthInBytes(self, i):
        """Get value ``WidthInBytes`` of ``self._ptr[i]``.
        """
        return self._ptr[i].WidthInBytes
    def set_WidthInBytes(self, i, unsigned int value):
        """Set value ``WidthInBytes`` of ``self._ptr[i]``.
        """
        self._ptr[i].WidthInBytes = value
    @property
    def WidthInBytes(self):
        return self.get_WidthInBytes(0)
    @WidthInBytes.setter
    def WidthInBytes(self, unsigned int value):
        self.set_WidthInBytes(0,value)

    def get_Height(self, i):
        """Get value ``Height`` of ``self._ptr[i]``.
        """
        return self._ptr[i].Height
    def set_Height(self, i, unsigned int value):
        """Set value ``Height`` of ``self._ptr[i]``.
        """
        self._ptr[i].Height = value
    @property
    def Height(self):
        return self.get_Height(0)
    @Height.setter
    def Height(self, unsigned int value):
        self.set_Height(0,value)

    def get_Depth(self, i):
        """Get value ``Depth`` of ``self._ptr[i]``.
        """
        return self._ptr[i].Depth
    def set_Depth(self, i, unsigned int value):
        """Set value ``Depth`` of ``self._ptr[i]``.
        """
        self._ptr[i].Depth = value
    @property
    def Depth(self):
        return self.get_Depth(0)
    @Depth.setter
    def Depth(self, unsigned int value):
        self.set_Depth(0,value)

    @staticmethod
    def PROPERTIES():
        return ["srcXInBytes","srcY","srcZ","srcLOD","srcMemoryType","srcHost","srcDevice","srcPitch","srcHeight","dstXInBytes","dstY","dstZ","dstLOD","dstMemoryType","dstHost","dstDevice","dstPitch","dstHeight","WidthInBytes","Height","Depth"]

    def __contains__(self,item):
        properties = self.PROPERTIES()
        return item in properties

    def __getitem__(self,item):
        properties = self.PROPERTIES()
        if isinstance(item,int):
            if item < 0 or item >= len(properties):
                raise IndexError()
            return getattr(self,properties[item])
        raise ValueError("'item' type must be 'int'")


class _hipFunction_attribute__Base(enum.IntEnum):
    """Empty enum base class that allows subclassing.
    """
    pass
class hipFunction_attribute(_hipFunction_attribute__Base):
    HIP_FUNC_ATTRIBUTE_MAX_THREADS_PER_BLOCK = chip.HIP_FUNC_ATTRIBUTE_MAX_THREADS_PER_BLOCK
    HIP_FUNC_ATTRIBUTE_SHARED_SIZE_BYTES = chip.HIP_FUNC_ATTRIBUTE_SHARED_SIZE_BYTES
    HIP_FUNC_ATTRIBUTE_CONST_SIZE_BYTES = chip.HIP_FUNC_ATTRIBUTE_CONST_SIZE_BYTES
    HIP_FUNC_ATTRIBUTE_LOCAL_SIZE_BYTES = chip.HIP_FUNC_ATTRIBUTE_LOCAL_SIZE_BYTES
    HIP_FUNC_ATTRIBUTE_NUM_REGS = chip.HIP_FUNC_ATTRIBUTE_NUM_REGS
    HIP_FUNC_ATTRIBUTE_PTX_VERSION = chip.HIP_FUNC_ATTRIBUTE_PTX_VERSION
    HIP_FUNC_ATTRIBUTE_BINARY_VERSION = chip.HIP_FUNC_ATTRIBUTE_BINARY_VERSION
    HIP_FUNC_ATTRIBUTE_CACHE_MODE_CA = chip.HIP_FUNC_ATTRIBUTE_CACHE_MODE_CA
    HIP_FUNC_ATTRIBUTE_MAX_DYNAMIC_SHARED_SIZE_BYTES = chip.HIP_FUNC_ATTRIBUTE_MAX_DYNAMIC_SHARED_SIZE_BYTES
    HIP_FUNC_ATTRIBUTE_PREFERRED_SHARED_MEMORY_CARVEOUT = chip.HIP_FUNC_ATTRIBUTE_PREFERRED_SHARED_MEMORY_CARVEOUT
    HIP_FUNC_ATTRIBUTE_MAX = chip.HIP_FUNC_ATTRIBUTE_MAX
    @staticmethod
    def ctypes_type():
        """The type of the enum constants as ctypes type."""
        return ctypes.c_uint 


class _hipPointer_attribute__Base(enum.IntEnum):
    """Empty enum base class that allows subclassing.
    """
    pass
class hipPointer_attribute(_hipPointer_attribute__Base):
    HIP_POINTER_ATTRIBUTE_CONTEXT = chip.HIP_POINTER_ATTRIBUTE_CONTEXT
    HIP_POINTER_ATTRIBUTE_MEMORY_TYPE = chip.HIP_POINTER_ATTRIBUTE_MEMORY_TYPE
    HIP_POINTER_ATTRIBUTE_DEVICE_POINTER = chip.HIP_POINTER_ATTRIBUTE_DEVICE_POINTER
    HIP_POINTER_ATTRIBUTE_HOST_POINTER = chip.HIP_POINTER_ATTRIBUTE_HOST_POINTER
    HIP_POINTER_ATTRIBUTE_P2P_TOKENS = chip.HIP_POINTER_ATTRIBUTE_P2P_TOKENS
    HIP_POINTER_ATTRIBUTE_SYNC_MEMOPS = chip.HIP_POINTER_ATTRIBUTE_SYNC_MEMOPS
    HIP_POINTER_ATTRIBUTE_BUFFER_ID = chip.HIP_POINTER_ATTRIBUTE_BUFFER_ID
    HIP_POINTER_ATTRIBUTE_IS_MANAGED = chip.HIP_POINTER_ATTRIBUTE_IS_MANAGED
    HIP_POINTER_ATTRIBUTE_DEVICE_ORDINAL = chip.HIP_POINTER_ATTRIBUTE_DEVICE_ORDINAL
    HIP_POINTER_ATTRIBUTE_IS_LEGACY_HIP_IPC_CAPABLE = chip.HIP_POINTER_ATTRIBUTE_IS_LEGACY_HIP_IPC_CAPABLE
    HIP_POINTER_ATTRIBUTE_RANGE_START_ADDR = chip.HIP_POINTER_ATTRIBUTE_RANGE_START_ADDR
    HIP_POINTER_ATTRIBUTE_RANGE_SIZE = chip.HIP_POINTER_ATTRIBUTE_RANGE_SIZE
    HIP_POINTER_ATTRIBUTE_MAPPED = chip.HIP_POINTER_ATTRIBUTE_MAPPED
    HIP_POINTER_ATTRIBUTE_ALLOWED_HANDLE_TYPES = chip.HIP_POINTER_ATTRIBUTE_ALLOWED_HANDLE_TYPES
    HIP_POINTER_ATTRIBUTE_IS_GPU_DIRECT_RDMA_CAPABLE = chip.HIP_POINTER_ATTRIBUTE_IS_GPU_DIRECT_RDMA_CAPABLE
    HIP_POINTER_ATTRIBUTE_ACCESS_FLAGS = chip.HIP_POINTER_ATTRIBUTE_ACCESS_FLAGS
    HIP_POINTER_ATTRIBUTE_MEMPOOL_HANDLE = chip.HIP_POINTER_ATTRIBUTE_MEMPOOL_HANDLE
    @staticmethod
    def ctypes_type():
        """The type of the enum constants as ctypes type."""
        return ctypes.c_uint 


cdef class uchar1:
    # members declared in pxd file

    def __cinit__(self):
        self._ptr = NULL
        self.ptr_owner = False
        self._py_buffer_acquired = False

    @staticmethod
    cdef uchar1 from_ptr(chip.uchar1* ptr, bint owner=False):
        """Factory function to create ``uchar1`` objects from
        given ``chip.uchar1`` pointer.

        Setting ``owner`` flag to ``True`` causes
        the extension type to ``free`` the structure pointed to by ``ptr``
        when the wrapper object is deallocated.
        """
        # Fast call to __new__() that bypasses the __init__() constructor.
        cdef uchar1 wrapper = uchar1.__new__(uchar1)
        wrapper._ptr = ptr
        wrapper.ptr_owner = owner
        return wrapper

    @staticmethod
    cdef uchar1 from_pyobj(object pyobj):
        """Derives a uchar1 from a Python object.

        Derives a uchar1 from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``uchar1`` reference, this method
        returns it directly. No new ``uchar1`` is created in this case.

        Args:
            pyobj (object): Must be either ``None``, a simple, contiguous buffer according to the buffer protocol,
                            or of type ``uchar1``, ``int``, or ``ctypes.c_void_p``

        Note:
            This routine does not perform a copy but returns the original ``pyobj``
            if ``pyobj`` is an instance of uchar1!
        """
        cdef uchar1 wrapper = uchar1.__new__(uchar1)
        cdef dict cuda_array_interface = getattr(pyobj, "__cuda_array_interface__", None)

        if pyobj is None:
            wrapper._ptr = NULL
        elif isinstance(pyobj,uchar1):
            return pyobj
        elif isinstance(pyobj,int):
            wrapper._ptr = <chip.uchar1*>cpython.long.PyLong_AsVoidPtr(pyobj)
        elif isinstance(pyobj,ctypes.c_void_p):
            wrapper._ptr = <chip.uchar1*>cpython.long.PyLong_AsVoidPtr(pyobj.value) if pyobj.value != None else NULL
        elif cuda_array_interface != None:
            if not "data" in cuda_array_interface:
                raise ValueError("input object has '__cuda_array_interface__' attribute but the dict has no 'data' key")
            ptr_as_int = cuda_array_interface["data"][0]
            wrapper._ptr = <chip.uchar1*>cpython.long.PyLong_AsVoidPtr(ptr_as_int)
        elif cpython.buffer.PyObject_CheckBuffer(pyobj):
            err = cpython.buffer.PyObject_GetBuffer( 
                pyobj,
                &wrapper._py_buffer, 
                cpython.buffer.PyBUF_SIMPLE | cpython.buffer.PyBUF_ANY_CONTIGUOUS
            )
            if err == -1:
                raise RuntimeError("failed to create simple, contiguous Py_buffer from Python object")
            wrapper._py_buffer_acquired = True
            wrapper._ptr = <chip.uchar1*>wrapper._py_buffer.buf
        else:
            raise TypeError(f"unsupported input type: '{str(type(pyobj))}'")
        return wrapper
    def __dealloc__(self):
        # Release the buffer handle
        if self._py_buffer_acquired is True:
            cpython.buffer.PyBuffer_Release(&self._py_buffer)
        # De-allocate if not null and flag is set
        if self._ptr is not NULL and self.ptr_owner is True:
            stdlib.free(self._ptr)
            self._ptr = NULL
    @staticmethod
    cdef __allocate(chip.uchar1** ptr):
        ptr[0] = <chip.uchar1*>stdlib.malloc(sizeof(chip.uchar1))

        if ptr[0] is NULL:
            raise MemoryError
        # TODO init values, if present

    @staticmethod
    cdef uchar1 new():
        """Factory function to create uchar1 objects with
        newly allocated chip.uchar1"""
        cdef chip.uchar1* ptr
        uchar1.__allocate(&ptr)
        return uchar1.from_ptr(ptr, owner=True)
   
    def __init__(self,*args,**kwargs):
        uchar1.__allocate(&self._ptr)
        self.ptr_owner = True
        attribs = self.PROPERTIES()
        used_attribs = set()
        if len(args) > len(attribs):
            raise ValueError("More positional arguments specified than this type has properties.")
        for i,v in enumerate(args):
            setattr(self,attribs[i],v)
            used_attribs.add(attribs[i])
        valid_names = ", ".join(["'"+p+"'" for p in attribs])
        for k,v in kwargs.items():
            if k in used_attribs:
                raise KeyError(f"argument '{k}' has already been specified as positional argument.")
            elif k not in attribs:
                raise KeyError(f"'{k}' is no valid property name. Valid names: {valid_names}")
            setattr(self,k,v)
    
    def __int__(self):
        """Returns the data's address as long integer."""
        return cpython.long.PyLong_FromVoidPtr(self._ptr)
    def __repr__(self):
        return f"<uchar1 object, self.ptr={int(self)}>"
    def as_c_void_p(self):
        """Returns the data's address as `ctypes.c_void_p`"""
        return ctypes.c_void_p(int(self))
    def get_x(self, i):
        """Get value ``x`` of ``self._ptr[i]``.
        """
        return self._ptr[i].x
    def set_x(self, i, unsigned char value):
        """Set value ``x`` of ``self._ptr[i]``.
        """
        self._ptr[i].x = value
    @property
    def x(self):
        return self.get_x(0)
    @x.setter
    def x(self, unsigned char value):
        self.set_x(0,value)

    @staticmethod
    def PROPERTIES():
        return ["x"]

    def __contains__(self,item):
        properties = self.PROPERTIES()
        return item in properties

    def __getitem__(self,item):
        properties = self.PROPERTIES()
        if isinstance(item,int):
            if item < 0 or item >= len(properties):
                raise IndexError()
            return getattr(self,properties[item])
        raise ValueError("'item' type must be 'int'")


cdef class uchar2:
    # members declared in pxd file

    def __cinit__(self):
        self._ptr = NULL
        self.ptr_owner = False
        self._py_buffer_acquired = False

    @staticmethod
    cdef uchar2 from_ptr(chip.uchar2* ptr, bint owner=False):
        """Factory function to create ``uchar2`` objects from
        given ``chip.uchar2`` pointer.

        Setting ``owner`` flag to ``True`` causes
        the extension type to ``free`` the structure pointed to by ``ptr``
        when the wrapper object is deallocated.
        """
        # Fast call to __new__() that bypasses the __init__() constructor.
        cdef uchar2 wrapper = uchar2.__new__(uchar2)
        wrapper._ptr = ptr
        wrapper.ptr_owner = owner
        return wrapper

    @staticmethod
    cdef uchar2 from_pyobj(object pyobj):
        """Derives a uchar2 from a Python object.

        Derives a uchar2 from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``uchar2`` reference, this method
        returns it directly. No new ``uchar2`` is created in this case.

        Args:
            pyobj (object): Must be either ``None``, a simple, contiguous buffer according to the buffer protocol,
                            or of type ``uchar2``, ``int``, or ``ctypes.c_void_p``

        Note:
            This routine does not perform a copy but returns the original ``pyobj``
            if ``pyobj`` is an instance of uchar2!
        """
        cdef uchar2 wrapper = uchar2.__new__(uchar2)
        cdef dict cuda_array_interface = getattr(pyobj, "__cuda_array_interface__", None)

        if pyobj is None:
            wrapper._ptr = NULL
        elif isinstance(pyobj,uchar2):
            return pyobj
        elif isinstance(pyobj,int):
            wrapper._ptr = <chip.uchar2*>cpython.long.PyLong_AsVoidPtr(pyobj)
        elif isinstance(pyobj,ctypes.c_void_p):
            wrapper._ptr = <chip.uchar2*>cpython.long.PyLong_AsVoidPtr(pyobj.value) if pyobj.value != None else NULL
        elif cuda_array_interface != None:
            if not "data" in cuda_array_interface:
                raise ValueError("input object has '__cuda_array_interface__' attribute but the dict has no 'data' key")
            ptr_as_int = cuda_array_interface["data"][0]
            wrapper._ptr = <chip.uchar2*>cpython.long.PyLong_AsVoidPtr(ptr_as_int)
        elif cpython.buffer.PyObject_CheckBuffer(pyobj):
            err = cpython.buffer.PyObject_GetBuffer( 
                pyobj,
                &wrapper._py_buffer, 
                cpython.buffer.PyBUF_SIMPLE | cpython.buffer.PyBUF_ANY_CONTIGUOUS
            )
            if err == -1:
                raise RuntimeError("failed to create simple, contiguous Py_buffer from Python object")
            wrapper._py_buffer_acquired = True
            wrapper._ptr = <chip.uchar2*>wrapper._py_buffer.buf
        else:
            raise TypeError(f"unsupported input type: '{str(type(pyobj))}'")
        return wrapper
    def __dealloc__(self):
        # Release the buffer handle
        if self._py_buffer_acquired is True:
            cpython.buffer.PyBuffer_Release(&self._py_buffer)
        # De-allocate if not null and flag is set
        if self._ptr is not NULL and self.ptr_owner is True:
            stdlib.free(self._ptr)
            self._ptr = NULL
    @staticmethod
    cdef __allocate(chip.uchar2** ptr):
        ptr[0] = <chip.uchar2*>stdlib.malloc(sizeof(chip.uchar2))

        if ptr[0] is NULL:
            raise MemoryError
        # TODO init values, if present

    @staticmethod
    cdef uchar2 new():
        """Factory function to create uchar2 objects with
        newly allocated chip.uchar2"""
        cdef chip.uchar2* ptr
        uchar2.__allocate(&ptr)
        return uchar2.from_ptr(ptr, owner=True)
   
    def __init__(self,*args,**kwargs):
        uchar2.__allocate(&self._ptr)
        self.ptr_owner = True
        attribs = self.PROPERTIES()
        used_attribs = set()
        if len(args) > len(attribs):
            raise ValueError("More positional arguments specified than this type has properties.")
        for i,v in enumerate(args):
            setattr(self,attribs[i],v)
            used_attribs.add(attribs[i])
        valid_names = ", ".join(["'"+p+"'" for p in attribs])
        for k,v in kwargs.items():
            if k in used_attribs:
                raise KeyError(f"argument '{k}' has already been specified as positional argument.")
            elif k not in attribs:
                raise KeyError(f"'{k}' is no valid property name. Valid names: {valid_names}")
            setattr(self,k,v)
    
    def __int__(self):
        """Returns the data's address as long integer."""
        return cpython.long.PyLong_FromVoidPtr(self._ptr)
    def __repr__(self):
        return f"<uchar2 object, self.ptr={int(self)}>"
    def as_c_void_p(self):
        """Returns the data's address as `ctypes.c_void_p`"""
        return ctypes.c_void_p(int(self))
    def get_x(self, i):
        """Get value ``x`` of ``self._ptr[i]``.
        """
        return self._ptr[i].x
    def set_x(self, i, unsigned char value):
        """Set value ``x`` of ``self._ptr[i]``.
        """
        self._ptr[i].x = value
    @property
    def x(self):
        return self.get_x(0)
    @x.setter
    def x(self, unsigned char value):
        self.set_x(0,value)

    def get_y(self, i):
        """Get value ``y`` of ``self._ptr[i]``.
        """
        return self._ptr[i].y
    def set_y(self, i, unsigned char value):
        """Set value ``y`` of ``self._ptr[i]``.
        """
        self._ptr[i].y = value
    @property
    def y(self):
        return self.get_y(0)
    @y.setter
    def y(self, unsigned char value):
        self.set_y(0,value)

    @staticmethod
    def PROPERTIES():
        return ["x","y"]

    def __contains__(self,item):
        properties = self.PROPERTIES()
        return item in properties

    def __getitem__(self,item):
        properties = self.PROPERTIES()
        if isinstance(item,int):
            if item < 0 or item >= len(properties):
                raise IndexError()
            return getattr(self,properties[item])
        raise ValueError("'item' type must be 'int'")


cdef class uchar3:
    # members declared in pxd file

    def __cinit__(self):
        self._ptr = NULL
        self.ptr_owner = False
        self._py_buffer_acquired = False

    @staticmethod
    cdef uchar3 from_ptr(chip.uchar3* ptr, bint owner=False):
        """Factory function to create ``uchar3`` objects from
        given ``chip.uchar3`` pointer.

        Setting ``owner`` flag to ``True`` causes
        the extension type to ``free`` the structure pointed to by ``ptr``
        when the wrapper object is deallocated.
        """
        # Fast call to __new__() that bypasses the __init__() constructor.
        cdef uchar3 wrapper = uchar3.__new__(uchar3)
        wrapper._ptr = ptr
        wrapper.ptr_owner = owner
        return wrapper

    @staticmethod
    cdef uchar3 from_pyobj(object pyobj):
        """Derives a uchar3 from a Python object.

        Derives a uchar3 from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``uchar3`` reference, this method
        returns it directly. No new ``uchar3`` is created in this case.

        Args:
            pyobj (object): Must be either ``None``, a simple, contiguous buffer according to the buffer protocol,
                            or of type ``uchar3``, ``int``, or ``ctypes.c_void_p``

        Note:
            This routine does not perform a copy but returns the original ``pyobj``
            if ``pyobj`` is an instance of uchar3!
        """
        cdef uchar3 wrapper = uchar3.__new__(uchar3)
        cdef dict cuda_array_interface = getattr(pyobj, "__cuda_array_interface__", None)

        if pyobj is None:
            wrapper._ptr = NULL
        elif isinstance(pyobj,uchar3):
            return pyobj
        elif isinstance(pyobj,int):
            wrapper._ptr = <chip.uchar3*>cpython.long.PyLong_AsVoidPtr(pyobj)
        elif isinstance(pyobj,ctypes.c_void_p):
            wrapper._ptr = <chip.uchar3*>cpython.long.PyLong_AsVoidPtr(pyobj.value) if pyobj.value != None else NULL
        elif cuda_array_interface != None:
            if not "data" in cuda_array_interface:
                raise ValueError("input object has '__cuda_array_interface__' attribute but the dict has no 'data' key")
            ptr_as_int = cuda_array_interface["data"][0]
            wrapper._ptr = <chip.uchar3*>cpython.long.PyLong_AsVoidPtr(ptr_as_int)
        elif cpython.buffer.PyObject_CheckBuffer(pyobj):
            err = cpython.buffer.PyObject_GetBuffer( 
                pyobj,
                &wrapper._py_buffer, 
                cpython.buffer.PyBUF_SIMPLE | cpython.buffer.PyBUF_ANY_CONTIGUOUS
            )
            if err == -1:
                raise RuntimeError("failed to create simple, contiguous Py_buffer from Python object")
            wrapper._py_buffer_acquired = True
            wrapper._ptr = <chip.uchar3*>wrapper._py_buffer.buf
        else:
            raise TypeError(f"unsupported input type: '{str(type(pyobj))}'")
        return wrapper
    def __dealloc__(self):
        # Release the buffer handle
        if self._py_buffer_acquired is True:
            cpython.buffer.PyBuffer_Release(&self._py_buffer)
        # De-allocate if not null and flag is set
        if self._ptr is not NULL and self.ptr_owner is True:
            stdlib.free(self._ptr)
            self._ptr = NULL
    @staticmethod
    cdef __allocate(chip.uchar3** ptr):
        ptr[0] = <chip.uchar3*>stdlib.malloc(sizeof(chip.uchar3))

        if ptr[0] is NULL:
            raise MemoryError
        # TODO init values, if present

    @staticmethod
    cdef uchar3 new():
        """Factory function to create uchar3 objects with
        newly allocated chip.uchar3"""
        cdef chip.uchar3* ptr
        uchar3.__allocate(&ptr)
        return uchar3.from_ptr(ptr, owner=True)
   
    def __init__(self,*args,**kwargs):
        uchar3.__allocate(&self._ptr)
        self.ptr_owner = True
        attribs = self.PROPERTIES()
        used_attribs = set()
        if len(args) > len(attribs):
            raise ValueError("More positional arguments specified than this type has properties.")
        for i,v in enumerate(args):
            setattr(self,attribs[i],v)
            used_attribs.add(attribs[i])
        valid_names = ", ".join(["'"+p+"'" for p in attribs])
        for k,v in kwargs.items():
            if k in used_attribs:
                raise KeyError(f"argument '{k}' has already been specified as positional argument.")
            elif k not in attribs:
                raise KeyError(f"'{k}' is no valid property name. Valid names: {valid_names}")
            setattr(self,k,v)
    
    def __int__(self):
        """Returns the data's address as long integer."""
        return cpython.long.PyLong_FromVoidPtr(self._ptr)
    def __repr__(self):
        return f"<uchar3 object, self.ptr={int(self)}>"
    def as_c_void_p(self):
        """Returns the data's address as `ctypes.c_void_p`"""
        return ctypes.c_void_p(int(self))
    def get_x(self, i):
        """Get value ``x`` of ``self._ptr[i]``.
        """
        return self._ptr[i].x
    def set_x(self, i, unsigned char value):
        """Set value ``x`` of ``self._ptr[i]``.
        """
        self._ptr[i].x = value
    @property
    def x(self):
        return self.get_x(0)
    @x.setter
    def x(self, unsigned char value):
        self.set_x(0,value)

    def get_y(self, i):
        """Get value ``y`` of ``self._ptr[i]``.
        """
        return self._ptr[i].y
    def set_y(self, i, unsigned char value):
        """Set value ``y`` of ``self._ptr[i]``.
        """
        self._ptr[i].y = value
    @property
    def y(self):
        return self.get_y(0)
    @y.setter
    def y(self, unsigned char value):
        self.set_y(0,value)

    def get_z(self, i):
        """Get value ``z`` of ``self._ptr[i]``.
        """
        return self._ptr[i].z
    def set_z(self, i, unsigned char value):
        """Set value ``z`` of ``self._ptr[i]``.
        """
        self._ptr[i].z = value
    @property
    def z(self):
        return self.get_z(0)
    @z.setter
    def z(self, unsigned char value):
        self.set_z(0,value)

    @staticmethod
    def PROPERTIES():
        return ["x","y","z"]

    def __contains__(self,item):
        properties = self.PROPERTIES()
        return item in properties

    def __getitem__(self,item):
        properties = self.PROPERTIES()
        if isinstance(item,int):
            if item < 0 or item >= len(properties):
                raise IndexError()
            return getattr(self,properties[item])
        raise ValueError("'item' type must be 'int'")


cdef class uchar4:
    # members declared in pxd file

    def __cinit__(self):
        self._ptr = NULL
        self.ptr_owner = False
        self._py_buffer_acquired = False

    @staticmethod
    cdef uchar4 from_ptr(chip.uchar4* ptr, bint owner=False):
        """Factory function to create ``uchar4`` objects from
        given ``chip.uchar4`` pointer.

        Setting ``owner`` flag to ``True`` causes
        the extension type to ``free`` the structure pointed to by ``ptr``
        when the wrapper object is deallocated.
        """
        # Fast call to __new__() that bypasses the __init__() constructor.
        cdef uchar4 wrapper = uchar4.__new__(uchar4)
        wrapper._ptr = ptr
        wrapper.ptr_owner = owner
        return wrapper

    @staticmethod
    cdef uchar4 from_pyobj(object pyobj):
        """Derives a uchar4 from a Python object.

        Derives a uchar4 from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``uchar4`` reference, this method
        returns it directly. No new ``uchar4`` is created in this case.

        Args:
            pyobj (object): Must be either ``None``, a simple, contiguous buffer according to the buffer protocol,
                            or of type ``uchar4``, ``int``, or ``ctypes.c_void_p``

        Note:
            This routine does not perform a copy but returns the original ``pyobj``
            if ``pyobj`` is an instance of uchar4!
        """
        cdef uchar4 wrapper = uchar4.__new__(uchar4)
        cdef dict cuda_array_interface = getattr(pyobj, "__cuda_array_interface__", None)

        if pyobj is None:
            wrapper._ptr = NULL
        elif isinstance(pyobj,uchar4):
            return pyobj
        elif isinstance(pyobj,int):
            wrapper._ptr = <chip.uchar4*>cpython.long.PyLong_AsVoidPtr(pyobj)
        elif isinstance(pyobj,ctypes.c_void_p):
            wrapper._ptr = <chip.uchar4*>cpython.long.PyLong_AsVoidPtr(pyobj.value) if pyobj.value != None else NULL
        elif cuda_array_interface != None:
            if not "data" in cuda_array_interface:
                raise ValueError("input object has '__cuda_array_interface__' attribute but the dict has no 'data' key")
            ptr_as_int = cuda_array_interface["data"][0]
            wrapper._ptr = <chip.uchar4*>cpython.long.PyLong_AsVoidPtr(ptr_as_int)
        elif cpython.buffer.PyObject_CheckBuffer(pyobj):
            err = cpython.buffer.PyObject_GetBuffer( 
                pyobj,
                &wrapper._py_buffer, 
                cpython.buffer.PyBUF_SIMPLE | cpython.buffer.PyBUF_ANY_CONTIGUOUS
            )
            if err == -1:
                raise RuntimeError("failed to create simple, contiguous Py_buffer from Python object")
            wrapper._py_buffer_acquired = True
            wrapper._ptr = <chip.uchar4*>wrapper._py_buffer.buf
        else:
            raise TypeError(f"unsupported input type: '{str(type(pyobj))}'")
        return wrapper
    def __dealloc__(self):
        # Release the buffer handle
        if self._py_buffer_acquired is True:
            cpython.buffer.PyBuffer_Release(&self._py_buffer)
        # De-allocate if not null and flag is set
        if self._ptr is not NULL and self.ptr_owner is True:
            stdlib.free(self._ptr)
            self._ptr = NULL
    @staticmethod
    cdef __allocate(chip.uchar4** ptr):
        ptr[0] = <chip.uchar4*>stdlib.malloc(sizeof(chip.uchar4))

        if ptr[0] is NULL:
            raise MemoryError
        # TODO init values, if present

    @staticmethod
    cdef uchar4 new():
        """Factory function to create uchar4 objects with
        newly allocated chip.uchar4"""
        cdef chip.uchar4* ptr
        uchar4.__allocate(&ptr)
        return uchar4.from_ptr(ptr, owner=True)
   
    def __init__(self,*args,**kwargs):
        uchar4.__allocate(&self._ptr)
        self.ptr_owner = True
        attribs = self.PROPERTIES()
        used_attribs = set()
        if len(args) > len(attribs):
            raise ValueError("More positional arguments specified than this type has properties.")
        for i,v in enumerate(args):
            setattr(self,attribs[i],v)
            used_attribs.add(attribs[i])
        valid_names = ", ".join(["'"+p+"'" for p in attribs])
        for k,v in kwargs.items():
            if k in used_attribs:
                raise KeyError(f"argument '{k}' has already been specified as positional argument.")
            elif k not in attribs:
                raise KeyError(f"'{k}' is no valid property name. Valid names: {valid_names}")
            setattr(self,k,v)
    
    def __int__(self):
        """Returns the data's address as long integer."""
        return cpython.long.PyLong_FromVoidPtr(self._ptr)
    def __repr__(self):
        return f"<uchar4 object, self.ptr={int(self)}>"
    def as_c_void_p(self):
        """Returns the data's address as `ctypes.c_void_p`"""
        return ctypes.c_void_p(int(self))
    def get_x(self, i):
        """Get value ``x`` of ``self._ptr[i]``.
        """
        return self._ptr[i].x
    def set_x(self, i, unsigned char value):
        """Set value ``x`` of ``self._ptr[i]``.
        """
        self._ptr[i].x = value
    @property
    def x(self):
        return self.get_x(0)
    @x.setter
    def x(self, unsigned char value):
        self.set_x(0,value)

    def get_y(self, i):
        """Get value ``y`` of ``self._ptr[i]``.
        """
        return self._ptr[i].y
    def set_y(self, i, unsigned char value):
        """Set value ``y`` of ``self._ptr[i]``.
        """
        self._ptr[i].y = value
    @property
    def y(self):
        return self.get_y(0)
    @y.setter
    def y(self, unsigned char value):
        self.set_y(0,value)

    def get_z(self, i):
        """Get value ``z`` of ``self._ptr[i]``.
        """
        return self._ptr[i].z
    def set_z(self, i, unsigned char value):
        """Set value ``z`` of ``self._ptr[i]``.
        """
        self._ptr[i].z = value
    @property
    def z(self):
        return self.get_z(0)
    @z.setter
    def z(self, unsigned char value):
        self.set_z(0,value)

    def get_w(self, i):
        """Get value ``w`` of ``self._ptr[i]``.
        """
        return self._ptr[i].w
    def set_w(self, i, unsigned char value):
        """Set value ``w`` of ``self._ptr[i]``.
        """
        self._ptr[i].w = value
    @property
    def w(self):
        return self.get_w(0)
    @w.setter
    def w(self, unsigned char value):
        self.set_w(0,value)

    @staticmethod
    def PROPERTIES():
        return ["x","y","z","w"]

    def __contains__(self,item):
        properties = self.PROPERTIES()
        return item in properties

    def __getitem__(self,item):
        properties = self.PROPERTIES()
        if isinstance(item,int):
            if item < 0 or item >= len(properties):
                raise IndexError()
            return getattr(self,properties[item])
        raise ValueError("'item' type must be 'int'")


cdef class char1:
    # members declared in pxd file

    def __cinit__(self):
        self._ptr = NULL
        self.ptr_owner = False
        self._py_buffer_acquired = False

    @staticmethod
    cdef char1 from_ptr(chip.char1* ptr, bint owner=False):
        """Factory function to create ``char1`` objects from
        given ``chip.char1`` pointer.

        Setting ``owner`` flag to ``True`` causes
        the extension type to ``free`` the structure pointed to by ``ptr``
        when the wrapper object is deallocated.
        """
        # Fast call to __new__() that bypasses the __init__() constructor.
        cdef char1 wrapper = char1.__new__(char1)
        wrapper._ptr = ptr
        wrapper.ptr_owner = owner
        return wrapper

    @staticmethod
    cdef char1 from_pyobj(object pyobj):
        """Derives a char1 from a Python object.

        Derives a char1 from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``char1`` reference, this method
        returns it directly. No new ``char1`` is created in this case.

        Args:
            pyobj (object): Must be either ``None``, a simple, contiguous buffer according to the buffer protocol,
                            or of type ``char1``, ``int``, or ``ctypes.c_void_p``

        Note:
            This routine does not perform a copy but returns the original ``pyobj``
            if ``pyobj`` is an instance of char1!
        """
        cdef char1 wrapper = char1.__new__(char1)
        cdef dict cuda_array_interface = getattr(pyobj, "__cuda_array_interface__", None)

        if pyobj is None:
            wrapper._ptr = NULL
        elif isinstance(pyobj,char1):
            return pyobj
        elif isinstance(pyobj,int):
            wrapper._ptr = <chip.char1*>cpython.long.PyLong_AsVoidPtr(pyobj)
        elif isinstance(pyobj,ctypes.c_void_p):
            wrapper._ptr = <chip.char1*>cpython.long.PyLong_AsVoidPtr(pyobj.value) if pyobj.value != None else NULL
        elif cuda_array_interface != None:
            if not "data" in cuda_array_interface:
                raise ValueError("input object has '__cuda_array_interface__' attribute but the dict has no 'data' key")
            ptr_as_int = cuda_array_interface["data"][0]
            wrapper._ptr = <chip.char1*>cpython.long.PyLong_AsVoidPtr(ptr_as_int)
        elif cpython.buffer.PyObject_CheckBuffer(pyobj):
            err = cpython.buffer.PyObject_GetBuffer( 
                pyobj,
                &wrapper._py_buffer, 
                cpython.buffer.PyBUF_SIMPLE | cpython.buffer.PyBUF_ANY_CONTIGUOUS
            )
            if err == -1:
                raise RuntimeError("failed to create simple, contiguous Py_buffer from Python object")
            wrapper._py_buffer_acquired = True
            wrapper._ptr = <chip.char1*>wrapper._py_buffer.buf
        else:
            raise TypeError(f"unsupported input type: '{str(type(pyobj))}'")
        return wrapper
    def __dealloc__(self):
        # Release the buffer handle
        if self._py_buffer_acquired is True:
            cpython.buffer.PyBuffer_Release(&self._py_buffer)
        # De-allocate if not null and flag is set
        if self._ptr is not NULL and self.ptr_owner is True:
            stdlib.free(self._ptr)
            self._ptr = NULL
    @staticmethod
    cdef __allocate(chip.char1** ptr):
        ptr[0] = <chip.char1*>stdlib.malloc(sizeof(chip.char1))

        if ptr[0] is NULL:
            raise MemoryError
        # TODO init values, if present

    @staticmethod
    cdef char1 new():
        """Factory function to create char1 objects with
        newly allocated chip.char1"""
        cdef chip.char1* ptr
        char1.__allocate(&ptr)
        return char1.from_ptr(ptr, owner=True)
   
    def __init__(self,*args,**kwargs):
        char1.__allocate(&self._ptr)
        self.ptr_owner = True
        attribs = self.PROPERTIES()
        used_attribs = set()
        if len(args) > len(attribs):
            raise ValueError("More positional arguments specified than this type has properties.")
        for i,v in enumerate(args):
            setattr(self,attribs[i],v)
            used_attribs.add(attribs[i])
        valid_names = ", ".join(["'"+p+"'" for p in attribs])
        for k,v in kwargs.items():
            if k in used_attribs:
                raise KeyError(f"argument '{k}' has already been specified as positional argument.")
            elif k not in attribs:
                raise KeyError(f"'{k}' is no valid property name. Valid names: {valid_names}")
            setattr(self,k,v)
    
    def __int__(self):
        """Returns the data's address as long integer."""
        return cpython.long.PyLong_FromVoidPtr(self._ptr)
    def __repr__(self):
        return f"<char1 object, self.ptr={int(self)}>"
    def as_c_void_p(self):
        """Returns the data's address as `ctypes.c_void_p`"""
        return ctypes.c_void_p(int(self))
    def get_x(self, i):
        """Get value ``x`` of ``self._ptr[i]``.
        """
        return self._ptr[i].x
    def set_x(self, i, char value):
        """Set value ``x`` of ``self._ptr[i]``.
        """
        self._ptr[i].x = value
    @property
    def x(self):
        return self.get_x(0)
    @x.setter
    def x(self, char value):
        self.set_x(0,value)

    @staticmethod
    def PROPERTIES():
        return ["x"]

    def __contains__(self,item):
        properties = self.PROPERTIES()
        return item in properties

    def __getitem__(self,item):
        properties = self.PROPERTIES()
        if isinstance(item,int):
            if item < 0 or item >= len(properties):
                raise IndexError()
            return getattr(self,properties[item])
        raise ValueError("'item' type must be 'int'")


cdef class char2:
    # members declared in pxd file

    def __cinit__(self):
        self._ptr = NULL
        self.ptr_owner = False
        self._py_buffer_acquired = False

    @staticmethod
    cdef char2 from_ptr(chip.char2* ptr, bint owner=False):
        """Factory function to create ``char2`` objects from
        given ``chip.char2`` pointer.

        Setting ``owner`` flag to ``True`` causes
        the extension type to ``free`` the structure pointed to by ``ptr``
        when the wrapper object is deallocated.
        """
        # Fast call to __new__() that bypasses the __init__() constructor.
        cdef char2 wrapper = char2.__new__(char2)
        wrapper._ptr = ptr
        wrapper.ptr_owner = owner
        return wrapper

    @staticmethod
    cdef char2 from_pyobj(object pyobj):
        """Derives a char2 from a Python object.

        Derives a char2 from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``char2`` reference, this method
        returns it directly. No new ``char2`` is created in this case.

        Args:
            pyobj (object): Must be either ``None``, a simple, contiguous buffer according to the buffer protocol,
                            or of type ``char2``, ``int``, or ``ctypes.c_void_p``

        Note:
            This routine does not perform a copy but returns the original ``pyobj``
            if ``pyobj`` is an instance of char2!
        """
        cdef char2 wrapper = char2.__new__(char2)
        cdef dict cuda_array_interface = getattr(pyobj, "__cuda_array_interface__", None)

        if pyobj is None:
            wrapper._ptr = NULL
        elif isinstance(pyobj,char2):
            return pyobj
        elif isinstance(pyobj,int):
            wrapper._ptr = <chip.char2*>cpython.long.PyLong_AsVoidPtr(pyobj)
        elif isinstance(pyobj,ctypes.c_void_p):
            wrapper._ptr = <chip.char2*>cpython.long.PyLong_AsVoidPtr(pyobj.value) if pyobj.value != None else NULL
        elif cuda_array_interface != None:
            if not "data" in cuda_array_interface:
                raise ValueError("input object has '__cuda_array_interface__' attribute but the dict has no 'data' key")
            ptr_as_int = cuda_array_interface["data"][0]
            wrapper._ptr = <chip.char2*>cpython.long.PyLong_AsVoidPtr(ptr_as_int)
        elif cpython.buffer.PyObject_CheckBuffer(pyobj):
            err = cpython.buffer.PyObject_GetBuffer( 
                pyobj,
                &wrapper._py_buffer, 
                cpython.buffer.PyBUF_SIMPLE | cpython.buffer.PyBUF_ANY_CONTIGUOUS
            )
            if err == -1:
                raise RuntimeError("failed to create simple, contiguous Py_buffer from Python object")
            wrapper._py_buffer_acquired = True
            wrapper._ptr = <chip.char2*>wrapper._py_buffer.buf
        else:
            raise TypeError(f"unsupported input type: '{str(type(pyobj))}'")
        return wrapper
    def __dealloc__(self):
        # Release the buffer handle
        if self._py_buffer_acquired is True:
            cpython.buffer.PyBuffer_Release(&self._py_buffer)
        # De-allocate if not null and flag is set
        if self._ptr is not NULL and self.ptr_owner is True:
            stdlib.free(self._ptr)
            self._ptr = NULL
    @staticmethod
    cdef __allocate(chip.char2** ptr):
        ptr[0] = <chip.char2*>stdlib.malloc(sizeof(chip.char2))

        if ptr[0] is NULL:
            raise MemoryError
        # TODO init values, if present

    @staticmethod
    cdef char2 new():
        """Factory function to create char2 objects with
        newly allocated chip.char2"""
        cdef chip.char2* ptr
        char2.__allocate(&ptr)
        return char2.from_ptr(ptr, owner=True)
   
    def __init__(self,*args,**kwargs):
        char2.__allocate(&self._ptr)
        self.ptr_owner = True
        attribs = self.PROPERTIES()
        used_attribs = set()
        if len(args) > len(attribs):
            raise ValueError("More positional arguments specified than this type has properties.")
        for i,v in enumerate(args):
            setattr(self,attribs[i],v)
            used_attribs.add(attribs[i])
        valid_names = ", ".join(["'"+p+"'" for p in attribs])
        for k,v in kwargs.items():
            if k in used_attribs:
                raise KeyError(f"argument '{k}' has already been specified as positional argument.")
            elif k not in attribs:
                raise KeyError(f"'{k}' is no valid property name. Valid names: {valid_names}")
            setattr(self,k,v)
    
    def __int__(self):
        """Returns the data's address as long integer."""
        return cpython.long.PyLong_FromVoidPtr(self._ptr)
    def __repr__(self):
        return f"<char2 object, self.ptr={int(self)}>"
    def as_c_void_p(self):
        """Returns the data's address as `ctypes.c_void_p`"""
        return ctypes.c_void_p(int(self))
    def get_x(self, i):
        """Get value ``x`` of ``self._ptr[i]``.
        """
        return self._ptr[i].x
    def set_x(self, i, char value):
        """Set value ``x`` of ``self._ptr[i]``.
        """
        self._ptr[i].x = value
    @property
    def x(self):
        return self.get_x(0)
    @x.setter
    def x(self, char value):
        self.set_x(0,value)

    def get_y(self, i):
        """Get value ``y`` of ``self._ptr[i]``.
        """
        return self._ptr[i].y
    def set_y(self, i, char value):
        """Set value ``y`` of ``self._ptr[i]``.
        """
        self._ptr[i].y = value
    @property
    def y(self):
        return self.get_y(0)
    @y.setter
    def y(self, char value):
        self.set_y(0,value)

    @staticmethod
    def PROPERTIES():
        return ["x","y"]

    def __contains__(self,item):
        properties = self.PROPERTIES()
        return item in properties

    def __getitem__(self,item):
        properties = self.PROPERTIES()
        if isinstance(item,int):
            if item < 0 or item >= len(properties):
                raise IndexError()
            return getattr(self,properties[item])
        raise ValueError("'item' type must be 'int'")


cdef class char3:
    # members declared in pxd file

    def __cinit__(self):
        self._ptr = NULL
        self.ptr_owner = False
        self._py_buffer_acquired = False

    @staticmethod
    cdef char3 from_ptr(chip.char3* ptr, bint owner=False):
        """Factory function to create ``char3`` objects from
        given ``chip.char3`` pointer.

        Setting ``owner`` flag to ``True`` causes
        the extension type to ``free`` the structure pointed to by ``ptr``
        when the wrapper object is deallocated.
        """
        # Fast call to __new__() that bypasses the __init__() constructor.
        cdef char3 wrapper = char3.__new__(char3)
        wrapper._ptr = ptr
        wrapper.ptr_owner = owner
        return wrapper

    @staticmethod
    cdef char3 from_pyobj(object pyobj):
        """Derives a char3 from a Python object.

        Derives a char3 from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``char3`` reference, this method
        returns it directly. No new ``char3`` is created in this case.

        Args:
            pyobj (object): Must be either ``None``, a simple, contiguous buffer according to the buffer protocol,
                            or of type ``char3``, ``int``, or ``ctypes.c_void_p``

        Note:
            This routine does not perform a copy but returns the original ``pyobj``
            if ``pyobj`` is an instance of char3!
        """
        cdef char3 wrapper = char3.__new__(char3)
        cdef dict cuda_array_interface = getattr(pyobj, "__cuda_array_interface__", None)

        if pyobj is None:
            wrapper._ptr = NULL
        elif isinstance(pyobj,char3):
            return pyobj
        elif isinstance(pyobj,int):
            wrapper._ptr = <chip.char3*>cpython.long.PyLong_AsVoidPtr(pyobj)
        elif isinstance(pyobj,ctypes.c_void_p):
            wrapper._ptr = <chip.char3*>cpython.long.PyLong_AsVoidPtr(pyobj.value) if pyobj.value != None else NULL
        elif cuda_array_interface != None:
            if not "data" in cuda_array_interface:
                raise ValueError("input object has '__cuda_array_interface__' attribute but the dict has no 'data' key")
            ptr_as_int = cuda_array_interface["data"][0]
            wrapper._ptr = <chip.char3*>cpython.long.PyLong_AsVoidPtr(ptr_as_int)
        elif cpython.buffer.PyObject_CheckBuffer(pyobj):
            err = cpython.buffer.PyObject_GetBuffer( 
                pyobj,
                &wrapper._py_buffer, 
                cpython.buffer.PyBUF_SIMPLE | cpython.buffer.PyBUF_ANY_CONTIGUOUS
            )
            if err == -1:
                raise RuntimeError("failed to create simple, contiguous Py_buffer from Python object")
            wrapper._py_buffer_acquired = True
            wrapper._ptr = <chip.char3*>wrapper._py_buffer.buf
        else:
            raise TypeError(f"unsupported input type: '{str(type(pyobj))}'")
        return wrapper
    def __dealloc__(self):
        # Release the buffer handle
        if self._py_buffer_acquired is True:
            cpython.buffer.PyBuffer_Release(&self._py_buffer)
        # De-allocate if not null and flag is set
        if self._ptr is not NULL and self.ptr_owner is True:
            stdlib.free(self._ptr)
            self._ptr = NULL
    @staticmethod
    cdef __allocate(chip.char3** ptr):
        ptr[0] = <chip.char3*>stdlib.malloc(sizeof(chip.char3))

        if ptr[0] is NULL:
            raise MemoryError
        # TODO init values, if present

    @staticmethod
    cdef char3 new():
        """Factory function to create char3 objects with
        newly allocated chip.char3"""
        cdef chip.char3* ptr
        char3.__allocate(&ptr)
        return char3.from_ptr(ptr, owner=True)
   
    def __init__(self,*args,**kwargs):
        char3.__allocate(&self._ptr)
        self.ptr_owner = True
        attribs = self.PROPERTIES()
        used_attribs = set()
        if len(args) > len(attribs):
            raise ValueError("More positional arguments specified than this type has properties.")
        for i,v in enumerate(args):
            setattr(self,attribs[i],v)
            used_attribs.add(attribs[i])
        valid_names = ", ".join(["'"+p+"'" for p in attribs])
        for k,v in kwargs.items():
            if k in used_attribs:
                raise KeyError(f"argument '{k}' has already been specified as positional argument.")
            elif k not in attribs:
                raise KeyError(f"'{k}' is no valid property name. Valid names: {valid_names}")
            setattr(self,k,v)
    
    def __int__(self):
        """Returns the data's address as long integer."""
        return cpython.long.PyLong_FromVoidPtr(self._ptr)
    def __repr__(self):
        return f"<char3 object, self.ptr={int(self)}>"
    def as_c_void_p(self):
        """Returns the data's address as `ctypes.c_void_p`"""
        return ctypes.c_void_p(int(self))
    def get_x(self, i):
        """Get value ``x`` of ``self._ptr[i]``.
        """
        return self._ptr[i].x
    def set_x(self, i, char value):
        """Set value ``x`` of ``self._ptr[i]``.
        """
        self._ptr[i].x = value
    @property
    def x(self):
        return self.get_x(0)
    @x.setter
    def x(self, char value):
        self.set_x(0,value)

    def get_y(self, i):
        """Get value ``y`` of ``self._ptr[i]``.
        """
        return self._ptr[i].y
    def set_y(self, i, char value):
        """Set value ``y`` of ``self._ptr[i]``.
        """
        self._ptr[i].y = value
    @property
    def y(self):
        return self.get_y(0)
    @y.setter
    def y(self, char value):
        self.set_y(0,value)

    def get_z(self, i):
        """Get value ``z`` of ``self._ptr[i]``.
        """
        return self._ptr[i].z
    def set_z(self, i, char value):
        """Set value ``z`` of ``self._ptr[i]``.
        """
        self._ptr[i].z = value
    @property
    def z(self):
        return self.get_z(0)
    @z.setter
    def z(self, char value):
        self.set_z(0,value)

    @staticmethod
    def PROPERTIES():
        return ["x","y","z"]

    def __contains__(self,item):
        properties = self.PROPERTIES()
        return item in properties

    def __getitem__(self,item):
        properties = self.PROPERTIES()
        if isinstance(item,int):
            if item < 0 or item >= len(properties):
                raise IndexError()
            return getattr(self,properties[item])
        raise ValueError("'item' type must be 'int'")


cdef class char4:
    # members declared in pxd file

    def __cinit__(self):
        self._ptr = NULL
        self.ptr_owner = False
        self._py_buffer_acquired = False

    @staticmethod
    cdef char4 from_ptr(chip.char4* ptr, bint owner=False):
        """Factory function to create ``char4`` objects from
        given ``chip.char4`` pointer.

        Setting ``owner`` flag to ``True`` causes
        the extension type to ``free`` the structure pointed to by ``ptr``
        when the wrapper object is deallocated.
        """
        # Fast call to __new__() that bypasses the __init__() constructor.
        cdef char4 wrapper = char4.__new__(char4)
        wrapper._ptr = ptr
        wrapper.ptr_owner = owner
        return wrapper

    @staticmethod
    cdef char4 from_pyobj(object pyobj):
        """Derives a char4 from a Python object.

        Derives a char4 from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``char4`` reference, this method
        returns it directly. No new ``char4`` is created in this case.

        Args:
            pyobj (object): Must be either ``None``, a simple, contiguous buffer according to the buffer protocol,
                            or of type ``char4``, ``int``, or ``ctypes.c_void_p``

        Note:
            This routine does not perform a copy but returns the original ``pyobj``
            if ``pyobj`` is an instance of char4!
        """
        cdef char4 wrapper = char4.__new__(char4)
        cdef dict cuda_array_interface = getattr(pyobj, "__cuda_array_interface__", None)

        if pyobj is None:
            wrapper._ptr = NULL
        elif isinstance(pyobj,char4):
            return pyobj
        elif isinstance(pyobj,int):
            wrapper._ptr = <chip.char4*>cpython.long.PyLong_AsVoidPtr(pyobj)
        elif isinstance(pyobj,ctypes.c_void_p):
            wrapper._ptr = <chip.char4*>cpython.long.PyLong_AsVoidPtr(pyobj.value) if pyobj.value != None else NULL
        elif cuda_array_interface != None:
            if not "data" in cuda_array_interface:
                raise ValueError("input object has '__cuda_array_interface__' attribute but the dict has no 'data' key")
            ptr_as_int = cuda_array_interface["data"][0]
            wrapper._ptr = <chip.char4*>cpython.long.PyLong_AsVoidPtr(ptr_as_int)
        elif cpython.buffer.PyObject_CheckBuffer(pyobj):
            err = cpython.buffer.PyObject_GetBuffer( 
                pyobj,
                &wrapper._py_buffer, 
                cpython.buffer.PyBUF_SIMPLE | cpython.buffer.PyBUF_ANY_CONTIGUOUS
            )
            if err == -1:
                raise RuntimeError("failed to create simple, contiguous Py_buffer from Python object")
            wrapper._py_buffer_acquired = True
            wrapper._ptr = <chip.char4*>wrapper._py_buffer.buf
        else:
            raise TypeError(f"unsupported input type: '{str(type(pyobj))}'")
        return wrapper
    def __dealloc__(self):
        # Release the buffer handle
        if self._py_buffer_acquired is True:
            cpython.buffer.PyBuffer_Release(&self._py_buffer)
        # De-allocate if not null and flag is set
        if self._ptr is not NULL and self.ptr_owner is True:
            stdlib.free(self._ptr)
            self._ptr = NULL
    @staticmethod
    cdef __allocate(chip.char4** ptr):
        ptr[0] = <chip.char4*>stdlib.malloc(sizeof(chip.char4))

        if ptr[0] is NULL:
            raise MemoryError
        # TODO init values, if present

    @staticmethod
    cdef char4 new():
        """Factory function to create char4 objects with
        newly allocated chip.char4"""
        cdef chip.char4* ptr
        char4.__allocate(&ptr)
        return char4.from_ptr(ptr, owner=True)
   
    def __init__(self,*args,**kwargs):
        char4.__allocate(&self._ptr)
        self.ptr_owner = True
        attribs = self.PROPERTIES()
        used_attribs = set()
        if len(args) > len(attribs):
            raise ValueError("More positional arguments specified than this type has properties.")
        for i,v in enumerate(args):
            setattr(self,attribs[i],v)
            used_attribs.add(attribs[i])
        valid_names = ", ".join(["'"+p+"'" for p in attribs])
        for k,v in kwargs.items():
            if k in used_attribs:
                raise KeyError(f"argument '{k}' has already been specified as positional argument.")
            elif k not in attribs:
                raise KeyError(f"'{k}' is no valid property name. Valid names: {valid_names}")
            setattr(self,k,v)
    
    def __int__(self):
        """Returns the data's address as long integer."""
        return cpython.long.PyLong_FromVoidPtr(self._ptr)
    def __repr__(self):
        return f"<char4 object, self.ptr={int(self)}>"
    def as_c_void_p(self):
        """Returns the data's address as `ctypes.c_void_p`"""
        return ctypes.c_void_p(int(self))
    def get_x(self, i):
        """Get value ``x`` of ``self._ptr[i]``.
        """
        return self._ptr[i].x
    def set_x(self, i, char value):
        """Set value ``x`` of ``self._ptr[i]``.
        """
        self._ptr[i].x = value
    @property
    def x(self):
        return self.get_x(0)
    @x.setter
    def x(self, char value):
        self.set_x(0,value)

    def get_y(self, i):
        """Get value ``y`` of ``self._ptr[i]``.
        """
        return self._ptr[i].y
    def set_y(self, i, char value):
        """Set value ``y`` of ``self._ptr[i]``.
        """
        self._ptr[i].y = value
    @property
    def y(self):
        return self.get_y(0)
    @y.setter
    def y(self, char value):
        self.set_y(0,value)

    def get_z(self, i):
        """Get value ``z`` of ``self._ptr[i]``.
        """
        return self._ptr[i].z
    def set_z(self, i, char value):
        """Set value ``z`` of ``self._ptr[i]``.
        """
        self._ptr[i].z = value
    @property
    def z(self):
        return self.get_z(0)
    @z.setter
    def z(self, char value):
        self.set_z(0,value)

    def get_w(self, i):
        """Get value ``w`` of ``self._ptr[i]``.
        """
        return self._ptr[i].w
    def set_w(self, i, char value):
        """Set value ``w`` of ``self._ptr[i]``.
        """
        self._ptr[i].w = value
    @property
    def w(self):
        return self.get_w(0)
    @w.setter
    def w(self, char value):
        self.set_w(0,value)

    @staticmethod
    def PROPERTIES():
        return ["x","y","z","w"]

    def __contains__(self,item):
        properties = self.PROPERTIES()
        return item in properties

    def __getitem__(self,item):
        properties = self.PROPERTIES()
        if isinstance(item,int):
            if item < 0 or item >= len(properties):
                raise IndexError()
            return getattr(self,properties[item])
        raise ValueError("'item' type must be 'int'")


cdef class ushort1:
    # members declared in pxd file

    def __cinit__(self):
        self._ptr = NULL
        self.ptr_owner = False
        self._py_buffer_acquired = False

    @staticmethod
    cdef ushort1 from_ptr(chip.ushort1* ptr, bint owner=False):
        """Factory function to create ``ushort1`` objects from
        given ``chip.ushort1`` pointer.

        Setting ``owner`` flag to ``True`` causes
        the extension type to ``free`` the structure pointed to by ``ptr``
        when the wrapper object is deallocated.
        """
        # Fast call to __new__() that bypasses the __init__() constructor.
        cdef ushort1 wrapper = ushort1.__new__(ushort1)
        wrapper._ptr = ptr
        wrapper.ptr_owner = owner
        return wrapper

    @staticmethod
    cdef ushort1 from_pyobj(object pyobj):
        """Derives a ushort1 from a Python object.

        Derives a ushort1 from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``ushort1`` reference, this method
        returns it directly. No new ``ushort1`` is created in this case.

        Args:
            pyobj (object): Must be either ``None``, a simple, contiguous buffer according to the buffer protocol,
                            or of type ``ushort1``, ``int``, or ``ctypes.c_void_p``

        Note:
            This routine does not perform a copy but returns the original ``pyobj``
            if ``pyobj`` is an instance of ushort1!
        """
        cdef ushort1 wrapper = ushort1.__new__(ushort1)
        cdef dict cuda_array_interface = getattr(pyobj, "__cuda_array_interface__", None)

        if pyobj is None:
            wrapper._ptr = NULL
        elif isinstance(pyobj,ushort1):
            return pyobj
        elif isinstance(pyobj,int):
            wrapper._ptr = <chip.ushort1*>cpython.long.PyLong_AsVoidPtr(pyobj)
        elif isinstance(pyobj,ctypes.c_void_p):
            wrapper._ptr = <chip.ushort1*>cpython.long.PyLong_AsVoidPtr(pyobj.value) if pyobj.value != None else NULL
        elif cuda_array_interface != None:
            if not "data" in cuda_array_interface:
                raise ValueError("input object has '__cuda_array_interface__' attribute but the dict has no 'data' key")
            ptr_as_int = cuda_array_interface["data"][0]
            wrapper._ptr = <chip.ushort1*>cpython.long.PyLong_AsVoidPtr(ptr_as_int)
        elif cpython.buffer.PyObject_CheckBuffer(pyobj):
            err = cpython.buffer.PyObject_GetBuffer( 
                pyobj,
                &wrapper._py_buffer, 
                cpython.buffer.PyBUF_SIMPLE | cpython.buffer.PyBUF_ANY_CONTIGUOUS
            )
            if err == -1:
                raise RuntimeError("failed to create simple, contiguous Py_buffer from Python object")
            wrapper._py_buffer_acquired = True
            wrapper._ptr = <chip.ushort1*>wrapper._py_buffer.buf
        else:
            raise TypeError(f"unsupported input type: '{str(type(pyobj))}'")
        return wrapper
    def __dealloc__(self):
        # Release the buffer handle
        if self._py_buffer_acquired is True:
            cpython.buffer.PyBuffer_Release(&self._py_buffer)
        # De-allocate if not null and flag is set
        if self._ptr is not NULL and self.ptr_owner is True:
            stdlib.free(self._ptr)
            self._ptr = NULL
    @staticmethod
    cdef __allocate(chip.ushort1** ptr):
        ptr[0] = <chip.ushort1*>stdlib.malloc(sizeof(chip.ushort1))

        if ptr[0] is NULL:
            raise MemoryError
        # TODO init values, if present

    @staticmethod
    cdef ushort1 new():
        """Factory function to create ushort1 objects with
        newly allocated chip.ushort1"""
        cdef chip.ushort1* ptr
        ushort1.__allocate(&ptr)
        return ushort1.from_ptr(ptr, owner=True)
   
    def __init__(self,*args,**kwargs):
        ushort1.__allocate(&self._ptr)
        self.ptr_owner = True
        attribs = self.PROPERTIES()
        used_attribs = set()
        if len(args) > len(attribs):
            raise ValueError("More positional arguments specified than this type has properties.")
        for i,v in enumerate(args):
            setattr(self,attribs[i],v)
            used_attribs.add(attribs[i])
        valid_names = ", ".join(["'"+p+"'" for p in attribs])
        for k,v in kwargs.items():
            if k in used_attribs:
                raise KeyError(f"argument '{k}' has already been specified as positional argument.")
            elif k not in attribs:
                raise KeyError(f"'{k}' is no valid property name. Valid names: {valid_names}")
            setattr(self,k,v)
    
    def __int__(self):
        """Returns the data's address as long integer."""
        return cpython.long.PyLong_FromVoidPtr(self._ptr)
    def __repr__(self):
        return f"<ushort1 object, self.ptr={int(self)}>"
    def as_c_void_p(self):
        """Returns the data's address as `ctypes.c_void_p`"""
        return ctypes.c_void_p(int(self))
    def get_x(self, i):
        """Get value ``x`` of ``self._ptr[i]``.
        """
        return self._ptr[i].x
    def set_x(self, i, unsigned short value):
        """Set value ``x`` of ``self._ptr[i]``.
        """
        self._ptr[i].x = value
    @property
    def x(self):
        return self.get_x(0)
    @x.setter
    def x(self, unsigned short value):
        self.set_x(0,value)

    @staticmethod
    def PROPERTIES():
        return ["x"]

    def __contains__(self,item):
        properties = self.PROPERTIES()
        return item in properties

    def __getitem__(self,item):
        properties = self.PROPERTIES()
        if isinstance(item,int):
            if item < 0 or item >= len(properties):
                raise IndexError()
            return getattr(self,properties[item])
        raise ValueError("'item' type must be 'int'")


cdef class ushort2:
    # members declared in pxd file

    def __cinit__(self):
        self._ptr = NULL
        self.ptr_owner = False
        self._py_buffer_acquired = False

    @staticmethod
    cdef ushort2 from_ptr(chip.ushort2* ptr, bint owner=False):
        """Factory function to create ``ushort2`` objects from
        given ``chip.ushort2`` pointer.

        Setting ``owner`` flag to ``True`` causes
        the extension type to ``free`` the structure pointed to by ``ptr``
        when the wrapper object is deallocated.
        """
        # Fast call to __new__() that bypasses the __init__() constructor.
        cdef ushort2 wrapper = ushort2.__new__(ushort2)
        wrapper._ptr = ptr
        wrapper.ptr_owner = owner
        return wrapper

    @staticmethod
    cdef ushort2 from_pyobj(object pyobj):
        """Derives a ushort2 from a Python object.

        Derives a ushort2 from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``ushort2`` reference, this method
        returns it directly. No new ``ushort2`` is created in this case.

        Args:
            pyobj (object): Must be either ``None``, a simple, contiguous buffer according to the buffer protocol,
                            or of type ``ushort2``, ``int``, or ``ctypes.c_void_p``

        Note:
            This routine does not perform a copy but returns the original ``pyobj``
            if ``pyobj`` is an instance of ushort2!
        """
        cdef ushort2 wrapper = ushort2.__new__(ushort2)
        cdef dict cuda_array_interface = getattr(pyobj, "__cuda_array_interface__", None)

        if pyobj is None:
            wrapper._ptr = NULL
        elif isinstance(pyobj,ushort2):
            return pyobj
        elif isinstance(pyobj,int):
            wrapper._ptr = <chip.ushort2*>cpython.long.PyLong_AsVoidPtr(pyobj)
        elif isinstance(pyobj,ctypes.c_void_p):
            wrapper._ptr = <chip.ushort2*>cpython.long.PyLong_AsVoidPtr(pyobj.value) if pyobj.value != None else NULL
        elif cuda_array_interface != None:
            if not "data" in cuda_array_interface:
                raise ValueError("input object has '__cuda_array_interface__' attribute but the dict has no 'data' key")
            ptr_as_int = cuda_array_interface["data"][0]
            wrapper._ptr = <chip.ushort2*>cpython.long.PyLong_AsVoidPtr(ptr_as_int)
        elif cpython.buffer.PyObject_CheckBuffer(pyobj):
            err = cpython.buffer.PyObject_GetBuffer( 
                pyobj,
                &wrapper._py_buffer, 
                cpython.buffer.PyBUF_SIMPLE | cpython.buffer.PyBUF_ANY_CONTIGUOUS
            )
            if err == -1:
                raise RuntimeError("failed to create simple, contiguous Py_buffer from Python object")
            wrapper._py_buffer_acquired = True
            wrapper._ptr = <chip.ushort2*>wrapper._py_buffer.buf
        else:
            raise TypeError(f"unsupported input type: '{str(type(pyobj))}'")
        return wrapper
    def __dealloc__(self):
        # Release the buffer handle
        if self._py_buffer_acquired is True:
            cpython.buffer.PyBuffer_Release(&self._py_buffer)
        # De-allocate if not null and flag is set
        if self._ptr is not NULL and self.ptr_owner is True:
            stdlib.free(self._ptr)
            self._ptr = NULL
    @staticmethod
    cdef __allocate(chip.ushort2** ptr):
        ptr[0] = <chip.ushort2*>stdlib.malloc(sizeof(chip.ushort2))

        if ptr[0] is NULL:
            raise MemoryError
        # TODO init values, if present

    @staticmethod
    cdef ushort2 new():
        """Factory function to create ushort2 objects with
        newly allocated chip.ushort2"""
        cdef chip.ushort2* ptr
        ushort2.__allocate(&ptr)
        return ushort2.from_ptr(ptr, owner=True)
   
    def __init__(self,*args,**kwargs):
        ushort2.__allocate(&self._ptr)
        self.ptr_owner = True
        attribs = self.PROPERTIES()
        used_attribs = set()
        if len(args) > len(attribs):
            raise ValueError("More positional arguments specified than this type has properties.")
        for i,v in enumerate(args):
            setattr(self,attribs[i],v)
            used_attribs.add(attribs[i])
        valid_names = ", ".join(["'"+p+"'" for p in attribs])
        for k,v in kwargs.items():
            if k in used_attribs:
                raise KeyError(f"argument '{k}' has already been specified as positional argument.")
            elif k not in attribs:
                raise KeyError(f"'{k}' is no valid property name. Valid names: {valid_names}")
            setattr(self,k,v)
    
    def __int__(self):
        """Returns the data's address as long integer."""
        return cpython.long.PyLong_FromVoidPtr(self._ptr)
    def __repr__(self):
        return f"<ushort2 object, self.ptr={int(self)}>"
    def as_c_void_p(self):
        """Returns the data's address as `ctypes.c_void_p`"""
        return ctypes.c_void_p(int(self))
    def get_x(self, i):
        """Get value ``x`` of ``self._ptr[i]``.
        """
        return self._ptr[i].x
    def set_x(self, i, unsigned short value):
        """Set value ``x`` of ``self._ptr[i]``.
        """
        self._ptr[i].x = value
    @property
    def x(self):
        return self.get_x(0)
    @x.setter
    def x(self, unsigned short value):
        self.set_x(0,value)

    def get_y(self, i):
        """Get value ``y`` of ``self._ptr[i]``.
        """
        return self._ptr[i].y
    def set_y(self, i, unsigned short value):
        """Set value ``y`` of ``self._ptr[i]``.
        """
        self._ptr[i].y = value
    @property
    def y(self):
        return self.get_y(0)
    @y.setter
    def y(self, unsigned short value):
        self.set_y(0,value)

    @staticmethod
    def PROPERTIES():
        return ["x","y"]

    def __contains__(self,item):
        properties = self.PROPERTIES()
        return item in properties

    def __getitem__(self,item):
        properties = self.PROPERTIES()
        if isinstance(item,int):
            if item < 0 or item >= len(properties):
                raise IndexError()
            return getattr(self,properties[item])
        raise ValueError("'item' type must be 'int'")


cdef class ushort3:
    # members declared in pxd file

    def __cinit__(self):
        self._ptr = NULL
        self.ptr_owner = False
        self._py_buffer_acquired = False

    @staticmethod
    cdef ushort3 from_ptr(chip.ushort3* ptr, bint owner=False):
        """Factory function to create ``ushort3`` objects from
        given ``chip.ushort3`` pointer.

        Setting ``owner`` flag to ``True`` causes
        the extension type to ``free`` the structure pointed to by ``ptr``
        when the wrapper object is deallocated.
        """
        # Fast call to __new__() that bypasses the __init__() constructor.
        cdef ushort3 wrapper = ushort3.__new__(ushort3)
        wrapper._ptr = ptr
        wrapper.ptr_owner = owner
        return wrapper

    @staticmethod
    cdef ushort3 from_pyobj(object pyobj):
        """Derives a ushort3 from a Python object.

        Derives a ushort3 from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``ushort3`` reference, this method
        returns it directly. No new ``ushort3`` is created in this case.

        Args:
            pyobj (object): Must be either ``None``, a simple, contiguous buffer according to the buffer protocol,
                            or of type ``ushort3``, ``int``, or ``ctypes.c_void_p``

        Note:
            This routine does not perform a copy but returns the original ``pyobj``
            if ``pyobj`` is an instance of ushort3!
        """
        cdef ushort3 wrapper = ushort3.__new__(ushort3)
        cdef dict cuda_array_interface = getattr(pyobj, "__cuda_array_interface__", None)

        if pyobj is None:
            wrapper._ptr = NULL
        elif isinstance(pyobj,ushort3):
            return pyobj
        elif isinstance(pyobj,int):
            wrapper._ptr = <chip.ushort3*>cpython.long.PyLong_AsVoidPtr(pyobj)
        elif isinstance(pyobj,ctypes.c_void_p):
            wrapper._ptr = <chip.ushort3*>cpython.long.PyLong_AsVoidPtr(pyobj.value) if pyobj.value != None else NULL
        elif cuda_array_interface != None:
            if not "data" in cuda_array_interface:
                raise ValueError("input object has '__cuda_array_interface__' attribute but the dict has no 'data' key")
            ptr_as_int = cuda_array_interface["data"][0]
            wrapper._ptr = <chip.ushort3*>cpython.long.PyLong_AsVoidPtr(ptr_as_int)
        elif cpython.buffer.PyObject_CheckBuffer(pyobj):
            err = cpython.buffer.PyObject_GetBuffer( 
                pyobj,
                &wrapper._py_buffer, 
                cpython.buffer.PyBUF_SIMPLE | cpython.buffer.PyBUF_ANY_CONTIGUOUS
            )
            if err == -1:
                raise RuntimeError("failed to create simple, contiguous Py_buffer from Python object")
            wrapper._py_buffer_acquired = True
            wrapper._ptr = <chip.ushort3*>wrapper._py_buffer.buf
        else:
            raise TypeError(f"unsupported input type: '{str(type(pyobj))}'")
        return wrapper
    def __dealloc__(self):
        # Release the buffer handle
        if self._py_buffer_acquired is True:
            cpython.buffer.PyBuffer_Release(&self._py_buffer)
        # De-allocate if not null and flag is set
        if self._ptr is not NULL and self.ptr_owner is True:
            stdlib.free(self._ptr)
            self._ptr = NULL
    @staticmethod
    cdef __allocate(chip.ushort3** ptr):
        ptr[0] = <chip.ushort3*>stdlib.malloc(sizeof(chip.ushort3))

        if ptr[0] is NULL:
            raise MemoryError
        # TODO init values, if present

    @staticmethod
    cdef ushort3 new():
        """Factory function to create ushort3 objects with
        newly allocated chip.ushort3"""
        cdef chip.ushort3* ptr
        ushort3.__allocate(&ptr)
        return ushort3.from_ptr(ptr, owner=True)
   
    def __init__(self,*args,**kwargs):
        ushort3.__allocate(&self._ptr)
        self.ptr_owner = True
        attribs = self.PROPERTIES()
        used_attribs = set()
        if len(args) > len(attribs):
            raise ValueError("More positional arguments specified than this type has properties.")
        for i,v in enumerate(args):
            setattr(self,attribs[i],v)
            used_attribs.add(attribs[i])
        valid_names = ", ".join(["'"+p+"'" for p in attribs])
        for k,v in kwargs.items():
            if k in used_attribs:
                raise KeyError(f"argument '{k}' has already been specified as positional argument.")
            elif k not in attribs:
                raise KeyError(f"'{k}' is no valid property name. Valid names: {valid_names}")
            setattr(self,k,v)
    
    def __int__(self):
        """Returns the data's address as long integer."""
        return cpython.long.PyLong_FromVoidPtr(self._ptr)
    def __repr__(self):
        return f"<ushort3 object, self.ptr={int(self)}>"
    def as_c_void_p(self):
        """Returns the data's address as `ctypes.c_void_p`"""
        return ctypes.c_void_p(int(self))
    def get_x(self, i):
        """Get value ``x`` of ``self._ptr[i]``.
        """
        return self._ptr[i].x
    def set_x(self, i, unsigned short value):
        """Set value ``x`` of ``self._ptr[i]``.
        """
        self._ptr[i].x = value
    @property
    def x(self):
        return self.get_x(0)
    @x.setter
    def x(self, unsigned short value):
        self.set_x(0,value)

    def get_y(self, i):
        """Get value ``y`` of ``self._ptr[i]``.
        """
        return self._ptr[i].y
    def set_y(self, i, unsigned short value):
        """Set value ``y`` of ``self._ptr[i]``.
        """
        self._ptr[i].y = value
    @property
    def y(self):
        return self.get_y(0)
    @y.setter
    def y(self, unsigned short value):
        self.set_y(0,value)

    def get_z(self, i):
        """Get value ``z`` of ``self._ptr[i]``.
        """
        return self._ptr[i].z
    def set_z(self, i, unsigned short value):
        """Set value ``z`` of ``self._ptr[i]``.
        """
        self._ptr[i].z = value
    @property
    def z(self):
        return self.get_z(0)
    @z.setter
    def z(self, unsigned short value):
        self.set_z(0,value)

    @staticmethod
    def PROPERTIES():
        return ["x","y","z"]

    def __contains__(self,item):
        properties = self.PROPERTIES()
        return item in properties

    def __getitem__(self,item):
        properties = self.PROPERTIES()
        if isinstance(item,int):
            if item < 0 or item >= len(properties):
                raise IndexError()
            return getattr(self,properties[item])
        raise ValueError("'item' type must be 'int'")


cdef class ushort4:
    # members declared in pxd file

    def __cinit__(self):
        self._ptr = NULL
        self.ptr_owner = False
        self._py_buffer_acquired = False

    @staticmethod
    cdef ushort4 from_ptr(chip.ushort4* ptr, bint owner=False):
        """Factory function to create ``ushort4`` objects from
        given ``chip.ushort4`` pointer.

        Setting ``owner`` flag to ``True`` causes
        the extension type to ``free`` the structure pointed to by ``ptr``
        when the wrapper object is deallocated.
        """
        # Fast call to __new__() that bypasses the __init__() constructor.
        cdef ushort4 wrapper = ushort4.__new__(ushort4)
        wrapper._ptr = ptr
        wrapper.ptr_owner = owner
        return wrapper

    @staticmethod
    cdef ushort4 from_pyobj(object pyobj):
        """Derives a ushort4 from a Python object.

        Derives a ushort4 from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``ushort4`` reference, this method
        returns it directly. No new ``ushort4`` is created in this case.

        Args:
            pyobj (object): Must be either ``None``, a simple, contiguous buffer according to the buffer protocol,
                            or of type ``ushort4``, ``int``, or ``ctypes.c_void_p``

        Note:
            This routine does not perform a copy but returns the original ``pyobj``
            if ``pyobj`` is an instance of ushort4!
        """
        cdef ushort4 wrapper = ushort4.__new__(ushort4)
        cdef dict cuda_array_interface = getattr(pyobj, "__cuda_array_interface__", None)

        if pyobj is None:
            wrapper._ptr = NULL
        elif isinstance(pyobj,ushort4):
            return pyobj
        elif isinstance(pyobj,int):
            wrapper._ptr = <chip.ushort4*>cpython.long.PyLong_AsVoidPtr(pyobj)
        elif isinstance(pyobj,ctypes.c_void_p):
            wrapper._ptr = <chip.ushort4*>cpython.long.PyLong_AsVoidPtr(pyobj.value) if pyobj.value != None else NULL
        elif cuda_array_interface != None:
            if not "data" in cuda_array_interface:
                raise ValueError("input object has '__cuda_array_interface__' attribute but the dict has no 'data' key")
            ptr_as_int = cuda_array_interface["data"][0]
            wrapper._ptr = <chip.ushort4*>cpython.long.PyLong_AsVoidPtr(ptr_as_int)
        elif cpython.buffer.PyObject_CheckBuffer(pyobj):
            err = cpython.buffer.PyObject_GetBuffer( 
                pyobj,
                &wrapper._py_buffer, 
                cpython.buffer.PyBUF_SIMPLE | cpython.buffer.PyBUF_ANY_CONTIGUOUS
            )
            if err == -1:
                raise RuntimeError("failed to create simple, contiguous Py_buffer from Python object")
            wrapper._py_buffer_acquired = True
            wrapper._ptr = <chip.ushort4*>wrapper._py_buffer.buf
        else:
            raise TypeError(f"unsupported input type: '{str(type(pyobj))}'")
        return wrapper
    def __dealloc__(self):
        # Release the buffer handle
        if self._py_buffer_acquired is True:
            cpython.buffer.PyBuffer_Release(&self._py_buffer)
        # De-allocate if not null and flag is set
        if self._ptr is not NULL and self.ptr_owner is True:
            stdlib.free(self._ptr)
            self._ptr = NULL
    @staticmethod
    cdef __allocate(chip.ushort4** ptr):
        ptr[0] = <chip.ushort4*>stdlib.malloc(sizeof(chip.ushort4))

        if ptr[0] is NULL:
            raise MemoryError
        # TODO init values, if present

    @staticmethod
    cdef ushort4 new():
        """Factory function to create ushort4 objects with
        newly allocated chip.ushort4"""
        cdef chip.ushort4* ptr
        ushort4.__allocate(&ptr)
        return ushort4.from_ptr(ptr, owner=True)
   
    def __init__(self,*args,**kwargs):
        ushort4.__allocate(&self._ptr)
        self.ptr_owner = True
        attribs = self.PROPERTIES()
        used_attribs = set()
        if len(args) > len(attribs):
            raise ValueError("More positional arguments specified than this type has properties.")
        for i,v in enumerate(args):
            setattr(self,attribs[i],v)
            used_attribs.add(attribs[i])
        valid_names = ", ".join(["'"+p+"'" for p in attribs])
        for k,v in kwargs.items():
            if k in used_attribs:
                raise KeyError(f"argument '{k}' has already been specified as positional argument.")
            elif k not in attribs:
                raise KeyError(f"'{k}' is no valid property name. Valid names: {valid_names}")
            setattr(self,k,v)
    
    def __int__(self):
        """Returns the data's address as long integer."""
        return cpython.long.PyLong_FromVoidPtr(self._ptr)
    def __repr__(self):
        return f"<ushort4 object, self.ptr={int(self)}>"
    def as_c_void_p(self):
        """Returns the data's address as `ctypes.c_void_p`"""
        return ctypes.c_void_p(int(self))
    def get_x(self, i):
        """Get value ``x`` of ``self._ptr[i]``.
        """
        return self._ptr[i].x
    def set_x(self, i, unsigned short value):
        """Set value ``x`` of ``self._ptr[i]``.
        """
        self._ptr[i].x = value
    @property
    def x(self):
        return self.get_x(0)
    @x.setter
    def x(self, unsigned short value):
        self.set_x(0,value)

    def get_y(self, i):
        """Get value ``y`` of ``self._ptr[i]``.
        """
        return self._ptr[i].y
    def set_y(self, i, unsigned short value):
        """Set value ``y`` of ``self._ptr[i]``.
        """
        self._ptr[i].y = value
    @property
    def y(self):
        return self.get_y(0)
    @y.setter
    def y(self, unsigned short value):
        self.set_y(0,value)

    def get_z(self, i):
        """Get value ``z`` of ``self._ptr[i]``.
        """
        return self._ptr[i].z
    def set_z(self, i, unsigned short value):
        """Set value ``z`` of ``self._ptr[i]``.
        """
        self._ptr[i].z = value
    @property
    def z(self):
        return self.get_z(0)
    @z.setter
    def z(self, unsigned short value):
        self.set_z(0,value)

    def get_w(self, i):
        """Get value ``w`` of ``self._ptr[i]``.
        """
        return self._ptr[i].w
    def set_w(self, i, unsigned short value):
        """Set value ``w`` of ``self._ptr[i]``.
        """
        self._ptr[i].w = value
    @property
    def w(self):
        return self.get_w(0)
    @w.setter
    def w(self, unsigned short value):
        self.set_w(0,value)

    @staticmethod
    def PROPERTIES():
        return ["x","y","z","w"]

    def __contains__(self,item):
        properties = self.PROPERTIES()
        return item in properties

    def __getitem__(self,item):
        properties = self.PROPERTIES()
        if isinstance(item,int):
            if item < 0 or item >= len(properties):
                raise IndexError()
            return getattr(self,properties[item])
        raise ValueError("'item' type must be 'int'")


cdef class short1:
    # members declared in pxd file

    def __cinit__(self):
        self._ptr = NULL
        self.ptr_owner = False
        self._py_buffer_acquired = False

    @staticmethod
    cdef short1 from_ptr(chip.short1* ptr, bint owner=False):
        """Factory function to create ``short1`` objects from
        given ``chip.short1`` pointer.

        Setting ``owner`` flag to ``True`` causes
        the extension type to ``free`` the structure pointed to by ``ptr``
        when the wrapper object is deallocated.
        """
        # Fast call to __new__() that bypasses the __init__() constructor.
        cdef short1 wrapper = short1.__new__(short1)
        wrapper._ptr = ptr
        wrapper.ptr_owner = owner
        return wrapper

    @staticmethod
    cdef short1 from_pyobj(object pyobj):
        """Derives a short1 from a Python object.

        Derives a short1 from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``short1`` reference, this method
        returns it directly. No new ``short1`` is created in this case.

        Args:
            pyobj (object): Must be either ``None``, a simple, contiguous buffer according to the buffer protocol,
                            or of type ``short1``, ``int``, or ``ctypes.c_void_p``

        Note:
            This routine does not perform a copy but returns the original ``pyobj``
            if ``pyobj`` is an instance of short1!
        """
        cdef short1 wrapper = short1.__new__(short1)
        cdef dict cuda_array_interface = getattr(pyobj, "__cuda_array_interface__", None)

        if pyobj is None:
            wrapper._ptr = NULL
        elif isinstance(pyobj,short1):
            return pyobj
        elif isinstance(pyobj,int):
            wrapper._ptr = <chip.short1*>cpython.long.PyLong_AsVoidPtr(pyobj)
        elif isinstance(pyobj,ctypes.c_void_p):
            wrapper._ptr = <chip.short1*>cpython.long.PyLong_AsVoidPtr(pyobj.value) if pyobj.value != None else NULL
        elif cuda_array_interface != None:
            if not "data" in cuda_array_interface:
                raise ValueError("input object has '__cuda_array_interface__' attribute but the dict has no 'data' key")
            ptr_as_int = cuda_array_interface["data"][0]
            wrapper._ptr = <chip.short1*>cpython.long.PyLong_AsVoidPtr(ptr_as_int)
        elif cpython.buffer.PyObject_CheckBuffer(pyobj):
            err = cpython.buffer.PyObject_GetBuffer( 
                pyobj,
                &wrapper._py_buffer, 
                cpython.buffer.PyBUF_SIMPLE | cpython.buffer.PyBUF_ANY_CONTIGUOUS
            )
            if err == -1:
                raise RuntimeError("failed to create simple, contiguous Py_buffer from Python object")
            wrapper._py_buffer_acquired = True
            wrapper._ptr = <chip.short1*>wrapper._py_buffer.buf
        else:
            raise TypeError(f"unsupported input type: '{str(type(pyobj))}'")
        return wrapper
    def __dealloc__(self):
        # Release the buffer handle
        if self._py_buffer_acquired is True:
            cpython.buffer.PyBuffer_Release(&self._py_buffer)
        # De-allocate if not null and flag is set
        if self._ptr is not NULL and self.ptr_owner is True:
            stdlib.free(self._ptr)
            self._ptr = NULL
    @staticmethod
    cdef __allocate(chip.short1** ptr):
        ptr[0] = <chip.short1*>stdlib.malloc(sizeof(chip.short1))

        if ptr[0] is NULL:
            raise MemoryError
        # TODO init values, if present

    @staticmethod
    cdef short1 new():
        """Factory function to create short1 objects with
        newly allocated chip.short1"""
        cdef chip.short1* ptr
        short1.__allocate(&ptr)
        return short1.from_ptr(ptr, owner=True)
   
    def __init__(self,*args,**kwargs):
        short1.__allocate(&self._ptr)
        self.ptr_owner = True
        attribs = self.PROPERTIES()
        used_attribs = set()
        if len(args) > len(attribs):
            raise ValueError("More positional arguments specified than this type has properties.")
        for i,v in enumerate(args):
            setattr(self,attribs[i],v)
            used_attribs.add(attribs[i])
        valid_names = ", ".join(["'"+p+"'" for p in attribs])
        for k,v in kwargs.items():
            if k in used_attribs:
                raise KeyError(f"argument '{k}' has already been specified as positional argument.")
            elif k not in attribs:
                raise KeyError(f"'{k}' is no valid property name. Valid names: {valid_names}")
            setattr(self,k,v)
    
    def __int__(self):
        """Returns the data's address as long integer."""
        return cpython.long.PyLong_FromVoidPtr(self._ptr)
    def __repr__(self):
        return f"<short1 object, self.ptr={int(self)}>"
    def as_c_void_p(self):
        """Returns the data's address as `ctypes.c_void_p`"""
        return ctypes.c_void_p(int(self))
    def get_x(self, i):
        """Get value ``x`` of ``self._ptr[i]``.
        """
        return self._ptr[i].x
    def set_x(self, i, short value):
        """Set value ``x`` of ``self._ptr[i]``.
        """
        self._ptr[i].x = value
    @property
    def x(self):
        return self.get_x(0)
    @x.setter
    def x(self, short value):
        self.set_x(0,value)

    @staticmethod
    def PROPERTIES():
        return ["x"]

    def __contains__(self,item):
        properties = self.PROPERTIES()
        return item in properties

    def __getitem__(self,item):
        properties = self.PROPERTIES()
        if isinstance(item,int):
            if item < 0 or item >= len(properties):
                raise IndexError()
            return getattr(self,properties[item])
        raise ValueError("'item' type must be 'int'")


cdef class short2:
    # members declared in pxd file

    def __cinit__(self):
        self._ptr = NULL
        self.ptr_owner = False
        self._py_buffer_acquired = False

    @staticmethod
    cdef short2 from_ptr(chip.short2* ptr, bint owner=False):
        """Factory function to create ``short2`` objects from
        given ``chip.short2`` pointer.

        Setting ``owner`` flag to ``True`` causes
        the extension type to ``free`` the structure pointed to by ``ptr``
        when the wrapper object is deallocated.
        """
        # Fast call to __new__() that bypasses the __init__() constructor.
        cdef short2 wrapper = short2.__new__(short2)
        wrapper._ptr = ptr
        wrapper.ptr_owner = owner
        return wrapper

    @staticmethod
    cdef short2 from_pyobj(object pyobj):
        """Derives a short2 from a Python object.

        Derives a short2 from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``short2`` reference, this method
        returns it directly. No new ``short2`` is created in this case.

        Args:
            pyobj (object): Must be either ``None``, a simple, contiguous buffer according to the buffer protocol,
                            or of type ``short2``, ``int``, or ``ctypes.c_void_p``

        Note:
            This routine does not perform a copy but returns the original ``pyobj``
            if ``pyobj`` is an instance of short2!
        """
        cdef short2 wrapper = short2.__new__(short2)
        cdef dict cuda_array_interface = getattr(pyobj, "__cuda_array_interface__", None)

        if pyobj is None:
            wrapper._ptr = NULL
        elif isinstance(pyobj,short2):
            return pyobj
        elif isinstance(pyobj,int):
            wrapper._ptr = <chip.short2*>cpython.long.PyLong_AsVoidPtr(pyobj)
        elif isinstance(pyobj,ctypes.c_void_p):
            wrapper._ptr = <chip.short2*>cpython.long.PyLong_AsVoidPtr(pyobj.value) if pyobj.value != None else NULL
        elif cuda_array_interface != None:
            if not "data" in cuda_array_interface:
                raise ValueError("input object has '__cuda_array_interface__' attribute but the dict has no 'data' key")
            ptr_as_int = cuda_array_interface["data"][0]
            wrapper._ptr = <chip.short2*>cpython.long.PyLong_AsVoidPtr(ptr_as_int)
        elif cpython.buffer.PyObject_CheckBuffer(pyobj):
            err = cpython.buffer.PyObject_GetBuffer( 
                pyobj,
                &wrapper._py_buffer, 
                cpython.buffer.PyBUF_SIMPLE | cpython.buffer.PyBUF_ANY_CONTIGUOUS
            )
            if err == -1:
                raise RuntimeError("failed to create simple, contiguous Py_buffer from Python object")
            wrapper._py_buffer_acquired = True
            wrapper._ptr = <chip.short2*>wrapper._py_buffer.buf
        else:
            raise TypeError(f"unsupported input type: '{str(type(pyobj))}'")
        return wrapper
    def __dealloc__(self):
        # Release the buffer handle
        if self._py_buffer_acquired is True:
            cpython.buffer.PyBuffer_Release(&self._py_buffer)
        # De-allocate if not null and flag is set
        if self._ptr is not NULL and self.ptr_owner is True:
            stdlib.free(self._ptr)
            self._ptr = NULL
    @staticmethod
    cdef __allocate(chip.short2** ptr):
        ptr[0] = <chip.short2*>stdlib.malloc(sizeof(chip.short2))

        if ptr[0] is NULL:
            raise MemoryError
        # TODO init values, if present

    @staticmethod
    cdef short2 new():
        """Factory function to create short2 objects with
        newly allocated chip.short2"""
        cdef chip.short2* ptr
        short2.__allocate(&ptr)
        return short2.from_ptr(ptr, owner=True)
   
    def __init__(self,*args,**kwargs):
        short2.__allocate(&self._ptr)
        self.ptr_owner = True
        attribs = self.PROPERTIES()
        used_attribs = set()
        if len(args) > len(attribs):
            raise ValueError("More positional arguments specified than this type has properties.")
        for i,v in enumerate(args):
            setattr(self,attribs[i],v)
            used_attribs.add(attribs[i])
        valid_names = ", ".join(["'"+p+"'" for p in attribs])
        for k,v in kwargs.items():
            if k in used_attribs:
                raise KeyError(f"argument '{k}' has already been specified as positional argument.")
            elif k not in attribs:
                raise KeyError(f"'{k}' is no valid property name. Valid names: {valid_names}")
            setattr(self,k,v)
    
    def __int__(self):
        """Returns the data's address as long integer."""
        return cpython.long.PyLong_FromVoidPtr(self._ptr)
    def __repr__(self):
        return f"<short2 object, self.ptr={int(self)}>"
    def as_c_void_p(self):
        """Returns the data's address as `ctypes.c_void_p`"""
        return ctypes.c_void_p(int(self))
    def get_x(self, i):
        """Get value ``x`` of ``self._ptr[i]``.
        """
        return self._ptr[i].x
    def set_x(self, i, short value):
        """Set value ``x`` of ``self._ptr[i]``.
        """
        self._ptr[i].x = value
    @property
    def x(self):
        return self.get_x(0)
    @x.setter
    def x(self, short value):
        self.set_x(0,value)

    def get_y(self, i):
        """Get value ``y`` of ``self._ptr[i]``.
        """
        return self._ptr[i].y
    def set_y(self, i, short value):
        """Set value ``y`` of ``self._ptr[i]``.
        """
        self._ptr[i].y = value
    @property
    def y(self):
        return self.get_y(0)
    @y.setter
    def y(self, short value):
        self.set_y(0,value)

    @staticmethod
    def PROPERTIES():
        return ["x","y"]

    def __contains__(self,item):
        properties = self.PROPERTIES()
        return item in properties

    def __getitem__(self,item):
        properties = self.PROPERTIES()
        if isinstance(item,int):
            if item < 0 or item >= len(properties):
                raise IndexError()
            return getattr(self,properties[item])
        raise ValueError("'item' type must be 'int'")


cdef class short3:
    # members declared in pxd file

    def __cinit__(self):
        self._ptr = NULL
        self.ptr_owner = False
        self._py_buffer_acquired = False

    @staticmethod
    cdef short3 from_ptr(chip.short3* ptr, bint owner=False):
        """Factory function to create ``short3`` objects from
        given ``chip.short3`` pointer.

        Setting ``owner`` flag to ``True`` causes
        the extension type to ``free`` the structure pointed to by ``ptr``
        when the wrapper object is deallocated.
        """
        # Fast call to __new__() that bypasses the __init__() constructor.
        cdef short3 wrapper = short3.__new__(short3)
        wrapper._ptr = ptr
        wrapper.ptr_owner = owner
        return wrapper

    @staticmethod
    cdef short3 from_pyobj(object pyobj):
        """Derives a short3 from a Python object.

        Derives a short3 from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``short3`` reference, this method
        returns it directly. No new ``short3`` is created in this case.

        Args:
            pyobj (object): Must be either ``None``, a simple, contiguous buffer according to the buffer protocol,
                            or of type ``short3``, ``int``, or ``ctypes.c_void_p``

        Note:
            This routine does not perform a copy but returns the original ``pyobj``
            if ``pyobj`` is an instance of short3!
        """
        cdef short3 wrapper = short3.__new__(short3)
        cdef dict cuda_array_interface = getattr(pyobj, "__cuda_array_interface__", None)

        if pyobj is None:
            wrapper._ptr = NULL
        elif isinstance(pyobj,short3):
            return pyobj
        elif isinstance(pyobj,int):
            wrapper._ptr = <chip.short3*>cpython.long.PyLong_AsVoidPtr(pyobj)
        elif isinstance(pyobj,ctypes.c_void_p):
            wrapper._ptr = <chip.short3*>cpython.long.PyLong_AsVoidPtr(pyobj.value) if pyobj.value != None else NULL
        elif cuda_array_interface != None:
            if not "data" in cuda_array_interface:
                raise ValueError("input object has '__cuda_array_interface__' attribute but the dict has no 'data' key")
            ptr_as_int = cuda_array_interface["data"][0]
            wrapper._ptr = <chip.short3*>cpython.long.PyLong_AsVoidPtr(ptr_as_int)
        elif cpython.buffer.PyObject_CheckBuffer(pyobj):
            err = cpython.buffer.PyObject_GetBuffer( 
                pyobj,
                &wrapper._py_buffer, 
                cpython.buffer.PyBUF_SIMPLE | cpython.buffer.PyBUF_ANY_CONTIGUOUS
            )
            if err == -1:
                raise RuntimeError("failed to create simple, contiguous Py_buffer from Python object")
            wrapper._py_buffer_acquired = True
            wrapper._ptr = <chip.short3*>wrapper._py_buffer.buf
        else:
            raise TypeError(f"unsupported input type: '{str(type(pyobj))}'")
        return wrapper
    def __dealloc__(self):
        # Release the buffer handle
        if self._py_buffer_acquired is True:
            cpython.buffer.PyBuffer_Release(&self._py_buffer)
        # De-allocate if not null and flag is set
        if self._ptr is not NULL and self.ptr_owner is True:
            stdlib.free(self._ptr)
            self._ptr = NULL
    @staticmethod
    cdef __allocate(chip.short3** ptr):
        ptr[0] = <chip.short3*>stdlib.malloc(sizeof(chip.short3))

        if ptr[0] is NULL:
            raise MemoryError
        # TODO init values, if present

    @staticmethod
    cdef short3 new():
        """Factory function to create short3 objects with
        newly allocated chip.short3"""
        cdef chip.short3* ptr
        short3.__allocate(&ptr)
        return short3.from_ptr(ptr, owner=True)
   
    def __init__(self,*args,**kwargs):
        short3.__allocate(&self._ptr)
        self.ptr_owner = True
        attribs = self.PROPERTIES()
        used_attribs = set()
        if len(args) > len(attribs):
            raise ValueError("More positional arguments specified than this type has properties.")
        for i,v in enumerate(args):
            setattr(self,attribs[i],v)
            used_attribs.add(attribs[i])
        valid_names = ", ".join(["'"+p+"'" for p in attribs])
        for k,v in kwargs.items():
            if k in used_attribs:
                raise KeyError(f"argument '{k}' has already been specified as positional argument.")
            elif k not in attribs:
                raise KeyError(f"'{k}' is no valid property name. Valid names: {valid_names}")
            setattr(self,k,v)
    
    def __int__(self):
        """Returns the data's address as long integer."""
        return cpython.long.PyLong_FromVoidPtr(self._ptr)
    def __repr__(self):
        return f"<short3 object, self.ptr={int(self)}>"
    def as_c_void_p(self):
        """Returns the data's address as `ctypes.c_void_p`"""
        return ctypes.c_void_p(int(self))
    def get_x(self, i):
        """Get value ``x`` of ``self._ptr[i]``.
        """
        return self._ptr[i].x
    def set_x(self, i, short value):
        """Set value ``x`` of ``self._ptr[i]``.
        """
        self._ptr[i].x = value
    @property
    def x(self):
        return self.get_x(0)
    @x.setter
    def x(self, short value):
        self.set_x(0,value)

    def get_y(self, i):
        """Get value ``y`` of ``self._ptr[i]``.
        """
        return self._ptr[i].y
    def set_y(self, i, short value):
        """Set value ``y`` of ``self._ptr[i]``.
        """
        self._ptr[i].y = value
    @property
    def y(self):
        return self.get_y(0)
    @y.setter
    def y(self, short value):
        self.set_y(0,value)

    def get_z(self, i):
        """Get value ``z`` of ``self._ptr[i]``.
        """
        return self._ptr[i].z
    def set_z(self, i, short value):
        """Set value ``z`` of ``self._ptr[i]``.
        """
        self._ptr[i].z = value
    @property
    def z(self):
        return self.get_z(0)
    @z.setter
    def z(self, short value):
        self.set_z(0,value)

    @staticmethod
    def PROPERTIES():
        return ["x","y","z"]

    def __contains__(self,item):
        properties = self.PROPERTIES()
        return item in properties

    def __getitem__(self,item):
        properties = self.PROPERTIES()
        if isinstance(item,int):
            if item < 0 or item >= len(properties):
                raise IndexError()
            return getattr(self,properties[item])
        raise ValueError("'item' type must be 'int'")


cdef class short4:
    # members declared in pxd file

    def __cinit__(self):
        self._ptr = NULL
        self.ptr_owner = False
        self._py_buffer_acquired = False

    @staticmethod
    cdef short4 from_ptr(chip.short4* ptr, bint owner=False):
        """Factory function to create ``short4`` objects from
        given ``chip.short4`` pointer.

        Setting ``owner`` flag to ``True`` causes
        the extension type to ``free`` the structure pointed to by ``ptr``
        when the wrapper object is deallocated.
        """
        # Fast call to __new__() that bypasses the __init__() constructor.
        cdef short4 wrapper = short4.__new__(short4)
        wrapper._ptr = ptr
        wrapper.ptr_owner = owner
        return wrapper

    @staticmethod
    cdef short4 from_pyobj(object pyobj):
        """Derives a short4 from a Python object.

        Derives a short4 from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``short4`` reference, this method
        returns it directly. No new ``short4`` is created in this case.

        Args:
            pyobj (object): Must be either ``None``, a simple, contiguous buffer according to the buffer protocol,
                            or of type ``short4``, ``int``, or ``ctypes.c_void_p``

        Note:
            This routine does not perform a copy but returns the original ``pyobj``
            if ``pyobj`` is an instance of short4!
        """
        cdef short4 wrapper = short4.__new__(short4)
        cdef dict cuda_array_interface = getattr(pyobj, "__cuda_array_interface__", None)

        if pyobj is None:
            wrapper._ptr = NULL
        elif isinstance(pyobj,short4):
            return pyobj
        elif isinstance(pyobj,int):
            wrapper._ptr = <chip.short4*>cpython.long.PyLong_AsVoidPtr(pyobj)
        elif isinstance(pyobj,ctypes.c_void_p):
            wrapper._ptr = <chip.short4*>cpython.long.PyLong_AsVoidPtr(pyobj.value) if pyobj.value != None else NULL
        elif cuda_array_interface != None:
            if not "data" in cuda_array_interface:
                raise ValueError("input object has '__cuda_array_interface__' attribute but the dict has no 'data' key")
            ptr_as_int = cuda_array_interface["data"][0]
            wrapper._ptr = <chip.short4*>cpython.long.PyLong_AsVoidPtr(ptr_as_int)
        elif cpython.buffer.PyObject_CheckBuffer(pyobj):
            err = cpython.buffer.PyObject_GetBuffer( 
                pyobj,
                &wrapper._py_buffer, 
                cpython.buffer.PyBUF_SIMPLE | cpython.buffer.PyBUF_ANY_CONTIGUOUS
            )
            if err == -1:
                raise RuntimeError("failed to create simple, contiguous Py_buffer from Python object")
            wrapper._py_buffer_acquired = True
            wrapper._ptr = <chip.short4*>wrapper._py_buffer.buf
        else:
            raise TypeError(f"unsupported input type: '{str(type(pyobj))}'")
        return wrapper
    def __dealloc__(self):
        # Release the buffer handle
        if self._py_buffer_acquired is True:
            cpython.buffer.PyBuffer_Release(&self._py_buffer)
        # De-allocate if not null and flag is set
        if self._ptr is not NULL and self.ptr_owner is True:
            stdlib.free(self._ptr)
            self._ptr = NULL
    @staticmethod
    cdef __allocate(chip.short4** ptr):
        ptr[0] = <chip.short4*>stdlib.malloc(sizeof(chip.short4))

        if ptr[0] is NULL:
            raise MemoryError
        # TODO init values, if present

    @staticmethod
    cdef short4 new():
        """Factory function to create short4 objects with
        newly allocated chip.short4"""
        cdef chip.short4* ptr
        short4.__allocate(&ptr)
        return short4.from_ptr(ptr, owner=True)
   
    def __init__(self,*args,**kwargs):
        short4.__allocate(&self._ptr)
        self.ptr_owner = True
        attribs = self.PROPERTIES()
        used_attribs = set()
        if len(args) > len(attribs):
            raise ValueError("More positional arguments specified than this type has properties.")
        for i,v in enumerate(args):
            setattr(self,attribs[i],v)
            used_attribs.add(attribs[i])
        valid_names = ", ".join(["'"+p+"'" for p in attribs])
        for k,v in kwargs.items():
            if k in used_attribs:
                raise KeyError(f"argument '{k}' has already been specified as positional argument.")
            elif k not in attribs:
                raise KeyError(f"'{k}' is no valid property name. Valid names: {valid_names}")
            setattr(self,k,v)
    
    def __int__(self):
        """Returns the data's address as long integer."""
        return cpython.long.PyLong_FromVoidPtr(self._ptr)
    def __repr__(self):
        return f"<short4 object, self.ptr={int(self)}>"
    def as_c_void_p(self):
        """Returns the data's address as `ctypes.c_void_p`"""
        return ctypes.c_void_p(int(self))
    def get_x(self, i):
        """Get value ``x`` of ``self._ptr[i]``.
        """
        return self._ptr[i].x
    def set_x(self, i, short value):
        """Set value ``x`` of ``self._ptr[i]``.
        """
        self._ptr[i].x = value
    @property
    def x(self):
        return self.get_x(0)
    @x.setter
    def x(self, short value):
        self.set_x(0,value)

    def get_y(self, i):
        """Get value ``y`` of ``self._ptr[i]``.
        """
        return self._ptr[i].y
    def set_y(self, i, short value):
        """Set value ``y`` of ``self._ptr[i]``.
        """
        self._ptr[i].y = value
    @property
    def y(self):
        return self.get_y(0)
    @y.setter
    def y(self, short value):
        self.set_y(0,value)

    def get_z(self, i):
        """Get value ``z`` of ``self._ptr[i]``.
        """
        return self._ptr[i].z
    def set_z(self, i, short value):
        """Set value ``z`` of ``self._ptr[i]``.
        """
        self._ptr[i].z = value
    @property
    def z(self):
        return self.get_z(0)
    @z.setter
    def z(self, short value):
        self.set_z(0,value)

    def get_w(self, i):
        """Get value ``w`` of ``self._ptr[i]``.
        """
        return self._ptr[i].w
    def set_w(self, i, short value):
        """Set value ``w`` of ``self._ptr[i]``.
        """
        self._ptr[i].w = value
    @property
    def w(self):
        return self.get_w(0)
    @w.setter
    def w(self, short value):
        self.set_w(0,value)

    @staticmethod
    def PROPERTIES():
        return ["x","y","z","w"]

    def __contains__(self,item):
        properties = self.PROPERTIES()
        return item in properties

    def __getitem__(self,item):
        properties = self.PROPERTIES()
        if isinstance(item,int):
            if item < 0 or item >= len(properties):
                raise IndexError()
            return getattr(self,properties[item])
        raise ValueError("'item' type must be 'int'")


cdef class uint1:
    # members declared in pxd file

    def __cinit__(self):
        self._ptr = NULL
        self.ptr_owner = False
        self._py_buffer_acquired = False

    @staticmethod
    cdef uint1 from_ptr(chip.uint1* ptr, bint owner=False):
        """Factory function to create ``uint1`` objects from
        given ``chip.uint1`` pointer.

        Setting ``owner`` flag to ``True`` causes
        the extension type to ``free`` the structure pointed to by ``ptr``
        when the wrapper object is deallocated.
        """
        # Fast call to __new__() that bypasses the __init__() constructor.
        cdef uint1 wrapper = uint1.__new__(uint1)
        wrapper._ptr = ptr
        wrapper.ptr_owner = owner
        return wrapper

    @staticmethod
    cdef uint1 from_pyobj(object pyobj):
        """Derives a uint1 from a Python object.

        Derives a uint1 from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``uint1`` reference, this method
        returns it directly. No new ``uint1`` is created in this case.

        Args:
            pyobj (object): Must be either ``None``, a simple, contiguous buffer according to the buffer protocol,
                            or of type ``uint1``, ``int``, or ``ctypes.c_void_p``

        Note:
            This routine does not perform a copy but returns the original ``pyobj``
            if ``pyobj`` is an instance of uint1!
        """
        cdef uint1 wrapper = uint1.__new__(uint1)
        cdef dict cuda_array_interface = getattr(pyobj, "__cuda_array_interface__", None)

        if pyobj is None:
            wrapper._ptr = NULL
        elif isinstance(pyobj,uint1):
            return pyobj
        elif isinstance(pyobj,int):
            wrapper._ptr = <chip.uint1*>cpython.long.PyLong_AsVoidPtr(pyobj)
        elif isinstance(pyobj,ctypes.c_void_p):
            wrapper._ptr = <chip.uint1*>cpython.long.PyLong_AsVoidPtr(pyobj.value) if pyobj.value != None else NULL
        elif cuda_array_interface != None:
            if not "data" in cuda_array_interface:
                raise ValueError("input object has '__cuda_array_interface__' attribute but the dict has no 'data' key")
            ptr_as_int = cuda_array_interface["data"][0]
            wrapper._ptr = <chip.uint1*>cpython.long.PyLong_AsVoidPtr(ptr_as_int)
        elif cpython.buffer.PyObject_CheckBuffer(pyobj):
            err = cpython.buffer.PyObject_GetBuffer( 
                pyobj,
                &wrapper._py_buffer, 
                cpython.buffer.PyBUF_SIMPLE | cpython.buffer.PyBUF_ANY_CONTIGUOUS
            )
            if err == -1:
                raise RuntimeError("failed to create simple, contiguous Py_buffer from Python object")
            wrapper._py_buffer_acquired = True
            wrapper._ptr = <chip.uint1*>wrapper._py_buffer.buf
        else:
            raise TypeError(f"unsupported input type: '{str(type(pyobj))}'")
        return wrapper
    def __dealloc__(self):
        # Release the buffer handle
        if self._py_buffer_acquired is True:
            cpython.buffer.PyBuffer_Release(&self._py_buffer)
        # De-allocate if not null and flag is set
        if self._ptr is not NULL and self.ptr_owner is True:
            stdlib.free(self._ptr)
            self._ptr = NULL
    @staticmethod
    cdef __allocate(chip.uint1** ptr):
        ptr[0] = <chip.uint1*>stdlib.malloc(sizeof(chip.uint1))

        if ptr[0] is NULL:
            raise MemoryError
        # TODO init values, if present

    @staticmethod
    cdef uint1 new():
        """Factory function to create uint1 objects with
        newly allocated chip.uint1"""
        cdef chip.uint1* ptr
        uint1.__allocate(&ptr)
        return uint1.from_ptr(ptr, owner=True)
   
    def __init__(self,*args,**kwargs):
        uint1.__allocate(&self._ptr)
        self.ptr_owner = True
        attribs = self.PROPERTIES()
        used_attribs = set()
        if len(args) > len(attribs):
            raise ValueError("More positional arguments specified than this type has properties.")
        for i,v in enumerate(args):
            setattr(self,attribs[i],v)
            used_attribs.add(attribs[i])
        valid_names = ", ".join(["'"+p+"'" for p in attribs])
        for k,v in kwargs.items():
            if k in used_attribs:
                raise KeyError(f"argument '{k}' has already been specified as positional argument.")
            elif k not in attribs:
                raise KeyError(f"'{k}' is no valid property name. Valid names: {valid_names}")
            setattr(self,k,v)
    
    def __int__(self):
        """Returns the data's address as long integer."""
        return cpython.long.PyLong_FromVoidPtr(self._ptr)
    def __repr__(self):
        return f"<uint1 object, self.ptr={int(self)}>"
    def as_c_void_p(self):
        """Returns the data's address as `ctypes.c_void_p`"""
        return ctypes.c_void_p(int(self))
    def get_x(self, i):
        """Get value ``x`` of ``self._ptr[i]``.
        """
        return self._ptr[i].x
    def set_x(self, i, unsigned int value):
        """Set value ``x`` of ``self._ptr[i]``.
        """
        self._ptr[i].x = value
    @property
    def x(self):
        return self.get_x(0)
    @x.setter
    def x(self, unsigned int value):
        self.set_x(0,value)

    @staticmethod
    def PROPERTIES():
        return ["x"]

    def __contains__(self,item):
        properties = self.PROPERTIES()
        return item in properties

    def __getitem__(self,item):
        properties = self.PROPERTIES()
        if isinstance(item,int):
            if item < 0 or item >= len(properties):
                raise IndexError()
            return getattr(self,properties[item])
        raise ValueError("'item' type must be 'int'")


cdef class uint2:
    # members declared in pxd file

    def __cinit__(self):
        self._ptr = NULL
        self.ptr_owner = False
        self._py_buffer_acquired = False

    @staticmethod
    cdef uint2 from_ptr(chip.uint2* ptr, bint owner=False):
        """Factory function to create ``uint2`` objects from
        given ``chip.uint2`` pointer.

        Setting ``owner`` flag to ``True`` causes
        the extension type to ``free`` the structure pointed to by ``ptr``
        when the wrapper object is deallocated.
        """
        # Fast call to __new__() that bypasses the __init__() constructor.
        cdef uint2 wrapper = uint2.__new__(uint2)
        wrapper._ptr = ptr
        wrapper.ptr_owner = owner
        return wrapper

    @staticmethod
    cdef uint2 from_pyobj(object pyobj):
        """Derives a uint2 from a Python object.

        Derives a uint2 from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``uint2`` reference, this method
        returns it directly. No new ``uint2`` is created in this case.

        Args:
            pyobj (object): Must be either ``None``, a simple, contiguous buffer according to the buffer protocol,
                            or of type ``uint2``, ``int``, or ``ctypes.c_void_p``

        Note:
            This routine does not perform a copy but returns the original ``pyobj``
            if ``pyobj`` is an instance of uint2!
        """
        cdef uint2 wrapper = uint2.__new__(uint2)
        cdef dict cuda_array_interface = getattr(pyobj, "__cuda_array_interface__", None)

        if pyobj is None:
            wrapper._ptr = NULL
        elif isinstance(pyobj,uint2):
            return pyobj
        elif isinstance(pyobj,int):
            wrapper._ptr = <chip.uint2*>cpython.long.PyLong_AsVoidPtr(pyobj)
        elif isinstance(pyobj,ctypes.c_void_p):
            wrapper._ptr = <chip.uint2*>cpython.long.PyLong_AsVoidPtr(pyobj.value) if pyobj.value != None else NULL
        elif cuda_array_interface != None:
            if not "data" in cuda_array_interface:
                raise ValueError("input object has '__cuda_array_interface__' attribute but the dict has no 'data' key")
            ptr_as_int = cuda_array_interface["data"][0]
            wrapper._ptr = <chip.uint2*>cpython.long.PyLong_AsVoidPtr(ptr_as_int)
        elif cpython.buffer.PyObject_CheckBuffer(pyobj):
            err = cpython.buffer.PyObject_GetBuffer( 
                pyobj,
                &wrapper._py_buffer, 
                cpython.buffer.PyBUF_SIMPLE | cpython.buffer.PyBUF_ANY_CONTIGUOUS
            )
            if err == -1:
                raise RuntimeError("failed to create simple, contiguous Py_buffer from Python object")
            wrapper._py_buffer_acquired = True
            wrapper._ptr = <chip.uint2*>wrapper._py_buffer.buf
        else:
            raise TypeError(f"unsupported input type: '{str(type(pyobj))}'")
        return wrapper
    def __dealloc__(self):
        # Release the buffer handle
        if self._py_buffer_acquired is True:
            cpython.buffer.PyBuffer_Release(&self._py_buffer)
        # De-allocate if not null and flag is set
        if self._ptr is not NULL and self.ptr_owner is True:
            stdlib.free(self._ptr)
            self._ptr = NULL
    @staticmethod
    cdef __allocate(chip.uint2** ptr):
        ptr[0] = <chip.uint2*>stdlib.malloc(sizeof(chip.uint2))

        if ptr[0] is NULL:
            raise MemoryError
        # TODO init values, if present

    @staticmethod
    cdef uint2 new():
        """Factory function to create uint2 objects with
        newly allocated chip.uint2"""
        cdef chip.uint2* ptr
        uint2.__allocate(&ptr)
        return uint2.from_ptr(ptr, owner=True)
   
    def __init__(self,*args,**kwargs):
        uint2.__allocate(&self._ptr)
        self.ptr_owner = True
        attribs = self.PROPERTIES()
        used_attribs = set()
        if len(args) > len(attribs):
            raise ValueError("More positional arguments specified than this type has properties.")
        for i,v in enumerate(args):
            setattr(self,attribs[i],v)
            used_attribs.add(attribs[i])
        valid_names = ", ".join(["'"+p+"'" for p in attribs])
        for k,v in kwargs.items():
            if k in used_attribs:
                raise KeyError(f"argument '{k}' has already been specified as positional argument.")
            elif k not in attribs:
                raise KeyError(f"'{k}' is no valid property name. Valid names: {valid_names}")
            setattr(self,k,v)
    
    def __int__(self):
        """Returns the data's address as long integer."""
        return cpython.long.PyLong_FromVoidPtr(self._ptr)
    def __repr__(self):
        return f"<uint2 object, self.ptr={int(self)}>"
    def as_c_void_p(self):
        """Returns the data's address as `ctypes.c_void_p`"""
        return ctypes.c_void_p(int(self))
    def get_x(self, i):
        """Get value ``x`` of ``self._ptr[i]``.
        """
        return self._ptr[i].x
    def set_x(self, i, unsigned int value):
        """Set value ``x`` of ``self._ptr[i]``.
        """
        self._ptr[i].x = value
    @property
    def x(self):
        return self.get_x(0)
    @x.setter
    def x(self, unsigned int value):
        self.set_x(0,value)

    def get_y(self, i):
        """Get value ``y`` of ``self._ptr[i]``.
        """
        return self._ptr[i].y
    def set_y(self, i, unsigned int value):
        """Set value ``y`` of ``self._ptr[i]``.
        """
        self._ptr[i].y = value
    @property
    def y(self):
        return self.get_y(0)
    @y.setter
    def y(self, unsigned int value):
        self.set_y(0,value)

    @staticmethod
    def PROPERTIES():
        return ["x","y"]

    def __contains__(self,item):
        properties = self.PROPERTIES()
        return item in properties

    def __getitem__(self,item):
        properties = self.PROPERTIES()
        if isinstance(item,int):
            if item < 0 or item >= len(properties):
                raise IndexError()
            return getattr(self,properties[item])
        raise ValueError("'item' type must be 'int'")


cdef class uint3:
    # members declared in pxd file

    def __cinit__(self):
        self._ptr = NULL
        self.ptr_owner = False
        self._py_buffer_acquired = False

    @staticmethod
    cdef uint3 from_ptr(chip.uint3* ptr, bint owner=False):
        """Factory function to create ``uint3`` objects from
        given ``chip.uint3`` pointer.

        Setting ``owner`` flag to ``True`` causes
        the extension type to ``free`` the structure pointed to by ``ptr``
        when the wrapper object is deallocated.
        """
        # Fast call to __new__() that bypasses the __init__() constructor.
        cdef uint3 wrapper = uint3.__new__(uint3)
        wrapper._ptr = ptr
        wrapper.ptr_owner = owner
        return wrapper

    @staticmethod
    cdef uint3 from_pyobj(object pyobj):
        """Derives a uint3 from a Python object.

        Derives a uint3 from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``uint3`` reference, this method
        returns it directly. No new ``uint3`` is created in this case.

        Args:
            pyobj (object): Must be either ``None``, a simple, contiguous buffer according to the buffer protocol,
                            or of type ``uint3``, ``int``, or ``ctypes.c_void_p``

        Note:
            This routine does not perform a copy but returns the original ``pyobj``
            if ``pyobj`` is an instance of uint3!
        """
        cdef uint3 wrapper = uint3.__new__(uint3)
        cdef dict cuda_array_interface = getattr(pyobj, "__cuda_array_interface__", None)

        if pyobj is None:
            wrapper._ptr = NULL
        elif isinstance(pyobj,uint3):
            return pyobj
        elif isinstance(pyobj,int):
            wrapper._ptr = <chip.uint3*>cpython.long.PyLong_AsVoidPtr(pyobj)
        elif isinstance(pyobj,ctypes.c_void_p):
            wrapper._ptr = <chip.uint3*>cpython.long.PyLong_AsVoidPtr(pyobj.value) if pyobj.value != None else NULL
        elif cuda_array_interface != None:
            if not "data" in cuda_array_interface:
                raise ValueError("input object has '__cuda_array_interface__' attribute but the dict has no 'data' key")
            ptr_as_int = cuda_array_interface["data"][0]
            wrapper._ptr = <chip.uint3*>cpython.long.PyLong_AsVoidPtr(ptr_as_int)
        elif cpython.buffer.PyObject_CheckBuffer(pyobj):
            err = cpython.buffer.PyObject_GetBuffer( 
                pyobj,
                &wrapper._py_buffer, 
                cpython.buffer.PyBUF_SIMPLE | cpython.buffer.PyBUF_ANY_CONTIGUOUS
            )
            if err == -1:
                raise RuntimeError("failed to create simple, contiguous Py_buffer from Python object")
            wrapper._py_buffer_acquired = True
            wrapper._ptr = <chip.uint3*>wrapper._py_buffer.buf
        else:
            raise TypeError(f"unsupported input type: '{str(type(pyobj))}'")
        return wrapper
    def __dealloc__(self):
        # Release the buffer handle
        if self._py_buffer_acquired is True:
            cpython.buffer.PyBuffer_Release(&self._py_buffer)
        # De-allocate if not null and flag is set
        if self._ptr is not NULL and self.ptr_owner is True:
            stdlib.free(self._ptr)
            self._ptr = NULL
    @staticmethod
    cdef __allocate(chip.uint3** ptr):
        ptr[0] = <chip.uint3*>stdlib.malloc(sizeof(chip.uint3))

        if ptr[0] is NULL:
            raise MemoryError
        # TODO init values, if present

    @staticmethod
    cdef uint3 new():
        """Factory function to create uint3 objects with
        newly allocated chip.uint3"""
        cdef chip.uint3* ptr
        uint3.__allocate(&ptr)
        return uint3.from_ptr(ptr, owner=True)
   
    def __init__(self,*args,**kwargs):
        uint3.__allocate(&self._ptr)
        self.ptr_owner = True
        attribs = self.PROPERTIES()
        used_attribs = set()
        if len(args) > len(attribs):
            raise ValueError("More positional arguments specified than this type has properties.")
        for i,v in enumerate(args):
            setattr(self,attribs[i],v)
            used_attribs.add(attribs[i])
        valid_names = ", ".join(["'"+p+"'" for p in attribs])
        for k,v in kwargs.items():
            if k in used_attribs:
                raise KeyError(f"argument '{k}' has already been specified as positional argument.")
            elif k not in attribs:
                raise KeyError(f"'{k}' is no valid property name. Valid names: {valid_names}")
            setattr(self,k,v)
    
    def __int__(self):
        """Returns the data's address as long integer."""
        return cpython.long.PyLong_FromVoidPtr(self._ptr)
    def __repr__(self):
        return f"<uint3 object, self.ptr={int(self)}>"
    def as_c_void_p(self):
        """Returns the data's address as `ctypes.c_void_p`"""
        return ctypes.c_void_p(int(self))
    def get_x(self, i):
        """Get value ``x`` of ``self._ptr[i]``.
        """
        return self._ptr[i].x
    def set_x(self, i, unsigned int value):
        """Set value ``x`` of ``self._ptr[i]``.
        """
        self._ptr[i].x = value
    @property
    def x(self):
        return self.get_x(0)
    @x.setter
    def x(self, unsigned int value):
        self.set_x(0,value)

    def get_y(self, i):
        """Get value ``y`` of ``self._ptr[i]``.
        """
        return self._ptr[i].y
    def set_y(self, i, unsigned int value):
        """Set value ``y`` of ``self._ptr[i]``.
        """
        self._ptr[i].y = value
    @property
    def y(self):
        return self.get_y(0)
    @y.setter
    def y(self, unsigned int value):
        self.set_y(0,value)

    def get_z(self, i):
        """Get value ``z`` of ``self._ptr[i]``.
        """
        return self._ptr[i].z
    def set_z(self, i, unsigned int value):
        """Set value ``z`` of ``self._ptr[i]``.
        """
        self._ptr[i].z = value
    @property
    def z(self):
        return self.get_z(0)
    @z.setter
    def z(self, unsigned int value):
        self.set_z(0,value)

    @staticmethod
    def PROPERTIES():
        return ["x","y","z"]

    def __contains__(self,item):
        properties = self.PROPERTIES()
        return item in properties

    def __getitem__(self,item):
        properties = self.PROPERTIES()
        if isinstance(item,int):
            if item < 0 or item >= len(properties):
                raise IndexError()
            return getattr(self,properties[item])
        raise ValueError("'item' type must be 'int'")


cdef class uint4:
    # members declared in pxd file

    def __cinit__(self):
        self._ptr = NULL
        self.ptr_owner = False
        self._py_buffer_acquired = False

    @staticmethod
    cdef uint4 from_ptr(chip.uint4* ptr, bint owner=False):
        """Factory function to create ``uint4`` objects from
        given ``chip.uint4`` pointer.

        Setting ``owner`` flag to ``True`` causes
        the extension type to ``free`` the structure pointed to by ``ptr``
        when the wrapper object is deallocated.
        """
        # Fast call to __new__() that bypasses the __init__() constructor.
        cdef uint4 wrapper = uint4.__new__(uint4)
        wrapper._ptr = ptr
        wrapper.ptr_owner = owner
        return wrapper

    @staticmethod
    cdef uint4 from_pyobj(object pyobj):
        """Derives a uint4 from a Python object.

        Derives a uint4 from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``uint4`` reference, this method
        returns it directly. No new ``uint4`` is created in this case.

        Args:
            pyobj (object): Must be either ``None``, a simple, contiguous buffer according to the buffer protocol,
                            or of type ``uint4``, ``int``, or ``ctypes.c_void_p``

        Note:
            This routine does not perform a copy but returns the original ``pyobj``
            if ``pyobj`` is an instance of uint4!
        """
        cdef uint4 wrapper = uint4.__new__(uint4)
        cdef dict cuda_array_interface = getattr(pyobj, "__cuda_array_interface__", None)

        if pyobj is None:
            wrapper._ptr = NULL
        elif isinstance(pyobj,uint4):
            return pyobj
        elif isinstance(pyobj,int):
            wrapper._ptr = <chip.uint4*>cpython.long.PyLong_AsVoidPtr(pyobj)
        elif isinstance(pyobj,ctypes.c_void_p):
            wrapper._ptr = <chip.uint4*>cpython.long.PyLong_AsVoidPtr(pyobj.value) if pyobj.value != None else NULL
        elif cuda_array_interface != None:
            if not "data" in cuda_array_interface:
                raise ValueError("input object has '__cuda_array_interface__' attribute but the dict has no 'data' key")
            ptr_as_int = cuda_array_interface["data"][0]
            wrapper._ptr = <chip.uint4*>cpython.long.PyLong_AsVoidPtr(ptr_as_int)
        elif cpython.buffer.PyObject_CheckBuffer(pyobj):
            err = cpython.buffer.PyObject_GetBuffer( 
                pyobj,
                &wrapper._py_buffer, 
                cpython.buffer.PyBUF_SIMPLE | cpython.buffer.PyBUF_ANY_CONTIGUOUS
            )
            if err == -1:
                raise RuntimeError("failed to create simple, contiguous Py_buffer from Python object")
            wrapper._py_buffer_acquired = True
            wrapper._ptr = <chip.uint4*>wrapper._py_buffer.buf
        else:
            raise TypeError(f"unsupported input type: '{str(type(pyobj))}'")
        return wrapper
    def __dealloc__(self):
        # Release the buffer handle
        if self._py_buffer_acquired is True:
            cpython.buffer.PyBuffer_Release(&self._py_buffer)
        # De-allocate if not null and flag is set
        if self._ptr is not NULL and self.ptr_owner is True:
            stdlib.free(self._ptr)
            self._ptr = NULL
    @staticmethod
    cdef __allocate(chip.uint4** ptr):
        ptr[0] = <chip.uint4*>stdlib.malloc(sizeof(chip.uint4))

        if ptr[0] is NULL:
            raise MemoryError
        # TODO init values, if present

    @staticmethod
    cdef uint4 new():
        """Factory function to create uint4 objects with
        newly allocated chip.uint4"""
        cdef chip.uint4* ptr
        uint4.__allocate(&ptr)
        return uint4.from_ptr(ptr, owner=True)
   
    def __init__(self,*args,**kwargs):
        uint4.__allocate(&self._ptr)
        self.ptr_owner = True
        attribs = self.PROPERTIES()
        used_attribs = set()
        if len(args) > len(attribs):
            raise ValueError("More positional arguments specified than this type has properties.")
        for i,v in enumerate(args):
            setattr(self,attribs[i],v)
            used_attribs.add(attribs[i])
        valid_names = ", ".join(["'"+p+"'" for p in attribs])
        for k,v in kwargs.items():
            if k in used_attribs:
                raise KeyError(f"argument '{k}' has already been specified as positional argument.")
            elif k not in attribs:
                raise KeyError(f"'{k}' is no valid property name. Valid names: {valid_names}")
            setattr(self,k,v)
    
    def __int__(self):
        """Returns the data's address as long integer."""
        return cpython.long.PyLong_FromVoidPtr(self._ptr)
    def __repr__(self):
        return f"<uint4 object, self.ptr={int(self)}>"
    def as_c_void_p(self):
        """Returns the data's address as `ctypes.c_void_p`"""
        return ctypes.c_void_p(int(self))
    def get_x(self, i):
        """Get value ``x`` of ``self._ptr[i]``.
        """
        return self._ptr[i].x
    def set_x(self, i, unsigned int value):
        """Set value ``x`` of ``self._ptr[i]``.
        """
        self._ptr[i].x = value
    @property
    def x(self):
        return self.get_x(0)
    @x.setter
    def x(self, unsigned int value):
        self.set_x(0,value)

    def get_y(self, i):
        """Get value ``y`` of ``self._ptr[i]``.
        """
        return self._ptr[i].y
    def set_y(self, i, unsigned int value):
        """Set value ``y`` of ``self._ptr[i]``.
        """
        self._ptr[i].y = value
    @property
    def y(self):
        return self.get_y(0)
    @y.setter
    def y(self, unsigned int value):
        self.set_y(0,value)

    def get_z(self, i):
        """Get value ``z`` of ``self._ptr[i]``.
        """
        return self._ptr[i].z
    def set_z(self, i, unsigned int value):
        """Set value ``z`` of ``self._ptr[i]``.
        """
        self._ptr[i].z = value
    @property
    def z(self):
        return self.get_z(0)
    @z.setter
    def z(self, unsigned int value):
        self.set_z(0,value)

    def get_w(self, i):
        """Get value ``w`` of ``self._ptr[i]``.
        """
        return self._ptr[i].w
    def set_w(self, i, unsigned int value):
        """Set value ``w`` of ``self._ptr[i]``.
        """
        self._ptr[i].w = value
    @property
    def w(self):
        return self.get_w(0)
    @w.setter
    def w(self, unsigned int value):
        self.set_w(0,value)

    @staticmethod
    def PROPERTIES():
        return ["x","y","z","w"]

    def __contains__(self,item):
        properties = self.PROPERTIES()
        return item in properties

    def __getitem__(self,item):
        properties = self.PROPERTIES()
        if isinstance(item,int):
            if item < 0 or item >= len(properties):
                raise IndexError()
            return getattr(self,properties[item])
        raise ValueError("'item' type must be 'int'")


cdef class int1:
    # members declared in pxd file

    def __cinit__(self):
        self._ptr = NULL
        self.ptr_owner = False
        self._py_buffer_acquired = False

    @staticmethod
    cdef int1 from_ptr(chip.int1* ptr, bint owner=False):
        """Factory function to create ``int1`` objects from
        given ``chip.int1`` pointer.

        Setting ``owner`` flag to ``True`` causes
        the extension type to ``free`` the structure pointed to by ``ptr``
        when the wrapper object is deallocated.
        """
        # Fast call to __new__() that bypasses the __init__() constructor.
        cdef int1 wrapper = int1.__new__(int1)
        wrapper._ptr = ptr
        wrapper.ptr_owner = owner
        return wrapper

    @staticmethod
    cdef int1 from_pyobj(object pyobj):
        """Derives a int1 from a Python object.

        Derives a int1 from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``int1`` reference, this method
        returns it directly. No new ``int1`` is created in this case.

        Args:
            pyobj (object): Must be either ``None``, a simple, contiguous buffer according to the buffer protocol,
                            or of type ``int1``, ``int``, or ``ctypes.c_void_p``

        Note:
            This routine does not perform a copy but returns the original ``pyobj``
            if ``pyobj`` is an instance of int1!
        """
        cdef int1 wrapper = int1.__new__(int1)
        cdef dict cuda_array_interface = getattr(pyobj, "__cuda_array_interface__", None)

        if pyobj is None:
            wrapper._ptr = NULL
        elif isinstance(pyobj,int1):
            return pyobj
        elif isinstance(pyobj,int):
            wrapper._ptr = <chip.int1*>cpython.long.PyLong_AsVoidPtr(pyobj)
        elif isinstance(pyobj,ctypes.c_void_p):
            wrapper._ptr = <chip.int1*>cpython.long.PyLong_AsVoidPtr(pyobj.value) if pyobj.value != None else NULL
        elif cuda_array_interface != None:
            if not "data" in cuda_array_interface:
                raise ValueError("input object has '__cuda_array_interface__' attribute but the dict has no 'data' key")
            ptr_as_int = cuda_array_interface["data"][0]
            wrapper._ptr = <chip.int1*>cpython.long.PyLong_AsVoidPtr(ptr_as_int)
        elif cpython.buffer.PyObject_CheckBuffer(pyobj):
            err = cpython.buffer.PyObject_GetBuffer( 
                pyobj,
                &wrapper._py_buffer, 
                cpython.buffer.PyBUF_SIMPLE | cpython.buffer.PyBUF_ANY_CONTIGUOUS
            )
            if err == -1:
                raise RuntimeError("failed to create simple, contiguous Py_buffer from Python object")
            wrapper._py_buffer_acquired = True
            wrapper._ptr = <chip.int1*>wrapper._py_buffer.buf
        else:
            raise TypeError(f"unsupported input type: '{str(type(pyobj))}'")
        return wrapper
    def __dealloc__(self):
        # Release the buffer handle
        if self._py_buffer_acquired is True:
            cpython.buffer.PyBuffer_Release(&self._py_buffer)
        # De-allocate if not null and flag is set
        if self._ptr is not NULL and self.ptr_owner is True:
            stdlib.free(self._ptr)
            self._ptr = NULL
    @staticmethod
    cdef __allocate(chip.int1** ptr):
        ptr[0] = <chip.int1*>stdlib.malloc(sizeof(chip.int1))

        if ptr[0] is NULL:
            raise MemoryError
        # TODO init values, if present

    @staticmethod
    cdef int1 new():
        """Factory function to create int1 objects with
        newly allocated chip.int1"""
        cdef chip.int1* ptr
        int1.__allocate(&ptr)
        return int1.from_ptr(ptr, owner=True)
   
    def __init__(self,*args,**kwargs):
        int1.__allocate(&self._ptr)
        self.ptr_owner = True
        attribs = self.PROPERTIES()
        used_attribs = set()
        if len(args) > len(attribs):
            raise ValueError("More positional arguments specified than this type has properties.")
        for i,v in enumerate(args):
            setattr(self,attribs[i],v)
            used_attribs.add(attribs[i])
        valid_names = ", ".join(["'"+p+"'" for p in attribs])
        for k,v in kwargs.items():
            if k in used_attribs:
                raise KeyError(f"argument '{k}' has already been specified as positional argument.")
            elif k not in attribs:
                raise KeyError(f"'{k}' is no valid property name. Valid names: {valid_names}")
            setattr(self,k,v)
    
    def __int__(self):
        """Returns the data's address as long integer."""
        return cpython.long.PyLong_FromVoidPtr(self._ptr)
    def __repr__(self):
        return f"<int1 object, self.ptr={int(self)}>"
    def as_c_void_p(self):
        """Returns the data's address as `ctypes.c_void_p`"""
        return ctypes.c_void_p(int(self))
    def get_x(self, i):
        """Get value ``x`` of ``self._ptr[i]``.
        """
        return self._ptr[i].x
    def set_x(self, i, int value):
        """Set value ``x`` of ``self._ptr[i]``.
        """
        self._ptr[i].x = value
    @property
    def x(self):
        return self.get_x(0)
    @x.setter
    def x(self, int value):
        self.set_x(0,value)

    @staticmethod
    def PROPERTIES():
        return ["x"]

    def __contains__(self,item):
        properties = self.PROPERTIES()
        return item in properties

    def __getitem__(self,item):
        properties = self.PROPERTIES()
        if isinstance(item,int):
            if item < 0 or item >= len(properties):
                raise IndexError()
            return getattr(self,properties[item])
        raise ValueError("'item' type must be 'int'")


cdef class int2:
    # members declared in pxd file

    def __cinit__(self):
        self._ptr = NULL
        self.ptr_owner = False
        self._py_buffer_acquired = False

    @staticmethod
    cdef int2 from_ptr(chip.int2* ptr, bint owner=False):
        """Factory function to create ``int2`` objects from
        given ``chip.int2`` pointer.

        Setting ``owner`` flag to ``True`` causes
        the extension type to ``free`` the structure pointed to by ``ptr``
        when the wrapper object is deallocated.
        """
        # Fast call to __new__() that bypasses the __init__() constructor.
        cdef int2 wrapper = int2.__new__(int2)
        wrapper._ptr = ptr
        wrapper.ptr_owner = owner
        return wrapper

    @staticmethod
    cdef int2 from_pyobj(object pyobj):
        """Derives a int2 from a Python object.

        Derives a int2 from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``int2`` reference, this method
        returns it directly. No new ``int2`` is created in this case.

        Args:
            pyobj (object): Must be either ``None``, a simple, contiguous buffer according to the buffer protocol,
                            or of type ``int2``, ``int``, or ``ctypes.c_void_p``

        Note:
            This routine does not perform a copy but returns the original ``pyobj``
            if ``pyobj`` is an instance of int2!
        """
        cdef int2 wrapper = int2.__new__(int2)
        cdef dict cuda_array_interface = getattr(pyobj, "__cuda_array_interface__", None)

        if pyobj is None:
            wrapper._ptr = NULL
        elif isinstance(pyobj,int2):
            return pyobj
        elif isinstance(pyobj,int):
            wrapper._ptr = <chip.int2*>cpython.long.PyLong_AsVoidPtr(pyobj)
        elif isinstance(pyobj,ctypes.c_void_p):
            wrapper._ptr = <chip.int2*>cpython.long.PyLong_AsVoidPtr(pyobj.value) if pyobj.value != None else NULL
        elif cuda_array_interface != None:
            if not "data" in cuda_array_interface:
                raise ValueError("input object has '__cuda_array_interface__' attribute but the dict has no 'data' key")
            ptr_as_int = cuda_array_interface["data"][0]
            wrapper._ptr = <chip.int2*>cpython.long.PyLong_AsVoidPtr(ptr_as_int)
        elif cpython.buffer.PyObject_CheckBuffer(pyobj):
            err = cpython.buffer.PyObject_GetBuffer( 
                pyobj,
                &wrapper._py_buffer, 
                cpython.buffer.PyBUF_SIMPLE | cpython.buffer.PyBUF_ANY_CONTIGUOUS
            )
            if err == -1:
                raise RuntimeError("failed to create simple, contiguous Py_buffer from Python object")
            wrapper._py_buffer_acquired = True
            wrapper._ptr = <chip.int2*>wrapper._py_buffer.buf
        else:
            raise TypeError(f"unsupported input type: '{str(type(pyobj))}'")
        return wrapper
    def __dealloc__(self):
        # Release the buffer handle
        if self._py_buffer_acquired is True:
            cpython.buffer.PyBuffer_Release(&self._py_buffer)
        # De-allocate if not null and flag is set
        if self._ptr is not NULL and self.ptr_owner is True:
            stdlib.free(self._ptr)
            self._ptr = NULL
    @staticmethod
    cdef __allocate(chip.int2** ptr):
        ptr[0] = <chip.int2*>stdlib.malloc(sizeof(chip.int2))

        if ptr[0] is NULL:
            raise MemoryError
        # TODO init values, if present

    @staticmethod
    cdef int2 new():
        """Factory function to create int2 objects with
        newly allocated chip.int2"""
        cdef chip.int2* ptr
        int2.__allocate(&ptr)
        return int2.from_ptr(ptr, owner=True)
   
    def __init__(self,*args,**kwargs):
        int2.__allocate(&self._ptr)
        self.ptr_owner = True
        attribs = self.PROPERTIES()
        used_attribs = set()
        if len(args) > len(attribs):
            raise ValueError("More positional arguments specified than this type has properties.")
        for i,v in enumerate(args):
            setattr(self,attribs[i],v)
            used_attribs.add(attribs[i])
        valid_names = ", ".join(["'"+p+"'" for p in attribs])
        for k,v in kwargs.items():
            if k in used_attribs:
                raise KeyError(f"argument '{k}' has already been specified as positional argument.")
            elif k not in attribs:
                raise KeyError(f"'{k}' is no valid property name. Valid names: {valid_names}")
            setattr(self,k,v)
    
    def __int__(self):
        """Returns the data's address as long integer."""
        return cpython.long.PyLong_FromVoidPtr(self._ptr)
    def __repr__(self):
        return f"<int2 object, self.ptr={int(self)}>"
    def as_c_void_p(self):
        """Returns the data's address as `ctypes.c_void_p`"""
        return ctypes.c_void_p(int(self))
    def get_x(self, i):
        """Get value ``x`` of ``self._ptr[i]``.
        """
        return self._ptr[i].x
    def set_x(self, i, int value):
        """Set value ``x`` of ``self._ptr[i]``.
        """
        self._ptr[i].x = value
    @property
    def x(self):
        return self.get_x(0)
    @x.setter
    def x(self, int value):
        self.set_x(0,value)

    def get_y(self, i):
        """Get value ``y`` of ``self._ptr[i]``.
        """
        return self._ptr[i].y
    def set_y(self, i, int value):
        """Set value ``y`` of ``self._ptr[i]``.
        """
        self._ptr[i].y = value
    @property
    def y(self):
        return self.get_y(0)
    @y.setter
    def y(self, int value):
        self.set_y(0,value)

    @staticmethod
    def PROPERTIES():
        return ["x","y"]

    def __contains__(self,item):
        properties = self.PROPERTIES()
        return item in properties

    def __getitem__(self,item):
        properties = self.PROPERTIES()
        if isinstance(item,int):
            if item < 0 or item >= len(properties):
                raise IndexError()
            return getattr(self,properties[item])
        raise ValueError("'item' type must be 'int'")


cdef class int3:
    # members declared in pxd file

    def __cinit__(self):
        self._ptr = NULL
        self.ptr_owner = False
        self._py_buffer_acquired = False

    @staticmethod
    cdef int3 from_ptr(chip.int3* ptr, bint owner=False):
        """Factory function to create ``int3`` objects from
        given ``chip.int3`` pointer.

        Setting ``owner`` flag to ``True`` causes
        the extension type to ``free`` the structure pointed to by ``ptr``
        when the wrapper object is deallocated.
        """
        # Fast call to __new__() that bypasses the __init__() constructor.
        cdef int3 wrapper = int3.__new__(int3)
        wrapper._ptr = ptr
        wrapper.ptr_owner = owner
        return wrapper

    @staticmethod
    cdef int3 from_pyobj(object pyobj):
        """Derives a int3 from a Python object.

        Derives a int3 from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``int3`` reference, this method
        returns it directly. No new ``int3`` is created in this case.

        Args:
            pyobj (object): Must be either ``None``, a simple, contiguous buffer according to the buffer protocol,
                            or of type ``int3``, ``int``, or ``ctypes.c_void_p``

        Note:
            This routine does not perform a copy but returns the original ``pyobj``
            if ``pyobj`` is an instance of int3!
        """
        cdef int3 wrapper = int3.__new__(int3)
        cdef dict cuda_array_interface = getattr(pyobj, "__cuda_array_interface__", None)

        if pyobj is None:
            wrapper._ptr = NULL
        elif isinstance(pyobj,int3):
            return pyobj
        elif isinstance(pyobj,int):
            wrapper._ptr = <chip.int3*>cpython.long.PyLong_AsVoidPtr(pyobj)
        elif isinstance(pyobj,ctypes.c_void_p):
            wrapper._ptr = <chip.int3*>cpython.long.PyLong_AsVoidPtr(pyobj.value) if pyobj.value != None else NULL
        elif cuda_array_interface != None:
            if not "data" in cuda_array_interface:
                raise ValueError("input object has '__cuda_array_interface__' attribute but the dict has no 'data' key")
            ptr_as_int = cuda_array_interface["data"][0]
            wrapper._ptr = <chip.int3*>cpython.long.PyLong_AsVoidPtr(ptr_as_int)
        elif cpython.buffer.PyObject_CheckBuffer(pyobj):
            err = cpython.buffer.PyObject_GetBuffer( 
                pyobj,
                &wrapper._py_buffer, 
                cpython.buffer.PyBUF_SIMPLE | cpython.buffer.PyBUF_ANY_CONTIGUOUS
            )
            if err == -1:
                raise RuntimeError("failed to create simple, contiguous Py_buffer from Python object")
            wrapper._py_buffer_acquired = True
            wrapper._ptr = <chip.int3*>wrapper._py_buffer.buf
        else:
            raise TypeError(f"unsupported input type: '{str(type(pyobj))}'")
        return wrapper
    def __dealloc__(self):
        # Release the buffer handle
        if self._py_buffer_acquired is True:
            cpython.buffer.PyBuffer_Release(&self._py_buffer)
        # De-allocate if not null and flag is set
        if self._ptr is not NULL and self.ptr_owner is True:
            stdlib.free(self._ptr)
            self._ptr = NULL
    @staticmethod
    cdef __allocate(chip.int3** ptr):
        ptr[0] = <chip.int3*>stdlib.malloc(sizeof(chip.int3))

        if ptr[0] is NULL:
            raise MemoryError
        # TODO init values, if present

    @staticmethod
    cdef int3 new():
        """Factory function to create int3 objects with
        newly allocated chip.int3"""
        cdef chip.int3* ptr
        int3.__allocate(&ptr)
        return int3.from_ptr(ptr, owner=True)
   
    def __init__(self,*args,**kwargs):
        int3.__allocate(&self._ptr)
        self.ptr_owner = True
        attribs = self.PROPERTIES()
        used_attribs = set()
        if len(args) > len(attribs):
            raise ValueError("More positional arguments specified than this type has properties.")
        for i,v in enumerate(args):
            setattr(self,attribs[i],v)
            used_attribs.add(attribs[i])
        valid_names = ", ".join(["'"+p+"'" for p in attribs])
        for k,v in kwargs.items():
            if k in used_attribs:
                raise KeyError(f"argument '{k}' has already been specified as positional argument.")
            elif k not in attribs:
                raise KeyError(f"'{k}' is no valid property name. Valid names: {valid_names}")
            setattr(self,k,v)
    
    def __int__(self):
        """Returns the data's address as long integer."""
        return cpython.long.PyLong_FromVoidPtr(self._ptr)
    def __repr__(self):
        return f"<int3 object, self.ptr={int(self)}>"
    def as_c_void_p(self):
        """Returns the data's address as `ctypes.c_void_p`"""
        return ctypes.c_void_p(int(self))
    def get_x(self, i):
        """Get value ``x`` of ``self._ptr[i]``.
        """
        return self._ptr[i].x
    def set_x(self, i, int value):
        """Set value ``x`` of ``self._ptr[i]``.
        """
        self._ptr[i].x = value
    @property
    def x(self):
        return self.get_x(0)
    @x.setter
    def x(self, int value):
        self.set_x(0,value)

    def get_y(self, i):
        """Get value ``y`` of ``self._ptr[i]``.
        """
        return self._ptr[i].y
    def set_y(self, i, int value):
        """Set value ``y`` of ``self._ptr[i]``.
        """
        self._ptr[i].y = value
    @property
    def y(self):
        return self.get_y(0)
    @y.setter
    def y(self, int value):
        self.set_y(0,value)

    def get_z(self, i):
        """Get value ``z`` of ``self._ptr[i]``.
        """
        return self._ptr[i].z
    def set_z(self, i, int value):
        """Set value ``z`` of ``self._ptr[i]``.
        """
        self._ptr[i].z = value
    @property
    def z(self):
        return self.get_z(0)
    @z.setter
    def z(self, int value):
        self.set_z(0,value)

    @staticmethod
    def PROPERTIES():
        return ["x","y","z"]

    def __contains__(self,item):
        properties = self.PROPERTIES()
        return item in properties

    def __getitem__(self,item):
        properties = self.PROPERTIES()
        if isinstance(item,int):
            if item < 0 or item >= len(properties):
                raise IndexError()
            return getattr(self,properties[item])
        raise ValueError("'item' type must be 'int'")


cdef class int4:
    # members declared in pxd file

    def __cinit__(self):
        self._ptr = NULL
        self.ptr_owner = False
        self._py_buffer_acquired = False

    @staticmethod
    cdef int4 from_ptr(chip.int4* ptr, bint owner=False):
        """Factory function to create ``int4`` objects from
        given ``chip.int4`` pointer.

        Setting ``owner`` flag to ``True`` causes
        the extension type to ``free`` the structure pointed to by ``ptr``
        when the wrapper object is deallocated.
        """
        # Fast call to __new__() that bypasses the __init__() constructor.
        cdef int4 wrapper = int4.__new__(int4)
        wrapper._ptr = ptr
        wrapper.ptr_owner = owner
        return wrapper

    @staticmethod
    cdef int4 from_pyobj(object pyobj):
        """Derives a int4 from a Python object.

        Derives a int4 from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``int4`` reference, this method
        returns it directly. No new ``int4`` is created in this case.

        Args:
            pyobj (object): Must be either ``None``, a simple, contiguous buffer according to the buffer protocol,
                            or of type ``int4``, ``int``, or ``ctypes.c_void_p``

        Note:
            This routine does not perform a copy but returns the original ``pyobj``
            if ``pyobj`` is an instance of int4!
        """
        cdef int4 wrapper = int4.__new__(int4)
        cdef dict cuda_array_interface = getattr(pyobj, "__cuda_array_interface__", None)

        if pyobj is None:
            wrapper._ptr = NULL
        elif isinstance(pyobj,int4):
            return pyobj
        elif isinstance(pyobj,int):
            wrapper._ptr = <chip.int4*>cpython.long.PyLong_AsVoidPtr(pyobj)
        elif isinstance(pyobj,ctypes.c_void_p):
            wrapper._ptr = <chip.int4*>cpython.long.PyLong_AsVoidPtr(pyobj.value) if pyobj.value != None else NULL
        elif cuda_array_interface != None:
            if not "data" in cuda_array_interface:
                raise ValueError("input object has '__cuda_array_interface__' attribute but the dict has no 'data' key")
            ptr_as_int = cuda_array_interface["data"][0]
            wrapper._ptr = <chip.int4*>cpython.long.PyLong_AsVoidPtr(ptr_as_int)
        elif cpython.buffer.PyObject_CheckBuffer(pyobj):
            err = cpython.buffer.PyObject_GetBuffer( 
                pyobj,
                &wrapper._py_buffer, 
                cpython.buffer.PyBUF_SIMPLE | cpython.buffer.PyBUF_ANY_CONTIGUOUS
            )
            if err == -1:
                raise RuntimeError("failed to create simple, contiguous Py_buffer from Python object")
            wrapper._py_buffer_acquired = True
            wrapper._ptr = <chip.int4*>wrapper._py_buffer.buf
        else:
            raise TypeError(f"unsupported input type: '{str(type(pyobj))}'")
        return wrapper
    def __dealloc__(self):
        # Release the buffer handle
        if self._py_buffer_acquired is True:
            cpython.buffer.PyBuffer_Release(&self._py_buffer)
        # De-allocate if not null and flag is set
        if self._ptr is not NULL and self.ptr_owner is True:
            stdlib.free(self._ptr)
            self._ptr = NULL
    @staticmethod
    cdef __allocate(chip.int4** ptr):
        ptr[0] = <chip.int4*>stdlib.malloc(sizeof(chip.int4))

        if ptr[0] is NULL:
            raise MemoryError
        # TODO init values, if present

    @staticmethod
    cdef int4 new():
        """Factory function to create int4 objects with
        newly allocated chip.int4"""
        cdef chip.int4* ptr
        int4.__allocate(&ptr)
        return int4.from_ptr(ptr, owner=True)
   
    def __init__(self,*args,**kwargs):
        int4.__allocate(&self._ptr)
        self.ptr_owner = True
        attribs = self.PROPERTIES()
        used_attribs = set()
        if len(args) > len(attribs):
            raise ValueError("More positional arguments specified than this type has properties.")
        for i,v in enumerate(args):
            setattr(self,attribs[i],v)
            used_attribs.add(attribs[i])
        valid_names = ", ".join(["'"+p+"'" for p in attribs])
        for k,v in kwargs.items():
            if k in used_attribs:
                raise KeyError(f"argument '{k}' has already been specified as positional argument.")
            elif k not in attribs:
                raise KeyError(f"'{k}' is no valid property name. Valid names: {valid_names}")
            setattr(self,k,v)
    
    def __int__(self):
        """Returns the data's address as long integer."""
        return cpython.long.PyLong_FromVoidPtr(self._ptr)
    def __repr__(self):
        return f"<int4 object, self.ptr={int(self)}>"
    def as_c_void_p(self):
        """Returns the data's address as `ctypes.c_void_p`"""
        return ctypes.c_void_p(int(self))
    def get_x(self, i):
        """Get value ``x`` of ``self._ptr[i]``.
        """
        return self._ptr[i].x
    def set_x(self, i, int value):
        """Set value ``x`` of ``self._ptr[i]``.
        """
        self._ptr[i].x = value
    @property
    def x(self):
        return self.get_x(0)
    @x.setter
    def x(self, int value):
        self.set_x(0,value)

    def get_y(self, i):
        """Get value ``y`` of ``self._ptr[i]``.
        """
        return self._ptr[i].y
    def set_y(self, i, int value):
        """Set value ``y`` of ``self._ptr[i]``.
        """
        self._ptr[i].y = value
    @property
    def y(self):
        return self.get_y(0)
    @y.setter
    def y(self, int value):
        self.set_y(0,value)

    def get_z(self, i):
        """Get value ``z`` of ``self._ptr[i]``.
        """
        return self._ptr[i].z
    def set_z(self, i, int value):
        """Set value ``z`` of ``self._ptr[i]``.
        """
        self._ptr[i].z = value
    @property
    def z(self):
        return self.get_z(0)
    @z.setter
    def z(self, int value):
        self.set_z(0,value)

    def get_w(self, i):
        """Get value ``w`` of ``self._ptr[i]``.
        """
        return self._ptr[i].w
    def set_w(self, i, int value):
        """Set value ``w`` of ``self._ptr[i]``.
        """
        self._ptr[i].w = value
    @property
    def w(self):
        return self.get_w(0)
    @w.setter
    def w(self, int value):
        self.set_w(0,value)

    @staticmethod
    def PROPERTIES():
        return ["x","y","z","w"]

    def __contains__(self,item):
        properties = self.PROPERTIES()
        return item in properties

    def __getitem__(self,item):
        properties = self.PROPERTIES()
        if isinstance(item,int):
            if item < 0 or item >= len(properties):
                raise IndexError()
            return getattr(self,properties[item])
        raise ValueError("'item' type must be 'int'")


cdef class ulong1:
    # members declared in pxd file

    def __cinit__(self):
        self._ptr = NULL
        self.ptr_owner = False
        self._py_buffer_acquired = False

    @staticmethod
    cdef ulong1 from_ptr(chip.ulong1* ptr, bint owner=False):
        """Factory function to create ``ulong1`` objects from
        given ``chip.ulong1`` pointer.

        Setting ``owner`` flag to ``True`` causes
        the extension type to ``free`` the structure pointed to by ``ptr``
        when the wrapper object is deallocated.
        """
        # Fast call to __new__() that bypasses the __init__() constructor.
        cdef ulong1 wrapper = ulong1.__new__(ulong1)
        wrapper._ptr = ptr
        wrapper.ptr_owner = owner
        return wrapper

    @staticmethod
    cdef ulong1 from_pyobj(object pyobj):
        """Derives a ulong1 from a Python object.

        Derives a ulong1 from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``ulong1`` reference, this method
        returns it directly. No new ``ulong1`` is created in this case.

        Args:
            pyobj (object): Must be either ``None``, a simple, contiguous buffer according to the buffer protocol,
                            or of type ``ulong1``, ``int``, or ``ctypes.c_void_p``

        Note:
            This routine does not perform a copy but returns the original ``pyobj``
            if ``pyobj`` is an instance of ulong1!
        """
        cdef ulong1 wrapper = ulong1.__new__(ulong1)
        cdef dict cuda_array_interface = getattr(pyobj, "__cuda_array_interface__", None)

        if pyobj is None:
            wrapper._ptr = NULL
        elif isinstance(pyobj,ulong1):
            return pyobj
        elif isinstance(pyobj,int):
            wrapper._ptr = <chip.ulong1*>cpython.long.PyLong_AsVoidPtr(pyobj)
        elif isinstance(pyobj,ctypes.c_void_p):
            wrapper._ptr = <chip.ulong1*>cpython.long.PyLong_AsVoidPtr(pyobj.value) if pyobj.value != None else NULL
        elif cuda_array_interface != None:
            if not "data" in cuda_array_interface:
                raise ValueError("input object has '__cuda_array_interface__' attribute but the dict has no 'data' key")
            ptr_as_int = cuda_array_interface["data"][0]
            wrapper._ptr = <chip.ulong1*>cpython.long.PyLong_AsVoidPtr(ptr_as_int)
        elif cpython.buffer.PyObject_CheckBuffer(pyobj):
            err = cpython.buffer.PyObject_GetBuffer( 
                pyobj,
                &wrapper._py_buffer, 
                cpython.buffer.PyBUF_SIMPLE | cpython.buffer.PyBUF_ANY_CONTIGUOUS
            )
            if err == -1:
                raise RuntimeError("failed to create simple, contiguous Py_buffer from Python object")
            wrapper._py_buffer_acquired = True
            wrapper._ptr = <chip.ulong1*>wrapper._py_buffer.buf
        else:
            raise TypeError(f"unsupported input type: '{str(type(pyobj))}'")
        return wrapper
    def __dealloc__(self):
        # Release the buffer handle
        if self._py_buffer_acquired is True:
            cpython.buffer.PyBuffer_Release(&self._py_buffer)
        # De-allocate if not null and flag is set
        if self._ptr is not NULL and self.ptr_owner is True:
            stdlib.free(self._ptr)
            self._ptr = NULL
    @staticmethod
    cdef __allocate(chip.ulong1** ptr):
        ptr[0] = <chip.ulong1*>stdlib.malloc(sizeof(chip.ulong1))

        if ptr[0] is NULL:
            raise MemoryError
        # TODO init values, if present

    @staticmethod
    cdef ulong1 new():
        """Factory function to create ulong1 objects with
        newly allocated chip.ulong1"""
        cdef chip.ulong1* ptr
        ulong1.__allocate(&ptr)
        return ulong1.from_ptr(ptr, owner=True)
   
    def __init__(self,*args,**kwargs):
        ulong1.__allocate(&self._ptr)
        self.ptr_owner = True
        attribs = self.PROPERTIES()
        used_attribs = set()
        if len(args) > len(attribs):
            raise ValueError("More positional arguments specified than this type has properties.")
        for i,v in enumerate(args):
            setattr(self,attribs[i],v)
            used_attribs.add(attribs[i])
        valid_names = ", ".join(["'"+p+"'" for p in attribs])
        for k,v in kwargs.items():
            if k in used_attribs:
                raise KeyError(f"argument '{k}' has already been specified as positional argument.")
            elif k not in attribs:
                raise KeyError(f"'{k}' is no valid property name. Valid names: {valid_names}")
            setattr(self,k,v)
    
    def __int__(self):
        """Returns the data's address as long integer."""
        return cpython.long.PyLong_FromVoidPtr(self._ptr)
    def __repr__(self):
        return f"<ulong1 object, self.ptr={int(self)}>"
    def as_c_void_p(self):
        """Returns the data's address as `ctypes.c_void_p`"""
        return ctypes.c_void_p(int(self))
    def get_x(self, i):
        """Get value ``x`` of ``self._ptr[i]``.
        """
        return self._ptr[i].x
    def set_x(self, i, unsigned long value):
        """Set value ``x`` of ``self._ptr[i]``.
        """
        self._ptr[i].x = value
    @property
    def x(self):
        return self.get_x(0)
    @x.setter
    def x(self, unsigned long value):
        self.set_x(0,value)

    @staticmethod
    def PROPERTIES():
        return ["x"]

    def __contains__(self,item):
        properties = self.PROPERTIES()
        return item in properties

    def __getitem__(self,item):
        properties = self.PROPERTIES()
        if isinstance(item,int):
            if item < 0 or item >= len(properties):
                raise IndexError()
            return getattr(self,properties[item])
        raise ValueError("'item' type must be 'int'")


cdef class ulong2:
    # members declared in pxd file

    def __cinit__(self):
        self._ptr = NULL
        self.ptr_owner = False
        self._py_buffer_acquired = False

    @staticmethod
    cdef ulong2 from_ptr(chip.ulong2* ptr, bint owner=False):
        """Factory function to create ``ulong2`` objects from
        given ``chip.ulong2`` pointer.

        Setting ``owner`` flag to ``True`` causes
        the extension type to ``free`` the structure pointed to by ``ptr``
        when the wrapper object is deallocated.
        """
        # Fast call to __new__() that bypasses the __init__() constructor.
        cdef ulong2 wrapper = ulong2.__new__(ulong2)
        wrapper._ptr = ptr
        wrapper.ptr_owner = owner
        return wrapper

    @staticmethod
    cdef ulong2 from_pyobj(object pyobj):
        """Derives a ulong2 from a Python object.

        Derives a ulong2 from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``ulong2`` reference, this method
        returns it directly. No new ``ulong2`` is created in this case.

        Args:
            pyobj (object): Must be either ``None``, a simple, contiguous buffer according to the buffer protocol,
                            or of type ``ulong2``, ``int``, or ``ctypes.c_void_p``

        Note:
            This routine does not perform a copy but returns the original ``pyobj``
            if ``pyobj`` is an instance of ulong2!
        """
        cdef ulong2 wrapper = ulong2.__new__(ulong2)
        cdef dict cuda_array_interface = getattr(pyobj, "__cuda_array_interface__", None)

        if pyobj is None:
            wrapper._ptr = NULL
        elif isinstance(pyobj,ulong2):
            return pyobj
        elif isinstance(pyobj,int):
            wrapper._ptr = <chip.ulong2*>cpython.long.PyLong_AsVoidPtr(pyobj)
        elif isinstance(pyobj,ctypes.c_void_p):
            wrapper._ptr = <chip.ulong2*>cpython.long.PyLong_AsVoidPtr(pyobj.value) if pyobj.value != None else NULL
        elif cuda_array_interface != None:
            if not "data" in cuda_array_interface:
                raise ValueError("input object has '__cuda_array_interface__' attribute but the dict has no 'data' key")
            ptr_as_int = cuda_array_interface["data"][0]
            wrapper._ptr = <chip.ulong2*>cpython.long.PyLong_AsVoidPtr(ptr_as_int)
        elif cpython.buffer.PyObject_CheckBuffer(pyobj):
            err = cpython.buffer.PyObject_GetBuffer( 
                pyobj,
                &wrapper._py_buffer, 
                cpython.buffer.PyBUF_SIMPLE | cpython.buffer.PyBUF_ANY_CONTIGUOUS
            )
            if err == -1:
                raise RuntimeError("failed to create simple, contiguous Py_buffer from Python object")
            wrapper._py_buffer_acquired = True
            wrapper._ptr = <chip.ulong2*>wrapper._py_buffer.buf
        else:
            raise TypeError(f"unsupported input type: '{str(type(pyobj))}'")
        return wrapper
    def __dealloc__(self):
        # Release the buffer handle
        if self._py_buffer_acquired is True:
            cpython.buffer.PyBuffer_Release(&self._py_buffer)
        # De-allocate if not null and flag is set
        if self._ptr is not NULL and self.ptr_owner is True:
            stdlib.free(self._ptr)
            self._ptr = NULL
    @staticmethod
    cdef __allocate(chip.ulong2** ptr):
        ptr[0] = <chip.ulong2*>stdlib.malloc(sizeof(chip.ulong2))

        if ptr[0] is NULL:
            raise MemoryError
        # TODO init values, if present

    @staticmethod
    cdef ulong2 new():
        """Factory function to create ulong2 objects with
        newly allocated chip.ulong2"""
        cdef chip.ulong2* ptr
        ulong2.__allocate(&ptr)
        return ulong2.from_ptr(ptr, owner=True)
   
    def __init__(self,*args,**kwargs):
        ulong2.__allocate(&self._ptr)
        self.ptr_owner = True
        attribs = self.PROPERTIES()
        used_attribs = set()
        if len(args) > len(attribs):
            raise ValueError("More positional arguments specified than this type has properties.")
        for i,v in enumerate(args):
            setattr(self,attribs[i],v)
            used_attribs.add(attribs[i])
        valid_names = ", ".join(["'"+p+"'" for p in attribs])
        for k,v in kwargs.items():
            if k in used_attribs:
                raise KeyError(f"argument '{k}' has already been specified as positional argument.")
            elif k not in attribs:
                raise KeyError(f"'{k}' is no valid property name. Valid names: {valid_names}")
            setattr(self,k,v)
    
    def __int__(self):
        """Returns the data's address as long integer."""
        return cpython.long.PyLong_FromVoidPtr(self._ptr)
    def __repr__(self):
        return f"<ulong2 object, self.ptr={int(self)}>"
    def as_c_void_p(self):
        """Returns the data's address as `ctypes.c_void_p`"""
        return ctypes.c_void_p(int(self))
    def get_x(self, i):
        """Get value ``x`` of ``self._ptr[i]``.
        """
        return self._ptr[i].x
    def set_x(self, i, unsigned long value):
        """Set value ``x`` of ``self._ptr[i]``.
        """
        self._ptr[i].x = value
    @property
    def x(self):
        return self.get_x(0)
    @x.setter
    def x(self, unsigned long value):
        self.set_x(0,value)

    def get_y(self, i):
        """Get value ``y`` of ``self._ptr[i]``.
        """
        return self._ptr[i].y
    def set_y(self, i, unsigned long value):
        """Set value ``y`` of ``self._ptr[i]``.
        """
        self._ptr[i].y = value
    @property
    def y(self):
        return self.get_y(0)
    @y.setter
    def y(self, unsigned long value):
        self.set_y(0,value)

    @staticmethod
    def PROPERTIES():
        return ["x","y"]

    def __contains__(self,item):
        properties = self.PROPERTIES()
        return item in properties

    def __getitem__(self,item):
        properties = self.PROPERTIES()
        if isinstance(item,int):
            if item < 0 or item >= len(properties):
                raise IndexError()
            return getattr(self,properties[item])
        raise ValueError("'item' type must be 'int'")


cdef class ulong3:
    # members declared in pxd file

    def __cinit__(self):
        self._ptr = NULL
        self.ptr_owner = False
        self._py_buffer_acquired = False

    @staticmethod
    cdef ulong3 from_ptr(chip.ulong3* ptr, bint owner=False):
        """Factory function to create ``ulong3`` objects from
        given ``chip.ulong3`` pointer.

        Setting ``owner`` flag to ``True`` causes
        the extension type to ``free`` the structure pointed to by ``ptr``
        when the wrapper object is deallocated.
        """
        # Fast call to __new__() that bypasses the __init__() constructor.
        cdef ulong3 wrapper = ulong3.__new__(ulong3)
        wrapper._ptr = ptr
        wrapper.ptr_owner = owner
        return wrapper

    @staticmethod
    cdef ulong3 from_pyobj(object pyobj):
        """Derives a ulong3 from a Python object.

        Derives a ulong3 from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``ulong3`` reference, this method
        returns it directly. No new ``ulong3`` is created in this case.

        Args:
            pyobj (object): Must be either ``None``, a simple, contiguous buffer according to the buffer protocol,
                            or of type ``ulong3``, ``int``, or ``ctypes.c_void_p``

        Note:
            This routine does not perform a copy but returns the original ``pyobj``
            if ``pyobj`` is an instance of ulong3!
        """
        cdef ulong3 wrapper = ulong3.__new__(ulong3)
        cdef dict cuda_array_interface = getattr(pyobj, "__cuda_array_interface__", None)

        if pyobj is None:
            wrapper._ptr = NULL
        elif isinstance(pyobj,ulong3):
            return pyobj
        elif isinstance(pyobj,int):
            wrapper._ptr = <chip.ulong3*>cpython.long.PyLong_AsVoidPtr(pyobj)
        elif isinstance(pyobj,ctypes.c_void_p):
            wrapper._ptr = <chip.ulong3*>cpython.long.PyLong_AsVoidPtr(pyobj.value) if pyobj.value != None else NULL
        elif cuda_array_interface != None:
            if not "data" in cuda_array_interface:
                raise ValueError("input object has '__cuda_array_interface__' attribute but the dict has no 'data' key")
            ptr_as_int = cuda_array_interface["data"][0]
            wrapper._ptr = <chip.ulong3*>cpython.long.PyLong_AsVoidPtr(ptr_as_int)
        elif cpython.buffer.PyObject_CheckBuffer(pyobj):
            err = cpython.buffer.PyObject_GetBuffer( 
                pyobj,
                &wrapper._py_buffer, 
                cpython.buffer.PyBUF_SIMPLE | cpython.buffer.PyBUF_ANY_CONTIGUOUS
            )
            if err == -1:
                raise RuntimeError("failed to create simple, contiguous Py_buffer from Python object")
            wrapper._py_buffer_acquired = True
            wrapper._ptr = <chip.ulong3*>wrapper._py_buffer.buf
        else:
            raise TypeError(f"unsupported input type: '{str(type(pyobj))}'")
        return wrapper
    def __dealloc__(self):
        # Release the buffer handle
        if self._py_buffer_acquired is True:
            cpython.buffer.PyBuffer_Release(&self._py_buffer)
        # De-allocate if not null and flag is set
        if self._ptr is not NULL and self.ptr_owner is True:
            stdlib.free(self._ptr)
            self._ptr = NULL
    @staticmethod
    cdef __allocate(chip.ulong3** ptr):
        ptr[0] = <chip.ulong3*>stdlib.malloc(sizeof(chip.ulong3))

        if ptr[0] is NULL:
            raise MemoryError
        # TODO init values, if present

    @staticmethod
    cdef ulong3 new():
        """Factory function to create ulong3 objects with
        newly allocated chip.ulong3"""
        cdef chip.ulong3* ptr
        ulong3.__allocate(&ptr)
        return ulong3.from_ptr(ptr, owner=True)
   
    def __init__(self,*args,**kwargs):
        ulong3.__allocate(&self._ptr)
        self.ptr_owner = True
        attribs = self.PROPERTIES()
        used_attribs = set()
        if len(args) > len(attribs):
            raise ValueError("More positional arguments specified than this type has properties.")
        for i,v in enumerate(args):
            setattr(self,attribs[i],v)
            used_attribs.add(attribs[i])
        valid_names = ", ".join(["'"+p+"'" for p in attribs])
        for k,v in kwargs.items():
            if k in used_attribs:
                raise KeyError(f"argument '{k}' has already been specified as positional argument.")
            elif k not in attribs:
                raise KeyError(f"'{k}' is no valid property name. Valid names: {valid_names}")
            setattr(self,k,v)
    
    def __int__(self):
        """Returns the data's address as long integer."""
        return cpython.long.PyLong_FromVoidPtr(self._ptr)
    def __repr__(self):
        return f"<ulong3 object, self.ptr={int(self)}>"
    def as_c_void_p(self):
        """Returns the data's address as `ctypes.c_void_p`"""
        return ctypes.c_void_p(int(self))
    def get_x(self, i):
        """Get value ``x`` of ``self._ptr[i]``.
        """
        return self._ptr[i].x
    def set_x(self, i, unsigned long value):
        """Set value ``x`` of ``self._ptr[i]``.
        """
        self._ptr[i].x = value
    @property
    def x(self):
        return self.get_x(0)
    @x.setter
    def x(self, unsigned long value):
        self.set_x(0,value)

    def get_y(self, i):
        """Get value ``y`` of ``self._ptr[i]``.
        """
        return self._ptr[i].y
    def set_y(self, i, unsigned long value):
        """Set value ``y`` of ``self._ptr[i]``.
        """
        self._ptr[i].y = value
    @property
    def y(self):
        return self.get_y(0)
    @y.setter
    def y(self, unsigned long value):
        self.set_y(0,value)

    def get_z(self, i):
        """Get value ``z`` of ``self._ptr[i]``.
        """
        return self._ptr[i].z
    def set_z(self, i, unsigned long value):
        """Set value ``z`` of ``self._ptr[i]``.
        """
        self._ptr[i].z = value
    @property
    def z(self):
        return self.get_z(0)
    @z.setter
    def z(self, unsigned long value):
        self.set_z(0,value)

    @staticmethod
    def PROPERTIES():
        return ["x","y","z"]

    def __contains__(self,item):
        properties = self.PROPERTIES()
        return item in properties

    def __getitem__(self,item):
        properties = self.PROPERTIES()
        if isinstance(item,int):
            if item < 0 or item >= len(properties):
                raise IndexError()
            return getattr(self,properties[item])
        raise ValueError("'item' type must be 'int'")


cdef class ulong4:
    # members declared in pxd file

    def __cinit__(self):
        self._ptr = NULL
        self.ptr_owner = False
        self._py_buffer_acquired = False

    @staticmethod
    cdef ulong4 from_ptr(chip.ulong4* ptr, bint owner=False):
        """Factory function to create ``ulong4`` objects from
        given ``chip.ulong4`` pointer.

        Setting ``owner`` flag to ``True`` causes
        the extension type to ``free`` the structure pointed to by ``ptr``
        when the wrapper object is deallocated.
        """
        # Fast call to __new__() that bypasses the __init__() constructor.
        cdef ulong4 wrapper = ulong4.__new__(ulong4)
        wrapper._ptr = ptr
        wrapper.ptr_owner = owner
        return wrapper

    @staticmethod
    cdef ulong4 from_pyobj(object pyobj):
        """Derives a ulong4 from a Python object.

        Derives a ulong4 from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``ulong4`` reference, this method
        returns it directly. No new ``ulong4`` is created in this case.

        Args:
            pyobj (object): Must be either ``None``, a simple, contiguous buffer according to the buffer protocol,
                            or of type ``ulong4``, ``int``, or ``ctypes.c_void_p``

        Note:
            This routine does not perform a copy but returns the original ``pyobj``
            if ``pyobj`` is an instance of ulong4!
        """
        cdef ulong4 wrapper = ulong4.__new__(ulong4)
        cdef dict cuda_array_interface = getattr(pyobj, "__cuda_array_interface__", None)

        if pyobj is None:
            wrapper._ptr = NULL
        elif isinstance(pyobj,ulong4):
            return pyobj
        elif isinstance(pyobj,int):
            wrapper._ptr = <chip.ulong4*>cpython.long.PyLong_AsVoidPtr(pyobj)
        elif isinstance(pyobj,ctypes.c_void_p):
            wrapper._ptr = <chip.ulong4*>cpython.long.PyLong_AsVoidPtr(pyobj.value) if pyobj.value != None else NULL
        elif cuda_array_interface != None:
            if not "data" in cuda_array_interface:
                raise ValueError("input object has '__cuda_array_interface__' attribute but the dict has no 'data' key")
            ptr_as_int = cuda_array_interface["data"][0]
            wrapper._ptr = <chip.ulong4*>cpython.long.PyLong_AsVoidPtr(ptr_as_int)
        elif cpython.buffer.PyObject_CheckBuffer(pyobj):
            err = cpython.buffer.PyObject_GetBuffer( 
                pyobj,
                &wrapper._py_buffer, 
                cpython.buffer.PyBUF_SIMPLE | cpython.buffer.PyBUF_ANY_CONTIGUOUS
            )
            if err == -1:
                raise RuntimeError("failed to create simple, contiguous Py_buffer from Python object")
            wrapper._py_buffer_acquired = True
            wrapper._ptr = <chip.ulong4*>wrapper._py_buffer.buf
        else:
            raise TypeError(f"unsupported input type: '{str(type(pyobj))}'")
        return wrapper
    def __dealloc__(self):
        # Release the buffer handle
        if self._py_buffer_acquired is True:
            cpython.buffer.PyBuffer_Release(&self._py_buffer)
        # De-allocate if not null and flag is set
        if self._ptr is not NULL and self.ptr_owner is True:
            stdlib.free(self._ptr)
            self._ptr = NULL
    @staticmethod
    cdef __allocate(chip.ulong4** ptr):
        ptr[0] = <chip.ulong4*>stdlib.malloc(sizeof(chip.ulong4))

        if ptr[0] is NULL:
            raise MemoryError
        # TODO init values, if present

    @staticmethod
    cdef ulong4 new():
        """Factory function to create ulong4 objects with
        newly allocated chip.ulong4"""
        cdef chip.ulong4* ptr
        ulong4.__allocate(&ptr)
        return ulong4.from_ptr(ptr, owner=True)
   
    def __init__(self,*args,**kwargs):
        ulong4.__allocate(&self._ptr)
        self.ptr_owner = True
        attribs = self.PROPERTIES()
        used_attribs = set()
        if len(args) > len(attribs):
            raise ValueError("More positional arguments specified than this type has properties.")
        for i,v in enumerate(args):
            setattr(self,attribs[i],v)
            used_attribs.add(attribs[i])
        valid_names = ", ".join(["'"+p+"'" for p in attribs])
        for k,v in kwargs.items():
            if k in used_attribs:
                raise KeyError(f"argument '{k}' has already been specified as positional argument.")
            elif k not in attribs:
                raise KeyError(f"'{k}' is no valid property name. Valid names: {valid_names}")
            setattr(self,k,v)
    
    def __int__(self):
        """Returns the data's address as long integer."""
        return cpython.long.PyLong_FromVoidPtr(self._ptr)
    def __repr__(self):
        return f"<ulong4 object, self.ptr={int(self)}>"
    def as_c_void_p(self):
        """Returns the data's address as `ctypes.c_void_p`"""
        return ctypes.c_void_p(int(self))
    def get_x(self, i):
        """Get value ``x`` of ``self._ptr[i]``.
        """
        return self._ptr[i].x
    def set_x(self, i, unsigned long value):
        """Set value ``x`` of ``self._ptr[i]``.
        """
        self._ptr[i].x = value
    @property
    def x(self):
        return self.get_x(0)
    @x.setter
    def x(self, unsigned long value):
        self.set_x(0,value)

    def get_y(self, i):
        """Get value ``y`` of ``self._ptr[i]``.
        """
        return self._ptr[i].y
    def set_y(self, i, unsigned long value):
        """Set value ``y`` of ``self._ptr[i]``.
        """
        self._ptr[i].y = value
    @property
    def y(self):
        return self.get_y(0)
    @y.setter
    def y(self, unsigned long value):
        self.set_y(0,value)

    def get_z(self, i):
        """Get value ``z`` of ``self._ptr[i]``.
        """
        return self._ptr[i].z
    def set_z(self, i, unsigned long value):
        """Set value ``z`` of ``self._ptr[i]``.
        """
        self._ptr[i].z = value
    @property
    def z(self):
        return self.get_z(0)
    @z.setter
    def z(self, unsigned long value):
        self.set_z(0,value)

    def get_w(self, i):
        """Get value ``w`` of ``self._ptr[i]``.
        """
        return self._ptr[i].w
    def set_w(self, i, unsigned long value):
        """Set value ``w`` of ``self._ptr[i]``.
        """
        self._ptr[i].w = value
    @property
    def w(self):
        return self.get_w(0)
    @w.setter
    def w(self, unsigned long value):
        self.set_w(0,value)

    @staticmethod
    def PROPERTIES():
        return ["x","y","z","w"]

    def __contains__(self,item):
        properties = self.PROPERTIES()
        return item in properties

    def __getitem__(self,item):
        properties = self.PROPERTIES()
        if isinstance(item,int):
            if item < 0 or item >= len(properties):
                raise IndexError()
            return getattr(self,properties[item])
        raise ValueError("'item' type must be 'int'")


cdef class long1:
    # members declared in pxd file

    def __cinit__(self):
        self._ptr = NULL
        self.ptr_owner = False
        self._py_buffer_acquired = False

    @staticmethod
    cdef long1 from_ptr(chip.long1* ptr, bint owner=False):
        """Factory function to create ``long1`` objects from
        given ``chip.long1`` pointer.

        Setting ``owner`` flag to ``True`` causes
        the extension type to ``free`` the structure pointed to by ``ptr``
        when the wrapper object is deallocated.
        """
        # Fast call to __new__() that bypasses the __init__() constructor.
        cdef long1 wrapper = long1.__new__(long1)
        wrapper._ptr = ptr
        wrapper.ptr_owner = owner
        return wrapper

    @staticmethod
    cdef long1 from_pyobj(object pyobj):
        """Derives a long1 from a Python object.

        Derives a long1 from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``long1`` reference, this method
        returns it directly. No new ``long1`` is created in this case.

        Args:
            pyobj (object): Must be either ``None``, a simple, contiguous buffer according to the buffer protocol,
                            or of type ``long1``, ``int``, or ``ctypes.c_void_p``

        Note:
            This routine does not perform a copy but returns the original ``pyobj``
            if ``pyobj`` is an instance of long1!
        """
        cdef long1 wrapper = long1.__new__(long1)
        cdef dict cuda_array_interface = getattr(pyobj, "__cuda_array_interface__", None)

        if pyobj is None:
            wrapper._ptr = NULL
        elif isinstance(pyobj,long1):
            return pyobj
        elif isinstance(pyobj,int):
            wrapper._ptr = <chip.long1*>cpython.long.PyLong_AsVoidPtr(pyobj)
        elif isinstance(pyobj,ctypes.c_void_p):
            wrapper._ptr = <chip.long1*>cpython.long.PyLong_AsVoidPtr(pyobj.value) if pyobj.value != None else NULL
        elif cuda_array_interface != None:
            if not "data" in cuda_array_interface:
                raise ValueError("input object has '__cuda_array_interface__' attribute but the dict has no 'data' key")
            ptr_as_int = cuda_array_interface["data"][0]
            wrapper._ptr = <chip.long1*>cpython.long.PyLong_AsVoidPtr(ptr_as_int)
        elif cpython.buffer.PyObject_CheckBuffer(pyobj):
            err = cpython.buffer.PyObject_GetBuffer( 
                pyobj,
                &wrapper._py_buffer, 
                cpython.buffer.PyBUF_SIMPLE | cpython.buffer.PyBUF_ANY_CONTIGUOUS
            )
            if err == -1:
                raise RuntimeError("failed to create simple, contiguous Py_buffer from Python object")
            wrapper._py_buffer_acquired = True
            wrapper._ptr = <chip.long1*>wrapper._py_buffer.buf
        else:
            raise TypeError(f"unsupported input type: '{str(type(pyobj))}'")
        return wrapper
    def __dealloc__(self):
        # Release the buffer handle
        if self._py_buffer_acquired is True:
            cpython.buffer.PyBuffer_Release(&self._py_buffer)
        # De-allocate if not null and flag is set
        if self._ptr is not NULL and self.ptr_owner is True:
            stdlib.free(self._ptr)
            self._ptr = NULL
    @staticmethod
    cdef __allocate(chip.long1** ptr):
        ptr[0] = <chip.long1*>stdlib.malloc(sizeof(chip.long1))

        if ptr[0] is NULL:
            raise MemoryError
        # TODO init values, if present

    @staticmethod
    cdef long1 new():
        """Factory function to create long1 objects with
        newly allocated chip.long1"""
        cdef chip.long1* ptr
        long1.__allocate(&ptr)
        return long1.from_ptr(ptr, owner=True)
   
    def __init__(self,*args,**kwargs):
        long1.__allocate(&self._ptr)
        self.ptr_owner = True
        attribs = self.PROPERTIES()
        used_attribs = set()
        if len(args) > len(attribs):
            raise ValueError("More positional arguments specified than this type has properties.")
        for i,v in enumerate(args):
            setattr(self,attribs[i],v)
            used_attribs.add(attribs[i])
        valid_names = ", ".join(["'"+p+"'" for p in attribs])
        for k,v in kwargs.items():
            if k in used_attribs:
                raise KeyError(f"argument '{k}' has already been specified as positional argument.")
            elif k not in attribs:
                raise KeyError(f"'{k}' is no valid property name. Valid names: {valid_names}")
            setattr(self,k,v)
    
    def __int__(self):
        """Returns the data's address as long integer."""
        return cpython.long.PyLong_FromVoidPtr(self._ptr)
    def __repr__(self):
        return f"<long1 object, self.ptr={int(self)}>"
    def as_c_void_p(self):
        """Returns the data's address as `ctypes.c_void_p`"""
        return ctypes.c_void_p(int(self))
    def get_x(self, i):
        """Get value ``x`` of ``self._ptr[i]``.
        """
        return self._ptr[i].x
    def set_x(self, i, long value):
        """Set value ``x`` of ``self._ptr[i]``.
        """
        self._ptr[i].x = value
    @property
    def x(self):
        return self.get_x(0)
    @x.setter
    def x(self, long value):
        self.set_x(0,value)

    @staticmethod
    def PROPERTIES():
        return ["x"]

    def __contains__(self,item):
        properties = self.PROPERTIES()
        return item in properties

    def __getitem__(self,item):
        properties = self.PROPERTIES()
        if isinstance(item,int):
            if item < 0 or item >= len(properties):
                raise IndexError()
            return getattr(self,properties[item])
        raise ValueError("'item' type must be 'int'")


cdef class long2:
    # members declared in pxd file

    def __cinit__(self):
        self._ptr = NULL
        self.ptr_owner = False
        self._py_buffer_acquired = False

    @staticmethod
    cdef long2 from_ptr(chip.long2* ptr, bint owner=False):
        """Factory function to create ``long2`` objects from
        given ``chip.long2`` pointer.

        Setting ``owner`` flag to ``True`` causes
        the extension type to ``free`` the structure pointed to by ``ptr``
        when the wrapper object is deallocated.
        """
        # Fast call to __new__() that bypasses the __init__() constructor.
        cdef long2 wrapper = long2.__new__(long2)
        wrapper._ptr = ptr
        wrapper.ptr_owner = owner
        return wrapper

    @staticmethod
    cdef long2 from_pyobj(object pyobj):
        """Derives a long2 from a Python object.

        Derives a long2 from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``long2`` reference, this method
        returns it directly. No new ``long2`` is created in this case.

        Args:
            pyobj (object): Must be either ``None``, a simple, contiguous buffer according to the buffer protocol,
                            or of type ``long2``, ``int``, or ``ctypes.c_void_p``

        Note:
            This routine does not perform a copy but returns the original ``pyobj``
            if ``pyobj`` is an instance of long2!
        """
        cdef long2 wrapper = long2.__new__(long2)
        cdef dict cuda_array_interface = getattr(pyobj, "__cuda_array_interface__", None)

        if pyobj is None:
            wrapper._ptr = NULL
        elif isinstance(pyobj,long2):
            return pyobj
        elif isinstance(pyobj,int):
            wrapper._ptr = <chip.long2*>cpython.long.PyLong_AsVoidPtr(pyobj)
        elif isinstance(pyobj,ctypes.c_void_p):
            wrapper._ptr = <chip.long2*>cpython.long.PyLong_AsVoidPtr(pyobj.value) if pyobj.value != None else NULL
        elif cuda_array_interface != None:
            if not "data" in cuda_array_interface:
                raise ValueError("input object has '__cuda_array_interface__' attribute but the dict has no 'data' key")
            ptr_as_int = cuda_array_interface["data"][0]
            wrapper._ptr = <chip.long2*>cpython.long.PyLong_AsVoidPtr(ptr_as_int)
        elif cpython.buffer.PyObject_CheckBuffer(pyobj):
            err = cpython.buffer.PyObject_GetBuffer( 
                pyobj,
                &wrapper._py_buffer, 
                cpython.buffer.PyBUF_SIMPLE | cpython.buffer.PyBUF_ANY_CONTIGUOUS
            )
            if err == -1:
                raise RuntimeError("failed to create simple, contiguous Py_buffer from Python object")
            wrapper._py_buffer_acquired = True
            wrapper._ptr = <chip.long2*>wrapper._py_buffer.buf
        else:
            raise TypeError(f"unsupported input type: '{str(type(pyobj))}'")
        return wrapper
    def __dealloc__(self):
        # Release the buffer handle
        if self._py_buffer_acquired is True:
            cpython.buffer.PyBuffer_Release(&self._py_buffer)
        # De-allocate if not null and flag is set
        if self._ptr is not NULL and self.ptr_owner is True:
            stdlib.free(self._ptr)
            self._ptr = NULL
    @staticmethod
    cdef __allocate(chip.long2** ptr):
        ptr[0] = <chip.long2*>stdlib.malloc(sizeof(chip.long2))

        if ptr[0] is NULL:
            raise MemoryError
        # TODO init values, if present

    @staticmethod
    cdef long2 new():
        """Factory function to create long2 objects with
        newly allocated chip.long2"""
        cdef chip.long2* ptr
        long2.__allocate(&ptr)
        return long2.from_ptr(ptr, owner=True)
   
    def __init__(self,*args,**kwargs):
        long2.__allocate(&self._ptr)
        self.ptr_owner = True
        attribs = self.PROPERTIES()
        used_attribs = set()
        if len(args) > len(attribs):
            raise ValueError("More positional arguments specified than this type has properties.")
        for i,v in enumerate(args):
            setattr(self,attribs[i],v)
            used_attribs.add(attribs[i])
        valid_names = ", ".join(["'"+p+"'" for p in attribs])
        for k,v in kwargs.items():
            if k in used_attribs:
                raise KeyError(f"argument '{k}' has already been specified as positional argument.")
            elif k not in attribs:
                raise KeyError(f"'{k}' is no valid property name. Valid names: {valid_names}")
            setattr(self,k,v)
    
    def __int__(self):
        """Returns the data's address as long integer."""
        return cpython.long.PyLong_FromVoidPtr(self._ptr)
    def __repr__(self):
        return f"<long2 object, self.ptr={int(self)}>"
    def as_c_void_p(self):
        """Returns the data's address as `ctypes.c_void_p`"""
        return ctypes.c_void_p(int(self))
    def get_x(self, i):
        """Get value ``x`` of ``self._ptr[i]``.
        """
        return self._ptr[i].x
    def set_x(self, i, long value):
        """Set value ``x`` of ``self._ptr[i]``.
        """
        self._ptr[i].x = value
    @property
    def x(self):
        return self.get_x(0)
    @x.setter
    def x(self, long value):
        self.set_x(0,value)

    def get_y(self, i):
        """Get value ``y`` of ``self._ptr[i]``.
        """
        return self._ptr[i].y
    def set_y(self, i, long value):
        """Set value ``y`` of ``self._ptr[i]``.
        """
        self._ptr[i].y = value
    @property
    def y(self):
        return self.get_y(0)
    @y.setter
    def y(self, long value):
        self.set_y(0,value)

    @staticmethod
    def PROPERTIES():
        return ["x","y"]

    def __contains__(self,item):
        properties = self.PROPERTIES()
        return item in properties

    def __getitem__(self,item):
        properties = self.PROPERTIES()
        if isinstance(item,int):
            if item < 0 or item >= len(properties):
                raise IndexError()
            return getattr(self,properties[item])
        raise ValueError("'item' type must be 'int'")


cdef class long3:
    # members declared in pxd file

    def __cinit__(self):
        self._ptr = NULL
        self.ptr_owner = False
        self._py_buffer_acquired = False

    @staticmethod
    cdef long3 from_ptr(chip.long3* ptr, bint owner=False):
        """Factory function to create ``long3`` objects from
        given ``chip.long3`` pointer.

        Setting ``owner`` flag to ``True`` causes
        the extension type to ``free`` the structure pointed to by ``ptr``
        when the wrapper object is deallocated.
        """
        # Fast call to __new__() that bypasses the __init__() constructor.
        cdef long3 wrapper = long3.__new__(long3)
        wrapper._ptr = ptr
        wrapper.ptr_owner = owner
        return wrapper

    @staticmethod
    cdef long3 from_pyobj(object pyobj):
        """Derives a long3 from a Python object.

        Derives a long3 from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``long3`` reference, this method
        returns it directly. No new ``long3`` is created in this case.

        Args:
            pyobj (object): Must be either ``None``, a simple, contiguous buffer according to the buffer protocol,
                            or of type ``long3``, ``int``, or ``ctypes.c_void_p``

        Note:
            This routine does not perform a copy but returns the original ``pyobj``
            if ``pyobj`` is an instance of long3!
        """
        cdef long3 wrapper = long3.__new__(long3)
        cdef dict cuda_array_interface = getattr(pyobj, "__cuda_array_interface__", None)

        if pyobj is None:
            wrapper._ptr = NULL
        elif isinstance(pyobj,long3):
            return pyobj
        elif isinstance(pyobj,int):
            wrapper._ptr = <chip.long3*>cpython.long.PyLong_AsVoidPtr(pyobj)
        elif isinstance(pyobj,ctypes.c_void_p):
            wrapper._ptr = <chip.long3*>cpython.long.PyLong_AsVoidPtr(pyobj.value) if pyobj.value != None else NULL
        elif cuda_array_interface != None:
            if not "data" in cuda_array_interface:
                raise ValueError("input object has '__cuda_array_interface__' attribute but the dict has no 'data' key")
            ptr_as_int = cuda_array_interface["data"][0]
            wrapper._ptr = <chip.long3*>cpython.long.PyLong_AsVoidPtr(ptr_as_int)
        elif cpython.buffer.PyObject_CheckBuffer(pyobj):
            err = cpython.buffer.PyObject_GetBuffer( 
                pyobj,
                &wrapper._py_buffer, 
                cpython.buffer.PyBUF_SIMPLE | cpython.buffer.PyBUF_ANY_CONTIGUOUS
            )
            if err == -1:
                raise RuntimeError("failed to create simple, contiguous Py_buffer from Python object")
            wrapper._py_buffer_acquired = True
            wrapper._ptr = <chip.long3*>wrapper._py_buffer.buf
        else:
            raise TypeError(f"unsupported input type: '{str(type(pyobj))}'")
        return wrapper
    def __dealloc__(self):
        # Release the buffer handle
        if self._py_buffer_acquired is True:
            cpython.buffer.PyBuffer_Release(&self._py_buffer)
        # De-allocate if not null and flag is set
        if self._ptr is not NULL and self.ptr_owner is True:
            stdlib.free(self._ptr)
            self._ptr = NULL
    @staticmethod
    cdef __allocate(chip.long3** ptr):
        ptr[0] = <chip.long3*>stdlib.malloc(sizeof(chip.long3))

        if ptr[0] is NULL:
            raise MemoryError
        # TODO init values, if present

    @staticmethod
    cdef long3 new():
        """Factory function to create long3 objects with
        newly allocated chip.long3"""
        cdef chip.long3* ptr
        long3.__allocate(&ptr)
        return long3.from_ptr(ptr, owner=True)
   
    def __init__(self,*args,**kwargs):
        long3.__allocate(&self._ptr)
        self.ptr_owner = True
        attribs = self.PROPERTIES()
        used_attribs = set()
        if len(args) > len(attribs):
            raise ValueError("More positional arguments specified than this type has properties.")
        for i,v in enumerate(args):
            setattr(self,attribs[i],v)
            used_attribs.add(attribs[i])
        valid_names = ", ".join(["'"+p+"'" for p in attribs])
        for k,v in kwargs.items():
            if k in used_attribs:
                raise KeyError(f"argument '{k}' has already been specified as positional argument.")
            elif k not in attribs:
                raise KeyError(f"'{k}' is no valid property name. Valid names: {valid_names}")
            setattr(self,k,v)
    
    def __int__(self):
        """Returns the data's address as long integer."""
        return cpython.long.PyLong_FromVoidPtr(self._ptr)
    def __repr__(self):
        return f"<long3 object, self.ptr={int(self)}>"
    def as_c_void_p(self):
        """Returns the data's address as `ctypes.c_void_p`"""
        return ctypes.c_void_p(int(self))
    def get_x(self, i):
        """Get value ``x`` of ``self._ptr[i]``.
        """
        return self._ptr[i].x
    def set_x(self, i, long value):
        """Set value ``x`` of ``self._ptr[i]``.
        """
        self._ptr[i].x = value
    @property
    def x(self):
        return self.get_x(0)
    @x.setter
    def x(self, long value):
        self.set_x(0,value)

    def get_y(self, i):
        """Get value ``y`` of ``self._ptr[i]``.
        """
        return self._ptr[i].y
    def set_y(self, i, long value):
        """Set value ``y`` of ``self._ptr[i]``.
        """
        self._ptr[i].y = value
    @property
    def y(self):
        return self.get_y(0)
    @y.setter
    def y(self, long value):
        self.set_y(0,value)

    def get_z(self, i):
        """Get value ``z`` of ``self._ptr[i]``.
        """
        return self._ptr[i].z
    def set_z(self, i, long value):
        """Set value ``z`` of ``self._ptr[i]``.
        """
        self._ptr[i].z = value
    @property
    def z(self):
        return self.get_z(0)
    @z.setter
    def z(self, long value):
        self.set_z(0,value)

    @staticmethod
    def PROPERTIES():
        return ["x","y","z"]

    def __contains__(self,item):
        properties = self.PROPERTIES()
        return item in properties

    def __getitem__(self,item):
        properties = self.PROPERTIES()
        if isinstance(item,int):
            if item < 0 or item >= len(properties):
                raise IndexError()
            return getattr(self,properties[item])
        raise ValueError("'item' type must be 'int'")


cdef class long4:
    # members declared in pxd file

    def __cinit__(self):
        self._ptr = NULL
        self.ptr_owner = False
        self._py_buffer_acquired = False

    @staticmethod
    cdef long4 from_ptr(chip.long4* ptr, bint owner=False):
        """Factory function to create ``long4`` objects from
        given ``chip.long4`` pointer.

        Setting ``owner`` flag to ``True`` causes
        the extension type to ``free`` the structure pointed to by ``ptr``
        when the wrapper object is deallocated.
        """
        # Fast call to __new__() that bypasses the __init__() constructor.
        cdef long4 wrapper = long4.__new__(long4)
        wrapper._ptr = ptr
        wrapper.ptr_owner = owner
        return wrapper

    @staticmethod
    cdef long4 from_pyobj(object pyobj):
        """Derives a long4 from a Python object.

        Derives a long4 from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``long4`` reference, this method
        returns it directly. No new ``long4`` is created in this case.

        Args:
            pyobj (object): Must be either ``None``, a simple, contiguous buffer according to the buffer protocol,
                            or of type ``long4``, ``int``, or ``ctypes.c_void_p``

        Note:
            This routine does not perform a copy but returns the original ``pyobj``
            if ``pyobj`` is an instance of long4!
        """
        cdef long4 wrapper = long4.__new__(long4)
        cdef dict cuda_array_interface = getattr(pyobj, "__cuda_array_interface__", None)

        if pyobj is None:
            wrapper._ptr = NULL
        elif isinstance(pyobj,long4):
            return pyobj
        elif isinstance(pyobj,int):
            wrapper._ptr = <chip.long4*>cpython.long.PyLong_AsVoidPtr(pyobj)
        elif isinstance(pyobj,ctypes.c_void_p):
            wrapper._ptr = <chip.long4*>cpython.long.PyLong_AsVoidPtr(pyobj.value) if pyobj.value != None else NULL
        elif cuda_array_interface != None:
            if not "data" in cuda_array_interface:
                raise ValueError("input object has '__cuda_array_interface__' attribute but the dict has no 'data' key")
            ptr_as_int = cuda_array_interface["data"][0]
            wrapper._ptr = <chip.long4*>cpython.long.PyLong_AsVoidPtr(ptr_as_int)
        elif cpython.buffer.PyObject_CheckBuffer(pyobj):
            err = cpython.buffer.PyObject_GetBuffer( 
                pyobj,
                &wrapper._py_buffer, 
                cpython.buffer.PyBUF_SIMPLE | cpython.buffer.PyBUF_ANY_CONTIGUOUS
            )
            if err == -1:
                raise RuntimeError("failed to create simple, contiguous Py_buffer from Python object")
            wrapper._py_buffer_acquired = True
            wrapper._ptr = <chip.long4*>wrapper._py_buffer.buf
        else:
            raise TypeError(f"unsupported input type: '{str(type(pyobj))}'")
        return wrapper
    def __dealloc__(self):
        # Release the buffer handle
        if self._py_buffer_acquired is True:
            cpython.buffer.PyBuffer_Release(&self._py_buffer)
        # De-allocate if not null and flag is set
        if self._ptr is not NULL and self.ptr_owner is True:
            stdlib.free(self._ptr)
            self._ptr = NULL
    @staticmethod
    cdef __allocate(chip.long4** ptr):
        ptr[0] = <chip.long4*>stdlib.malloc(sizeof(chip.long4))

        if ptr[0] is NULL:
            raise MemoryError
        # TODO init values, if present

    @staticmethod
    cdef long4 new():
        """Factory function to create long4 objects with
        newly allocated chip.long4"""
        cdef chip.long4* ptr
        long4.__allocate(&ptr)
        return long4.from_ptr(ptr, owner=True)
   
    def __init__(self,*args,**kwargs):
        long4.__allocate(&self._ptr)
        self.ptr_owner = True
        attribs = self.PROPERTIES()
        used_attribs = set()
        if len(args) > len(attribs):
            raise ValueError("More positional arguments specified than this type has properties.")
        for i,v in enumerate(args):
            setattr(self,attribs[i],v)
            used_attribs.add(attribs[i])
        valid_names = ", ".join(["'"+p+"'" for p in attribs])
        for k,v in kwargs.items():
            if k in used_attribs:
                raise KeyError(f"argument '{k}' has already been specified as positional argument.")
            elif k not in attribs:
                raise KeyError(f"'{k}' is no valid property name. Valid names: {valid_names}")
            setattr(self,k,v)
    
    def __int__(self):
        """Returns the data's address as long integer."""
        return cpython.long.PyLong_FromVoidPtr(self._ptr)
    def __repr__(self):
        return f"<long4 object, self.ptr={int(self)}>"
    def as_c_void_p(self):
        """Returns the data's address as `ctypes.c_void_p`"""
        return ctypes.c_void_p(int(self))
    def get_x(self, i):
        """Get value ``x`` of ``self._ptr[i]``.
        """
        return self._ptr[i].x
    def set_x(self, i, long value):
        """Set value ``x`` of ``self._ptr[i]``.
        """
        self._ptr[i].x = value
    @property
    def x(self):
        return self.get_x(0)
    @x.setter
    def x(self, long value):
        self.set_x(0,value)

    def get_y(self, i):
        """Get value ``y`` of ``self._ptr[i]``.
        """
        return self._ptr[i].y
    def set_y(self, i, long value):
        """Set value ``y`` of ``self._ptr[i]``.
        """
        self._ptr[i].y = value
    @property
    def y(self):
        return self.get_y(0)
    @y.setter
    def y(self, long value):
        self.set_y(0,value)

    def get_z(self, i):
        """Get value ``z`` of ``self._ptr[i]``.
        """
        return self._ptr[i].z
    def set_z(self, i, long value):
        """Set value ``z`` of ``self._ptr[i]``.
        """
        self._ptr[i].z = value
    @property
    def z(self):
        return self.get_z(0)
    @z.setter
    def z(self, long value):
        self.set_z(0,value)

    def get_w(self, i):
        """Get value ``w`` of ``self._ptr[i]``.
        """
        return self._ptr[i].w
    def set_w(self, i, long value):
        """Set value ``w`` of ``self._ptr[i]``.
        """
        self._ptr[i].w = value
    @property
    def w(self):
        return self.get_w(0)
    @w.setter
    def w(self, long value):
        self.set_w(0,value)

    @staticmethod
    def PROPERTIES():
        return ["x","y","z","w"]

    def __contains__(self,item):
        properties = self.PROPERTIES()
        return item in properties

    def __getitem__(self,item):
        properties = self.PROPERTIES()
        if isinstance(item,int):
            if item < 0 or item >= len(properties):
                raise IndexError()
            return getattr(self,properties[item])
        raise ValueError("'item' type must be 'int'")


cdef class ulonglong1:
    # members declared in pxd file

    def __cinit__(self):
        self._ptr = NULL
        self.ptr_owner = False
        self._py_buffer_acquired = False

    @staticmethod
    cdef ulonglong1 from_ptr(chip.ulonglong1* ptr, bint owner=False):
        """Factory function to create ``ulonglong1`` objects from
        given ``chip.ulonglong1`` pointer.

        Setting ``owner`` flag to ``True`` causes
        the extension type to ``free`` the structure pointed to by ``ptr``
        when the wrapper object is deallocated.
        """
        # Fast call to __new__() that bypasses the __init__() constructor.
        cdef ulonglong1 wrapper = ulonglong1.__new__(ulonglong1)
        wrapper._ptr = ptr
        wrapper.ptr_owner = owner
        return wrapper

    @staticmethod
    cdef ulonglong1 from_pyobj(object pyobj):
        """Derives a ulonglong1 from a Python object.

        Derives a ulonglong1 from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``ulonglong1`` reference, this method
        returns it directly. No new ``ulonglong1`` is created in this case.

        Args:
            pyobj (object): Must be either ``None``, a simple, contiguous buffer according to the buffer protocol,
                            or of type ``ulonglong1``, ``int``, or ``ctypes.c_void_p``

        Note:
            This routine does not perform a copy but returns the original ``pyobj``
            if ``pyobj`` is an instance of ulonglong1!
        """
        cdef ulonglong1 wrapper = ulonglong1.__new__(ulonglong1)
        cdef dict cuda_array_interface = getattr(pyobj, "__cuda_array_interface__", None)

        if pyobj is None:
            wrapper._ptr = NULL
        elif isinstance(pyobj,ulonglong1):
            return pyobj
        elif isinstance(pyobj,int):
            wrapper._ptr = <chip.ulonglong1*>cpython.long.PyLong_AsVoidPtr(pyobj)
        elif isinstance(pyobj,ctypes.c_void_p):
            wrapper._ptr = <chip.ulonglong1*>cpython.long.PyLong_AsVoidPtr(pyobj.value) if pyobj.value != None else NULL
        elif cuda_array_interface != None:
            if not "data" in cuda_array_interface:
                raise ValueError("input object has '__cuda_array_interface__' attribute but the dict has no 'data' key")
            ptr_as_int = cuda_array_interface["data"][0]
            wrapper._ptr = <chip.ulonglong1*>cpython.long.PyLong_AsVoidPtr(ptr_as_int)
        elif cpython.buffer.PyObject_CheckBuffer(pyobj):
            err = cpython.buffer.PyObject_GetBuffer( 
                pyobj,
                &wrapper._py_buffer, 
                cpython.buffer.PyBUF_SIMPLE | cpython.buffer.PyBUF_ANY_CONTIGUOUS
            )
            if err == -1:
                raise RuntimeError("failed to create simple, contiguous Py_buffer from Python object")
            wrapper._py_buffer_acquired = True
            wrapper._ptr = <chip.ulonglong1*>wrapper._py_buffer.buf
        else:
            raise TypeError(f"unsupported input type: '{str(type(pyobj))}'")
        return wrapper
    def __dealloc__(self):
        # Release the buffer handle
        if self._py_buffer_acquired is True:
            cpython.buffer.PyBuffer_Release(&self._py_buffer)
        # De-allocate if not null and flag is set
        if self._ptr is not NULL and self.ptr_owner is True:
            stdlib.free(self._ptr)
            self._ptr = NULL
    @staticmethod
    cdef __allocate(chip.ulonglong1** ptr):
        ptr[0] = <chip.ulonglong1*>stdlib.malloc(sizeof(chip.ulonglong1))

        if ptr[0] is NULL:
            raise MemoryError
        # TODO init values, if present

    @staticmethod
    cdef ulonglong1 new():
        """Factory function to create ulonglong1 objects with
        newly allocated chip.ulonglong1"""
        cdef chip.ulonglong1* ptr
        ulonglong1.__allocate(&ptr)
        return ulonglong1.from_ptr(ptr, owner=True)
   
    def __init__(self,*args,**kwargs):
        ulonglong1.__allocate(&self._ptr)
        self.ptr_owner = True
        attribs = self.PROPERTIES()
        used_attribs = set()
        if len(args) > len(attribs):
            raise ValueError("More positional arguments specified than this type has properties.")
        for i,v in enumerate(args):
            setattr(self,attribs[i],v)
            used_attribs.add(attribs[i])
        valid_names = ", ".join(["'"+p+"'" for p in attribs])
        for k,v in kwargs.items():
            if k in used_attribs:
                raise KeyError(f"argument '{k}' has already been specified as positional argument.")
            elif k not in attribs:
                raise KeyError(f"'{k}' is no valid property name. Valid names: {valid_names}")
            setattr(self,k,v)
    
    def __int__(self):
        """Returns the data's address as long integer."""
        return cpython.long.PyLong_FromVoidPtr(self._ptr)
    def __repr__(self):
        return f"<ulonglong1 object, self.ptr={int(self)}>"
    def as_c_void_p(self):
        """Returns the data's address as `ctypes.c_void_p`"""
        return ctypes.c_void_p(int(self))
    def get_x(self, i):
        """Get value ``x`` of ``self._ptr[i]``.
        """
        return self._ptr[i].x
    def set_x(self, i, unsigned long long value):
        """Set value ``x`` of ``self._ptr[i]``.
        """
        self._ptr[i].x = value
    @property
    def x(self):
        return self.get_x(0)
    @x.setter
    def x(self, unsigned long long value):
        self.set_x(0,value)

    @staticmethod
    def PROPERTIES():
        return ["x"]

    def __contains__(self,item):
        properties = self.PROPERTIES()
        return item in properties

    def __getitem__(self,item):
        properties = self.PROPERTIES()
        if isinstance(item,int):
            if item < 0 or item >= len(properties):
                raise IndexError()
            return getattr(self,properties[item])
        raise ValueError("'item' type must be 'int'")


cdef class ulonglong2:
    # members declared in pxd file

    def __cinit__(self):
        self._ptr = NULL
        self.ptr_owner = False
        self._py_buffer_acquired = False

    @staticmethod
    cdef ulonglong2 from_ptr(chip.ulonglong2* ptr, bint owner=False):
        """Factory function to create ``ulonglong2`` objects from
        given ``chip.ulonglong2`` pointer.

        Setting ``owner`` flag to ``True`` causes
        the extension type to ``free`` the structure pointed to by ``ptr``
        when the wrapper object is deallocated.
        """
        # Fast call to __new__() that bypasses the __init__() constructor.
        cdef ulonglong2 wrapper = ulonglong2.__new__(ulonglong2)
        wrapper._ptr = ptr
        wrapper.ptr_owner = owner
        return wrapper

    @staticmethod
    cdef ulonglong2 from_pyobj(object pyobj):
        """Derives a ulonglong2 from a Python object.

        Derives a ulonglong2 from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``ulonglong2`` reference, this method
        returns it directly. No new ``ulonglong2`` is created in this case.

        Args:
            pyobj (object): Must be either ``None``, a simple, contiguous buffer according to the buffer protocol,
                            or of type ``ulonglong2``, ``int``, or ``ctypes.c_void_p``

        Note:
            This routine does not perform a copy but returns the original ``pyobj``
            if ``pyobj`` is an instance of ulonglong2!
        """
        cdef ulonglong2 wrapper = ulonglong2.__new__(ulonglong2)
        cdef dict cuda_array_interface = getattr(pyobj, "__cuda_array_interface__", None)

        if pyobj is None:
            wrapper._ptr = NULL
        elif isinstance(pyobj,ulonglong2):
            return pyobj
        elif isinstance(pyobj,int):
            wrapper._ptr = <chip.ulonglong2*>cpython.long.PyLong_AsVoidPtr(pyobj)
        elif isinstance(pyobj,ctypes.c_void_p):
            wrapper._ptr = <chip.ulonglong2*>cpython.long.PyLong_AsVoidPtr(pyobj.value) if pyobj.value != None else NULL
        elif cuda_array_interface != None:
            if not "data" in cuda_array_interface:
                raise ValueError("input object has '__cuda_array_interface__' attribute but the dict has no 'data' key")
            ptr_as_int = cuda_array_interface["data"][0]
            wrapper._ptr = <chip.ulonglong2*>cpython.long.PyLong_AsVoidPtr(ptr_as_int)
        elif cpython.buffer.PyObject_CheckBuffer(pyobj):
            err = cpython.buffer.PyObject_GetBuffer( 
                pyobj,
                &wrapper._py_buffer, 
                cpython.buffer.PyBUF_SIMPLE | cpython.buffer.PyBUF_ANY_CONTIGUOUS
            )
            if err == -1:
                raise RuntimeError("failed to create simple, contiguous Py_buffer from Python object")
            wrapper._py_buffer_acquired = True
            wrapper._ptr = <chip.ulonglong2*>wrapper._py_buffer.buf
        else:
            raise TypeError(f"unsupported input type: '{str(type(pyobj))}'")
        return wrapper
    def __dealloc__(self):
        # Release the buffer handle
        if self._py_buffer_acquired is True:
            cpython.buffer.PyBuffer_Release(&self._py_buffer)
        # De-allocate if not null and flag is set
        if self._ptr is not NULL and self.ptr_owner is True:
            stdlib.free(self._ptr)
            self._ptr = NULL
    @staticmethod
    cdef __allocate(chip.ulonglong2** ptr):
        ptr[0] = <chip.ulonglong2*>stdlib.malloc(sizeof(chip.ulonglong2))

        if ptr[0] is NULL:
            raise MemoryError
        # TODO init values, if present

    @staticmethod
    cdef ulonglong2 new():
        """Factory function to create ulonglong2 objects with
        newly allocated chip.ulonglong2"""
        cdef chip.ulonglong2* ptr
        ulonglong2.__allocate(&ptr)
        return ulonglong2.from_ptr(ptr, owner=True)
   
    def __init__(self,*args,**kwargs):
        ulonglong2.__allocate(&self._ptr)
        self.ptr_owner = True
        attribs = self.PROPERTIES()
        used_attribs = set()
        if len(args) > len(attribs):
            raise ValueError("More positional arguments specified than this type has properties.")
        for i,v in enumerate(args):
            setattr(self,attribs[i],v)
            used_attribs.add(attribs[i])
        valid_names = ", ".join(["'"+p+"'" for p in attribs])
        for k,v in kwargs.items():
            if k in used_attribs:
                raise KeyError(f"argument '{k}' has already been specified as positional argument.")
            elif k not in attribs:
                raise KeyError(f"'{k}' is no valid property name. Valid names: {valid_names}")
            setattr(self,k,v)
    
    def __int__(self):
        """Returns the data's address as long integer."""
        return cpython.long.PyLong_FromVoidPtr(self._ptr)
    def __repr__(self):
        return f"<ulonglong2 object, self.ptr={int(self)}>"
    def as_c_void_p(self):
        """Returns the data's address as `ctypes.c_void_p`"""
        return ctypes.c_void_p(int(self))
    def get_x(self, i):
        """Get value ``x`` of ``self._ptr[i]``.
        """
        return self._ptr[i].x
    def set_x(self, i, unsigned long long value):
        """Set value ``x`` of ``self._ptr[i]``.
        """
        self._ptr[i].x = value
    @property
    def x(self):
        return self.get_x(0)
    @x.setter
    def x(self, unsigned long long value):
        self.set_x(0,value)

    def get_y(self, i):
        """Get value ``y`` of ``self._ptr[i]``.
        """
        return self._ptr[i].y
    def set_y(self, i, unsigned long long value):
        """Set value ``y`` of ``self._ptr[i]``.
        """
        self._ptr[i].y = value
    @property
    def y(self):
        return self.get_y(0)
    @y.setter
    def y(self, unsigned long long value):
        self.set_y(0,value)

    @staticmethod
    def PROPERTIES():
        return ["x","y"]

    def __contains__(self,item):
        properties = self.PROPERTIES()
        return item in properties

    def __getitem__(self,item):
        properties = self.PROPERTIES()
        if isinstance(item,int):
            if item < 0 or item >= len(properties):
                raise IndexError()
            return getattr(self,properties[item])
        raise ValueError("'item' type must be 'int'")


cdef class ulonglong3:
    # members declared in pxd file

    def __cinit__(self):
        self._ptr = NULL
        self.ptr_owner = False
        self._py_buffer_acquired = False

    @staticmethod
    cdef ulonglong3 from_ptr(chip.ulonglong3* ptr, bint owner=False):
        """Factory function to create ``ulonglong3`` objects from
        given ``chip.ulonglong3`` pointer.

        Setting ``owner`` flag to ``True`` causes
        the extension type to ``free`` the structure pointed to by ``ptr``
        when the wrapper object is deallocated.
        """
        # Fast call to __new__() that bypasses the __init__() constructor.
        cdef ulonglong3 wrapper = ulonglong3.__new__(ulonglong3)
        wrapper._ptr = ptr
        wrapper.ptr_owner = owner
        return wrapper

    @staticmethod
    cdef ulonglong3 from_pyobj(object pyobj):
        """Derives a ulonglong3 from a Python object.

        Derives a ulonglong3 from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``ulonglong3`` reference, this method
        returns it directly. No new ``ulonglong3`` is created in this case.

        Args:
            pyobj (object): Must be either ``None``, a simple, contiguous buffer according to the buffer protocol,
                            or of type ``ulonglong3``, ``int``, or ``ctypes.c_void_p``

        Note:
            This routine does not perform a copy but returns the original ``pyobj``
            if ``pyobj`` is an instance of ulonglong3!
        """
        cdef ulonglong3 wrapper = ulonglong3.__new__(ulonglong3)
        cdef dict cuda_array_interface = getattr(pyobj, "__cuda_array_interface__", None)

        if pyobj is None:
            wrapper._ptr = NULL
        elif isinstance(pyobj,ulonglong3):
            return pyobj
        elif isinstance(pyobj,int):
            wrapper._ptr = <chip.ulonglong3*>cpython.long.PyLong_AsVoidPtr(pyobj)
        elif isinstance(pyobj,ctypes.c_void_p):
            wrapper._ptr = <chip.ulonglong3*>cpython.long.PyLong_AsVoidPtr(pyobj.value) if pyobj.value != None else NULL
        elif cuda_array_interface != None:
            if not "data" in cuda_array_interface:
                raise ValueError("input object has '__cuda_array_interface__' attribute but the dict has no 'data' key")
            ptr_as_int = cuda_array_interface["data"][0]
            wrapper._ptr = <chip.ulonglong3*>cpython.long.PyLong_AsVoidPtr(ptr_as_int)
        elif cpython.buffer.PyObject_CheckBuffer(pyobj):
            err = cpython.buffer.PyObject_GetBuffer( 
                pyobj,
                &wrapper._py_buffer, 
                cpython.buffer.PyBUF_SIMPLE | cpython.buffer.PyBUF_ANY_CONTIGUOUS
            )
            if err == -1:
                raise RuntimeError("failed to create simple, contiguous Py_buffer from Python object")
            wrapper._py_buffer_acquired = True
            wrapper._ptr = <chip.ulonglong3*>wrapper._py_buffer.buf
        else:
            raise TypeError(f"unsupported input type: '{str(type(pyobj))}'")
        return wrapper
    def __dealloc__(self):
        # Release the buffer handle
        if self._py_buffer_acquired is True:
            cpython.buffer.PyBuffer_Release(&self._py_buffer)
        # De-allocate if not null and flag is set
        if self._ptr is not NULL and self.ptr_owner is True:
            stdlib.free(self._ptr)
            self._ptr = NULL
    @staticmethod
    cdef __allocate(chip.ulonglong3** ptr):
        ptr[0] = <chip.ulonglong3*>stdlib.malloc(sizeof(chip.ulonglong3))

        if ptr[0] is NULL:
            raise MemoryError
        # TODO init values, if present

    @staticmethod
    cdef ulonglong3 new():
        """Factory function to create ulonglong3 objects with
        newly allocated chip.ulonglong3"""
        cdef chip.ulonglong3* ptr
        ulonglong3.__allocate(&ptr)
        return ulonglong3.from_ptr(ptr, owner=True)
   
    def __init__(self,*args,**kwargs):
        ulonglong3.__allocate(&self._ptr)
        self.ptr_owner = True
        attribs = self.PROPERTIES()
        used_attribs = set()
        if len(args) > len(attribs):
            raise ValueError("More positional arguments specified than this type has properties.")
        for i,v in enumerate(args):
            setattr(self,attribs[i],v)
            used_attribs.add(attribs[i])
        valid_names = ", ".join(["'"+p+"'" for p in attribs])
        for k,v in kwargs.items():
            if k in used_attribs:
                raise KeyError(f"argument '{k}' has already been specified as positional argument.")
            elif k not in attribs:
                raise KeyError(f"'{k}' is no valid property name. Valid names: {valid_names}")
            setattr(self,k,v)
    
    def __int__(self):
        """Returns the data's address as long integer."""
        return cpython.long.PyLong_FromVoidPtr(self._ptr)
    def __repr__(self):
        return f"<ulonglong3 object, self.ptr={int(self)}>"
    def as_c_void_p(self):
        """Returns the data's address as `ctypes.c_void_p`"""
        return ctypes.c_void_p(int(self))
    def get_x(self, i):
        """Get value ``x`` of ``self._ptr[i]``.
        """
        return self._ptr[i].x
    def set_x(self, i, unsigned long long value):
        """Set value ``x`` of ``self._ptr[i]``.
        """
        self._ptr[i].x = value
    @property
    def x(self):
        return self.get_x(0)
    @x.setter
    def x(self, unsigned long long value):
        self.set_x(0,value)

    def get_y(self, i):
        """Get value ``y`` of ``self._ptr[i]``.
        """
        return self._ptr[i].y
    def set_y(self, i, unsigned long long value):
        """Set value ``y`` of ``self._ptr[i]``.
        """
        self._ptr[i].y = value
    @property
    def y(self):
        return self.get_y(0)
    @y.setter
    def y(self, unsigned long long value):
        self.set_y(0,value)

    def get_z(self, i):
        """Get value ``z`` of ``self._ptr[i]``.
        """
        return self._ptr[i].z
    def set_z(self, i, unsigned long long value):
        """Set value ``z`` of ``self._ptr[i]``.
        """
        self._ptr[i].z = value
    @property
    def z(self):
        return self.get_z(0)
    @z.setter
    def z(self, unsigned long long value):
        self.set_z(0,value)

    @staticmethod
    def PROPERTIES():
        return ["x","y","z"]

    def __contains__(self,item):
        properties = self.PROPERTIES()
        return item in properties

    def __getitem__(self,item):
        properties = self.PROPERTIES()
        if isinstance(item,int):
            if item < 0 or item >= len(properties):
                raise IndexError()
            return getattr(self,properties[item])
        raise ValueError("'item' type must be 'int'")


cdef class ulonglong4:
    # members declared in pxd file

    def __cinit__(self):
        self._ptr = NULL
        self.ptr_owner = False
        self._py_buffer_acquired = False

    @staticmethod
    cdef ulonglong4 from_ptr(chip.ulonglong4* ptr, bint owner=False):
        """Factory function to create ``ulonglong4`` objects from
        given ``chip.ulonglong4`` pointer.

        Setting ``owner`` flag to ``True`` causes
        the extension type to ``free`` the structure pointed to by ``ptr``
        when the wrapper object is deallocated.
        """
        # Fast call to __new__() that bypasses the __init__() constructor.
        cdef ulonglong4 wrapper = ulonglong4.__new__(ulonglong4)
        wrapper._ptr = ptr
        wrapper.ptr_owner = owner
        return wrapper

    @staticmethod
    cdef ulonglong4 from_pyobj(object pyobj):
        """Derives a ulonglong4 from a Python object.

        Derives a ulonglong4 from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``ulonglong4`` reference, this method
        returns it directly. No new ``ulonglong4`` is created in this case.

        Args:
            pyobj (object): Must be either ``None``, a simple, contiguous buffer according to the buffer protocol,
                            or of type ``ulonglong4``, ``int``, or ``ctypes.c_void_p``

        Note:
            This routine does not perform a copy but returns the original ``pyobj``
            if ``pyobj`` is an instance of ulonglong4!
        """
        cdef ulonglong4 wrapper = ulonglong4.__new__(ulonglong4)
        cdef dict cuda_array_interface = getattr(pyobj, "__cuda_array_interface__", None)

        if pyobj is None:
            wrapper._ptr = NULL
        elif isinstance(pyobj,ulonglong4):
            return pyobj
        elif isinstance(pyobj,int):
            wrapper._ptr = <chip.ulonglong4*>cpython.long.PyLong_AsVoidPtr(pyobj)
        elif isinstance(pyobj,ctypes.c_void_p):
            wrapper._ptr = <chip.ulonglong4*>cpython.long.PyLong_AsVoidPtr(pyobj.value) if pyobj.value != None else NULL
        elif cuda_array_interface != None:
            if not "data" in cuda_array_interface:
                raise ValueError("input object has '__cuda_array_interface__' attribute but the dict has no 'data' key")
            ptr_as_int = cuda_array_interface["data"][0]
            wrapper._ptr = <chip.ulonglong4*>cpython.long.PyLong_AsVoidPtr(ptr_as_int)
        elif cpython.buffer.PyObject_CheckBuffer(pyobj):
            err = cpython.buffer.PyObject_GetBuffer( 
                pyobj,
                &wrapper._py_buffer, 
                cpython.buffer.PyBUF_SIMPLE | cpython.buffer.PyBUF_ANY_CONTIGUOUS
            )
            if err == -1:
                raise RuntimeError("failed to create simple, contiguous Py_buffer from Python object")
            wrapper._py_buffer_acquired = True
            wrapper._ptr = <chip.ulonglong4*>wrapper._py_buffer.buf
        else:
            raise TypeError(f"unsupported input type: '{str(type(pyobj))}'")
        return wrapper
    def __dealloc__(self):
        # Release the buffer handle
        if self._py_buffer_acquired is True:
            cpython.buffer.PyBuffer_Release(&self._py_buffer)
        # De-allocate if not null and flag is set
        if self._ptr is not NULL and self.ptr_owner is True:
            stdlib.free(self._ptr)
            self._ptr = NULL
    @staticmethod
    cdef __allocate(chip.ulonglong4** ptr):
        ptr[0] = <chip.ulonglong4*>stdlib.malloc(sizeof(chip.ulonglong4))

        if ptr[0] is NULL:
            raise MemoryError
        # TODO init values, if present

    @staticmethod
    cdef ulonglong4 new():
        """Factory function to create ulonglong4 objects with
        newly allocated chip.ulonglong4"""
        cdef chip.ulonglong4* ptr
        ulonglong4.__allocate(&ptr)
        return ulonglong4.from_ptr(ptr, owner=True)
   
    def __init__(self,*args,**kwargs):
        ulonglong4.__allocate(&self._ptr)
        self.ptr_owner = True
        attribs = self.PROPERTIES()
        used_attribs = set()
        if len(args) > len(attribs):
            raise ValueError("More positional arguments specified than this type has properties.")
        for i,v in enumerate(args):
            setattr(self,attribs[i],v)
            used_attribs.add(attribs[i])
        valid_names = ", ".join(["'"+p+"'" for p in attribs])
        for k,v in kwargs.items():
            if k in used_attribs:
                raise KeyError(f"argument '{k}' has already been specified as positional argument.")
            elif k not in attribs:
                raise KeyError(f"'{k}' is no valid property name. Valid names: {valid_names}")
            setattr(self,k,v)
    
    def __int__(self):
        """Returns the data's address as long integer."""
        return cpython.long.PyLong_FromVoidPtr(self._ptr)
    def __repr__(self):
        return f"<ulonglong4 object, self.ptr={int(self)}>"
    def as_c_void_p(self):
        """Returns the data's address as `ctypes.c_void_p`"""
        return ctypes.c_void_p(int(self))
    def get_x(self, i):
        """Get value ``x`` of ``self._ptr[i]``.
        """
        return self._ptr[i].x
    def set_x(self, i, unsigned long long value):
        """Set value ``x`` of ``self._ptr[i]``.
        """
        self._ptr[i].x = value
    @property
    def x(self):
        return self.get_x(0)
    @x.setter
    def x(self, unsigned long long value):
        self.set_x(0,value)

    def get_y(self, i):
        """Get value ``y`` of ``self._ptr[i]``.
        """
        return self._ptr[i].y
    def set_y(self, i, unsigned long long value):
        """Set value ``y`` of ``self._ptr[i]``.
        """
        self._ptr[i].y = value
    @property
    def y(self):
        return self.get_y(0)
    @y.setter
    def y(self, unsigned long long value):
        self.set_y(0,value)

    def get_z(self, i):
        """Get value ``z`` of ``self._ptr[i]``.
        """
        return self._ptr[i].z
    def set_z(self, i, unsigned long long value):
        """Set value ``z`` of ``self._ptr[i]``.
        """
        self._ptr[i].z = value
    @property
    def z(self):
        return self.get_z(0)
    @z.setter
    def z(self, unsigned long long value):
        self.set_z(0,value)

    def get_w(self, i):
        """Get value ``w`` of ``self._ptr[i]``.
        """
        return self._ptr[i].w
    def set_w(self, i, unsigned long long value):
        """Set value ``w`` of ``self._ptr[i]``.
        """
        self._ptr[i].w = value
    @property
    def w(self):
        return self.get_w(0)
    @w.setter
    def w(self, unsigned long long value):
        self.set_w(0,value)

    @staticmethod
    def PROPERTIES():
        return ["x","y","z","w"]

    def __contains__(self,item):
        properties = self.PROPERTIES()
        return item in properties

    def __getitem__(self,item):
        properties = self.PROPERTIES()
        if isinstance(item,int):
            if item < 0 or item >= len(properties):
                raise IndexError()
            return getattr(self,properties[item])
        raise ValueError("'item' type must be 'int'")


cdef class longlong1:
    # members declared in pxd file

    def __cinit__(self):
        self._ptr = NULL
        self.ptr_owner = False
        self._py_buffer_acquired = False

    @staticmethod
    cdef longlong1 from_ptr(chip.longlong1* ptr, bint owner=False):
        """Factory function to create ``longlong1`` objects from
        given ``chip.longlong1`` pointer.

        Setting ``owner`` flag to ``True`` causes
        the extension type to ``free`` the structure pointed to by ``ptr``
        when the wrapper object is deallocated.
        """
        # Fast call to __new__() that bypasses the __init__() constructor.
        cdef longlong1 wrapper = longlong1.__new__(longlong1)
        wrapper._ptr = ptr
        wrapper.ptr_owner = owner
        return wrapper

    @staticmethod
    cdef longlong1 from_pyobj(object pyobj):
        """Derives a longlong1 from a Python object.

        Derives a longlong1 from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``longlong1`` reference, this method
        returns it directly. No new ``longlong1`` is created in this case.

        Args:
            pyobj (object): Must be either ``None``, a simple, contiguous buffer according to the buffer protocol,
                            or of type ``longlong1``, ``int``, or ``ctypes.c_void_p``

        Note:
            This routine does not perform a copy but returns the original ``pyobj``
            if ``pyobj`` is an instance of longlong1!
        """
        cdef longlong1 wrapper = longlong1.__new__(longlong1)
        cdef dict cuda_array_interface = getattr(pyobj, "__cuda_array_interface__", None)

        if pyobj is None:
            wrapper._ptr = NULL
        elif isinstance(pyobj,longlong1):
            return pyobj
        elif isinstance(pyobj,int):
            wrapper._ptr = <chip.longlong1*>cpython.long.PyLong_AsVoidPtr(pyobj)
        elif isinstance(pyobj,ctypes.c_void_p):
            wrapper._ptr = <chip.longlong1*>cpython.long.PyLong_AsVoidPtr(pyobj.value) if pyobj.value != None else NULL
        elif cuda_array_interface != None:
            if not "data" in cuda_array_interface:
                raise ValueError("input object has '__cuda_array_interface__' attribute but the dict has no 'data' key")
            ptr_as_int = cuda_array_interface["data"][0]
            wrapper._ptr = <chip.longlong1*>cpython.long.PyLong_AsVoidPtr(ptr_as_int)
        elif cpython.buffer.PyObject_CheckBuffer(pyobj):
            err = cpython.buffer.PyObject_GetBuffer( 
                pyobj,
                &wrapper._py_buffer, 
                cpython.buffer.PyBUF_SIMPLE | cpython.buffer.PyBUF_ANY_CONTIGUOUS
            )
            if err == -1:
                raise RuntimeError("failed to create simple, contiguous Py_buffer from Python object")
            wrapper._py_buffer_acquired = True
            wrapper._ptr = <chip.longlong1*>wrapper._py_buffer.buf
        else:
            raise TypeError(f"unsupported input type: '{str(type(pyobj))}'")
        return wrapper
    def __dealloc__(self):
        # Release the buffer handle
        if self._py_buffer_acquired is True:
            cpython.buffer.PyBuffer_Release(&self._py_buffer)
        # De-allocate if not null and flag is set
        if self._ptr is not NULL and self.ptr_owner is True:
            stdlib.free(self._ptr)
            self._ptr = NULL
    @staticmethod
    cdef __allocate(chip.longlong1** ptr):
        ptr[0] = <chip.longlong1*>stdlib.malloc(sizeof(chip.longlong1))

        if ptr[0] is NULL:
            raise MemoryError
        # TODO init values, if present

    @staticmethod
    cdef longlong1 new():
        """Factory function to create longlong1 objects with
        newly allocated chip.longlong1"""
        cdef chip.longlong1* ptr
        longlong1.__allocate(&ptr)
        return longlong1.from_ptr(ptr, owner=True)
   
    def __init__(self,*args,**kwargs):
        longlong1.__allocate(&self._ptr)
        self.ptr_owner = True
        attribs = self.PROPERTIES()
        used_attribs = set()
        if len(args) > len(attribs):
            raise ValueError("More positional arguments specified than this type has properties.")
        for i,v in enumerate(args):
            setattr(self,attribs[i],v)
            used_attribs.add(attribs[i])
        valid_names = ", ".join(["'"+p+"'" for p in attribs])
        for k,v in kwargs.items():
            if k in used_attribs:
                raise KeyError(f"argument '{k}' has already been specified as positional argument.")
            elif k not in attribs:
                raise KeyError(f"'{k}' is no valid property name. Valid names: {valid_names}")
            setattr(self,k,v)
    
    def __int__(self):
        """Returns the data's address as long integer."""
        return cpython.long.PyLong_FromVoidPtr(self._ptr)
    def __repr__(self):
        return f"<longlong1 object, self.ptr={int(self)}>"
    def as_c_void_p(self):
        """Returns the data's address as `ctypes.c_void_p`"""
        return ctypes.c_void_p(int(self))
    def get_x(self, i):
        """Get value ``x`` of ``self._ptr[i]``.
        """
        return self._ptr[i].x
    def set_x(self, i, long long value):
        """Set value ``x`` of ``self._ptr[i]``.
        """
        self._ptr[i].x = value
    @property
    def x(self):
        return self.get_x(0)
    @x.setter
    def x(self, long long value):
        self.set_x(0,value)

    @staticmethod
    def PROPERTIES():
        return ["x"]

    def __contains__(self,item):
        properties = self.PROPERTIES()
        return item in properties

    def __getitem__(self,item):
        properties = self.PROPERTIES()
        if isinstance(item,int):
            if item < 0 or item >= len(properties):
                raise IndexError()
            return getattr(self,properties[item])
        raise ValueError("'item' type must be 'int'")


cdef class longlong2:
    # members declared in pxd file

    def __cinit__(self):
        self._ptr = NULL
        self.ptr_owner = False
        self._py_buffer_acquired = False

    @staticmethod
    cdef longlong2 from_ptr(chip.longlong2* ptr, bint owner=False):
        """Factory function to create ``longlong2`` objects from
        given ``chip.longlong2`` pointer.

        Setting ``owner`` flag to ``True`` causes
        the extension type to ``free`` the structure pointed to by ``ptr``
        when the wrapper object is deallocated.
        """
        # Fast call to __new__() that bypasses the __init__() constructor.
        cdef longlong2 wrapper = longlong2.__new__(longlong2)
        wrapper._ptr = ptr
        wrapper.ptr_owner = owner
        return wrapper

    @staticmethod
    cdef longlong2 from_pyobj(object pyobj):
        """Derives a longlong2 from a Python object.

        Derives a longlong2 from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``longlong2`` reference, this method
        returns it directly. No new ``longlong2`` is created in this case.

        Args:
            pyobj (object): Must be either ``None``, a simple, contiguous buffer according to the buffer protocol,
                            or of type ``longlong2``, ``int``, or ``ctypes.c_void_p``

        Note:
            This routine does not perform a copy but returns the original ``pyobj``
            if ``pyobj`` is an instance of longlong2!
        """
        cdef longlong2 wrapper = longlong2.__new__(longlong2)
        cdef dict cuda_array_interface = getattr(pyobj, "__cuda_array_interface__", None)

        if pyobj is None:
            wrapper._ptr = NULL
        elif isinstance(pyobj,longlong2):
            return pyobj
        elif isinstance(pyobj,int):
            wrapper._ptr = <chip.longlong2*>cpython.long.PyLong_AsVoidPtr(pyobj)
        elif isinstance(pyobj,ctypes.c_void_p):
            wrapper._ptr = <chip.longlong2*>cpython.long.PyLong_AsVoidPtr(pyobj.value) if pyobj.value != None else NULL
        elif cuda_array_interface != None:
            if not "data" in cuda_array_interface:
                raise ValueError("input object has '__cuda_array_interface__' attribute but the dict has no 'data' key")
            ptr_as_int = cuda_array_interface["data"][0]
            wrapper._ptr = <chip.longlong2*>cpython.long.PyLong_AsVoidPtr(ptr_as_int)
        elif cpython.buffer.PyObject_CheckBuffer(pyobj):
            err = cpython.buffer.PyObject_GetBuffer( 
                pyobj,
                &wrapper._py_buffer, 
                cpython.buffer.PyBUF_SIMPLE | cpython.buffer.PyBUF_ANY_CONTIGUOUS
            )
            if err == -1:
                raise RuntimeError("failed to create simple, contiguous Py_buffer from Python object")
            wrapper._py_buffer_acquired = True
            wrapper._ptr = <chip.longlong2*>wrapper._py_buffer.buf
        else:
            raise TypeError(f"unsupported input type: '{str(type(pyobj))}'")
        return wrapper
    def __dealloc__(self):
        # Release the buffer handle
        if self._py_buffer_acquired is True:
            cpython.buffer.PyBuffer_Release(&self._py_buffer)
        # De-allocate if not null and flag is set
        if self._ptr is not NULL and self.ptr_owner is True:
            stdlib.free(self._ptr)
            self._ptr = NULL
    @staticmethod
    cdef __allocate(chip.longlong2** ptr):
        ptr[0] = <chip.longlong2*>stdlib.malloc(sizeof(chip.longlong2))

        if ptr[0] is NULL:
            raise MemoryError
        # TODO init values, if present

    @staticmethod
    cdef longlong2 new():
        """Factory function to create longlong2 objects with
        newly allocated chip.longlong2"""
        cdef chip.longlong2* ptr
        longlong2.__allocate(&ptr)
        return longlong2.from_ptr(ptr, owner=True)
   
    def __init__(self,*args,**kwargs):
        longlong2.__allocate(&self._ptr)
        self.ptr_owner = True
        attribs = self.PROPERTIES()
        used_attribs = set()
        if len(args) > len(attribs):
            raise ValueError("More positional arguments specified than this type has properties.")
        for i,v in enumerate(args):
            setattr(self,attribs[i],v)
            used_attribs.add(attribs[i])
        valid_names = ", ".join(["'"+p+"'" for p in attribs])
        for k,v in kwargs.items():
            if k in used_attribs:
                raise KeyError(f"argument '{k}' has already been specified as positional argument.")
            elif k not in attribs:
                raise KeyError(f"'{k}' is no valid property name. Valid names: {valid_names}")
            setattr(self,k,v)
    
    def __int__(self):
        """Returns the data's address as long integer."""
        return cpython.long.PyLong_FromVoidPtr(self._ptr)
    def __repr__(self):
        return f"<longlong2 object, self.ptr={int(self)}>"
    def as_c_void_p(self):
        """Returns the data's address as `ctypes.c_void_p`"""
        return ctypes.c_void_p(int(self))
    def get_x(self, i):
        """Get value ``x`` of ``self._ptr[i]``.
        """
        return self._ptr[i].x
    def set_x(self, i, long long value):
        """Set value ``x`` of ``self._ptr[i]``.
        """
        self._ptr[i].x = value
    @property
    def x(self):
        return self.get_x(0)
    @x.setter
    def x(self, long long value):
        self.set_x(0,value)

    def get_y(self, i):
        """Get value ``y`` of ``self._ptr[i]``.
        """
        return self._ptr[i].y
    def set_y(self, i, long long value):
        """Set value ``y`` of ``self._ptr[i]``.
        """
        self._ptr[i].y = value
    @property
    def y(self):
        return self.get_y(0)
    @y.setter
    def y(self, long long value):
        self.set_y(0,value)

    @staticmethod
    def PROPERTIES():
        return ["x","y"]

    def __contains__(self,item):
        properties = self.PROPERTIES()
        return item in properties

    def __getitem__(self,item):
        properties = self.PROPERTIES()
        if isinstance(item,int):
            if item < 0 or item >= len(properties):
                raise IndexError()
            return getattr(self,properties[item])
        raise ValueError("'item' type must be 'int'")


cdef class longlong3:
    # members declared in pxd file

    def __cinit__(self):
        self._ptr = NULL
        self.ptr_owner = False
        self._py_buffer_acquired = False

    @staticmethod
    cdef longlong3 from_ptr(chip.longlong3* ptr, bint owner=False):
        """Factory function to create ``longlong3`` objects from
        given ``chip.longlong3`` pointer.

        Setting ``owner`` flag to ``True`` causes
        the extension type to ``free`` the structure pointed to by ``ptr``
        when the wrapper object is deallocated.
        """
        # Fast call to __new__() that bypasses the __init__() constructor.
        cdef longlong3 wrapper = longlong3.__new__(longlong3)
        wrapper._ptr = ptr
        wrapper.ptr_owner = owner
        return wrapper

    @staticmethod
    cdef longlong3 from_pyobj(object pyobj):
        """Derives a longlong3 from a Python object.

        Derives a longlong3 from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``longlong3`` reference, this method
        returns it directly. No new ``longlong3`` is created in this case.

        Args:
            pyobj (object): Must be either ``None``, a simple, contiguous buffer according to the buffer protocol,
                            or of type ``longlong3``, ``int``, or ``ctypes.c_void_p``

        Note:
            This routine does not perform a copy but returns the original ``pyobj``
            if ``pyobj`` is an instance of longlong3!
        """
        cdef longlong3 wrapper = longlong3.__new__(longlong3)
        cdef dict cuda_array_interface = getattr(pyobj, "__cuda_array_interface__", None)

        if pyobj is None:
            wrapper._ptr = NULL
        elif isinstance(pyobj,longlong3):
            return pyobj
        elif isinstance(pyobj,int):
            wrapper._ptr = <chip.longlong3*>cpython.long.PyLong_AsVoidPtr(pyobj)
        elif isinstance(pyobj,ctypes.c_void_p):
            wrapper._ptr = <chip.longlong3*>cpython.long.PyLong_AsVoidPtr(pyobj.value) if pyobj.value != None else NULL
        elif cuda_array_interface != None:
            if not "data" in cuda_array_interface:
                raise ValueError("input object has '__cuda_array_interface__' attribute but the dict has no 'data' key")
            ptr_as_int = cuda_array_interface["data"][0]
            wrapper._ptr = <chip.longlong3*>cpython.long.PyLong_AsVoidPtr(ptr_as_int)
        elif cpython.buffer.PyObject_CheckBuffer(pyobj):
            err = cpython.buffer.PyObject_GetBuffer( 
                pyobj,
                &wrapper._py_buffer, 
                cpython.buffer.PyBUF_SIMPLE | cpython.buffer.PyBUF_ANY_CONTIGUOUS
            )
            if err == -1:
                raise RuntimeError("failed to create simple, contiguous Py_buffer from Python object")
            wrapper._py_buffer_acquired = True
            wrapper._ptr = <chip.longlong3*>wrapper._py_buffer.buf
        else:
            raise TypeError(f"unsupported input type: '{str(type(pyobj))}'")
        return wrapper
    def __dealloc__(self):
        # Release the buffer handle
        if self._py_buffer_acquired is True:
            cpython.buffer.PyBuffer_Release(&self._py_buffer)
        # De-allocate if not null and flag is set
        if self._ptr is not NULL and self.ptr_owner is True:
            stdlib.free(self._ptr)
            self._ptr = NULL
    @staticmethod
    cdef __allocate(chip.longlong3** ptr):
        ptr[0] = <chip.longlong3*>stdlib.malloc(sizeof(chip.longlong3))

        if ptr[0] is NULL:
            raise MemoryError
        # TODO init values, if present

    @staticmethod
    cdef longlong3 new():
        """Factory function to create longlong3 objects with
        newly allocated chip.longlong3"""
        cdef chip.longlong3* ptr
        longlong3.__allocate(&ptr)
        return longlong3.from_ptr(ptr, owner=True)
   
    def __init__(self,*args,**kwargs):
        longlong3.__allocate(&self._ptr)
        self.ptr_owner = True
        attribs = self.PROPERTIES()
        used_attribs = set()
        if len(args) > len(attribs):
            raise ValueError("More positional arguments specified than this type has properties.")
        for i,v in enumerate(args):
            setattr(self,attribs[i],v)
            used_attribs.add(attribs[i])
        valid_names = ", ".join(["'"+p+"'" for p in attribs])
        for k,v in kwargs.items():
            if k in used_attribs:
                raise KeyError(f"argument '{k}' has already been specified as positional argument.")
            elif k not in attribs:
                raise KeyError(f"'{k}' is no valid property name. Valid names: {valid_names}")
            setattr(self,k,v)
    
    def __int__(self):
        """Returns the data's address as long integer."""
        return cpython.long.PyLong_FromVoidPtr(self._ptr)
    def __repr__(self):
        return f"<longlong3 object, self.ptr={int(self)}>"
    def as_c_void_p(self):
        """Returns the data's address as `ctypes.c_void_p`"""
        return ctypes.c_void_p(int(self))
    def get_x(self, i):
        """Get value ``x`` of ``self._ptr[i]``.
        """
        return self._ptr[i].x
    def set_x(self, i, long long value):
        """Set value ``x`` of ``self._ptr[i]``.
        """
        self._ptr[i].x = value
    @property
    def x(self):
        return self.get_x(0)
    @x.setter
    def x(self, long long value):
        self.set_x(0,value)

    def get_y(self, i):
        """Get value ``y`` of ``self._ptr[i]``.
        """
        return self._ptr[i].y
    def set_y(self, i, long long value):
        """Set value ``y`` of ``self._ptr[i]``.
        """
        self._ptr[i].y = value
    @property
    def y(self):
        return self.get_y(0)
    @y.setter
    def y(self, long long value):
        self.set_y(0,value)

    def get_z(self, i):
        """Get value ``z`` of ``self._ptr[i]``.
        """
        return self._ptr[i].z
    def set_z(self, i, long long value):
        """Set value ``z`` of ``self._ptr[i]``.
        """
        self._ptr[i].z = value
    @property
    def z(self):
        return self.get_z(0)
    @z.setter
    def z(self, long long value):
        self.set_z(0,value)

    @staticmethod
    def PROPERTIES():
        return ["x","y","z"]

    def __contains__(self,item):
        properties = self.PROPERTIES()
        return item in properties

    def __getitem__(self,item):
        properties = self.PROPERTIES()
        if isinstance(item,int):
            if item < 0 or item >= len(properties):
                raise IndexError()
            return getattr(self,properties[item])
        raise ValueError("'item' type must be 'int'")


cdef class longlong4:
    # members declared in pxd file

    def __cinit__(self):
        self._ptr = NULL
        self.ptr_owner = False
        self._py_buffer_acquired = False

    @staticmethod
    cdef longlong4 from_ptr(chip.longlong4* ptr, bint owner=False):
        """Factory function to create ``longlong4`` objects from
        given ``chip.longlong4`` pointer.

        Setting ``owner`` flag to ``True`` causes
        the extension type to ``free`` the structure pointed to by ``ptr``
        when the wrapper object is deallocated.
        """
        # Fast call to __new__() that bypasses the __init__() constructor.
        cdef longlong4 wrapper = longlong4.__new__(longlong4)
        wrapper._ptr = ptr
        wrapper.ptr_owner = owner
        return wrapper

    @staticmethod
    cdef longlong4 from_pyobj(object pyobj):
        """Derives a longlong4 from a Python object.

        Derives a longlong4 from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``longlong4`` reference, this method
        returns it directly. No new ``longlong4`` is created in this case.

        Args:
            pyobj (object): Must be either ``None``, a simple, contiguous buffer according to the buffer protocol,
                            or of type ``longlong4``, ``int``, or ``ctypes.c_void_p``

        Note:
            This routine does not perform a copy but returns the original ``pyobj``
            if ``pyobj`` is an instance of longlong4!
        """
        cdef longlong4 wrapper = longlong4.__new__(longlong4)
        cdef dict cuda_array_interface = getattr(pyobj, "__cuda_array_interface__", None)

        if pyobj is None:
            wrapper._ptr = NULL
        elif isinstance(pyobj,longlong4):
            return pyobj
        elif isinstance(pyobj,int):
            wrapper._ptr = <chip.longlong4*>cpython.long.PyLong_AsVoidPtr(pyobj)
        elif isinstance(pyobj,ctypes.c_void_p):
            wrapper._ptr = <chip.longlong4*>cpython.long.PyLong_AsVoidPtr(pyobj.value) if pyobj.value != None else NULL
        elif cuda_array_interface != None:
            if not "data" in cuda_array_interface:
                raise ValueError("input object has '__cuda_array_interface__' attribute but the dict has no 'data' key")
            ptr_as_int = cuda_array_interface["data"][0]
            wrapper._ptr = <chip.longlong4*>cpython.long.PyLong_AsVoidPtr(ptr_as_int)
        elif cpython.buffer.PyObject_CheckBuffer(pyobj):
            err = cpython.buffer.PyObject_GetBuffer( 
                pyobj,
                &wrapper._py_buffer, 
                cpython.buffer.PyBUF_SIMPLE | cpython.buffer.PyBUF_ANY_CONTIGUOUS
            )
            if err == -1:
                raise RuntimeError("failed to create simple, contiguous Py_buffer from Python object")
            wrapper._py_buffer_acquired = True
            wrapper._ptr = <chip.longlong4*>wrapper._py_buffer.buf
        else:
            raise TypeError(f"unsupported input type: '{str(type(pyobj))}'")
        return wrapper
    def __dealloc__(self):
        # Release the buffer handle
        if self._py_buffer_acquired is True:
            cpython.buffer.PyBuffer_Release(&self._py_buffer)
        # De-allocate if not null and flag is set
        if self._ptr is not NULL and self.ptr_owner is True:
            stdlib.free(self._ptr)
            self._ptr = NULL
    @staticmethod
    cdef __allocate(chip.longlong4** ptr):
        ptr[0] = <chip.longlong4*>stdlib.malloc(sizeof(chip.longlong4))

        if ptr[0] is NULL:
            raise MemoryError
        # TODO init values, if present

    @staticmethod
    cdef longlong4 new():
        """Factory function to create longlong4 objects with
        newly allocated chip.longlong4"""
        cdef chip.longlong4* ptr
        longlong4.__allocate(&ptr)
        return longlong4.from_ptr(ptr, owner=True)
   
    def __init__(self,*args,**kwargs):
        longlong4.__allocate(&self._ptr)
        self.ptr_owner = True
        attribs = self.PROPERTIES()
        used_attribs = set()
        if len(args) > len(attribs):
            raise ValueError("More positional arguments specified than this type has properties.")
        for i,v in enumerate(args):
            setattr(self,attribs[i],v)
            used_attribs.add(attribs[i])
        valid_names = ", ".join(["'"+p+"'" for p in attribs])
        for k,v in kwargs.items():
            if k in used_attribs:
                raise KeyError(f"argument '{k}' has already been specified as positional argument.")
            elif k not in attribs:
                raise KeyError(f"'{k}' is no valid property name. Valid names: {valid_names}")
            setattr(self,k,v)
    
    def __int__(self):
        """Returns the data's address as long integer."""
        return cpython.long.PyLong_FromVoidPtr(self._ptr)
    def __repr__(self):
        return f"<longlong4 object, self.ptr={int(self)}>"
    def as_c_void_p(self):
        """Returns the data's address as `ctypes.c_void_p`"""
        return ctypes.c_void_p(int(self))
    def get_x(self, i):
        """Get value ``x`` of ``self._ptr[i]``.
        """
        return self._ptr[i].x
    def set_x(self, i, long long value):
        """Set value ``x`` of ``self._ptr[i]``.
        """
        self._ptr[i].x = value
    @property
    def x(self):
        return self.get_x(0)
    @x.setter
    def x(self, long long value):
        self.set_x(0,value)

    def get_y(self, i):
        """Get value ``y`` of ``self._ptr[i]``.
        """
        return self._ptr[i].y
    def set_y(self, i, long long value):
        """Set value ``y`` of ``self._ptr[i]``.
        """
        self._ptr[i].y = value
    @property
    def y(self):
        return self.get_y(0)
    @y.setter
    def y(self, long long value):
        self.set_y(0,value)

    def get_z(self, i):
        """Get value ``z`` of ``self._ptr[i]``.
        """
        return self._ptr[i].z
    def set_z(self, i, long long value):
        """Set value ``z`` of ``self._ptr[i]``.
        """
        self._ptr[i].z = value
    @property
    def z(self):
        return self.get_z(0)
    @z.setter
    def z(self, long long value):
        self.set_z(0,value)

    def get_w(self, i):
        """Get value ``w`` of ``self._ptr[i]``.
        """
        return self._ptr[i].w
    def set_w(self, i, long long value):
        """Set value ``w`` of ``self._ptr[i]``.
        """
        self._ptr[i].w = value
    @property
    def w(self):
        return self.get_w(0)
    @w.setter
    def w(self, long long value):
        self.set_w(0,value)

    @staticmethod
    def PROPERTIES():
        return ["x","y","z","w"]

    def __contains__(self,item):
        properties = self.PROPERTIES()
        return item in properties

    def __getitem__(self,item):
        properties = self.PROPERTIES()
        if isinstance(item,int):
            if item < 0 or item >= len(properties):
                raise IndexError()
            return getattr(self,properties[item])
        raise ValueError("'item' type must be 'int'")


cdef class float1:
    # members declared in pxd file

    def __cinit__(self):
        self._ptr = NULL
        self.ptr_owner = False
        self._py_buffer_acquired = False

    @staticmethod
    cdef float1 from_ptr(chip.float1* ptr, bint owner=False):
        """Factory function to create ``float1`` objects from
        given ``chip.float1`` pointer.

        Setting ``owner`` flag to ``True`` causes
        the extension type to ``free`` the structure pointed to by ``ptr``
        when the wrapper object is deallocated.
        """
        # Fast call to __new__() that bypasses the __init__() constructor.
        cdef float1 wrapper = float1.__new__(float1)
        wrapper._ptr = ptr
        wrapper.ptr_owner = owner
        return wrapper

    @staticmethod
    cdef float1 from_pyobj(object pyobj):
        """Derives a float1 from a Python object.

        Derives a float1 from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``float1`` reference, this method
        returns it directly. No new ``float1`` is created in this case.

        Args:
            pyobj (object): Must be either ``None``, a simple, contiguous buffer according to the buffer protocol,
                            or of type ``float1``, ``int``, or ``ctypes.c_void_p``

        Note:
            This routine does not perform a copy but returns the original ``pyobj``
            if ``pyobj`` is an instance of float1!
        """
        cdef float1 wrapper = float1.__new__(float1)
        cdef dict cuda_array_interface = getattr(pyobj, "__cuda_array_interface__", None)

        if pyobj is None:
            wrapper._ptr = NULL
        elif isinstance(pyobj,float1):
            return pyobj
        elif isinstance(pyobj,int):
            wrapper._ptr = <chip.float1*>cpython.long.PyLong_AsVoidPtr(pyobj)
        elif isinstance(pyobj,ctypes.c_void_p):
            wrapper._ptr = <chip.float1*>cpython.long.PyLong_AsVoidPtr(pyobj.value) if pyobj.value != None else NULL
        elif cuda_array_interface != None:
            if not "data" in cuda_array_interface:
                raise ValueError("input object has '__cuda_array_interface__' attribute but the dict has no 'data' key")
            ptr_as_int = cuda_array_interface["data"][0]
            wrapper._ptr = <chip.float1*>cpython.long.PyLong_AsVoidPtr(ptr_as_int)
        elif cpython.buffer.PyObject_CheckBuffer(pyobj):
            err = cpython.buffer.PyObject_GetBuffer( 
                pyobj,
                &wrapper._py_buffer, 
                cpython.buffer.PyBUF_SIMPLE | cpython.buffer.PyBUF_ANY_CONTIGUOUS
            )
            if err == -1:
                raise RuntimeError("failed to create simple, contiguous Py_buffer from Python object")
            wrapper._py_buffer_acquired = True
            wrapper._ptr = <chip.float1*>wrapper._py_buffer.buf
        else:
            raise TypeError(f"unsupported input type: '{str(type(pyobj))}'")
        return wrapper
    def __dealloc__(self):
        # Release the buffer handle
        if self._py_buffer_acquired is True:
            cpython.buffer.PyBuffer_Release(&self._py_buffer)
        # De-allocate if not null and flag is set
        if self._ptr is not NULL and self.ptr_owner is True:
            stdlib.free(self._ptr)
            self._ptr = NULL
    @staticmethod
    cdef __allocate(chip.float1** ptr):
        ptr[0] = <chip.float1*>stdlib.malloc(sizeof(chip.float1))

        if ptr[0] is NULL:
            raise MemoryError
        # TODO init values, if present

    @staticmethod
    cdef float1 new():
        """Factory function to create float1 objects with
        newly allocated chip.float1"""
        cdef chip.float1* ptr
        float1.__allocate(&ptr)
        return float1.from_ptr(ptr, owner=True)
   
    def __init__(self,*args,**kwargs):
        float1.__allocate(&self._ptr)
        self.ptr_owner = True
        attribs = self.PROPERTIES()
        used_attribs = set()
        if len(args) > len(attribs):
            raise ValueError("More positional arguments specified than this type has properties.")
        for i,v in enumerate(args):
            setattr(self,attribs[i],v)
            used_attribs.add(attribs[i])
        valid_names = ", ".join(["'"+p+"'" for p in attribs])
        for k,v in kwargs.items():
            if k in used_attribs:
                raise KeyError(f"argument '{k}' has already been specified as positional argument.")
            elif k not in attribs:
                raise KeyError(f"'{k}' is no valid property name. Valid names: {valid_names}")
            setattr(self,k,v)
    
    def __int__(self):
        """Returns the data's address as long integer."""
        return cpython.long.PyLong_FromVoidPtr(self._ptr)
    def __repr__(self):
        return f"<float1 object, self.ptr={int(self)}>"
    def as_c_void_p(self):
        """Returns the data's address as `ctypes.c_void_p`"""
        return ctypes.c_void_p(int(self))
    def get_x(self, i):
        """Get value ``x`` of ``self._ptr[i]``.
        """
        return self._ptr[i].x
    def set_x(self, i, float value):
        """Set value ``x`` of ``self._ptr[i]``.
        """
        self._ptr[i].x = value
    @property
    def x(self):
        return self.get_x(0)
    @x.setter
    def x(self, float value):
        self.set_x(0,value)

    @staticmethod
    def PROPERTIES():
        return ["x"]

    def __contains__(self,item):
        properties = self.PROPERTIES()
        return item in properties

    def __getitem__(self,item):
        properties = self.PROPERTIES()
        if isinstance(item,int):
            if item < 0 or item >= len(properties):
                raise IndexError()
            return getattr(self,properties[item])
        raise ValueError("'item' type must be 'int'")


cdef class float2:
    # members declared in pxd file

    def __cinit__(self):
        self._ptr = NULL
        self.ptr_owner = False
        self._py_buffer_acquired = False

    @staticmethod
    cdef float2 from_ptr(chip.float2* ptr, bint owner=False):
        """Factory function to create ``float2`` objects from
        given ``chip.float2`` pointer.

        Setting ``owner`` flag to ``True`` causes
        the extension type to ``free`` the structure pointed to by ``ptr``
        when the wrapper object is deallocated.
        """
        # Fast call to __new__() that bypasses the __init__() constructor.
        cdef float2 wrapper = float2.__new__(float2)
        wrapper._ptr = ptr
        wrapper.ptr_owner = owner
        return wrapper

    @staticmethod
    cdef float2 from_pyobj(object pyobj):
        """Derives a float2 from a Python object.

        Derives a float2 from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``float2`` reference, this method
        returns it directly. No new ``float2`` is created in this case.

        Args:
            pyobj (object): Must be either ``None``, a simple, contiguous buffer according to the buffer protocol,
                            or of type ``float2``, ``int``, or ``ctypes.c_void_p``

        Note:
            This routine does not perform a copy but returns the original ``pyobj``
            if ``pyobj`` is an instance of float2!
        """
        cdef float2 wrapper = float2.__new__(float2)
        cdef dict cuda_array_interface = getattr(pyobj, "__cuda_array_interface__", None)

        if pyobj is None:
            wrapper._ptr = NULL
        elif isinstance(pyobj,float2):
            return pyobj
        elif isinstance(pyobj,int):
            wrapper._ptr = <chip.float2*>cpython.long.PyLong_AsVoidPtr(pyobj)
        elif isinstance(pyobj,ctypes.c_void_p):
            wrapper._ptr = <chip.float2*>cpython.long.PyLong_AsVoidPtr(pyobj.value) if pyobj.value != None else NULL
        elif cuda_array_interface != None:
            if not "data" in cuda_array_interface:
                raise ValueError("input object has '__cuda_array_interface__' attribute but the dict has no 'data' key")
            ptr_as_int = cuda_array_interface["data"][0]
            wrapper._ptr = <chip.float2*>cpython.long.PyLong_AsVoidPtr(ptr_as_int)
        elif cpython.buffer.PyObject_CheckBuffer(pyobj):
            err = cpython.buffer.PyObject_GetBuffer( 
                pyobj,
                &wrapper._py_buffer, 
                cpython.buffer.PyBUF_SIMPLE | cpython.buffer.PyBUF_ANY_CONTIGUOUS
            )
            if err == -1:
                raise RuntimeError("failed to create simple, contiguous Py_buffer from Python object")
            wrapper._py_buffer_acquired = True
            wrapper._ptr = <chip.float2*>wrapper._py_buffer.buf
        else:
            raise TypeError(f"unsupported input type: '{str(type(pyobj))}'")
        return wrapper
    def __dealloc__(self):
        # Release the buffer handle
        if self._py_buffer_acquired is True:
            cpython.buffer.PyBuffer_Release(&self._py_buffer)
        # De-allocate if not null and flag is set
        if self._ptr is not NULL and self.ptr_owner is True:
            stdlib.free(self._ptr)
            self._ptr = NULL
    @staticmethod
    cdef __allocate(chip.float2** ptr):
        ptr[0] = <chip.float2*>stdlib.malloc(sizeof(chip.float2))

        if ptr[0] is NULL:
            raise MemoryError
        # TODO init values, if present

    @staticmethod
    cdef float2 new():
        """Factory function to create float2 objects with
        newly allocated chip.float2"""
        cdef chip.float2* ptr
        float2.__allocate(&ptr)
        return float2.from_ptr(ptr, owner=True)
   
    def __init__(self,*args,**kwargs):
        float2.__allocate(&self._ptr)
        self.ptr_owner = True
        attribs = self.PROPERTIES()
        used_attribs = set()
        if len(args) > len(attribs):
            raise ValueError("More positional arguments specified than this type has properties.")
        for i,v in enumerate(args):
            setattr(self,attribs[i],v)
            used_attribs.add(attribs[i])
        valid_names = ", ".join(["'"+p+"'" for p in attribs])
        for k,v in kwargs.items():
            if k in used_attribs:
                raise KeyError(f"argument '{k}' has already been specified as positional argument.")
            elif k not in attribs:
                raise KeyError(f"'{k}' is no valid property name. Valid names: {valid_names}")
            setattr(self,k,v)
    
    def __int__(self):
        """Returns the data's address as long integer."""
        return cpython.long.PyLong_FromVoidPtr(self._ptr)
    def __repr__(self):
        return f"<float2 object, self.ptr={int(self)}>"
    def as_c_void_p(self):
        """Returns the data's address as `ctypes.c_void_p`"""
        return ctypes.c_void_p(int(self))
    def get_x(self, i):
        """Get value ``x`` of ``self._ptr[i]``.
        """
        return self._ptr[i].x
    def set_x(self, i, float value):
        """Set value ``x`` of ``self._ptr[i]``.
        """
        self._ptr[i].x = value
    @property
    def x(self):
        return self.get_x(0)
    @x.setter
    def x(self, float value):
        self.set_x(0,value)

    def get_y(self, i):
        """Get value ``y`` of ``self._ptr[i]``.
        """
        return self._ptr[i].y
    def set_y(self, i, float value):
        """Set value ``y`` of ``self._ptr[i]``.
        """
        self._ptr[i].y = value
    @property
    def y(self):
        return self.get_y(0)
    @y.setter
    def y(self, float value):
        self.set_y(0,value)

    @staticmethod
    def PROPERTIES():
        return ["x","y"]

    def __contains__(self,item):
        properties = self.PROPERTIES()
        return item in properties

    def __getitem__(self,item):
        properties = self.PROPERTIES()
        if isinstance(item,int):
            if item < 0 or item >= len(properties):
                raise IndexError()
            return getattr(self,properties[item])
        raise ValueError("'item' type must be 'int'")


cdef class float3:
    # members declared in pxd file

    def __cinit__(self):
        self._ptr = NULL
        self.ptr_owner = False
        self._py_buffer_acquired = False

    @staticmethod
    cdef float3 from_ptr(chip.float3* ptr, bint owner=False):
        """Factory function to create ``float3`` objects from
        given ``chip.float3`` pointer.

        Setting ``owner`` flag to ``True`` causes
        the extension type to ``free`` the structure pointed to by ``ptr``
        when the wrapper object is deallocated.
        """
        # Fast call to __new__() that bypasses the __init__() constructor.
        cdef float3 wrapper = float3.__new__(float3)
        wrapper._ptr = ptr
        wrapper.ptr_owner = owner
        return wrapper

    @staticmethod
    cdef float3 from_pyobj(object pyobj):
        """Derives a float3 from a Python object.

        Derives a float3 from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``float3`` reference, this method
        returns it directly. No new ``float3`` is created in this case.

        Args:
            pyobj (object): Must be either ``None``, a simple, contiguous buffer according to the buffer protocol,
                            or of type ``float3``, ``int``, or ``ctypes.c_void_p``

        Note:
            This routine does not perform a copy but returns the original ``pyobj``
            if ``pyobj`` is an instance of float3!
        """
        cdef float3 wrapper = float3.__new__(float3)
        cdef dict cuda_array_interface = getattr(pyobj, "__cuda_array_interface__", None)

        if pyobj is None:
            wrapper._ptr = NULL
        elif isinstance(pyobj,float3):
            return pyobj
        elif isinstance(pyobj,int):
            wrapper._ptr = <chip.float3*>cpython.long.PyLong_AsVoidPtr(pyobj)
        elif isinstance(pyobj,ctypes.c_void_p):
            wrapper._ptr = <chip.float3*>cpython.long.PyLong_AsVoidPtr(pyobj.value) if pyobj.value != None else NULL
        elif cuda_array_interface != None:
            if not "data" in cuda_array_interface:
                raise ValueError("input object has '__cuda_array_interface__' attribute but the dict has no 'data' key")
            ptr_as_int = cuda_array_interface["data"][0]
            wrapper._ptr = <chip.float3*>cpython.long.PyLong_AsVoidPtr(ptr_as_int)
        elif cpython.buffer.PyObject_CheckBuffer(pyobj):
            err = cpython.buffer.PyObject_GetBuffer( 
                pyobj,
                &wrapper._py_buffer, 
                cpython.buffer.PyBUF_SIMPLE | cpython.buffer.PyBUF_ANY_CONTIGUOUS
            )
            if err == -1:
                raise RuntimeError("failed to create simple, contiguous Py_buffer from Python object")
            wrapper._py_buffer_acquired = True
            wrapper._ptr = <chip.float3*>wrapper._py_buffer.buf
        else:
            raise TypeError(f"unsupported input type: '{str(type(pyobj))}'")
        return wrapper
    def __dealloc__(self):
        # Release the buffer handle
        if self._py_buffer_acquired is True:
            cpython.buffer.PyBuffer_Release(&self._py_buffer)
        # De-allocate if not null and flag is set
        if self._ptr is not NULL and self.ptr_owner is True:
            stdlib.free(self._ptr)
            self._ptr = NULL
    @staticmethod
    cdef __allocate(chip.float3** ptr):
        ptr[0] = <chip.float3*>stdlib.malloc(sizeof(chip.float3))

        if ptr[0] is NULL:
            raise MemoryError
        # TODO init values, if present

    @staticmethod
    cdef float3 new():
        """Factory function to create float3 objects with
        newly allocated chip.float3"""
        cdef chip.float3* ptr
        float3.__allocate(&ptr)
        return float3.from_ptr(ptr, owner=True)
   
    def __init__(self,*args,**kwargs):
        float3.__allocate(&self._ptr)
        self.ptr_owner = True
        attribs = self.PROPERTIES()
        used_attribs = set()
        if len(args) > len(attribs):
            raise ValueError("More positional arguments specified than this type has properties.")
        for i,v in enumerate(args):
            setattr(self,attribs[i],v)
            used_attribs.add(attribs[i])
        valid_names = ", ".join(["'"+p+"'" for p in attribs])
        for k,v in kwargs.items():
            if k in used_attribs:
                raise KeyError(f"argument '{k}' has already been specified as positional argument.")
            elif k not in attribs:
                raise KeyError(f"'{k}' is no valid property name. Valid names: {valid_names}")
            setattr(self,k,v)
    
    def __int__(self):
        """Returns the data's address as long integer."""
        return cpython.long.PyLong_FromVoidPtr(self._ptr)
    def __repr__(self):
        return f"<float3 object, self.ptr={int(self)}>"
    def as_c_void_p(self):
        """Returns the data's address as `ctypes.c_void_p`"""
        return ctypes.c_void_p(int(self))
    def get_x(self, i):
        """Get value ``x`` of ``self._ptr[i]``.
        """
        return self._ptr[i].x
    def set_x(self, i, float value):
        """Set value ``x`` of ``self._ptr[i]``.
        """
        self._ptr[i].x = value
    @property
    def x(self):
        return self.get_x(0)
    @x.setter
    def x(self, float value):
        self.set_x(0,value)

    def get_y(self, i):
        """Get value ``y`` of ``self._ptr[i]``.
        """
        return self._ptr[i].y
    def set_y(self, i, float value):
        """Set value ``y`` of ``self._ptr[i]``.
        """
        self._ptr[i].y = value
    @property
    def y(self):
        return self.get_y(0)
    @y.setter
    def y(self, float value):
        self.set_y(0,value)

    def get_z(self, i):
        """Get value ``z`` of ``self._ptr[i]``.
        """
        return self._ptr[i].z
    def set_z(self, i, float value):
        """Set value ``z`` of ``self._ptr[i]``.
        """
        self._ptr[i].z = value
    @property
    def z(self):
        return self.get_z(0)
    @z.setter
    def z(self, float value):
        self.set_z(0,value)

    @staticmethod
    def PROPERTIES():
        return ["x","y","z"]

    def __contains__(self,item):
        properties = self.PROPERTIES()
        return item in properties

    def __getitem__(self,item):
        properties = self.PROPERTIES()
        if isinstance(item,int):
            if item < 0 or item >= len(properties):
                raise IndexError()
            return getattr(self,properties[item])
        raise ValueError("'item' type must be 'int'")


cdef class float4:
    # members declared in pxd file

    def __cinit__(self):
        self._ptr = NULL
        self.ptr_owner = False
        self._py_buffer_acquired = False

    @staticmethod
    cdef float4 from_ptr(chip.float4* ptr, bint owner=False):
        """Factory function to create ``float4`` objects from
        given ``chip.float4`` pointer.

        Setting ``owner`` flag to ``True`` causes
        the extension type to ``free`` the structure pointed to by ``ptr``
        when the wrapper object is deallocated.
        """
        # Fast call to __new__() that bypasses the __init__() constructor.
        cdef float4 wrapper = float4.__new__(float4)
        wrapper._ptr = ptr
        wrapper.ptr_owner = owner
        return wrapper

    @staticmethod
    cdef float4 from_pyobj(object pyobj):
        """Derives a float4 from a Python object.

        Derives a float4 from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``float4`` reference, this method
        returns it directly. No new ``float4`` is created in this case.

        Args:
            pyobj (object): Must be either ``None``, a simple, contiguous buffer according to the buffer protocol,
                            or of type ``float4``, ``int``, or ``ctypes.c_void_p``

        Note:
            This routine does not perform a copy but returns the original ``pyobj``
            if ``pyobj`` is an instance of float4!
        """
        cdef float4 wrapper = float4.__new__(float4)
        cdef dict cuda_array_interface = getattr(pyobj, "__cuda_array_interface__", None)

        if pyobj is None:
            wrapper._ptr = NULL
        elif isinstance(pyobj,float4):
            return pyobj
        elif isinstance(pyobj,int):
            wrapper._ptr = <chip.float4*>cpython.long.PyLong_AsVoidPtr(pyobj)
        elif isinstance(pyobj,ctypes.c_void_p):
            wrapper._ptr = <chip.float4*>cpython.long.PyLong_AsVoidPtr(pyobj.value) if pyobj.value != None else NULL
        elif cuda_array_interface != None:
            if not "data" in cuda_array_interface:
                raise ValueError("input object has '__cuda_array_interface__' attribute but the dict has no 'data' key")
            ptr_as_int = cuda_array_interface["data"][0]
            wrapper._ptr = <chip.float4*>cpython.long.PyLong_AsVoidPtr(ptr_as_int)
        elif cpython.buffer.PyObject_CheckBuffer(pyobj):
            err = cpython.buffer.PyObject_GetBuffer( 
                pyobj,
                &wrapper._py_buffer, 
                cpython.buffer.PyBUF_SIMPLE | cpython.buffer.PyBUF_ANY_CONTIGUOUS
            )
            if err == -1:
                raise RuntimeError("failed to create simple, contiguous Py_buffer from Python object")
            wrapper._py_buffer_acquired = True
            wrapper._ptr = <chip.float4*>wrapper._py_buffer.buf
        else:
            raise TypeError(f"unsupported input type: '{str(type(pyobj))}'")
        return wrapper
    def __dealloc__(self):
        # Release the buffer handle
        if self._py_buffer_acquired is True:
            cpython.buffer.PyBuffer_Release(&self._py_buffer)
        # De-allocate if not null and flag is set
        if self._ptr is not NULL and self.ptr_owner is True:
            stdlib.free(self._ptr)
            self._ptr = NULL
    @staticmethod
    cdef __allocate(chip.float4** ptr):
        ptr[0] = <chip.float4*>stdlib.malloc(sizeof(chip.float4))

        if ptr[0] is NULL:
            raise MemoryError
        # TODO init values, if present

    @staticmethod
    cdef float4 new():
        """Factory function to create float4 objects with
        newly allocated chip.float4"""
        cdef chip.float4* ptr
        float4.__allocate(&ptr)
        return float4.from_ptr(ptr, owner=True)
   
    def __init__(self,*args,**kwargs):
        float4.__allocate(&self._ptr)
        self.ptr_owner = True
        attribs = self.PROPERTIES()
        used_attribs = set()
        if len(args) > len(attribs):
            raise ValueError("More positional arguments specified than this type has properties.")
        for i,v in enumerate(args):
            setattr(self,attribs[i],v)
            used_attribs.add(attribs[i])
        valid_names = ", ".join(["'"+p+"'" for p in attribs])
        for k,v in kwargs.items():
            if k in used_attribs:
                raise KeyError(f"argument '{k}' has already been specified as positional argument.")
            elif k not in attribs:
                raise KeyError(f"'{k}' is no valid property name. Valid names: {valid_names}")
            setattr(self,k,v)
    
    def __int__(self):
        """Returns the data's address as long integer."""
        return cpython.long.PyLong_FromVoidPtr(self._ptr)
    def __repr__(self):
        return f"<float4 object, self.ptr={int(self)}>"
    def as_c_void_p(self):
        """Returns the data's address as `ctypes.c_void_p`"""
        return ctypes.c_void_p(int(self))
    def get_x(self, i):
        """Get value ``x`` of ``self._ptr[i]``.
        """
        return self._ptr[i].x
    def set_x(self, i, float value):
        """Set value ``x`` of ``self._ptr[i]``.
        """
        self._ptr[i].x = value
    @property
    def x(self):
        return self.get_x(0)
    @x.setter
    def x(self, float value):
        self.set_x(0,value)

    def get_y(self, i):
        """Get value ``y`` of ``self._ptr[i]``.
        """
        return self._ptr[i].y
    def set_y(self, i, float value):
        """Set value ``y`` of ``self._ptr[i]``.
        """
        self._ptr[i].y = value
    @property
    def y(self):
        return self.get_y(0)
    @y.setter
    def y(self, float value):
        self.set_y(0,value)

    def get_z(self, i):
        """Get value ``z`` of ``self._ptr[i]``.
        """
        return self._ptr[i].z
    def set_z(self, i, float value):
        """Set value ``z`` of ``self._ptr[i]``.
        """
        self._ptr[i].z = value
    @property
    def z(self):
        return self.get_z(0)
    @z.setter
    def z(self, float value):
        self.set_z(0,value)

    def get_w(self, i):
        """Get value ``w`` of ``self._ptr[i]``.
        """
        return self._ptr[i].w
    def set_w(self, i, float value):
        """Set value ``w`` of ``self._ptr[i]``.
        """
        self._ptr[i].w = value
    @property
    def w(self):
        return self.get_w(0)
    @w.setter
    def w(self, float value):
        self.set_w(0,value)

    @staticmethod
    def PROPERTIES():
        return ["x","y","z","w"]

    def __contains__(self,item):
        properties = self.PROPERTIES()
        return item in properties

    def __getitem__(self,item):
        properties = self.PROPERTIES()
        if isinstance(item,int):
            if item < 0 or item >= len(properties):
                raise IndexError()
            return getattr(self,properties[item])
        raise ValueError("'item' type must be 'int'")


cdef class double1:
    # members declared in pxd file

    def __cinit__(self):
        self._ptr = NULL
        self.ptr_owner = False
        self._py_buffer_acquired = False

    @staticmethod
    cdef double1 from_ptr(chip.double1* ptr, bint owner=False):
        """Factory function to create ``double1`` objects from
        given ``chip.double1`` pointer.

        Setting ``owner`` flag to ``True`` causes
        the extension type to ``free`` the structure pointed to by ``ptr``
        when the wrapper object is deallocated.
        """
        # Fast call to __new__() that bypasses the __init__() constructor.
        cdef double1 wrapper = double1.__new__(double1)
        wrapper._ptr = ptr
        wrapper.ptr_owner = owner
        return wrapper

    @staticmethod
    cdef double1 from_pyobj(object pyobj):
        """Derives a double1 from a Python object.

        Derives a double1 from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``double1`` reference, this method
        returns it directly. No new ``double1`` is created in this case.

        Args:
            pyobj (object): Must be either ``None``, a simple, contiguous buffer according to the buffer protocol,
                            or of type ``double1``, ``int``, or ``ctypes.c_void_p``

        Note:
            This routine does not perform a copy but returns the original ``pyobj``
            if ``pyobj`` is an instance of double1!
        """
        cdef double1 wrapper = double1.__new__(double1)
        cdef dict cuda_array_interface = getattr(pyobj, "__cuda_array_interface__", None)

        if pyobj is None:
            wrapper._ptr = NULL
        elif isinstance(pyobj,double1):
            return pyobj
        elif isinstance(pyobj,int):
            wrapper._ptr = <chip.double1*>cpython.long.PyLong_AsVoidPtr(pyobj)
        elif isinstance(pyobj,ctypes.c_void_p):
            wrapper._ptr = <chip.double1*>cpython.long.PyLong_AsVoidPtr(pyobj.value) if pyobj.value != None else NULL
        elif cuda_array_interface != None:
            if not "data" in cuda_array_interface:
                raise ValueError("input object has '__cuda_array_interface__' attribute but the dict has no 'data' key")
            ptr_as_int = cuda_array_interface["data"][0]
            wrapper._ptr = <chip.double1*>cpython.long.PyLong_AsVoidPtr(ptr_as_int)
        elif cpython.buffer.PyObject_CheckBuffer(pyobj):
            err = cpython.buffer.PyObject_GetBuffer( 
                pyobj,
                &wrapper._py_buffer, 
                cpython.buffer.PyBUF_SIMPLE | cpython.buffer.PyBUF_ANY_CONTIGUOUS
            )
            if err == -1:
                raise RuntimeError("failed to create simple, contiguous Py_buffer from Python object")
            wrapper._py_buffer_acquired = True
            wrapper._ptr = <chip.double1*>wrapper._py_buffer.buf
        else:
            raise TypeError(f"unsupported input type: '{str(type(pyobj))}'")
        return wrapper
    def __dealloc__(self):
        # Release the buffer handle
        if self._py_buffer_acquired is True:
            cpython.buffer.PyBuffer_Release(&self._py_buffer)
        # De-allocate if not null and flag is set
        if self._ptr is not NULL and self.ptr_owner is True:
            stdlib.free(self._ptr)
            self._ptr = NULL
    @staticmethod
    cdef __allocate(chip.double1** ptr):
        ptr[0] = <chip.double1*>stdlib.malloc(sizeof(chip.double1))

        if ptr[0] is NULL:
            raise MemoryError
        # TODO init values, if present

    @staticmethod
    cdef double1 new():
        """Factory function to create double1 objects with
        newly allocated chip.double1"""
        cdef chip.double1* ptr
        double1.__allocate(&ptr)
        return double1.from_ptr(ptr, owner=True)
   
    def __init__(self,*args,**kwargs):
        double1.__allocate(&self._ptr)
        self.ptr_owner = True
        attribs = self.PROPERTIES()
        used_attribs = set()
        if len(args) > len(attribs):
            raise ValueError("More positional arguments specified than this type has properties.")
        for i,v in enumerate(args):
            setattr(self,attribs[i],v)
            used_attribs.add(attribs[i])
        valid_names = ", ".join(["'"+p+"'" for p in attribs])
        for k,v in kwargs.items():
            if k in used_attribs:
                raise KeyError(f"argument '{k}' has already been specified as positional argument.")
            elif k not in attribs:
                raise KeyError(f"'{k}' is no valid property name. Valid names: {valid_names}")
            setattr(self,k,v)
    
    def __int__(self):
        """Returns the data's address as long integer."""
        return cpython.long.PyLong_FromVoidPtr(self._ptr)
    def __repr__(self):
        return f"<double1 object, self.ptr={int(self)}>"
    def as_c_void_p(self):
        """Returns the data's address as `ctypes.c_void_p`"""
        return ctypes.c_void_p(int(self))
    def get_x(self, i):
        """Get value ``x`` of ``self._ptr[i]``.
        """
        return self._ptr[i].x
    def set_x(self, i, double value):
        """Set value ``x`` of ``self._ptr[i]``.
        """
        self._ptr[i].x = value
    @property
    def x(self):
        return self.get_x(0)
    @x.setter
    def x(self, double value):
        self.set_x(0,value)

    @staticmethod
    def PROPERTIES():
        return ["x"]

    def __contains__(self,item):
        properties = self.PROPERTIES()
        return item in properties

    def __getitem__(self,item):
        properties = self.PROPERTIES()
        if isinstance(item,int):
            if item < 0 or item >= len(properties):
                raise IndexError()
            return getattr(self,properties[item])
        raise ValueError("'item' type must be 'int'")


cdef class double2:
    # members declared in pxd file

    def __cinit__(self):
        self._ptr = NULL
        self.ptr_owner = False
        self._py_buffer_acquired = False

    @staticmethod
    cdef double2 from_ptr(chip.double2* ptr, bint owner=False):
        """Factory function to create ``double2`` objects from
        given ``chip.double2`` pointer.

        Setting ``owner`` flag to ``True`` causes
        the extension type to ``free`` the structure pointed to by ``ptr``
        when the wrapper object is deallocated.
        """
        # Fast call to __new__() that bypasses the __init__() constructor.
        cdef double2 wrapper = double2.__new__(double2)
        wrapper._ptr = ptr
        wrapper.ptr_owner = owner
        return wrapper

    @staticmethod
    cdef double2 from_pyobj(object pyobj):
        """Derives a double2 from a Python object.

        Derives a double2 from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``double2`` reference, this method
        returns it directly. No new ``double2`` is created in this case.

        Args:
            pyobj (object): Must be either ``None``, a simple, contiguous buffer according to the buffer protocol,
                            or of type ``double2``, ``int``, or ``ctypes.c_void_p``

        Note:
            This routine does not perform a copy but returns the original ``pyobj``
            if ``pyobj`` is an instance of double2!
        """
        cdef double2 wrapper = double2.__new__(double2)
        cdef dict cuda_array_interface = getattr(pyobj, "__cuda_array_interface__", None)

        if pyobj is None:
            wrapper._ptr = NULL
        elif isinstance(pyobj,double2):
            return pyobj
        elif isinstance(pyobj,int):
            wrapper._ptr = <chip.double2*>cpython.long.PyLong_AsVoidPtr(pyobj)
        elif isinstance(pyobj,ctypes.c_void_p):
            wrapper._ptr = <chip.double2*>cpython.long.PyLong_AsVoidPtr(pyobj.value) if pyobj.value != None else NULL
        elif cuda_array_interface != None:
            if not "data" in cuda_array_interface:
                raise ValueError("input object has '__cuda_array_interface__' attribute but the dict has no 'data' key")
            ptr_as_int = cuda_array_interface["data"][0]
            wrapper._ptr = <chip.double2*>cpython.long.PyLong_AsVoidPtr(ptr_as_int)
        elif cpython.buffer.PyObject_CheckBuffer(pyobj):
            err = cpython.buffer.PyObject_GetBuffer( 
                pyobj,
                &wrapper._py_buffer, 
                cpython.buffer.PyBUF_SIMPLE | cpython.buffer.PyBUF_ANY_CONTIGUOUS
            )
            if err == -1:
                raise RuntimeError("failed to create simple, contiguous Py_buffer from Python object")
            wrapper._py_buffer_acquired = True
            wrapper._ptr = <chip.double2*>wrapper._py_buffer.buf
        else:
            raise TypeError(f"unsupported input type: '{str(type(pyobj))}'")
        return wrapper
    def __dealloc__(self):
        # Release the buffer handle
        if self._py_buffer_acquired is True:
            cpython.buffer.PyBuffer_Release(&self._py_buffer)
        # De-allocate if not null and flag is set
        if self._ptr is not NULL and self.ptr_owner is True:
            stdlib.free(self._ptr)
            self._ptr = NULL
    @staticmethod
    cdef __allocate(chip.double2** ptr):
        ptr[0] = <chip.double2*>stdlib.malloc(sizeof(chip.double2))

        if ptr[0] is NULL:
            raise MemoryError
        # TODO init values, if present

    @staticmethod
    cdef double2 new():
        """Factory function to create double2 objects with
        newly allocated chip.double2"""
        cdef chip.double2* ptr
        double2.__allocate(&ptr)
        return double2.from_ptr(ptr, owner=True)
   
    def __init__(self,*args,**kwargs):
        double2.__allocate(&self._ptr)
        self.ptr_owner = True
        attribs = self.PROPERTIES()
        used_attribs = set()
        if len(args) > len(attribs):
            raise ValueError("More positional arguments specified than this type has properties.")
        for i,v in enumerate(args):
            setattr(self,attribs[i],v)
            used_attribs.add(attribs[i])
        valid_names = ", ".join(["'"+p+"'" for p in attribs])
        for k,v in kwargs.items():
            if k in used_attribs:
                raise KeyError(f"argument '{k}' has already been specified as positional argument.")
            elif k not in attribs:
                raise KeyError(f"'{k}' is no valid property name. Valid names: {valid_names}")
            setattr(self,k,v)
    
    def __int__(self):
        """Returns the data's address as long integer."""
        return cpython.long.PyLong_FromVoidPtr(self._ptr)
    def __repr__(self):
        return f"<double2 object, self.ptr={int(self)}>"
    def as_c_void_p(self):
        """Returns the data's address as `ctypes.c_void_p`"""
        return ctypes.c_void_p(int(self))
    def get_x(self, i):
        """Get value ``x`` of ``self._ptr[i]``.
        """
        return self._ptr[i].x
    def set_x(self, i, double value):
        """Set value ``x`` of ``self._ptr[i]``.
        """
        self._ptr[i].x = value
    @property
    def x(self):
        return self.get_x(0)
    @x.setter
    def x(self, double value):
        self.set_x(0,value)

    def get_y(self, i):
        """Get value ``y`` of ``self._ptr[i]``.
        """
        return self._ptr[i].y
    def set_y(self, i, double value):
        """Set value ``y`` of ``self._ptr[i]``.
        """
        self._ptr[i].y = value
    @property
    def y(self):
        return self.get_y(0)
    @y.setter
    def y(self, double value):
        self.set_y(0,value)

    @staticmethod
    def PROPERTIES():
        return ["x","y"]

    def __contains__(self,item):
        properties = self.PROPERTIES()
        return item in properties

    def __getitem__(self,item):
        properties = self.PROPERTIES()
        if isinstance(item,int):
            if item < 0 or item >= len(properties):
                raise IndexError()
            return getattr(self,properties[item])
        raise ValueError("'item' type must be 'int'")


cdef class double3:
    # members declared in pxd file

    def __cinit__(self):
        self._ptr = NULL
        self.ptr_owner = False
        self._py_buffer_acquired = False

    @staticmethod
    cdef double3 from_ptr(chip.double3* ptr, bint owner=False):
        """Factory function to create ``double3`` objects from
        given ``chip.double3`` pointer.

        Setting ``owner`` flag to ``True`` causes
        the extension type to ``free`` the structure pointed to by ``ptr``
        when the wrapper object is deallocated.
        """
        # Fast call to __new__() that bypasses the __init__() constructor.
        cdef double3 wrapper = double3.__new__(double3)
        wrapper._ptr = ptr
        wrapper.ptr_owner = owner
        return wrapper

    @staticmethod
    cdef double3 from_pyobj(object pyobj):
        """Derives a double3 from a Python object.

        Derives a double3 from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``double3`` reference, this method
        returns it directly. No new ``double3`` is created in this case.

        Args:
            pyobj (object): Must be either ``None``, a simple, contiguous buffer according to the buffer protocol,
                            or of type ``double3``, ``int``, or ``ctypes.c_void_p``

        Note:
            This routine does not perform a copy but returns the original ``pyobj``
            if ``pyobj`` is an instance of double3!
        """
        cdef double3 wrapper = double3.__new__(double3)
        cdef dict cuda_array_interface = getattr(pyobj, "__cuda_array_interface__", None)

        if pyobj is None:
            wrapper._ptr = NULL
        elif isinstance(pyobj,double3):
            return pyobj
        elif isinstance(pyobj,int):
            wrapper._ptr = <chip.double3*>cpython.long.PyLong_AsVoidPtr(pyobj)
        elif isinstance(pyobj,ctypes.c_void_p):
            wrapper._ptr = <chip.double3*>cpython.long.PyLong_AsVoidPtr(pyobj.value) if pyobj.value != None else NULL
        elif cuda_array_interface != None:
            if not "data" in cuda_array_interface:
                raise ValueError("input object has '__cuda_array_interface__' attribute but the dict has no 'data' key")
            ptr_as_int = cuda_array_interface["data"][0]
            wrapper._ptr = <chip.double3*>cpython.long.PyLong_AsVoidPtr(ptr_as_int)
        elif cpython.buffer.PyObject_CheckBuffer(pyobj):
            err = cpython.buffer.PyObject_GetBuffer( 
                pyobj,
                &wrapper._py_buffer, 
                cpython.buffer.PyBUF_SIMPLE | cpython.buffer.PyBUF_ANY_CONTIGUOUS
            )
            if err == -1:
                raise RuntimeError("failed to create simple, contiguous Py_buffer from Python object")
            wrapper._py_buffer_acquired = True
            wrapper._ptr = <chip.double3*>wrapper._py_buffer.buf
        else:
            raise TypeError(f"unsupported input type: '{str(type(pyobj))}'")
        return wrapper
    def __dealloc__(self):
        # Release the buffer handle
        if self._py_buffer_acquired is True:
            cpython.buffer.PyBuffer_Release(&self._py_buffer)
        # De-allocate if not null and flag is set
        if self._ptr is not NULL and self.ptr_owner is True:
            stdlib.free(self._ptr)
            self._ptr = NULL
    @staticmethod
    cdef __allocate(chip.double3** ptr):
        ptr[0] = <chip.double3*>stdlib.malloc(sizeof(chip.double3))

        if ptr[0] is NULL:
            raise MemoryError
        # TODO init values, if present

    @staticmethod
    cdef double3 new():
        """Factory function to create double3 objects with
        newly allocated chip.double3"""
        cdef chip.double3* ptr
        double3.__allocate(&ptr)
        return double3.from_ptr(ptr, owner=True)
   
    def __init__(self,*args,**kwargs):
        double3.__allocate(&self._ptr)
        self.ptr_owner = True
        attribs = self.PROPERTIES()
        used_attribs = set()
        if len(args) > len(attribs):
            raise ValueError("More positional arguments specified than this type has properties.")
        for i,v in enumerate(args):
            setattr(self,attribs[i],v)
            used_attribs.add(attribs[i])
        valid_names = ", ".join(["'"+p+"'" for p in attribs])
        for k,v in kwargs.items():
            if k in used_attribs:
                raise KeyError(f"argument '{k}' has already been specified as positional argument.")
            elif k not in attribs:
                raise KeyError(f"'{k}' is no valid property name. Valid names: {valid_names}")
            setattr(self,k,v)
    
    def __int__(self):
        """Returns the data's address as long integer."""
        return cpython.long.PyLong_FromVoidPtr(self._ptr)
    def __repr__(self):
        return f"<double3 object, self.ptr={int(self)}>"
    def as_c_void_p(self):
        """Returns the data's address as `ctypes.c_void_p`"""
        return ctypes.c_void_p(int(self))
    def get_x(self, i):
        """Get value ``x`` of ``self._ptr[i]``.
        """
        return self._ptr[i].x
    def set_x(self, i, double value):
        """Set value ``x`` of ``self._ptr[i]``.
        """
        self._ptr[i].x = value
    @property
    def x(self):
        return self.get_x(0)
    @x.setter
    def x(self, double value):
        self.set_x(0,value)

    def get_y(self, i):
        """Get value ``y`` of ``self._ptr[i]``.
        """
        return self._ptr[i].y
    def set_y(self, i, double value):
        """Set value ``y`` of ``self._ptr[i]``.
        """
        self._ptr[i].y = value
    @property
    def y(self):
        return self.get_y(0)
    @y.setter
    def y(self, double value):
        self.set_y(0,value)

    def get_z(self, i):
        """Get value ``z`` of ``self._ptr[i]``.
        """
        return self._ptr[i].z
    def set_z(self, i, double value):
        """Set value ``z`` of ``self._ptr[i]``.
        """
        self._ptr[i].z = value
    @property
    def z(self):
        return self.get_z(0)
    @z.setter
    def z(self, double value):
        self.set_z(0,value)

    @staticmethod
    def PROPERTIES():
        return ["x","y","z"]

    def __contains__(self,item):
        properties = self.PROPERTIES()
        return item in properties

    def __getitem__(self,item):
        properties = self.PROPERTIES()
        if isinstance(item,int):
            if item < 0 or item >= len(properties):
                raise IndexError()
            return getattr(self,properties[item])
        raise ValueError("'item' type must be 'int'")


cdef class double4:
    # members declared in pxd file

    def __cinit__(self):
        self._ptr = NULL
        self.ptr_owner = False
        self._py_buffer_acquired = False

    @staticmethod
    cdef double4 from_ptr(chip.double4* ptr, bint owner=False):
        """Factory function to create ``double4`` objects from
        given ``chip.double4`` pointer.

        Setting ``owner`` flag to ``True`` causes
        the extension type to ``free`` the structure pointed to by ``ptr``
        when the wrapper object is deallocated.
        """
        # Fast call to __new__() that bypasses the __init__() constructor.
        cdef double4 wrapper = double4.__new__(double4)
        wrapper._ptr = ptr
        wrapper.ptr_owner = owner
        return wrapper

    @staticmethod
    cdef double4 from_pyobj(object pyobj):
        """Derives a double4 from a Python object.

        Derives a double4 from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``double4`` reference, this method
        returns it directly. No new ``double4`` is created in this case.

        Args:
            pyobj (object): Must be either ``None``, a simple, contiguous buffer according to the buffer protocol,
                            or of type ``double4``, ``int``, or ``ctypes.c_void_p``

        Note:
            This routine does not perform a copy but returns the original ``pyobj``
            if ``pyobj`` is an instance of double4!
        """
        cdef double4 wrapper = double4.__new__(double4)
        cdef dict cuda_array_interface = getattr(pyobj, "__cuda_array_interface__", None)

        if pyobj is None:
            wrapper._ptr = NULL
        elif isinstance(pyobj,double4):
            return pyobj
        elif isinstance(pyobj,int):
            wrapper._ptr = <chip.double4*>cpython.long.PyLong_AsVoidPtr(pyobj)
        elif isinstance(pyobj,ctypes.c_void_p):
            wrapper._ptr = <chip.double4*>cpython.long.PyLong_AsVoidPtr(pyobj.value) if pyobj.value != None else NULL
        elif cuda_array_interface != None:
            if not "data" in cuda_array_interface:
                raise ValueError("input object has '__cuda_array_interface__' attribute but the dict has no 'data' key")
            ptr_as_int = cuda_array_interface["data"][0]
            wrapper._ptr = <chip.double4*>cpython.long.PyLong_AsVoidPtr(ptr_as_int)
        elif cpython.buffer.PyObject_CheckBuffer(pyobj):
            err = cpython.buffer.PyObject_GetBuffer( 
                pyobj,
                &wrapper._py_buffer, 
                cpython.buffer.PyBUF_SIMPLE | cpython.buffer.PyBUF_ANY_CONTIGUOUS
            )
            if err == -1:
                raise RuntimeError("failed to create simple, contiguous Py_buffer from Python object")
            wrapper._py_buffer_acquired = True
            wrapper._ptr = <chip.double4*>wrapper._py_buffer.buf
        else:
            raise TypeError(f"unsupported input type: '{str(type(pyobj))}'")
        return wrapper
    def __dealloc__(self):
        # Release the buffer handle
        if self._py_buffer_acquired is True:
            cpython.buffer.PyBuffer_Release(&self._py_buffer)
        # De-allocate if not null and flag is set
        if self._ptr is not NULL and self.ptr_owner is True:
            stdlib.free(self._ptr)
            self._ptr = NULL
    @staticmethod
    cdef __allocate(chip.double4** ptr):
        ptr[0] = <chip.double4*>stdlib.malloc(sizeof(chip.double4))

        if ptr[0] is NULL:
            raise MemoryError
        # TODO init values, if present

    @staticmethod
    cdef double4 new():
        """Factory function to create double4 objects with
        newly allocated chip.double4"""
        cdef chip.double4* ptr
        double4.__allocate(&ptr)
        return double4.from_ptr(ptr, owner=True)
   
    def __init__(self,*args,**kwargs):
        double4.__allocate(&self._ptr)
        self.ptr_owner = True
        attribs = self.PROPERTIES()
        used_attribs = set()
        if len(args) > len(attribs):
            raise ValueError("More positional arguments specified than this type has properties.")
        for i,v in enumerate(args):
            setattr(self,attribs[i],v)
            used_attribs.add(attribs[i])
        valid_names = ", ".join(["'"+p+"'" for p in attribs])
        for k,v in kwargs.items():
            if k in used_attribs:
                raise KeyError(f"argument '{k}' has already been specified as positional argument.")
            elif k not in attribs:
                raise KeyError(f"'{k}' is no valid property name. Valid names: {valid_names}")
            setattr(self,k,v)
    
    def __int__(self):
        """Returns the data's address as long integer."""
        return cpython.long.PyLong_FromVoidPtr(self._ptr)
    def __repr__(self):
        return f"<double4 object, self.ptr={int(self)}>"
    def as_c_void_p(self):
        """Returns the data's address as `ctypes.c_void_p`"""
        return ctypes.c_void_p(int(self))
    def get_x(self, i):
        """Get value ``x`` of ``self._ptr[i]``.
        """
        return self._ptr[i].x
    def set_x(self, i, double value):
        """Set value ``x`` of ``self._ptr[i]``.
        """
        self._ptr[i].x = value
    @property
    def x(self):
        return self.get_x(0)
    @x.setter
    def x(self, double value):
        self.set_x(0,value)

    def get_y(self, i):
        """Get value ``y`` of ``self._ptr[i]``.
        """
        return self._ptr[i].y
    def set_y(self, i, double value):
        """Set value ``y`` of ``self._ptr[i]``.
        """
        self._ptr[i].y = value
    @property
    def y(self):
        return self.get_y(0)
    @y.setter
    def y(self, double value):
        self.set_y(0,value)

    def get_z(self, i):
        """Get value ``z`` of ``self._ptr[i]``.
        """
        return self._ptr[i].z
    def set_z(self, i, double value):
        """Set value ``z`` of ``self._ptr[i]``.
        """
        self._ptr[i].z = value
    @property
    def z(self):
        return self.get_z(0)
    @z.setter
    def z(self, double value):
        self.set_z(0,value)

    def get_w(self, i):
        """Get value ``w`` of ``self._ptr[i]``.
        """
        return self._ptr[i].w
    def set_w(self, i, double value):
        """Set value ``w`` of ``self._ptr[i]``.
        """
        self._ptr[i].w = value
    @property
    def w(self):
        return self.get_w(0)
    @w.setter
    def w(self, double value):
        self.set_w(0,value)

    @staticmethod
    def PROPERTIES():
        return ["x","y","z","w"]

    def __contains__(self,item):
        properties = self.PROPERTIES()
        return item in properties

    def __getitem__(self,item):
        properties = self.PROPERTIES()
        if isinstance(item,int):
            if item < 0 or item >= len(properties):
                raise IndexError()
            return getattr(self,properties[item])
        raise ValueError("'item' type must be 'int'")


@cython.embedsignature(True)
def hipCreateChannelDesc(int x, int y, int z, int w, object f):
    r"""(No short description)
    """
    if not isinstance(f,_hipChannelFormatKind__Base):
        raise TypeError("argument 'f' must be of type '_hipChannelFormatKind__Base'")
        # fully specified


cdef class __hip_texture:
    # members declared in pxd file

    def __cinit__(self):
        self._ptr = NULL
        self.ptr_owner = False
        self._py_buffer_acquired = False

    @staticmethod
    cdef __hip_texture from_ptr(chip.__hip_texture* ptr, bint owner=False):
        """Factory function to create ``__hip_texture`` objects from
        given ``chip.__hip_texture`` pointer.
        """
        # Fast call to __new__() that bypasses the __init__() constructor.
        cdef __hip_texture wrapper = __hip_texture.__new__(__hip_texture)
        wrapper._ptr = ptr
        wrapper.ptr_owner = owner
        return wrapper

    @staticmethod
    cdef __hip_texture from_pyobj(object pyobj):
        """Derives a __hip_texture from a Python object.

        Derives a __hip_texture from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``__hip_texture`` reference, this method
        returns it directly. No new ``__hip_texture`` is created in this case.

        Args:
            pyobj (object): Must be either ``None``, a simple, contiguous buffer according to the buffer protocol,
                            or of type ``__hip_texture``, ``int``, or ``ctypes.c_void_p``

        Note:
            This routine does not perform a copy but returns the original ``pyobj``
            if ``pyobj`` is an instance of __hip_texture!
        """
        cdef __hip_texture wrapper = __hip_texture.__new__(__hip_texture)
        cdef dict cuda_array_interface = getattr(pyobj, "__cuda_array_interface__", None)

        if pyobj is None:
            wrapper._ptr = NULL
        elif isinstance(pyobj,__hip_texture):
            return pyobj
        elif isinstance(pyobj,int):
            wrapper._ptr = <chip.__hip_texture*>cpython.long.PyLong_AsVoidPtr(pyobj)
        elif isinstance(pyobj,ctypes.c_void_p):
            wrapper._ptr = <chip.__hip_texture*>cpython.long.PyLong_AsVoidPtr(pyobj.value) if pyobj.value != None else NULL
        elif cuda_array_interface != None:
            if not "data" in cuda_array_interface:
                raise ValueError("input object has '__cuda_array_interface__' attribute but the dict has no 'data' key")
            ptr_as_int = cuda_array_interface["data"][0]
            wrapper._ptr = <chip.__hip_texture*>cpython.long.PyLong_AsVoidPtr(ptr_as_int)
        elif cpython.buffer.PyObject_CheckBuffer(pyobj):
            err = cpython.buffer.PyObject_GetBuffer( 
                pyobj,
                &wrapper._py_buffer, 
                cpython.buffer.PyBUF_SIMPLE | cpython.buffer.PyBUF_ANY_CONTIGUOUS
            )
            if err == -1:
                raise RuntimeError("failed to create simple, contiguous Py_buffer from Python object")
            wrapper._py_buffer_acquired = True
            wrapper._ptr = <chip.__hip_texture*>wrapper._py_buffer.buf
        else:
            raise TypeError(f"unsupported input type: '{str(type(pyobj))}'")
        return wrapper
    def __dealloc__(self):
        # Release the buffer handle
        if self._py_buffer_acquired is True:
            cpython.buffer.PyBuffer_Release(&self._py_buffer)
    
    def __int__(self):
        """Returns the data's address as long integer."""
        return cpython.long.PyLong_FromVoidPtr(self._ptr)
    def __repr__(self):
        return f"<__hip_texture object, self.ptr={int(self)}>"
    def as_c_void_p(self):
        """Returns the data's address as `ctypes.c_void_p`"""
        return ctypes.c_void_p(int(self))
    @staticmethod
    def PROPERTIES():
        return []

    def __contains__(self,item):
        properties = self.PROPERTIES()
        return item in properties

    def __getitem__(self,item):
        properties = self.PROPERTIES()
        if isinstance(item,int):
            if item < 0 or item >= len(properties):
                raise IndexError()
            return getattr(self,properties[item])
        raise ValueError("'item' type must be 'int'")


hipTextureObject_t = __hip_texture

class _hipTextureAddressMode__Base(enum.IntEnum):
    """Empty enum base class that allows subclassing.
    """
    pass
class hipTextureAddressMode(_hipTextureAddressMode__Base):
    hipAddressModeWrap = chip.hipAddressModeWrap
    hipAddressModeClamp = chip.hipAddressModeClamp
    hipAddressModeMirror = chip.hipAddressModeMirror
    hipAddressModeBorder = chip.hipAddressModeBorder
    @staticmethod
    def ctypes_type():
        """The type of the enum constants as ctypes type."""
        return ctypes.c_uint 


class _hipTextureFilterMode__Base(enum.IntEnum):
    """Empty enum base class that allows subclassing.
    """
    pass
class hipTextureFilterMode(_hipTextureFilterMode__Base):
    hipFilterModePoint = chip.hipFilterModePoint
    hipFilterModeLinear = chip.hipFilterModeLinear
    @staticmethod
    def ctypes_type():
        """The type of the enum constants as ctypes type."""
        return ctypes.c_uint 


class _hipTextureReadMode__Base(enum.IntEnum):
    """Empty enum base class that allows subclassing.
    """
    pass
class hipTextureReadMode(_hipTextureReadMode__Base):
    hipReadModeElementType = chip.hipReadModeElementType
    hipReadModeNormalizedFloat = chip.hipReadModeNormalizedFloat
    @staticmethod
    def ctypes_type():
        """The type of the enum constants as ctypes type."""
        return ctypes.c_uint 


cdef class textureReference:
    # members declared in pxd file

    def __cinit__(self):
        self._ptr = NULL
        self.ptr_owner = False
        self._py_buffer_acquired = False

    @staticmethod
    cdef textureReference from_ptr(chip.textureReference* ptr, bint owner=False):
        """Factory function to create ``textureReference`` objects from
        given ``chip.textureReference`` pointer.

        Setting ``owner`` flag to ``True`` causes
        the extension type to ``free`` the structure pointed to by ``ptr``
        when the wrapper object is deallocated.
        """
        # Fast call to __new__() that bypasses the __init__() constructor.
        cdef textureReference wrapper = textureReference.__new__(textureReference)
        wrapper._ptr = ptr
        wrapper.ptr_owner = owner
        return wrapper

    @staticmethod
    cdef textureReference from_pyobj(object pyobj):
        """Derives a textureReference from a Python object.

        Derives a textureReference from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``textureReference`` reference, this method
        returns it directly. No new ``textureReference`` is created in this case.

        Args:
            pyobj (object): Must be either ``None``, a simple, contiguous buffer according to the buffer protocol,
                            or of type ``textureReference``, ``int``, or ``ctypes.c_void_p``

        Note:
            This routine does not perform a copy but returns the original ``pyobj``
            if ``pyobj`` is an instance of textureReference!
        """
        cdef textureReference wrapper = textureReference.__new__(textureReference)
        cdef dict cuda_array_interface = getattr(pyobj, "__cuda_array_interface__", None)

        if pyobj is None:
            wrapper._ptr = NULL
        elif isinstance(pyobj,textureReference):
            return pyobj
        elif isinstance(pyobj,int):
            wrapper._ptr = <chip.textureReference*>cpython.long.PyLong_AsVoidPtr(pyobj)
        elif isinstance(pyobj,ctypes.c_void_p):
            wrapper._ptr = <chip.textureReference*>cpython.long.PyLong_AsVoidPtr(pyobj.value) if pyobj.value != None else NULL
        elif cuda_array_interface != None:
            if not "data" in cuda_array_interface:
                raise ValueError("input object has '__cuda_array_interface__' attribute but the dict has no 'data' key")
            ptr_as_int = cuda_array_interface["data"][0]
            wrapper._ptr = <chip.textureReference*>cpython.long.PyLong_AsVoidPtr(ptr_as_int)
        elif cpython.buffer.PyObject_CheckBuffer(pyobj):
            err = cpython.buffer.PyObject_GetBuffer( 
                pyobj,
                &wrapper._py_buffer, 
                cpython.buffer.PyBUF_SIMPLE | cpython.buffer.PyBUF_ANY_CONTIGUOUS
            )
            if err == -1:
                raise RuntimeError("failed to create simple, contiguous Py_buffer from Python object")
            wrapper._py_buffer_acquired = True
            wrapper._ptr = <chip.textureReference*>wrapper._py_buffer.buf
        else:
            raise TypeError(f"unsupported input type: '{str(type(pyobj))}'")
        return wrapper
    def __dealloc__(self):
        # Release the buffer handle
        if self._py_buffer_acquired is True:
            cpython.buffer.PyBuffer_Release(&self._py_buffer)
        # De-allocate if not null and flag is set
        if self._ptr is not NULL and self.ptr_owner is True:
            stdlib.free(self._ptr)
            self._ptr = NULL
    @staticmethod
    cdef __allocate(chip.textureReference** ptr):
        ptr[0] = <chip.textureReference*>stdlib.malloc(sizeof(chip.textureReference))

        if ptr[0] is NULL:
            raise MemoryError
        # TODO init values, if present

    @staticmethod
    cdef textureReference new():
        """Factory function to create textureReference objects with
        newly allocated chip.textureReference"""
        cdef chip.textureReference* ptr
        textureReference.__allocate(&ptr)
        return textureReference.from_ptr(ptr, owner=True)
   
    # False
    # False
    def __init__(self,**kwargs):
        textureReference.__allocate(&self._ptr)
        self.ptr_owner = True
        attribs = self.PROPERTIES()
        used_attribs = set()
        valid_names = ", ".join(["'"+p+"'" for p in attribs])
        for k,v in kwargs.items():
            if k in used_attribs:
                raise KeyError(f"argument '{k}' has already been specified as positional argument.")
            elif k not in attribs:
                raise KeyError(f"'{k}' is no valid property name. Valid names: {valid_names}")
            setattr(self,k,v)
    
    def __int__(self):
        """Returns the data's address as long integer."""
        return cpython.long.PyLong_FromVoidPtr(self._ptr)
    def __repr__(self):
        return f"<textureReference object, self.ptr={int(self)}>"
    def as_c_void_p(self):
        """Returns the data's address as `ctypes.c_void_p`"""
        return ctypes.c_void_p(int(self))
    def get_normalized(self, i):
        """Get value ``normalized`` of ``self._ptr[i]``.
        """
        return self._ptr[i].normalized
    def set_normalized(self, i, int value):
        """Set value ``normalized`` of ``self._ptr[i]``.
        """
        self._ptr[i].normalized = value
    @property
    def normalized(self):
        return self.get_normalized(0)
    @normalized.setter
    def normalized(self, int value):
        self.set_normalized(0,value)

    def get_readMode(self, i):
        """Get value of ``readMode`` of ``self._ptr[i]``.
        """
        return hipTextureReadMode(self._ptr[i].readMode)
    def set_readMode(self, i, value):
        """Set value ``readMode`` of ``self._ptr[i]``.
        """
        if not isinstance(value, hipTextureReadMode):
            raise TypeError("'value' must be of type 'hipTextureReadMode'")
        self._ptr[i].readMode = value.value
    @property
    def readMode(self):
        return self.get_readMode(0)
    @readMode.setter
    def readMode(self, value):
        self.set_readMode(0,value)

    def get_filterMode(self, i):
        """Get value of ``filterMode`` of ``self._ptr[i]``.
        """
        return hipTextureFilterMode(self._ptr[i].filterMode)
    def set_filterMode(self, i, value):
        """Set value ``filterMode`` of ``self._ptr[i]``.
        """
        if not isinstance(value, hipTextureFilterMode):
            raise TypeError("'value' must be of type 'hipTextureFilterMode'")
        self._ptr[i].filterMode = value.value
    @property
    def filterMode(self):
        return self.get_filterMode(0)
    @filterMode.setter
    def filterMode(self, value):
        self.set_filterMode(0,value)

    def get_channelDesc(self, i):
        """Get value of ``channelDesc`` of ``self._ptr[i]``.
        """
        return hipChannelFormatDesc.from_ptr(&self._ptr[i].channelDesc)
    @property
    def channelDesc(self):
        return self.get_channelDesc(0)

    def get_sRGB(self, i):
        """Get value ``sRGB`` of ``self._ptr[i]``.
        """
        return self._ptr[i].sRGB
    def set_sRGB(self, i, int value):
        """Set value ``sRGB`` of ``self._ptr[i]``.
        """
        self._ptr[i].sRGB = value
    @property
    def sRGB(self):
        return self.get_sRGB(0)
    @sRGB.setter
    def sRGB(self, int value):
        self.set_sRGB(0,value)

    def get_maxAnisotropy(self, i):
        """Get value ``maxAnisotropy`` of ``self._ptr[i]``.
        """
        return self._ptr[i].maxAnisotropy
    def set_maxAnisotropy(self, i, unsigned int value):
        """Set value ``maxAnisotropy`` of ``self._ptr[i]``.
        """
        self._ptr[i].maxAnisotropy = value
    @property
    def maxAnisotropy(self):
        return self.get_maxAnisotropy(0)
    @maxAnisotropy.setter
    def maxAnisotropy(self, unsigned int value):
        self.set_maxAnisotropy(0,value)

    def get_mipmapFilterMode(self, i):
        """Get value of ``mipmapFilterMode`` of ``self._ptr[i]``.
        """
        return hipTextureFilterMode(self._ptr[i].mipmapFilterMode)
    def set_mipmapFilterMode(self, i, value):
        """Set value ``mipmapFilterMode`` of ``self._ptr[i]``.
        """
        if not isinstance(value, hipTextureFilterMode):
            raise TypeError("'value' must be of type 'hipTextureFilterMode'")
        self._ptr[i].mipmapFilterMode = value.value
    @property
    def mipmapFilterMode(self):
        return self.get_mipmapFilterMode(0)
    @mipmapFilterMode.setter
    def mipmapFilterMode(self, value):
        self.set_mipmapFilterMode(0,value)

    def get_mipmapLevelBias(self, i):
        """Get value ``mipmapLevelBias`` of ``self._ptr[i]``.
        """
        return self._ptr[i].mipmapLevelBias
    def set_mipmapLevelBias(self, i, float value):
        """Set value ``mipmapLevelBias`` of ``self._ptr[i]``.
        """
        self._ptr[i].mipmapLevelBias = value
    @property
    def mipmapLevelBias(self):
        return self.get_mipmapLevelBias(0)
    @mipmapLevelBias.setter
    def mipmapLevelBias(self, float value):
        self.set_mipmapLevelBias(0,value)

    def get_minMipmapLevelClamp(self, i):
        """Get value ``minMipmapLevelClamp`` of ``self._ptr[i]``.
        """
        return self._ptr[i].minMipmapLevelClamp
    def set_minMipmapLevelClamp(self, i, float value):
        """Set value ``minMipmapLevelClamp`` of ``self._ptr[i]``.
        """
        self._ptr[i].minMipmapLevelClamp = value
    @property
    def minMipmapLevelClamp(self):
        return self.get_minMipmapLevelClamp(0)
    @minMipmapLevelClamp.setter
    def minMipmapLevelClamp(self, float value):
        self.set_minMipmapLevelClamp(0,value)

    def get_maxMipmapLevelClamp(self, i):
        """Get value ``maxMipmapLevelClamp`` of ``self._ptr[i]``.
        """
        return self._ptr[i].maxMipmapLevelClamp
    def set_maxMipmapLevelClamp(self, i, float value):
        """Set value ``maxMipmapLevelClamp`` of ``self._ptr[i]``.
        """
        self._ptr[i].maxMipmapLevelClamp = value
    @property
    def maxMipmapLevelClamp(self):
        return self.get_maxMipmapLevelClamp(0)
    @maxMipmapLevelClamp.setter
    def maxMipmapLevelClamp(self, float value):
        self.set_maxMipmapLevelClamp(0,value)

    def get_numChannels(self, i):
        """Get value ``numChannels`` of ``self._ptr[i]``.
        """
        return self._ptr[i].numChannels
    def set_numChannels(self, i, int value):
        """Set value ``numChannels`` of ``self._ptr[i]``.
        """
        self._ptr[i].numChannels = value
    @property
    def numChannels(self):
        return self.get_numChannels(0)
    @numChannels.setter
    def numChannels(self, int value):
        self.set_numChannels(0,value)

    def get_format(self, i):
        """Get value of ``format`` of ``self._ptr[i]``.
        """
        return hipArray_Format(self._ptr[i].format)
    def set_format(self, i, value):
        """Set value ``format`` of ``self._ptr[i]``.
        """
        if not isinstance(value, hipArray_Format):
            raise TypeError("'value' must be of type 'hipArray_Format'")
        self._ptr[i].format = value.value
    @property
    def format(self):
        return self.get_format(0)
    @format.setter
    def format(self, value):
        self.set_format(0,value)

    @staticmethod
    def PROPERTIES():
        return ["normalized","readMode","filterMode","channelDesc","sRGB","maxAnisotropy","mipmapFilterMode","mipmapLevelBias","minMipmapLevelClamp","maxMipmapLevelClamp","numChannels","format"]

    def __contains__(self,item):
        properties = self.PROPERTIES()
        return item in properties

    def __getitem__(self,item):
        properties = self.PROPERTIES()
        if isinstance(item,int):
            if item < 0 or item >= len(properties):
                raise IndexError()
            return getattr(self,properties[item])
        raise ValueError("'item' type must be 'int'")


cdef class hipTextureDesc:
    # members declared in pxd file

    def __cinit__(self):
        self._ptr = NULL
        self.ptr_owner = False
        self._py_buffer_acquired = False

    @staticmethod
    cdef hipTextureDesc from_ptr(chip.hipTextureDesc* ptr, bint owner=False):
        """Factory function to create ``hipTextureDesc`` objects from
        given ``chip.hipTextureDesc`` pointer.

        Setting ``owner`` flag to ``True`` causes
        the extension type to ``free`` the structure pointed to by ``ptr``
        when the wrapper object is deallocated.
        """
        # Fast call to __new__() that bypasses the __init__() constructor.
        cdef hipTextureDesc wrapper = hipTextureDesc.__new__(hipTextureDesc)
        wrapper._ptr = ptr
        wrapper.ptr_owner = owner
        return wrapper

    @staticmethod
    cdef hipTextureDesc from_pyobj(object pyobj):
        """Derives a hipTextureDesc from a Python object.

        Derives a hipTextureDesc from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``hipTextureDesc`` reference, this method
        returns it directly. No new ``hipTextureDesc`` is created in this case.

        Args:
            pyobj (object): Must be either ``None``, a simple, contiguous buffer according to the buffer protocol,
                            or of type ``hipTextureDesc``, ``int``, or ``ctypes.c_void_p``

        Note:
            This routine does not perform a copy but returns the original ``pyobj``
            if ``pyobj`` is an instance of hipTextureDesc!
        """
        cdef hipTextureDesc wrapper = hipTextureDesc.__new__(hipTextureDesc)
        cdef dict cuda_array_interface = getattr(pyobj, "__cuda_array_interface__", None)

        if pyobj is None:
            wrapper._ptr = NULL
        elif isinstance(pyobj,hipTextureDesc):
            return pyobj
        elif isinstance(pyobj,int):
            wrapper._ptr = <chip.hipTextureDesc*>cpython.long.PyLong_AsVoidPtr(pyobj)
        elif isinstance(pyobj,ctypes.c_void_p):
            wrapper._ptr = <chip.hipTextureDesc*>cpython.long.PyLong_AsVoidPtr(pyobj.value) if pyobj.value != None else NULL
        elif cuda_array_interface != None:
            if not "data" in cuda_array_interface:
                raise ValueError("input object has '__cuda_array_interface__' attribute but the dict has no 'data' key")
            ptr_as_int = cuda_array_interface["data"][0]
            wrapper._ptr = <chip.hipTextureDesc*>cpython.long.PyLong_AsVoidPtr(ptr_as_int)
        elif cpython.buffer.PyObject_CheckBuffer(pyobj):
            err = cpython.buffer.PyObject_GetBuffer( 
                pyobj,
                &wrapper._py_buffer, 
                cpython.buffer.PyBUF_SIMPLE | cpython.buffer.PyBUF_ANY_CONTIGUOUS
            )
            if err == -1:
                raise RuntimeError("failed to create simple, contiguous Py_buffer from Python object")
            wrapper._py_buffer_acquired = True
            wrapper._ptr = <chip.hipTextureDesc*>wrapper._py_buffer.buf
        else:
            raise TypeError(f"unsupported input type: '{str(type(pyobj))}'")
        return wrapper
    def __dealloc__(self):
        # Release the buffer handle
        if self._py_buffer_acquired is True:
            cpython.buffer.PyBuffer_Release(&self._py_buffer)
        # De-allocate if not null and flag is set
        if self._ptr is not NULL and self.ptr_owner is True:
            stdlib.free(self._ptr)
            self._ptr = NULL
    @staticmethod
    cdef __allocate(chip.hipTextureDesc** ptr):
        ptr[0] = <chip.hipTextureDesc*>stdlib.malloc(sizeof(chip.hipTextureDesc))

        if ptr[0] is NULL:
            raise MemoryError
        # TODO init values, if present

    @staticmethod
    cdef hipTextureDesc new():
        """Factory function to create hipTextureDesc objects with
        newly allocated chip.hipTextureDesc"""
        cdef chip.hipTextureDesc* ptr
        hipTextureDesc.__allocate(&ptr)
        return hipTextureDesc.from_ptr(ptr, owner=True)
   
    # False
    # False
    def __init__(self,**kwargs):
        hipTextureDesc.__allocate(&self._ptr)
        self.ptr_owner = True
        attribs = self.PROPERTIES()
        used_attribs = set()
        valid_names = ", ".join(["'"+p+"'" for p in attribs])
        for k,v in kwargs.items():
            if k in used_attribs:
                raise KeyError(f"argument '{k}' has already been specified as positional argument.")
            elif k not in attribs:
                raise KeyError(f"'{k}' is no valid property name. Valid names: {valid_names}")
            setattr(self,k,v)
    
    def __int__(self):
        """Returns the data's address as long integer."""
        return cpython.long.PyLong_FromVoidPtr(self._ptr)
    def __repr__(self):
        return f"<hipTextureDesc object, self.ptr={int(self)}>"
    def as_c_void_p(self):
        """Returns the data's address as `ctypes.c_void_p`"""
        return ctypes.c_void_p(int(self))
    def get_filterMode(self, i):
        """Get value of ``filterMode`` of ``self._ptr[i]``.
        """
        return hipTextureFilterMode(self._ptr[i].filterMode)
    def set_filterMode(self, i, value):
        """Set value ``filterMode`` of ``self._ptr[i]``.
        """
        if not isinstance(value, hipTextureFilterMode):
            raise TypeError("'value' must be of type 'hipTextureFilterMode'")
        self._ptr[i].filterMode = value.value
    @property
    def filterMode(self):
        return self.get_filterMode(0)
    @filterMode.setter
    def filterMode(self, value):
        self.set_filterMode(0,value)

    def get_readMode(self, i):
        """Get value of ``readMode`` of ``self._ptr[i]``.
        """
        return hipTextureReadMode(self._ptr[i].readMode)
    def set_readMode(self, i, value):
        """Set value ``readMode`` of ``self._ptr[i]``.
        """
        if not isinstance(value, hipTextureReadMode):
            raise TypeError("'value' must be of type 'hipTextureReadMode'")
        self._ptr[i].readMode = value.value
    @property
    def readMode(self):
        return self.get_readMode(0)
    @readMode.setter
    def readMode(self, value):
        self.set_readMode(0,value)

    def get_sRGB(self, i):
        """Get value ``sRGB`` of ``self._ptr[i]``.
        """
        return self._ptr[i].sRGB
    def set_sRGB(self, i, int value):
        """Set value ``sRGB`` of ``self._ptr[i]``.
        """
        self._ptr[i].sRGB = value
    @property
    def sRGB(self):
        return self.get_sRGB(0)
    @sRGB.setter
    def sRGB(self, int value):
        self.set_sRGB(0,value)

    def get_borderColor(self, i):
        """Get value of ``borderColor`` of ``self._ptr[i]``.
        """
        return self._ptr[i].borderColor
    # TODO add setters
    #def set_borderColor(self, i, float[4] value):
    #    """Set value ``borderColor`` of ``self._ptr[i]``.
    #    """
    #    self._ptr[i].borderColor = value
    @property
    def borderColor(self):
        return self.get_borderColor(0)
    # TODO add setters
    #@borderColor.setter
    #def borderColor(self, float[4] value):
    #    self.set_borderColor(0,value)

    def get_normalizedCoords(self, i):
        """Get value ``normalizedCoords`` of ``self._ptr[i]``.
        """
        return self._ptr[i].normalizedCoords
    def set_normalizedCoords(self, i, int value):
        """Set value ``normalizedCoords`` of ``self._ptr[i]``.
        """
        self._ptr[i].normalizedCoords = value
    @property
    def normalizedCoords(self):
        return self.get_normalizedCoords(0)
    @normalizedCoords.setter
    def normalizedCoords(self, int value):
        self.set_normalizedCoords(0,value)

    def get_maxAnisotropy(self, i):
        """Get value ``maxAnisotropy`` of ``self._ptr[i]``.
        """
        return self._ptr[i].maxAnisotropy
    def set_maxAnisotropy(self, i, unsigned int value):
        """Set value ``maxAnisotropy`` of ``self._ptr[i]``.
        """
        self._ptr[i].maxAnisotropy = value
    @property
    def maxAnisotropy(self):
        return self.get_maxAnisotropy(0)
    @maxAnisotropy.setter
    def maxAnisotropy(self, unsigned int value):
        self.set_maxAnisotropy(0,value)

    def get_mipmapFilterMode(self, i):
        """Get value of ``mipmapFilterMode`` of ``self._ptr[i]``.
        """
        return hipTextureFilterMode(self._ptr[i].mipmapFilterMode)
    def set_mipmapFilterMode(self, i, value):
        """Set value ``mipmapFilterMode`` of ``self._ptr[i]``.
        """
        if not isinstance(value, hipTextureFilterMode):
            raise TypeError("'value' must be of type 'hipTextureFilterMode'")
        self._ptr[i].mipmapFilterMode = value.value
    @property
    def mipmapFilterMode(self):
        return self.get_mipmapFilterMode(0)
    @mipmapFilterMode.setter
    def mipmapFilterMode(self, value):
        self.set_mipmapFilterMode(0,value)

    def get_mipmapLevelBias(self, i):
        """Get value ``mipmapLevelBias`` of ``self._ptr[i]``.
        """
        return self._ptr[i].mipmapLevelBias
    def set_mipmapLevelBias(self, i, float value):
        """Set value ``mipmapLevelBias`` of ``self._ptr[i]``.
        """
        self._ptr[i].mipmapLevelBias = value
    @property
    def mipmapLevelBias(self):
        return self.get_mipmapLevelBias(0)
    @mipmapLevelBias.setter
    def mipmapLevelBias(self, float value):
        self.set_mipmapLevelBias(0,value)

    def get_minMipmapLevelClamp(self, i):
        """Get value ``minMipmapLevelClamp`` of ``self._ptr[i]``.
        """
        return self._ptr[i].minMipmapLevelClamp
    def set_minMipmapLevelClamp(self, i, float value):
        """Set value ``minMipmapLevelClamp`` of ``self._ptr[i]``.
        """
        self._ptr[i].minMipmapLevelClamp = value
    @property
    def minMipmapLevelClamp(self):
        return self.get_minMipmapLevelClamp(0)
    @minMipmapLevelClamp.setter
    def minMipmapLevelClamp(self, float value):
        self.set_minMipmapLevelClamp(0,value)

    def get_maxMipmapLevelClamp(self, i):
        """Get value ``maxMipmapLevelClamp`` of ``self._ptr[i]``.
        """
        return self._ptr[i].maxMipmapLevelClamp
    def set_maxMipmapLevelClamp(self, i, float value):
        """Set value ``maxMipmapLevelClamp`` of ``self._ptr[i]``.
        """
        self._ptr[i].maxMipmapLevelClamp = value
    @property
    def maxMipmapLevelClamp(self):
        return self.get_maxMipmapLevelClamp(0)
    @maxMipmapLevelClamp.setter
    def maxMipmapLevelClamp(self, float value):
        self.set_maxMipmapLevelClamp(0,value)

    @staticmethod
    def PROPERTIES():
        return ["filterMode","readMode","sRGB","borderColor","normalizedCoords","maxAnisotropy","mipmapFilterMode","mipmapLevelBias","minMipmapLevelClamp","maxMipmapLevelClamp"]

    def __contains__(self,item):
        properties = self.PROPERTIES()
        return item in properties

    def __getitem__(self,item):
        properties = self.PROPERTIES()
        if isinstance(item,int):
            if item < 0 or item >= len(properties):
                raise IndexError()
            return getattr(self,properties[item])
        raise ValueError("'item' type must be 'int'")


cdef class __hip_surface:
    # members declared in pxd file

    def __cinit__(self):
        self._ptr = NULL
        self.ptr_owner = False
        self._py_buffer_acquired = False

    @staticmethod
    cdef __hip_surface from_ptr(chip.__hip_surface* ptr, bint owner=False):
        """Factory function to create ``__hip_surface`` objects from
        given ``chip.__hip_surface`` pointer.
        """
        # Fast call to __new__() that bypasses the __init__() constructor.
        cdef __hip_surface wrapper = __hip_surface.__new__(__hip_surface)
        wrapper._ptr = ptr
        wrapper.ptr_owner = owner
        return wrapper

    @staticmethod
    cdef __hip_surface from_pyobj(object pyobj):
        """Derives a __hip_surface from a Python object.

        Derives a __hip_surface from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``__hip_surface`` reference, this method
        returns it directly. No new ``__hip_surface`` is created in this case.

        Args:
            pyobj (object): Must be either ``None``, a simple, contiguous buffer according to the buffer protocol,
                            or of type ``__hip_surface``, ``int``, or ``ctypes.c_void_p``

        Note:
            This routine does not perform a copy but returns the original ``pyobj``
            if ``pyobj`` is an instance of __hip_surface!
        """
        cdef __hip_surface wrapper = __hip_surface.__new__(__hip_surface)
        cdef dict cuda_array_interface = getattr(pyobj, "__cuda_array_interface__", None)

        if pyobj is None:
            wrapper._ptr = NULL
        elif isinstance(pyobj,__hip_surface):
            return pyobj
        elif isinstance(pyobj,int):
            wrapper._ptr = <chip.__hip_surface*>cpython.long.PyLong_AsVoidPtr(pyobj)
        elif isinstance(pyobj,ctypes.c_void_p):
            wrapper._ptr = <chip.__hip_surface*>cpython.long.PyLong_AsVoidPtr(pyobj.value) if pyobj.value != None else NULL
        elif cuda_array_interface != None:
            if not "data" in cuda_array_interface:
                raise ValueError("input object has '__cuda_array_interface__' attribute but the dict has no 'data' key")
            ptr_as_int = cuda_array_interface["data"][0]
            wrapper._ptr = <chip.__hip_surface*>cpython.long.PyLong_AsVoidPtr(ptr_as_int)
        elif cpython.buffer.PyObject_CheckBuffer(pyobj):
            err = cpython.buffer.PyObject_GetBuffer( 
                pyobj,
                &wrapper._py_buffer, 
                cpython.buffer.PyBUF_SIMPLE | cpython.buffer.PyBUF_ANY_CONTIGUOUS
            )
            if err == -1:
                raise RuntimeError("failed to create simple, contiguous Py_buffer from Python object")
            wrapper._py_buffer_acquired = True
            wrapper._ptr = <chip.__hip_surface*>wrapper._py_buffer.buf
        else:
            raise TypeError(f"unsupported input type: '{str(type(pyobj))}'")
        return wrapper
    def __dealloc__(self):
        # Release the buffer handle
        if self._py_buffer_acquired is True:
            cpython.buffer.PyBuffer_Release(&self._py_buffer)
    
    def __int__(self):
        """Returns the data's address as long integer."""
        return cpython.long.PyLong_FromVoidPtr(self._ptr)
    def __repr__(self):
        return f"<__hip_surface object, self.ptr={int(self)}>"
    def as_c_void_p(self):
        """Returns the data's address as `ctypes.c_void_p`"""
        return ctypes.c_void_p(int(self))
    @staticmethod
    def PROPERTIES():
        return []

    def __contains__(self,item):
        properties = self.PROPERTIES()
        return item in properties

    def __getitem__(self,item):
        properties = self.PROPERTIES()
        if isinstance(item,int):
            if item < 0 or item >= len(properties):
                raise IndexError()
            return getattr(self,properties[item])
        raise ValueError("'item' type must be 'int'")


hipSurfaceObject_t = __hip_surface

cdef class surfaceReference:
    # members declared in pxd file

    def __cinit__(self):
        self._ptr = NULL
        self.ptr_owner = False
        self._py_buffer_acquired = False

    @staticmethod
    cdef surfaceReference from_ptr(chip.surfaceReference* ptr, bint owner=False):
        """Factory function to create ``surfaceReference`` objects from
        given ``chip.surfaceReference`` pointer.

        Setting ``owner`` flag to ``True`` causes
        the extension type to ``free`` the structure pointed to by ``ptr``
        when the wrapper object is deallocated.
        """
        # Fast call to __new__() that bypasses the __init__() constructor.
        cdef surfaceReference wrapper = surfaceReference.__new__(surfaceReference)
        wrapper._ptr = ptr
        wrapper.ptr_owner = owner
        return wrapper

    @staticmethod
    cdef surfaceReference from_pyobj(object pyobj):
        """Derives a surfaceReference from a Python object.

        Derives a surfaceReference from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``surfaceReference`` reference, this method
        returns it directly. No new ``surfaceReference`` is created in this case.

        Args:
            pyobj (object): Must be either ``None``, a simple, contiguous buffer according to the buffer protocol,
                            or of type ``surfaceReference``, ``int``, or ``ctypes.c_void_p``

        Note:
            This routine does not perform a copy but returns the original ``pyobj``
            if ``pyobj`` is an instance of surfaceReference!
        """
        cdef surfaceReference wrapper = surfaceReference.__new__(surfaceReference)
        cdef dict cuda_array_interface = getattr(pyobj, "__cuda_array_interface__", None)

        if pyobj is None:
            wrapper._ptr = NULL
        elif isinstance(pyobj,surfaceReference):
            return pyobj
        elif isinstance(pyobj,int):
            wrapper._ptr = <chip.surfaceReference*>cpython.long.PyLong_AsVoidPtr(pyobj)
        elif isinstance(pyobj,ctypes.c_void_p):
            wrapper._ptr = <chip.surfaceReference*>cpython.long.PyLong_AsVoidPtr(pyobj.value) if pyobj.value != None else NULL
        elif cuda_array_interface != None:
            if not "data" in cuda_array_interface:
                raise ValueError("input object has '__cuda_array_interface__' attribute but the dict has no 'data' key")
            ptr_as_int = cuda_array_interface["data"][0]
            wrapper._ptr = <chip.surfaceReference*>cpython.long.PyLong_AsVoidPtr(ptr_as_int)
        elif cpython.buffer.PyObject_CheckBuffer(pyobj):
            err = cpython.buffer.PyObject_GetBuffer( 
                pyobj,
                &wrapper._py_buffer, 
                cpython.buffer.PyBUF_SIMPLE | cpython.buffer.PyBUF_ANY_CONTIGUOUS
            )
            if err == -1:
                raise RuntimeError("failed to create simple, contiguous Py_buffer from Python object")
            wrapper._py_buffer_acquired = True
            wrapper._ptr = <chip.surfaceReference*>wrapper._py_buffer.buf
        else:
            raise TypeError(f"unsupported input type: '{str(type(pyobj))}'")
        return wrapper
    def __dealloc__(self):
        # Release the buffer handle
        if self._py_buffer_acquired is True:
            cpython.buffer.PyBuffer_Release(&self._py_buffer)
        # De-allocate if not null and flag is set
        if self._ptr is not NULL and self.ptr_owner is True:
            stdlib.free(self._ptr)
            self._ptr = NULL
    @staticmethod
    cdef __allocate(chip.surfaceReference** ptr):
        ptr[0] = <chip.surfaceReference*>stdlib.malloc(sizeof(chip.surfaceReference))

        if ptr[0] is NULL:
            raise MemoryError
        # TODO init values, if present

    @staticmethod
    cdef surfaceReference new():
        """Factory function to create surfaceReference objects with
        newly allocated chip.surfaceReference"""
        cdef chip.surfaceReference* ptr
        surfaceReference.__allocate(&ptr)
        return surfaceReference.from_ptr(ptr, owner=True)
   
    # False
    # False
    def __init__(self,**kwargs):
        surfaceReference.__allocate(&self._ptr)
        self.ptr_owner = True
        attribs = self.PROPERTIES()
        used_attribs = set()
        valid_names = ", ".join(["'"+p+"'" for p in attribs])
        for k,v in kwargs.items():
            if k in used_attribs:
                raise KeyError(f"argument '{k}' has already been specified as positional argument.")
            elif k not in attribs:
                raise KeyError(f"'{k}' is no valid property name. Valid names: {valid_names}")
            setattr(self,k,v)
    
    def __int__(self):
        """Returns the data's address as long integer."""
        return cpython.long.PyLong_FromVoidPtr(self._ptr)
    def __repr__(self):
        return f"<surfaceReference object, self.ptr={int(self)}>"
    def as_c_void_p(self):
        """Returns the data's address as `ctypes.c_void_p`"""
        return ctypes.c_void_p(int(self))
    @staticmethod
    def PROPERTIES():
        return []

    def __contains__(self,item):
        properties = self.PROPERTIES()
        return item in properties

    def __getitem__(self,item):
        properties = self.PROPERTIES()
        if isinstance(item,int):
            if item < 0 or item >= len(properties):
                raise IndexError()
            return getattr(self,properties[item])
        raise ValueError("'item' type must be 'int'")


class _hipSurfaceBoundaryMode__Base(enum.IntEnum):
    """Empty enum base class that allows subclassing.
    """
    pass
class hipSurfaceBoundaryMode(_hipSurfaceBoundaryMode__Base):
    hipBoundaryModeZero = chip.hipBoundaryModeZero
    hipBoundaryModeTrap = chip.hipBoundaryModeTrap
    hipBoundaryModeClamp = chip.hipBoundaryModeClamp
    @staticmethod
    def ctypes_type():
        """The type of the enum constants as ctypes type."""
        return ctypes.c_uint 


cdef class ihipCtx_t:
    # members declared in pxd file

    def __cinit__(self):
        self._ptr = NULL
        self.ptr_owner = False
        self._py_buffer_acquired = False

    @staticmethod
    cdef ihipCtx_t from_ptr(chip.ihipCtx_t* ptr, bint owner=False):
        """Factory function to create ``ihipCtx_t`` objects from
        given ``chip.ihipCtx_t`` pointer.
        """
        # Fast call to __new__() that bypasses the __init__() constructor.
        cdef ihipCtx_t wrapper = ihipCtx_t.__new__(ihipCtx_t)
        wrapper._ptr = ptr
        wrapper.ptr_owner = owner
        return wrapper

    @staticmethod
    cdef ihipCtx_t from_pyobj(object pyobj):
        """Derives a ihipCtx_t from a Python object.

        Derives a ihipCtx_t from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``ihipCtx_t`` reference, this method
        returns it directly. No new ``ihipCtx_t`` is created in this case.

        Args:
            pyobj (object): Must be either ``None``, a simple, contiguous buffer according to the buffer protocol,
                            or of type ``ihipCtx_t``, ``int``, or ``ctypes.c_void_p``

        Note:
            This routine does not perform a copy but returns the original ``pyobj``
            if ``pyobj`` is an instance of ihipCtx_t!
        """
        cdef ihipCtx_t wrapper = ihipCtx_t.__new__(ihipCtx_t)
        cdef dict cuda_array_interface = getattr(pyobj, "__cuda_array_interface__", None)

        if pyobj is None:
            wrapper._ptr = NULL
        elif isinstance(pyobj,ihipCtx_t):
            return pyobj
        elif isinstance(pyobj,int):
            wrapper._ptr = <chip.ihipCtx_t*>cpython.long.PyLong_AsVoidPtr(pyobj)
        elif isinstance(pyobj,ctypes.c_void_p):
            wrapper._ptr = <chip.ihipCtx_t*>cpython.long.PyLong_AsVoidPtr(pyobj.value) if pyobj.value != None else NULL
        elif cuda_array_interface != None:
            if not "data" in cuda_array_interface:
                raise ValueError("input object has '__cuda_array_interface__' attribute but the dict has no 'data' key")
            ptr_as_int = cuda_array_interface["data"][0]
            wrapper._ptr = <chip.ihipCtx_t*>cpython.long.PyLong_AsVoidPtr(ptr_as_int)
        elif cpython.buffer.PyObject_CheckBuffer(pyobj):
            err = cpython.buffer.PyObject_GetBuffer( 
                pyobj,
                &wrapper._py_buffer, 
                cpython.buffer.PyBUF_SIMPLE | cpython.buffer.PyBUF_ANY_CONTIGUOUS
            )
            if err == -1:
                raise RuntimeError("failed to create simple, contiguous Py_buffer from Python object")
            wrapper._py_buffer_acquired = True
            wrapper._ptr = <chip.ihipCtx_t*>wrapper._py_buffer.buf
        else:
            raise TypeError(f"unsupported input type: '{str(type(pyobj))}'")
        return wrapper
    def __dealloc__(self):
        # Release the buffer handle
        if self._py_buffer_acquired is True:
            cpython.buffer.PyBuffer_Release(&self._py_buffer)
    
    def __int__(self):
        """Returns the data's address as long integer."""
        return cpython.long.PyLong_FromVoidPtr(self._ptr)
    def __repr__(self):
        return f"<ihipCtx_t object, self.ptr={int(self)}>"
    def as_c_void_p(self):
        """Returns the data's address as `ctypes.c_void_p`"""
        return ctypes.c_void_p(int(self))
    @staticmethod
    def PROPERTIES():
        return []

    def __contains__(self,item):
        properties = self.PROPERTIES()
        return item in properties

    def __getitem__(self,item):
        properties = self.PROPERTIES()
        if isinstance(item,int):
            if item < 0 or item >= len(properties):
                raise IndexError()
            return getattr(self,properties[item])
        raise ValueError("'item' type must be 'int'")


hipCtx_t = ihipCtx_t

class _hipDeviceP2PAttr__Base(enum.IntEnum):
    """Empty enum base class that allows subclassing.
    """
    pass
class hipDeviceP2PAttr(_hipDeviceP2PAttr__Base):
    hipDevP2PAttrPerformanceRank = chip.hipDevP2PAttrPerformanceRank
    hipDevP2PAttrAccessSupported = chip.hipDevP2PAttrAccessSupported
    hipDevP2PAttrNativeAtomicSupported = chip.hipDevP2PAttrNativeAtomicSupported
    hipDevP2PAttrHipArrayAccessSupported = chip.hipDevP2PAttrHipArrayAccessSupported
    @staticmethod
    def ctypes_type():
        """The type of the enum constants as ctypes type."""
        return ctypes.c_uint 


cdef class ihipStream_t:
    # members declared in pxd file

    def __cinit__(self):
        self._ptr = NULL
        self.ptr_owner = False
        self._py_buffer_acquired = False

    @staticmethod
    cdef ihipStream_t from_ptr(chip.ihipStream_t* ptr, bint owner=False):
        """Factory function to create ``ihipStream_t`` objects from
        given ``chip.ihipStream_t`` pointer.
        """
        # Fast call to __new__() that bypasses the __init__() constructor.
        cdef ihipStream_t wrapper = ihipStream_t.__new__(ihipStream_t)
        wrapper._ptr = ptr
        wrapper.ptr_owner = owner
        return wrapper

    @staticmethod
    cdef ihipStream_t from_pyobj(object pyobj):
        """Derives a ihipStream_t from a Python object.

        Derives a ihipStream_t from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``ihipStream_t`` reference, this method
        returns it directly. No new ``ihipStream_t`` is created in this case.

        Args:
            pyobj (object): Must be either ``None``, a simple, contiguous buffer according to the buffer protocol,
                            or of type ``ihipStream_t``, ``int``, or ``ctypes.c_void_p``

        Note:
            This routine does not perform a copy but returns the original ``pyobj``
            if ``pyobj`` is an instance of ihipStream_t!
        """
        cdef ihipStream_t wrapper = ihipStream_t.__new__(ihipStream_t)
        cdef dict cuda_array_interface = getattr(pyobj, "__cuda_array_interface__", None)

        if pyobj is None:
            wrapper._ptr = NULL
        elif isinstance(pyobj,ihipStream_t):
            return pyobj
        elif isinstance(pyobj,int):
            wrapper._ptr = <chip.ihipStream_t*>cpython.long.PyLong_AsVoidPtr(pyobj)
        elif isinstance(pyobj,ctypes.c_void_p):
            wrapper._ptr = <chip.ihipStream_t*>cpython.long.PyLong_AsVoidPtr(pyobj.value) if pyobj.value != None else NULL
        elif cuda_array_interface != None:
            if not "data" in cuda_array_interface:
                raise ValueError("input object has '__cuda_array_interface__' attribute but the dict has no 'data' key")
            ptr_as_int = cuda_array_interface["data"][0]
            wrapper._ptr = <chip.ihipStream_t*>cpython.long.PyLong_AsVoidPtr(ptr_as_int)
        elif cpython.buffer.PyObject_CheckBuffer(pyobj):
            err = cpython.buffer.PyObject_GetBuffer( 
                pyobj,
                &wrapper._py_buffer, 
                cpython.buffer.PyBUF_SIMPLE | cpython.buffer.PyBUF_ANY_CONTIGUOUS
            )
            if err == -1:
                raise RuntimeError("failed to create simple, contiguous Py_buffer from Python object")
            wrapper._py_buffer_acquired = True
            wrapper._ptr = <chip.ihipStream_t*>wrapper._py_buffer.buf
        else:
            raise TypeError(f"unsupported input type: '{str(type(pyobj))}'")
        return wrapper
    def __dealloc__(self):
        # Release the buffer handle
        if self._py_buffer_acquired is True:
            cpython.buffer.PyBuffer_Release(&self._py_buffer)
    
    def __int__(self):
        """Returns the data's address as long integer."""
        return cpython.long.PyLong_FromVoidPtr(self._ptr)
    def __repr__(self):
        return f"<ihipStream_t object, self.ptr={int(self)}>"
    def as_c_void_p(self):
        """Returns the data's address as `ctypes.c_void_p`"""
        return ctypes.c_void_p(int(self))
    @staticmethod
    def PROPERTIES():
        return []

    def __contains__(self,item):
        properties = self.PROPERTIES()
        return item in properties

    def __getitem__(self,item):
        properties = self.PROPERTIES()
        if isinstance(item,int):
            if item < 0 or item >= len(properties):
                raise IndexError()
            return getattr(self,properties[item])
        raise ValueError("'item' type must be 'int'")


hipStream_t = ihipStream_t

cdef class hipIpcMemHandle_st:
    # members declared in pxd file

    def __cinit__(self):
        self._ptr = NULL
        self.ptr_owner = False
        self._py_buffer_acquired = False

    @staticmethod
    cdef hipIpcMemHandle_st from_ptr(chip.hipIpcMemHandle_st* ptr, bint owner=False):
        """Factory function to create ``hipIpcMemHandle_st`` objects from
        given ``chip.hipIpcMemHandle_st`` pointer.

        Setting ``owner`` flag to ``True`` causes
        the extension type to ``free`` the structure pointed to by ``ptr``
        when the wrapper object is deallocated.
        """
        # Fast call to __new__() that bypasses the __init__() constructor.
        cdef hipIpcMemHandle_st wrapper = hipIpcMemHandle_st.__new__(hipIpcMemHandle_st)
        wrapper._ptr = ptr
        wrapper.ptr_owner = owner
        return wrapper

    @staticmethod
    cdef hipIpcMemHandle_st from_pyobj(object pyobj):
        """Derives a hipIpcMemHandle_st from a Python object.

        Derives a hipIpcMemHandle_st from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``hipIpcMemHandle_st`` reference, this method
        returns it directly. No new ``hipIpcMemHandle_st`` is created in this case.

        Args:
            pyobj (object): Must be either ``None``, a simple, contiguous buffer according to the buffer protocol,
                            or of type ``hipIpcMemHandle_st``, ``int``, or ``ctypes.c_void_p``

        Note:
            This routine does not perform a copy but returns the original ``pyobj``
            if ``pyobj`` is an instance of hipIpcMemHandle_st!
        """
        cdef hipIpcMemHandle_st wrapper = hipIpcMemHandle_st.__new__(hipIpcMemHandle_st)
        cdef dict cuda_array_interface = getattr(pyobj, "__cuda_array_interface__", None)

        if pyobj is None:
            wrapper._ptr = NULL
        elif isinstance(pyobj,hipIpcMemHandle_st):
            return pyobj
        elif isinstance(pyobj,int):
            wrapper._ptr = <chip.hipIpcMemHandle_st*>cpython.long.PyLong_AsVoidPtr(pyobj)
        elif isinstance(pyobj,ctypes.c_void_p):
            wrapper._ptr = <chip.hipIpcMemHandle_st*>cpython.long.PyLong_AsVoidPtr(pyobj.value) if pyobj.value != None else NULL
        elif cuda_array_interface != None:
            if not "data" in cuda_array_interface:
                raise ValueError("input object has '__cuda_array_interface__' attribute but the dict has no 'data' key")
            ptr_as_int = cuda_array_interface["data"][0]
            wrapper._ptr = <chip.hipIpcMemHandle_st*>cpython.long.PyLong_AsVoidPtr(ptr_as_int)
        elif cpython.buffer.PyObject_CheckBuffer(pyobj):
            err = cpython.buffer.PyObject_GetBuffer( 
                pyobj,
                &wrapper._py_buffer, 
                cpython.buffer.PyBUF_SIMPLE | cpython.buffer.PyBUF_ANY_CONTIGUOUS
            )
            if err == -1:
                raise RuntimeError("failed to create simple, contiguous Py_buffer from Python object")
            wrapper._py_buffer_acquired = True
            wrapper._ptr = <chip.hipIpcMemHandle_st*>wrapper._py_buffer.buf
        else:
            raise TypeError(f"unsupported input type: '{str(type(pyobj))}'")
        return wrapper
    def __dealloc__(self):
        # Release the buffer handle
        if self._py_buffer_acquired is True:
            cpython.buffer.PyBuffer_Release(&self._py_buffer)
        # De-allocate if not null and flag is set
        if self._ptr is not NULL and self.ptr_owner is True:
            stdlib.free(self._ptr)
            self._ptr = NULL
    @staticmethod
    cdef __allocate(chip.hipIpcMemHandle_st** ptr):
        ptr[0] = <chip.hipIpcMemHandle_st*>stdlib.malloc(sizeof(chip.hipIpcMemHandle_st))

        if ptr[0] is NULL:
            raise MemoryError
        # TODO init values, if present

    @staticmethod
    cdef hipIpcMemHandle_st new():
        """Factory function to create hipIpcMemHandle_st objects with
        newly allocated chip.hipIpcMemHandle_st"""
        cdef chip.hipIpcMemHandle_st* ptr
        hipIpcMemHandle_st.__allocate(&ptr)
        return hipIpcMemHandle_st.from_ptr(ptr, owner=True)
   
    def __init__(self,*args,**kwargs):
        hipIpcMemHandle_st.__allocate(&self._ptr)
        self.ptr_owner = True
        attribs = self.PROPERTIES()
        used_attribs = set()
        if len(args) > len(attribs):
            raise ValueError("More positional arguments specified than this type has properties.")
        for i,v in enumerate(args):
            setattr(self,attribs[i],v)
            used_attribs.add(attribs[i])
        valid_names = ", ".join(["'"+p+"'" for p in attribs])
        for k,v in kwargs.items():
            if k in used_attribs:
                raise KeyError(f"argument '{k}' has already been specified as positional argument.")
            elif k not in attribs:
                raise KeyError(f"'{k}' is no valid property name. Valid names: {valid_names}")
            setattr(self,k,v)
    
    def __int__(self):
        """Returns the data's address as long integer."""
        return cpython.long.PyLong_FromVoidPtr(self._ptr)
    def __repr__(self):
        return f"<hipIpcMemHandle_st object, self.ptr={int(self)}>"
    def as_c_void_p(self):
        """Returns the data's address as `ctypes.c_void_p`"""
        return ctypes.c_void_p(int(self))
    def get_reserved(self, i):
        """Get value of ``reserved`` of ``self._ptr[i]``.
        """
        return self._ptr[i].reserved
    # TODO add setters
    #def set_reserved(self, i, char[64] value):
    #    """Set value ``reserved`` of ``self._ptr[i]``.
    #    """
    #    self._ptr[i].reserved = value
    @property
    def reserved(self):
        return self.get_reserved(0)
    # TODO add setters
    #@reserved.setter
    #def reserved(self, char[64] value):
    #    self.set_reserved(0,value)

    @staticmethod
    def PROPERTIES():
        return ["reserved"]

    def __contains__(self,item):
        properties = self.PROPERTIES()
        return item in properties

    def __getitem__(self,item):
        properties = self.PROPERTIES()
        if isinstance(item,int):
            if item < 0 or item >= len(properties):
                raise IndexError()
            return getattr(self,properties[item])
        raise ValueError("'item' type must be 'int'")


hipIpcMemHandle_t = hipIpcMemHandle_st

cdef class hipIpcEventHandle_st:
    # members declared in pxd file

    def __cinit__(self):
        self._ptr = NULL
        self.ptr_owner = False
        self._py_buffer_acquired = False

    @staticmethod
    cdef hipIpcEventHandle_st from_ptr(chip.hipIpcEventHandle_st* ptr, bint owner=False):
        """Factory function to create ``hipIpcEventHandle_st`` objects from
        given ``chip.hipIpcEventHandle_st`` pointer.

        Setting ``owner`` flag to ``True`` causes
        the extension type to ``free`` the structure pointed to by ``ptr``
        when the wrapper object is deallocated.
        """
        # Fast call to __new__() that bypasses the __init__() constructor.
        cdef hipIpcEventHandle_st wrapper = hipIpcEventHandle_st.__new__(hipIpcEventHandle_st)
        wrapper._ptr = ptr
        wrapper.ptr_owner = owner
        return wrapper

    @staticmethod
    cdef hipIpcEventHandle_st from_pyobj(object pyobj):
        """Derives a hipIpcEventHandle_st from a Python object.

        Derives a hipIpcEventHandle_st from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``hipIpcEventHandle_st`` reference, this method
        returns it directly. No new ``hipIpcEventHandle_st`` is created in this case.

        Args:
            pyobj (object): Must be either ``None``, a simple, contiguous buffer according to the buffer protocol,
                            or of type ``hipIpcEventHandle_st``, ``int``, or ``ctypes.c_void_p``

        Note:
            This routine does not perform a copy but returns the original ``pyobj``
            if ``pyobj`` is an instance of hipIpcEventHandle_st!
        """
        cdef hipIpcEventHandle_st wrapper = hipIpcEventHandle_st.__new__(hipIpcEventHandle_st)
        cdef dict cuda_array_interface = getattr(pyobj, "__cuda_array_interface__", None)

        if pyobj is None:
            wrapper._ptr = NULL
        elif isinstance(pyobj,hipIpcEventHandle_st):
            return pyobj
        elif isinstance(pyobj,int):
            wrapper._ptr = <chip.hipIpcEventHandle_st*>cpython.long.PyLong_AsVoidPtr(pyobj)
        elif isinstance(pyobj,ctypes.c_void_p):
            wrapper._ptr = <chip.hipIpcEventHandle_st*>cpython.long.PyLong_AsVoidPtr(pyobj.value) if pyobj.value != None else NULL
        elif cuda_array_interface != None:
            if not "data" in cuda_array_interface:
                raise ValueError("input object has '__cuda_array_interface__' attribute but the dict has no 'data' key")
            ptr_as_int = cuda_array_interface["data"][0]
            wrapper._ptr = <chip.hipIpcEventHandle_st*>cpython.long.PyLong_AsVoidPtr(ptr_as_int)
        elif cpython.buffer.PyObject_CheckBuffer(pyobj):
            err = cpython.buffer.PyObject_GetBuffer( 
                pyobj,
                &wrapper._py_buffer, 
                cpython.buffer.PyBUF_SIMPLE | cpython.buffer.PyBUF_ANY_CONTIGUOUS
            )
            if err == -1:
                raise RuntimeError("failed to create simple, contiguous Py_buffer from Python object")
            wrapper._py_buffer_acquired = True
            wrapper._ptr = <chip.hipIpcEventHandle_st*>wrapper._py_buffer.buf
        else:
            raise TypeError(f"unsupported input type: '{str(type(pyobj))}'")
        return wrapper
    def __dealloc__(self):
        # Release the buffer handle
        if self._py_buffer_acquired is True:
            cpython.buffer.PyBuffer_Release(&self._py_buffer)
        # De-allocate if not null and flag is set
        if self._ptr is not NULL and self.ptr_owner is True:
            stdlib.free(self._ptr)
            self._ptr = NULL
    @staticmethod
    cdef __allocate(chip.hipIpcEventHandle_st** ptr):
        ptr[0] = <chip.hipIpcEventHandle_st*>stdlib.malloc(sizeof(chip.hipIpcEventHandle_st))

        if ptr[0] is NULL:
            raise MemoryError
        # TODO init values, if present

    @staticmethod
    cdef hipIpcEventHandle_st new():
        """Factory function to create hipIpcEventHandle_st objects with
        newly allocated chip.hipIpcEventHandle_st"""
        cdef chip.hipIpcEventHandle_st* ptr
        hipIpcEventHandle_st.__allocate(&ptr)
        return hipIpcEventHandle_st.from_ptr(ptr, owner=True)
   
    def __init__(self,*args,**kwargs):
        hipIpcEventHandle_st.__allocate(&self._ptr)
        self.ptr_owner = True
        attribs = self.PROPERTIES()
        used_attribs = set()
        if len(args) > len(attribs):
            raise ValueError("More positional arguments specified than this type has properties.")
        for i,v in enumerate(args):
            setattr(self,attribs[i],v)
            used_attribs.add(attribs[i])
        valid_names = ", ".join(["'"+p+"'" for p in attribs])
        for k,v in kwargs.items():
            if k in used_attribs:
                raise KeyError(f"argument '{k}' has already been specified as positional argument.")
            elif k not in attribs:
                raise KeyError(f"'{k}' is no valid property name. Valid names: {valid_names}")
            setattr(self,k,v)
    
    def __int__(self):
        """Returns the data's address as long integer."""
        return cpython.long.PyLong_FromVoidPtr(self._ptr)
    def __repr__(self):
        return f"<hipIpcEventHandle_st object, self.ptr={int(self)}>"
    def as_c_void_p(self):
        """Returns the data's address as `ctypes.c_void_p`"""
        return ctypes.c_void_p(int(self))
    def get_reserved(self, i):
        """Get value of ``reserved`` of ``self._ptr[i]``.
        """
        return self._ptr[i].reserved
    # TODO add setters
    #def set_reserved(self, i, char[64] value):
    #    """Set value ``reserved`` of ``self._ptr[i]``.
    #    """
    #    self._ptr[i].reserved = value
    @property
    def reserved(self):
        return self.get_reserved(0)
    # TODO add setters
    #@reserved.setter
    #def reserved(self, char[64] value):
    #    self.set_reserved(0,value)

    @staticmethod
    def PROPERTIES():
        return ["reserved"]

    def __contains__(self,item):
        properties = self.PROPERTIES()
        return item in properties

    def __getitem__(self,item):
        properties = self.PROPERTIES()
        if isinstance(item,int):
            if item < 0 or item >= len(properties):
                raise IndexError()
            return getattr(self,properties[item])
        raise ValueError("'item' type must be 'int'")


hipIpcEventHandle_t = hipIpcEventHandle_st

cdef class ihipModule_t:
    # members declared in pxd file

    def __cinit__(self):
        self._ptr = NULL
        self.ptr_owner = False
        self._py_buffer_acquired = False

    @staticmethod
    cdef ihipModule_t from_ptr(chip.ihipModule_t* ptr, bint owner=False):
        """Factory function to create ``ihipModule_t`` objects from
        given ``chip.ihipModule_t`` pointer.
        """
        # Fast call to __new__() that bypasses the __init__() constructor.
        cdef ihipModule_t wrapper = ihipModule_t.__new__(ihipModule_t)
        wrapper._ptr = ptr
        wrapper.ptr_owner = owner
        return wrapper

    @staticmethod
    cdef ihipModule_t from_pyobj(object pyobj):
        """Derives a ihipModule_t from a Python object.

        Derives a ihipModule_t from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``ihipModule_t`` reference, this method
        returns it directly. No new ``ihipModule_t`` is created in this case.

        Args:
            pyobj (object): Must be either ``None``, a simple, contiguous buffer according to the buffer protocol,
                            or of type ``ihipModule_t``, ``int``, or ``ctypes.c_void_p``

        Note:
            This routine does not perform a copy but returns the original ``pyobj``
            if ``pyobj`` is an instance of ihipModule_t!
        """
        cdef ihipModule_t wrapper = ihipModule_t.__new__(ihipModule_t)
        cdef dict cuda_array_interface = getattr(pyobj, "__cuda_array_interface__", None)

        if pyobj is None:
            wrapper._ptr = NULL
        elif isinstance(pyobj,ihipModule_t):
            return pyobj
        elif isinstance(pyobj,int):
            wrapper._ptr = <chip.ihipModule_t*>cpython.long.PyLong_AsVoidPtr(pyobj)
        elif isinstance(pyobj,ctypes.c_void_p):
            wrapper._ptr = <chip.ihipModule_t*>cpython.long.PyLong_AsVoidPtr(pyobj.value) if pyobj.value != None else NULL
        elif cuda_array_interface != None:
            if not "data" in cuda_array_interface:
                raise ValueError("input object has '__cuda_array_interface__' attribute but the dict has no 'data' key")
            ptr_as_int = cuda_array_interface["data"][0]
            wrapper._ptr = <chip.ihipModule_t*>cpython.long.PyLong_AsVoidPtr(ptr_as_int)
        elif cpython.buffer.PyObject_CheckBuffer(pyobj):
            err = cpython.buffer.PyObject_GetBuffer( 
                pyobj,
                &wrapper._py_buffer, 
                cpython.buffer.PyBUF_SIMPLE | cpython.buffer.PyBUF_ANY_CONTIGUOUS
            )
            if err == -1:
                raise RuntimeError("failed to create simple, contiguous Py_buffer from Python object")
            wrapper._py_buffer_acquired = True
            wrapper._ptr = <chip.ihipModule_t*>wrapper._py_buffer.buf
        else:
            raise TypeError(f"unsupported input type: '{str(type(pyobj))}'")
        return wrapper
    def __dealloc__(self):
        # Release the buffer handle
        if self._py_buffer_acquired is True:
            cpython.buffer.PyBuffer_Release(&self._py_buffer)
    
    def __int__(self):
        """Returns the data's address as long integer."""
        return cpython.long.PyLong_FromVoidPtr(self._ptr)
    def __repr__(self):
        return f"<ihipModule_t object, self.ptr={int(self)}>"
    def as_c_void_p(self):
        """Returns the data's address as `ctypes.c_void_p`"""
        return ctypes.c_void_p(int(self))
    @staticmethod
    def PROPERTIES():
        return []

    def __contains__(self,item):
        properties = self.PROPERTIES()
        return item in properties

    def __getitem__(self,item):
        properties = self.PROPERTIES()
        if isinstance(item,int):
            if item < 0 or item >= len(properties):
                raise IndexError()
            return getattr(self,properties[item])
        raise ValueError("'item' type must be 'int'")


hipModule_t = ihipModule_t

cdef class ihipModuleSymbol_t:
    # members declared in pxd file

    def __cinit__(self):
        self._ptr = NULL
        self.ptr_owner = False
        self._py_buffer_acquired = False

    @staticmethod
    cdef ihipModuleSymbol_t from_ptr(chip.ihipModuleSymbol_t* ptr, bint owner=False):
        """Factory function to create ``ihipModuleSymbol_t`` objects from
        given ``chip.ihipModuleSymbol_t`` pointer.
        """
        # Fast call to __new__() that bypasses the __init__() constructor.
        cdef ihipModuleSymbol_t wrapper = ihipModuleSymbol_t.__new__(ihipModuleSymbol_t)
        wrapper._ptr = ptr
        wrapper.ptr_owner = owner
        return wrapper

    @staticmethod
    cdef ihipModuleSymbol_t from_pyobj(object pyobj):
        """Derives a ihipModuleSymbol_t from a Python object.

        Derives a ihipModuleSymbol_t from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``ihipModuleSymbol_t`` reference, this method
        returns it directly. No new ``ihipModuleSymbol_t`` is created in this case.

        Args:
            pyobj (object): Must be either ``None``, a simple, contiguous buffer according to the buffer protocol,
                            or of type ``ihipModuleSymbol_t``, ``int``, or ``ctypes.c_void_p``

        Note:
            This routine does not perform a copy but returns the original ``pyobj``
            if ``pyobj`` is an instance of ihipModuleSymbol_t!
        """
        cdef ihipModuleSymbol_t wrapper = ihipModuleSymbol_t.__new__(ihipModuleSymbol_t)
        cdef dict cuda_array_interface = getattr(pyobj, "__cuda_array_interface__", None)

        if pyobj is None:
            wrapper._ptr = NULL
        elif isinstance(pyobj,ihipModuleSymbol_t):
            return pyobj
        elif isinstance(pyobj,int):
            wrapper._ptr = <chip.ihipModuleSymbol_t*>cpython.long.PyLong_AsVoidPtr(pyobj)
        elif isinstance(pyobj,ctypes.c_void_p):
            wrapper._ptr = <chip.ihipModuleSymbol_t*>cpython.long.PyLong_AsVoidPtr(pyobj.value) if pyobj.value != None else NULL
        elif cuda_array_interface != None:
            if not "data" in cuda_array_interface:
                raise ValueError("input object has '__cuda_array_interface__' attribute but the dict has no 'data' key")
            ptr_as_int = cuda_array_interface["data"][0]
            wrapper._ptr = <chip.ihipModuleSymbol_t*>cpython.long.PyLong_AsVoidPtr(ptr_as_int)
        elif cpython.buffer.PyObject_CheckBuffer(pyobj):
            err = cpython.buffer.PyObject_GetBuffer( 
                pyobj,
                &wrapper._py_buffer, 
                cpython.buffer.PyBUF_SIMPLE | cpython.buffer.PyBUF_ANY_CONTIGUOUS
            )
            if err == -1:
                raise RuntimeError("failed to create simple, contiguous Py_buffer from Python object")
            wrapper._py_buffer_acquired = True
            wrapper._ptr = <chip.ihipModuleSymbol_t*>wrapper._py_buffer.buf
        else:
            raise TypeError(f"unsupported input type: '{str(type(pyobj))}'")
        return wrapper
    def __dealloc__(self):
        # Release the buffer handle
        if self._py_buffer_acquired is True:
            cpython.buffer.PyBuffer_Release(&self._py_buffer)
    
    def __int__(self):
        """Returns the data's address as long integer."""
        return cpython.long.PyLong_FromVoidPtr(self._ptr)
    def __repr__(self):
        return f"<ihipModuleSymbol_t object, self.ptr={int(self)}>"
    def as_c_void_p(self):
        """Returns the data's address as `ctypes.c_void_p`"""
        return ctypes.c_void_p(int(self))
    @staticmethod
    def PROPERTIES():
        return []

    def __contains__(self,item):
        properties = self.PROPERTIES()
        return item in properties

    def __getitem__(self,item):
        properties = self.PROPERTIES()
        if isinstance(item,int):
            if item < 0 or item >= len(properties):
                raise IndexError()
            return getattr(self,properties[item])
        raise ValueError("'item' type must be 'int'")


hipFunction_t = ihipModuleSymbol_t

cdef class ihipMemPoolHandle_t:
    # members declared in pxd file

    def __cinit__(self):
        self._ptr = NULL
        self.ptr_owner = False
        self._py_buffer_acquired = False

    @staticmethod
    cdef ihipMemPoolHandle_t from_ptr(chip.ihipMemPoolHandle_t* ptr, bint owner=False):
        """Factory function to create ``ihipMemPoolHandle_t`` objects from
        given ``chip.ihipMemPoolHandle_t`` pointer.
        """
        # Fast call to __new__() that bypasses the __init__() constructor.
        cdef ihipMemPoolHandle_t wrapper = ihipMemPoolHandle_t.__new__(ihipMemPoolHandle_t)
        wrapper._ptr = ptr
        wrapper.ptr_owner = owner
        return wrapper

    @staticmethod
    cdef ihipMemPoolHandle_t from_pyobj(object pyobj):
        """Derives a ihipMemPoolHandle_t from a Python object.

        Derives a ihipMemPoolHandle_t from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``ihipMemPoolHandle_t`` reference, this method
        returns it directly. No new ``ihipMemPoolHandle_t`` is created in this case.

        Args:
            pyobj (object): Must be either ``None``, a simple, contiguous buffer according to the buffer protocol,
                            or of type ``ihipMemPoolHandle_t``, ``int``, or ``ctypes.c_void_p``

        Note:
            This routine does not perform a copy but returns the original ``pyobj``
            if ``pyobj`` is an instance of ihipMemPoolHandle_t!
        """
        cdef ihipMemPoolHandle_t wrapper = ihipMemPoolHandle_t.__new__(ihipMemPoolHandle_t)
        cdef dict cuda_array_interface = getattr(pyobj, "__cuda_array_interface__", None)

        if pyobj is None:
            wrapper._ptr = NULL
        elif isinstance(pyobj,ihipMemPoolHandle_t):
            return pyobj
        elif isinstance(pyobj,int):
            wrapper._ptr = <chip.ihipMemPoolHandle_t*>cpython.long.PyLong_AsVoidPtr(pyobj)
        elif isinstance(pyobj,ctypes.c_void_p):
            wrapper._ptr = <chip.ihipMemPoolHandle_t*>cpython.long.PyLong_AsVoidPtr(pyobj.value) if pyobj.value != None else NULL
        elif cuda_array_interface != None:
            if not "data" in cuda_array_interface:
                raise ValueError("input object has '__cuda_array_interface__' attribute but the dict has no 'data' key")
            ptr_as_int = cuda_array_interface["data"][0]
            wrapper._ptr = <chip.ihipMemPoolHandle_t*>cpython.long.PyLong_AsVoidPtr(ptr_as_int)
        elif cpython.buffer.PyObject_CheckBuffer(pyobj):
            err = cpython.buffer.PyObject_GetBuffer( 
                pyobj,
                &wrapper._py_buffer, 
                cpython.buffer.PyBUF_SIMPLE | cpython.buffer.PyBUF_ANY_CONTIGUOUS
            )
            if err == -1:
                raise RuntimeError("failed to create simple, contiguous Py_buffer from Python object")
            wrapper._py_buffer_acquired = True
            wrapper._ptr = <chip.ihipMemPoolHandle_t*>wrapper._py_buffer.buf
        else:
            raise TypeError(f"unsupported input type: '{str(type(pyobj))}'")
        return wrapper
    def __dealloc__(self):
        # Release the buffer handle
        if self._py_buffer_acquired is True:
            cpython.buffer.PyBuffer_Release(&self._py_buffer)
    
    def __int__(self):
        """Returns the data's address as long integer."""
        return cpython.long.PyLong_FromVoidPtr(self._ptr)
    def __repr__(self):
        return f"<ihipMemPoolHandle_t object, self.ptr={int(self)}>"
    def as_c_void_p(self):
        """Returns the data's address as `ctypes.c_void_p`"""
        return ctypes.c_void_p(int(self))
    @staticmethod
    def PROPERTIES():
        return []

    def __contains__(self,item):
        properties = self.PROPERTIES()
        return item in properties

    def __getitem__(self,item):
        properties = self.PROPERTIES()
        if isinstance(item,int):
            if item < 0 or item >= len(properties):
                raise IndexError()
            return getattr(self,properties[item])
        raise ValueError("'item' type must be 'int'")


hipMemPool_t = ihipMemPoolHandle_t

cdef class hipFuncAttributes:
    # members declared in pxd file

    def __cinit__(self):
        self._ptr = NULL
        self.ptr_owner = False
        self._py_buffer_acquired = False

    @staticmethod
    cdef hipFuncAttributes from_ptr(chip.hipFuncAttributes* ptr, bint owner=False):
        """Factory function to create ``hipFuncAttributes`` objects from
        given ``chip.hipFuncAttributes`` pointer.

        Setting ``owner`` flag to ``True`` causes
        the extension type to ``free`` the structure pointed to by ``ptr``
        when the wrapper object is deallocated.
        """
        # Fast call to __new__() that bypasses the __init__() constructor.
        cdef hipFuncAttributes wrapper = hipFuncAttributes.__new__(hipFuncAttributes)
        wrapper._ptr = ptr
        wrapper.ptr_owner = owner
        return wrapper

    @staticmethod
    cdef hipFuncAttributes from_pyobj(object pyobj):
        """Derives a hipFuncAttributes from a Python object.

        Derives a hipFuncAttributes from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``hipFuncAttributes`` reference, this method
        returns it directly. No new ``hipFuncAttributes`` is created in this case.

        Args:
            pyobj (object): Must be either ``None``, a simple, contiguous buffer according to the buffer protocol,
                            or of type ``hipFuncAttributes``, ``int``, or ``ctypes.c_void_p``

        Note:
            This routine does not perform a copy but returns the original ``pyobj``
            if ``pyobj`` is an instance of hipFuncAttributes!
        """
        cdef hipFuncAttributes wrapper = hipFuncAttributes.__new__(hipFuncAttributes)
        cdef dict cuda_array_interface = getattr(pyobj, "__cuda_array_interface__", None)

        if pyobj is None:
            wrapper._ptr = NULL
        elif isinstance(pyobj,hipFuncAttributes):
            return pyobj
        elif isinstance(pyobj,int):
            wrapper._ptr = <chip.hipFuncAttributes*>cpython.long.PyLong_AsVoidPtr(pyobj)
        elif isinstance(pyobj,ctypes.c_void_p):
            wrapper._ptr = <chip.hipFuncAttributes*>cpython.long.PyLong_AsVoidPtr(pyobj.value) if pyobj.value != None else NULL
        elif cuda_array_interface != None:
            if not "data" in cuda_array_interface:
                raise ValueError("input object has '__cuda_array_interface__' attribute but the dict has no 'data' key")
            ptr_as_int = cuda_array_interface["data"][0]
            wrapper._ptr = <chip.hipFuncAttributes*>cpython.long.PyLong_AsVoidPtr(ptr_as_int)
        elif cpython.buffer.PyObject_CheckBuffer(pyobj):
            err = cpython.buffer.PyObject_GetBuffer( 
                pyobj,
                &wrapper._py_buffer, 
                cpython.buffer.PyBUF_SIMPLE | cpython.buffer.PyBUF_ANY_CONTIGUOUS
            )
            if err == -1:
                raise RuntimeError("failed to create simple, contiguous Py_buffer from Python object")
            wrapper._py_buffer_acquired = True
            wrapper._ptr = <chip.hipFuncAttributes*>wrapper._py_buffer.buf
        else:
            raise TypeError(f"unsupported input type: '{str(type(pyobj))}'")
        return wrapper
    def __dealloc__(self):
        # Release the buffer handle
        if self._py_buffer_acquired is True:
            cpython.buffer.PyBuffer_Release(&self._py_buffer)
        # De-allocate if not null and flag is set
        if self._ptr is not NULL and self.ptr_owner is True:
            stdlib.free(self._ptr)
            self._ptr = NULL
    @staticmethod
    cdef __allocate(chip.hipFuncAttributes** ptr):
        ptr[0] = <chip.hipFuncAttributes*>stdlib.malloc(sizeof(chip.hipFuncAttributes))

        if ptr[0] is NULL:
            raise MemoryError
        # TODO init values, if present

    @staticmethod
    cdef hipFuncAttributes new():
        """Factory function to create hipFuncAttributes objects with
        newly allocated chip.hipFuncAttributes"""
        cdef chip.hipFuncAttributes* ptr
        hipFuncAttributes.__allocate(&ptr)
        return hipFuncAttributes.from_ptr(ptr, owner=True)
   
    def __init__(self,*args,**kwargs):
        hipFuncAttributes.__allocate(&self._ptr)
        self.ptr_owner = True
        attribs = self.PROPERTIES()
        used_attribs = set()
        if len(args) > len(attribs):
            raise ValueError("More positional arguments specified than this type has properties.")
        for i,v in enumerate(args):
            setattr(self,attribs[i],v)
            used_attribs.add(attribs[i])
        valid_names = ", ".join(["'"+p+"'" for p in attribs])
        for k,v in kwargs.items():
            if k in used_attribs:
                raise KeyError(f"argument '{k}' has already been specified as positional argument.")
            elif k not in attribs:
                raise KeyError(f"'{k}' is no valid property name. Valid names: {valid_names}")
            setattr(self,k,v)
    
    def __int__(self):
        """Returns the data's address as long integer."""
        return cpython.long.PyLong_FromVoidPtr(self._ptr)
    def __repr__(self):
        return f"<hipFuncAttributes object, self.ptr={int(self)}>"
    def as_c_void_p(self):
        """Returns the data's address as `ctypes.c_void_p`"""
        return ctypes.c_void_p(int(self))
    def get_binaryVersion(self, i):
        """Get value ``binaryVersion`` of ``self._ptr[i]``.
        """
        return self._ptr[i].binaryVersion
    def set_binaryVersion(self, i, int value):
        """Set value ``binaryVersion`` of ``self._ptr[i]``.
        """
        self._ptr[i].binaryVersion = value
    @property
    def binaryVersion(self):
        return self.get_binaryVersion(0)
    @binaryVersion.setter
    def binaryVersion(self, int value):
        self.set_binaryVersion(0,value)

    def get_cacheModeCA(self, i):
        """Get value ``cacheModeCA`` of ``self._ptr[i]``.
        """
        return self._ptr[i].cacheModeCA
    def set_cacheModeCA(self, i, int value):
        """Set value ``cacheModeCA`` of ``self._ptr[i]``.
        """
        self._ptr[i].cacheModeCA = value
    @property
    def cacheModeCA(self):
        return self.get_cacheModeCA(0)
    @cacheModeCA.setter
    def cacheModeCA(self, int value):
        self.set_cacheModeCA(0,value)

    def get_constSizeBytes(self, i):
        """Get value ``constSizeBytes`` of ``self._ptr[i]``.
        """
        return self._ptr[i].constSizeBytes
    def set_constSizeBytes(self, i, unsigned long value):
        """Set value ``constSizeBytes`` of ``self._ptr[i]``.
        """
        self._ptr[i].constSizeBytes = value
    @property
    def constSizeBytes(self):
        return self.get_constSizeBytes(0)
    @constSizeBytes.setter
    def constSizeBytes(self, unsigned long value):
        self.set_constSizeBytes(0,value)

    def get_localSizeBytes(self, i):
        """Get value ``localSizeBytes`` of ``self._ptr[i]``.
        """
        return self._ptr[i].localSizeBytes
    def set_localSizeBytes(self, i, unsigned long value):
        """Set value ``localSizeBytes`` of ``self._ptr[i]``.
        """
        self._ptr[i].localSizeBytes = value
    @property
    def localSizeBytes(self):
        return self.get_localSizeBytes(0)
    @localSizeBytes.setter
    def localSizeBytes(self, unsigned long value):
        self.set_localSizeBytes(0,value)

    def get_maxDynamicSharedSizeBytes(self, i):
        """Get value ``maxDynamicSharedSizeBytes`` of ``self._ptr[i]``.
        """
        return self._ptr[i].maxDynamicSharedSizeBytes
    def set_maxDynamicSharedSizeBytes(self, i, int value):
        """Set value ``maxDynamicSharedSizeBytes`` of ``self._ptr[i]``.
        """
        self._ptr[i].maxDynamicSharedSizeBytes = value
    @property
    def maxDynamicSharedSizeBytes(self):
        return self.get_maxDynamicSharedSizeBytes(0)
    @maxDynamicSharedSizeBytes.setter
    def maxDynamicSharedSizeBytes(self, int value):
        self.set_maxDynamicSharedSizeBytes(0,value)

    def get_maxThreadsPerBlock(self, i):
        """Get value ``maxThreadsPerBlock`` of ``self._ptr[i]``.
        """
        return self._ptr[i].maxThreadsPerBlock
    def set_maxThreadsPerBlock(self, i, int value):
        """Set value ``maxThreadsPerBlock`` of ``self._ptr[i]``.
        """
        self._ptr[i].maxThreadsPerBlock = value
    @property
    def maxThreadsPerBlock(self):
        return self.get_maxThreadsPerBlock(0)
    @maxThreadsPerBlock.setter
    def maxThreadsPerBlock(self, int value):
        self.set_maxThreadsPerBlock(0,value)

    def get_numRegs(self, i):
        """Get value ``numRegs`` of ``self._ptr[i]``.
        """
        return self._ptr[i].numRegs
    def set_numRegs(self, i, int value):
        """Set value ``numRegs`` of ``self._ptr[i]``.
        """
        self._ptr[i].numRegs = value
    @property
    def numRegs(self):
        return self.get_numRegs(0)
    @numRegs.setter
    def numRegs(self, int value):
        self.set_numRegs(0,value)

    def get_preferredShmemCarveout(self, i):
        """Get value ``preferredShmemCarveout`` of ``self._ptr[i]``.
        """
        return self._ptr[i].preferredShmemCarveout
    def set_preferredShmemCarveout(self, i, int value):
        """Set value ``preferredShmemCarveout`` of ``self._ptr[i]``.
        """
        self._ptr[i].preferredShmemCarveout = value
    @property
    def preferredShmemCarveout(self):
        return self.get_preferredShmemCarveout(0)
    @preferredShmemCarveout.setter
    def preferredShmemCarveout(self, int value):
        self.set_preferredShmemCarveout(0,value)

    def get_ptxVersion(self, i):
        """Get value ``ptxVersion`` of ``self._ptr[i]``.
        """
        return self._ptr[i].ptxVersion
    def set_ptxVersion(self, i, int value):
        """Set value ``ptxVersion`` of ``self._ptr[i]``.
        """
        self._ptr[i].ptxVersion = value
    @property
    def ptxVersion(self):
        return self.get_ptxVersion(0)
    @ptxVersion.setter
    def ptxVersion(self, int value):
        self.set_ptxVersion(0,value)

    def get_sharedSizeBytes(self, i):
        """Get value ``sharedSizeBytes`` of ``self._ptr[i]``.
        """
        return self._ptr[i].sharedSizeBytes
    def set_sharedSizeBytes(self, i, unsigned long value):
        """Set value ``sharedSizeBytes`` of ``self._ptr[i]``.
        """
        self._ptr[i].sharedSizeBytes = value
    @property
    def sharedSizeBytes(self):
        return self.get_sharedSizeBytes(0)
    @sharedSizeBytes.setter
    def sharedSizeBytes(self, unsigned long value):
        self.set_sharedSizeBytes(0,value)

    @staticmethod
    def PROPERTIES():
        return ["binaryVersion","cacheModeCA","constSizeBytes","localSizeBytes","maxDynamicSharedSizeBytes","maxThreadsPerBlock","numRegs","preferredShmemCarveout","ptxVersion","sharedSizeBytes"]

    def __contains__(self,item):
        properties = self.PROPERTIES()
        return item in properties

    def __getitem__(self,item):
        properties = self.PROPERTIES()
        if isinstance(item,int):
            if item < 0 or item >= len(properties):
                raise IndexError()
            return getattr(self,properties[item])
        raise ValueError("'item' type must be 'int'")


cdef class ihipEvent_t:
    # members declared in pxd file

    def __cinit__(self):
        self._ptr = NULL
        self.ptr_owner = False
        self._py_buffer_acquired = False

    @staticmethod
    cdef ihipEvent_t from_ptr(chip.ihipEvent_t* ptr, bint owner=False):
        """Factory function to create ``ihipEvent_t`` objects from
        given ``chip.ihipEvent_t`` pointer.
        """
        # Fast call to __new__() that bypasses the __init__() constructor.
        cdef ihipEvent_t wrapper = ihipEvent_t.__new__(ihipEvent_t)
        wrapper._ptr = ptr
        wrapper.ptr_owner = owner
        return wrapper

    @staticmethod
    cdef ihipEvent_t from_pyobj(object pyobj):
        """Derives a ihipEvent_t from a Python object.

        Derives a ihipEvent_t from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``ihipEvent_t`` reference, this method
        returns it directly. No new ``ihipEvent_t`` is created in this case.

        Args:
            pyobj (object): Must be either ``None``, a simple, contiguous buffer according to the buffer protocol,
                            or of type ``ihipEvent_t``, ``int``, or ``ctypes.c_void_p``

        Note:
            This routine does not perform a copy but returns the original ``pyobj``
            if ``pyobj`` is an instance of ihipEvent_t!
        """
        cdef ihipEvent_t wrapper = ihipEvent_t.__new__(ihipEvent_t)
        cdef dict cuda_array_interface = getattr(pyobj, "__cuda_array_interface__", None)

        if pyobj is None:
            wrapper._ptr = NULL
        elif isinstance(pyobj,ihipEvent_t):
            return pyobj
        elif isinstance(pyobj,int):
            wrapper._ptr = <chip.ihipEvent_t*>cpython.long.PyLong_AsVoidPtr(pyobj)
        elif isinstance(pyobj,ctypes.c_void_p):
            wrapper._ptr = <chip.ihipEvent_t*>cpython.long.PyLong_AsVoidPtr(pyobj.value) if pyobj.value != None else NULL
        elif cuda_array_interface != None:
            if not "data" in cuda_array_interface:
                raise ValueError("input object has '__cuda_array_interface__' attribute but the dict has no 'data' key")
            ptr_as_int = cuda_array_interface["data"][0]
            wrapper._ptr = <chip.ihipEvent_t*>cpython.long.PyLong_AsVoidPtr(ptr_as_int)
        elif cpython.buffer.PyObject_CheckBuffer(pyobj):
            err = cpython.buffer.PyObject_GetBuffer( 
                pyobj,
                &wrapper._py_buffer, 
                cpython.buffer.PyBUF_SIMPLE | cpython.buffer.PyBUF_ANY_CONTIGUOUS
            )
            if err == -1:
                raise RuntimeError("failed to create simple, contiguous Py_buffer from Python object")
            wrapper._py_buffer_acquired = True
            wrapper._ptr = <chip.ihipEvent_t*>wrapper._py_buffer.buf
        else:
            raise TypeError(f"unsupported input type: '{str(type(pyobj))}'")
        return wrapper
    def __dealloc__(self):
        # Release the buffer handle
        if self._py_buffer_acquired is True:
            cpython.buffer.PyBuffer_Release(&self._py_buffer)
    
    def __int__(self):
        """Returns the data's address as long integer."""
        return cpython.long.PyLong_FromVoidPtr(self._ptr)
    def __repr__(self):
        return f"<ihipEvent_t object, self.ptr={int(self)}>"
    def as_c_void_p(self):
        """Returns the data's address as `ctypes.c_void_p`"""
        return ctypes.c_void_p(int(self))
    @staticmethod
    def PROPERTIES():
        return []

    def __contains__(self,item):
        properties = self.PROPERTIES()
        return item in properties

    def __getitem__(self,item):
        properties = self.PROPERTIES()
        if isinstance(item,int):
            if item < 0 or item >= len(properties):
                raise IndexError()
            return getattr(self,properties[item])
        raise ValueError("'item' type must be 'int'")


hipEvent_t = ihipEvent_t

class _hipLimit_t__Base(enum.IntEnum):
    """Empty enum base class that allows subclassing.
    """
    pass
class hipLimit_t(_hipLimit_t__Base):
    hipLimitStackSize = chip.hipLimitStackSize
    hipLimitPrintfFifoSize = chip.hipLimitPrintfFifoSize
    hipLimitMallocHeapSize = chip.hipLimitMallocHeapSize
    hipLimitRange = chip.hipLimitRange
    @staticmethod
    def ctypes_type():
        """The type of the enum constants as ctypes type."""
        return ctypes.c_uint 


class _hipMemoryAdvise__Base(enum.IntEnum):
    """Empty enum base class that allows subclassing.
    """
    pass
class hipMemoryAdvise(_hipMemoryAdvise__Base):
    hipMemAdviseSetReadMostly = chip.hipMemAdviseSetReadMostly
    hipMemAdviseUnsetReadMostly = chip.hipMemAdviseUnsetReadMostly
    hipMemAdviseSetPreferredLocation = chip.hipMemAdviseSetPreferredLocation
    hipMemAdviseUnsetPreferredLocation = chip.hipMemAdviseUnsetPreferredLocation
    hipMemAdviseSetAccessedBy = chip.hipMemAdviseSetAccessedBy
    hipMemAdviseUnsetAccessedBy = chip.hipMemAdviseUnsetAccessedBy
    hipMemAdviseSetCoarseGrain = chip.hipMemAdviseSetCoarseGrain
    hipMemAdviseUnsetCoarseGrain = chip.hipMemAdviseUnsetCoarseGrain
    @staticmethod
    def ctypes_type():
        """The type of the enum constants as ctypes type."""
        return ctypes.c_uint 


class _hipMemRangeCoherencyMode__Base(enum.IntEnum):
    """Empty enum base class that allows subclassing.
    """
    pass
class hipMemRangeCoherencyMode(_hipMemRangeCoherencyMode__Base):
    hipMemRangeCoherencyModeFineGrain = chip.hipMemRangeCoherencyModeFineGrain
    hipMemRangeCoherencyModeCoarseGrain = chip.hipMemRangeCoherencyModeCoarseGrain
    hipMemRangeCoherencyModeIndeterminate = chip.hipMemRangeCoherencyModeIndeterminate
    @staticmethod
    def ctypes_type():
        """The type of the enum constants as ctypes type."""
        return ctypes.c_uint 


class _hipMemRangeAttribute__Base(enum.IntEnum):
    """Empty enum base class that allows subclassing.
    """
    pass
class hipMemRangeAttribute(_hipMemRangeAttribute__Base):
    hipMemRangeAttributeReadMostly = chip.hipMemRangeAttributeReadMostly
    hipMemRangeAttributePreferredLocation = chip.hipMemRangeAttributePreferredLocation
    hipMemRangeAttributeAccessedBy = chip.hipMemRangeAttributeAccessedBy
    hipMemRangeAttributeLastPrefetchLocation = chip.hipMemRangeAttributeLastPrefetchLocation
    hipMemRangeAttributeCoherencyMode = chip.hipMemRangeAttributeCoherencyMode
    @staticmethod
    def ctypes_type():
        """The type of the enum constants as ctypes type."""
        return ctypes.c_uint 


class _hipMemPoolAttr__Base(enum.IntEnum):
    """Empty enum base class that allows subclassing.
    """
    pass
class hipMemPoolAttr(_hipMemPoolAttr__Base):
    hipMemPoolReuseFollowEventDependencies = chip.hipMemPoolReuseFollowEventDependencies
    hipMemPoolReuseAllowOpportunistic = chip.hipMemPoolReuseAllowOpportunistic
    hipMemPoolReuseAllowInternalDependencies = chip.hipMemPoolReuseAllowInternalDependencies
    hipMemPoolAttrReleaseThreshold = chip.hipMemPoolAttrReleaseThreshold
    hipMemPoolAttrReservedMemCurrent = chip.hipMemPoolAttrReservedMemCurrent
    hipMemPoolAttrReservedMemHigh = chip.hipMemPoolAttrReservedMemHigh
    hipMemPoolAttrUsedMemCurrent = chip.hipMemPoolAttrUsedMemCurrent
    hipMemPoolAttrUsedMemHigh = chip.hipMemPoolAttrUsedMemHigh
    @staticmethod
    def ctypes_type():
        """The type of the enum constants as ctypes type."""
        return ctypes.c_uint 


class _hipMemLocationType__Base(enum.IntEnum):
    """Empty enum base class that allows subclassing.
    """
    pass
class hipMemLocationType(_hipMemLocationType__Base):
    hipMemLocationTypeInvalid = chip.hipMemLocationTypeInvalid
    hipMemLocationTypeDevice = chip.hipMemLocationTypeDevice
    @staticmethod
    def ctypes_type():
        """The type of the enum constants as ctypes type."""
        return ctypes.c_uint 


cdef class hipMemLocation:
    # members declared in pxd file

    def __cinit__(self):
        self._ptr = NULL
        self.ptr_owner = False
        self._py_buffer_acquired = False

    @staticmethod
    cdef hipMemLocation from_ptr(chip.hipMemLocation* ptr, bint owner=False):
        """Factory function to create ``hipMemLocation`` objects from
        given ``chip.hipMemLocation`` pointer.

        Setting ``owner`` flag to ``True`` causes
        the extension type to ``free`` the structure pointed to by ``ptr``
        when the wrapper object is deallocated.
        """
        # Fast call to __new__() that bypasses the __init__() constructor.
        cdef hipMemLocation wrapper = hipMemLocation.__new__(hipMemLocation)
        wrapper._ptr = ptr
        wrapper.ptr_owner = owner
        return wrapper

    @staticmethod
    cdef hipMemLocation from_pyobj(object pyobj):
        """Derives a hipMemLocation from a Python object.

        Derives a hipMemLocation from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``hipMemLocation`` reference, this method
        returns it directly. No new ``hipMemLocation`` is created in this case.

        Args:
            pyobj (object): Must be either ``None``, a simple, contiguous buffer according to the buffer protocol,
                            or of type ``hipMemLocation``, ``int``, or ``ctypes.c_void_p``

        Note:
            This routine does not perform a copy but returns the original ``pyobj``
            if ``pyobj`` is an instance of hipMemLocation!
        """
        cdef hipMemLocation wrapper = hipMemLocation.__new__(hipMemLocation)
        cdef dict cuda_array_interface = getattr(pyobj, "__cuda_array_interface__", None)

        if pyobj is None:
            wrapper._ptr = NULL
        elif isinstance(pyobj,hipMemLocation):
            return pyobj
        elif isinstance(pyobj,int):
            wrapper._ptr = <chip.hipMemLocation*>cpython.long.PyLong_AsVoidPtr(pyobj)
        elif isinstance(pyobj,ctypes.c_void_p):
            wrapper._ptr = <chip.hipMemLocation*>cpython.long.PyLong_AsVoidPtr(pyobj.value) if pyobj.value != None else NULL
        elif cuda_array_interface != None:
            if not "data" in cuda_array_interface:
                raise ValueError("input object has '__cuda_array_interface__' attribute but the dict has no 'data' key")
            ptr_as_int = cuda_array_interface["data"][0]
            wrapper._ptr = <chip.hipMemLocation*>cpython.long.PyLong_AsVoidPtr(ptr_as_int)
        elif cpython.buffer.PyObject_CheckBuffer(pyobj):
            err = cpython.buffer.PyObject_GetBuffer( 
                pyobj,
                &wrapper._py_buffer, 
                cpython.buffer.PyBUF_SIMPLE | cpython.buffer.PyBUF_ANY_CONTIGUOUS
            )
            if err == -1:
                raise RuntimeError("failed to create simple, contiguous Py_buffer from Python object")
            wrapper._py_buffer_acquired = True
            wrapper._ptr = <chip.hipMemLocation*>wrapper._py_buffer.buf
        else:
            raise TypeError(f"unsupported input type: '{str(type(pyobj))}'")
        return wrapper
    def __dealloc__(self):
        # Release the buffer handle
        if self._py_buffer_acquired is True:
            cpython.buffer.PyBuffer_Release(&self._py_buffer)
        # De-allocate if not null and flag is set
        if self._ptr is not NULL and self.ptr_owner is True:
            stdlib.free(self._ptr)
            self._ptr = NULL
    @staticmethod
    cdef __allocate(chip.hipMemLocation** ptr):
        ptr[0] = <chip.hipMemLocation*>stdlib.malloc(sizeof(chip.hipMemLocation))

        if ptr[0] is NULL:
            raise MemoryError
        # TODO init values, if present

    @staticmethod
    cdef hipMemLocation new():
        """Factory function to create hipMemLocation objects with
        newly allocated chip.hipMemLocation"""
        cdef chip.hipMemLocation* ptr
        hipMemLocation.__allocate(&ptr)
        return hipMemLocation.from_ptr(ptr, owner=True)
   
    def __init__(self,*args,**kwargs):
        hipMemLocation.__allocate(&self._ptr)
        self.ptr_owner = True
        attribs = self.PROPERTIES()
        used_attribs = set()
        if len(args) > len(attribs):
            raise ValueError("More positional arguments specified than this type has properties.")
        for i,v in enumerate(args):
            setattr(self,attribs[i],v)
            used_attribs.add(attribs[i])
        valid_names = ", ".join(["'"+p+"'" for p in attribs])
        for k,v in kwargs.items():
            if k in used_attribs:
                raise KeyError(f"argument '{k}' has already been specified as positional argument.")
            elif k not in attribs:
                raise KeyError(f"'{k}' is no valid property name. Valid names: {valid_names}")
            setattr(self,k,v)
    
    def __int__(self):
        """Returns the data's address as long integer."""
        return cpython.long.PyLong_FromVoidPtr(self._ptr)
    def __repr__(self):
        return f"<hipMemLocation object, self.ptr={int(self)}>"
    def as_c_void_p(self):
        """Returns the data's address as `ctypes.c_void_p`"""
        return ctypes.c_void_p(int(self))
    def get_type(self, i):
        """Get value of ``type`` of ``self._ptr[i]``.
        """
        return hipMemLocationType(self._ptr[i].type)
    def set_type(self, i, value):
        """Set value ``type`` of ``self._ptr[i]``.
        """
        if not isinstance(value, hipMemLocationType):
            raise TypeError("'value' must be of type 'hipMemLocationType'")
        self._ptr[i].type = value.value
    @property
    def type(self):
        return self.get_type(0)
    @type.setter
    def type(self, value):
        self.set_type(0,value)

    def get_id(self, i):
        """Get value ``id`` of ``self._ptr[i]``.
        """
        return self._ptr[i].id
    def set_id(self, i, int value):
        """Set value ``id`` of ``self._ptr[i]``.
        """
        self._ptr[i].id = value
    @property
    def id(self):
        return self.get_id(0)
    @id.setter
    def id(self, int value):
        self.set_id(0,value)

    @staticmethod
    def PROPERTIES():
        return ["type","id"]

    def __contains__(self,item):
        properties = self.PROPERTIES()
        return item in properties

    def __getitem__(self,item):
        properties = self.PROPERTIES()
        if isinstance(item,int):
            if item < 0 or item >= len(properties):
                raise IndexError()
            return getattr(self,properties[item])
        raise ValueError("'item' type must be 'int'")


class _hipMemAccessFlags__Base(enum.IntEnum):
    """Empty enum base class that allows subclassing.
    """
    pass
class hipMemAccessFlags(_hipMemAccessFlags__Base):
    hipMemAccessFlagsProtNone = chip.hipMemAccessFlagsProtNone
    hipMemAccessFlagsProtRead = chip.hipMemAccessFlagsProtRead
    hipMemAccessFlagsProtReadWrite = chip.hipMemAccessFlagsProtReadWrite
    @staticmethod
    def ctypes_type():
        """The type of the enum constants as ctypes type."""
        return ctypes.c_uint 


cdef class hipMemAccessDesc:
    # members declared in pxd file

    def __cinit__(self):
        self._ptr = NULL
        self.ptr_owner = False
        self._py_buffer_acquired = False

    @staticmethod
    cdef hipMemAccessDesc from_ptr(chip.hipMemAccessDesc* ptr, bint owner=False):
        """Factory function to create ``hipMemAccessDesc`` objects from
        given ``chip.hipMemAccessDesc`` pointer.

        Setting ``owner`` flag to ``True`` causes
        the extension type to ``free`` the structure pointed to by ``ptr``
        when the wrapper object is deallocated.
        """
        # Fast call to __new__() that bypasses the __init__() constructor.
        cdef hipMemAccessDesc wrapper = hipMemAccessDesc.__new__(hipMemAccessDesc)
        wrapper._ptr = ptr
        wrapper.ptr_owner = owner
        return wrapper

    @staticmethod
    cdef hipMemAccessDesc from_pyobj(object pyobj):
        """Derives a hipMemAccessDesc from a Python object.

        Derives a hipMemAccessDesc from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``hipMemAccessDesc`` reference, this method
        returns it directly. No new ``hipMemAccessDesc`` is created in this case.

        Args:
            pyobj (object): Must be either ``None``, a simple, contiguous buffer according to the buffer protocol,
                            or of type ``hipMemAccessDesc``, ``int``, or ``ctypes.c_void_p``

        Note:
            This routine does not perform a copy but returns the original ``pyobj``
            if ``pyobj`` is an instance of hipMemAccessDesc!
        """
        cdef hipMemAccessDesc wrapper = hipMemAccessDesc.__new__(hipMemAccessDesc)
        cdef dict cuda_array_interface = getattr(pyobj, "__cuda_array_interface__", None)

        if pyobj is None:
            wrapper._ptr = NULL
        elif isinstance(pyobj,hipMemAccessDesc):
            return pyobj
        elif isinstance(pyobj,int):
            wrapper._ptr = <chip.hipMemAccessDesc*>cpython.long.PyLong_AsVoidPtr(pyobj)
        elif isinstance(pyobj,ctypes.c_void_p):
            wrapper._ptr = <chip.hipMemAccessDesc*>cpython.long.PyLong_AsVoidPtr(pyobj.value) if pyobj.value != None else NULL
        elif cuda_array_interface != None:
            if not "data" in cuda_array_interface:
                raise ValueError("input object has '__cuda_array_interface__' attribute but the dict has no 'data' key")
            ptr_as_int = cuda_array_interface["data"][0]
            wrapper._ptr = <chip.hipMemAccessDesc*>cpython.long.PyLong_AsVoidPtr(ptr_as_int)
        elif cpython.buffer.PyObject_CheckBuffer(pyobj):
            err = cpython.buffer.PyObject_GetBuffer( 
                pyobj,
                &wrapper._py_buffer, 
                cpython.buffer.PyBUF_SIMPLE | cpython.buffer.PyBUF_ANY_CONTIGUOUS
            )
            if err == -1:
                raise RuntimeError("failed to create simple, contiguous Py_buffer from Python object")
            wrapper._py_buffer_acquired = True
            wrapper._ptr = <chip.hipMemAccessDesc*>wrapper._py_buffer.buf
        else:
            raise TypeError(f"unsupported input type: '{str(type(pyobj))}'")
        return wrapper
    def __dealloc__(self):
        # Release the buffer handle
        if self._py_buffer_acquired is True:
            cpython.buffer.PyBuffer_Release(&self._py_buffer)
        # De-allocate if not null and flag is set
        if self._ptr is not NULL and self.ptr_owner is True:
            stdlib.free(self._ptr)
            self._ptr = NULL
    @staticmethod
    cdef __allocate(chip.hipMemAccessDesc** ptr):
        ptr[0] = <chip.hipMemAccessDesc*>stdlib.malloc(sizeof(chip.hipMemAccessDesc))

        if ptr[0] is NULL:
            raise MemoryError
        # TODO init values, if present

    @staticmethod
    cdef hipMemAccessDesc new():
        """Factory function to create hipMemAccessDesc objects with
        newly allocated chip.hipMemAccessDesc"""
        cdef chip.hipMemAccessDesc* ptr
        hipMemAccessDesc.__allocate(&ptr)
        return hipMemAccessDesc.from_ptr(ptr, owner=True)
   
    def __init__(self,*args,**kwargs):
        hipMemAccessDesc.__allocate(&self._ptr)
        self.ptr_owner = True
        attribs = self.PROPERTIES()
        used_attribs = set()
        if len(args) > len(attribs):
            raise ValueError("More positional arguments specified than this type has properties.")
        for i,v in enumerate(args):
            setattr(self,attribs[i],v)
            used_attribs.add(attribs[i])
        valid_names = ", ".join(["'"+p+"'" for p in attribs])
        for k,v in kwargs.items():
            if k in used_attribs:
                raise KeyError(f"argument '{k}' has already been specified as positional argument.")
            elif k not in attribs:
                raise KeyError(f"'{k}' is no valid property name. Valid names: {valid_names}")
            setattr(self,k,v)
    
    def __int__(self):
        """Returns the data's address as long integer."""
        return cpython.long.PyLong_FromVoidPtr(self._ptr)
    def __repr__(self):
        return f"<hipMemAccessDesc object, self.ptr={int(self)}>"
    def as_c_void_p(self):
        """Returns the data's address as `ctypes.c_void_p`"""
        return ctypes.c_void_p(int(self))
    def get_location(self, i):
        """Get value of ``location`` of ``self._ptr[i]``.
        """
        return hipMemLocation.from_ptr(&self._ptr[i].location)
    @property
    def location(self):
        return self.get_location(0)

    def get_flags(self, i):
        """Get value of ``flags`` of ``self._ptr[i]``.
        """
        return hipMemAccessFlags(self._ptr[i].flags)
    def set_flags(self, i, value):
        """Set value ``flags`` of ``self._ptr[i]``.
        """
        if not isinstance(value, hipMemAccessFlags):
            raise TypeError("'value' must be of type 'hipMemAccessFlags'")
        self._ptr[i].flags = value.value
    @property
    def flags(self):
        return self.get_flags(0)
    @flags.setter
    def flags(self, value):
        self.set_flags(0,value)

    @staticmethod
    def PROPERTIES():
        return ["location","flags"]

    def __contains__(self,item):
        properties = self.PROPERTIES()
        return item in properties

    def __getitem__(self,item):
        properties = self.PROPERTIES()
        if isinstance(item,int):
            if item < 0 or item >= len(properties):
                raise IndexError()
            return getattr(self,properties[item])
        raise ValueError("'item' type must be 'int'")


class _hipMemAllocationType__Base(enum.IntEnum):
    """Empty enum base class that allows subclassing.
    """
    pass
class hipMemAllocationType(_hipMemAllocationType__Base):
    hipMemAllocationTypeInvalid = chip.hipMemAllocationTypeInvalid
    hipMemAllocationTypePinned = chip.hipMemAllocationTypePinned
    hipMemAllocationTypeMax = chip.hipMemAllocationTypeMax
    @staticmethod
    def ctypes_type():
        """The type of the enum constants as ctypes type."""
        return ctypes.c_uint 


class _hipMemAllocationHandleType__Base(enum.IntEnum):
    """Empty enum base class that allows subclassing.
    """
    pass
class hipMemAllocationHandleType(_hipMemAllocationHandleType__Base):
    hipMemHandleTypeNone = chip.hipMemHandleTypeNone
    hipMemHandleTypePosixFileDescriptor = chip.hipMemHandleTypePosixFileDescriptor
    hipMemHandleTypeWin32 = chip.hipMemHandleTypeWin32
    hipMemHandleTypeWin32Kmt = chip.hipMemHandleTypeWin32Kmt
    @staticmethod
    def ctypes_type():
        """The type of the enum constants as ctypes type."""
        return ctypes.c_uint 


cdef class hipMemPoolProps:
    # members declared in pxd file

    def __cinit__(self):
        self._ptr = NULL
        self.ptr_owner = False
        self._py_buffer_acquired = False

    @staticmethod
    cdef hipMemPoolProps from_ptr(chip.hipMemPoolProps* ptr, bint owner=False):
        """Factory function to create ``hipMemPoolProps`` objects from
        given ``chip.hipMemPoolProps`` pointer.

        Setting ``owner`` flag to ``True`` causes
        the extension type to ``free`` the structure pointed to by ``ptr``
        when the wrapper object is deallocated.
        """
        # Fast call to __new__() that bypasses the __init__() constructor.
        cdef hipMemPoolProps wrapper = hipMemPoolProps.__new__(hipMemPoolProps)
        wrapper._ptr = ptr
        wrapper.ptr_owner = owner
        return wrapper

    @staticmethod
    cdef hipMemPoolProps from_pyobj(object pyobj):
        """Derives a hipMemPoolProps from a Python object.

        Derives a hipMemPoolProps from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``hipMemPoolProps`` reference, this method
        returns it directly. No new ``hipMemPoolProps`` is created in this case.

        Args:
            pyobj (object): Must be either ``None``, a simple, contiguous buffer according to the buffer protocol,
                            or of type ``hipMemPoolProps``, ``int``, or ``ctypes.c_void_p``

        Note:
            This routine does not perform a copy but returns the original ``pyobj``
            if ``pyobj`` is an instance of hipMemPoolProps!
        """
        cdef hipMemPoolProps wrapper = hipMemPoolProps.__new__(hipMemPoolProps)
        cdef dict cuda_array_interface = getattr(pyobj, "__cuda_array_interface__", None)

        if pyobj is None:
            wrapper._ptr = NULL
        elif isinstance(pyobj,hipMemPoolProps):
            return pyobj
        elif isinstance(pyobj,int):
            wrapper._ptr = <chip.hipMemPoolProps*>cpython.long.PyLong_AsVoidPtr(pyobj)
        elif isinstance(pyobj,ctypes.c_void_p):
            wrapper._ptr = <chip.hipMemPoolProps*>cpython.long.PyLong_AsVoidPtr(pyobj.value) if pyobj.value != None else NULL
        elif cuda_array_interface != None:
            if not "data" in cuda_array_interface:
                raise ValueError("input object has '__cuda_array_interface__' attribute but the dict has no 'data' key")
            ptr_as_int = cuda_array_interface["data"][0]
            wrapper._ptr = <chip.hipMemPoolProps*>cpython.long.PyLong_AsVoidPtr(ptr_as_int)
        elif cpython.buffer.PyObject_CheckBuffer(pyobj):
            err = cpython.buffer.PyObject_GetBuffer( 
                pyobj,
                &wrapper._py_buffer, 
                cpython.buffer.PyBUF_SIMPLE | cpython.buffer.PyBUF_ANY_CONTIGUOUS
            )
            if err == -1:
                raise RuntimeError("failed to create simple, contiguous Py_buffer from Python object")
            wrapper._py_buffer_acquired = True
            wrapper._ptr = <chip.hipMemPoolProps*>wrapper._py_buffer.buf
        else:
            raise TypeError(f"unsupported input type: '{str(type(pyobj))}'")
        return wrapper
    def __dealloc__(self):
        # Release the buffer handle
        if self._py_buffer_acquired is True:
            cpython.buffer.PyBuffer_Release(&self._py_buffer)
        # De-allocate if not null and flag is set
        if self._ptr is not NULL and self.ptr_owner is True:
            stdlib.free(self._ptr)
            self._ptr = NULL
    @staticmethod
    cdef __allocate(chip.hipMemPoolProps** ptr):
        ptr[0] = <chip.hipMemPoolProps*>stdlib.malloc(sizeof(chip.hipMemPoolProps))

        if ptr[0] is NULL:
            raise MemoryError
        # TODO init values, if present

    @staticmethod
    cdef hipMemPoolProps new():
        """Factory function to create hipMemPoolProps objects with
        newly allocated chip.hipMemPoolProps"""
        cdef chip.hipMemPoolProps* ptr
        hipMemPoolProps.__allocate(&ptr)
        return hipMemPoolProps.from_ptr(ptr, owner=True)
   
    def __init__(self,*args,**kwargs):
        hipMemPoolProps.__allocate(&self._ptr)
        self.ptr_owner = True
        attribs = self.PROPERTIES()
        used_attribs = set()
        if len(args) > len(attribs):
            raise ValueError("More positional arguments specified than this type has properties.")
        for i,v in enumerate(args):
            setattr(self,attribs[i],v)
            used_attribs.add(attribs[i])
        valid_names = ", ".join(["'"+p+"'" for p in attribs])
        for k,v in kwargs.items():
            if k in used_attribs:
                raise KeyError(f"argument '{k}' has already been specified as positional argument.")
            elif k not in attribs:
                raise KeyError(f"'{k}' is no valid property name. Valid names: {valid_names}")
            setattr(self,k,v)
    
    def __int__(self):
        """Returns the data's address as long integer."""
        return cpython.long.PyLong_FromVoidPtr(self._ptr)
    def __repr__(self):
        return f"<hipMemPoolProps object, self.ptr={int(self)}>"
    def as_c_void_p(self):
        """Returns the data's address as `ctypes.c_void_p`"""
        return ctypes.c_void_p(int(self))
    def get_allocType(self, i):
        """Get value of ``allocType`` of ``self._ptr[i]``.
        """
        return hipMemAllocationType(self._ptr[i].allocType)
    def set_allocType(self, i, value):
        """Set value ``allocType`` of ``self._ptr[i]``.
        """
        if not isinstance(value, hipMemAllocationType):
            raise TypeError("'value' must be of type 'hipMemAllocationType'")
        self._ptr[i].allocType = value.value
    @property
    def allocType(self):
        return self.get_allocType(0)
    @allocType.setter
    def allocType(self, value):
        self.set_allocType(0,value)

    def get_handleTypes(self, i):
        """Get value of ``handleTypes`` of ``self._ptr[i]``.
        """
        return hipMemAllocationHandleType(self._ptr[i].handleTypes)
    def set_handleTypes(self, i, value):
        """Set value ``handleTypes`` of ``self._ptr[i]``.
        """
        if not isinstance(value, hipMemAllocationHandleType):
            raise TypeError("'value' must be of type 'hipMemAllocationHandleType'")
        self._ptr[i].handleTypes = value.value
    @property
    def handleTypes(self):
        return self.get_handleTypes(0)
    @handleTypes.setter
    def handleTypes(self, value):
        self.set_handleTypes(0,value)

    def get_location(self, i):
        """Get value of ``location`` of ``self._ptr[i]``.
        """
        return hipMemLocation.from_ptr(&self._ptr[i].location)
    @property
    def location(self):
        return self.get_location(0)

    def get_win32SecurityAttributes(self, i):
        """Get value ``win32SecurityAttributes`` of ``self._ptr[i]``.
        """
        return hip._util.types.DataHandle.from_ptr(self._ptr[i].win32SecurityAttributes)
    def set_win32SecurityAttributes(self, i, object value):
        """Set value ``win32SecurityAttributes`` of ``self._ptr[i]``.

        Note:
            This can be dangerous if the pointer is from a python object
            that is later on garbage collected.
        """
        self._ptr[i].win32SecurityAttributes = <void *>cpython.long.PyLong_AsVoidPtr(int(hip._util.types.DataHandle.from_pyobj(value)))
    @property
    def win32SecurityAttributes(self):
        """
        Note:
            Setting this win32SecurityAttributes can be dangerous if the underlying pointer is from a python object that
            is later on garbage collected.
        """
        return self.get_win32SecurityAttributes(0)
    @win32SecurityAttributes.setter
    def win32SecurityAttributes(self, object value):
        self.set_win32SecurityAttributes(0,value)

    def get_reserved(self, i):
        """Get value of ``reserved`` of ``self._ptr[i]``.
        """
        return self._ptr[i].reserved
    # TODO add setters
    #def set_reserved(self, i, unsigned char[64] value):
    #    """Set value ``reserved`` of ``self._ptr[i]``.
    #    """
    #    self._ptr[i].reserved = value
    @property
    def reserved(self):
        return self.get_reserved(0)
    # TODO add setters
    #@reserved.setter
    #def reserved(self, unsigned char[64] value):
    #    self.set_reserved(0,value)

    @staticmethod
    def PROPERTIES():
        return ["allocType","handleTypes","location","win32SecurityAttributes","reserved"]

    def __contains__(self,item):
        properties = self.PROPERTIES()
        return item in properties

    def __getitem__(self,item):
        properties = self.PROPERTIES()
        if isinstance(item,int):
            if item < 0 or item >= len(properties):
                raise IndexError()
            return getattr(self,properties[item])
        raise ValueError("'item' type must be 'int'")


cdef class hipMemPoolPtrExportData:
    # members declared in pxd file

    def __cinit__(self):
        self._ptr = NULL
        self.ptr_owner = False
        self._py_buffer_acquired = False

    @staticmethod
    cdef hipMemPoolPtrExportData from_ptr(chip.hipMemPoolPtrExportData* ptr, bint owner=False):
        """Factory function to create ``hipMemPoolPtrExportData`` objects from
        given ``chip.hipMemPoolPtrExportData`` pointer.

        Setting ``owner`` flag to ``True`` causes
        the extension type to ``free`` the structure pointed to by ``ptr``
        when the wrapper object is deallocated.
        """
        # Fast call to __new__() that bypasses the __init__() constructor.
        cdef hipMemPoolPtrExportData wrapper = hipMemPoolPtrExportData.__new__(hipMemPoolPtrExportData)
        wrapper._ptr = ptr
        wrapper.ptr_owner = owner
        return wrapper

    @staticmethod
    cdef hipMemPoolPtrExportData from_pyobj(object pyobj):
        """Derives a hipMemPoolPtrExportData from a Python object.

        Derives a hipMemPoolPtrExportData from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``hipMemPoolPtrExportData`` reference, this method
        returns it directly. No new ``hipMemPoolPtrExportData`` is created in this case.

        Args:
            pyobj (object): Must be either ``None``, a simple, contiguous buffer according to the buffer protocol,
                            or of type ``hipMemPoolPtrExportData``, ``int``, or ``ctypes.c_void_p``

        Note:
            This routine does not perform a copy but returns the original ``pyobj``
            if ``pyobj`` is an instance of hipMemPoolPtrExportData!
        """
        cdef hipMemPoolPtrExportData wrapper = hipMemPoolPtrExportData.__new__(hipMemPoolPtrExportData)
        cdef dict cuda_array_interface = getattr(pyobj, "__cuda_array_interface__", None)

        if pyobj is None:
            wrapper._ptr = NULL
        elif isinstance(pyobj,hipMemPoolPtrExportData):
            return pyobj
        elif isinstance(pyobj,int):
            wrapper._ptr = <chip.hipMemPoolPtrExportData*>cpython.long.PyLong_AsVoidPtr(pyobj)
        elif isinstance(pyobj,ctypes.c_void_p):
            wrapper._ptr = <chip.hipMemPoolPtrExportData*>cpython.long.PyLong_AsVoidPtr(pyobj.value) if pyobj.value != None else NULL
        elif cuda_array_interface != None:
            if not "data" in cuda_array_interface:
                raise ValueError("input object has '__cuda_array_interface__' attribute but the dict has no 'data' key")
            ptr_as_int = cuda_array_interface["data"][0]
            wrapper._ptr = <chip.hipMemPoolPtrExportData*>cpython.long.PyLong_AsVoidPtr(ptr_as_int)
        elif cpython.buffer.PyObject_CheckBuffer(pyobj):
            err = cpython.buffer.PyObject_GetBuffer( 
                pyobj,
                &wrapper._py_buffer, 
                cpython.buffer.PyBUF_SIMPLE | cpython.buffer.PyBUF_ANY_CONTIGUOUS
            )
            if err == -1:
                raise RuntimeError("failed to create simple, contiguous Py_buffer from Python object")
            wrapper._py_buffer_acquired = True
            wrapper._ptr = <chip.hipMemPoolPtrExportData*>wrapper._py_buffer.buf
        else:
            raise TypeError(f"unsupported input type: '{str(type(pyobj))}'")
        return wrapper
    def __dealloc__(self):
        # Release the buffer handle
        if self._py_buffer_acquired is True:
            cpython.buffer.PyBuffer_Release(&self._py_buffer)
        # De-allocate if not null and flag is set
        if self._ptr is not NULL and self.ptr_owner is True:
            stdlib.free(self._ptr)
            self._ptr = NULL
    @staticmethod
    cdef __allocate(chip.hipMemPoolPtrExportData** ptr):
        ptr[0] = <chip.hipMemPoolPtrExportData*>stdlib.malloc(sizeof(chip.hipMemPoolPtrExportData))

        if ptr[0] is NULL:
            raise MemoryError
        # TODO init values, if present

    @staticmethod
    cdef hipMemPoolPtrExportData new():
        """Factory function to create hipMemPoolPtrExportData objects with
        newly allocated chip.hipMemPoolPtrExportData"""
        cdef chip.hipMemPoolPtrExportData* ptr
        hipMemPoolPtrExportData.__allocate(&ptr)
        return hipMemPoolPtrExportData.from_ptr(ptr, owner=True)
   
    def __init__(self,*args,**kwargs):
        hipMemPoolPtrExportData.__allocate(&self._ptr)
        self.ptr_owner = True
        attribs = self.PROPERTIES()
        used_attribs = set()
        if len(args) > len(attribs):
            raise ValueError("More positional arguments specified than this type has properties.")
        for i,v in enumerate(args):
            setattr(self,attribs[i],v)
            used_attribs.add(attribs[i])
        valid_names = ", ".join(["'"+p+"'" for p in attribs])
        for k,v in kwargs.items():
            if k in used_attribs:
                raise KeyError(f"argument '{k}' has already been specified as positional argument.")
            elif k not in attribs:
                raise KeyError(f"'{k}' is no valid property name. Valid names: {valid_names}")
            setattr(self,k,v)
    
    def __int__(self):
        """Returns the data's address as long integer."""
        return cpython.long.PyLong_FromVoidPtr(self._ptr)
    def __repr__(self):
        return f"<hipMemPoolPtrExportData object, self.ptr={int(self)}>"
    def as_c_void_p(self):
        """Returns the data's address as `ctypes.c_void_p`"""
        return ctypes.c_void_p(int(self))
    def get_reserved(self, i):
        """Get value of ``reserved`` of ``self._ptr[i]``.
        """
        return self._ptr[i].reserved
    # TODO add setters
    #def set_reserved(self, i, unsigned char[64] value):
    #    """Set value ``reserved`` of ``self._ptr[i]``.
    #    """
    #    self._ptr[i].reserved = value
    @property
    def reserved(self):
        return self.get_reserved(0)
    # TODO add setters
    #@reserved.setter
    #def reserved(self, unsigned char[64] value):
    #    self.set_reserved(0,value)

    @staticmethod
    def PROPERTIES():
        return ["reserved"]

    def __contains__(self,item):
        properties = self.PROPERTIES()
        return item in properties

    def __getitem__(self,item):
        properties = self.PROPERTIES()
        if isinstance(item,int):
            if item < 0 or item >= len(properties):
                raise IndexError()
            return getattr(self,properties[item])
        raise ValueError("'item' type must be 'int'")


class _hipJitOption__Base(enum.IntEnum):
    """Empty enum base class that allows subclassing.
    """
    pass
class hipJitOption(_hipJitOption__Base):
    hipJitOptionMaxRegisters = chip.hipJitOptionMaxRegisters
    hipJitOptionThreadsPerBlock = chip.hipJitOptionThreadsPerBlock
    hipJitOptionWallTime = chip.hipJitOptionWallTime
    hipJitOptionInfoLogBuffer = chip.hipJitOptionInfoLogBuffer
    hipJitOptionInfoLogBufferSizeBytes = chip.hipJitOptionInfoLogBufferSizeBytes
    hipJitOptionErrorLogBuffer = chip.hipJitOptionErrorLogBuffer
    hipJitOptionErrorLogBufferSizeBytes = chip.hipJitOptionErrorLogBufferSizeBytes
    hipJitOptionOptimizationLevel = chip.hipJitOptionOptimizationLevel
    hipJitOptionTargetFromContext = chip.hipJitOptionTargetFromContext
    hipJitOptionTarget = chip.hipJitOptionTarget
    hipJitOptionFallbackStrategy = chip.hipJitOptionFallbackStrategy
    hipJitOptionGenerateDebugInfo = chip.hipJitOptionGenerateDebugInfo
    hipJitOptionLogVerbose = chip.hipJitOptionLogVerbose
    hipJitOptionGenerateLineInfo = chip.hipJitOptionGenerateLineInfo
    hipJitOptionCacheMode = chip.hipJitOptionCacheMode
    hipJitOptionSm3xOpt = chip.hipJitOptionSm3xOpt
    hipJitOptionFastCompile = chip.hipJitOptionFastCompile
    hipJitOptionNumOptions = chip.hipJitOptionNumOptions
    @staticmethod
    def ctypes_type():
        """The type of the enum constants as ctypes type."""
        return ctypes.c_uint 


class _hipFuncAttribute__Base(enum.IntEnum):
    """Empty enum base class that allows subclassing.
    """
    pass
class hipFuncAttribute(_hipFuncAttribute__Base):
    hipFuncAttributeMaxDynamicSharedMemorySize = chip.hipFuncAttributeMaxDynamicSharedMemorySize
    hipFuncAttributePreferredSharedMemoryCarveout = chip.hipFuncAttributePreferredSharedMemoryCarveout
    hipFuncAttributeMax = chip.hipFuncAttributeMax
    @staticmethod
    def ctypes_type():
        """The type of the enum constants as ctypes type."""
        return ctypes.c_uint 


class _hipFuncCache_t__Base(enum.IntEnum):
    """Empty enum base class that allows subclassing.
    """
    pass
class hipFuncCache_t(_hipFuncCache_t__Base):
    hipFuncCachePreferNone = chip.hipFuncCachePreferNone
    hipFuncCachePreferShared = chip.hipFuncCachePreferShared
    hipFuncCachePreferL1 = chip.hipFuncCachePreferL1
    hipFuncCachePreferEqual = chip.hipFuncCachePreferEqual
    @staticmethod
    def ctypes_type():
        """The type of the enum constants as ctypes type."""
        return ctypes.c_uint 


class _hipSharedMemConfig__Base(enum.IntEnum):
    """Empty enum base class that allows subclassing.
    """
    pass
class hipSharedMemConfig(_hipSharedMemConfig__Base):
    hipSharedMemBankSizeDefault = chip.hipSharedMemBankSizeDefault
    hipSharedMemBankSizeFourByte = chip.hipSharedMemBankSizeFourByte
    hipSharedMemBankSizeEightByte = chip.hipSharedMemBankSizeEightByte
    @staticmethod
    def ctypes_type():
        """The type of the enum constants as ctypes type."""
        return ctypes.c_uint 


cdef class dim3:
    # members declared in pxd file

    def __cinit__(self):
        self._ptr = NULL
        self.ptr_owner = False
        self._py_buffer_acquired = False

    @staticmethod
    cdef dim3 from_ptr(chip.dim3* ptr, bint owner=False):
        """Factory function to create ``dim3`` objects from
        given ``chip.dim3`` pointer.

        Setting ``owner`` flag to ``True`` causes
        the extension type to ``free`` the structure pointed to by ``ptr``
        when the wrapper object is deallocated.
        """
        # Fast call to __new__() that bypasses the __init__() constructor.
        cdef dim3 wrapper = dim3.__new__(dim3)
        wrapper._ptr = ptr
        wrapper.ptr_owner = owner
        return wrapper

    @staticmethod
    cdef dim3 from_pyobj(object pyobj):
        """Derives a dim3 from a Python object.

        Derives a dim3 from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``dim3`` reference, this method
        returns it directly. No new ``dim3`` is created in this case.

        Args:
            pyobj (object): Must be either ``None``, a simple, contiguous buffer according to the buffer protocol,
                            or of type ``dim3``, ``int``, or ``ctypes.c_void_p``

        Note:
            This routine does not perform a copy but returns the original ``pyobj``
            if ``pyobj`` is an instance of dim3!
        """
        cdef dim3 wrapper = dim3.__new__(dim3)
        cdef dict cuda_array_interface = getattr(pyobj, "__cuda_array_interface__", None)

        if pyobj is None:
            wrapper._ptr = NULL
        elif isinstance(pyobj,dim3):
            return pyobj
        elif isinstance(pyobj,int):
            wrapper._ptr = <chip.dim3*>cpython.long.PyLong_AsVoidPtr(pyobj)
        elif isinstance(pyobj,ctypes.c_void_p):
            wrapper._ptr = <chip.dim3*>cpython.long.PyLong_AsVoidPtr(pyobj.value) if pyobj.value != None else NULL
        elif cuda_array_interface != None:
            if not "data" in cuda_array_interface:
                raise ValueError("input object has '__cuda_array_interface__' attribute but the dict has no 'data' key")
            ptr_as_int = cuda_array_interface["data"][0]
            wrapper._ptr = <chip.dim3*>cpython.long.PyLong_AsVoidPtr(ptr_as_int)
        elif cpython.buffer.PyObject_CheckBuffer(pyobj):
            err = cpython.buffer.PyObject_GetBuffer( 
                pyobj,
                &wrapper._py_buffer, 
                cpython.buffer.PyBUF_SIMPLE | cpython.buffer.PyBUF_ANY_CONTIGUOUS
            )
            if err == -1:
                raise RuntimeError("failed to create simple, contiguous Py_buffer from Python object")
            wrapper._py_buffer_acquired = True
            wrapper._ptr = <chip.dim3*>wrapper._py_buffer.buf
        else:
            raise TypeError(f"unsupported input type: '{str(type(pyobj))}'")
        return wrapper
    def __dealloc__(self):
        # Release the buffer handle
        if self._py_buffer_acquired is True:
            cpython.buffer.PyBuffer_Release(&self._py_buffer)
        # De-allocate if not null and flag is set
        if self._ptr is not NULL and self.ptr_owner is True:
            stdlib.free(self._ptr)
            self._ptr = NULL
    @staticmethod
    cdef __allocate(chip.dim3** ptr):
        ptr[0] = <chip.dim3*>stdlib.malloc(sizeof(chip.dim3))

        if ptr[0] is NULL:
            raise MemoryError
        # TODO init values, if present

    @staticmethod
    cdef dim3 new():
        """Factory function to create dim3 objects with
        newly allocated chip.dim3"""
        cdef chip.dim3* ptr
        dim3.__allocate(&ptr)
        return dim3.from_ptr(ptr, owner=True)
   
    def __init__(self,*args,**kwargs):
        dim3.__allocate(&self._ptr)
        self.ptr_owner = True
        self.x = 1
        self.y = 1
        self.z = 1
        attribs = self.PROPERTIES()
        used_attribs = set()
        if len(args) > len(attribs):
            raise ValueError("More positional arguments specified than this type has properties.")
        for i,v in enumerate(args):
            setattr(self,attribs[i],v)
            used_attribs.add(attribs[i])
        valid_names = ", ".join(["'"+p+"'" for p in attribs])
        for k,v in kwargs.items():
            if k in used_attribs:
                raise KeyError(f"argument '{k}' has already been specified as positional argument.")
            elif k not in attribs:
                raise KeyError(f"'{k}' is no valid property name. Valid names: {valid_names}")
            setattr(self,k,v)
    
    def __int__(self):
        """Returns the data's address as long integer."""
        return cpython.long.PyLong_FromVoidPtr(self._ptr)
    def __repr__(self):
        return f"<dim3 object, self.ptr={int(self)}>"
    def as_c_void_p(self):
        """Returns the data's address as `ctypes.c_void_p`"""
        return ctypes.c_void_p(int(self))
    def get_x(self, i):
        """Get value ``x`` of ``self._ptr[i]``.
        """
        return self._ptr[i].x
    def set_x(self, i, unsigned int value):
        """Set value ``x`` of ``self._ptr[i]``.
        """
        self._ptr[i].x = value
    @property
    def x(self):
        return self.get_x(0)
    @x.setter
    def x(self, unsigned int value):
        self.set_x(0,value)

    def get_y(self, i):
        """Get value ``y`` of ``self._ptr[i]``.
        """
        return self._ptr[i].y
    def set_y(self, i, unsigned int value):
        """Set value ``y`` of ``self._ptr[i]``.
        """
        self._ptr[i].y = value
    @property
    def y(self):
        return self.get_y(0)
    @y.setter
    def y(self, unsigned int value):
        self.set_y(0,value)

    def get_z(self, i):
        """Get value ``z`` of ``self._ptr[i]``.
        """
        return self._ptr[i].z
    def set_z(self, i, unsigned int value):
        """Set value ``z`` of ``self._ptr[i]``.
        """
        self._ptr[i].z = value
    @property
    def z(self):
        return self.get_z(0)
    @z.setter
    def z(self, unsigned int value):
        self.set_z(0,value)

    @staticmethod
    def PROPERTIES():
        return ["x","y","z"]

    def __contains__(self,item):
        properties = self.PROPERTIES()
        return item in properties

    def __getitem__(self,item):
        properties = self.PROPERTIES()
        if isinstance(item,int):
            if item < 0 or item >= len(properties):
                raise IndexError()
            return getattr(self,properties[item])
        raise ValueError("'item' type must be 'int'")


cdef class hipLaunchParams_t:
    # members declared in pxd file

    def __cinit__(self):
        self._ptr = NULL
        self.ptr_owner = False
        self._py_buffer_acquired = False

    @staticmethod
    cdef hipLaunchParams_t from_ptr(chip.hipLaunchParams_t* ptr, bint owner=False):
        """Factory function to create ``hipLaunchParams_t`` objects from
        given ``chip.hipLaunchParams_t`` pointer.

        Setting ``owner`` flag to ``True`` causes
        the extension type to ``free`` the structure pointed to by ``ptr``
        when the wrapper object is deallocated.
        """
        # Fast call to __new__() that bypasses the __init__() constructor.
        cdef hipLaunchParams_t wrapper = hipLaunchParams_t.__new__(hipLaunchParams_t)
        wrapper._ptr = ptr
        wrapper.ptr_owner = owner
        return wrapper

    @staticmethod
    cdef hipLaunchParams_t from_pyobj(object pyobj):
        """Derives a hipLaunchParams_t from a Python object.

        Derives a hipLaunchParams_t from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``hipLaunchParams_t`` reference, this method
        returns it directly. No new ``hipLaunchParams_t`` is created in this case.

        Args:
            pyobj (object): Must be either ``None``, a simple, contiguous buffer according to the buffer protocol,
                            or of type ``hipLaunchParams_t``, ``int``, or ``ctypes.c_void_p``

        Note:
            This routine does not perform a copy but returns the original ``pyobj``
            if ``pyobj`` is an instance of hipLaunchParams_t!
        """
        cdef hipLaunchParams_t wrapper = hipLaunchParams_t.__new__(hipLaunchParams_t)
        cdef dict cuda_array_interface = getattr(pyobj, "__cuda_array_interface__", None)

        if pyobj is None:
            wrapper._ptr = NULL
        elif isinstance(pyobj,hipLaunchParams_t):
            return pyobj
        elif isinstance(pyobj,int):
            wrapper._ptr = <chip.hipLaunchParams_t*>cpython.long.PyLong_AsVoidPtr(pyobj)
        elif isinstance(pyobj,ctypes.c_void_p):
            wrapper._ptr = <chip.hipLaunchParams_t*>cpython.long.PyLong_AsVoidPtr(pyobj.value) if pyobj.value != None else NULL
        elif cuda_array_interface != None:
            if not "data" in cuda_array_interface:
                raise ValueError("input object has '__cuda_array_interface__' attribute but the dict has no 'data' key")
            ptr_as_int = cuda_array_interface["data"][0]
            wrapper._ptr = <chip.hipLaunchParams_t*>cpython.long.PyLong_AsVoidPtr(ptr_as_int)
        elif cpython.buffer.PyObject_CheckBuffer(pyobj):
            err = cpython.buffer.PyObject_GetBuffer( 
                pyobj,
                &wrapper._py_buffer, 
                cpython.buffer.PyBUF_SIMPLE | cpython.buffer.PyBUF_ANY_CONTIGUOUS
            )
            if err == -1:
                raise RuntimeError("failed to create simple, contiguous Py_buffer from Python object")
            wrapper._py_buffer_acquired = True
            wrapper._ptr = <chip.hipLaunchParams_t*>wrapper._py_buffer.buf
        else:
            raise TypeError(f"unsupported input type: '{str(type(pyobj))}'")
        return wrapper
    def __dealloc__(self):
        # Release the buffer handle
        if self._py_buffer_acquired is True:
            cpython.buffer.PyBuffer_Release(&self._py_buffer)
        # De-allocate if not null and flag is set
        if self._ptr is not NULL and self.ptr_owner is True:
            stdlib.free(self._ptr)
            self._ptr = NULL
    @staticmethod
    cdef __allocate(chip.hipLaunchParams_t** ptr):
        ptr[0] = <chip.hipLaunchParams_t*>stdlib.malloc(sizeof(chip.hipLaunchParams_t))

        if ptr[0] is NULL:
            raise MemoryError
        # TODO init values, if present

    @staticmethod
    cdef hipLaunchParams_t new():
        """Factory function to create hipLaunchParams_t objects with
        newly allocated chip.hipLaunchParams_t"""
        cdef chip.hipLaunchParams_t* ptr
        hipLaunchParams_t.__allocate(&ptr)
        return hipLaunchParams_t.from_ptr(ptr, owner=True)
   
    # False
    # False
    def __init__(self,**kwargs):
        hipLaunchParams_t.__allocate(&self._ptr)
        self.ptr_owner = True
        attribs = self.PROPERTIES()
        used_attribs = set()
        valid_names = ", ".join(["'"+p+"'" for p in attribs])
        for k,v in kwargs.items():
            if k in used_attribs:
                raise KeyError(f"argument '{k}' has already been specified as positional argument.")
            elif k not in attribs:
                raise KeyError(f"'{k}' is no valid property name. Valid names: {valid_names}")
            setattr(self,k,v)
    
    def __int__(self):
        """Returns the data's address as long integer."""
        return cpython.long.PyLong_FromVoidPtr(self._ptr)
    def __repr__(self):
        return f"<hipLaunchParams_t object, self.ptr={int(self)}>"
    def as_c_void_p(self):
        """Returns the data's address as `ctypes.c_void_p`"""
        return ctypes.c_void_p(int(self))
    def get_func(self, i):
        """Get value ``func`` of ``self._ptr[i]``.
        """
        return hip._util.types.DataHandle.from_ptr(self._ptr[i].func)
    def set_func(self, i, object value):
        """Set value ``func`` of ``self._ptr[i]``.

        Note:
            This can be dangerous if the pointer is from a python object
            that is later on garbage collected.
        """
        self._ptr[i].func = <void *>cpython.long.PyLong_AsVoidPtr(int(hip._util.types.DataHandle.from_pyobj(value)))
    @property
    def func(self):
        """
        Note:
            Setting this func can be dangerous if the underlying pointer is from a python object that
            is later on garbage collected.
        """
        return self.get_func(0)
    @func.setter
    def func(self, object value):
        self.set_func(0,value)

    def get_gridDim(self, i):
        """Get value of ``gridDim`` of ``self._ptr[i]``.
        """
        return dim3.from_ptr(&self._ptr[i].gridDim)
    @property
    def gridDim(self):
        return self.get_gridDim(0)

    def get_blockDim(self, i):
        """Get value of ``blockDim`` of ``self._ptr[i]``.
        """
        return dim3.from_ptr(&self._ptr[i].blockDim)
    @property
    def blockDim(self):
        return self.get_blockDim(0)

    def get_args(self, i):
        """Get value ``args`` of ``self._ptr[i]``.
        """
        return hip._util.types.DataHandle.from_ptr(self._ptr[i].args)
    def set_args(self, i, object value):
        """Set value ``args`` of ``self._ptr[i]``.

        Note:
            This can be dangerous if the pointer is from a python object
            that is later on garbage collected.
        """
        self._ptr[i].args = <void **>cpython.long.PyLong_AsVoidPtr(int(hip._util.types.DataHandle.from_pyobj(value)))
    @property
    def args(self):
        """
        Note:
            Setting this args can be dangerous if the underlying pointer is from a python object that
            is later on garbage collected.
        """
        return self.get_args(0)
    @args.setter
    def args(self, object value):
        self.set_args(0,value)

    def get_sharedMem(self, i):
        """Get value ``sharedMem`` of ``self._ptr[i]``.
        """
        return self._ptr[i].sharedMem
    def set_sharedMem(self, i, unsigned long value):
        """Set value ``sharedMem`` of ``self._ptr[i]``.
        """
        self._ptr[i].sharedMem = value
    @property
    def sharedMem(self):
        return self.get_sharedMem(0)
    @sharedMem.setter
    def sharedMem(self, unsigned long value):
        self.set_sharedMem(0,value)

    @staticmethod
    def PROPERTIES():
        return ["func","gridDim","blockDim","args","sharedMem"]

    def __contains__(self,item):
        properties = self.PROPERTIES()
        return item in properties

    def __getitem__(self,item):
        properties = self.PROPERTIES()
        if isinstance(item,int):
            if item < 0 or item >= len(properties):
                raise IndexError()
            return getattr(self,properties[item])
        raise ValueError("'item' type must be 'int'")


hipLaunchParams = hipLaunchParams_t

class _hipExternalMemoryHandleType_enum__Base(enum.IntEnum):
    """Empty enum base class that allows subclassing.
    """
    pass
class hipExternalMemoryHandleType_enum(_hipExternalMemoryHandleType_enum__Base):
    hipExternalMemoryHandleTypeOpaqueFd = chip.hipExternalMemoryHandleTypeOpaqueFd
    hipExternalMemoryHandleTypeOpaqueWin32 = chip.hipExternalMemoryHandleTypeOpaqueWin32
    hipExternalMemoryHandleTypeOpaqueWin32Kmt = chip.hipExternalMemoryHandleTypeOpaqueWin32Kmt
    hipExternalMemoryHandleTypeD3D12Heap = chip.hipExternalMemoryHandleTypeD3D12Heap
    hipExternalMemoryHandleTypeD3D12Resource = chip.hipExternalMemoryHandleTypeD3D12Resource
    hipExternalMemoryHandleTypeD3D11Resource = chip.hipExternalMemoryHandleTypeD3D11Resource
    hipExternalMemoryHandleTypeD3D11ResourceKmt = chip.hipExternalMemoryHandleTypeD3D11ResourceKmt
    @staticmethod
    def ctypes_type():
        """The type of the enum constants as ctypes type."""
        return ctypes.c_uint 


hipExternalMemoryHandleType = hipExternalMemoryHandleType_enum

cdef class hipExternalMemoryHandleDesc_st_union_0_struct_0:
    # members declared in pxd file

    def __cinit__(self):
        self._ptr = NULL
        self.ptr_owner = False
        self._py_buffer_acquired = False

    @staticmethod
    cdef hipExternalMemoryHandleDesc_st_union_0_struct_0 from_ptr(chip.hipExternalMemoryHandleDesc_st_union_0_struct_0* ptr, bint owner=False):
        """Factory function to create ``hipExternalMemoryHandleDesc_st_union_0_struct_0`` objects from
        given ``chip.hipExternalMemoryHandleDesc_st_union_0_struct_0`` pointer.

        Setting ``owner`` flag to ``True`` causes
        the extension type to ``free`` the structure pointed to by ``ptr``
        when the wrapper object is deallocated.
        """
        # Fast call to __new__() that bypasses the __init__() constructor.
        cdef hipExternalMemoryHandleDesc_st_union_0_struct_0 wrapper = hipExternalMemoryHandleDesc_st_union_0_struct_0.__new__(hipExternalMemoryHandleDesc_st_union_0_struct_0)
        wrapper._ptr = ptr
        wrapper.ptr_owner = owner
        return wrapper

    @staticmethod
    cdef hipExternalMemoryHandleDesc_st_union_0_struct_0 from_pyobj(object pyobj):
        """Derives a hipExternalMemoryHandleDesc_st_union_0_struct_0 from a Python object.

        Derives a hipExternalMemoryHandleDesc_st_union_0_struct_0 from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``hipExternalMemoryHandleDesc_st_union_0_struct_0`` reference, this method
        returns it directly. No new ``hipExternalMemoryHandleDesc_st_union_0_struct_0`` is created in this case.

        Args:
            pyobj (object): Must be either ``None``, a simple, contiguous buffer according to the buffer protocol,
                            or of type ``hipExternalMemoryHandleDesc_st_union_0_struct_0``, ``int``, or ``ctypes.c_void_p``

        Note:
            This routine does not perform a copy but returns the original ``pyobj``
            if ``pyobj`` is an instance of hipExternalMemoryHandleDesc_st_union_0_struct_0!
        """
        cdef hipExternalMemoryHandleDesc_st_union_0_struct_0 wrapper = hipExternalMemoryHandleDesc_st_union_0_struct_0.__new__(hipExternalMemoryHandleDesc_st_union_0_struct_0)
        cdef dict cuda_array_interface = getattr(pyobj, "__cuda_array_interface__", None)

        if pyobj is None:
            wrapper._ptr = NULL
        elif isinstance(pyobj,hipExternalMemoryHandleDesc_st_union_0_struct_0):
            return pyobj
        elif isinstance(pyobj,int):
            wrapper._ptr = <chip.hipExternalMemoryHandleDesc_st_union_0_struct_0*>cpython.long.PyLong_AsVoidPtr(pyobj)
        elif isinstance(pyobj,ctypes.c_void_p):
            wrapper._ptr = <chip.hipExternalMemoryHandleDesc_st_union_0_struct_0*>cpython.long.PyLong_AsVoidPtr(pyobj.value) if pyobj.value != None else NULL
        elif cuda_array_interface != None:
            if not "data" in cuda_array_interface:
                raise ValueError("input object has '__cuda_array_interface__' attribute but the dict has no 'data' key")
            ptr_as_int = cuda_array_interface["data"][0]
            wrapper._ptr = <chip.hipExternalMemoryHandleDesc_st_union_0_struct_0*>cpython.long.PyLong_AsVoidPtr(ptr_as_int)
        elif cpython.buffer.PyObject_CheckBuffer(pyobj):
            err = cpython.buffer.PyObject_GetBuffer( 
                pyobj,
                &wrapper._py_buffer, 
                cpython.buffer.PyBUF_SIMPLE | cpython.buffer.PyBUF_ANY_CONTIGUOUS
            )
            if err == -1:
                raise RuntimeError("failed to create simple, contiguous Py_buffer from Python object")
            wrapper._py_buffer_acquired = True
            wrapper._ptr = <chip.hipExternalMemoryHandleDesc_st_union_0_struct_0*>wrapper._py_buffer.buf
        else:
            raise TypeError(f"unsupported input type: '{str(type(pyobj))}'")
        return wrapper
    def __dealloc__(self):
        # Release the buffer handle
        if self._py_buffer_acquired is True:
            cpython.buffer.PyBuffer_Release(&self._py_buffer)
        # De-allocate if not null and flag is set
        if self._ptr is not NULL and self.ptr_owner is True:
            stdlib.free(self._ptr)
            self._ptr = NULL
    @staticmethod
    cdef __allocate(chip.hipExternalMemoryHandleDesc_st_union_0_struct_0** ptr):
        ptr[0] = <chip.hipExternalMemoryHandleDesc_st_union_0_struct_0*>stdlib.malloc(sizeof(chip.hipExternalMemoryHandleDesc_st_union_0_struct_0))

        if ptr[0] is NULL:
            raise MemoryError
        # TODO init values, if present

    @staticmethod
    cdef hipExternalMemoryHandleDesc_st_union_0_struct_0 new():
        """Factory function to create hipExternalMemoryHandleDesc_st_union_0_struct_0 objects with
        newly allocated chip.hipExternalMemoryHandleDesc_st_union_0_struct_0"""
        cdef chip.hipExternalMemoryHandleDesc_st_union_0_struct_0* ptr
        hipExternalMemoryHandleDesc_st_union_0_struct_0.__allocate(&ptr)
        return hipExternalMemoryHandleDesc_st_union_0_struct_0.from_ptr(ptr, owner=True)
   
    def __init__(self,*args,**kwargs):
        hipExternalMemoryHandleDesc_st_union_0_struct_0.__allocate(&self._ptr)
        self.ptr_owner = True
        attribs = self.PROPERTIES()
        used_attribs = set()
        if len(args) > len(attribs):
            raise ValueError("More positional arguments specified than this type has properties.")
        for i,v in enumerate(args):
            setattr(self,attribs[i],v)
            used_attribs.add(attribs[i])
        valid_names = ", ".join(["'"+p+"'" for p in attribs])
        for k,v in kwargs.items():
            if k in used_attribs:
                raise KeyError(f"argument '{k}' has already been specified as positional argument.")
            elif k not in attribs:
                raise KeyError(f"'{k}' is no valid property name. Valid names: {valid_names}")
            setattr(self,k,v)
    
    def __int__(self):
        """Returns the data's address as long integer."""
        return cpython.long.PyLong_FromVoidPtr(self._ptr)
    def __repr__(self):
        return f"<hipExternalMemoryHandleDesc_st_union_0_struct_0 object, self.ptr={int(self)}>"
    def as_c_void_p(self):
        """Returns the data's address as `ctypes.c_void_p`"""
        return ctypes.c_void_p(int(self))
    def get_handle(self, i):
        """Get value ``handle`` of ``self._ptr[i]``.
        """
        return hip._util.types.DataHandle.from_ptr(self._ptr[i].handle)
    def set_handle(self, i, object value):
        """Set value ``handle`` of ``self._ptr[i]``.

        Note:
            This can be dangerous if the pointer is from a python object
            that is later on garbage collected.
        """
        self._ptr[i].handle = <void *>cpython.long.PyLong_AsVoidPtr(int(hip._util.types.DataHandle.from_pyobj(value)))
    @property
    def handle(self):
        """
        Note:
            Setting this handle can be dangerous if the underlying pointer is from a python object that
            is later on garbage collected.
        """
        return self.get_handle(0)
    @handle.setter
    def handle(self, object value):
        self.set_handle(0,value)

    def get_name(self, i):
        """Get value ``name`` of ``self._ptr[i]``.
        """
        return hip._util.types.DataHandle.from_ptr(self._ptr[i].name)
    def set_name(self, i, object value):
        """Set value ``name`` of ``self._ptr[i]``.

        Note:
            This can be dangerous if the pointer is from a python object
            that is later on garbage collected.
        """
        self._ptr[i].name = <const void *>cpython.long.PyLong_AsVoidPtr(int(hip._util.types.DataHandle.from_pyobj(value)))
    @property
    def name(self):
        """
        Note:
            Setting this name can be dangerous if the underlying pointer is from a python object that
            is later on garbage collected.
        """
        return self.get_name(0)
    @name.setter
    def name(self, object value):
        self.set_name(0,value)

    @staticmethod
    def PROPERTIES():
        return ["handle","name"]

    def __contains__(self,item):
        properties = self.PROPERTIES()
        return item in properties

    def __getitem__(self,item):
        properties = self.PROPERTIES()
        if isinstance(item,int):
            if item < 0 or item >= len(properties):
                raise IndexError()
            return getattr(self,properties[item])
        raise ValueError("'item' type must be 'int'")


cdef class hipExternalMemoryHandleDesc_st_union_0:
    # members declared in pxd file

    def __cinit__(self):
        self._ptr = NULL
        self.ptr_owner = False
        self._py_buffer_acquired = False

    @staticmethod
    cdef hipExternalMemoryHandleDesc_st_union_0 from_ptr(chip.hipExternalMemoryHandleDesc_st_union_0* ptr, bint owner=False):
        """Factory function to create ``hipExternalMemoryHandleDesc_st_union_0`` objects from
        given ``chip.hipExternalMemoryHandleDesc_st_union_0`` pointer.

        Setting ``owner`` flag to ``True`` causes
        the extension type to ``free`` the structure pointed to by ``ptr``
        when the wrapper object is deallocated.
        """
        # Fast call to __new__() that bypasses the __init__() constructor.
        cdef hipExternalMemoryHandleDesc_st_union_0 wrapper = hipExternalMemoryHandleDesc_st_union_0.__new__(hipExternalMemoryHandleDesc_st_union_0)
        wrapper._ptr = ptr
        wrapper.ptr_owner = owner
        return wrapper

    @staticmethod
    cdef hipExternalMemoryHandleDesc_st_union_0 from_pyobj(object pyobj):
        """Derives a hipExternalMemoryHandleDesc_st_union_0 from a Python object.

        Derives a hipExternalMemoryHandleDesc_st_union_0 from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``hipExternalMemoryHandleDesc_st_union_0`` reference, this method
        returns it directly. No new ``hipExternalMemoryHandleDesc_st_union_0`` is created in this case.

        Args:
            pyobj (object): Must be either ``None``, a simple, contiguous buffer according to the buffer protocol,
                            or of type ``hipExternalMemoryHandleDesc_st_union_0``, ``int``, or ``ctypes.c_void_p``

        Note:
            This routine does not perform a copy but returns the original ``pyobj``
            if ``pyobj`` is an instance of hipExternalMemoryHandleDesc_st_union_0!
        """
        cdef hipExternalMemoryHandleDesc_st_union_0 wrapper = hipExternalMemoryHandleDesc_st_union_0.__new__(hipExternalMemoryHandleDesc_st_union_0)
        cdef dict cuda_array_interface = getattr(pyobj, "__cuda_array_interface__", None)

        if pyobj is None:
            wrapper._ptr = NULL
        elif isinstance(pyobj,hipExternalMemoryHandleDesc_st_union_0):
            return pyobj
        elif isinstance(pyobj,int):
            wrapper._ptr = <chip.hipExternalMemoryHandleDesc_st_union_0*>cpython.long.PyLong_AsVoidPtr(pyobj)
        elif isinstance(pyobj,ctypes.c_void_p):
            wrapper._ptr = <chip.hipExternalMemoryHandleDesc_st_union_0*>cpython.long.PyLong_AsVoidPtr(pyobj.value) if pyobj.value != None else NULL
        elif cuda_array_interface != None:
            if not "data" in cuda_array_interface:
                raise ValueError("input object has '__cuda_array_interface__' attribute but the dict has no 'data' key")
            ptr_as_int = cuda_array_interface["data"][0]
            wrapper._ptr = <chip.hipExternalMemoryHandleDesc_st_union_0*>cpython.long.PyLong_AsVoidPtr(ptr_as_int)
        elif cpython.buffer.PyObject_CheckBuffer(pyobj):
            err = cpython.buffer.PyObject_GetBuffer( 
                pyobj,
                &wrapper._py_buffer, 
                cpython.buffer.PyBUF_SIMPLE | cpython.buffer.PyBUF_ANY_CONTIGUOUS
            )
            if err == -1:
                raise RuntimeError("failed to create simple, contiguous Py_buffer from Python object")
            wrapper._py_buffer_acquired = True
            wrapper._ptr = <chip.hipExternalMemoryHandleDesc_st_union_0*>wrapper._py_buffer.buf
        else:
            raise TypeError(f"unsupported input type: '{str(type(pyobj))}'")
        return wrapper
    def __dealloc__(self):
        # Release the buffer handle
        if self._py_buffer_acquired is True:
            cpython.buffer.PyBuffer_Release(&self._py_buffer)
        # De-allocate if not null and flag is set
        if self._ptr is not NULL and self.ptr_owner is True:
            stdlib.free(self._ptr)
            self._ptr = NULL
    @staticmethod
    cdef __allocate(chip.hipExternalMemoryHandleDesc_st_union_0** ptr):
        ptr[0] = <chip.hipExternalMemoryHandleDesc_st_union_0*>stdlib.malloc(sizeof(chip.hipExternalMemoryHandleDesc_st_union_0))

        if ptr[0] is NULL:
            raise MemoryError
        # TODO init values, if present

    @staticmethod
    cdef hipExternalMemoryHandleDesc_st_union_0 new():
        """Factory function to create hipExternalMemoryHandleDesc_st_union_0 objects with
        newly allocated chip.hipExternalMemoryHandleDesc_st_union_0"""
        cdef chip.hipExternalMemoryHandleDesc_st_union_0* ptr
        hipExternalMemoryHandleDesc_st_union_0.__allocate(&ptr)
        return hipExternalMemoryHandleDesc_st_union_0.from_ptr(ptr, owner=True)
   
    # True
    # True
    def __init__(self,**kwargs):
        hipExternalMemoryHandleDesc_st_union_0.__allocate(&self._ptr)
        self.ptr_owner = True
        attribs = self.PROPERTIES()
        used_attribs = set()
        if len(kwargs) > 1:
            raise ValueError("Not more than one attribute might specified for Python types derived from C union types.")
        valid_names = ", ".join(["'"+p+"'" for p in attribs])
        for k,v in kwargs.items():
            if k in used_attribs:
                raise KeyError(f"argument '{k}' has already been specified as positional argument.")
            elif k not in attribs:
                raise KeyError(f"'{k}' is no valid property name. Valid names: {valid_names}")
            setattr(self,k,v)
    
    def __int__(self):
        """Returns the data's address as long integer."""
        return cpython.long.PyLong_FromVoidPtr(self._ptr)
    def __repr__(self):
        return f"<hipExternalMemoryHandleDesc_st_union_0 object, self.ptr={int(self)}>"
    def as_c_void_p(self):
        """Returns the data's address as `ctypes.c_void_p`"""
        return ctypes.c_void_p(int(self))
    def get_fd(self, i):
        """Get value ``fd`` of ``self._ptr[i]``.
        """
        return self._ptr[i].fd
    def set_fd(self, i, int value):
        """Set value ``fd`` of ``self._ptr[i]``.
        """
        self._ptr[i].fd = value
    @property
    def fd(self):
        return self.get_fd(0)
    @fd.setter
    def fd(self, int value):
        self.set_fd(0,value)

    def get_win32(self, i):
        """Get value of ``win32`` of ``self._ptr[i]``.
        """
        return hipExternalMemoryHandleDesc_st_union_0_struct_0.from_ptr(&self._ptr[i].win32)
    @property
    def win32(self):
        return self.get_win32(0)

    @staticmethod
    def PROPERTIES():
        return ["fd","win32"]


cdef class hipExternalMemoryHandleDesc_st:
    # members declared in pxd file

    def __cinit__(self):
        self._ptr = NULL
        self.ptr_owner = False
        self._py_buffer_acquired = False

    @staticmethod
    cdef hipExternalMemoryHandleDesc_st from_ptr(chip.hipExternalMemoryHandleDesc_st* ptr, bint owner=False):
        """Factory function to create ``hipExternalMemoryHandleDesc_st`` objects from
        given ``chip.hipExternalMemoryHandleDesc_st`` pointer.

        Setting ``owner`` flag to ``True`` causes
        the extension type to ``free`` the structure pointed to by ``ptr``
        when the wrapper object is deallocated.
        """
        # Fast call to __new__() that bypasses the __init__() constructor.
        cdef hipExternalMemoryHandleDesc_st wrapper = hipExternalMemoryHandleDesc_st.__new__(hipExternalMemoryHandleDesc_st)
        wrapper._ptr = ptr
        wrapper.ptr_owner = owner
        return wrapper

    @staticmethod
    cdef hipExternalMemoryHandleDesc_st from_pyobj(object pyobj):
        """Derives a hipExternalMemoryHandleDesc_st from a Python object.

        Derives a hipExternalMemoryHandleDesc_st from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``hipExternalMemoryHandleDesc_st`` reference, this method
        returns it directly. No new ``hipExternalMemoryHandleDesc_st`` is created in this case.

        Args:
            pyobj (object): Must be either ``None``, a simple, contiguous buffer according to the buffer protocol,
                            or of type ``hipExternalMemoryHandleDesc_st``, ``int``, or ``ctypes.c_void_p``

        Note:
            This routine does not perform a copy but returns the original ``pyobj``
            if ``pyobj`` is an instance of hipExternalMemoryHandleDesc_st!
        """
        cdef hipExternalMemoryHandleDesc_st wrapper = hipExternalMemoryHandleDesc_st.__new__(hipExternalMemoryHandleDesc_st)
        cdef dict cuda_array_interface = getattr(pyobj, "__cuda_array_interface__", None)

        if pyobj is None:
            wrapper._ptr = NULL
        elif isinstance(pyobj,hipExternalMemoryHandleDesc_st):
            return pyobj
        elif isinstance(pyobj,int):
            wrapper._ptr = <chip.hipExternalMemoryHandleDesc_st*>cpython.long.PyLong_AsVoidPtr(pyobj)
        elif isinstance(pyobj,ctypes.c_void_p):
            wrapper._ptr = <chip.hipExternalMemoryHandleDesc_st*>cpython.long.PyLong_AsVoidPtr(pyobj.value) if pyobj.value != None else NULL
        elif cuda_array_interface != None:
            if not "data" in cuda_array_interface:
                raise ValueError("input object has '__cuda_array_interface__' attribute but the dict has no 'data' key")
            ptr_as_int = cuda_array_interface["data"][0]
            wrapper._ptr = <chip.hipExternalMemoryHandleDesc_st*>cpython.long.PyLong_AsVoidPtr(ptr_as_int)
        elif cpython.buffer.PyObject_CheckBuffer(pyobj):
            err = cpython.buffer.PyObject_GetBuffer( 
                pyobj,
                &wrapper._py_buffer, 
                cpython.buffer.PyBUF_SIMPLE | cpython.buffer.PyBUF_ANY_CONTIGUOUS
            )
            if err == -1:
                raise RuntimeError("failed to create simple, contiguous Py_buffer from Python object")
            wrapper._py_buffer_acquired = True
            wrapper._ptr = <chip.hipExternalMemoryHandleDesc_st*>wrapper._py_buffer.buf
        else:
            raise TypeError(f"unsupported input type: '{str(type(pyobj))}'")
        return wrapper
    def __dealloc__(self):
        # Release the buffer handle
        if self._py_buffer_acquired is True:
            cpython.buffer.PyBuffer_Release(&self._py_buffer)
        # De-allocate if not null and flag is set
        if self._ptr is not NULL and self.ptr_owner is True:
            stdlib.free(self._ptr)
            self._ptr = NULL
    @staticmethod
    cdef __allocate(chip.hipExternalMemoryHandleDesc_st** ptr):
        ptr[0] = <chip.hipExternalMemoryHandleDesc_st*>stdlib.malloc(sizeof(chip.hipExternalMemoryHandleDesc_st))

        if ptr[0] is NULL:
            raise MemoryError
        # TODO init values, if present

    @staticmethod
    cdef hipExternalMemoryHandleDesc_st new():
        """Factory function to create hipExternalMemoryHandleDesc_st objects with
        newly allocated chip.hipExternalMemoryHandleDesc_st"""
        cdef chip.hipExternalMemoryHandleDesc_st* ptr
        hipExternalMemoryHandleDesc_st.__allocate(&ptr)
        return hipExternalMemoryHandleDesc_st.from_ptr(ptr, owner=True)
   
    def __init__(self,*args,**kwargs):
        hipExternalMemoryHandleDesc_st.__allocate(&self._ptr)
        self.ptr_owner = True
        attribs = self.PROPERTIES()
        used_attribs = set()
        if len(args) > len(attribs):
            raise ValueError("More positional arguments specified than this type has properties.")
        for i,v in enumerate(args):
            setattr(self,attribs[i],v)
            used_attribs.add(attribs[i])
        valid_names = ", ".join(["'"+p+"'" for p in attribs])
        for k,v in kwargs.items():
            if k in used_attribs:
                raise KeyError(f"argument '{k}' has already been specified as positional argument.")
            elif k not in attribs:
                raise KeyError(f"'{k}' is no valid property name. Valid names: {valid_names}")
            setattr(self,k,v)
    
    def __int__(self):
        """Returns the data's address as long integer."""
        return cpython.long.PyLong_FromVoidPtr(self._ptr)
    def __repr__(self):
        return f"<hipExternalMemoryHandleDesc_st object, self.ptr={int(self)}>"
    def as_c_void_p(self):
        """Returns the data's address as `ctypes.c_void_p`"""
        return ctypes.c_void_p(int(self))
    def get_type(self, i):
        """Get value of ``type`` of ``self._ptr[i]``.
        """
        return hipExternalMemoryHandleType_enum(self._ptr[i].type)
    def set_type(self, i, value):
        """Set value ``type`` of ``self._ptr[i]``.
        """
        if not isinstance(value, hipExternalMemoryHandleType_enum):
            raise TypeError("'value' must be of type 'hipExternalMemoryHandleType_enum'")
        self._ptr[i].type = value.value
    @property
    def type(self):
        return self.get_type(0)
    @type.setter
    def type(self, value):
        self.set_type(0,value)

    def get_handle(self, i):
        """Get value of ``handle`` of ``self._ptr[i]``.
        """
        return hipExternalMemoryHandleDesc_st_union_0.from_ptr(&self._ptr[i].handle)
    @property
    def handle(self):
        return self.get_handle(0)

    def get_size(self, i):
        """Get value ``size`` of ``self._ptr[i]``.
        """
        return self._ptr[i].size
    def set_size(self, i, unsigned long long value):
        """Set value ``size`` of ``self._ptr[i]``.
        """
        self._ptr[i].size = value
    @property
    def size(self):
        return self.get_size(0)
    @size.setter
    def size(self, unsigned long long value):
        self.set_size(0,value)

    def get_flags(self, i):
        """Get value ``flags`` of ``self._ptr[i]``.
        """
        return self._ptr[i].flags
    def set_flags(self, i, unsigned int value):
        """Set value ``flags`` of ``self._ptr[i]``.
        """
        self._ptr[i].flags = value
    @property
    def flags(self):
        return self.get_flags(0)
    @flags.setter
    def flags(self, unsigned int value):
        self.set_flags(0,value)

    @staticmethod
    def PROPERTIES():
        return ["type","handle","size","flags"]

    def __contains__(self,item):
        properties = self.PROPERTIES()
        return item in properties

    def __getitem__(self,item):
        properties = self.PROPERTIES()
        if isinstance(item,int):
            if item < 0 or item >= len(properties):
                raise IndexError()
            return getattr(self,properties[item])
        raise ValueError("'item' type must be 'int'")


hipExternalMemoryHandleDesc = hipExternalMemoryHandleDesc_st

cdef class hipExternalMemoryBufferDesc_st:
    # members declared in pxd file

    def __cinit__(self):
        self._ptr = NULL
        self.ptr_owner = False
        self._py_buffer_acquired = False

    @staticmethod
    cdef hipExternalMemoryBufferDesc_st from_ptr(chip.hipExternalMemoryBufferDesc_st* ptr, bint owner=False):
        """Factory function to create ``hipExternalMemoryBufferDesc_st`` objects from
        given ``chip.hipExternalMemoryBufferDesc_st`` pointer.

        Setting ``owner`` flag to ``True`` causes
        the extension type to ``free`` the structure pointed to by ``ptr``
        when the wrapper object is deallocated.
        """
        # Fast call to __new__() that bypasses the __init__() constructor.
        cdef hipExternalMemoryBufferDesc_st wrapper = hipExternalMemoryBufferDesc_st.__new__(hipExternalMemoryBufferDesc_st)
        wrapper._ptr = ptr
        wrapper.ptr_owner = owner
        return wrapper

    @staticmethod
    cdef hipExternalMemoryBufferDesc_st from_pyobj(object pyobj):
        """Derives a hipExternalMemoryBufferDesc_st from a Python object.

        Derives a hipExternalMemoryBufferDesc_st from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``hipExternalMemoryBufferDesc_st`` reference, this method
        returns it directly. No new ``hipExternalMemoryBufferDesc_st`` is created in this case.

        Args:
            pyobj (object): Must be either ``None``, a simple, contiguous buffer according to the buffer protocol,
                            or of type ``hipExternalMemoryBufferDesc_st``, ``int``, or ``ctypes.c_void_p``

        Note:
            This routine does not perform a copy but returns the original ``pyobj``
            if ``pyobj`` is an instance of hipExternalMemoryBufferDesc_st!
        """
        cdef hipExternalMemoryBufferDesc_st wrapper = hipExternalMemoryBufferDesc_st.__new__(hipExternalMemoryBufferDesc_st)
        cdef dict cuda_array_interface = getattr(pyobj, "__cuda_array_interface__", None)

        if pyobj is None:
            wrapper._ptr = NULL
        elif isinstance(pyobj,hipExternalMemoryBufferDesc_st):
            return pyobj
        elif isinstance(pyobj,int):
            wrapper._ptr = <chip.hipExternalMemoryBufferDesc_st*>cpython.long.PyLong_AsVoidPtr(pyobj)
        elif isinstance(pyobj,ctypes.c_void_p):
            wrapper._ptr = <chip.hipExternalMemoryBufferDesc_st*>cpython.long.PyLong_AsVoidPtr(pyobj.value) if pyobj.value != None else NULL
        elif cuda_array_interface != None:
            if not "data" in cuda_array_interface:
                raise ValueError("input object has '__cuda_array_interface__' attribute but the dict has no 'data' key")
            ptr_as_int = cuda_array_interface["data"][0]
            wrapper._ptr = <chip.hipExternalMemoryBufferDesc_st*>cpython.long.PyLong_AsVoidPtr(ptr_as_int)
        elif cpython.buffer.PyObject_CheckBuffer(pyobj):
            err = cpython.buffer.PyObject_GetBuffer( 
                pyobj,
                &wrapper._py_buffer, 
                cpython.buffer.PyBUF_SIMPLE | cpython.buffer.PyBUF_ANY_CONTIGUOUS
            )
            if err == -1:
                raise RuntimeError("failed to create simple, contiguous Py_buffer from Python object")
            wrapper._py_buffer_acquired = True
            wrapper._ptr = <chip.hipExternalMemoryBufferDesc_st*>wrapper._py_buffer.buf
        else:
            raise TypeError(f"unsupported input type: '{str(type(pyobj))}'")
        return wrapper
    def __dealloc__(self):
        # Release the buffer handle
        if self._py_buffer_acquired is True:
            cpython.buffer.PyBuffer_Release(&self._py_buffer)
        # De-allocate if not null and flag is set
        if self._ptr is not NULL and self.ptr_owner is True:
            stdlib.free(self._ptr)
            self._ptr = NULL
    @staticmethod
    cdef __allocate(chip.hipExternalMemoryBufferDesc_st** ptr):
        ptr[0] = <chip.hipExternalMemoryBufferDesc_st*>stdlib.malloc(sizeof(chip.hipExternalMemoryBufferDesc_st))

        if ptr[0] is NULL:
            raise MemoryError
        # TODO init values, if present

    @staticmethod
    cdef hipExternalMemoryBufferDesc_st new():
        """Factory function to create hipExternalMemoryBufferDesc_st objects with
        newly allocated chip.hipExternalMemoryBufferDesc_st"""
        cdef chip.hipExternalMemoryBufferDesc_st* ptr
        hipExternalMemoryBufferDesc_st.__allocate(&ptr)
        return hipExternalMemoryBufferDesc_st.from_ptr(ptr, owner=True)
   
    def __init__(self,*args,**kwargs):
        hipExternalMemoryBufferDesc_st.__allocate(&self._ptr)
        self.ptr_owner = True
        attribs = self.PROPERTIES()
        used_attribs = set()
        if len(args) > len(attribs):
            raise ValueError("More positional arguments specified than this type has properties.")
        for i,v in enumerate(args):
            setattr(self,attribs[i],v)
            used_attribs.add(attribs[i])
        valid_names = ", ".join(["'"+p+"'" for p in attribs])
        for k,v in kwargs.items():
            if k in used_attribs:
                raise KeyError(f"argument '{k}' has already been specified as positional argument.")
            elif k not in attribs:
                raise KeyError(f"'{k}' is no valid property name. Valid names: {valid_names}")
            setattr(self,k,v)
    
    def __int__(self):
        """Returns the data's address as long integer."""
        return cpython.long.PyLong_FromVoidPtr(self._ptr)
    def __repr__(self):
        return f"<hipExternalMemoryBufferDesc_st object, self.ptr={int(self)}>"
    def as_c_void_p(self):
        """Returns the data's address as `ctypes.c_void_p`"""
        return ctypes.c_void_p(int(self))
    def get_offset(self, i):
        """Get value ``offset`` of ``self._ptr[i]``.
        """
        return self._ptr[i].offset
    def set_offset(self, i, unsigned long long value):
        """Set value ``offset`` of ``self._ptr[i]``.
        """
        self._ptr[i].offset = value
    @property
    def offset(self):
        return self.get_offset(0)
    @offset.setter
    def offset(self, unsigned long long value):
        self.set_offset(0,value)

    def get_size(self, i):
        """Get value ``size`` of ``self._ptr[i]``.
        """
        return self._ptr[i].size
    def set_size(self, i, unsigned long long value):
        """Set value ``size`` of ``self._ptr[i]``.
        """
        self._ptr[i].size = value
    @property
    def size(self):
        return self.get_size(0)
    @size.setter
    def size(self, unsigned long long value):
        self.set_size(0,value)

    def get_flags(self, i):
        """Get value ``flags`` of ``self._ptr[i]``.
        """
        return self._ptr[i].flags
    def set_flags(self, i, unsigned int value):
        """Set value ``flags`` of ``self._ptr[i]``.
        """
        self._ptr[i].flags = value
    @property
    def flags(self):
        return self.get_flags(0)
    @flags.setter
    def flags(self, unsigned int value):
        self.set_flags(0,value)

    @staticmethod
    def PROPERTIES():
        return ["offset","size","flags"]

    def __contains__(self,item):
        properties = self.PROPERTIES()
        return item in properties

    def __getitem__(self,item):
        properties = self.PROPERTIES()
        if isinstance(item,int):
            if item < 0 or item >= len(properties):
                raise IndexError()
            return getattr(self,properties[item])
        raise ValueError("'item' type must be 'int'")


hipExternalMemoryBufferDesc = hipExternalMemoryBufferDesc_st

class _hipExternalSemaphoreHandleType_enum__Base(enum.IntEnum):
    """Empty enum base class that allows subclassing.
    """
    pass
class hipExternalSemaphoreHandleType_enum(_hipExternalSemaphoreHandleType_enum__Base):
    hipExternalSemaphoreHandleTypeOpaqueFd = chip.hipExternalSemaphoreHandleTypeOpaqueFd
    hipExternalSemaphoreHandleTypeOpaqueWin32 = chip.hipExternalSemaphoreHandleTypeOpaqueWin32
    hipExternalSemaphoreHandleTypeOpaqueWin32Kmt = chip.hipExternalSemaphoreHandleTypeOpaqueWin32Kmt
    hipExternalSemaphoreHandleTypeD3D12Fence = chip.hipExternalSemaphoreHandleTypeD3D12Fence
    @staticmethod
    def ctypes_type():
        """The type of the enum constants as ctypes type."""
        return ctypes.c_uint 


hipExternalSemaphoreHandleType = hipExternalSemaphoreHandleType_enum

cdef class hipExternalSemaphoreHandleDesc_st_union_0_struct_0:
    # members declared in pxd file

    def __cinit__(self):
        self._ptr = NULL
        self.ptr_owner = False
        self._py_buffer_acquired = False

    @staticmethod
    cdef hipExternalSemaphoreHandleDesc_st_union_0_struct_0 from_ptr(chip.hipExternalSemaphoreHandleDesc_st_union_0_struct_0* ptr, bint owner=False):
        """Factory function to create ``hipExternalSemaphoreHandleDesc_st_union_0_struct_0`` objects from
        given ``chip.hipExternalSemaphoreHandleDesc_st_union_0_struct_0`` pointer.

        Setting ``owner`` flag to ``True`` causes
        the extension type to ``free`` the structure pointed to by ``ptr``
        when the wrapper object is deallocated.
        """
        # Fast call to __new__() that bypasses the __init__() constructor.
        cdef hipExternalSemaphoreHandleDesc_st_union_0_struct_0 wrapper = hipExternalSemaphoreHandleDesc_st_union_0_struct_0.__new__(hipExternalSemaphoreHandleDesc_st_union_0_struct_0)
        wrapper._ptr = ptr
        wrapper.ptr_owner = owner
        return wrapper

    @staticmethod
    cdef hipExternalSemaphoreHandleDesc_st_union_0_struct_0 from_pyobj(object pyobj):
        """Derives a hipExternalSemaphoreHandleDesc_st_union_0_struct_0 from a Python object.

        Derives a hipExternalSemaphoreHandleDesc_st_union_0_struct_0 from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``hipExternalSemaphoreHandleDesc_st_union_0_struct_0`` reference, this method
        returns it directly. No new ``hipExternalSemaphoreHandleDesc_st_union_0_struct_0`` is created in this case.

        Args:
            pyobj (object): Must be either ``None``, a simple, contiguous buffer according to the buffer protocol,
                            or of type ``hipExternalSemaphoreHandleDesc_st_union_0_struct_0``, ``int``, or ``ctypes.c_void_p``

        Note:
            This routine does not perform a copy but returns the original ``pyobj``
            if ``pyobj`` is an instance of hipExternalSemaphoreHandleDesc_st_union_0_struct_0!
        """
        cdef hipExternalSemaphoreHandleDesc_st_union_0_struct_0 wrapper = hipExternalSemaphoreHandleDesc_st_union_0_struct_0.__new__(hipExternalSemaphoreHandleDesc_st_union_0_struct_0)
        cdef dict cuda_array_interface = getattr(pyobj, "__cuda_array_interface__", None)

        if pyobj is None:
            wrapper._ptr = NULL
        elif isinstance(pyobj,hipExternalSemaphoreHandleDesc_st_union_0_struct_0):
            return pyobj
        elif isinstance(pyobj,int):
            wrapper._ptr = <chip.hipExternalSemaphoreHandleDesc_st_union_0_struct_0*>cpython.long.PyLong_AsVoidPtr(pyobj)
        elif isinstance(pyobj,ctypes.c_void_p):
            wrapper._ptr = <chip.hipExternalSemaphoreHandleDesc_st_union_0_struct_0*>cpython.long.PyLong_AsVoidPtr(pyobj.value) if pyobj.value != None else NULL
        elif cuda_array_interface != None:
            if not "data" in cuda_array_interface:
                raise ValueError("input object has '__cuda_array_interface__' attribute but the dict has no 'data' key")
            ptr_as_int = cuda_array_interface["data"][0]
            wrapper._ptr = <chip.hipExternalSemaphoreHandleDesc_st_union_0_struct_0*>cpython.long.PyLong_AsVoidPtr(ptr_as_int)
        elif cpython.buffer.PyObject_CheckBuffer(pyobj):
            err = cpython.buffer.PyObject_GetBuffer( 
                pyobj,
                &wrapper._py_buffer, 
                cpython.buffer.PyBUF_SIMPLE | cpython.buffer.PyBUF_ANY_CONTIGUOUS
            )
            if err == -1:
                raise RuntimeError("failed to create simple, contiguous Py_buffer from Python object")
            wrapper._py_buffer_acquired = True
            wrapper._ptr = <chip.hipExternalSemaphoreHandleDesc_st_union_0_struct_0*>wrapper._py_buffer.buf
        else:
            raise TypeError(f"unsupported input type: '{str(type(pyobj))}'")
        return wrapper
    def __dealloc__(self):
        # Release the buffer handle
        if self._py_buffer_acquired is True:
            cpython.buffer.PyBuffer_Release(&self._py_buffer)
        # De-allocate if not null and flag is set
        if self._ptr is not NULL and self.ptr_owner is True:
            stdlib.free(self._ptr)
            self._ptr = NULL
    @staticmethod
    cdef __allocate(chip.hipExternalSemaphoreHandleDesc_st_union_0_struct_0** ptr):
        ptr[0] = <chip.hipExternalSemaphoreHandleDesc_st_union_0_struct_0*>stdlib.malloc(sizeof(chip.hipExternalSemaphoreHandleDesc_st_union_0_struct_0))

        if ptr[0] is NULL:
            raise MemoryError
        # TODO init values, if present

    @staticmethod
    cdef hipExternalSemaphoreHandleDesc_st_union_0_struct_0 new():
        """Factory function to create hipExternalSemaphoreHandleDesc_st_union_0_struct_0 objects with
        newly allocated chip.hipExternalSemaphoreHandleDesc_st_union_0_struct_0"""
        cdef chip.hipExternalSemaphoreHandleDesc_st_union_0_struct_0* ptr
        hipExternalSemaphoreHandleDesc_st_union_0_struct_0.__allocate(&ptr)
        return hipExternalSemaphoreHandleDesc_st_union_0_struct_0.from_ptr(ptr, owner=True)
   
    def __init__(self,*args,**kwargs):
        hipExternalSemaphoreHandleDesc_st_union_0_struct_0.__allocate(&self._ptr)
        self.ptr_owner = True
        attribs = self.PROPERTIES()
        used_attribs = set()
        if len(args) > len(attribs):
            raise ValueError("More positional arguments specified than this type has properties.")
        for i,v in enumerate(args):
            setattr(self,attribs[i],v)
            used_attribs.add(attribs[i])
        valid_names = ", ".join(["'"+p+"'" for p in attribs])
        for k,v in kwargs.items():
            if k in used_attribs:
                raise KeyError(f"argument '{k}' has already been specified as positional argument.")
            elif k not in attribs:
                raise KeyError(f"'{k}' is no valid property name. Valid names: {valid_names}")
            setattr(self,k,v)
    
    def __int__(self):
        """Returns the data's address as long integer."""
        return cpython.long.PyLong_FromVoidPtr(self._ptr)
    def __repr__(self):
        return f"<hipExternalSemaphoreHandleDesc_st_union_0_struct_0 object, self.ptr={int(self)}>"
    def as_c_void_p(self):
        """Returns the data's address as `ctypes.c_void_p`"""
        return ctypes.c_void_p(int(self))
    def get_handle(self, i):
        """Get value ``handle`` of ``self._ptr[i]``.
        """
        return hip._util.types.DataHandle.from_ptr(self._ptr[i].handle)
    def set_handle(self, i, object value):
        """Set value ``handle`` of ``self._ptr[i]``.

        Note:
            This can be dangerous if the pointer is from a python object
            that is later on garbage collected.
        """
        self._ptr[i].handle = <void *>cpython.long.PyLong_AsVoidPtr(int(hip._util.types.DataHandle.from_pyobj(value)))
    @property
    def handle(self):
        """
        Note:
            Setting this handle can be dangerous if the underlying pointer is from a python object that
            is later on garbage collected.
        """
        return self.get_handle(0)
    @handle.setter
    def handle(self, object value):
        self.set_handle(0,value)

    def get_name(self, i):
        """Get value ``name`` of ``self._ptr[i]``.
        """
        return hip._util.types.DataHandle.from_ptr(self._ptr[i].name)
    def set_name(self, i, object value):
        """Set value ``name`` of ``self._ptr[i]``.

        Note:
            This can be dangerous if the pointer is from a python object
            that is later on garbage collected.
        """
        self._ptr[i].name = <const void *>cpython.long.PyLong_AsVoidPtr(int(hip._util.types.DataHandle.from_pyobj(value)))
    @property
    def name(self):
        """
        Note:
            Setting this name can be dangerous if the underlying pointer is from a python object that
            is later on garbage collected.
        """
        return self.get_name(0)
    @name.setter
    def name(self, object value):
        self.set_name(0,value)

    @staticmethod
    def PROPERTIES():
        return ["handle","name"]

    def __contains__(self,item):
        properties = self.PROPERTIES()
        return item in properties

    def __getitem__(self,item):
        properties = self.PROPERTIES()
        if isinstance(item,int):
            if item < 0 or item >= len(properties):
                raise IndexError()
            return getattr(self,properties[item])
        raise ValueError("'item' type must be 'int'")


cdef class hipExternalSemaphoreHandleDesc_st_union_0:
    # members declared in pxd file

    def __cinit__(self):
        self._ptr = NULL
        self.ptr_owner = False
        self._py_buffer_acquired = False

    @staticmethod
    cdef hipExternalSemaphoreHandleDesc_st_union_0 from_ptr(chip.hipExternalSemaphoreHandleDesc_st_union_0* ptr, bint owner=False):
        """Factory function to create ``hipExternalSemaphoreHandleDesc_st_union_0`` objects from
        given ``chip.hipExternalSemaphoreHandleDesc_st_union_0`` pointer.

        Setting ``owner`` flag to ``True`` causes
        the extension type to ``free`` the structure pointed to by ``ptr``
        when the wrapper object is deallocated.
        """
        # Fast call to __new__() that bypasses the __init__() constructor.
        cdef hipExternalSemaphoreHandleDesc_st_union_0 wrapper = hipExternalSemaphoreHandleDesc_st_union_0.__new__(hipExternalSemaphoreHandleDesc_st_union_0)
        wrapper._ptr = ptr
        wrapper.ptr_owner = owner
        return wrapper

    @staticmethod
    cdef hipExternalSemaphoreHandleDesc_st_union_0 from_pyobj(object pyobj):
        """Derives a hipExternalSemaphoreHandleDesc_st_union_0 from a Python object.

        Derives a hipExternalSemaphoreHandleDesc_st_union_0 from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``hipExternalSemaphoreHandleDesc_st_union_0`` reference, this method
        returns it directly. No new ``hipExternalSemaphoreHandleDesc_st_union_0`` is created in this case.

        Args:
            pyobj (object): Must be either ``None``, a simple, contiguous buffer according to the buffer protocol,
                            or of type ``hipExternalSemaphoreHandleDesc_st_union_0``, ``int``, or ``ctypes.c_void_p``

        Note:
            This routine does not perform a copy but returns the original ``pyobj``
            if ``pyobj`` is an instance of hipExternalSemaphoreHandleDesc_st_union_0!
        """
        cdef hipExternalSemaphoreHandleDesc_st_union_0 wrapper = hipExternalSemaphoreHandleDesc_st_union_0.__new__(hipExternalSemaphoreHandleDesc_st_union_0)
        cdef dict cuda_array_interface = getattr(pyobj, "__cuda_array_interface__", None)

        if pyobj is None:
            wrapper._ptr = NULL
        elif isinstance(pyobj,hipExternalSemaphoreHandleDesc_st_union_0):
            return pyobj
        elif isinstance(pyobj,int):
            wrapper._ptr = <chip.hipExternalSemaphoreHandleDesc_st_union_0*>cpython.long.PyLong_AsVoidPtr(pyobj)
        elif isinstance(pyobj,ctypes.c_void_p):
            wrapper._ptr = <chip.hipExternalSemaphoreHandleDesc_st_union_0*>cpython.long.PyLong_AsVoidPtr(pyobj.value) if pyobj.value != None else NULL
        elif cuda_array_interface != None:
            if not "data" in cuda_array_interface:
                raise ValueError("input object has '__cuda_array_interface__' attribute but the dict has no 'data' key")
            ptr_as_int = cuda_array_interface["data"][0]
            wrapper._ptr = <chip.hipExternalSemaphoreHandleDesc_st_union_0*>cpython.long.PyLong_AsVoidPtr(ptr_as_int)
        elif cpython.buffer.PyObject_CheckBuffer(pyobj):
            err = cpython.buffer.PyObject_GetBuffer( 
                pyobj,
                &wrapper._py_buffer, 
                cpython.buffer.PyBUF_SIMPLE | cpython.buffer.PyBUF_ANY_CONTIGUOUS
            )
            if err == -1:
                raise RuntimeError("failed to create simple, contiguous Py_buffer from Python object")
            wrapper._py_buffer_acquired = True
            wrapper._ptr = <chip.hipExternalSemaphoreHandleDesc_st_union_0*>wrapper._py_buffer.buf
        else:
            raise TypeError(f"unsupported input type: '{str(type(pyobj))}'")
        return wrapper
    def __dealloc__(self):
        # Release the buffer handle
        if self._py_buffer_acquired is True:
            cpython.buffer.PyBuffer_Release(&self._py_buffer)
        # De-allocate if not null and flag is set
        if self._ptr is not NULL and self.ptr_owner is True:
            stdlib.free(self._ptr)
            self._ptr = NULL
    @staticmethod
    cdef __allocate(chip.hipExternalSemaphoreHandleDesc_st_union_0** ptr):
        ptr[0] = <chip.hipExternalSemaphoreHandleDesc_st_union_0*>stdlib.malloc(sizeof(chip.hipExternalSemaphoreHandleDesc_st_union_0))

        if ptr[0] is NULL:
            raise MemoryError
        # TODO init values, if present

    @staticmethod
    cdef hipExternalSemaphoreHandleDesc_st_union_0 new():
        """Factory function to create hipExternalSemaphoreHandleDesc_st_union_0 objects with
        newly allocated chip.hipExternalSemaphoreHandleDesc_st_union_0"""
        cdef chip.hipExternalSemaphoreHandleDesc_st_union_0* ptr
        hipExternalSemaphoreHandleDesc_st_union_0.__allocate(&ptr)
        return hipExternalSemaphoreHandleDesc_st_union_0.from_ptr(ptr, owner=True)
   
    # True
    # True
    def __init__(self,**kwargs):
        hipExternalSemaphoreHandleDesc_st_union_0.__allocate(&self._ptr)
        self.ptr_owner = True
        attribs = self.PROPERTIES()
        used_attribs = set()
        if len(kwargs) > 1:
            raise ValueError("Not more than one attribute might specified for Python types derived from C union types.")
        valid_names = ", ".join(["'"+p+"'" for p in attribs])
        for k,v in kwargs.items():
            if k in used_attribs:
                raise KeyError(f"argument '{k}' has already been specified as positional argument.")
            elif k not in attribs:
                raise KeyError(f"'{k}' is no valid property name. Valid names: {valid_names}")
            setattr(self,k,v)
    
    def __int__(self):
        """Returns the data's address as long integer."""
        return cpython.long.PyLong_FromVoidPtr(self._ptr)
    def __repr__(self):
        return f"<hipExternalSemaphoreHandleDesc_st_union_0 object, self.ptr={int(self)}>"
    def as_c_void_p(self):
        """Returns the data's address as `ctypes.c_void_p`"""
        return ctypes.c_void_p(int(self))
    def get_fd(self, i):
        """Get value ``fd`` of ``self._ptr[i]``.
        """
        return self._ptr[i].fd
    def set_fd(self, i, int value):
        """Set value ``fd`` of ``self._ptr[i]``.
        """
        self._ptr[i].fd = value
    @property
    def fd(self):
        return self.get_fd(0)
    @fd.setter
    def fd(self, int value):
        self.set_fd(0,value)

    def get_win32(self, i):
        """Get value of ``win32`` of ``self._ptr[i]``.
        """
        return hipExternalSemaphoreHandleDesc_st_union_0_struct_0.from_ptr(&self._ptr[i].win32)
    @property
    def win32(self):
        return self.get_win32(0)

    @staticmethod
    def PROPERTIES():
        return ["fd","win32"]


cdef class hipExternalSemaphoreHandleDesc_st:
    # members declared in pxd file

    def __cinit__(self):
        self._ptr = NULL
        self.ptr_owner = False
        self._py_buffer_acquired = False

    @staticmethod
    cdef hipExternalSemaphoreHandleDesc_st from_ptr(chip.hipExternalSemaphoreHandleDesc_st* ptr, bint owner=False):
        """Factory function to create ``hipExternalSemaphoreHandleDesc_st`` objects from
        given ``chip.hipExternalSemaphoreHandleDesc_st`` pointer.

        Setting ``owner`` flag to ``True`` causes
        the extension type to ``free`` the structure pointed to by ``ptr``
        when the wrapper object is deallocated.
        """
        # Fast call to __new__() that bypasses the __init__() constructor.
        cdef hipExternalSemaphoreHandleDesc_st wrapper = hipExternalSemaphoreHandleDesc_st.__new__(hipExternalSemaphoreHandleDesc_st)
        wrapper._ptr = ptr
        wrapper.ptr_owner = owner
        return wrapper

    @staticmethod
    cdef hipExternalSemaphoreHandleDesc_st from_pyobj(object pyobj):
        """Derives a hipExternalSemaphoreHandleDesc_st from a Python object.

        Derives a hipExternalSemaphoreHandleDesc_st from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``hipExternalSemaphoreHandleDesc_st`` reference, this method
        returns it directly. No new ``hipExternalSemaphoreHandleDesc_st`` is created in this case.

        Args:
            pyobj (object): Must be either ``None``, a simple, contiguous buffer according to the buffer protocol,
                            or of type ``hipExternalSemaphoreHandleDesc_st``, ``int``, or ``ctypes.c_void_p``

        Note:
            This routine does not perform a copy but returns the original ``pyobj``
            if ``pyobj`` is an instance of hipExternalSemaphoreHandleDesc_st!
        """
        cdef hipExternalSemaphoreHandleDesc_st wrapper = hipExternalSemaphoreHandleDesc_st.__new__(hipExternalSemaphoreHandleDesc_st)
        cdef dict cuda_array_interface = getattr(pyobj, "__cuda_array_interface__", None)

        if pyobj is None:
            wrapper._ptr = NULL
        elif isinstance(pyobj,hipExternalSemaphoreHandleDesc_st):
            return pyobj
        elif isinstance(pyobj,int):
            wrapper._ptr = <chip.hipExternalSemaphoreHandleDesc_st*>cpython.long.PyLong_AsVoidPtr(pyobj)
        elif isinstance(pyobj,ctypes.c_void_p):
            wrapper._ptr = <chip.hipExternalSemaphoreHandleDesc_st*>cpython.long.PyLong_AsVoidPtr(pyobj.value) if pyobj.value != None else NULL
        elif cuda_array_interface != None:
            if not "data" in cuda_array_interface:
                raise ValueError("input object has '__cuda_array_interface__' attribute but the dict has no 'data' key")
            ptr_as_int = cuda_array_interface["data"][0]
            wrapper._ptr = <chip.hipExternalSemaphoreHandleDesc_st*>cpython.long.PyLong_AsVoidPtr(ptr_as_int)
        elif cpython.buffer.PyObject_CheckBuffer(pyobj):
            err = cpython.buffer.PyObject_GetBuffer( 
                pyobj,
                &wrapper._py_buffer, 
                cpython.buffer.PyBUF_SIMPLE | cpython.buffer.PyBUF_ANY_CONTIGUOUS
            )
            if err == -1:
                raise RuntimeError("failed to create simple, contiguous Py_buffer from Python object")
            wrapper._py_buffer_acquired = True
            wrapper._ptr = <chip.hipExternalSemaphoreHandleDesc_st*>wrapper._py_buffer.buf
        else:
            raise TypeError(f"unsupported input type: '{str(type(pyobj))}'")
        return wrapper
    def __dealloc__(self):
        # Release the buffer handle
        if self._py_buffer_acquired is True:
            cpython.buffer.PyBuffer_Release(&self._py_buffer)
        # De-allocate if not null and flag is set
        if self._ptr is not NULL and self.ptr_owner is True:
            stdlib.free(self._ptr)
            self._ptr = NULL
    @staticmethod
    cdef __allocate(chip.hipExternalSemaphoreHandleDesc_st** ptr):
        ptr[0] = <chip.hipExternalSemaphoreHandleDesc_st*>stdlib.malloc(sizeof(chip.hipExternalSemaphoreHandleDesc_st))

        if ptr[0] is NULL:
            raise MemoryError
        # TODO init values, if present

    @staticmethod
    cdef hipExternalSemaphoreHandleDesc_st new():
        """Factory function to create hipExternalSemaphoreHandleDesc_st objects with
        newly allocated chip.hipExternalSemaphoreHandleDesc_st"""
        cdef chip.hipExternalSemaphoreHandleDesc_st* ptr
        hipExternalSemaphoreHandleDesc_st.__allocate(&ptr)
        return hipExternalSemaphoreHandleDesc_st.from_ptr(ptr, owner=True)
   
    def __init__(self,*args,**kwargs):
        hipExternalSemaphoreHandleDesc_st.__allocate(&self._ptr)
        self.ptr_owner = True
        attribs = self.PROPERTIES()
        used_attribs = set()
        if len(args) > len(attribs):
            raise ValueError("More positional arguments specified than this type has properties.")
        for i,v in enumerate(args):
            setattr(self,attribs[i],v)
            used_attribs.add(attribs[i])
        valid_names = ", ".join(["'"+p+"'" for p in attribs])
        for k,v in kwargs.items():
            if k in used_attribs:
                raise KeyError(f"argument '{k}' has already been specified as positional argument.")
            elif k not in attribs:
                raise KeyError(f"'{k}' is no valid property name. Valid names: {valid_names}")
            setattr(self,k,v)
    
    def __int__(self):
        """Returns the data's address as long integer."""
        return cpython.long.PyLong_FromVoidPtr(self._ptr)
    def __repr__(self):
        return f"<hipExternalSemaphoreHandleDesc_st object, self.ptr={int(self)}>"
    def as_c_void_p(self):
        """Returns the data's address as `ctypes.c_void_p`"""
        return ctypes.c_void_p(int(self))
    def get_type(self, i):
        """Get value of ``type`` of ``self._ptr[i]``.
        """
        return hipExternalSemaphoreHandleType_enum(self._ptr[i].type)
    def set_type(self, i, value):
        """Set value ``type`` of ``self._ptr[i]``.
        """
        if not isinstance(value, hipExternalSemaphoreHandleType_enum):
            raise TypeError("'value' must be of type 'hipExternalSemaphoreHandleType_enum'")
        self._ptr[i].type = value.value
    @property
    def type(self):
        return self.get_type(0)
    @type.setter
    def type(self, value):
        self.set_type(0,value)

    def get_handle(self, i):
        """Get value of ``handle`` of ``self._ptr[i]``.
        """
        return hipExternalSemaphoreHandleDesc_st_union_0.from_ptr(&self._ptr[i].handle)
    @property
    def handle(self):
        return self.get_handle(0)

    def get_flags(self, i):
        """Get value ``flags`` of ``self._ptr[i]``.
        """
        return self._ptr[i].flags
    def set_flags(self, i, unsigned int value):
        """Set value ``flags`` of ``self._ptr[i]``.
        """
        self._ptr[i].flags = value
    @property
    def flags(self):
        return self.get_flags(0)
    @flags.setter
    def flags(self, unsigned int value):
        self.set_flags(0,value)

    @staticmethod
    def PROPERTIES():
        return ["type","handle","flags"]

    def __contains__(self,item):
        properties = self.PROPERTIES()
        return item in properties

    def __getitem__(self,item):
        properties = self.PROPERTIES()
        if isinstance(item,int):
            if item < 0 or item >= len(properties):
                raise IndexError()
            return getattr(self,properties[item])
        raise ValueError("'item' type must be 'int'")


hipExternalSemaphoreHandleDesc = hipExternalSemaphoreHandleDesc_st

cdef class hipExternalSemaphoreSignalParams_st_struct_0_struct_0:
    # members declared in pxd file

    def __cinit__(self):
        self._ptr = NULL
        self.ptr_owner = False
        self._py_buffer_acquired = False

    @staticmethod
    cdef hipExternalSemaphoreSignalParams_st_struct_0_struct_0 from_ptr(chip.hipExternalSemaphoreSignalParams_st_struct_0_struct_0* ptr, bint owner=False):
        """Factory function to create ``hipExternalSemaphoreSignalParams_st_struct_0_struct_0`` objects from
        given ``chip.hipExternalSemaphoreSignalParams_st_struct_0_struct_0`` pointer.

        Setting ``owner`` flag to ``True`` causes
        the extension type to ``free`` the structure pointed to by ``ptr``
        when the wrapper object is deallocated.
        """
        # Fast call to __new__() that bypasses the __init__() constructor.
        cdef hipExternalSemaphoreSignalParams_st_struct_0_struct_0 wrapper = hipExternalSemaphoreSignalParams_st_struct_0_struct_0.__new__(hipExternalSemaphoreSignalParams_st_struct_0_struct_0)
        wrapper._ptr = ptr
        wrapper.ptr_owner = owner
        return wrapper

    @staticmethod
    cdef hipExternalSemaphoreSignalParams_st_struct_0_struct_0 from_pyobj(object pyobj):
        """Derives a hipExternalSemaphoreSignalParams_st_struct_0_struct_0 from a Python object.

        Derives a hipExternalSemaphoreSignalParams_st_struct_0_struct_0 from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``hipExternalSemaphoreSignalParams_st_struct_0_struct_0`` reference, this method
        returns it directly. No new ``hipExternalSemaphoreSignalParams_st_struct_0_struct_0`` is created in this case.

        Args:
            pyobj (object): Must be either ``None``, a simple, contiguous buffer according to the buffer protocol,
                            or of type ``hipExternalSemaphoreSignalParams_st_struct_0_struct_0``, ``int``, or ``ctypes.c_void_p``

        Note:
            This routine does not perform a copy but returns the original ``pyobj``
            if ``pyobj`` is an instance of hipExternalSemaphoreSignalParams_st_struct_0_struct_0!
        """
        cdef hipExternalSemaphoreSignalParams_st_struct_0_struct_0 wrapper = hipExternalSemaphoreSignalParams_st_struct_0_struct_0.__new__(hipExternalSemaphoreSignalParams_st_struct_0_struct_0)
        cdef dict cuda_array_interface = getattr(pyobj, "__cuda_array_interface__", None)

        if pyobj is None:
            wrapper._ptr = NULL
        elif isinstance(pyobj,hipExternalSemaphoreSignalParams_st_struct_0_struct_0):
            return pyobj
        elif isinstance(pyobj,int):
            wrapper._ptr = <chip.hipExternalSemaphoreSignalParams_st_struct_0_struct_0*>cpython.long.PyLong_AsVoidPtr(pyobj)
        elif isinstance(pyobj,ctypes.c_void_p):
            wrapper._ptr = <chip.hipExternalSemaphoreSignalParams_st_struct_0_struct_0*>cpython.long.PyLong_AsVoidPtr(pyobj.value) if pyobj.value != None else NULL
        elif cuda_array_interface != None:
            if not "data" in cuda_array_interface:
                raise ValueError("input object has '__cuda_array_interface__' attribute but the dict has no 'data' key")
            ptr_as_int = cuda_array_interface["data"][0]
            wrapper._ptr = <chip.hipExternalSemaphoreSignalParams_st_struct_0_struct_0*>cpython.long.PyLong_AsVoidPtr(ptr_as_int)
        elif cpython.buffer.PyObject_CheckBuffer(pyobj):
            err = cpython.buffer.PyObject_GetBuffer( 
                pyobj,
                &wrapper._py_buffer, 
                cpython.buffer.PyBUF_SIMPLE | cpython.buffer.PyBUF_ANY_CONTIGUOUS
            )
            if err == -1:
                raise RuntimeError("failed to create simple, contiguous Py_buffer from Python object")
            wrapper._py_buffer_acquired = True
            wrapper._ptr = <chip.hipExternalSemaphoreSignalParams_st_struct_0_struct_0*>wrapper._py_buffer.buf
        else:
            raise TypeError(f"unsupported input type: '{str(type(pyobj))}'")
        return wrapper
    def __dealloc__(self):
        # Release the buffer handle
        if self._py_buffer_acquired is True:
            cpython.buffer.PyBuffer_Release(&self._py_buffer)
        # De-allocate if not null and flag is set
        if self._ptr is not NULL and self.ptr_owner is True:
            stdlib.free(self._ptr)
            self._ptr = NULL
    @staticmethod
    cdef __allocate(chip.hipExternalSemaphoreSignalParams_st_struct_0_struct_0** ptr):
        ptr[0] = <chip.hipExternalSemaphoreSignalParams_st_struct_0_struct_0*>stdlib.malloc(sizeof(chip.hipExternalSemaphoreSignalParams_st_struct_0_struct_0))

        if ptr[0] is NULL:
            raise MemoryError
        # TODO init values, if present

    @staticmethod
    cdef hipExternalSemaphoreSignalParams_st_struct_0_struct_0 new():
        """Factory function to create hipExternalSemaphoreSignalParams_st_struct_0_struct_0 objects with
        newly allocated chip.hipExternalSemaphoreSignalParams_st_struct_0_struct_0"""
        cdef chip.hipExternalSemaphoreSignalParams_st_struct_0_struct_0* ptr
        hipExternalSemaphoreSignalParams_st_struct_0_struct_0.__allocate(&ptr)
        return hipExternalSemaphoreSignalParams_st_struct_0_struct_0.from_ptr(ptr, owner=True)
   
    def __init__(self,*args,**kwargs):
        hipExternalSemaphoreSignalParams_st_struct_0_struct_0.__allocate(&self._ptr)
        self.ptr_owner = True
        attribs = self.PROPERTIES()
        used_attribs = set()
        if len(args) > len(attribs):
            raise ValueError("More positional arguments specified than this type has properties.")
        for i,v in enumerate(args):
            setattr(self,attribs[i],v)
            used_attribs.add(attribs[i])
        valid_names = ", ".join(["'"+p+"'" for p in attribs])
        for k,v in kwargs.items():
            if k in used_attribs:
                raise KeyError(f"argument '{k}' has already been specified as positional argument.")
            elif k not in attribs:
                raise KeyError(f"'{k}' is no valid property name. Valid names: {valid_names}")
            setattr(self,k,v)
    
    def __int__(self):
        """Returns the data's address as long integer."""
        return cpython.long.PyLong_FromVoidPtr(self._ptr)
    def __repr__(self):
        return f"<hipExternalSemaphoreSignalParams_st_struct_0_struct_0 object, self.ptr={int(self)}>"
    def as_c_void_p(self):
        """Returns the data's address as `ctypes.c_void_p`"""
        return ctypes.c_void_p(int(self))
    def get_value(self, i):
        """Get value ``value`` of ``self._ptr[i]``.
        """
        return self._ptr[i].value
    def set_value(self, i, unsigned long long value):
        """Set value ``value`` of ``self._ptr[i]``.
        """
        self._ptr[i].value = value
    @property
    def value(self):
        return self.get_value(0)
    @value.setter
    def value(self, unsigned long long value):
        self.set_value(0,value)

    @staticmethod
    def PROPERTIES():
        return ["value"]

    def __contains__(self,item):
        properties = self.PROPERTIES()
        return item in properties

    def __getitem__(self,item):
        properties = self.PROPERTIES()
        if isinstance(item,int):
            if item < 0 or item >= len(properties):
                raise IndexError()
            return getattr(self,properties[item])
        raise ValueError("'item' type must be 'int'")


cdef class hipExternalSemaphoreSignalParams_st_struct_0_struct_1:
    # members declared in pxd file

    def __cinit__(self):
        self._ptr = NULL
        self.ptr_owner = False
        self._py_buffer_acquired = False

    @staticmethod
    cdef hipExternalSemaphoreSignalParams_st_struct_0_struct_1 from_ptr(chip.hipExternalSemaphoreSignalParams_st_struct_0_struct_1* ptr, bint owner=False):
        """Factory function to create ``hipExternalSemaphoreSignalParams_st_struct_0_struct_1`` objects from
        given ``chip.hipExternalSemaphoreSignalParams_st_struct_0_struct_1`` pointer.

        Setting ``owner`` flag to ``True`` causes
        the extension type to ``free`` the structure pointed to by ``ptr``
        when the wrapper object is deallocated.
        """
        # Fast call to __new__() that bypasses the __init__() constructor.
        cdef hipExternalSemaphoreSignalParams_st_struct_0_struct_1 wrapper = hipExternalSemaphoreSignalParams_st_struct_0_struct_1.__new__(hipExternalSemaphoreSignalParams_st_struct_0_struct_1)
        wrapper._ptr = ptr
        wrapper.ptr_owner = owner
        return wrapper

    @staticmethod
    cdef hipExternalSemaphoreSignalParams_st_struct_0_struct_1 from_pyobj(object pyobj):
        """Derives a hipExternalSemaphoreSignalParams_st_struct_0_struct_1 from a Python object.

        Derives a hipExternalSemaphoreSignalParams_st_struct_0_struct_1 from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``hipExternalSemaphoreSignalParams_st_struct_0_struct_1`` reference, this method
        returns it directly. No new ``hipExternalSemaphoreSignalParams_st_struct_0_struct_1`` is created in this case.

        Args:
            pyobj (object): Must be either ``None``, a simple, contiguous buffer according to the buffer protocol,
                            or of type ``hipExternalSemaphoreSignalParams_st_struct_0_struct_1``, ``int``, or ``ctypes.c_void_p``

        Note:
            This routine does not perform a copy but returns the original ``pyobj``
            if ``pyobj`` is an instance of hipExternalSemaphoreSignalParams_st_struct_0_struct_1!
        """
        cdef hipExternalSemaphoreSignalParams_st_struct_0_struct_1 wrapper = hipExternalSemaphoreSignalParams_st_struct_0_struct_1.__new__(hipExternalSemaphoreSignalParams_st_struct_0_struct_1)
        cdef dict cuda_array_interface = getattr(pyobj, "__cuda_array_interface__", None)

        if pyobj is None:
            wrapper._ptr = NULL
        elif isinstance(pyobj,hipExternalSemaphoreSignalParams_st_struct_0_struct_1):
            return pyobj
        elif isinstance(pyobj,int):
            wrapper._ptr = <chip.hipExternalSemaphoreSignalParams_st_struct_0_struct_1*>cpython.long.PyLong_AsVoidPtr(pyobj)
        elif isinstance(pyobj,ctypes.c_void_p):
            wrapper._ptr = <chip.hipExternalSemaphoreSignalParams_st_struct_0_struct_1*>cpython.long.PyLong_AsVoidPtr(pyobj.value) if pyobj.value != None else NULL
        elif cuda_array_interface != None:
            if not "data" in cuda_array_interface:
                raise ValueError("input object has '__cuda_array_interface__' attribute but the dict has no 'data' key")
            ptr_as_int = cuda_array_interface["data"][0]
            wrapper._ptr = <chip.hipExternalSemaphoreSignalParams_st_struct_0_struct_1*>cpython.long.PyLong_AsVoidPtr(ptr_as_int)
        elif cpython.buffer.PyObject_CheckBuffer(pyobj):
            err = cpython.buffer.PyObject_GetBuffer( 
                pyobj,
                &wrapper._py_buffer, 
                cpython.buffer.PyBUF_SIMPLE | cpython.buffer.PyBUF_ANY_CONTIGUOUS
            )
            if err == -1:
                raise RuntimeError("failed to create simple, contiguous Py_buffer from Python object")
            wrapper._py_buffer_acquired = True
            wrapper._ptr = <chip.hipExternalSemaphoreSignalParams_st_struct_0_struct_1*>wrapper._py_buffer.buf
        else:
            raise TypeError(f"unsupported input type: '{str(type(pyobj))}'")
        return wrapper
    def __dealloc__(self):
        # Release the buffer handle
        if self._py_buffer_acquired is True:
            cpython.buffer.PyBuffer_Release(&self._py_buffer)
        # De-allocate if not null and flag is set
        if self._ptr is not NULL and self.ptr_owner is True:
            stdlib.free(self._ptr)
            self._ptr = NULL
    @staticmethod
    cdef __allocate(chip.hipExternalSemaphoreSignalParams_st_struct_0_struct_1** ptr):
        ptr[0] = <chip.hipExternalSemaphoreSignalParams_st_struct_0_struct_1*>stdlib.malloc(sizeof(chip.hipExternalSemaphoreSignalParams_st_struct_0_struct_1))

        if ptr[0] is NULL:
            raise MemoryError
        # TODO init values, if present

    @staticmethod
    cdef hipExternalSemaphoreSignalParams_st_struct_0_struct_1 new():
        """Factory function to create hipExternalSemaphoreSignalParams_st_struct_0_struct_1 objects with
        newly allocated chip.hipExternalSemaphoreSignalParams_st_struct_0_struct_1"""
        cdef chip.hipExternalSemaphoreSignalParams_st_struct_0_struct_1* ptr
        hipExternalSemaphoreSignalParams_st_struct_0_struct_1.__allocate(&ptr)
        return hipExternalSemaphoreSignalParams_st_struct_0_struct_1.from_ptr(ptr, owner=True)
   
    def __init__(self,*args,**kwargs):
        hipExternalSemaphoreSignalParams_st_struct_0_struct_1.__allocate(&self._ptr)
        self.ptr_owner = True
        attribs = self.PROPERTIES()
        used_attribs = set()
        if len(args) > len(attribs):
            raise ValueError("More positional arguments specified than this type has properties.")
        for i,v in enumerate(args):
            setattr(self,attribs[i],v)
            used_attribs.add(attribs[i])
        valid_names = ", ".join(["'"+p+"'" for p in attribs])
        for k,v in kwargs.items():
            if k in used_attribs:
                raise KeyError(f"argument '{k}' has already been specified as positional argument.")
            elif k not in attribs:
                raise KeyError(f"'{k}' is no valid property name. Valid names: {valid_names}")
            setattr(self,k,v)
    
    def __int__(self):
        """Returns the data's address as long integer."""
        return cpython.long.PyLong_FromVoidPtr(self._ptr)
    def __repr__(self):
        return f"<hipExternalSemaphoreSignalParams_st_struct_0_struct_1 object, self.ptr={int(self)}>"
    def as_c_void_p(self):
        """Returns the data's address as `ctypes.c_void_p`"""
        return ctypes.c_void_p(int(self))
    def get_key(self, i):
        """Get value ``key`` of ``self._ptr[i]``.
        """
        return self._ptr[i].key
    def set_key(self, i, unsigned long long value):
        """Set value ``key`` of ``self._ptr[i]``.
        """
        self._ptr[i].key = value
    @property
    def key(self):
        return self.get_key(0)
    @key.setter
    def key(self, unsigned long long value):
        self.set_key(0,value)

    @staticmethod
    def PROPERTIES():
        return ["key"]

    def __contains__(self,item):
        properties = self.PROPERTIES()
        return item in properties

    def __getitem__(self,item):
        properties = self.PROPERTIES()
        if isinstance(item,int):
            if item < 0 or item >= len(properties):
                raise IndexError()
            return getattr(self,properties[item])
        raise ValueError("'item' type must be 'int'")


cdef class hipExternalSemaphoreSignalParams_st_struct_0:
    # members declared in pxd file

    def __cinit__(self):
        self._ptr = NULL
        self.ptr_owner = False
        self._py_buffer_acquired = False

    @staticmethod
    cdef hipExternalSemaphoreSignalParams_st_struct_0 from_ptr(chip.hipExternalSemaphoreSignalParams_st_struct_0* ptr, bint owner=False):
        """Factory function to create ``hipExternalSemaphoreSignalParams_st_struct_0`` objects from
        given ``chip.hipExternalSemaphoreSignalParams_st_struct_0`` pointer.

        Setting ``owner`` flag to ``True`` causes
        the extension type to ``free`` the structure pointed to by ``ptr``
        when the wrapper object is deallocated.
        """
        # Fast call to __new__() that bypasses the __init__() constructor.
        cdef hipExternalSemaphoreSignalParams_st_struct_0 wrapper = hipExternalSemaphoreSignalParams_st_struct_0.__new__(hipExternalSemaphoreSignalParams_st_struct_0)
        wrapper._ptr = ptr
        wrapper.ptr_owner = owner
        return wrapper

    @staticmethod
    cdef hipExternalSemaphoreSignalParams_st_struct_0 from_pyobj(object pyobj):
        """Derives a hipExternalSemaphoreSignalParams_st_struct_0 from a Python object.

        Derives a hipExternalSemaphoreSignalParams_st_struct_0 from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``hipExternalSemaphoreSignalParams_st_struct_0`` reference, this method
        returns it directly. No new ``hipExternalSemaphoreSignalParams_st_struct_0`` is created in this case.

        Args:
            pyobj (object): Must be either ``None``, a simple, contiguous buffer according to the buffer protocol,
                            or of type ``hipExternalSemaphoreSignalParams_st_struct_0``, ``int``, or ``ctypes.c_void_p``

        Note:
            This routine does not perform a copy but returns the original ``pyobj``
            if ``pyobj`` is an instance of hipExternalSemaphoreSignalParams_st_struct_0!
        """
        cdef hipExternalSemaphoreSignalParams_st_struct_0 wrapper = hipExternalSemaphoreSignalParams_st_struct_0.__new__(hipExternalSemaphoreSignalParams_st_struct_0)
        cdef dict cuda_array_interface = getattr(pyobj, "__cuda_array_interface__", None)

        if pyobj is None:
            wrapper._ptr = NULL
        elif isinstance(pyobj,hipExternalSemaphoreSignalParams_st_struct_0):
            return pyobj
        elif isinstance(pyobj,int):
            wrapper._ptr = <chip.hipExternalSemaphoreSignalParams_st_struct_0*>cpython.long.PyLong_AsVoidPtr(pyobj)
        elif isinstance(pyobj,ctypes.c_void_p):
            wrapper._ptr = <chip.hipExternalSemaphoreSignalParams_st_struct_0*>cpython.long.PyLong_AsVoidPtr(pyobj.value) if pyobj.value != None else NULL
        elif cuda_array_interface != None:
            if not "data" in cuda_array_interface:
                raise ValueError("input object has '__cuda_array_interface__' attribute but the dict has no 'data' key")
            ptr_as_int = cuda_array_interface["data"][0]
            wrapper._ptr = <chip.hipExternalSemaphoreSignalParams_st_struct_0*>cpython.long.PyLong_AsVoidPtr(ptr_as_int)
        elif cpython.buffer.PyObject_CheckBuffer(pyobj):
            err = cpython.buffer.PyObject_GetBuffer( 
                pyobj,
                &wrapper._py_buffer, 
                cpython.buffer.PyBUF_SIMPLE | cpython.buffer.PyBUF_ANY_CONTIGUOUS
            )
            if err == -1:
                raise RuntimeError("failed to create simple, contiguous Py_buffer from Python object")
            wrapper._py_buffer_acquired = True
            wrapper._ptr = <chip.hipExternalSemaphoreSignalParams_st_struct_0*>wrapper._py_buffer.buf
        else:
            raise TypeError(f"unsupported input type: '{str(type(pyobj))}'")
        return wrapper
    def __dealloc__(self):
        # Release the buffer handle
        if self._py_buffer_acquired is True:
            cpython.buffer.PyBuffer_Release(&self._py_buffer)
        # De-allocate if not null and flag is set
        if self._ptr is not NULL and self.ptr_owner is True:
            stdlib.free(self._ptr)
            self._ptr = NULL
    @staticmethod
    cdef __allocate(chip.hipExternalSemaphoreSignalParams_st_struct_0** ptr):
        ptr[0] = <chip.hipExternalSemaphoreSignalParams_st_struct_0*>stdlib.malloc(sizeof(chip.hipExternalSemaphoreSignalParams_st_struct_0))

        if ptr[0] is NULL:
            raise MemoryError
        # TODO init values, if present

    @staticmethod
    cdef hipExternalSemaphoreSignalParams_st_struct_0 new():
        """Factory function to create hipExternalSemaphoreSignalParams_st_struct_0 objects with
        newly allocated chip.hipExternalSemaphoreSignalParams_st_struct_0"""
        cdef chip.hipExternalSemaphoreSignalParams_st_struct_0* ptr
        hipExternalSemaphoreSignalParams_st_struct_0.__allocate(&ptr)
        return hipExternalSemaphoreSignalParams_st_struct_0.from_ptr(ptr, owner=True)
   
    def __init__(self,*args,**kwargs):
        hipExternalSemaphoreSignalParams_st_struct_0.__allocate(&self._ptr)
        self.ptr_owner = True
        attribs = self.PROPERTIES()
        used_attribs = set()
        if len(args) > len(attribs):
            raise ValueError("More positional arguments specified than this type has properties.")
        for i,v in enumerate(args):
            setattr(self,attribs[i],v)
            used_attribs.add(attribs[i])
        valid_names = ", ".join(["'"+p+"'" for p in attribs])
        for k,v in kwargs.items():
            if k in used_attribs:
                raise KeyError(f"argument '{k}' has already been specified as positional argument.")
            elif k not in attribs:
                raise KeyError(f"'{k}' is no valid property name. Valid names: {valid_names}")
            setattr(self,k,v)
    
    def __int__(self):
        """Returns the data's address as long integer."""
        return cpython.long.PyLong_FromVoidPtr(self._ptr)
    def __repr__(self):
        return f"<hipExternalSemaphoreSignalParams_st_struct_0 object, self.ptr={int(self)}>"
    def as_c_void_p(self):
        """Returns the data's address as `ctypes.c_void_p`"""
        return ctypes.c_void_p(int(self))
    def get_fence(self, i):
        """Get value of ``fence`` of ``self._ptr[i]``.
        """
        return hipExternalSemaphoreSignalParams_st_struct_0_struct_0.from_ptr(&self._ptr[i].fence)
    @property
    def fence(self):
        return self.get_fence(0)

    def get_keyedMutex(self, i):
        """Get value of ``keyedMutex`` of ``self._ptr[i]``.
        """
        return hipExternalSemaphoreSignalParams_st_struct_0_struct_1.from_ptr(&self._ptr[i].keyedMutex)
    @property
    def keyedMutex(self):
        return self.get_keyedMutex(0)

    def get_reserved(self, i):
        """Get value of ``reserved`` of ``self._ptr[i]``.
        """
        return self._ptr[i].reserved
    # TODO add setters
    #def set_reserved(self, i, unsigned int[12] value):
    #    """Set value ``reserved`` of ``self._ptr[i]``.
    #    """
    #    self._ptr[i].reserved = value
    @property
    def reserved(self):
        return self.get_reserved(0)
    # TODO add setters
    #@reserved.setter
    #def reserved(self, unsigned int[12] value):
    #    self.set_reserved(0,value)

    @staticmethod
    def PROPERTIES():
        return ["fence","keyedMutex","reserved"]

    def __contains__(self,item):
        properties = self.PROPERTIES()
        return item in properties

    def __getitem__(self,item):
        properties = self.PROPERTIES()
        if isinstance(item,int):
            if item < 0 or item >= len(properties):
                raise IndexError()
            return getattr(self,properties[item])
        raise ValueError("'item' type must be 'int'")


cdef class hipExternalSemaphoreSignalParams_st:
    # members declared in pxd file

    def __cinit__(self):
        self._ptr = NULL
        self.ptr_owner = False
        self._py_buffer_acquired = False

    @staticmethod
    cdef hipExternalSemaphoreSignalParams_st from_ptr(chip.hipExternalSemaphoreSignalParams_st* ptr, bint owner=False):
        """Factory function to create ``hipExternalSemaphoreSignalParams_st`` objects from
        given ``chip.hipExternalSemaphoreSignalParams_st`` pointer.

        Setting ``owner`` flag to ``True`` causes
        the extension type to ``free`` the structure pointed to by ``ptr``
        when the wrapper object is deallocated.
        """
        # Fast call to __new__() that bypasses the __init__() constructor.
        cdef hipExternalSemaphoreSignalParams_st wrapper = hipExternalSemaphoreSignalParams_st.__new__(hipExternalSemaphoreSignalParams_st)
        wrapper._ptr = ptr
        wrapper.ptr_owner = owner
        return wrapper

    @staticmethod
    cdef hipExternalSemaphoreSignalParams_st from_pyobj(object pyobj):
        """Derives a hipExternalSemaphoreSignalParams_st from a Python object.

        Derives a hipExternalSemaphoreSignalParams_st from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``hipExternalSemaphoreSignalParams_st`` reference, this method
        returns it directly. No new ``hipExternalSemaphoreSignalParams_st`` is created in this case.

        Args:
            pyobj (object): Must be either ``None``, a simple, contiguous buffer according to the buffer protocol,
                            or of type ``hipExternalSemaphoreSignalParams_st``, ``int``, or ``ctypes.c_void_p``

        Note:
            This routine does not perform a copy but returns the original ``pyobj``
            if ``pyobj`` is an instance of hipExternalSemaphoreSignalParams_st!
        """
        cdef hipExternalSemaphoreSignalParams_st wrapper = hipExternalSemaphoreSignalParams_st.__new__(hipExternalSemaphoreSignalParams_st)
        cdef dict cuda_array_interface = getattr(pyobj, "__cuda_array_interface__", None)

        if pyobj is None:
            wrapper._ptr = NULL
        elif isinstance(pyobj,hipExternalSemaphoreSignalParams_st):
            return pyobj
        elif isinstance(pyobj,int):
            wrapper._ptr = <chip.hipExternalSemaphoreSignalParams_st*>cpython.long.PyLong_AsVoidPtr(pyobj)
        elif isinstance(pyobj,ctypes.c_void_p):
            wrapper._ptr = <chip.hipExternalSemaphoreSignalParams_st*>cpython.long.PyLong_AsVoidPtr(pyobj.value) if pyobj.value != None else NULL
        elif cuda_array_interface != None:
            if not "data" in cuda_array_interface:
                raise ValueError("input object has '__cuda_array_interface__' attribute but the dict has no 'data' key")
            ptr_as_int = cuda_array_interface["data"][0]
            wrapper._ptr = <chip.hipExternalSemaphoreSignalParams_st*>cpython.long.PyLong_AsVoidPtr(ptr_as_int)
        elif cpython.buffer.PyObject_CheckBuffer(pyobj):
            err = cpython.buffer.PyObject_GetBuffer( 
                pyobj,
                &wrapper._py_buffer, 
                cpython.buffer.PyBUF_SIMPLE | cpython.buffer.PyBUF_ANY_CONTIGUOUS
            )
            if err == -1:
                raise RuntimeError("failed to create simple, contiguous Py_buffer from Python object")
            wrapper._py_buffer_acquired = True
            wrapper._ptr = <chip.hipExternalSemaphoreSignalParams_st*>wrapper._py_buffer.buf
        else:
            raise TypeError(f"unsupported input type: '{str(type(pyobj))}'")
        return wrapper
    def __dealloc__(self):
        # Release the buffer handle
        if self._py_buffer_acquired is True:
            cpython.buffer.PyBuffer_Release(&self._py_buffer)
        # De-allocate if not null and flag is set
        if self._ptr is not NULL and self.ptr_owner is True:
            stdlib.free(self._ptr)
            self._ptr = NULL
    @staticmethod
    cdef __allocate(chip.hipExternalSemaphoreSignalParams_st** ptr):
        ptr[0] = <chip.hipExternalSemaphoreSignalParams_st*>stdlib.malloc(sizeof(chip.hipExternalSemaphoreSignalParams_st))

        if ptr[0] is NULL:
            raise MemoryError
        # TODO init values, if present

    @staticmethod
    cdef hipExternalSemaphoreSignalParams_st new():
        """Factory function to create hipExternalSemaphoreSignalParams_st objects with
        newly allocated chip.hipExternalSemaphoreSignalParams_st"""
        cdef chip.hipExternalSemaphoreSignalParams_st* ptr
        hipExternalSemaphoreSignalParams_st.__allocate(&ptr)
        return hipExternalSemaphoreSignalParams_st.from_ptr(ptr, owner=True)
   
    def __init__(self,*args,**kwargs):
        hipExternalSemaphoreSignalParams_st.__allocate(&self._ptr)
        self.ptr_owner = True
        attribs = self.PROPERTIES()
        used_attribs = set()
        if len(args) > len(attribs):
            raise ValueError("More positional arguments specified than this type has properties.")
        for i,v in enumerate(args):
            setattr(self,attribs[i],v)
            used_attribs.add(attribs[i])
        valid_names = ", ".join(["'"+p+"'" for p in attribs])
        for k,v in kwargs.items():
            if k in used_attribs:
                raise KeyError(f"argument '{k}' has already been specified as positional argument.")
            elif k not in attribs:
                raise KeyError(f"'{k}' is no valid property name. Valid names: {valid_names}")
            setattr(self,k,v)
    
    def __int__(self):
        """Returns the data's address as long integer."""
        return cpython.long.PyLong_FromVoidPtr(self._ptr)
    def __repr__(self):
        return f"<hipExternalSemaphoreSignalParams_st object, self.ptr={int(self)}>"
    def as_c_void_p(self):
        """Returns the data's address as `ctypes.c_void_p`"""
        return ctypes.c_void_p(int(self))
    def get_params(self, i):
        """Get value of ``params`` of ``self._ptr[i]``.
        """
        return hipExternalSemaphoreSignalParams_st_struct_0.from_ptr(&self._ptr[i].params)
    @property
    def params(self):
        return self.get_params(0)

    def get_flags(self, i):
        """Get value ``flags`` of ``self._ptr[i]``.
        """
        return self._ptr[i].flags
    def set_flags(self, i, unsigned int value):
        """Set value ``flags`` of ``self._ptr[i]``.
        """
        self._ptr[i].flags = value
    @property
    def flags(self):
        return self.get_flags(0)
    @flags.setter
    def flags(self, unsigned int value):
        self.set_flags(0,value)

    def get_reserved(self, i):
        """Get value of ``reserved`` of ``self._ptr[i]``.
        """
        return self._ptr[i].reserved
    # TODO add setters
    #def set_reserved(self, i, unsigned int[16] value):
    #    """Set value ``reserved`` of ``self._ptr[i]``.
    #    """
    #    self._ptr[i].reserved = value
    @property
    def reserved(self):
        return self.get_reserved(0)
    # TODO add setters
    #@reserved.setter
    #def reserved(self, unsigned int[16] value):
    #    self.set_reserved(0,value)

    @staticmethod
    def PROPERTIES():
        return ["params","flags","reserved"]

    def __contains__(self,item):
        properties = self.PROPERTIES()
        return item in properties

    def __getitem__(self,item):
        properties = self.PROPERTIES()
        if isinstance(item,int):
            if item < 0 or item >= len(properties):
                raise IndexError()
            return getattr(self,properties[item])
        raise ValueError("'item' type must be 'int'")


hipExternalSemaphoreSignalParams = hipExternalSemaphoreSignalParams_st

cdef class hipExternalSemaphoreWaitParams_st_struct_0_struct_0:
    # members declared in pxd file

    def __cinit__(self):
        self._ptr = NULL
        self.ptr_owner = False
        self._py_buffer_acquired = False

    @staticmethod
    cdef hipExternalSemaphoreWaitParams_st_struct_0_struct_0 from_ptr(chip.hipExternalSemaphoreWaitParams_st_struct_0_struct_0* ptr, bint owner=False):
        """Factory function to create ``hipExternalSemaphoreWaitParams_st_struct_0_struct_0`` objects from
        given ``chip.hipExternalSemaphoreWaitParams_st_struct_0_struct_0`` pointer.

        Setting ``owner`` flag to ``True`` causes
        the extension type to ``free`` the structure pointed to by ``ptr``
        when the wrapper object is deallocated.
        """
        # Fast call to __new__() that bypasses the __init__() constructor.
        cdef hipExternalSemaphoreWaitParams_st_struct_0_struct_0 wrapper = hipExternalSemaphoreWaitParams_st_struct_0_struct_0.__new__(hipExternalSemaphoreWaitParams_st_struct_0_struct_0)
        wrapper._ptr = ptr
        wrapper.ptr_owner = owner
        return wrapper

    @staticmethod
    cdef hipExternalSemaphoreWaitParams_st_struct_0_struct_0 from_pyobj(object pyobj):
        """Derives a hipExternalSemaphoreWaitParams_st_struct_0_struct_0 from a Python object.

        Derives a hipExternalSemaphoreWaitParams_st_struct_0_struct_0 from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``hipExternalSemaphoreWaitParams_st_struct_0_struct_0`` reference, this method
        returns it directly. No new ``hipExternalSemaphoreWaitParams_st_struct_0_struct_0`` is created in this case.

        Args:
            pyobj (object): Must be either ``None``, a simple, contiguous buffer according to the buffer protocol,
                            or of type ``hipExternalSemaphoreWaitParams_st_struct_0_struct_0``, ``int``, or ``ctypes.c_void_p``

        Note:
            This routine does not perform a copy but returns the original ``pyobj``
            if ``pyobj`` is an instance of hipExternalSemaphoreWaitParams_st_struct_0_struct_0!
        """
        cdef hipExternalSemaphoreWaitParams_st_struct_0_struct_0 wrapper = hipExternalSemaphoreWaitParams_st_struct_0_struct_0.__new__(hipExternalSemaphoreWaitParams_st_struct_0_struct_0)
        cdef dict cuda_array_interface = getattr(pyobj, "__cuda_array_interface__", None)

        if pyobj is None:
            wrapper._ptr = NULL
        elif isinstance(pyobj,hipExternalSemaphoreWaitParams_st_struct_0_struct_0):
            return pyobj
        elif isinstance(pyobj,int):
            wrapper._ptr = <chip.hipExternalSemaphoreWaitParams_st_struct_0_struct_0*>cpython.long.PyLong_AsVoidPtr(pyobj)
        elif isinstance(pyobj,ctypes.c_void_p):
            wrapper._ptr = <chip.hipExternalSemaphoreWaitParams_st_struct_0_struct_0*>cpython.long.PyLong_AsVoidPtr(pyobj.value) if pyobj.value != None else NULL
        elif cuda_array_interface != None:
            if not "data" in cuda_array_interface:
                raise ValueError("input object has '__cuda_array_interface__' attribute but the dict has no 'data' key")
            ptr_as_int = cuda_array_interface["data"][0]
            wrapper._ptr = <chip.hipExternalSemaphoreWaitParams_st_struct_0_struct_0*>cpython.long.PyLong_AsVoidPtr(ptr_as_int)
        elif cpython.buffer.PyObject_CheckBuffer(pyobj):
            err = cpython.buffer.PyObject_GetBuffer( 
                pyobj,
                &wrapper._py_buffer, 
                cpython.buffer.PyBUF_SIMPLE | cpython.buffer.PyBUF_ANY_CONTIGUOUS
            )
            if err == -1:
                raise RuntimeError("failed to create simple, contiguous Py_buffer from Python object")
            wrapper._py_buffer_acquired = True
            wrapper._ptr = <chip.hipExternalSemaphoreWaitParams_st_struct_0_struct_0*>wrapper._py_buffer.buf
        else:
            raise TypeError(f"unsupported input type: '{str(type(pyobj))}'")
        return wrapper
    def __dealloc__(self):
        # Release the buffer handle
        if self._py_buffer_acquired is True:
            cpython.buffer.PyBuffer_Release(&self._py_buffer)
        # De-allocate if not null and flag is set
        if self._ptr is not NULL and self.ptr_owner is True:
            stdlib.free(self._ptr)
            self._ptr = NULL
    @staticmethod
    cdef __allocate(chip.hipExternalSemaphoreWaitParams_st_struct_0_struct_0** ptr):
        ptr[0] = <chip.hipExternalSemaphoreWaitParams_st_struct_0_struct_0*>stdlib.malloc(sizeof(chip.hipExternalSemaphoreWaitParams_st_struct_0_struct_0))

        if ptr[0] is NULL:
            raise MemoryError
        # TODO init values, if present

    @staticmethod
    cdef hipExternalSemaphoreWaitParams_st_struct_0_struct_0 new():
        """Factory function to create hipExternalSemaphoreWaitParams_st_struct_0_struct_0 objects with
        newly allocated chip.hipExternalSemaphoreWaitParams_st_struct_0_struct_0"""
        cdef chip.hipExternalSemaphoreWaitParams_st_struct_0_struct_0* ptr
        hipExternalSemaphoreWaitParams_st_struct_0_struct_0.__allocate(&ptr)
        return hipExternalSemaphoreWaitParams_st_struct_0_struct_0.from_ptr(ptr, owner=True)
   
    def __init__(self,*args,**kwargs):
        hipExternalSemaphoreWaitParams_st_struct_0_struct_0.__allocate(&self._ptr)
        self.ptr_owner = True
        attribs = self.PROPERTIES()
        used_attribs = set()
        if len(args) > len(attribs):
            raise ValueError("More positional arguments specified than this type has properties.")
        for i,v in enumerate(args):
            setattr(self,attribs[i],v)
            used_attribs.add(attribs[i])
        valid_names = ", ".join(["'"+p+"'" for p in attribs])
        for k,v in kwargs.items():
            if k in used_attribs:
                raise KeyError(f"argument '{k}' has already been specified as positional argument.")
            elif k not in attribs:
                raise KeyError(f"'{k}' is no valid property name. Valid names: {valid_names}")
            setattr(self,k,v)
    
    def __int__(self):
        """Returns the data's address as long integer."""
        return cpython.long.PyLong_FromVoidPtr(self._ptr)
    def __repr__(self):
        return f"<hipExternalSemaphoreWaitParams_st_struct_0_struct_0 object, self.ptr={int(self)}>"
    def as_c_void_p(self):
        """Returns the data's address as `ctypes.c_void_p`"""
        return ctypes.c_void_p(int(self))
    def get_value(self, i):
        """Get value ``value`` of ``self._ptr[i]``.
        """
        return self._ptr[i].value
    def set_value(self, i, unsigned long long value):
        """Set value ``value`` of ``self._ptr[i]``.
        """
        self._ptr[i].value = value
    @property
    def value(self):
        return self.get_value(0)
    @value.setter
    def value(self, unsigned long long value):
        self.set_value(0,value)

    @staticmethod
    def PROPERTIES():
        return ["value"]

    def __contains__(self,item):
        properties = self.PROPERTIES()
        return item in properties

    def __getitem__(self,item):
        properties = self.PROPERTIES()
        if isinstance(item,int):
            if item < 0 or item >= len(properties):
                raise IndexError()
            return getattr(self,properties[item])
        raise ValueError("'item' type must be 'int'")


cdef class hipExternalSemaphoreWaitParams_st_struct_0_struct_1:
    # members declared in pxd file

    def __cinit__(self):
        self._ptr = NULL
        self.ptr_owner = False
        self._py_buffer_acquired = False

    @staticmethod
    cdef hipExternalSemaphoreWaitParams_st_struct_0_struct_1 from_ptr(chip.hipExternalSemaphoreWaitParams_st_struct_0_struct_1* ptr, bint owner=False):
        """Factory function to create ``hipExternalSemaphoreWaitParams_st_struct_0_struct_1`` objects from
        given ``chip.hipExternalSemaphoreWaitParams_st_struct_0_struct_1`` pointer.

        Setting ``owner`` flag to ``True`` causes
        the extension type to ``free`` the structure pointed to by ``ptr``
        when the wrapper object is deallocated.
        """
        # Fast call to __new__() that bypasses the __init__() constructor.
        cdef hipExternalSemaphoreWaitParams_st_struct_0_struct_1 wrapper = hipExternalSemaphoreWaitParams_st_struct_0_struct_1.__new__(hipExternalSemaphoreWaitParams_st_struct_0_struct_1)
        wrapper._ptr = ptr
        wrapper.ptr_owner = owner
        return wrapper

    @staticmethod
    cdef hipExternalSemaphoreWaitParams_st_struct_0_struct_1 from_pyobj(object pyobj):
        """Derives a hipExternalSemaphoreWaitParams_st_struct_0_struct_1 from a Python object.

        Derives a hipExternalSemaphoreWaitParams_st_struct_0_struct_1 from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``hipExternalSemaphoreWaitParams_st_struct_0_struct_1`` reference, this method
        returns it directly. No new ``hipExternalSemaphoreWaitParams_st_struct_0_struct_1`` is created in this case.

        Args:
            pyobj (object): Must be either ``None``, a simple, contiguous buffer according to the buffer protocol,
                            or of type ``hipExternalSemaphoreWaitParams_st_struct_0_struct_1``, ``int``, or ``ctypes.c_void_p``

        Note:
            This routine does not perform a copy but returns the original ``pyobj``
            if ``pyobj`` is an instance of hipExternalSemaphoreWaitParams_st_struct_0_struct_1!
        """
        cdef hipExternalSemaphoreWaitParams_st_struct_0_struct_1 wrapper = hipExternalSemaphoreWaitParams_st_struct_0_struct_1.__new__(hipExternalSemaphoreWaitParams_st_struct_0_struct_1)
        cdef dict cuda_array_interface = getattr(pyobj, "__cuda_array_interface__", None)

        if pyobj is None:
            wrapper._ptr = NULL
        elif isinstance(pyobj,hipExternalSemaphoreWaitParams_st_struct_0_struct_1):
            return pyobj
        elif isinstance(pyobj,int):
            wrapper._ptr = <chip.hipExternalSemaphoreWaitParams_st_struct_0_struct_1*>cpython.long.PyLong_AsVoidPtr(pyobj)
        elif isinstance(pyobj,ctypes.c_void_p):
            wrapper._ptr = <chip.hipExternalSemaphoreWaitParams_st_struct_0_struct_1*>cpython.long.PyLong_AsVoidPtr(pyobj.value) if pyobj.value != None else NULL
        elif cuda_array_interface != None:
            if not "data" in cuda_array_interface:
                raise ValueError("input object has '__cuda_array_interface__' attribute but the dict has no 'data' key")
            ptr_as_int = cuda_array_interface["data"][0]
            wrapper._ptr = <chip.hipExternalSemaphoreWaitParams_st_struct_0_struct_1*>cpython.long.PyLong_AsVoidPtr(ptr_as_int)
        elif cpython.buffer.PyObject_CheckBuffer(pyobj):
            err = cpython.buffer.PyObject_GetBuffer( 
                pyobj,
                &wrapper._py_buffer, 
                cpython.buffer.PyBUF_SIMPLE | cpython.buffer.PyBUF_ANY_CONTIGUOUS
            )
            if err == -1:
                raise RuntimeError("failed to create simple, contiguous Py_buffer from Python object")
            wrapper._py_buffer_acquired = True
            wrapper._ptr = <chip.hipExternalSemaphoreWaitParams_st_struct_0_struct_1*>wrapper._py_buffer.buf
        else:
            raise TypeError(f"unsupported input type: '{str(type(pyobj))}'")
        return wrapper
    def __dealloc__(self):
        # Release the buffer handle
        if self._py_buffer_acquired is True:
            cpython.buffer.PyBuffer_Release(&self._py_buffer)
        # De-allocate if not null and flag is set
        if self._ptr is not NULL and self.ptr_owner is True:
            stdlib.free(self._ptr)
            self._ptr = NULL
    @staticmethod
    cdef __allocate(chip.hipExternalSemaphoreWaitParams_st_struct_0_struct_1** ptr):
        ptr[0] = <chip.hipExternalSemaphoreWaitParams_st_struct_0_struct_1*>stdlib.malloc(sizeof(chip.hipExternalSemaphoreWaitParams_st_struct_0_struct_1))

        if ptr[0] is NULL:
            raise MemoryError
        # TODO init values, if present

    @staticmethod
    cdef hipExternalSemaphoreWaitParams_st_struct_0_struct_1 new():
        """Factory function to create hipExternalSemaphoreWaitParams_st_struct_0_struct_1 objects with
        newly allocated chip.hipExternalSemaphoreWaitParams_st_struct_0_struct_1"""
        cdef chip.hipExternalSemaphoreWaitParams_st_struct_0_struct_1* ptr
        hipExternalSemaphoreWaitParams_st_struct_0_struct_1.__allocate(&ptr)
        return hipExternalSemaphoreWaitParams_st_struct_0_struct_1.from_ptr(ptr, owner=True)
   
    def __init__(self,*args,**kwargs):
        hipExternalSemaphoreWaitParams_st_struct_0_struct_1.__allocate(&self._ptr)
        self.ptr_owner = True
        attribs = self.PROPERTIES()
        used_attribs = set()
        if len(args) > len(attribs):
            raise ValueError("More positional arguments specified than this type has properties.")
        for i,v in enumerate(args):
            setattr(self,attribs[i],v)
            used_attribs.add(attribs[i])
        valid_names = ", ".join(["'"+p+"'" for p in attribs])
        for k,v in kwargs.items():
            if k in used_attribs:
                raise KeyError(f"argument '{k}' has already been specified as positional argument.")
            elif k not in attribs:
                raise KeyError(f"'{k}' is no valid property name. Valid names: {valid_names}")
            setattr(self,k,v)
    
    def __int__(self):
        """Returns the data's address as long integer."""
        return cpython.long.PyLong_FromVoidPtr(self._ptr)
    def __repr__(self):
        return f"<hipExternalSemaphoreWaitParams_st_struct_0_struct_1 object, self.ptr={int(self)}>"
    def as_c_void_p(self):
        """Returns the data's address as `ctypes.c_void_p`"""
        return ctypes.c_void_p(int(self))
    def get_key(self, i):
        """Get value ``key`` of ``self._ptr[i]``.
        """
        return self._ptr[i].key
    def set_key(self, i, unsigned long long value):
        """Set value ``key`` of ``self._ptr[i]``.
        """
        self._ptr[i].key = value
    @property
    def key(self):
        return self.get_key(0)
    @key.setter
    def key(self, unsigned long long value):
        self.set_key(0,value)

    def get_timeoutMs(self, i):
        """Get value ``timeoutMs`` of ``self._ptr[i]``.
        """
        return self._ptr[i].timeoutMs
    def set_timeoutMs(self, i, unsigned int value):
        """Set value ``timeoutMs`` of ``self._ptr[i]``.
        """
        self._ptr[i].timeoutMs = value
    @property
    def timeoutMs(self):
        return self.get_timeoutMs(0)
    @timeoutMs.setter
    def timeoutMs(self, unsigned int value):
        self.set_timeoutMs(0,value)

    @staticmethod
    def PROPERTIES():
        return ["key","timeoutMs"]

    def __contains__(self,item):
        properties = self.PROPERTIES()
        return item in properties

    def __getitem__(self,item):
        properties = self.PROPERTIES()
        if isinstance(item,int):
            if item < 0 or item >= len(properties):
                raise IndexError()
            return getattr(self,properties[item])
        raise ValueError("'item' type must be 'int'")


cdef class hipExternalSemaphoreWaitParams_st_struct_0:
    # members declared in pxd file

    def __cinit__(self):
        self._ptr = NULL
        self.ptr_owner = False
        self._py_buffer_acquired = False

    @staticmethod
    cdef hipExternalSemaphoreWaitParams_st_struct_0 from_ptr(chip.hipExternalSemaphoreWaitParams_st_struct_0* ptr, bint owner=False):
        """Factory function to create ``hipExternalSemaphoreWaitParams_st_struct_0`` objects from
        given ``chip.hipExternalSemaphoreWaitParams_st_struct_0`` pointer.

        Setting ``owner`` flag to ``True`` causes
        the extension type to ``free`` the structure pointed to by ``ptr``
        when the wrapper object is deallocated.
        """
        # Fast call to __new__() that bypasses the __init__() constructor.
        cdef hipExternalSemaphoreWaitParams_st_struct_0 wrapper = hipExternalSemaphoreWaitParams_st_struct_0.__new__(hipExternalSemaphoreWaitParams_st_struct_0)
        wrapper._ptr = ptr
        wrapper.ptr_owner = owner
        return wrapper

    @staticmethod
    cdef hipExternalSemaphoreWaitParams_st_struct_0 from_pyobj(object pyobj):
        """Derives a hipExternalSemaphoreWaitParams_st_struct_0 from a Python object.

        Derives a hipExternalSemaphoreWaitParams_st_struct_0 from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``hipExternalSemaphoreWaitParams_st_struct_0`` reference, this method
        returns it directly. No new ``hipExternalSemaphoreWaitParams_st_struct_0`` is created in this case.

        Args:
            pyobj (object): Must be either ``None``, a simple, contiguous buffer according to the buffer protocol,
                            or of type ``hipExternalSemaphoreWaitParams_st_struct_0``, ``int``, or ``ctypes.c_void_p``

        Note:
            This routine does not perform a copy but returns the original ``pyobj``
            if ``pyobj`` is an instance of hipExternalSemaphoreWaitParams_st_struct_0!
        """
        cdef hipExternalSemaphoreWaitParams_st_struct_0 wrapper = hipExternalSemaphoreWaitParams_st_struct_0.__new__(hipExternalSemaphoreWaitParams_st_struct_0)
        cdef dict cuda_array_interface = getattr(pyobj, "__cuda_array_interface__", None)

        if pyobj is None:
            wrapper._ptr = NULL
        elif isinstance(pyobj,hipExternalSemaphoreWaitParams_st_struct_0):
            return pyobj
        elif isinstance(pyobj,int):
            wrapper._ptr = <chip.hipExternalSemaphoreWaitParams_st_struct_0*>cpython.long.PyLong_AsVoidPtr(pyobj)
        elif isinstance(pyobj,ctypes.c_void_p):
            wrapper._ptr = <chip.hipExternalSemaphoreWaitParams_st_struct_0*>cpython.long.PyLong_AsVoidPtr(pyobj.value) if pyobj.value != None else NULL
        elif cuda_array_interface != None:
            if not "data" in cuda_array_interface:
                raise ValueError("input object has '__cuda_array_interface__' attribute but the dict has no 'data' key")
            ptr_as_int = cuda_array_interface["data"][0]
            wrapper._ptr = <chip.hipExternalSemaphoreWaitParams_st_struct_0*>cpython.long.PyLong_AsVoidPtr(ptr_as_int)
        elif cpython.buffer.PyObject_CheckBuffer(pyobj):
            err = cpython.buffer.PyObject_GetBuffer( 
                pyobj,
                &wrapper._py_buffer, 
                cpython.buffer.PyBUF_SIMPLE | cpython.buffer.PyBUF_ANY_CONTIGUOUS
            )
            if err == -1:
                raise RuntimeError("failed to create simple, contiguous Py_buffer from Python object")
            wrapper._py_buffer_acquired = True
            wrapper._ptr = <chip.hipExternalSemaphoreWaitParams_st_struct_0*>wrapper._py_buffer.buf
        else:
            raise TypeError(f"unsupported input type: '{str(type(pyobj))}'")
        return wrapper
    def __dealloc__(self):
        # Release the buffer handle
        if self._py_buffer_acquired is True:
            cpython.buffer.PyBuffer_Release(&self._py_buffer)
        # De-allocate if not null and flag is set
        if self._ptr is not NULL and self.ptr_owner is True:
            stdlib.free(self._ptr)
            self._ptr = NULL
    @staticmethod
    cdef __allocate(chip.hipExternalSemaphoreWaitParams_st_struct_0** ptr):
        ptr[0] = <chip.hipExternalSemaphoreWaitParams_st_struct_0*>stdlib.malloc(sizeof(chip.hipExternalSemaphoreWaitParams_st_struct_0))

        if ptr[0] is NULL:
            raise MemoryError
        # TODO init values, if present

    @staticmethod
    cdef hipExternalSemaphoreWaitParams_st_struct_0 new():
        """Factory function to create hipExternalSemaphoreWaitParams_st_struct_0 objects with
        newly allocated chip.hipExternalSemaphoreWaitParams_st_struct_0"""
        cdef chip.hipExternalSemaphoreWaitParams_st_struct_0* ptr
        hipExternalSemaphoreWaitParams_st_struct_0.__allocate(&ptr)
        return hipExternalSemaphoreWaitParams_st_struct_0.from_ptr(ptr, owner=True)
   
    def __init__(self,*args,**kwargs):
        hipExternalSemaphoreWaitParams_st_struct_0.__allocate(&self._ptr)
        self.ptr_owner = True
        attribs = self.PROPERTIES()
        used_attribs = set()
        if len(args) > len(attribs):
            raise ValueError("More positional arguments specified than this type has properties.")
        for i,v in enumerate(args):
            setattr(self,attribs[i],v)
            used_attribs.add(attribs[i])
        valid_names = ", ".join(["'"+p+"'" for p in attribs])
        for k,v in kwargs.items():
            if k in used_attribs:
                raise KeyError(f"argument '{k}' has already been specified as positional argument.")
            elif k not in attribs:
                raise KeyError(f"'{k}' is no valid property name. Valid names: {valid_names}")
            setattr(self,k,v)
    
    def __int__(self):
        """Returns the data's address as long integer."""
        return cpython.long.PyLong_FromVoidPtr(self._ptr)
    def __repr__(self):
        return f"<hipExternalSemaphoreWaitParams_st_struct_0 object, self.ptr={int(self)}>"
    def as_c_void_p(self):
        """Returns the data's address as `ctypes.c_void_p`"""
        return ctypes.c_void_p(int(self))
    def get_fence(self, i):
        """Get value of ``fence`` of ``self._ptr[i]``.
        """
        return hipExternalSemaphoreWaitParams_st_struct_0_struct_0.from_ptr(&self._ptr[i].fence)
    @property
    def fence(self):
        return self.get_fence(0)

    def get_keyedMutex(self, i):
        """Get value of ``keyedMutex`` of ``self._ptr[i]``.
        """
        return hipExternalSemaphoreWaitParams_st_struct_0_struct_1.from_ptr(&self._ptr[i].keyedMutex)
    @property
    def keyedMutex(self):
        return self.get_keyedMutex(0)

    def get_reserved(self, i):
        """Get value of ``reserved`` of ``self._ptr[i]``.
        """
        return self._ptr[i].reserved
    # TODO add setters
    #def set_reserved(self, i, unsigned int[10] value):
    #    """Set value ``reserved`` of ``self._ptr[i]``.
    #    """
    #    self._ptr[i].reserved = value
    @property
    def reserved(self):
        return self.get_reserved(0)
    # TODO add setters
    #@reserved.setter
    #def reserved(self, unsigned int[10] value):
    #    self.set_reserved(0,value)

    @staticmethod
    def PROPERTIES():
        return ["fence","keyedMutex","reserved"]

    def __contains__(self,item):
        properties = self.PROPERTIES()
        return item in properties

    def __getitem__(self,item):
        properties = self.PROPERTIES()
        if isinstance(item,int):
            if item < 0 or item >= len(properties):
                raise IndexError()
            return getattr(self,properties[item])
        raise ValueError("'item' type must be 'int'")


cdef class hipExternalSemaphoreWaitParams_st:
    # members declared in pxd file

    def __cinit__(self):
        self._ptr = NULL
        self.ptr_owner = False
        self._py_buffer_acquired = False

    @staticmethod
    cdef hipExternalSemaphoreWaitParams_st from_ptr(chip.hipExternalSemaphoreWaitParams_st* ptr, bint owner=False):
        """Factory function to create ``hipExternalSemaphoreWaitParams_st`` objects from
        given ``chip.hipExternalSemaphoreWaitParams_st`` pointer.

        Setting ``owner`` flag to ``True`` causes
        the extension type to ``free`` the structure pointed to by ``ptr``
        when the wrapper object is deallocated.
        """
        # Fast call to __new__() that bypasses the __init__() constructor.
        cdef hipExternalSemaphoreWaitParams_st wrapper = hipExternalSemaphoreWaitParams_st.__new__(hipExternalSemaphoreWaitParams_st)
        wrapper._ptr = ptr
        wrapper.ptr_owner = owner
        return wrapper

    @staticmethod
    cdef hipExternalSemaphoreWaitParams_st from_pyobj(object pyobj):
        """Derives a hipExternalSemaphoreWaitParams_st from a Python object.

        Derives a hipExternalSemaphoreWaitParams_st from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``hipExternalSemaphoreWaitParams_st`` reference, this method
        returns it directly. No new ``hipExternalSemaphoreWaitParams_st`` is created in this case.

        Args:
            pyobj (object): Must be either ``None``, a simple, contiguous buffer according to the buffer protocol,
                            or of type ``hipExternalSemaphoreWaitParams_st``, ``int``, or ``ctypes.c_void_p``

        Note:
            This routine does not perform a copy but returns the original ``pyobj``
            if ``pyobj`` is an instance of hipExternalSemaphoreWaitParams_st!
        """
        cdef hipExternalSemaphoreWaitParams_st wrapper = hipExternalSemaphoreWaitParams_st.__new__(hipExternalSemaphoreWaitParams_st)
        cdef dict cuda_array_interface = getattr(pyobj, "__cuda_array_interface__", None)

        if pyobj is None:
            wrapper._ptr = NULL
        elif isinstance(pyobj,hipExternalSemaphoreWaitParams_st):
            return pyobj
        elif isinstance(pyobj,int):
            wrapper._ptr = <chip.hipExternalSemaphoreWaitParams_st*>cpython.long.PyLong_AsVoidPtr(pyobj)
        elif isinstance(pyobj,ctypes.c_void_p):
            wrapper._ptr = <chip.hipExternalSemaphoreWaitParams_st*>cpython.long.PyLong_AsVoidPtr(pyobj.value) if pyobj.value != None else NULL
        elif cuda_array_interface != None:
            if not "data" in cuda_array_interface:
                raise ValueError("input object has '__cuda_array_interface__' attribute but the dict has no 'data' key")
            ptr_as_int = cuda_array_interface["data"][0]
            wrapper._ptr = <chip.hipExternalSemaphoreWaitParams_st*>cpython.long.PyLong_AsVoidPtr(ptr_as_int)
        elif cpython.buffer.PyObject_CheckBuffer(pyobj):
            err = cpython.buffer.PyObject_GetBuffer( 
                pyobj,
                &wrapper._py_buffer, 
                cpython.buffer.PyBUF_SIMPLE | cpython.buffer.PyBUF_ANY_CONTIGUOUS
            )
            if err == -1:
                raise RuntimeError("failed to create simple, contiguous Py_buffer from Python object")
            wrapper._py_buffer_acquired = True
            wrapper._ptr = <chip.hipExternalSemaphoreWaitParams_st*>wrapper._py_buffer.buf
        else:
            raise TypeError(f"unsupported input type: '{str(type(pyobj))}'")
        return wrapper
    def __dealloc__(self):
        # Release the buffer handle
        if self._py_buffer_acquired is True:
            cpython.buffer.PyBuffer_Release(&self._py_buffer)
        # De-allocate if not null and flag is set
        if self._ptr is not NULL and self.ptr_owner is True:
            stdlib.free(self._ptr)
            self._ptr = NULL
    @staticmethod
    cdef __allocate(chip.hipExternalSemaphoreWaitParams_st** ptr):
        ptr[0] = <chip.hipExternalSemaphoreWaitParams_st*>stdlib.malloc(sizeof(chip.hipExternalSemaphoreWaitParams_st))

        if ptr[0] is NULL:
            raise MemoryError
        # TODO init values, if present

    @staticmethod
    cdef hipExternalSemaphoreWaitParams_st new():
        """Factory function to create hipExternalSemaphoreWaitParams_st objects with
        newly allocated chip.hipExternalSemaphoreWaitParams_st"""
        cdef chip.hipExternalSemaphoreWaitParams_st* ptr
        hipExternalSemaphoreWaitParams_st.__allocate(&ptr)
        return hipExternalSemaphoreWaitParams_st.from_ptr(ptr, owner=True)
   
    def __init__(self,*args,**kwargs):
        hipExternalSemaphoreWaitParams_st.__allocate(&self._ptr)
        self.ptr_owner = True
        attribs = self.PROPERTIES()
        used_attribs = set()
        if len(args) > len(attribs):
            raise ValueError("More positional arguments specified than this type has properties.")
        for i,v in enumerate(args):
            setattr(self,attribs[i],v)
            used_attribs.add(attribs[i])
        valid_names = ", ".join(["'"+p+"'" for p in attribs])
        for k,v in kwargs.items():
            if k in used_attribs:
                raise KeyError(f"argument '{k}' has already been specified as positional argument.")
            elif k not in attribs:
                raise KeyError(f"'{k}' is no valid property name. Valid names: {valid_names}")
            setattr(self,k,v)
    
    def __int__(self):
        """Returns the data's address as long integer."""
        return cpython.long.PyLong_FromVoidPtr(self._ptr)
    def __repr__(self):
        return f"<hipExternalSemaphoreWaitParams_st object, self.ptr={int(self)}>"
    def as_c_void_p(self):
        """Returns the data's address as `ctypes.c_void_p`"""
        return ctypes.c_void_p(int(self))
    def get_params(self, i):
        """Get value of ``params`` of ``self._ptr[i]``.
        """
        return hipExternalSemaphoreWaitParams_st_struct_0.from_ptr(&self._ptr[i].params)
    @property
    def params(self):
        return self.get_params(0)

    def get_flags(self, i):
        """Get value ``flags`` of ``self._ptr[i]``.
        """
        return self._ptr[i].flags
    def set_flags(self, i, unsigned int value):
        """Set value ``flags`` of ``self._ptr[i]``.
        """
        self._ptr[i].flags = value
    @property
    def flags(self):
        return self.get_flags(0)
    @flags.setter
    def flags(self, unsigned int value):
        self.set_flags(0,value)

    def get_reserved(self, i):
        """Get value of ``reserved`` of ``self._ptr[i]``.
        """
        return self._ptr[i].reserved
    # TODO add setters
    #def set_reserved(self, i, unsigned int[16] value):
    #    """Set value ``reserved`` of ``self._ptr[i]``.
    #    """
    #    self._ptr[i].reserved = value
    @property
    def reserved(self):
        return self.get_reserved(0)
    # TODO add setters
    #@reserved.setter
    #def reserved(self, unsigned int[16] value):
    #    self.set_reserved(0,value)

    @staticmethod
    def PROPERTIES():
        return ["params","flags","reserved"]

    def __contains__(self,item):
        properties = self.PROPERTIES()
        return item in properties

    def __getitem__(self,item):
        properties = self.PROPERTIES()
        if isinstance(item,int):
            if item < 0 or item >= len(properties):
                raise IndexError()
            return getattr(self,properties[item])
        raise ValueError("'item' type must be 'int'")


hipExternalSemaphoreWaitParams = hipExternalSemaphoreWaitParams_st

class _hipGLDeviceList__Base(enum.IntEnum):
    """Empty enum base class that allows subclassing.
    """
    pass
class hipGLDeviceList(_hipGLDeviceList__Base):
    hipGLDeviceListAll = chip.hipGLDeviceListAll
    hipGLDeviceListCurrentFrame = chip.hipGLDeviceListCurrentFrame
    hipGLDeviceListNextFrame = chip.hipGLDeviceListNextFrame
    @staticmethod
    def ctypes_type():
        """The type of the enum constants as ctypes type."""
        return ctypes.c_uint 


class _hipGraphicsRegisterFlags__Base(enum.IntEnum):
    """Empty enum base class that allows subclassing.
    """
    pass
class hipGraphicsRegisterFlags(_hipGraphicsRegisterFlags__Base):
    hipGraphicsRegisterFlagsNone = chip.hipGraphicsRegisterFlagsNone
    hipGraphicsRegisterFlagsReadOnly = chip.hipGraphicsRegisterFlagsReadOnly
    hipGraphicsRegisterFlagsWriteDiscard = chip.hipGraphicsRegisterFlagsWriteDiscard
    hipGraphicsRegisterFlagsSurfaceLoadStore = chip.hipGraphicsRegisterFlagsSurfaceLoadStore
    hipGraphicsRegisterFlagsTextureGather = chip.hipGraphicsRegisterFlagsTextureGather
    @staticmethod
    def ctypes_type():
        """The type of the enum constants as ctypes type."""
        return ctypes.c_uint 


cdef class _hipGraphicsResource:
    # members declared in pxd file

    def __cinit__(self):
        self._ptr = NULL
        self.ptr_owner = False
        self._py_buffer_acquired = False

    @staticmethod
    cdef _hipGraphicsResource from_ptr(chip._hipGraphicsResource* ptr, bint owner=False):
        """Factory function to create ``_hipGraphicsResource`` objects from
        given ``chip._hipGraphicsResource`` pointer.
        """
        # Fast call to __new__() that bypasses the __init__() constructor.
        cdef _hipGraphicsResource wrapper = _hipGraphicsResource.__new__(_hipGraphicsResource)
        wrapper._ptr = ptr
        wrapper.ptr_owner = owner
        return wrapper

    @staticmethod
    cdef _hipGraphicsResource from_pyobj(object pyobj):
        """Derives a _hipGraphicsResource from a Python object.

        Derives a _hipGraphicsResource from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``_hipGraphicsResource`` reference, this method
        returns it directly. No new ``_hipGraphicsResource`` is created in this case.

        Args:
            pyobj (object): Must be either ``None``, a simple, contiguous buffer according to the buffer protocol,
                            or of type ``_hipGraphicsResource``, ``int``, or ``ctypes.c_void_p``

        Note:
            This routine does not perform a copy but returns the original ``pyobj``
            if ``pyobj`` is an instance of _hipGraphicsResource!
        """
        cdef _hipGraphicsResource wrapper = _hipGraphicsResource.__new__(_hipGraphicsResource)
        cdef dict cuda_array_interface = getattr(pyobj, "__cuda_array_interface__", None)

        if pyobj is None:
            wrapper._ptr = NULL
        elif isinstance(pyobj,_hipGraphicsResource):
            return pyobj
        elif isinstance(pyobj,int):
            wrapper._ptr = <chip._hipGraphicsResource*>cpython.long.PyLong_AsVoidPtr(pyobj)
        elif isinstance(pyobj,ctypes.c_void_p):
            wrapper._ptr = <chip._hipGraphicsResource*>cpython.long.PyLong_AsVoidPtr(pyobj.value) if pyobj.value != None else NULL
        elif cuda_array_interface != None:
            if not "data" in cuda_array_interface:
                raise ValueError("input object has '__cuda_array_interface__' attribute but the dict has no 'data' key")
            ptr_as_int = cuda_array_interface["data"][0]
            wrapper._ptr = <chip._hipGraphicsResource*>cpython.long.PyLong_AsVoidPtr(ptr_as_int)
        elif cpython.buffer.PyObject_CheckBuffer(pyobj):
            err = cpython.buffer.PyObject_GetBuffer( 
                pyobj,
                &wrapper._py_buffer, 
                cpython.buffer.PyBUF_SIMPLE | cpython.buffer.PyBUF_ANY_CONTIGUOUS
            )
            if err == -1:
                raise RuntimeError("failed to create simple, contiguous Py_buffer from Python object")
            wrapper._py_buffer_acquired = True
            wrapper._ptr = <chip._hipGraphicsResource*>wrapper._py_buffer.buf
        else:
            raise TypeError(f"unsupported input type: '{str(type(pyobj))}'")
        return wrapper
    def __dealloc__(self):
        # Release the buffer handle
        if self._py_buffer_acquired is True:
            cpython.buffer.PyBuffer_Release(&self._py_buffer)
    
    def __int__(self):
        """Returns the data's address as long integer."""
        return cpython.long.PyLong_FromVoidPtr(self._ptr)
    def __repr__(self):
        return f"<_hipGraphicsResource object, self.ptr={int(self)}>"
    def as_c_void_p(self):
        """Returns the data's address as `ctypes.c_void_p`"""
        return ctypes.c_void_p(int(self))
    @staticmethod
    def PROPERTIES():
        return []

    def __contains__(self,item):
        properties = self.PROPERTIES()
        return item in properties

    def __getitem__(self,item):
        properties = self.PROPERTIES()
        if isinstance(item,int):
            if item < 0 or item >= len(properties):
                raise IndexError()
            return getattr(self,properties[item])
        raise ValueError("'item' type must be 'int'")


hipGraphicsResource = _hipGraphicsResource

hipGraphicsResource_t = _hipGraphicsResource

cdef class ihipGraph:
    # members declared in pxd file

    def __cinit__(self):
        self._ptr = NULL
        self.ptr_owner = False
        self._py_buffer_acquired = False

    @staticmethod
    cdef ihipGraph from_ptr(chip.ihipGraph* ptr, bint owner=False):
        """Factory function to create ``ihipGraph`` objects from
        given ``chip.ihipGraph`` pointer.
        """
        # Fast call to __new__() that bypasses the __init__() constructor.
        cdef ihipGraph wrapper = ihipGraph.__new__(ihipGraph)
        wrapper._ptr = ptr
        wrapper.ptr_owner = owner
        return wrapper

    @staticmethod
    cdef ihipGraph from_pyobj(object pyobj):
        """Derives a ihipGraph from a Python object.

        Derives a ihipGraph from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``ihipGraph`` reference, this method
        returns it directly. No new ``ihipGraph`` is created in this case.

        Args:
            pyobj (object): Must be either ``None``, a simple, contiguous buffer according to the buffer protocol,
                            or of type ``ihipGraph``, ``int``, or ``ctypes.c_void_p``

        Note:
            This routine does not perform a copy but returns the original ``pyobj``
            if ``pyobj`` is an instance of ihipGraph!
        """
        cdef ihipGraph wrapper = ihipGraph.__new__(ihipGraph)
        cdef dict cuda_array_interface = getattr(pyobj, "__cuda_array_interface__", None)

        if pyobj is None:
            wrapper._ptr = NULL
        elif isinstance(pyobj,ihipGraph):
            return pyobj
        elif isinstance(pyobj,int):
            wrapper._ptr = <chip.ihipGraph*>cpython.long.PyLong_AsVoidPtr(pyobj)
        elif isinstance(pyobj,ctypes.c_void_p):
            wrapper._ptr = <chip.ihipGraph*>cpython.long.PyLong_AsVoidPtr(pyobj.value) if pyobj.value != None else NULL
        elif cuda_array_interface != None:
            if not "data" in cuda_array_interface:
                raise ValueError("input object has '__cuda_array_interface__' attribute but the dict has no 'data' key")
            ptr_as_int = cuda_array_interface["data"][0]
            wrapper._ptr = <chip.ihipGraph*>cpython.long.PyLong_AsVoidPtr(ptr_as_int)
        elif cpython.buffer.PyObject_CheckBuffer(pyobj):
            err = cpython.buffer.PyObject_GetBuffer( 
                pyobj,
                &wrapper._py_buffer, 
                cpython.buffer.PyBUF_SIMPLE | cpython.buffer.PyBUF_ANY_CONTIGUOUS
            )
            if err == -1:
                raise RuntimeError("failed to create simple, contiguous Py_buffer from Python object")
            wrapper._py_buffer_acquired = True
            wrapper._ptr = <chip.ihipGraph*>wrapper._py_buffer.buf
        else:
            raise TypeError(f"unsupported input type: '{str(type(pyobj))}'")
        return wrapper
    def __dealloc__(self):
        # Release the buffer handle
        if self._py_buffer_acquired is True:
            cpython.buffer.PyBuffer_Release(&self._py_buffer)
    
    def __int__(self):
        """Returns the data's address as long integer."""
        return cpython.long.PyLong_FromVoidPtr(self._ptr)
    def __repr__(self):
        return f"<ihipGraph object, self.ptr={int(self)}>"
    def as_c_void_p(self):
        """Returns the data's address as `ctypes.c_void_p`"""
        return ctypes.c_void_p(int(self))
    @staticmethod
    def PROPERTIES():
        return []

    def __contains__(self,item):
        properties = self.PROPERTIES()
        return item in properties

    def __getitem__(self,item):
        properties = self.PROPERTIES()
        if isinstance(item,int):
            if item < 0 or item >= len(properties):
                raise IndexError()
            return getattr(self,properties[item])
        raise ValueError("'item' type must be 'int'")


hipGraph_t = ihipGraph

cdef class hipGraphNode:
    # members declared in pxd file

    def __cinit__(self):
        self._ptr = NULL
        self.ptr_owner = False
        self._py_buffer_acquired = False

    @staticmethod
    cdef hipGraphNode from_ptr(chip.hipGraphNode* ptr, bint owner=False):
        """Factory function to create ``hipGraphNode`` objects from
        given ``chip.hipGraphNode`` pointer.
        """
        # Fast call to __new__() that bypasses the __init__() constructor.
        cdef hipGraphNode wrapper = hipGraphNode.__new__(hipGraphNode)
        wrapper._ptr = ptr
        wrapper.ptr_owner = owner
        return wrapper

    @staticmethod
    cdef hipGraphNode from_pyobj(object pyobj):
        """Derives a hipGraphNode from a Python object.

        Derives a hipGraphNode from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``hipGraphNode`` reference, this method
        returns it directly. No new ``hipGraphNode`` is created in this case.

        Args:
            pyobj (object): Must be either ``None``, a simple, contiguous buffer according to the buffer protocol,
                            or of type ``hipGraphNode``, ``int``, or ``ctypes.c_void_p``

        Note:
            This routine does not perform a copy but returns the original ``pyobj``
            if ``pyobj`` is an instance of hipGraphNode!
        """
        cdef hipGraphNode wrapper = hipGraphNode.__new__(hipGraphNode)
        cdef dict cuda_array_interface = getattr(pyobj, "__cuda_array_interface__", None)

        if pyobj is None:
            wrapper._ptr = NULL
        elif isinstance(pyobj,hipGraphNode):
            return pyobj
        elif isinstance(pyobj,int):
            wrapper._ptr = <chip.hipGraphNode*>cpython.long.PyLong_AsVoidPtr(pyobj)
        elif isinstance(pyobj,ctypes.c_void_p):
            wrapper._ptr = <chip.hipGraphNode*>cpython.long.PyLong_AsVoidPtr(pyobj.value) if pyobj.value != None else NULL
        elif cuda_array_interface != None:
            if not "data" in cuda_array_interface:
                raise ValueError("input object has '__cuda_array_interface__' attribute but the dict has no 'data' key")
            ptr_as_int = cuda_array_interface["data"][0]
            wrapper._ptr = <chip.hipGraphNode*>cpython.long.PyLong_AsVoidPtr(ptr_as_int)
        elif cpython.buffer.PyObject_CheckBuffer(pyobj):
            err = cpython.buffer.PyObject_GetBuffer( 
                pyobj,
                &wrapper._py_buffer, 
                cpython.buffer.PyBUF_SIMPLE | cpython.buffer.PyBUF_ANY_CONTIGUOUS
            )
            if err == -1:
                raise RuntimeError("failed to create simple, contiguous Py_buffer from Python object")
            wrapper._py_buffer_acquired = True
            wrapper._ptr = <chip.hipGraphNode*>wrapper._py_buffer.buf
        else:
            raise TypeError(f"unsupported input type: '{str(type(pyobj))}'")
        return wrapper
    def __dealloc__(self):
        # Release the buffer handle
        if self._py_buffer_acquired is True:
            cpython.buffer.PyBuffer_Release(&self._py_buffer)
    
    def __int__(self):
        """Returns the data's address as long integer."""
        return cpython.long.PyLong_FromVoidPtr(self._ptr)
    def __repr__(self):
        return f"<hipGraphNode object, self.ptr={int(self)}>"
    def as_c_void_p(self):
        """Returns the data's address as `ctypes.c_void_p`"""
        return ctypes.c_void_p(int(self))
    @staticmethod
    def PROPERTIES():
        return []

    def __contains__(self,item):
        properties = self.PROPERTIES()
        return item in properties

    def __getitem__(self,item):
        properties = self.PROPERTIES()
        if isinstance(item,int):
            if item < 0 or item >= len(properties):
                raise IndexError()
            return getattr(self,properties[item])
        raise ValueError("'item' type must be 'int'")


hipGraphNode_t = hipGraphNode

cdef class hipGraphExec:
    # members declared in pxd file

    def __cinit__(self):
        self._ptr = NULL
        self.ptr_owner = False
        self._py_buffer_acquired = False

    @staticmethod
    cdef hipGraphExec from_ptr(chip.hipGraphExec* ptr, bint owner=False):
        """Factory function to create ``hipGraphExec`` objects from
        given ``chip.hipGraphExec`` pointer.
        """
        # Fast call to __new__() that bypasses the __init__() constructor.
        cdef hipGraphExec wrapper = hipGraphExec.__new__(hipGraphExec)
        wrapper._ptr = ptr
        wrapper.ptr_owner = owner
        return wrapper

    @staticmethod
    cdef hipGraphExec from_pyobj(object pyobj):
        """Derives a hipGraphExec from a Python object.

        Derives a hipGraphExec from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``hipGraphExec`` reference, this method
        returns it directly. No new ``hipGraphExec`` is created in this case.

        Args:
            pyobj (object): Must be either ``None``, a simple, contiguous buffer according to the buffer protocol,
                            or of type ``hipGraphExec``, ``int``, or ``ctypes.c_void_p``

        Note:
            This routine does not perform a copy but returns the original ``pyobj``
            if ``pyobj`` is an instance of hipGraphExec!
        """
        cdef hipGraphExec wrapper = hipGraphExec.__new__(hipGraphExec)
        cdef dict cuda_array_interface = getattr(pyobj, "__cuda_array_interface__", None)

        if pyobj is None:
            wrapper._ptr = NULL
        elif isinstance(pyobj,hipGraphExec):
            return pyobj
        elif isinstance(pyobj,int):
            wrapper._ptr = <chip.hipGraphExec*>cpython.long.PyLong_AsVoidPtr(pyobj)
        elif isinstance(pyobj,ctypes.c_void_p):
            wrapper._ptr = <chip.hipGraphExec*>cpython.long.PyLong_AsVoidPtr(pyobj.value) if pyobj.value != None else NULL
        elif cuda_array_interface != None:
            if not "data" in cuda_array_interface:
                raise ValueError("input object has '__cuda_array_interface__' attribute but the dict has no 'data' key")
            ptr_as_int = cuda_array_interface["data"][0]
            wrapper._ptr = <chip.hipGraphExec*>cpython.long.PyLong_AsVoidPtr(ptr_as_int)
        elif cpython.buffer.PyObject_CheckBuffer(pyobj):
            err = cpython.buffer.PyObject_GetBuffer( 
                pyobj,
                &wrapper._py_buffer, 
                cpython.buffer.PyBUF_SIMPLE | cpython.buffer.PyBUF_ANY_CONTIGUOUS
            )
            if err == -1:
                raise RuntimeError("failed to create simple, contiguous Py_buffer from Python object")
            wrapper._py_buffer_acquired = True
            wrapper._ptr = <chip.hipGraphExec*>wrapper._py_buffer.buf
        else:
            raise TypeError(f"unsupported input type: '{str(type(pyobj))}'")
        return wrapper
    def __dealloc__(self):
        # Release the buffer handle
        if self._py_buffer_acquired is True:
            cpython.buffer.PyBuffer_Release(&self._py_buffer)
    
    def __int__(self):
        """Returns the data's address as long integer."""
        return cpython.long.PyLong_FromVoidPtr(self._ptr)
    def __repr__(self):
        return f"<hipGraphExec object, self.ptr={int(self)}>"
    def as_c_void_p(self):
        """Returns the data's address as `ctypes.c_void_p`"""
        return ctypes.c_void_p(int(self))
    @staticmethod
    def PROPERTIES():
        return []

    def __contains__(self,item):
        properties = self.PROPERTIES()
        return item in properties

    def __getitem__(self,item):
        properties = self.PROPERTIES()
        if isinstance(item,int):
            if item < 0 or item >= len(properties):
                raise IndexError()
            return getattr(self,properties[item])
        raise ValueError("'item' type must be 'int'")


hipGraphExec_t = hipGraphExec

cdef class hipUserObject:
    # members declared in pxd file

    def __cinit__(self):
        self._ptr = NULL
        self.ptr_owner = False
        self._py_buffer_acquired = False

    @staticmethod
    cdef hipUserObject from_ptr(chip.hipUserObject* ptr, bint owner=False):
        """Factory function to create ``hipUserObject`` objects from
        given ``chip.hipUserObject`` pointer.
        """
        # Fast call to __new__() that bypasses the __init__() constructor.
        cdef hipUserObject wrapper = hipUserObject.__new__(hipUserObject)
        wrapper._ptr = ptr
        wrapper.ptr_owner = owner
        return wrapper

    @staticmethod
    cdef hipUserObject from_pyobj(object pyobj):
        """Derives a hipUserObject from a Python object.

        Derives a hipUserObject from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``hipUserObject`` reference, this method
        returns it directly. No new ``hipUserObject`` is created in this case.

        Args:
            pyobj (object): Must be either ``None``, a simple, contiguous buffer according to the buffer protocol,
                            or of type ``hipUserObject``, ``int``, or ``ctypes.c_void_p``

        Note:
            This routine does not perform a copy but returns the original ``pyobj``
            if ``pyobj`` is an instance of hipUserObject!
        """
        cdef hipUserObject wrapper = hipUserObject.__new__(hipUserObject)
        cdef dict cuda_array_interface = getattr(pyobj, "__cuda_array_interface__", None)

        if pyobj is None:
            wrapper._ptr = NULL
        elif isinstance(pyobj,hipUserObject):
            return pyobj
        elif isinstance(pyobj,int):
            wrapper._ptr = <chip.hipUserObject*>cpython.long.PyLong_AsVoidPtr(pyobj)
        elif isinstance(pyobj,ctypes.c_void_p):
            wrapper._ptr = <chip.hipUserObject*>cpython.long.PyLong_AsVoidPtr(pyobj.value) if pyobj.value != None else NULL
        elif cuda_array_interface != None:
            if not "data" in cuda_array_interface:
                raise ValueError("input object has '__cuda_array_interface__' attribute but the dict has no 'data' key")
            ptr_as_int = cuda_array_interface["data"][0]
            wrapper._ptr = <chip.hipUserObject*>cpython.long.PyLong_AsVoidPtr(ptr_as_int)
        elif cpython.buffer.PyObject_CheckBuffer(pyobj):
            err = cpython.buffer.PyObject_GetBuffer( 
                pyobj,
                &wrapper._py_buffer, 
                cpython.buffer.PyBUF_SIMPLE | cpython.buffer.PyBUF_ANY_CONTIGUOUS
            )
            if err == -1:
                raise RuntimeError("failed to create simple, contiguous Py_buffer from Python object")
            wrapper._py_buffer_acquired = True
            wrapper._ptr = <chip.hipUserObject*>wrapper._py_buffer.buf
        else:
            raise TypeError(f"unsupported input type: '{str(type(pyobj))}'")
        return wrapper
    def __dealloc__(self):
        # Release the buffer handle
        if self._py_buffer_acquired is True:
            cpython.buffer.PyBuffer_Release(&self._py_buffer)
    
    def __int__(self):
        """Returns the data's address as long integer."""
        return cpython.long.PyLong_FromVoidPtr(self._ptr)
    def __repr__(self):
        return f"<hipUserObject object, self.ptr={int(self)}>"
    def as_c_void_p(self):
        """Returns the data's address as `ctypes.c_void_p`"""
        return ctypes.c_void_p(int(self))
    @staticmethod
    def PROPERTIES():
        return []

    def __contains__(self,item):
        properties = self.PROPERTIES()
        return item in properties

    def __getitem__(self,item):
        properties = self.PROPERTIES()
        if isinstance(item,int):
            if item < 0 or item >= len(properties):
                raise IndexError()
            return getattr(self,properties[item])
        raise ValueError("'item' type must be 'int'")


hipUserObject_t = hipUserObject

class _hipGraphNodeType__Base(enum.IntEnum):
    """Empty enum base class that allows subclassing.
    """
    pass
class hipGraphNodeType(_hipGraphNodeType__Base):
    hipGraphNodeTypeKernel = chip.hipGraphNodeTypeKernel
    hipGraphNodeTypeMemcpy = chip.hipGraphNodeTypeMemcpy
    hipGraphNodeTypeMemset = chip.hipGraphNodeTypeMemset
    hipGraphNodeTypeHost = chip.hipGraphNodeTypeHost
    hipGraphNodeTypeGraph = chip.hipGraphNodeTypeGraph
    hipGraphNodeTypeEmpty = chip.hipGraphNodeTypeEmpty
    hipGraphNodeTypeWaitEvent = chip.hipGraphNodeTypeWaitEvent
    hipGraphNodeTypeEventRecord = chip.hipGraphNodeTypeEventRecord
    hipGraphNodeTypeExtSemaphoreSignal = chip.hipGraphNodeTypeExtSemaphoreSignal
    hipGraphNodeTypeExtSemaphoreWait = chip.hipGraphNodeTypeExtSemaphoreWait
    hipGraphNodeTypeMemcpyFromSymbol = chip.hipGraphNodeTypeMemcpyFromSymbol
    hipGraphNodeTypeMemcpyToSymbol = chip.hipGraphNodeTypeMemcpyToSymbol
    hipGraphNodeTypeCount = chip.hipGraphNodeTypeCount
    @staticmethod
    def ctypes_type():
        """The type of the enum constants as ctypes type."""
        return ctypes.c_uint 


cdef class hipHostFn_t:
    # members declared in pxd file

    def __cinit__(self):
        self._ptr = NULL
        self.ptr_owner = False
        self._py_buffer_acquired = False

    @staticmethod
    cdef hipHostFn_t from_ptr(chip.hipHostFn_t ptr, bint owner=False):
        """Factory function to create ``hipHostFn_t`` objects from
        given ``chip.hipHostFn_t`` pointer.
        """
        # Fast call to __new__() that bypasses the __init__() constructor.
        cdef hipHostFn_t wrapper = hipHostFn_t.__new__(hipHostFn_t)
        wrapper._ptr = ptr
        wrapper.ptr_owner = owner
        return wrapper

    @staticmethod
    cdef hipHostFn_t from_pyobj(object pyobj):
        """Derives a hipHostFn_t from a Python object.

        Derives a hipHostFn_t from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``hipHostFn_t`` reference, this method
        returns it directly. No new ``hipHostFn_t`` is created in this case.

        Args:
            pyobj (object): Must be either ``None``, a simple, contiguous buffer according to the buffer protocol,
                            or of type ``hipHostFn_t``, ``int``, or ``ctypes.c_void_p``

        Note:
            This routine does not perform a copy but returns the original ``pyobj``
            if ``pyobj`` is an instance of hipHostFn_t!
        """
        cdef hipHostFn_t wrapper = hipHostFn_t.__new__(hipHostFn_t)
        cdef dict cuda_array_interface = getattr(pyobj, "__cuda_array_interface__", None)

        if pyobj is None:
            wrapper._ptr = NULL
        elif isinstance(pyobj,hipHostFn_t):
            return pyobj
        elif isinstance(pyobj,int):
            wrapper._ptr = <chip.hipHostFn_t>cpython.long.PyLong_AsVoidPtr(pyobj)
        elif isinstance(pyobj,ctypes.c_void_p):
            wrapper._ptr = <chip.hipHostFn_t>cpython.long.PyLong_AsVoidPtr(pyobj.value) if pyobj.value != None else NULL
        elif str(type(pyobj)).startswith("<class 'ctypes.CFUNCTYPE.") and str(type(pyobj)).endswith(".CFunctionType'>" ):
            wrapper._ptr = <chip.hipHostFn_t>cpython.long.PyLong_AsVoidPtr(ctypes.cast(pyobj, ctypes.c_void_p).value)
        else:
            raise TypeError(f"unsupported input type: '{str(type(pyobj))}'")
        return wrapper
    def __dealloc__(self):
        # Release the buffer handle
        if self._py_buffer_acquired is True:
            cpython.buffer.PyBuffer_Release(&self._py_buffer)
    
    def __int__(self):
        """Returns the data's address as long integer."""
        return cpython.long.PyLong_FromVoidPtr(self._ptr)
    def __repr__(self):
        return f"<hipHostFn_t object, self.ptr={int(self)}>"
    def as_c_void_p(self):
        """Returns the data's address as `ctypes.c_void_p`"""
        return ctypes.c_void_p(int(self))


cdef class hipHostNodeParams:
    # members declared in pxd file

    def __cinit__(self):
        self._ptr = NULL
        self.ptr_owner = False
        self._py_buffer_acquired = False

    @staticmethod
    cdef hipHostNodeParams from_ptr(chip.hipHostNodeParams* ptr, bint owner=False):
        """Factory function to create ``hipHostNodeParams`` objects from
        given ``chip.hipHostNodeParams`` pointer.

        Setting ``owner`` flag to ``True`` causes
        the extension type to ``free`` the structure pointed to by ``ptr``
        when the wrapper object is deallocated.
        """
        # Fast call to __new__() that bypasses the __init__() constructor.
        cdef hipHostNodeParams wrapper = hipHostNodeParams.__new__(hipHostNodeParams)
        wrapper._ptr = ptr
        wrapper.ptr_owner = owner
        return wrapper

    @staticmethod
    cdef hipHostNodeParams from_pyobj(object pyobj):
        """Derives a hipHostNodeParams from a Python object.

        Derives a hipHostNodeParams from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``hipHostNodeParams`` reference, this method
        returns it directly. No new ``hipHostNodeParams`` is created in this case.

        Args:
            pyobj (object): Must be either ``None``, a simple, contiguous buffer according to the buffer protocol,
                            or of type ``hipHostNodeParams``, ``int``, or ``ctypes.c_void_p``

        Note:
            This routine does not perform a copy but returns the original ``pyobj``
            if ``pyobj`` is an instance of hipHostNodeParams!
        """
        cdef hipHostNodeParams wrapper = hipHostNodeParams.__new__(hipHostNodeParams)
        cdef dict cuda_array_interface = getattr(pyobj, "__cuda_array_interface__", None)

        if pyobj is None:
            wrapper._ptr = NULL
        elif isinstance(pyobj,hipHostNodeParams):
            return pyobj
        elif isinstance(pyobj,int):
            wrapper._ptr = <chip.hipHostNodeParams*>cpython.long.PyLong_AsVoidPtr(pyobj)
        elif isinstance(pyobj,ctypes.c_void_p):
            wrapper._ptr = <chip.hipHostNodeParams*>cpython.long.PyLong_AsVoidPtr(pyobj.value) if pyobj.value != None else NULL
        elif cuda_array_interface != None:
            if not "data" in cuda_array_interface:
                raise ValueError("input object has '__cuda_array_interface__' attribute but the dict has no 'data' key")
            ptr_as_int = cuda_array_interface["data"][0]
            wrapper._ptr = <chip.hipHostNodeParams*>cpython.long.PyLong_AsVoidPtr(ptr_as_int)
        elif cpython.buffer.PyObject_CheckBuffer(pyobj):
            err = cpython.buffer.PyObject_GetBuffer( 
                pyobj,
                &wrapper._py_buffer, 
                cpython.buffer.PyBUF_SIMPLE | cpython.buffer.PyBUF_ANY_CONTIGUOUS
            )
            if err == -1:
                raise RuntimeError("failed to create simple, contiguous Py_buffer from Python object")
            wrapper._py_buffer_acquired = True
            wrapper._ptr = <chip.hipHostNodeParams*>wrapper._py_buffer.buf
        else:
            raise TypeError(f"unsupported input type: '{str(type(pyobj))}'")
        return wrapper
    def __dealloc__(self):
        # Release the buffer handle
        if self._py_buffer_acquired is True:
            cpython.buffer.PyBuffer_Release(&self._py_buffer)
        # De-allocate if not null and flag is set
        if self._ptr is not NULL and self.ptr_owner is True:
            stdlib.free(self._ptr)
            self._ptr = NULL
    @staticmethod
    cdef __allocate(chip.hipHostNodeParams** ptr):
        ptr[0] = <chip.hipHostNodeParams*>stdlib.malloc(sizeof(chip.hipHostNodeParams))

        if ptr[0] is NULL:
            raise MemoryError
        # TODO init values, if present

    @staticmethod
    cdef hipHostNodeParams new():
        """Factory function to create hipHostNodeParams objects with
        newly allocated chip.hipHostNodeParams"""
        cdef chip.hipHostNodeParams* ptr
        hipHostNodeParams.__allocate(&ptr)
        return hipHostNodeParams.from_ptr(ptr, owner=True)
   
    # False
    # False
    def __init__(self,**kwargs):
        hipHostNodeParams.__allocate(&self._ptr)
        self.ptr_owner = True
        attribs = self.PROPERTIES()
        used_attribs = set()
        valid_names = ", ".join(["'"+p+"'" for p in attribs])
        for k,v in kwargs.items():
            if k in used_attribs:
                raise KeyError(f"argument '{k}' has already been specified as positional argument.")
            elif k not in attribs:
                raise KeyError(f"'{k}' is no valid property name. Valid names: {valid_names}")
            setattr(self,k,v)
    
    def __int__(self):
        """Returns the data's address as long integer."""
        return cpython.long.PyLong_FromVoidPtr(self._ptr)
    def __repr__(self):
        return f"<hipHostNodeParams object, self.ptr={int(self)}>"
    def as_c_void_p(self):
        """Returns the data's address as `ctypes.c_void_p`"""
        return ctypes.c_void_p(int(self))
    def get_userData(self, i):
        """Get value ``userData`` of ``self._ptr[i]``.
        """
        return hip._util.types.DataHandle.from_ptr(self._ptr[i].userData)
    def set_userData(self, i, object value):
        """Set value ``userData`` of ``self._ptr[i]``.

        Note:
            This can be dangerous if the pointer is from a python object
            that is later on garbage collected.
        """
        self._ptr[i].userData = <void *>cpython.long.PyLong_AsVoidPtr(int(hip._util.types.DataHandle.from_pyobj(value)))
    @property
    def userData(self):
        """
        Note:
            Setting this userData can be dangerous if the underlying pointer is from a python object that
            is later on garbage collected.
        """
        return self.get_userData(0)
    @userData.setter
    def userData(self, object value):
        self.set_userData(0,value)

    @staticmethod
    def PROPERTIES():
        return ["userData"]

    def __contains__(self,item):
        properties = self.PROPERTIES()
        return item in properties

    def __getitem__(self,item):
        properties = self.PROPERTIES()
        if isinstance(item,int):
            if item < 0 or item >= len(properties):
                raise IndexError()
            return getattr(self,properties[item])
        raise ValueError("'item' type must be 'int'")


cdef class hipKernelNodeParams:
    # members declared in pxd file

    def __cinit__(self):
        self._ptr = NULL
        self.ptr_owner = False
        self._py_buffer_acquired = False

    @staticmethod
    cdef hipKernelNodeParams from_ptr(chip.hipKernelNodeParams* ptr, bint owner=False):
        """Factory function to create ``hipKernelNodeParams`` objects from
        given ``chip.hipKernelNodeParams`` pointer.

        Setting ``owner`` flag to ``True`` causes
        the extension type to ``free`` the structure pointed to by ``ptr``
        when the wrapper object is deallocated.
        """
        # Fast call to __new__() that bypasses the __init__() constructor.
        cdef hipKernelNodeParams wrapper = hipKernelNodeParams.__new__(hipKernelNodeParams)
        wrapper._ptr = ptr
        wrapper.ptr_owner = owner
        return wrapper

    @staticmethod
    cdef hipKernelNodeParams from_pyobj(object pyobj):
        """Derives a hipKernelNodeParams from a Python object.

        Derives a hipKernelNodeParams from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``hipKernelNodeParams`` reference, this method
        returns it directly. No new ``hipKernelNodeParams`` is created in this case.

        Args:
            pyobj (object): Must be either ``None``, a simple, contiguous buffer according to the buffer protocol,
                            or of type ``hipKernelNodeParams``, ``int``, or ``ctypes.c_void_p``

        Note:
            This routine does not perform a copy but returns the original ``pyobj``
            if ``pyobj`` is an instance of hipKernelNodeParams!
        """
        cdef hipKernelNodeParams wrapper = hipKernelNodeParams.__new__(hipKernelNodeParams)
        cdef dict cuda_array_interface = getattr(pyobj, "__cuda_array_interface__", None)

        if pyobj is None:
            wrapper._ptr = NULL
        elif isinstance(pyobj,hipKernelNodeParams):
            return pyobj
        elif isinstance(pyobj,int):
            wrapper._ptr = <chip.hipKernelNodeParams*>cpython.long.PyLong_AsVoidPtr(pyobj)
        elif isinstance(pyobj,ctypes.c_void_p):
            wrapper._ptr = <chip.hipKernelNodeParams*>cpython.long.PyLong_AsVoidPtr(pyobj.value) if pyobj.value != None else NULL
        elif cuda_array_interface != None:
            if not "data" in cuda_array_interface:
                raise ValueError("input object has '__cuda_array_interface__' attribute but the dict has no 'data' key")
            ptr_as_int = cuda_array_interface["data"][0]
            wrapper._ptr = <chip.hipKernelNodeParams*>cpython.long.PyLong_AsVoidPtr(ptr_as_int)
        elif cpython.buffer.PyObject_CheckBuffer(pyobj):
            err = cpython.buffer.PyObject_GetBuffer( 
                pyobj,
                &wrapper._py_buffer, 
                cpython.buffer.PyBUF_SIMPLE | cpython.buffer.PyBUF_ANY_CONTIGUOUS
            )
            if err == -1:
                raise RuntimeError("failed to create simple, contiguous Py_buffer from Python object")
            wrapper._py_buffer_acquired = True
            wrapper._ptr = <chip.hipKernelNodeParams*>wrapper._py_buffer.buf
        else:
            raise TypeError(f"unsupported input type: '{str(type(pyobj))}'")
        return wrapper
    def __dealloc__(self):
        # Release the buffer handle
        if self._py_buffer_acquired is True:
            cpython.buffer.PyBuffer_Release(&self._py_buffer)
        # De-allocate if not null and flag is set
        if self._ptr is not NULL and self.ptr_owner is True:
            stdlib.free(self._ptr)
            self._ptr = NULL
    @staticmethod
    cdef __allocate(chip.hipKernelNodeParams** ptr):
        ptr[0] = <chip.hipKernelNodeParams*>stdlib.malloc(sizeof(chip.hipKernelNodeParams))

        if ptr[0] is NULL:
            raise MemoryError
        # TODO init values, if present

    @staticmethod
    cdef hipKernelNodeParams new():
        """Factory function to create hipKernelNodeParams objects with
        newly allocated chip.hipKernelNodeParams"""
        cdef chip.hipKernelNodeParams* ptr
        hipKernelNodeParams.__allocate(&ptr)
        return hipKernelNodeParams.from_ptr(ptr, owner=True)
   
    def __init__(self,*args,**kwargs):
        hipKernelNodeParams.__allocate(&self._ptr)
        self.ptr_owner = True
        attribs = self.PROPERTIES()
        used_attribs = set()
        if len(args) > len(attribs):
            raise ValueError("More positional arguments specified than this type has properties.")
        for i,v in enumerate(args):
            setattr(self,attribs[i],v)
            used_attribs.add(attribs[i])
        valid_names = ", ".join(["'"+p+"'" for p in attribs])
        for k,v in kwargs.items():
            if k in used_attribs:
                raise KeyError(f"argument '{k}' has already been specified as positional argument.")
            elif k not in attribs:
                raise KeyError(f"'{k}' is no valid property name. Valid names: {valid_names}")
            setattr(self,k,v)
    
    def __int__(self):
        """Returns the data's address as long integer."""
        return cpython.long.PyLong_FromVoidPtr(self._ptr)
    def __repr__(self):
        return f"<hipKernelNodeParams object, self.ptr={int(self)}>"
    def as_c_void_p(self):
        """Returns the data's address as `ctypes.c_void_p`"""
        return ctypes.c_void_p(int(self))
    def get_blockDim(self, i):
        """Get value of ``blockDim`` of ``self._ptr[i]``.
        """
        return dim3.from_ptr(&self._ptr[i].blockDim)
    @property
    def blockDim(self):
        return self.get_blockDim(0)

    def get_extra(self, i):
        """Get value ``extra`` of ``self._ptr[i]``.
        """
        return hip._util.types.DataHandle.from_ptr(self._ptr[i].extra)
    def set_extra(self, i, object value):
        """Set value ``extra`` of ``self._ptr[i]``.

        Note:
            This can be dangerous if the pointer is from a python object
            that is later on garbage collected.
        """
        self._ptr[i].extra = <void **>cpython.long.PyLong_AsVoidPtr(int(hip._util.types.DataHandle.from_pyobj(value)))
    @property
    def extra(self):
        """
        Note:
            Setting this extra can be dangerous if the underlying pointer is from a python object that
            is later on garbage collected.
        """
        return self.get_extra(0)
    @extra.setter
    def extra(self, object value):
        self.set_extra(0,value)

    def get_func(self, i):
        """Get value ``func`` of ``self._ptr[i]``.
        """
        return hip._util.types.DataHandle.from_ptr(self._ptr[i].func)
    def set_func(self, i, object value):
        """Set value ``func`` of ``self._ptr[i]``.

        Note:
            This can be dangerous if the pointer is from a python object
            that is later on garbage collected.
        """
        self._ptr[i].func = <void *>cpython.long.PyLong_AsVoidPtr(int(hip._util.types.DataHandle.from_pyobj(value)))
    @property
    def func(self):
        """
        Note:
            Setting this func can be dangerous if the underlying pointer is from a python object that
            is later on garbage collected.
        """
        return self.get_func(0)
    @func.setter
    def func(self, object value):
        self.set_func(0,value)

    def get_gridDim(self, i):
        """Get value of ``gridDim`` of ``self._ptr[i]``.
        """
        return dim3.from_ptr(&self._ptr[i].gridDim)
    @property
    def gridDim(self):
        return self.get_gridDim(0)

    def get_kernelParams(self, i):
        """Get value ``kernelParams`` of ``self._ptr[i]``.
        """
        return hip._util.types.DataHandle.from_ptr(self._ptr[i].kernelParams)
    def set_kernelParams(self, i, object value):
        """Set value ``kernelParams`` of ``self._ptr[i]``.

        Note:
            This can be dangerous if the pointer is from a python object
            that is later on garbage collected.
        """
        self._ptr[i].kernelParams = <void **>cpython.long.PyLong_AsVoidPtr(int(hip._util.types.DataHandle.from_pyobj(value)))
    @property
    def kernelParams(self):
        """
        Note:
            Setting this kernelParams can be dangerous if the underlying pointer is from a python object that
            is later on garbage collected.
        """
        return self.get_kernelParams(0)
    @kernelParams.setter
    def kernelParams(self, object value):
        self.set_kernelParams(0,value)

    def get_sharedMemBytes(self, i):
        """Get value ``sharedMemBytes`` of ``self._ptr[i]``.
        """
        return self._ptr[i].sharedMemBytes
    def set_sharedMemBytes(self, i, unsigned int value):
        """Set value ``sharedMemBytes`` of ``self._ptr[i]``.
        """
        self._ptr[i].sharedMemBytes = value
    @property
    def sharedMemBytes(self):
        return self.get_sharedMemBytes(0)
    @sharedMemBytes.setter
    def sharedMemBytes(self, unsigned int value):
        self.set_sharedMemBytes(0,value)

    @staticmethod
    def PROPERTIES():
        return ["blockDim","extra","func","gridDim","kernelParams","sharedMemBytes"]

    def __contains__(self,item):
        properties = self.PROPERTIES()
        return item in properties

    def __getitem__(self,item):
        properties = self.PROPERTIES()
        if isinstance(item,int):
            if item < 0 or item >= len(properties):
                raise IndexError()
            return getattr(self,properties[item])
        raise ValueError("'item' type must be 'int'")


cdef class hipMemsetParams:
    # members declared in pxd file

    def __cinit__(self):
        self._ptr = NULL
        self.ptr_owner = False
        self._py_buffer_acquired = False

    @staticmethod
    cdef hipMemsetParams from_ptr(chip.hipMemsetParams* ptr, bint owner=False):
        """Factory function to create ``hipMemsetParams`` objects from
        given ``chip.hipMemsetParams`` pointer.

        Setting ``owner`` flag to ``True`` causes
        the extension type to ``free`` the structure pointed to by ``ptr``
        when the wrapper object is deallocated.
        """
        # Fast call to __new__() that bypasses the __init__() constructor.
        cdef hipMemsetParams wrapper = hipMemsetParams.__new__(hipMemsetParams)
        wrapper._ptr = ptr
        wrapper.ptr_owner = owner
        return wrapper

    @staticmethod
    cdef hipMemsetParams from_pyobj(object pyobj):
        """Derives a hipMemsetParams from a Python object.

        Derives a hipMemsetParams from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``hipMemsetParams`` reference, this method
        returns it directly. No new ``hipMemsetParams`` is created in this case.

        Args:
            pyobj (object): Must be either ``None``, a simple, contiguous buffer according to the buffer protocol,
                            or of type ``hipMemsetParams``, ``int``, or ``ctypes.c_void_p``

        Note:
            This routine does not perform a copy but returns the original ``pyobj``
            if ``pyobj`` is an instance of hipMemsetParams!
        """
        cdef hipMemsetParams wrapper = hipMemsetParams.__new__(hipMemsetParams)
        cdef dict cuda_array_interface = getattr(pyobj, "__cuda_array_interface__", None)

        if pyobj is None:
            wrapper._ptr = NULL
        elif isinstance(pyobj,hipMemsetParams):
            return pyobj
        elif isinstance(pyobj,int):
            wrapper._ptr = <chip.hipMemsetParams*>cpython.long.PyLong_AsVoidPtr(pyobj)
        elif isinstance(pyobj,ctypes.c_void_p):
            wrapper._ptr = <chip.hipMemsetParams*>cpython.long.PyLong_AsVoidPtr(pyobj.value) if pyobj.value != None else NULL
        elif cuda_array_interface != None:
            if not "data" in cuda_array_interface:
                raise ValueError("input object has '__cuda_array_interface__' attribute but the dict has no 'data' key")
            ptr_as_int = cuda_array_interface["data"][0]
            wrapper._ptr = <chip.hipMemsetParams*>cpython.long.PyLong_AsVoidPtr(ptr_as_int)
        elif cpython.buffer.PyObject_CheckBuffer(pyobj):
            err = cpython.buffer.PyObject_GetBuffer( 
                pyobj,
                &wrapper._py_buffer, 
                cpython.buffer.PyBUF_SIMPLE | cpython.buffer.PyBUF_ANY_CONTIGUOUS
            )
            if err == -1:
                raise RuntimeError("failed to create simple, contiguous Py_buffer from Python object")
            wrapper._py_buffer_acquired = True
            wrapper._ptr = <chip.hipMemsetParams*>wrapper._py_buffer.buf
        else:
            raise TypeError(f"unsupported input type: '{str(type(pyobj))}'")
        return wrapper
    def __dealloc__(self):
        # Release the buffer handle
        if self._py_buffer_acquired is True:
            cpython.buffer.PyBuffer_Release(&self._py_buffer)
        # De-allocate if not null and flag is set
        if self._ptr is not NULL and self.ptr_owner is True:
            stdlib.free(self._ptr)
            self._ptr = NULL
    @staticmethod
    cdef __allocate(chip.hipMemsetParams** ptr):
        ptr[0] = <chip.hipMemsetParams*>stdlib.malloc(sizeof(chip.hipMemsetParams))

        if ptr[0] is NULL:
            raise MemoryError
        # TODO init values, if present

    @staticmethod
    cdef hipMemsetParams new():
        """Factory function to create hipMemsetParams objects with
        newly allocated chip.hipMemsetParams"""
        cdef chip.hipMemsetParams* ptr
        hipMemsetParams.__allocate(&ptr)
        return hipMemsetParams.from_ptr(ptr, owner=True)
   
    def __init__(self,*args,**kwargs):
        hipMemsetParams.__allocate(&self._ptr)
        self.ptr_owner = True
        attribs = self.PROPERTIES()
        used_attribs = set()
        if len(args) > len(attribs):
            raise ValueError("More positional arguments specified than this type has properties.")
        for i,v in enumerate(args):
            setattr(self,attribs[i],v)
            used_attribs.add(attribs[i])
        valid_names = ", ".join(["'"+p+"'" for p in attribs])
        for k,v in kwargs.items():
            if k in used_attribs:
                raise KeyError(f"argument '{k}' has already been specified as positional argument.")
            elif k not in attribs:
                raise KeyError(f"'{k}' is no valid property name. Valid names: {valid_names}")
            setattr(self,k,v)
    
    def __int__(self):
        """Returns the data's address as long integer."""
        return cpython.long.PyLong_FromVoidPtr(self._ptr)
    def __repr__(self):
        return f"<hipMemsetParams object, self.ptr={int(self)}>"
    def as_c_void_p(self):
        """Returns the data's address as `ctypes.c_void_p`"""
        return ctypes.c_void_p(int(self))
    def get_dst(self, i):
        """Get value ``dst`` of ``self._ptr[i]``.
        """
        return hip._util.types.DataHandle.from_ptr(self._ptr[i].dst)
    def set_dst(self, i, object value):
        """Set value ``dst`` of ``self._ptr[i]``.

        Note:
            This can be dangerous if the pointer is from a python object
            that is later on garbage collected.
        """
        self._ptr[i].dst = <void *>cpython.long.PyLong_AsVoidPtr(int(hip._util.types.DataHandle.from_pyobj(value)))
    @property
    def dst(self):
        """
        Note:
            Setting this dst can be dangerous if the underlying pointer is from a python object that
            is later on garbage collected.
        """
        return self.get_dst(0)
    @dst.setter
    def dst(self, object value):
        self.set_dst(0,value)

    def get_elementSize(self, i):
        """Get value ``elementSize`` of ``self._ptr[i]``.
        """
        return self._ptr[i].elementSize
    def set_elementSize(self, i, unsigned int value):
        """Set value ``elementSize`` of ``self._ptr[i]``.
        """
        self._ptr[i].elementSize = value
    @property
    def elementSize(self):
        return self.get_elementSize(0)
    @elementSize.setter
    def elementSize(self, unsigned int value):
        self.set_elementSize(0,value)

    def get_height(self, i):
        """Get value ``height`` of ``self._ptr[i]``.
        """
        return self._ptr[i].height
    def set_height(self, i, unsigned long value):
        """Set value ``height`` of ``self._ptr[i]``.
        """
        self._ptr[i].height = value
    @property
    def height(self):
        return self.get_height(0)
    @height.setter
    def height(self, unsigned long value):
        self.set_height(0,value)

    def get_pitch(self, i):
        """Get value ``pitch`` of ``self._ptr[i]``.
        """
        return self._ptr[i].pitch
    def set_pitch(self, i, unsigned long value):
        """Set value ``pitch`` of ``self._ptr[i]``.
        """
        self._ptr[i].pitch = value
    @property
    def pitch(self):
        return self.get_pitch(0)
    @pitch.setter
    def pitch(self, unsigned long value):
        self.set_pitch(0,value)

    def get_value(self, i):
        """Get value ``value`` of ``self._ptr[i]``.
        """
        return self._ptr[i].value
    def set_value(self, i, unsigned int value):
        """Set value ``value`` of ``self._ptr[i]``.
        """
        self._ptr[i].value = value
    @property
    def value(self):
        return self.get_value(0)
    @value.setter
    def value(self, unsigned int value):
        self.set_value(0,value)

    def get_width(self, i):
        """Get value ``width`` of ``self._ptr[i]``.
        """
        return self._ptr[i].width
    def set_width(self, i, unsigned long value):
        """Set value ``width`` of ``self._ptr[i]``.
        """
        self._ptr[i].width = value
    @property
    def width(self):
        return self.get_width(0)
    @width.setter
    def width(self, unsigned long value):
        self.set_width(0,value)

    @staticmethod
    def PROPERTIES():
        return ["dst","elementSize","height","pitch","value","width"]

    def __contains__(self,item):
        properties = self.PROPERTIES()
        return item in properties

    def __getitem__(self,item):
        properties = self.PROPERTIES()
        if isinstance(item,int):
            if item < 0 or item >= len(properties):
                raise IndexError()
            return getattr(self,properties[item])
        raise ValueError("'item' type must be 'int'")


class _hipKernelNodeAttrID__Base(enum.IntEnum):
    """Empty enum base class that allows subclassing.
    """
    pass
class hipKernelNodeAttrID(_hipKernelNodeAttrID__Base):
    hipKernelNodeAttributeAccessPolicyWindow = chip.hipKernelNodeAttributeAccessPolicyWindow
    hipKernelNodeAttributeCooperative = chip.hipKernelNodeAttributeCooperative
    @staticmethod
    def ctypes_type():
        """The type of the enum constants as ctypes type."""
        return ctypes.c_uint 


class _hipAccessProperty__Base(enum.IntEnum):
    """Empty enum base class that allows subclassing.
    """
    pass
class hipAccessProperty(_hipAccessProperty__Base):
    hipAccessPropertyNormal = chip.hipAccessPropertyNormal
    hipAccessPropertyStreaming = chip.hipAccessPropertyStreaming
    hipAccessPropertyPersisting = chip.hipAccessPropertyPersisting
    @staticmethod
    def ctypes_type():
        """The type of the enum constants as ctypes type."""
        return ctypes.c_uint 


cdef class hipAccessPolicyWindow:
    # members declared in pxd file

    def __cinit__(self):
        self._ptr = NULL
        self.ptr_owner = False
        self._py_buffer_acquired = False

    @staticmethod
    cdef hipAccessPolicyWindow from_ptr(chip.hipAccessPolicyWindow* ptr, bint owner=False):
        """Factory function to create ``hipAccessPolicyWindow`` objects from
        given ``chip.hipAccessPolicyWindow`` pointer.

        Setting ``owner`` flag to ``True`` causes
        the extension type to ``free`` the structure pointed to by ``ptr``
        when the wrapper object is deallocated.
        """
        # Fast call to __new__() that bypasses the __init__() constructor.
        cdef hipAccessPolicyWindow wrapper = hipAccessPolicyWindow.__new__(hipAccessPolicyWindow)
        wrapper._ptr = ptr
        wrapper.ptr_owner = owner
        return wrapper

    @staticmethod
    cdef hipAccessPolicyWindow from_pyobj(object pyobj):
        """Derives a hipAccessPolicyWindow from a Python object.

        Derives a hipAccessPolicyWindow from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``hipAccessPolicyWindow`` reference, this method
        returns it directly. No new ``hipAccessPolicyWindow`` is created in this case.

        Args:
            pyobj (object): Must be either ``None``, a simple, contiguous buffer according to the buffer protocol,
                            or of type ``hipAccessPolicyWindow``, ``int``, or ``ctypes.c_void_p``

        Note:
            This routine does not perform a copy but returns the original ``pyobj``
            if ``pyobj`` is an instance of hipAccessPolicyWindow!
        """
        cdef hipAccessPolicyWindow wrapper = hipAccessPolicyWindow.__new__(hipAccessPolicyWindow)
        cdef dict cuda_array_interface = getattr(pyobj, "__cuda_array_interface__", None)

        if pyobj is None:
            wrapper._ptr = NULL
        elif isinstance(pyobj,hipAccessPolicyWindow):
            return pyobj
        elif isinstance(pyobj,int):
            wrapper._ptr = <chip.hipAccessPolicyWindow*>cpython.long.PyLong_AsVoidPtr(pyobj)
        elif isinstance(pyobj,ctypes.c_void_p):
            wrapper._ptr = <chip.hipAccessPolicyWindow*>cpython.long.PyLong_AsVoidPtr(pyobj.value) if pyobj.value != None else NULL
        elif cuda_array_interface != None:
            if not "data" in cuda_array_interface:
                raise ValueError("input object has '__cuda_array_interface__' attribute but the dict has no 'data' key")
            ptr_as_int = cuda_array_interface["data"][0]
            wrapper._ptr = <chip.hipAccessPolicyWindow*>cpython.long.PyLong_AsVoidPtr(ptr_as_int)
        elif cpython.buffer.PyObject_CheckBuffer(pyobj):
            err = cpython.buffer.PyObject_GetBuffer( 
                pyobj,
                &wrapper._py_buffer, 
                cpython.buffer.PyBUF_SIMPLE | cpython.buffer.PyBUF_ANY_CONTIGUOUS
            )
            if err == -1:
                raise RuntimeError("failed to create simple, contiguous Py_buffer from Python object")
            wrapper._py_buffer_acquired = True
            wrapper._ptr = <chip.hipAccessPolicyWindow*>wrapper._py_buffer.buf
        else:
            raise TypeError(f"unsupported input type: '{str(type(pyobj))}'")
        return wrapper
    def __dealloc__(self):
        # Release the buffer handle
        if self._py_buffer_acquired is True:
            cpython.buffer.PyBuffer_Release(&self._py_buffer)
        # De-allocate if not null and flag is set
        if self._ptr is not NULL and self.ptr_owner is True:
            stdlib.free(self._ptr)
            self._ptr = NULL
    @staticmethod
    cdef __allocate(chip.hipAccessPolicyWindow** ptr):
        ptr[0] = <chip.hipAccessPolicyWindow*>stdlib.malloc(sizeof(chip.hipAccessPolicyWindow))

        if ptr[0] is NULL:
            raise MemoryError
        # TODO init values, if present

    @staticmethod
    cdef hipAccessPolicyWindow new():
        """Factory function to create hipAccessPolicyWindow objects with
        newly allocated chip.hipAccessPolicyWindow"""
        cdef chip.hipAccessPolicyWindow* ptr
        hipAccessPolicyWindow.__allocate(&ptr)
        return hipAccessPolicyWindow.from_ptr(ptr, owner=True)
   
    def __init__(self,*args,**kwargs):
        hipAccessPolicyWindow.__allocate(&self._ptr)
        self.ptr_owner = True
        attribs = self.PROPERTIES()
        used_attribs = set()
        if len(args) > len(attribs):
            raise ValueError("More positional arguments specified than this type has properties.")
        for i,v in enumerate(args):
            setattr(self,attribs[i],v)
            used_attribs.add(attribs[i])
        valid_names = ", ".join(["'"+p+"'" for p in attribs])
        for k,v in kwargs.items():
            if k in used_attribs:
                raise KeyError(f"argument '{k}' has already been specified as positional argument.")
            elif k not in attribs:
                raise KeyError(f"'{k}' is no valid property name. Valid names: {valid_names}")
            setattr(self,k,v)
    
    def __int__(self):
        """Returns the data's address as long integer."""
        return cpython.long.PyLong_FromVoidPtr(self._ptr)
    def __repr__(self):
        return f"<hipAccessPolicyWindow object, self.ptr={int(self)}>"
    def as_c_void_p(self):
        """Returns the data's address as `ctypes.c_void_p`"""
        return ctypes.c_void_p(int(self))
    def get_base_ptr(self, i):
        """Get value ``base_ptr`` of ``self._ptr[i]``.
        """
        return hip._util.types.DataHandle.from_ptr(self._ptr[i].base_ptr)
    def set_base_ptr(self, i, object value):
        """Set value ``base_ptr`` of ``self._ptr[i]``.

        Note:
            This can be dangerous if the pointer is from a python object
            that is later on garbage collected.
        """
        self._ptr[i].base_ptr = <void *>cpython.long.PyLong_AsVoidPtr(int(hip._util.types.DataHandle.from_pyobj(value)))
    @property
    def base_ptr(self):
        """
        Note:
            Setting this base_ptr can be dangerous if the underlying pointer is from a python object that
            is later on garbage collected.
        """
        return self.get_base_ptr(0)
    @base_ptr.setter
    def base_ptr(self, object value):
        self.set_base_ptr(0,value)

    def get_hitProp(self, i):
        """Get value of ``hitProp`` of ``self._ptr[i]``.
        """
        return hipAccessProperty(self._ptr[i].hitProp)
    def set_hitProp(self, i, value):
        """Set value ``hitProp`` of ``self._ptr[i]``.
        """
        if not isinstance(value, hipAccessProperty):
            raise TypeError("'value' must be of type 'hipAccessProperty'")
        self._ptr[i].hitProp = value.value
    @property
    def hitProp(self):
        return self.get_hitProp(0)
    @hitProp.setter
    def hitProp(self, value):
        self.set_hitProp(0,value)

    def get_hitRatio(self, i):
        """Get value ``hitRatio`` of ``self._ptr[i]``.
        """
        return self._ptr[i].hitRatio
    def set_hitRatio(self, i, float value):
        """Set value ``hitRatio`` of ``self._ptr[i]``.
        """
        self._ptr[i].hitRatio = value
    @property
    def hitRatio(self):
        return self.get_hitRatio(0)
    @hitRatio.setter
    def hitRatio(self, float value):
        self.set_hitRatio(0,value)

    def get_missProp(self, i):
        """Get value of ``missProp`` of ``self._ptr[i]``.
        """
        return hipAccessProperty(self._ptr[i].missProp)
    def set_missProp(self, i, value):
        """Set value ``missProp`` of ``self._ptr[i]``.
        """
        if not isinstance(value, hipAccessProperty):
            raise TypeError("'value' must be of type 'hipAccessProperty'")
        self._ptr[i].missProp = value.value
    @property
    def missProp(self):
        return self.get_missProp(0)
    @missProp.setter
    def missProp(self, value):
        self.set_missProp(0,value)

    def get_num_bytes(self, i):
        """Get value ``num_bytes`` of ``self._ptr[i]``.
        """
        return self._ptr[i].num_bytes
    def set_num_bytes(self, i, unsigned long value):
        """Set value ``num_bytes`` of ``self._ptr[i]``.
        """
        self._ptr[i].num_bytes = value
    @property
    def num_bytes(self):
        return self.get_num_bytes(0)
    @num_bytes.setter
    def num_bytes(self, unsigned long value):
        self.set_num_bytes(0,value)

    @staticmethod
    def PROPERTIES():
        return ["base_ptr","hitProp","hitRatio","missProp","num_bytes"]

    def __contains__(self,item):
        properties = self.PROPERTIES()
        return item in properties

    def __getitem__(self,item):
        properties = self.PROPERTIES()
        if isinstance(item,int):
            if item < 0 or item >= len(properties):
                raise IndexError()
            return getattr(self,properties[item])
        raise ValueError("'item' type must be 'int'")


cdef class hipKernelNodeAttrValue:
    # members declared in pxd file

    def __cinit__(self):
        self._ptr = NULL
        self.ptr_owner = False
        self._py_buffer_acquired = False

    @staticmethod
    cdef hipKernelNodeAttrValue from_ptr(chip.hipKernelNodeAttrValue* ptr, bint owner=False):
        """Factory function to create ``hipKernelNodeAttrValue`` objects from
        given ``chip.hipKernelNodeAttrValue`` pointer.

        Setting ``owner`` flag to ``True`` causes
        the extension type to ``free`` the structure pointed to by ``ptr``
        when the wrapper object is deallocated.
        """
        # Fast call to __new__() that bypasses the __init__() constructor.
        cdef hipKernelNodeAttrValue wrapper = hipKernelNodeAttrValue.__new__(hipKernelNodeAttrValue)
        wrapper._ptr = ptr
        wrapper.ptr_owner = owner
        return wrapper

    @staticmethod
    cdef hipKernelNodeAttrValue from_pyobj(object pyobj):
        """Derives a hipKernelNodeAttrValue from a Python object.

        Derives a hipKernelNodeAttrValue from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``hipKernelNodeAttrValue`` reference, this method
        returns it directly. No new ``hipKernelNodeAttrValue`` is created in this case.

        Args:
            pyobj (object): Must be either ``None``, a simple, contiguous buffer according to the buffer protocol,
                            or of type ``hipKernelNodeAttrValue``, ``int``, or ``ctypes.c_void_p``

        Note:
            This routine does not perform a copy but returns the original ``pyobj``
            if ``pyobj`` is an instance of hipKernelNodeAttrValue!
        """
        cdef hipKernelNodeAttrValue wrapper = hipKernelNodeAttrValue.__new__(hipKernelNodeAttrValue)
        cdef dict cuda_array_interface = getattr(pyobj, "__cuda_array_interface__", None)

        if pyobj is None:
            wrapper._ptr = NULL
        elif isinstance(pyobj,hipKernelNodeAttrValue):
            return pyobj
        elif isinstance(pyobj,int):
            wrapper._ptr = <chip.hipKernelNodeAttrValue*>cpython.long.PyLong_AsVoidPtr(pyobj)
        elif isinstance(pyobj,ctypes.c_void_p):
            wrapper._ptr = <chip.hipKernelNodeAttrValue*>cpython.long.PyLong_AsVoidPtr(pyobj.value) if pyobj.value != None else NULL
        elif cuda_array_interface != None:
            if not "data" in cuda_array_interface:
                raise ValueError("input object has '__cuda_array_interface__' attribute but the dict has no 'data' key")
            ptr_as_int = cuda_array_interface["data"][0]
            wrapper._ptr = <chip.hipKernelNodeAttrValue*>cpython.long.PyLong_AsVoidPtr(ptr_as_int)
        elif cpython.buffer.PyObject_CheckBuffer(pyobj):
            err = cpython.buffer.PyObject_GetBuffer( 
                pyobj,
                &wrapper._py_buffer, 
                cpython.buffer.PyBUF_SIMPLE | cpython.buffer.PyBUF_ANY_CONTIGUOUS
            )
            if err == -1:
                raise RuntimeError("failed to create simple, contiguous Py_buffer from Python object")
            wrapper._py_buffer_acquired = True
            wrapper._ptr = <chip.hipKernelNodeAttrValue*>wrapper._py_buffer.buf
        else:
            raise TypeError(f"unsupported input type: '{str(type(pyobj))}'")
        return wrapper
    def __dealloc__(self):
        # Release the buffer handle
        if self._py_buffer_acquired is True:
            cpython.buffer.PyBuffer_Release(&self._py_buffer)
        # De-allocate if not null and flag is set
        if self._ptr is not NULL and self.ptr_owner is True:
            stdlib.free(self._ptr)
            self._ptr = NULL
    @staticmethod
    cdef __allocate(chip.hipKernelNodeAttrValue** ptr):
        ptr[0] = <chip.hipKernelNodeAttrValue*>stdlib.malloc(sizeof(chip.hipKernelNodeAttrValue))

        if ptr[0] is NULL:
            raise MemoryError
        # TODO init values, if present

    @staticmethod
    cdef hipKernelNodeAttrValue new():
        """Factory function to create hipKernelNodeAttrValue objects with
        newly allocated chip.hipKernelNodeAttrValue"""
        cdef chip.hipKernelNodeAttrValue* ptr
        hipKernelNodeAttrValue.__allocate(&ptr)
        return hipKernelNodeAttrValue.from_ptr(ptr, owner=True)
   
    # True
    # True
    def __init__(self,**kwargs):
        hipKernelNodeAttrValue.__allocate(&self._ptr)
        self.ptr_owner = True
        attribs = self.PROPERTIES()
        used_attribs = set()
        if len(kwargs) > 1:
            raise ValueError("Not more than one attribute might specified for Python types derived from C union types.")
        valid_names = ", ".join(["'"+p+"'" for p in attribs])
        for k,v in kwargs.items():
            if k in used_attribs:
                raise KeyError(f"argument '{k}' has already been specified as positional argument.")
            elif k not in attribs:
                raise KeyError(f"'{k}' is no valid property name. Valid names: {valid_names}")
            setattr(self,k,v)
    
    def __int__(self):
        """Returns the data's address as long integer."""
        return cpython.long.PyLong_FromVoidPtr(self._ptr)
    def __repr__(self):
        return f"<hipKernelNodeAttrValue object, self.ptr={int(self)}>"
    def as_c_void_p(self):
        """Returns the data's address as `ctypes.c_void_p`"""
        return ctypes.c_void_p(int(self))
    def get_accessPolicyWindow(self, i):
        """Get value of ``accessPolicyWindow`` of ``self._ptr[i]``.
        """
        return hipAccessPolicyWindow.from_ptr(&self._ptr[i].accessPolicyWindow)
    @property
    def accessPolicyWindow(self):
        return self.get_accessPolicyWindow(0)

    def get_cooperative(self, i):
        """Get value ``cooperative`` of ``self._ptr[i]``.
        """
        return self._ptr[i].cooperative
    def set_cooperative(self, i, int value):
        """Set value ``cooperative`` of ``self._ptr[i]``.
        """
        self._ptr[i].cooperative = value
    @property
    def cooperative(self):
        return self.get_cooperative(0)
    @cooperative.setter
    def cooperative(self, int value):
        self.set_cooperative(0,value)

    @staticmethod
    def PROPERTIES():
        return ["accessPolicyWindow","cooperative"]


class _hipGraphExecUpdateResult__Base(enum.IntEnum):
    """Empty enum base class that allows subclassing.
    """
    pass
class hipGraphExecUpdateResult(_hipGraphExecUpdateResult__Base):
    hipGraphExecUpdateSuccess = chip.hipGraphExecUpdateSuccess
    hipGraphExecUpdateError = chip.hipGraphExecUpdateError
    hipGraphExecUpdateErrorTopologyChanged = chip.hipGraphExecUpdateErrorTopologyChanged
    hipGraphExecUpdateErrorNodeTypeChanged = chip.hipGraphExecUpdateErrorNodeTypeChanged
    hipGraphExecUpdateErrorFunctionChanged = chip.hipGraphExecUpdateErrorFunctionChanged
    hipGraphExecUpdateErrorParametersChanged = chip.hipGraphExecUpdateErrorParametersChanged
    hipGraphExecUpdateErrorNotSupported = chip.hipGraphExecUpdateErrorNotSupported
    hipGraphExecUpdateErrorUnsupportedFunctionChange = chip.hipGraphExecUpdateErrorUnsupportedFunctionChange
    @staticmethod
    def ctypes_type():
        """The type of the enum constants as ctypes type."""
        return ctypes.c_uint 


class _hipStreamCaptureMode__Base(enum.IntEnum):
    """Empty enum base class that allows subclassing.
    """
    pass
class hipStreamCaptureMode(_hipStreamCaptureMode__Base):
    hipStreamCaptureModeGlobal = chip.hipStreamCaptureModeGlobal
    hipStreamCaptureModeThreadLocal = chip.hipStreamCaptureModeThreadLocal
    hipStreamCaptureModeRelaxed = chip.hipStreamCaptureModeRelaxed
    @staticmethod
    def ctypes_type():
        """The type of the enum constants as ctypes type."""
        return ctypes.c_uint 


class _hipStreamCaptureStatus__Base(enum.IntEnum):
    """Empty enum base class that allows subclassing.
    """
    pass
class hipStreamCaptureStatus(_hipStreamCaptureStatus__Base):
    hipStreamCaptureStatusNone = chip.hipStreamCaptureStatusNone
    hipStreamCaptureStatusActive = chip.hipStreamCaptureStatusActive
    hipStreamCaptureStatusInvalidated = chip.hipStreamCaptureStatusInvalidated
    @staticmethod
    def ctypes_type():
        """The type of the enum constants as ctypes type."""
        return ctypes.c_uint 


class _hipStreamUpdateCaptureDependenciesFlags__Base(enum.IntEnum):
    """Empty enum base class that allows subclassing.
    """
    pass
class hipStreamUpdateCaptureDependenciesFlags(_hipStreamUpdateCaptureDependenciesFlags__Base):
    hipStreamAddCaptureDependencies = chip.hipStreamAddCaptureDependencies
    hipStreamSetCaptureDependencies = chip.hipStreamSetCaptureDependencies
    @staticmethod
    def ctypes_type():
        """The type of the enum constants as ctypes type."""
        return ctypes.c_uint 


class _hipGraphMemAttributeType__Base(enum.IntEnum):
    """Empty enum base class that allows subclassing.
    """
    pass
class hipGraphMemAttributeType(_hipGraphMemAttributeType__Base):
    hipGraphMemAttrUsedMemCurrent = chip.hipGraphMemAttrUsedMemCurrent
    hipGraphMemAttrUsedMemHigh = chip.hipGraphMemAttrUsedMemHigh
    hipGraphMemAttrReservedMemCurrent = chip.hipGraphMemAttrReservedMemCurrent
    hipGraphMemAttrReservedMemHigh = chip.hipGraphMemAttrReservedMemHigh
    @staticmethod
    def ctypes_type():
        """The type of the enum constants as ctypes type."""
        return ctypes.c_uint 


class _hipUserObjectFlags__Base(enum.IntEnum):
    """Empty enum base class that allows subclassing.
    """
    pass
class hipUserObjectFlags(_hipUserObjectFlags__Base):
    hipUserObjectNoDestructorSync = chip.hipUserObjectNoDestructorSync
    @staticmethod
    def ctypes_type():
        """The type of the enum constants as ctypes type."""
        return ctypes.c_uint 


class _hipUserObjectRetainFlags__Base(enum.IntEnum):
    """Empty enum base class that allows subclassing.
    """
    pass
class hipUserObjectRetainFlags(_hipUserObjectRetainFlags__Base):
    hipGraphUserObjectMove = chip.hipGraphUserObjectMove
    @staticmethod
    def ctypes_type():
        """The type of the enum constants as ctypes type."""
        return ctypes.c_uint 


class _hipGraphInstantiateFlags__Base(enum.IntEnum):
    """Empty enum base class that allows subclassing.
    """
    pass
class hipGraphInstantiateFlags(_hipGraphInstantiateFlags__Base):
    hipGraphInstantiateFlagAutoFreeOnLaunch = chip.hipGraphInstantiateFlagAutoFreeOnLaunch
    @staticmethod
    def ctypes_type():
        """The type of the enum constants as ctypes type."""
        return ctypes.c_uint 


cdef class hipMemAllocationProp_struct_0:
    # members declared in pxd file

    def __cinit__(self):
        self._ptr = NULL
        self.ptr_owner = False
        self._py_buffer_acquired = False

    @staticmethod
    cdef hipMemAllocationProp_struct_0 from_ptr(chip.hipMemAllocationProp_struct_0* ptr, bint owner=False):
        """Factory function to create ``hipMemAllocationProp_struct_0`` objects from
        given ``chip.hipMemAllocationProp_struct_0`` pointer.

        Setting ``owner`` flag to ``True`` causes
        the extension type to ``free`` the structure pointed to by ``ptr``
        when the wrapper object is deallocated.
        """
        # Fast call to __new__() that bypasses the __init__() constructor.
        cdef hipMemAllocationProp_struct_0 wrapper = hipMemAllocationProp_struct_0.__new__(hipMemAllocationProp_struct_0)
        wrapper._ptr = ptr
        wrapper.ptr_owner = owner
        return wrapper

    @staticmethod
    cdef hipMemAllocationProp_struct_0 from_pyobj(object pyobj):
        """Derives a hipMemAllocationProp_struct_0 from a Python object.

        Derives a hipMemAllocationProp_struct_0 from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``hipMemAllocationProp_struct_0`` reference, this method
        returns it directly. No new ``hipMemAllocationProp_struct_0`` is created in this case.

        Args:
            pyobj (object): Must be either ``None``, a simple, contiguous buffer according to the buffer protocol,
                            or of type ``hipMemAllocationProp_struct_0``, ``int``, or ``ctypes.c_void_p``

        Note:
            This routine does not perform a copy but returns the original ``pyobj``
            if ``pyobj`` is an instance of hipMemAllocationProp_struct_0!
        """
        cdef hipMemAllocationProp_struct_0 wrapper = hipMemAllocationProp_struct_0.__new__(hipMemAllocationProp_struct_0)
        cdef dict cuda_array_interface = getattr(pyobj, "__cuda_array_interface__", None)

        if pyobj is None:
            wrapper._ptr = NULL
        elif isinstance(pyobj,hipMemAllocationProp_struct_0):
            return pyobj
        elif isinstance(pyobj,int):
            wrapper._ptr = <chip.hipMemAllocationProp_struct_0*>cpython.long.PyLong_AsVoidPtr(pyobj)
        elif isinstance(pyobj,ctypes.c_void_p):
            wrapper._ptr = <chip.hipMemAllocationProp_struct_0*>cpython.long.PyLong_AsVoidPtr(pyobj.value) if pyobj.value != None else NULL
        elif cuda_array_interface != None:
            if not "data" in cuda_array_interface:
                raise ValueError("input object has '__cuda_array_interface__' attribute but the dict has no 'data' key")
            ptr_as_int = cuda_array_interface["data"][0]
            wrapper._ptr = <chip.hipMemAllocationProp_struct_0*>cpython.long.PyLong_AsVoidPtr(ptr_as_int)
        elif cpython.buffer.PyObject_CheckBuffer(pyobj):
            err = cpython.buffer.PyObject_GetBuffer( 
                pyobj,
                &wrapper._py_buffer, 
                cpython.buffer.PyBUF_SIMPLE | cpython.buffer.PyBUF_ANY_CONTIGUOUS
            )
            if err == -1:
                raise RuntimeError("failed to create simple, contiguous Py_buffer from Python object")
            wrapper._py_buffer_acquired = True
            wrapper._ptr = <chip.hipMemAllocationProp_struct_0*>wrapper._py_buffer.buf
        else:
            raise TypeError(f"unsupported input type: '{str(type(pyobj))}'")
        return wrapper
    def __dealloc__(self):
        # Release the buffer handle
        if self._py_buffer_acquired is True:
            cpython.buffer.PyBuffer_Release(&self._py_buffer)
        # De-allocate if not null and flag is set
        if self._ptr is not NULL and self.ptr_owner is True:
            stdlib.free(self._ptr)
            self._ptr = NULL
    @staticmethod
    cdef __allocate(chip.hipMemAllocationProp_struct_0** ptr):
        ptr[0] = <chip.hipMemAllocationProp_struct_0*>stdlib.malloc(sizeof(chip.hipMemAllocationProp_struct_0))

        if ptr[0] is NULL:
            raise MemoryError
        # TODO init values, if present

    @staticmethod
    cdef hipMemAllocationProp_struct_0 new():
        """Factory function to create hipMemAllocationProp_struct_0 objects with
        newly allocated chip.hipMemAllocationProp_struct_0"""
        cdef chip.hipMemAllocationProp_struct_0* ptr
        hipMemAllocationProp_struct_0.__allocate(&ptr)
        return hipMemAllocationProp_struct_0.from_ptr(ptr, owner=True)
   
    def __init__(self,*args,**kwargs):
        hipMemAllocationProp_struct_0.__allocate(&self._ptr)
        self.ptr_owner = True
        attribs = self.PROPERTIES()
        used_attribs = set()
        if len(args) > len(attribs):
            raise ValueError("More positional arguments specified than this type has properties.")
        for i,v in enumerate(args):
            setattr(self,attribs[i],v)
            used_attribs.add(attribs[i])
        valid_names = ", ".join(["'"+p+"'" for p in attribs])
        for k,v in kwargs.items():
            if k in used_attribs:
                raise KeyError(f"argument '{k}' has already been specified as positional argument.")
            elif k not in attribs:
                raise KeyError(f"'{k}' is no valid property name. Valid names: {valid_names}")
            setattr(self,k,v)
    
    def __int__(self):
        """Returns the data's address as long integer."""
        return cpython.long.PyLong_FromVoidPtr(self._ptr)
    def __repr__(self):
        return f"<hipMemAllocationProp_struct_0 object, self.ptr={int(self)}>"
    def as_c_void_p(self):
        """Returns the data's address as `ctypes.c_void_p`"""
        return ctypes.c_void_p(int(self))
    def get_compressionType(self, i):
        """Get value ``compressionType`` of ``self._ptr[i]``.
        """
        return self._ptr[i].compressionType
    def set_compressionType(self, i, unsigned char value):
        """Set value ``compressionType`` of ``self._ptr[i]``.
        """
        self._ptr[i].compressionType = value
    @property
    def compressionType(self):
        return self.get_compressionType(0)
    @compressionType.setter
    def compressionType(self, unsigned char value):
        self.set_compressionType(0,value)

    def get_gpuDirectRDMACapable(self, i):
        """Get value ``gpuDirectRDMACapable`` of ``self._ptr[i]``.
        """
        return self._ptr[i].gpuDirectRDMACapable
    def set_gpuDirectRDMACapable(self, i, unsigned char value):
        """Set value ``gpuDirectRDMACapable`` of ``self._ptr[i]``.
        """
        self._ptr[i].gpuDirectRDMACapable = value
    @property
    def gpuDirectRDMACapable(self):
        return self.get_gpuDirectRDMACapable(0)
    @gpuDirectRDMACapable.setter
    def gpuDirectRDMACapable(self, unsigned char value):
        self.set_gpuDirectRDMACapable(0,value)

    def get_usage(self, i):
        """Get value ``usage`` of ``self._ptr[i]``.
        """
        return self._ptr[i].usage
    def set_usage(self, i, unsigned short value):
        """Set value ``usage`` of ``self._ptr[i]``.
        """
        self._ptr[i].usage = value
    @property
    def usage(self):
        return self.get_usage(0)
    @usage.setter
    def usage(self, unsigned short value):
        self.set_usage(0,value)

    @staticmethod
    def PROPERTIES():
        return ["compressionType","gpuDirectRDMACapable","usage"]

    def __contains__(self,item):
        properties = self.PROPERTIES()
        return item in properties

    def __getitem__(self,item):
        properties = self.PROPERTIES()
        if isinstance(item,int):
            if item < 0 or item >= len(properties):
                raise IndexError()
            return getattr(self,properties[item])
        raise ValueError("'item' type must be 'int'")


cdef class hipMemAllocationProp:
    # members declared in pxd file

    def __cinit__(self):
        self._ptr = NULL
        self.ptr_owner = False
        self._py_buffer_acquired = False

    @staticmethod
    cdef hipMemAllocationProp from_ptr(chip.hipMemAllocationProp* ptr, bint owner=False):
        """Factory function to create ``hipMemAllocationProp`` objects from
        given ``chip.hipMemAllocationProp`` pointer.

        Setting ``owner`` flag to ``True`` causes
        the extension type to ``free`` the structure pointed to by ``ptr``
        when the wrapper object is deallocated.
        """
        # Fast call to __new__() that bypasses the __init__() constructor.
        cdef hipMemAllocationProp wrapper = hipMemAllocationProp.__new__(hipMemAllocationProp)
        wrapper._ptr = ptr
        wrapper.ptr_owner = owner
        return wrapper

    @staticmethod
    cdef hipMemAllocationProp from_pyobj(object pyobj):
        """Derives a hipMemAllocationProp from a Python object.

        Derives a hipMemAllocationProp from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``hipMemAllocationProp`` reference, this method
        returns it directly. No new ``hipMemAllocationProp`` is created in this case.

        Args:
            pyobj (object): Must be either ``None``, a simple, contiguous buffer according to the buffer protocol,
                            or of type ``hipMemAllocationProp``, ``int``, or ``ctypes.c_void_p``

        Note:
            This routine does not perform a copy but returns the original ``pyobj``
            if ``pyobj`` is an instance of hipMemAllocationProp!
        """
        cdef hipMemAllocationProp wrapper = hipMemAllocationProp.__new__(hipMemAllocationProp)
        cdef dict cuda_array_interface = getattr(pyobj, "__cuda_array_interface__", None)

        if pyobj is None:
            wrapper._ptr = NULL
        elif isinstance(pyobj,hipMemAllocationProp):
            return pyobj
        elif isinstance(pyobj,int):
            wrapper._ptr = <chip.hipMemAllocationProp*>cpython.long.PyLong_AsVoidPtr(pyobj)
        elif isinstance(pyobj,ctypes.c_void_p):
            wrapper._ptr = <chip.hipMemAllocationProp*>cpython.long.PyLong_AsVoidPtr(pyobj.value) if pyobj.value != None else NULL
        elif cuda_array_interface != None:
            if not "data" in cuda_array_interface:
                raise ValueError("input object has '__cuda_array_interface__' attribute but the dict has no 'data' key")
            ptr_as_int = cuda_array_interface["data"][0]
            wrapper._ptr = <chip.hipMemAllocationProp*>cpython.long.PyLong_AsVoidPtr(ptr_as_int)
        elif cpython.buffer.PyObject_CheckBuffer(pyobj):
            err = cpython.buffer.PyObject_GetBuffer( 
                pyobj,
                &wrapper._py_buffer, 
                cpython.buffer.PyBUF_SIMPLE | cpython.buffer.PyBUF_ANY_CONTIGUOUS
            )
            if err == -1:
                raise RuntimeError("failed to create simple, contiguous Py_buffer from Python object")
            wrapper._py_buffer_acquired = True
            wrapper._ptr = <chip.hipMemAllocationProp*>wrapper._py_buffer.buf
        else:
            raise TypeError(f"unsupported input type: '{str(type(pyobj))}'")
        return wrapper
    def __dealloc__(self):
        # Release the buffer handle
        if self._py_buffer_acquired is True:
            cpython.buffer.PyBuffer_Release(&self._py_buffer)
        # De-allocate if not null and flag is set
        if self._ptr is not NULL and self.ptr_owner is True:
            stdlib.free(self._ptr)
            self._ptr = NULL
    @staticmethod
    cdef __allocate(chip.hipMemAllocationProp** ptr):
        ptr[0] = <chip.hipMemAllocationProp*>stdlib.malloc(sizeof(chip.hipMemAllocationProp))

        if ptr[0] is NULL:
            raise MemoryError
        # TODO init values, if present

    @staticmethod
    cdef hipMemAllocationProp new():
        """Factory function to create hipMemAllocationProp objects with
        newly allocated chip.hipMemAllocationProp"""
        cdef chip.hipMemAllocationProp* ptr
        hipMemAllocationProp.__allocate(&ptr)
        return hipMemAllocationProp.from_ptr(ptr, owner=True)
   
    def __init__(self,*args,**kwargs):
        hipMemAllocationProp.__allocate(&self._ptr)
        self.ptr_owner = True
        attribs = self.PROPERTIES()
        used_attribs = set()
        if len(args) > len(attribs):
            raise ValueError("More positional arguments specified than this type has properties.")
        for i,v in enumerate(args):
            setattr(self,attribs[i],v)
            used_attribs.add(attribs[i])
        valid_names = ", ".join(["'"+p+"'" for p in attribs])
        for k,v in kwargs.items():
            if k in used_attribs:
                raise KeyError(f"argument '{k}' has already been specified as positional argument.")
            elif k not in attribs:
                raise KeyError(f"'{k}' is no valid property name. Valid names: {valid_names}")
            setattr(self,k,v)
    
    def __int__(self):
        """Returns the data's address as long integer."""
        return cpython.long.PyLong_FromVoidPtr(self._ptr)
    def __repr__(self):
        return f"<hipMemAllocationProp object, self.ptr={int(self)}>"
    def as_c_void_p(self):
        """Returns the data's address as `ctypes.c_void_p`"""
        return ctypes.c_void_p(int(self))
    def get_type(self, i):
        """Get value of ``type`` of ``self._ptr[i]``.
        """
        return hipMemAllocationType(self._ptr[i].type)
    def set_type(self, i, value):
        """Set value ``type`` of ``self._ptr[i]``.
        """
        if not isinstance(value, hipMemAllocationType):
            raise TypeError("'value' must be of type 'hipMemAllocationType'")
        self._ptr[i].type = value.value
    @property
    def type(self):
        return self.get_type(0)
    @type.setter
    def type(self, value):
        self.set_type(0,value)

    def get_requestedHandleType(self, i):
        """Get value of ``requestedHandleType`` of ``self._ptr[i]``.
        """
        return hipMemAllocationHandleType(self._ptr[i].requestedHandleType)
    def set_requestedHandleType(self, i, value):
        """Set value ``requestedHandleType`` of ``self._ptr[i]``.
        """
        if not isinstance(value, hipMemAllocationHandleType):
            raise TypeError("'value' must be of type 'hipMemAllocationHandleType'")
        self._ptr[i].requestedHandleType = value.value
    @property
    def requestedHandleType(self):
        return self.get_requestedHandleType(0)
    @requestedHandleType.setter
    def requestedHandleType(self, value):
        self.set_requestedHandleType(0,value)

    def get_location(self, i):
        """Get value of ``location`` of ``self._ptr[i]``.
        """
        return hipMemLocation.from_ptr(&self._ptr[i].location)
    @property
    def location(self):
        return self.get_location(0)

    def get_win32HandleMetaData(self, i):
        """Get value ``win32HandleMetaData`` of ``self._ptr[i]``.
        """
        return hip._util.types.DataHandle.from_ptr(self._ptr[i].win32HandleMetaData)
    def set_win32HandleMetaData(self, i, object value):
        """Set value ``win32HandleMetaData`` of ``self._ptr[i]``.

        Note:
            This can be dangerous if the pointer is from a python object
            that is later on garbage collected.
        """
        self._ptr[i].win32HandleMetaData = <void *>cpython.long.PyLong_AsVoidPtr(int(hip._util.types.DataHandle.from_pyobj(value)))
    @property
    def win32HandleMetaData(self):
        """
        Note:
            Setting this win32HandleMetaData can be dangerous if the underlying pointer is from a python object that
            is later on garbage collected.
        """
        return self.get_win32HandleMetaData(0)
    @win32HandleMetaData.setter
    def win32HandleMetaData(self, object value):
        self.set_win32HandleMetaData(0,value)

    def get_allocFlags(self, i):
        """Get value of ``allocFlags`` of ``self._ptr[i]``.
        """
        return hipMemAllocationProp_struct_0.from_ptr(&self._ptr[i].allocFlags)
    @property
    def allocFlags(self):
        return self.get_allocFlags(0)

    @staticmethod
    def PROPERTIES():
        return ["type","requestedHandleType","location","win32HandleMetaData","allocFlags"]

    def __contains__(self,item):
        properties = self.PROPERTIES()
        return item in properties

    def __getitem__(self,item):
        properties = self.PROPERTIES()
        if isinstance(item,int):
            if item < 0 or item >= len(properties):
                raise IndexError()
            return getattr(self,properties[item])
        raise ValueError("'item' type must be 'int'")


cdef class ihipMemGenericAllocationHandle:
    # members declared in pxd file

    def __cinit__(self):
        self._ptr = NULL
        self.ptr_owner = False
        self._py_buffer_acquired = False

    @staticmethod
    cdef ihipMemGenericAllocationHandle from_ptr(chip.ihipMemGenericAllocationHandle* ptr, bint owner=False):
        """Factory function to create ``ihipMemGenericAllocationHandle`` objects from
        given ``chip.ihipMemGenericAllocationHandle`` pointer.
        """
        # Fast call to __new__() that bypasses the __init__() constructor.
        cdef ihipMemGenericAllocationHandle wrapper = ihipMemGenericAllocationHandle.__new__(ihipMemGenericAllocationHandle)
        wrapper._ptr = ptr
        wrapper.ptr_owner = owner
        return wrapper

    @staticmethod
    cdef ihipMemGenericAllocationHandle from_pyobj(object pyobj):
        """Derives a ihipMemGenericAllocationHandle from a Python object.

        Derives a ihipMemGenericAllocationHandle from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``ihipMemGenericAllocationHandle`` reference, this method
        returns it directly. No new ``ihipMemGenericAllocationHandle`` is created in this case.

        Args:
            pyobj (object): Must be either ``None``, a simple, contiguous buffer according to the buffer protocol,
                            or of type ``ihipMemGenericAllocationHandle``, ``int``, or ``ctypes.c_void_p``

        Note:
            This routine does not perform a copy but returns the original ``pyobj``
            if ``pyobj`` is an instance of ihipMemGenericAllocationHandle!
        """
        cdef ihipMemGenericAllocationHandle wrapper = ihipMemGenericAllocationHandle.__new__(ihipMemGenericAllocationHandle)
        cdef dict cuda_array_interface = getattr(pyobj, "__cuda_array_interface__", None)

        if pyobj is None:
            wrapper._ptr = NULL
        elif isinstance(pyobj,ihipMemGenericAllocationHandle):
            return pyobj
        elif isinstance(pyobj,int):
            wrapper._ptr = <chip.ihipMemGenericAllocationHandle*>cpython.long.PyLong_AsVoidPtr(pyobj)
        elif isinstance(pyobj,ctypes.c_void_p):
            wrapper._ptr = <chip.ihipMemGenericAllocationHandle*>cpython.long.PyLong_AsVoidPtr(pyobj.value) if pyobj.value != None else NULL
        elif cuda_array_interface != None:
            if not "data" in cuda_array_interface:
                raise ValueError("input object has '__cuda_array_interface__' attribute but the dict has no 'data' key")
            ptr_as_int = cuda_array_interface["data"][0]
            wrapper._ptr = <chip.ihipMemGenericAllocationHandle*>cpython.long.PyLong_AsVoidPtr(ptr_as_int)
        elif cpython.buffer.PyObject_CheckBuffer(pyobj):
            err = cpython.buffer.PyObject_GetBuffer( 
                pyobj,
                &wrapper._py_buffer, 
                cpython.buffer.PyBUF_SIMPLE | cpython.buffer.PyBUF_ANY_CONTIGUOUS
            )
            if err == -1:
                raise RuntimeError("failed to create simple, contiguous Py_buffer from Python object")
            wrapper._py_buffer_acquired = True
            wrapper._ptr = <chip.ihipMemGenericAllocationHandle*>wrapper._py_buffer.buf
        else:
            raise TypeError(f"unsupported input type: '{str(type(pyobj))}'")
        return wrapper
    def __dealloc__(self):
        # Release the buffer handle
        if self._py_buffer_acquired is True:
            cpython.buffer.PyBuffer_Release(&self._py_buffer)
    
    def __int__(self):
        """Returns the data's address as long integer."""
        return cpython.long.PyLong_FromVoidPtr(self._ptr)
    def __repr__(self):
        return f"<ihipMemGenericAllocationHandle object, self.ptr={int(self)}>"
    def as_c_void_p(self):
        """Returns the data's address as `ctypes.c_void_p`"""
        return ctypes.c_void_p(int(self))
    @staticmethod
    def PROPERTIES():
        return []

    def __contains__(self,item):
        properties = self.PROPERTIES()
        return item in properties

    def __getitem__(self,item):
        properties = self.PROPERTIES()
        if isinstance(item,int):
            if item < 0 or item >= len(properties):
                raise IndexError()
            return getattr(self,properties[item])
        raise ValueError("'item' type must be 'int'")


hipMemGenericAllocationHandle_t = ihipMemGenericAllocationHandle

class _hipMemAllocationGranularity_flags__Base(enum.IntEnum):
    """Empty enum base class that allows subclassing.
    """
    pass
class hipMemAllocationGranularity_flags(_hipMemAllocationGranularity_flags__Base):
    hipMemAllocationGranularityMinimum = chip.hipMemAllocationGranularityMinimum
    hipMemAllocationGranularityRecommended = chip.hipMemAllocationGranularityRecommended
    @staticmethod
    def ctypes_type():
        """The type of the enum constants as ctypes type."""
        return ctypes.c_uint 


class _hipMemHandleType__Base(enum.IntEnum):
    """Empty enum base class that allows subclassing.
    """
    pass
class hipMemHandleType(_hipMemHandleType__Base):
    hipMemHandleTypeGeneric = chip.hipMemHandleTypeGeneric
    @staticmethod
    def ctypes_type():
        """The type of the enum constants as ctypes type."""
        return ctypes.c_uint 


class _hipMemOperationType__Base(enum.IntEnum):
    """Empty enum base class that allows subclassing.
    """
    pass
class hipMemOperationType(_hipMemOperationType__Base):
    hipMemOperationTypeMap = chip.hipMemOperationTypeMap
    hipMemOperationTypeUnmap = chip.hipMemOperationTypeUnmap
    @staticmethod
    def ctypes_type():
        """The type of the enum constants as ctypes type."""
        return ctypes.c_uint 


class _hipArraySparseSubresourceType__Base(enum.IntEnum):
    """Empty enum base class that allows subclassing.
    """
    pass
class hipArraySparseSubresourceType(_hipArraySparseSubresourceType__Base):
    hipArraySparseSubresourceTypeSparseLevel = chip.hipArraySparseSubresourceTypeSparseLevel
    hipArraySparseSubresourceTypeMiptail = chip.hipArraySparseSubresourceTypeMiptail
    @staticmethod
    def ctypes_type():
        """The type of the enum constants as ctypes type."""
        return ctypes.c_uint 


cdef class hipArrayMapInfo_union_0:
    # members declared in pxd file

    def __cinit__(self):
        self._ptr = NULL
        self.ptr_owner = False
        self._py_buffer_acquired = False

    @staticmethod
    cdef hipArrayMapInfo_union_0 from_ptr(chip.hipArrayMapInfo_union_0* ptr, bint owner=False):
        """Factory function to create ``hipArrayMapInfo_union_0`` objects from
        given ``chip.hipArrayMapInfo_union_0`` pointer.

        Setting ``owner`` flag to ``True`` causes
        the extension type to ``free`` the structure pointed to by ``ptr``
        when the wrapper object is deallocated.
        """
        # Fast call to __new__() that bypasses the __init__() constructor.
        cdef hipArrayMapInfo_union_0 wrapper = hipArrayMapInfo_union_0.__new__(hipArrayMapInfo_union_0)
        wrapper._ptr = ptr
        wrapper.ptr_owner = owner
        return wrapper

    @staticmethod
    cdef hipArrayMapInfo_union_0 from_pyobj(object pyobj):
        """Derives a hipArrayMapInfo_union_0 from a Python object.

        Derives a hipArrayMapInfo_union_0 from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``hipArrayMapInfo_union_0`` reference, this method
        returns it directly. No new ``hipArrayMapInfo_union_0`` is created in this case.

        Args:
            pyobj (object): Must be either ``None``, a simple, contiguous buffer according to the buffer protocol,
                            or of type ``hipArrayMapInfo_union_0``, ``int``, or ``ctypes.c_void_p``

        Note:
            This routine does not perform a copy but returns the original ``pyobj``
            if ``pyobj`` is an instance of hipArrayMapInfo_union_0!
        """
        cdef hipArrayMapInfo_union_0 wrapper = hipArrayMapInfo_union_0.__new__(hipArrayMapInfo_union_0)
        cdef dict cuda_array_interface = getattr(pyobj, "__cuda_array_interface__", None)

        if pyobj is None:
            wrapper._ptr = NULL
        elif isinstance(pyobj,hipArrayMapInfo_union_0):
            return pyobj
        elif isinstance(pyobj,int):
            wrapper._ptr = <chip.hipArrayMapInfo_union_0*>cpython.long.PyLong_AsVoidPtr(pyobj)
        elif isinstance(pyobj,ctypes.c_void_p):
            wrapper._ptr = <chip.hipArrayMapInfo_union_0*>cpython.long.PyLong_AsVoidPtr(pyobj.value) if pyobj.value != None else NULL
        elif cuda_array_interface != None:
            if not "data" in cuda_array_interface:
                raise ValueError("input object has '__cuda_array_interface__' attribute but the dict has no 'data' key")
            ptr_as_int = cuda_array_interface["data"][0]
            wrapper._ptr = <chip.hipArrayMapInfo_union_0*>cpython.long.PyLong_AsVoidPtr(ptr_as_int)
        elif cpython.buffer.PyObject_CheckBuffer(pyobj):
            err = cpython.buffer.PyObject_GetBuffer( 
                pyobj,
                &wrapper._py_buffer, 
                cpython.buffer.PyBUF_SIMPLE | cpython.buffer.PyBUF_ANY_CONTIGUOUS
            )
            if err == -1:
                raise RuntimeError("failed to create simple, contiguous Py_buffer from Python object")
            wrapper._py_buffer_acquired = True
            wrapper._ptr = <chip.hipArrayMapInfo_union_0*>wrapper._py_buffer.buf
        else:
            raise TypeError(f"unsupported input type: '{str(type(pyobj))}'")
        return wrapper
    def __dealloc__(self):
        # Release the buffer handle
        if self._py_buffer_acquired is True:
            cpython.buffer.PyBuffer_Release(&self._py_buffer)
        # De-allocate if not null and flag is set
        if self._ptr is not NULL and self.ptr_owner is True:
            stdlib.free(self._ptr)
            self._ptr = NULL
    @staticmethod
    cdef __allocate(chip.hipArrayMapInfo_union_0** ptr):
        ptr[0] = <chip.hipArrayMapInfo_union_0*>stdlib.malloc(sizeof(chip.hipArrayMapInfo_union_0))

        if ptr[0] is NULL:
            raise MemoryError
        # TODO init values, if present

    @staticmethod
    cdef hipArrayMapInfo_union_0 new():
        """Factory function to create hipArrayMapInfo_union_0 objects with
        newly allocated chip.hipArrayMapInfo_union_0"""
        cdef chip.hipArrayMapInfo_union_0* ptr
        hipArrayMapInfo_union_0.__allocate(&ptr)
        return hipArrayMapInfo_union_0.from_ptr(ptr, owner=True)
   
    # False
    # True
    def __init__(self,**kwargs):
        hipArrayMapInfo_union_0.__allocate(&self._ptr)
        self.ptr_owner = True
        attribs = self.PROPERTIES()
        used_attribs = set()
        if len(kwargs) > 1:
            raise ValueError("Not more than one attribute might specified for Python types derived from C union types.")
        valid_names = ", ".join(["'"+p+"'" for p in attribs])
        for k,v in kwargs.items():
            if k in used_attribs:
                raise KeyError(f"argument '{k}' has already been specified as positional argument.")
            elif k not in attribs:
                raise KeyError(f"'{k}' is no valid property name. Valid names: {valid_names}")
            setattr(self,k,v)
    
    def __int__(self):
        """Returns the data's address as long integer."""
        return cpython.long.PyLong_FromVoidPtr(self._ptr)
    def __repr__(self):
        return f"<hipArrayMapInfo_union_0 object, self.ptr={int(self)}>"
    def as_c_void_p(self):
        """Returns the data's address as `ctypes.c_void_p`"""
        return ctypes.c_void_p(int(self))
    def get_mipmap(self, i):
        """Get value of ``mipmap`` of ``self._ptr[i]``.
        """
        return hipMipmappedArray.from_ptr(&self._ptr[i].mipmap)
    @property
    def mipmap(self):
        return self.get_mipmap(0)

    @staticmethod
    def PROPERTIES():
        return ["mipmap"]


cdef class hipArrayMapInfo_union_1_struct_0:
    # members declared in pxd file

    def __cinit__(self):
        self._ptr = NULL
        self.ptr_owner = False
        self._py_buffer_acquired = False

    @staticmethod
    cdef hipArrayMapInfo_union_1_struct_0 from_ptr(chip.hipArrayMapInfo_union_1_struct_0* ptr, bint owner=False):
        """Factory function to create ``hipArrayMapInfo_union_1_struct_0`` objects from
        given ``chip.hipArrayMapInfo_union_1_struct_0`` pointer.

        Setting ``owner`` flag to ``True`` causes
        the extension type to ``free`` the structure pointed to by ``ptr``
        when the wrapper object is deallocated.
        """
        # Fast call to __new__() that bypasses the __init__() constructor.
        cdef hipArrayMapInfo_union_1_struct_0 wrapper = hipArrayMapInfo_union_1_struct_0.__new__(hipArrayMapInfo_union_1_struct_0)
        wrapper._ptr = ptr
        wrapper.ptr_owner = owner
        return wrapper

    @staticmethod
    cdef hipArrayMapInfo_union_1_struct_0 from_pyobj(object pyobj):
        """Derives a hipArrayMapInfo_union_1_struct_0 from a Python object.

        Derives a hipArrayMapInfo_union_1_struct_0 from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``hipArrayMapInfo_union_1_struct_0`` reference, this method
        returns it directly. No new ``hipArrayMapInfo_union_1_struct_0`` is created in this case.

        Args:
            pyobj (object): Must be either ``None``, a simple, contiguous buffer according to the buffer protocol,
                            or of type ``hipArrayMapInfo_union_1_struct_0``, ``int``, or ``ctypes.c_void_p``

        Note:
            This routine does not perform a copy but returns the original ``pyobj``
            if ``pyobj`` is an instance of hipArrayMapInfo_union_1_struct_0!
        """
        cdef hipArrayMapInfo_union_1_struct_0 wrapper = hipArrayMapInfo_union_1_struct_0.__new__(hipArrayMapInfo_union_1_struct_0)
        cdef dict cuda_array_interface = getattr(pyobj, "__cuda_array_interface__", None)

        if pyobj is None:
            wrapper._ptr = NULL
        elif isinstance(pyobj,hipArrayMapInfo_union_1_struct_0):
            return pyobj
        elif isinstance(pyobj,int):
            wrapper._ptr = <chip.hipArrayMapInfo_union_1_struct_0*>cpython.long.PyLong_AsVoidPtr(pyobj)
        elif isinstance(pyobj,ctypes.c_void_p):
            wrapper._ptr = <chip.hipArrayMapInfo_union_1_struct_0*>cpython.long.PyLong_AsVoidPtr(pyobj.value) if pyobj.value != None else NULL
        elif cuda_array_interface != None:
            if not "data" in cuda_array_interface:
                raise ValueError("input object has '__cuda_array_interface__' attribute but the dict has no 'data' key")
            ptr_as_int = cuda_array_interface["data"][0]
            wrapper._ptr = <chip.hipArrayMapInfo_union_1_struct_0*>cpython.long.PyLong_AsVoidPtr(ptr_as_int)
        elif cpython.buffer.PyObject_CheckBuffer(pyobj):
            err = cpython.buffer.PyObject_GetBuffer( 
                pyobj,
                &wrapper._py_buffer, 
                cpython.buffer.PyBUF_SIMPLE | cpython.buffer.PyBUF_ANY_CONTIGUOUS
            )
            if err == -1:
                raise RuntimeError("failed to create simple, contiguous Py_buffer from Python object")
            wrapper._py_buffer_acquired = True
            wrapper._ptr = <chip.hipArrayMapInfo_union_1_struct_0*>wrapper._py_buffer.buf
        else:
            raise TypeError(f"unsupported input type: '{str(type(pyobj))}'")
        return wrapper
    def __dealloc__(self):
        # Release the buffer handle
        if self._py_buffer_acquired is True:
            cpython.buffer.PyBuffer_Release(&self._py_buffer)
        # De-allocate if not null and flag is set
        if self._ptr is not NULL and self.ptr_owner is True:
            stdlib.free(self._ptr)
            self._ptr = NULL
    @staticmethod
    cdef __allocate(chip.hipArrayMapInfo_union_1_struct_0** ptr):
        ptr[0] = <chip.hipArrayMapInfo_union_1_struct_0*>stdlib.malloc(sizeof(chip.hipArrayMapInfo_union_1_struct_0))

        if ptr[0] is NULL:
            raise MemoryError
        # TODO init values, if present

    @staticmethod
    cdef hipArrayMapInfo_union_1_struct_0 new():
        """Factory function to create hipArrayMapInfo_union_1_struct_0 objects with
        newly allocated chip.hipArrayMapInfo_union_1_struct_0"""
        cdef chip.hipArrayMapInfo_union_1_struct_0* ptr
        hipArrayMapInfo_union_1_struct_0.__allocate(&ptr)
        return hipArrayMapInfo_union_1_struct_0.from_ptr(ptr, owner=True)
   
    def __init__(self,*args,**kwargs):
        hipArrayMapInfo_union_1_struct_0.__allocate(&self._ptr)
        self.ptr_owner = True
        attribs = self.PROPERTIES()
        used_attribs = set()
        if len(args) > len(attribs):
            raise ValueError("More positional arguments specified than this type has properties.")
        for i,v in enumerate(args):
            setattr(self,attribs[i],v)
            used_attribs.add(attribs[i])
        valid_names = ", ".join(["'"+p+"'" for p in attribs])
        for k,v in kwargs.items():
            if k in used_attribs:
                raise KeyError(f"argument '{k}' has already been specified as positional argument.")
            elif k not in attribs:
                raise KeyError(f"'{k}' is no valid property name. Valid names: {valid_names}")
            setattr(self,k,v)
    
    def __int__(self):
        """Returns the data's address as long integer."""
        return cpython.long.PyLong_FromVoidPtr(self._ptr)
    def __repr__(self):
        return f"<hipArrayMapInfo_union_1_struct_0 object, self.ptr={int(self)}>"
    def as_c_void_p(self):
        """Returns the data's address as `ctypes.c_void_p`"""
        return ctypes.c_void_p(int(self))
    def get_level(self, i):
        """Get value ``level`` of ``self._ptr[i]``.
        """
        return self._ptr[i].level
    def set_level(self, i, unsigned int value):
        """Set value ``level`` of ``self._ptr[i]``.
        """
        self._ptr[i].level = value
    @property
    def level(self):
        return self.get_level(0)
    @level.setter
    def level(self, unsigned int value):
        self.set_level(0,value)

    def get_layer(self, i):
        """Get value ``layer`` of ``self._ptr[i]``.
        """
        return self._ptr[i].layer
    def set_layer(self, i, unsigned int value):
        """Set value ``layer`` of ``self._ptr[i]``.
        """
        self._ptr[i].layer = value
    @property
    def layer(self):
        return self.get_layer(0)
    @layer.setter
    def layer(self, unsigned int value):
        self.set_layer(0,value)

    def get_offsetX(self, i):
        """Get value ``offsetX`` of ``self._ptr[i]``.
        """
        return self._ptr[i].offsetX
    def set_offsetX(self, i, unsigned int value):
        """Set value ``offsetX`` of ``self._ptr[i]``.
        """
        self._ptr[i].offsetX = value
    @property
    def offsetX(self):
        return self.get_offsetX(0)
    @offsetX.setter
    def offsetX(self, unsigned int value):
        self.set_offsetX(0,value)

    def get_offsetY(self, i):
        """Get value ``offsetY`` of ``self._ptr[i]``.
        """
        return self._ptr[i].offsetY
    def set_offsetY(self, i, unsigned int value):
        """Set value ``offsetY`` of ``self._ptr[i]``.
        """
        self._ptr[i].offsetY = value
    @property
    def offsetY(self):
        return self.get_offsetY(0)
    @offsetY.setter
    def offsetY(self, unsigned int value):
        self.set_offsetY(0,value)

    def get_offsetZ(self, i):
        """Get value ``offsetZ`` of ``self._ptr[i]``.
        """
        return self._ptr[i].offsetZ
    def set_offsetZ(self, i, unsigned int value):
        """Set value ``offsetZ`` of ``self._ptr[i]``.
        """
        self._ptr[i].offsetZ = value
    @property
    def offsetZ(self):
        return self.get_offsetZ(0)
    @offsetZ.setter
    def offsetZ(self, unsigned int value):
        self.set_offsetZ(0,value)

    def get_extentWidth(self, i):
        """Get value ``extentWidth`` of ``self._ptr[i]``.
        """
        return self._ptr[i].extentWidth
    def set_extentWidth(self, i, unsigned int value):
        """Set value ``extentWidth`` of ``self._ptr[i]``.
        """
        self._ptr[i].extentWidth = value
    @property
    def extentWidth(self):
        return self.get_extentWidth(0)
    @extentWidth.setter
    def extentWidth(self, unsigned int value):
        self.set_extentWidth(0,value)

    def get_extentHeight(self, i):
        """Get value ``extentHeight`` of ``self._ptr[i]``.
        """
        return self._ptr[i].extentHeight
    def set_extentHeight(self, i, unsigned int value):
        """Set value ``extentHeight`` of ``self._ptr[i]``.
        """
        self._ptr[i].extentHeight = value
    @property
    def extentHeight(self):
        return self.get_extentHeight(0)
    @extentHeight.setter
    def extentHeight(self, unsigned int value):
        self.set_extentHeight(0,value)

    def get_extentDepth(self, i):
        """Get value ``extentDepth`` of ``self._ptr[i]``.
        """
        return self._ptr[i].extentDepth
    def set_extentDepth(self, i, unsigned int value):
        """Set value ``extentDepth`` of ``self._ptr[i]``.
        """
        self._ptr[i].extentDepth = value
    @property
    def extentDepth(self):
        return self.get_extentDepth(0)
    @extentDepth.setter
    def extentDepth(self, unsigned int value):
        self.set_extentDepth(0,value)

    @staticmethod
    def PROPERTIES():
        return ["level","layer","offsetX","offsetY","offsetZ","extentWidth","extentHeight","extentDepth"]

    def __contains__(self,item):
        properties = self.PROPERTIES()
        return item in properties

    def __getitem__(self,item):
        properties = self.PROPERTIES()
        if isinstance(item,int):
            if item < 0 or item >= len(properties):
                raise IndexError()
            return getattr(self,properties[item])
        raise ValueError("'item' type must be 'int'")


cdef class hipArrayMapInfo_union_1_struct_1:
    # members declared in pxd file

    def __cinit__(self):
        self._ptr = NULL
        self.ptr_owner = False
        self._py_buffer_acquired = False

    @staticmethod
    cdef hipArrayMapInfo_union_1_struct_1 from_ptr(chip.hipArrayMapInfo_union_1_struct_1* ptr, bint owner=False):
        """Factory function to create ``hipArrayMapInfo_union_1_struct_1`` objects from
        given ``chip.hipArrayMapInfo_union_1_struct_1`` pointer.

        Setting ``owner`` flag to ``True`` causes
        the extension type to ``free`` the structure pointed to by ``ptr``
        when the wrapper object is deallocated.
        """
        # Fast call to __new__() that bypasses the __init__() constructor.
        cdef hipArrayMapInfo_union_1_struct_1 wrapper = hipArrayMapInfo_union_1_struct_1.__new__(hipArrayMapInfo_union_1_struct_1)
        wrapper._ptr = ptr
        wrapper.ptr_owner = owner
        return wrapper

    @staticmethod
    cdef hipArrayMapInfo_union_1_struct_1 from_pyobj(object pyobj):
        """Derives a hipArrayMapInfo_union_1_struct_1 from a Python object.

        Derives a hipArrayMapInfo_union_1_struct_1 from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``hipArrayMapInfo_union_1_struct_1`` reference, this method
        returns it directly. No new ``hipArrayMapInfo_union_1_struct_1`` is created in this case.

        Args:
            pyobj (object): Must be either ``None``, a simple, contiguous buffer according to the buffer protocol,
                            or of type ``hipArrayMapInfo_union_1_struct_1``, ``int``, or ``ctypes.c_void_p``

        Note:
            This routine does not perform a copy but returns the original ``pyobj``
            if ``pyobj`` is an instance of hipArrayMapInfo_union_1_struct_1!
        """
        cdef hipArrayMapInfo_union_1_struct_1 wrapper = hipArrayMapInfo_union_1_struct_1.__new__(hipArrayMapInfo_union_1_struct_1)
        cdef dict cuda_array_interface = getattr(pyobj, "__cuda_array_interface__", None)

        if pyobj is None:
            wrapper._ptr = NULL
        elif isinstance(pyobj,hipArrayMapInfo_union_1_struct_1):
            return pyobj
        elif isinstance(pyobj,int):
            wrapper._ptr = <chip.hipArrayMapInfo_union_1_struct_1*>cpython.long.PyLong_AsVoidPtr(pyobj)
        elif isinstance(pyobj,ctypes.c_void_p):
            wrapper._ptr = <chip.hipArrayMapInfo_union_1_struct_1*>cpython.long.PyLong_AsVoidPtr(pyobj.value) if pyobj.value != None else NULL
        elif cuda_array_interface != None:
            if not "data" in cuda_array_interface:
                raise ValueError("input object has '__cuda_array_interface__' attribute but the dict has no 'data' key")
            ptr_as_int = cuda_array_interface["data"][0]
            wrapper._ptr = <chip.hipArrayMapInfo_union_1_struct_1*>cpython.long.PyLong_AsVoidPtr(ptr_as_int)
        elif cpython.buffer.PyObject_CheckBuffer(pyobj):
            err = cpython.buffer.PyObject_GetBuffer( 
                pyobj,
                &wrapper._py_buffer, 
                cpython.buffer.PyBUF_SIMPLE | cpython.buffer.PyBUF_ANY_CONTIGUOUS
            )
            if err == -1:
                raise RuntimeError("failed to create simple, contiguous Py_buffer from Python object")
            wrapper._py_buffer_acquired = True
            wrapper._ptr = <chip.hipArrayMapInfo_union_1_struct_1*>wrapper._py_buffer.buf
        else:
            raise TypeError(f"unsupported input type: '{str(type(pyobj))}'")
        return wrapper
    def __dealloc__(self):
        # Release the buffer handle
        if self._py_buffer_acquired is True:
            cpython.buffer.PyBuffer_Release(&self._py_buffer)
        # De-allocate if not null and flag is set
        if self._ptr is not NULL and self.ptr_owner is True:
            stdlib.free(self._ptr)
            self._ptr = NULL
    @staticmethod
    cdef __allocate(chip.hipArrayMapInfo_union_1_struct_1** ptr):
        ptr[0] = <chip.hipArrayMapInfo_union_1_struct_1*>stdlib.malloc(sizeof(chip.hipArrayMapInfo_union_1_struct_1))

        if ptr[0] is NULL:
            raise MemoryError
        # TODO init values, if present

    @staticmethod
    cdef hipArrayMapInfo_union_1_struct_1 new():
        """Factory function to create hipArrayMapInfo_union_1_struct_1 objects with
        newly allocated chip.hipArrayMapInfo_union_1_struct_1"""
        cdef chip.hipArrayMapInfo_union_1_struct_1* ptr
        hipArrayMapInfo_union_1_struct_1.__allocate(&ptr)
        return hipArrayMapInfo_union_1_struct_1.from_ptr(ptr, owner=True)
   
    def __init__(self,*args,**kwargs):
        hipArrayMapInfo_union_1_struct_1.__allocate(&self._ptr)
        self.ptr_owner = True
        attribs = self.PROPERTIES()
        used_attribs = set()
        if len(args) > len(attribs):
            raise ValueError("More positional arguments specified than this type has properties.")
        for i,v in enumerate(args):
            setattr(self,attribs[i],v)
            used_attribs.add(attribs[i])
        valid_names = ", ".join(["'"+p+"'" for p in attribs])
        for k,v in kwargs.items():
            if k in used_attribs:
                raise KeyError(f"argument '{k}' has already been specified as positional argument.")
            elif k not in attribs:
                raise KeyError(f"'{k}' is no valid property name. Valid names: {valid_names}")
            setattr(self,k,v)
    
    def __int__(self):
        """Returns the data's address as long integer."""
        return cpython.long.PyLong_FromVoidPtr(self._ptr)
    def __repr__(self):
        return f"<hipArrayMapInfo_union_1_struct_1 object, self.ptr={int(self)}>"
    def as_c_void_p(self):
        """Returns the data's address as `ctypes.c_void_p`"""
        return ctypes.c_void_p(int(self))
    def get_layer(self, i):
        """Get value ``layer`` of ``self._ptr[i]``.
        """
        return self._ptr[i].layer
    def set_layer(self, i, unsigned int value):
        """Set value ``layer`` of ``self._ptr[i]``.
        """
        self._ptr[i].layer = value
    @property
    def layer(self):
        return self.get_layer(0)
    @layer.setter
    def layer(self, unsigned int value):
        self.set_layer(0,value)

    def get_offset(self, i):
        """Get value ``offset`` of ``self._ptr[i]``.
        """
        return self._ptr[i].offset
    def set_offset(self, i, unsigned long long value):
        """Set value ``offset`` of ``self._ptr[i]``.
        """
        self._ptr[i].offset = value
    @property
    def offset(self):
        return self.get_offset(0)
    @offset.setter
    def offset(self, unsigned long long value):
        self.set_offset(0,value)

    def get_size(self, i):
        """Get value ``size`` of ``self._ptr[i]``.
        """
        return self._ptr[i].size
    def set_size(self, i, unsigned long long value):
        """Set value ``size`` of ``self._ptr[i]``.
        """
        self._ptr[i].size = value
    @property
    def size(self):
        return self.get_size(0)
    @size.setter
    def size(self, unsigned long long value):
        self.set_size(0,value)

    @staticmethod
    def PROPERTIES():
        return ["layer","offset","size"]

    def __contains__(self,item):
        properties = self.PROPERTIES()
        return item in properties

    def __getitem__(self,item):
        properties = self.PROPERTIES()
        if isinstance(item,int):
            if item < 0 or item >= len(properties):
                raise IndexError()
            return getattr(self,properties[item])
        raise ValueError("'item' type must be 'int'")


cdef class hipArrayMapInfo_union_1:
    # members declared in pxd file

    def __cinit__(self):
        self._ptr = NULL
        self.ptr_owner = False
        self._py_buffer_acquired = False

    @staticmethod
    cdef hipArrayMapInfo_union_1 from_ptr(chip.hipArrayMapInfo_union_1* ptr, bint owner=False):
        """Factory function to create ``hipArrayMapInfo_union_1`` objects from
        given ``chip.hipArrayMapInfo_union_1`` pointer.

        Setting ``owner`` flag to ``True`` causes
        the extension type to ``free`` the structure pointed to by ``ptr``
        when the wrapper object is deallocated.
        """
        # Fast call to __new__() that bypasses the __init__() constructor.
        cdef hipArrayMapInfo_union_1 wrapper = hipArrayMapInfo_union_1.__new__(hipArrayMapInfo_union_1)
        wrapper._ptr = ptr
        wrapper.ptr_owner = owner
        return wrapper

    @staticmethod
    cdef hipArrayMapInfo_union_1 from_pyobj(object pyobj):
        """Derives a hipArrayMapInfo_union_1 from a Python object.

        Derives a hipArrayMapInfo_union_1 from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``hipArrayMapInfo_union_1`` reference, this method
        returns it directly. No new ``hipArrayMapInfo_union_1`` is created in this case.

        Args:
            pyobj (object): Must be either ``None``, a simple, contiguous buffer according to the buffer protocol,
                            or of type ``hipArrayMapInfo_union_1``, ``int``, or ``ctypes.c_void_p``

        Note:
            This routine does not perform a copy but returns the original ``pyobj``
            if ``pyobj`` is an instance of hipArrayMapInfo_union_1!
        """
        cdef hipArrayMapInfo_union_1 wrapper = hipArrayMapInfo_union_1.__new__(hipArrayMapInfo_union_1)
        cdef dict cuda_array_interface = getattr(pyobj, "__cuda_array_interface__", None)

        if pyobj is None:
            wrapper._ptr = NULL
        elif isinstance(pyobj,hipArrayMapInfo_union_1):
            return pyobj
        elif isinstance(pyobj,int):
            wrapper._ptr = <chip.hipArrayMapInfo_union_1*>cpython.long.PyLong_AsVoidPtr(pyobj)
        elif isinstance(pyobj,ctypes.c_void_p):
            wrapper._ptr = <chip.hipArrayMapInfo_union_1*>cpython.long.PyLong_AsVoidPtr(pyobj.value) if pyobj.value != None else NULL
        elif cuda_array_interface != None:
            if not "data" in cuda_array_interface:
                raise ValueError("input object has '__cuda_array_interface__' attribute but the dict has no 'data' key")
            ptr_as_int = cuda_array_interface["data"][0]
            wrapper._ptr = <chip.hipArrayMapInfo_union_1*>cpython.long.PyLong_AsVoidPtr(ptr_as_int)
        elif cpython.buffer.PyObject_CheckBuffer(pyobj):
            err = cpython.buffer.PyObject_GetBuffer( 
                pyobj,
                &wrapper._py_buffer, 
                cpython.buffer.PyBUF_SIMPLE | cpython.buffer.PyBUF_ANY_CONTIGUOUS
            )
            if err == -1:
                raise RuntimeError("failed to create simple, contiguous Py_buffer from Python object")
            wrapper._py_buffer_acquired = True
            wrapper._ptr = <chip.hipArrayMapInfo_union_1*>wrapper._py_buffer.buf
        else:
            raise TypeError(f"unsupported input type: '{str(type(pyobj))}'")
        return wrapper
    def __dealloc__(self):
        # Release the buffer handle
        if self._py_buffer_acquired is True:
            cpython.buffer.PyBuffer_Release(&self._py_buffer)
        # De-allocate if not null and flag is set
        if self._ptr is not NULL and self.ptr_owner is True:
            stdlib.free(self._ptr)
            self._ptr = NULL
    @staticmethod
    cdef __allocate(chip.hipArrayMapInfo_union_1** ptr):
        ptr[0] = <chip.hipArrayMapInfo_union_1*>stdlib.malloc(sizeof(chip.hipArrayMapInfo_union_1))

        if ptr[0] is NULL:
            raise MemoryError
        # TODO init values, if present

    @staticmethod
    cdef hipArrayMapInfo_union_1 new():
        """Factory function to create hipArrayMapInfo_union_1 objects with
        newly allocated chip.hipArrayMapInfo_union_1"""
        cdef chip.hipArrayMapInfo_union_1* ptr
        hipArrayMapInfo_union_1.__allocate(&ptr)
        return hipArrayMapInfo_union_1.from_ptr(ptr, owner=True)
   
    # True
    # True
    def __init__(self,**kwargs):
        hipArrayMapInfo_union_1.__allocate(&self._ptr)
        self.ptr_owner = True
        attribs = self.PROPERTIES()
        used_attribs = set()
        if len(kwargs) > 1:
            raise ValueError("Not more than one attribute might specified for Python types derived from C union types.")
        valid_names = ", ".join(["'"+p+"'" for p in attribs])
        for k,v in kwargs.items():
            if k in used_attribs:
                raise KeyError(f"argument '{k}' has already been specified as positional argument.")
            elif k not in attribs:
                raise KeyError(f"'{k}' is no valid property name. Valid names: {valid_names}")
            setattr(self,k,v)
    
    def __int__(self):
        """Returns the data's address as long integer."""
        return cpython.long.PyLong_FromVoidPtr(self._ptr)
    def __repr__(self):
        return f"<hipArrayMapInfo_union_1 object, self.ptr={int(self)}>"
    def as_c_void_p(self):
        """Returns the data's address as `ctypes.c_void_p`"""
        return ctypes.c_void_p(int(self))
    def get_sparseLevel(self, i):
        """Get value of ``sparseLevel`` of ``self._ptr[i]``.
        """
        return hipArrayMapInfo_union_1_struct_0.from_ptr(&self._ptr[i].sparseLevel)
    @property
    def sparseLevel(self):
        return self.get_sparseLevel(0)

    def get_miptail(self, i):
        """Get value of ``miptail`` of ``self._ptr[i]``.
        """
        return hipArrayMapInfo_union_1_struct_1.from_ptr(&self._ptr[i].miptail)
    @property
    def miptail(self):
        return self.get_miptail(0)

    @staticmethod
    def PROPERTIES():
        return ["sparseLevel","miptail"]


cdef class hipArrayMapInfo_union_2:
    # members declared in pxd file

    def __cinit__(self):
        self._ptr = NULL
        self.ptr_owner = False
        self._py_buffer_acquired = False

    @staticmethod
    cdef hipArrayMapInfo_union_2 from_ptr(chip.hipArrayMapInfo_union_2* ptr, bint owner=False):
        """Factory function to create ``hipArrayMapInfo_union_2`` objects from
        given ``chip.hipArrayMapInfo_union_2`` pointer.

        Setting ``owner`` flag to ``True`` causes
        the extension type to ``free`` the structure pointed to by ``ptr``
        when the wrapper object is deallocated.
        """
        # Fast call to __new__() that bypasses the __init__() constructor.
        cdef hipArrayMapInfo_union_2 wrapper = hipArrayMapInfo_union_2.__new__(hipArrayMapInfo_union_2)
        wrapper._ptr = ptr
        wrapper.ptr_owner = owner
        return wrapper

    @staticmethod
    cdef hipArrayMapInfo_union_2 from_pyobj(object pyobj):
        """Derives a hipArrayMapInfo_union_2 from a Python object.

        Derives a hipArrayMapInfo_union_2 from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``hipArrayMapInfo_union_2`` reference, this method
        returns it directly. No new ``hipArrayMapInfo_union_2`` is created in this case.

        Args:
            pyobj (object): Must be either ``None``, a simple, contiguous buffer according to the buffer protocol,
                            or of type ``hipArrayMapInfo_union_2``, ``int``, or ``ctypes.c_void_p``

        Note:
            This routine does not perform a copy but returns the original ``pyobj``
            if ``pyobj`` is an instance of hipArrayMapInfo_union_2!
        """
        cdef hipArrayMapInfo_union_2 wrapper = hipArrayMapInfo_union_2.__new__(hipArrayMapInfo_union_2)
        cdef dict cuda_array_interface = getattr(pyobj, "__cuda_array_interface__", None)

        if pyobj is None:
            wrapper._ptr = NULL
        elif isinstance(pyobj,hipArrayMapInfo_union_2):
            return pyobj
        elif isinstance(pyobj,int):
            wrapper._ptr = <chip.hipArrayMapInfo_union_2*>cpython.long.PyLong_AsVoidPtr(pyobj)
        elif isinstance(pyobj,ctypes.c_void_p):
            wrapper._ptr = <chip.hipArrayMapInfo_union_2*>cpython.long.PyLong_AsVoidPtr(pyobj.value) if pyobj.value != None else NULL
        elif cuda_array_interface != None:
            if not "data" in cuda_array_interface:
                raise ValueError("input object has '__cuda_array_interface__' attribute but the dict has no 'data' key")
            ptr_as_int = cuda_array_interface["data"][0]
            wrapper._ptr = <chip.hipArrayMapInfo_union_2*>cpython.long.PyLong_AsVoidPtr(ptr_as_int)
        elif cpython.buffer.PyObject_CheckBuffer(pyobj):
            err = cpython.buffer.PyObject_GetBuffer( 
                pyobj,
                &wrapper._py_buffer, 
                cpython.buffer.PyBUF_SIMPLE | cpython.buffer.PyBUF_ANY_CONTIGUOUS
            )
            if err == -1:
                raise RuntimeError("failed to create simple, contiguous Py_buffer from Python object")
            wrapper._py_buffer_acquired = True
            wrapper._ptr = <chip.hipArrayMapInfo_union_2*>wrapper._py_buffer.buf
        else:
            raise TypeError(f"unsupported input type: '{str(type(pyobj))}'")
        return wrapper
    def __dealloc__(self):
        # Release the buffer handle
        if self._py_buffer_acquired is True:
            cpython.buffer.PyBuffer_Release(&self._py_buffer)
        # De-allocate if not null and flag is set
        if self._ptr is not NULL and self.ptr_owner is True:
            stdlib.free(self._ptr)
            self._ptr = NULL
    @staticmethod
    cdef __allocate(chip.hipArrayMapInfo_union_2** ptr):
        ptr[0] = <chip.hipArrayMapInfo_union_2*>stdlib.malloc(sizeof(chip.hipArrayMapInfo_union_2))

        if ptr[0] is NULL:
            raise MemoryError
        # TODO init values, if present

    @staticmethod
    cdef hipArrayMapInfo_union_2 new():
        """Factory function to create hipArrayMapInfo_union_2 objects with
        newly allocated chip.hipArrayMapInfo_union_2"""
        cdef chip.hipArrayMapInfo_union_2* ptr
        hipArrayMapInfo_union_2.__allocate(&ptr)
        return hipArrayMapInfo_union_2.from_ptr(ptr, owner=True)
   
    # False
    # True
    def __init__(self,**kwargs):
        hipArrayMapInfo_union_2.__allocate(&self._ptr)
        self.ptr_owner = True
        attribs = self.PROPERTIES()
        used_attribs = set()
        if len(kwargs) > 1:
            raise ValueError("Not more than one attribute might specified for Python types derived from C union types.")
        valid_names = ", ".join(["'"+p+"'" for p in attribs])
        for k,v in kwargs.items():
            if k in used_attribs:
                raise KeyError(f"argument '{k}' has already been specified as positional argument.")
            elif k not in attribs:
                raise KeyError(f"'{k}' is no valid property name. Valid names: {valid_names}")
            setattr(self,k,v)
    
    def __int__(self):
        """Returns the data's address as long integer."""
        return cpython.long.PyLong_FromVoidPtr(self._ptr)
    def __repr__(self):
        return f"<hipArrayMapInfo_union_2 object, self.ptr={int(self)}>"
    def as_c_void_p(self):
        """Returns the data's address as `ctypes.c_void_p`"""
        return ctypes.c_void_p(int(self))
    @staticmethod
    def PROPERTIES():
        return []


cdef class hipArrayMapInfo:
    # members declared in pxd file

    def __cinit__(self):
        self._ptr = NULL
        self.ptr_owner = False
        self._py_buffer_acquired = False

    @staticmethod
    cdef hipArrayMapInfo from_ptr(chip.hipArrayMapInfo* ptr, bint owner=False):
        """Factory function to create ``hipArrayMapInfo`` objects from
        given ``chip.hipArrayMapInfo`` pointer.

        Setting ``owner`` flag to ``True`` causes
        the extension type to ``free`` the structure pointed to by ``ptr``
        when the wrapper object is deallocated.
        """
        # Fast call to __new__() that bypasses the __init__() constructor.
        cdef hipArrayMapInfo wrapper = hipArrayMapInfo.__new__(hipArrayMapInfo)
        wrapper._ptr = ptr
        wrapper.ptr_owner = owner
        return wrapper

    @staticmethod
    cdef hipArrayMapInfo from_pyobj(object pyobj):
        """Derives a hipArrayMapInfo from a Python object.

        Derives a hipArrayMapInfo from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``hipArrayMapInfo`` reference, this method
        returns it directly. No new ``hipArrayMapInfo`` is created in this case.

        Args:
            pyobj (object): Must be either ``None``, a simple, contiguous buffer according to the buffer protocol,
                            or of type ``hipArrayMapInfo``, ``int``, or ``ctypes.c_void_p``

        Note:
            This routine does not perform a copy but returns the original ``pyobj``
            if ``pyobj`` is an instance of hipArrayMapInfo!
        """
        cdef hipArrayMapInfo wrapper = hipArrayMapInfo.__new__(hipArrayMapInfo)
        cdef dict cuda_array_interface = getattr(pyobj, "__cuda_array_interface__", None)

        if pyobj is None:
            wrapper._ptr = NULL
        elif isinstance(pyobj,hipArrayMapInfo):
            return pyobj
        elif isinstance(pyobj,int):
            wrapper._ptr = <chip.hipArrayMapInfo*>cpython.long.PyLong_AsVoidPtr(pyobj)
        elif isinstance(pyobj,ctypes.c_void_p):
            wrapper._ptr = <chip.hipArrayMapInfo*>cpython.long.PyLong_AsVoidPtr(pyobj.value) if pyobj.value != None else NULL
        elif cuda_array_interface != None:
            if not "data" in cuda_array_interface:
                raise ValueError("input object has '__cuda_array_interface__' attribute but the dict has no 'data' key")
            ptr_as_int = cuda_array_interface["data"][0]
            wrapper._ptr = <chip.hipArrayMapInfo*>cpython.long.PyLong_AsVoidPtr(ptr_as_int)
        elif cpython.buffer.PyObject_CheckBuffer(pyobj):
            err = cpython.buffer.PyObject_GetBuffer( 
                pyobj,
                &wrapper._py_buffer, 
                cpython.buffer.PyBUF_SIMPLE | cpython.buffer.PyBUF_ANY_CONTIGUOUS
            )
            if err == -1:
                raise RuntimeError("failed to create simple, contiguous Py_buffer from Python object")
            wrapper._py_buffer_acquired = True
            wrapper._ptr = <chip.hipArrayMapInfo*>wrapper._py_buffer.buf
        else:
            raise TypeError(f"unsupported input type: '{str(type(pyobj))}'")
        return wrapper
    def __dealloc__(self):
        # Release the buffer handle
        if self._py_buffer_acquired is True:
            cpython.buffer.PyBuffer_Release(&self._py_buffer)
        # De-allocate if not null and flag is set
        if self._ptr is not NULL and self.ptr_owner is True:
            stdlib.free(self._ptr)
            self._ptr = NULL
    @staticmethod
    cdef __allocate(chip.hipArrayMapInfo** ptr):
        ptr[0] = <chip.hipArrayMapInfo*>stdlib.malloc(sizeof(chip.hipArrayMapInfo))

        if ptr[0] is NULL:
            raise MemoryError
        # TODO init values, if present

    @staticmethod
    cdef hipArrayMapInfo new():
        """Factory function to create hipArrayMapInfo objects with
        newly allocated chip.hipArrayMapInfo"""
        cdef chip.hipArrayMapInfo* ptr
        hipArrayMapInfo.__allocate(&ptr)
        return hipArrayMapInfo.from_ptr(ptr, owner=True)
   
    def __init__(self,*args,**kwargs):
        hipArrayMapInfo.__allocate(&self._ptr)
        self.ptr_owner = True
        attribs = self.PROPERTIES()
        used_attribs = set()
        if len(args) > len(attribs):
            raise ValueError("More positional arguments specified than this type has properties.")
        for i,v in enumerate(args):
            setattr(self,attribs[i],v)
            used_attribs.add(attribs[i])
        valid_names = ", ".join(["'"+p+"'" for p in attribs])
        for k,v in kwargs.items():
            if k in used_attribs:
                raise KeyError(f"argument '{k}' has already been specified as positional argument.")
            elif k not in attribs:
                raise KeyError(f"'{k}' is no valid property name. Valid names: {valid_names}")
            setattr(self,k,v)
    
    def __int__(self):
        """Returns the data's address as long integer."""
        return cpython.long.PyLong_FromVoidPtr(self._ptr)
    def __repr__(self):
        return f"<hipArrayMapInfo object, self.ptr={int(self)}>"
    def as_c_void_p(self):
        """Returns the data's address as `ctypes.c_void_p`"""
        return ctypes.c_void_p(int(self))
    def get_resourceType(self, i):
        """Get value of ``resourceType`` of ``self._ptr[i]``.
        """
        return hipResourceType(self._ptr[i].resourceType)
    def set_resourceType(self, i, value):
        """Set value ``resourceType`` of ``self._ptr[i]``.
        """
        if not isinstance(value, hipResourceType):
            raise TypeError("'value' must be of type 'hipResourceType'")
        self._ptr[i].resourceType = value.value
    @property
    def resourceType(self):
        return self.get_resourceType(0)
    @resourceType.setter
    def resourceType(self, value):
        self.set_resourceType(0,value)

    def get_resource(self, i):
        """Get value of ``resource`` of ``self._ptr[i]``.
        """
        return hipArrayMapInfo_union_0.from_ptr(&self._ptr[i].resource)
    @property
    def resource(self):
        return self.get_resource(0)

    def get_subresourceType(self, i):
        """Get value of ``subresourceType`` of ``self._ptr[i]``.
        """
        return hipArraySparseSubresourceType(self._ptr[i].subresourceType)
    def set_subresourceType(self, i, value):
        """Set value ``subresourceType`` of ``self._ptr[i]``.
        """
        if not isinstance(value, hipArraySparseSubresourceType):
            raise TypeError("'value' must be of type 'hipArraySparseSubresourceType'")
        self._ptr[i].subresourceType = value.value
    @property
    def subresourceType(self):
        return self.get_subresourceType(0)
    @subresourceType.setter
    def subresourceType(self, value):
        self.set_subresourceType(0,value)

    def get_subresource(self, i):
        """Get value of ``subresource`` of ``self._ptr[i]``.
        """
        return hipArrayMapInfo_union_1.from_ptr(&self._ptr[i].subresource)
    @property
    def subresource(self):
        return self.get_subresource(0)

    def get_memOperationType(self, i):
        """Get value of ``memOperationType`` of ``self._ptr[i]``.
        """
        return hipMemOperationType(self._ptr[i].memOperationType)
    def set_memOperationType(self, i, value):
        """Set value ``memOperationType`` of ``self._ptr[i]``.
        """
        if not isinstance(value, hipMemOperationType):
            raise TypeError("'value' must be of type 'hipMemOperationType'")
        self._ptr[i].memOperationType = value.value
    @property
    def memOperationType(self):
        return self.get_memOperationType(0)
    @memOperationType.setter
    def memOperationType(self, value):
        self.set_memOperationType(0,value)

    def get_memHandleType(self, i):
        """Get value of ``memHandleType`` of ``self._ptr[i]``.
        """
        return hipMemHandleType(self._ptr[i].memHandleType)
    def set_memHandleType(self, i, value):
        """Set value ``memHandleType`` of ``self._ptr[i]``.
        """
        if not isinstance(value, hipMemHandleType):
            raise TypeError("'value' must be of type 'hipMemHandleType'")
        self._ptr[i].memHandleType = value.value
    @property
    def memHandleType(self):
        return self.get_memHandleType(0)
    @memHandleType.setter
    def memHandleType(self, value):
        self.set_memHandleType(0,value)

    def get_memHandle(self, i):
        """Get value of ``memHandle`` of ``self._ptr[i]``.
        """
        return hipArrayMapInfo_union_2.from_ptr(&self._ptr[i].memHandle)
    @property
    def memHandle(self):
        return self.get_memHandle(0)

    def get_offset(self, i):
        """Get value ``offset`` of ``self._ptr[i]``.
        """
        return self._ptr[i].offset
    def set_offset(self, i, unsigned long long value):
        """Set value ``offset`` of ``self._ptr[i]``.
        """
        self._ptr[i].offset = value
    @property
    def offset(self):
        return self.get_offset(0)
    @offset.setter
    def offset(self, unsigned long long value):
        self.set_offset(0,value)

    def get_deviceBitMask(self, i):
        """Get value ``deviceBitMask`` of ``self._ptr[i]``.
        """
        return self._ptr[i].deviceBitMask
    def set_deviceBitMask(self, i, unsigned int value):
        """Set value ``deviceBitMask`` of ``self._ptr[i]``.
        """
        self._ptr[i].deviceBitMask = value
    @property
    def deviceBitMask(self):
        return self.get_deviceBitMask(0)
    @deviceBitMask.setter
    def deviceBitMask(self, unsigned int value):
        self.set_deviceBitMask(0,value)

    def get_flags(self, i):
        """Get value ``flags`` of ``self._ptr[i]``.
        """
        return self._ptr[i].flags
    def set_flags(self, i, unsigned int value):
        """Set value ``flags`` of ``self._ptr[i]``.
        """
        self._ptr[i].flags = value
    @property
    def flags(self):
        return self.get_flags(0)
    @flags.setter
    def flags(self, unsigned int value):
        self.set_flags(0,value)

    def get_reserved(self, i):
        """Get value of ``reserved`` of ``self._ptr[i]``.
        """
        return self._ptr[i].reserved
    # TODO add setters
    #def set_reserved(self, i, unsigned int[2] value):
    #    """Set value ``reserved`` of ``self._ptr[i]``.
    #    """
    #    self._ptr[i].reserved = value
    @property
    def reserved(self):
        return self.get_reserved(0)
    # TODO add setters
    #@reserved.setter
    #def reserved(self, unsigned int[2] value):
    #    self.set_reserved(0,value)

    @staticmethod
    def PROPERTIES():
        return ["resourceType","resource","subresourceType","subresource","memOperationType","memHandleType","memHandle","offset","deviceBitMask","flags","reserved"]

    def __contains__(self,item):
        properties = self.PROPERTIES()
        return item in properties

    def __getitem__(self,item):
        properties = self.PROPERTIES()
        if isinstance(item,int):
            if item < 0 or item >= len(properties):
                raise IndexError()
            return getattr(self,properties[item])
        raise ValueError("'item' type must be 'int'")


@cython.embedsignature(True)
def hipInit(unsigned int flags):
    r"""Explicitly initializes the HIP runtime.

    Most HIP APIs implicitly initialize the HIP runtime.
    This API provides control over the timing of the initialization.
    """
    _hipInit__retval = hipError_t(chip.hipInit(flags))    # fully specified
    return (_hipInit__retval,)


@cython.embedsignature(True)
def hipDriverGetVersion():
    r"""Returns the approximate HIP driver version.

    Warning:
        The HIP feature set does not correspond to an exact CUDA SDK driver revision.
        This function always set *driverVersion to 4 as an approximation though HIP supports
        some features which were introduced in later CUDA SDK revisions.
        HIP apps code should not rely on the driver revision number here and should
        use arch feature flags to test device capabilities or conditional compilation.

    See:
        hipRuntimeGetVersion

    Returns:
        A ``tuple`` of size 2 that contains (in that order):
        - #hipSuccess, #hipErrorInvalidValue
        - driverVersion:
    """
    cdef int driverVersion
    _hipDriverGetVersion__retval = hipError_t(chip.hipDriverGetVersion(&driverVersion))    # fully specified
    return (_hipDriverGetVersion__retval,driverVersion)


@cython.embedsignature(True)
def hipRuntimeGetVersion():
    r"""Returns the approximate HIP Runtime version.

    Warning:
        The version definition of HIP runtime is different from CUDA.
        On AMD platform, the function returns HIP runtime version,
        while on NVIDIA platform, it returns CUDA runtime version.
        And there is no mapping/correlation between HIP version and CUDA version.

    See:
        hipDriverGetVersion

    Returns:
        A ``tuple`` of size 2 that contains (in that order):
        - #hipSuccess, #hipErrorInvalidValue
        - runtimeVersion:
    """
    cdef int runtimeVersion
    _hipRuntimeGetVersion__retval = hipError_t(chip.hipRuntimeGetVersion(&runtimeVersion))    # fully specified
    return (_hipRuntimeGetVersion__retval,runtimeVersion)


@cython.embedsignature(True)
def hipDeviceGet(int ordinal):
    r"""Returns a handle to a compute device

    Args:
        ordinal: **[in]** 

    Returns:
        A ``tuple`` of size 2 that contains (in that order):
        - #hipSuccess, #hipErrorInvalidDevice
        - device:
    """
    cdef int device
    _hipDeviceGet__retval = hipError_t(chip.hipDeviceGet(&device,ordinal))    # fully specified
    return (_hipDeviceGet__retval,device)


@cython.embedsignature(True)
def hipDeviceComputeCapability(int device):
    r"""Returns the compute capability of the device

    Args:
        device: **[in]** 

    Returns:
        A ``tuple`` of size 3 that contains (in that order):
        - #hipSuccess, #hipErrorInvalidDevice
        - major:
        - minor:
    """
    cdef int major
    cdef int minor
    _hipDeviceComputeCapability__retval = hipError_t(chip.hipDeviceComputeCapability(&major,&minor,device))    # fully specified
    return (_hipDeviceComputeCapability__retval,major,minor)


@cython.embedsignature(True)
def hipDeviceGetName(char * name, int len, int device):
    r"""Returns an identifer string for the device.

    Args:
        name: **[out]** 

        len: **[in]** 

        device: **[in]** 

    Returns:
        A ``tuple`` of size 1 that contains (in that order):
        - #hipSuccess, #hipErrorInvalidDevice
    """
    _hipDeviceGetName__retval = hipError_t(chip.hipDeviceGetName(name,len,device))    # fully specified
    return (_hipDeviceGetName__retval,)


@cython.embedsignature(True)
def hipDeviceGetUuid(object uuid, int device):
    r"""Returns an UUID for the device.[BETA]

    Beta:
        This API is marked as beta, meaning, while this is feature complete,
        it is still open to changes and may have outstanding issues.

    Args:
        uuid: **[out]** 

        device: **[in]** 

    Returns:
        A ``tuple`` of size 1 that contains (in that order):
        - #hipSuccess, #hipErrorInvalidDevice, #hipErrorInvalidValue, #hipErrorNotInitialized,
            #hipErrorDeinitialized
    """
    _hipDeviceGetUuid__retval = hipError_t(chip.hipDeviceGetUuid(
        hipUUID_t.from_pyobj(uuid)._ptr,device))    # fully specified
    return (_hipDeviceGetUuid__retval,)


@cython.embedsignature(True)
def hipDeviceGetP2PAttribute(object attr, int srcDevice, int dstDevice):
    r"""Returns a value for attr of link between two devices

    Args:
        attr: **[in]** 

        srcDevice: **[in]** 

        dstDevice: **[in]** 

    Returns:
        A ``tuple`` of size 2 that contains (in that order):
        - #hipSuccess, #hipErrorInvalidDevice
        - value:
    """
    cdef int value
    if not isinstance(attr,_hipDeviceP2PAttr__Base):
        raise TypeError("argument 'attr' must be of type '_hipDeviceP2PAttr__Base'")
    _hipDeviceGetP2PAttribute__retval = hipError_t(chip.hipDeviceGetP2PAttribute(&value,attr.value,srcDevice,dstDevice))    # fully specified
    return (_hipDeviceGetP2PAttribute__retval,value)


@cython.embedsignature(True)
def hipDeviceGetPCIBusId(char * pciBusId, int len, int device):
    r"""Returns a PCI Bus Id string for the device, overloaded to take int device ID.

    Args:
        pciBusId: **[out]** 

        len: **[in]** 

        device: **[in]** 

    Returns:
        A ``tuple`` of size 1 that contains (in that order):
        - #hipSuccess, #hipErrorInvalidDevice
    """
    _hipDeviceGetPCIBusId__retval = hipError_t(chip.hipDeviceGetPCIBusId(pciBusId,len,device))    # fully specified
    return (_hipDeviceGetPCIBusId__retval,)


@cython.embedsignature(True)
def hipDeviceGetByPCIBusId(const char * pciBusId):
    r"""Returns a handle to a compute device.

    Args:
        PCI: **[in]** Bus ID

    Returns:
        A ``tuple`` of size 2 that contains (in that order):
        - #hipSuccess, #hipErrorInvalidDevice, #hipErrorInvalidValue
        - device: handle
    """
    cdef int device
    _hipDeviceGetByPCIBusId__retval = hipError_t(chip.hipDeviceGetByPCIBusId(&device,pciBusId))    # fully specified
    return (_hipDeviceGetByPCIBusId__retval,device)


@cython.embedsignature(True)
def hipDeviceTotalMem(int device):
    r"""Returns the total amount of memory on the device.

    Args:
        device: **[in]** 

    Returns:
        A ``tuple`` of size 2 that contains (in that order):
        - #hipSuccess, #hipErrorInvalidDevice
        - bytes:
    """
    cdef unsigned long bytes
    _hipDeviceTotalMem__retval = hipError_t(chip.hipDeviceTotalMem(&bytes,device))    # fully specified
    return (_hipDeviceTotalMem__retval,bytes)


@cython.embedsignature(True)
def hipDeviceSynchronize():
    r"""Waits on all active streams on current device

    When this command is invoked, the host thread gets blocked until all the commands associated
    with streams associated with the device. HIP does not support multiple blocking modes (yet!).

    See:
        hipSetDevice, hipDeviceReset

    Returns:
        A ``tuple`` of size 1 that contains (in that order):
        - #hipSuccess
    """
    _hipDeviceSynchronize__retval = hipError_t(chip.hipDeviceSynchronize())    # fully specified
    return (_hipDeviceSynchronize__retval,)


@cython.embedsignature(True)
def hipDeviceReset():
    r"""The state of current device is discarded and updated to a fresh state.

    Calling this function deletes all streams created, memory allocated, kernels running, events
    created. Make sure that no other thread is using the device or streams, memory, kernels, events
    associated with the current device.

    See:
        hipDeviceSynchronize

    Returns:
        A ``tuple`` of size 1 that contains (in that order):
        - #hipSuccess
    """
    _hipDeviceReset__retval = hipError_t(chip.hipDeviceReset())    # fully specified
    return (_hipDeviceReset__retval,)


@cython.embedsignature(True)
def hipSetDevice(int deviceId):
    r"""Set default device to be used for subsequent hip API calls from this thread.

    Sets ``device`` as the default device for the calling host thread.  Valid device id's are 0...
    (hipGetDeviceCount()-1).

    Many HIP APIs implicitly use the "default device" :

    - Any device memory subsequently allocated from this host thread (using hipMalloc) will be
    allocated on device.
    - Any streams or events created from this host thread will be associated with device.
    - Any kernels launched from this host thread (using hipLaunchKernel) will be executed on device
    (unless a specific stream is specified, in which case the device associated with that stream will
    be used).

    This function may be called from any host thread.  Multiple host threads may use the same device.
    This function does no synchronization with the previous or new device, and has very little
    runtime overhead. Applications can use hipSetDevice to quickly switch the default device before
    making a HIP runtime call which uses the default device.

    The default device is stored in thread-local-storage for each thread.
    Thread-pool implementations may inherit the default device of the previous thread.  A good
    practice is to always call hipSetDevice at the start of HIP coding sequency to establish a known
    standard device.

    See:
        hipGetDevice, hipGetDeviceCount

    Args:
        deviceId: **[in]** Valid device in range 0...hipGetDeviceCount().

    Returns:
        A ``tuple`` of size 1 that contains (in that order):
        - #hipSuccess, #hipErrorInvalidDevice, #hipErrorDeviceAlreadyInUse
    """
    _hipSetDevice__retval = hipError_t(chip.hipSetDevice(deviceId))    # fully specified
    return (_hipSetDevice__retval,)


@cython.embedsignature(True)
def hipGetDevice():
    r"""Return the default device id for the calling host thread.

    HIP maintains an default device for each thread using thread-local-storage.
    This device is used implicitly for HIP runtime APIs called by this thread.
    hipGetDevice returns in * ``device`` the default device for the calling host thread.

    See:
        hipSetDevice, hipGetDevicesizeBytes

    Args:
        device: **[out]** device is written with the default device

    Returns:
        A ``tuple`` of size 1 that contains (in that order):
        - #hipSuccess, #hipErrorInvalidDevice, #hipErrorInvalidValue
    """
    cdef int deviceId
    _hipGetDevice__retval = hipError_t(chip.hipGetDevice(&deviceId))    # fully specified
    return (_hipGetDevice__retval,deviceId)


@cython.embedsignature(True)
def hipGetDeviceCount():
    r"""Return number of compute-capable devices.

    @param [output] count Returns number of compute-capable devices.

    Returns in ``*count`` the number of devices that have ability to run compute commands.  If there
    are no such devices, then ``hipGetDeviceCount`` will return #hipErrorNoDevice. If 1 or more
    devices can be found, then hipGetDeviceCount returns #hipSuccess.

    Returns:
        A ``tuple`` of size 1 that contains (in that order):
        - #hipSuccess, #hipErrorNoDevice
    """
    cdef int count
    _hipGetDeviceCount__retval = hipError_t(chip.hipGetDeviceCount(&count))    # fully specified
    return (_hipGetDeviceCount__retval,count)


@cython.embedsignature(True)
def hipDeviceGetAttribute(object pi, object attr, int deviceId):
    r"""Query for a specific device attribute.

    Args:
        pi: **[out]** pointer to value to return

        attr: **[in]** attribute to query

        deviceId: **[in]** which device to query for information

    Returns:
        A ``tuple`` of size 1 that contains (in that order):
        - #hipSuccess, #hipErrorInvalidDevice, #hipErrorInvalidValue
    """
    if not isinstance(attr,_hipDeviceAttribute_t__Base):
        raise TypeError("argument 'attr' must be of type '_hipDeviceAttribute_t__Base'")
    _hipDeviceGetAttribute__retval = hipError_t(chip.hipDeviceGetAttribute(
        <int *>hip._util.types.DataHandle.from_pyobj(pi)._ptr,attr.value,deviceId))    # fully specified
    return (_hipDeviceGetAttribute__retval,)


@cython.embedsignature(True)
def hipDeviceGetDefaultMemPool(int device):
    r"""Returns the default memory pool of the specified device

    See:
        hipDeviceGetDefaultMemPool, hipMallocAsync, hipMemPoolTrimTo, hipMemPoolGetAttribute,
        hipDeviceSetMemPool, hipMemPoolSetAttribute, hipMemPoolSetAccess, hipMemPoolGetAccess

    Warning:
        This API is marked as beta, meaning, while this is feature complete,
        it is still open to changes and may have outstanding issues.

    Args:
        device: **[in]** Device index for query the default memory pool

    Returns:
        A ``tuple`` of size 2 that contains (in that order):
        - #chipSuccess, #hipErrorInvalidDevice, #hipErrorInvalidValue, #hipErrorNotSupported
        - mem_pool: Default memory pool to return
    """
    mem_pool = ihipMemPoolHandle_t.from_ptr(NULL)
    _hipDeviceGetDefaultMemPool__retval = hipError_t(chip.hipDeviceGetDefaultMemPool(&mem_pool._ptr,device))    # fully specified
    return (_hipDeviceGetDefaultMemPool__retval,mem_pool)


@cython.embedsignature(True)
def hipDeviceSetMemPool(int device, object mem_pool):
    r"""Sets the current memory pool of a device

    The memory pool must be local to the specified device.
    ``hipMallocAsync`` allocates from the current mempool of the provided stream's device.
    By default, a device's current memory pool is its default memory pool.

    Note:
        Use ``hipMallocFromPoolAsync`` for asynchronous memory allocations from a device
        different than the one the stream runs on.

    See:
        hipDeviceGetDefaultMemPool, hipMallocAsync, hipMemPoolTrimTo, hipMemPoolGetAttribute,
        hipDeviceSetMemPool, hipMemPoolSetAttribute, hipMemPoolSetAccess, hipMemPoolGetAccess

    Warning:
        This API is marked as beta, meaning, while this is feature complete,
        it is still open to changes and may have outstanding issues.

    Args:
        device: **[in]** Device index for the update

        mem_pool: **[in]** Memory pool for update as the current on the specified device

    Returns:
        A ``tuple`` of size 1 that contains (in that order):
        - #hipSuccess, #hipErrorInvalidValue, #hipErrorInvalidDevice, #hipErrorNotSupported
    """
    _hipDeviceSetMemPool__retval = hipError_t(chip.hipDeviceSetMemPool(device,
        ihipMemPoolHandle_t.from_pyobj(mem_pool)._ptr))    # fully specified
    return (_hipDeviceSetMemPool__retval,)


@cython.embedsignature(True)
def hipDeviceGetMemPool(int device):
    r"""Gets the current memory pool for the specified device

    Returns the last pool provided to ``hipDeviceSetMemPool`` for this device
    or the device's default memory pool if ``hipDeviceSetMemPool`` has never been called.
    By default the current mempool is the default mempool for a device,
    otherwise the returned pool must have been set with ``hipDeviceSetMemPool.``

    See:
        hipDeviceGetDefaultMemPool, hipMallocAsync, hipMemPoolTrimTo, hipMemPoolGetAttribute,
        hipDeviceSetMemPool, hipMemPoolSetAttribute, hipMemPoolSetAccess, hipMemPoolGetAccess

    Warning:
        This API is marked as beta, meaning, while this is feature complete,
        it is still open to changes and may have outstanding issues.

    Args:
        device: **[in]** Device index to query the current memory pool

    Returns:
        A ``tuple`` of size 2 that contains (in that order):
        - #hipSuccess, #hipErrorInvalidValue, #hipErrorNotSupported
        - mem_pool: Current memory pool on the specified device
    """
    mem_pool = ihipMemPoolHandle_t.from_ptr(NULL)
    _hipDeviceGetMemPool__retval = hipError_t(chip.hipDeviceGetMemPool(&mem_pool._ptr,device))    # fully specified
    return (_hipDeviceGetMemPool__retval,mem_pool)


@cython.embedsignature(True)
def hipGetDeviceProperties(object prop, int deviceId):
    r"""Returns device properties.

    Bug:
        HCC always returns 0 for maxThreadsPerMultiProcessor

    Bug:
        HCC always returns 0 for regsPerBlock

    Bug:
        HCC always returns 0 for l2CacheSize

    Populates hipGetDeviceProperties with information for the specified device.

    Args:
        prop: **[out]** written with device properties

        deviceId: **[in]** which device to query for information

    Returns:
        A ``tuple`` of size 1 that contains (in that order):
        - #hipSuccess, #hipErrorInvalidDevice
    """
    _hipGetDeviceProperties__retval = hipError_t(chip.hipGetDeviceProperties(
        hipDeviceProp_t.from_pyobj(prop)._ptr,deviceId))    # fully specified
    return (_hipGetDeviceProperties__retval,)


@cython.embedsignature(True)
def hipDeviceSetCacheConfig(object cacheConfig):
    r"""Set L1/Shared cache partition.

    Args:
        cacheConfig: **[in]** 

    Returns:
        A ``tuple`` of size 1 that contains (in that order):
        - #hipSuccess, #hipErrorNotInitialized
            Note: AMD devices and some Nvidia GPUS do not support reconfigurable cache.  This hint is ignored
            on those architectures.
    """
    if not isinstance(cacheConfig,_hipFuncCache_t__Base):
        raise TypeError("argument 'cacheConfig' must be of type '_hipFuncCache_t__Base'")
    _hipDeviceSetCacheConfig__retval = hipError_t(chip.hipDeviceSetCacheConfig(cacheConfig.value))    # fully specified
    return (_hipDeviceSetCacheConfig__retval,)


@cython.embedsignature(True)
def hipDeviceGetCacheConfig():
    r"""Get Cache configuration for a specific Device

    Returns:
        A ``tuple`` of size 2 that contains (in that order):
        - #hipSuccess, #hipErrorNotInitialized
            Note: AMD devices and some Nvidia GPUS do not support reconfigurable cache.  This hint is ignored
            on those architectures.
        - cacheConfig:
    """
    cdef chip.hipFuncCache_t cacheConfig
    _hipDeviceGetCacheConfig__retval = hipError_t(chip.hipDeviceGetCacheConfig(&cacheConfig))    # fully specified
    return (_hipDeviceGetCacheConfig__retval,hipFuncCache_t(cacheConfig))


@cython.embedsignature(True)
def hipDeviceGetLimit(object limit):
    r"""Get Resource limits of current device

    Args:
        limit: **[in]** 

    Returns:
        A ``tuple`` of size 2 that contains (in that order):
        - #hipSuccess, #hipErrorUnsupportedLimit, #hipErrorInvalidValue
            Note: Currently, only hipLimitMallocHeapSize is available
        - pValue:
    """
    cdef unsigned long pValue
    if not isinstance(limit,_hipLimit_t__Base):
        raise TypeError("argument 'limit' must be of type '_hipLimit_t__Base'")
    _hipDeviceGetLimit__retval = hipError_t(chip.hipDeviceGetLimit(&pValue,limit.value))    # fully specified
    return (_hipDeviceGetLimit__retval,pValue)


@cython.embedsignature(True)
def hipDeviceSetLimit(object limit, unsigned long value):
    r"""Set Resource limits of current device

    Args:
        limit: **[in]** 

        value: **[in]** 

    Returns:
        A ``tuple`` of size 1 that contains (in that order):
        - #hipSuccess, #hipErrorUnsupportedLimit, #hipErrorInvalidValue
    """
    if not isinstance(limit,_hipLimit_t__Base):
        raise TypeError("argument 'limit' must be of type '_hipLimit_t__Base'")
    _hipDeviceSetLimit__retval = hipError_t(chip.hipDeviceSetLimit(limit.value,value))    # fully specified
    return (_hipDeviceSetLimit__retval,)


@cython.embedsignature(True)
def hipDeviceGetSharedMemConfig():
    r"""Returns bank width of shared memory for current device

    Note: AMD devices and some Nvidia GPUS do not support shared cache banking, and the hint is
    ignored on those architectures.

    Returns:
        A ``tuple`` of size 2 that contains (in that order):
        - #hipSuccess, #hipErrorInvalidValue, #hipErrorNotInitialized
        - pConfig:
    """
    cdef chip.hipSharedMemConfig pConfig
    _hipDeviceGetSharedMemConfig__retval = hipError_t(chip.hipDeviceGetSharedMemConfig(&pConfig))    # fully specified
    return (_hipDeviceGetSharedMemConfig__retval,hipSharedMemConfig(pConfig))


@cython.embedsignature(True)
def hipGetDeviceFlags():
    r"""Gets the flags set for current device

    Returns:
        A ``tuple`` of size 2 that contains (in that order):
        - #hipSuccess, #hipErrorInvalidDevice, #hipErrorInvalidValue
        - flags:
    """
    cdef unsigned int flags
    _hipGetDeviceFlags__retval = hipError_t(chip.hipGetDeviceFlags(&flags))    # fully specified
    return (_hipGetDeviceFlags__retval,flags)


@cython.embedsignature(True)
def hipDeviceSetSharedMemConfig(object config):
    r"""The bank width of shared memory on current device is set

    Note: AMD devices and some Nvidia GPUS do not support shared cache banking, and the hint is
    ignored on those architectures.

    Args:
        config: **[in]** 

    Returns:
        A ``tuple`` of size 1 that contains (in that order):
        - #hipSuccess, #hipErrorInvalidValue, #hipErrorNotInitialized
    """
    if not isinstance(config,_hipSharedMemConfig__Base):
        raise TypeError("argument 'config' must be of type '_hipSharedMemConfig__Base'")
    _hipDeviceSetSharedMemConfig__retval = hipError_t(chip.hipDeviceSetSharedMemConfig(config.value))    # fully specified
    return (_hipDeviceSetSharedMemConfig__retval,)


@cython.embedsignature(True)
def hipSetDeviceFlags(unsigned int flags):
    r"""The current device behavior is changed according the flags passed.

    The schedule flags impact how HIP waits for the completion of a command running on a device.
    hipDeviceScheduleSpin         : HIP runtime will actively spin in the thread which submitted the
    work until the command completes.  This offers the lowest latency, but will consume a CPU core
    and may increase power. hipDeviceScheduleYield        : The HIP runtime will yield the CPU to
    system so that other tasks can use it.  This may increase latency to detect the completion but
    will consume less power and is friendlier to other tasks in the system.
    hipDeviceScheduleBlockingSync : On ROCm platform, this is a synonym for hipDeviceScheduleYield.
    hipDeviceScheduleAuto         : Use a hueristic to select between Spin and Yield modes.  If the
    number of HIP contexts is greater than the number of logical processors in the system, use Spin
    scheduling.  Else use Yield scheduling.

    hipDeviceMapHost              : Allow mapping host memory.  On ROCM, this is always allowed and
    the flag is ignored. hipDeviceLmemResizeToMax      :

    Warning:
        ROCm silently ignores this flag.

    Args:
        flags: **[in]** 

    Returns:
        A ``tuple`` of size 1 that contains (in that order):
        - #hipSuccess, #hipErrorInvalidDevice, #hipErrorSetOnActiveProcess
    """
    _hipSetDeviceFlags__retval = hipError_t(chip.hipSetDeviceFlags(flags))    # fully specified
    return (_hipSetDeviceFlags__retval,)


@cython.embedsignature(True)
def hipChooseDevice(object prop):
    r"""Device which matches hipDeviceProp_t is returned

    Returns:
        A ``tuple`` of size 3 that contains (in that order):
        - #hipSuccess, #hipErrorInvalidValue
        - device: ID
        - device: properties pointer
    """
    cdef int device
    _hipChooseDevice__retval = hipError_t(chip.hipChooseDevice(&device,
        hipDeviceProp_t.from_pyobj(prop)._ptr))    # fully specified
    return (_hipChooseDevice__retval,device)


@cython.embedsignature(True)
def hipExtGetLinkTypeAndHopCount(int device1, int device2):
    r"""Returns the link type and hop count between two devices

    Queries and returns the HSA link type and the hop count between the two specified devices.

    Args:
        device1: **[in]** Ordinal for device1

        device2: **[in]** Ordinal for device2

    Returns:
        A ``tuple`` of size 3 that contains (in that order):
        - #hipSuccess, #hipInvalidDevice, #hipErrorRuntimeOther
        - linktype: Returns the link type (See hsa_amd_link_info_type_t) between the two devices
        - hopcount: Returns the hop count between the two devices
    """
    cdef unsigned int linktype
    cdef unsigned int hopcount
    _hipExtGetLinkTypeAndHopCount__retval = hipError_t(chip.hipExtGetLinkTypeAndHopCount(device1,device2,&linktype,&hopcount))    # fully specified
    return (_hipExtGetLinkTypeAndHopCount__retval,linktype,hopcount)


@cython.embedsignature(True)
def hipIpcGetMemHandle(object handle, object devPtr):
    r"""Gets an interprocess memory handle for an existing device memory
             allocation

    Takes a pointer to the base of an existing device memory allocation created
    with hipMalloc and exports it for use in another process. This is a
    lightweight operation and may be called multiple times on an allocation
    without adverse effects.

    If a region of memory is freed with hipFree and a subsequent call
    to hipMalloc returns memory with the same device address,
    hipIpcGetMemHandle will return a unique handle for the
    new memory.

    Args:
        handle:  Pointer to user allocated hipIpcMemHandle to return
            the handle in.

        devPtr:  Base pointer to previously allocated device memory

    Returns:
        A ``tuple`` of size 1 that contains (in that order):
        - hipSuccess,
            hipErrorInvalidHandle,
            hipErrorOutOfMemory,
            hipErrorMapFailed,
    """
    _hipIpcGetMemHandle__retval = hipError_t(chip.hipIpcGetMemHandle(
        hipIpcMemHandle_st.from_pyobj(handle)._ptr,
        <void *>hip._util.types.DataHandle.from_pyobj(devPtr)._ptr))    # fully specified
    return (_hipIpcGetMemHandle__retval,)


@cython.embedsignature(True)
def hipIpcOpenMemHandle(object handle, unsigned int flags):
    r"""Opens an interprocess memory handle exported from another process
             and returns a device pointer usable in the local process.

    Maps memory exported from another process with hipIpcGetMemHandle into
    the current device address space. For contexts on different devices
    hipIpcOpenMemHandle can attempt to enable peer access between the
    devices as if the user called hipDeviceEnablePeerAccess. This behavior is
    controlled by the hipIpcMemLazyEnablePeerAccess flag.
    hipDeviceCanAccessPeer can determine if a mapping is possible.

    Contexts that may open hipIpcMemHandles are restricted in the following way.
    hipIpcMemHandles from each device in a given process may only be opened
    by one context per device per other process.

    Memory returned from hipIpcOpenMemHandle must be freed with
    hipIpcCloseMemHandle.

    Calling hipFree on an exported memory region before calling
    hipIpcCloseMemHandle in the importing context will result in undefined
    behavior.

    Note:
        During multiple processes, using the same memory handle opened by the current context,
        there is no guarantee that the same device poiter will be returned in ``*devPtr.``
        This is diffrent from CUDA.

    Args:
        handle:  hipIpcMemHandle to open

        flags:  Flags for this operation. Must be specified as hipIpcMemLazyEnablePeerAccess

    Returns:
        A ``tuple`` of size 2 that contains (in that order):
        - hipSuccess,
            hipErrorMapFailed,
            hipErrorInvalidHandle,
            hipErrorTooManyPeers
        - devPtr:  Returned device pointer
    """
    devPtr = hip._util.types.DataHandle.from_ptr(NULL)
    _hipIpcOpenMemHandle__retval = hipError_t(chip.hipIpcOpenMemHandle(
        <void **>&devPtr._ptr,
        hipIpcMemHandle_st.from_pyobj(handle)._ptr[0],flags))    # fully specified
    return (_hipIpcOpenMemHandle__retval,devPtr)


@cython.embedsignature(True)
def hipIpcCloseMemHandle(object devPtr):
    r"""Close memory mapped with hipIpcOpenMemHandle

    Unmaps memory returnd by hipIpcOpenMemHandle. The original allocation
    in the exporting process as well as imported mappings in other processes
    will be unaffected.

    Any resources used to enable peer access will be freed if this is the
    last mapping using them.

    Args:
        devPtr:  Device pointer returned by hipIpcOpenMemHandle

    Returns:
        A ``tuple`` of size 1 that contains (in that order):
        - hipSuccess,
            hipErrorMapFailed,
            hipErrorInvalidHandle,
    """
    _hipIpcCloseMemHandle__retval = hipError_t(chip.hipIpcCloseMemHandle(
        <void *>hip._util.types.DataHandle.from_pyobj(devPtr)._ptr))    # fully specified
    return (_hipIpcCloseMemHandle__retval,)


@cython.embedsignature(True)
def hipIpcGetEventHandle(object handle, object event):
    r"""Gets an opaque interprocess handle for an event.

    This opaque handle may be copied into other processes and opened with hipIpcOpenEventHandle.
    Then hipEventRecord, hipEventSynchronize, hipStreamWaitEvent and hipEventQuery may be used in
    either process. Operations on the imported event after the exported event has been freed with hipEventDestroy
    will result in undefined behavior.

    Args:
        handle: **[out]** Pointer to hipIpcEventHandle to return the opaque event handle

        event: **[in]** Event allocated with hipEventInterprocess and hipEventDisableTiming flags

    Returns:
        A ``tuple`` of size 1 that contains (in that order):
        - #hipSuccess, #hipErrorInvalidConfiguration, #hipErrorInvalidValue
    """
    _hipIpcGetEventHandle__retval = hipError_t(chip.hipIpcGetEventHandle(
        hipIpcEventHandle_st.from_pyobj(handle)._ptr,
        ihipEvent_t.from_pyobj(event)._ptr))    # fully specified
    return (_hipIpcGetEventHandle__retval,)


@cython.embedsignature(True)
def hipIpcOpenEventHandle(object handle):
    r"""Opens an interprocess event handles.

    Opens an interprocess event handle exported from another process with cudaIpcGetEventHandle. The returned
    hipEvent_t behaves like a locally created event with the hipEventDisableTiming flag specified. This event
    need be freed with hipEventDestroy. Operations on the imported event after the exported event has been freed
    with hipEventDestroy will result in undefined behavior. If the function is called within the same process where
    handle is returned by hipIpcGetEventHandle, it will return hipErrorInvalidContext.

    Args:
        handle: **[in]** The opaque interprocess handle to open

    Returns:
        A ``tuple`` of size 2 that contains (in that order):
        - #hipSuccess, #hipErrorInvalidValue, #hipErrorInvalidContext
        - event: Pointer to hipEvent_t to return the event
    """
    event = ihipEvent_t.from_ptr(NULL)
    _hipIpcOpenEventHandle__retval = hipError_t(chip.hipIpcOpenEventHandle(&event._ptr,
        hipIpcEventHandle_st.from_pyobj(handle)._ptr[0]))    # fully specified
    return (_hipIpcOpenEventHandle__retval,event)


@cython.embedsignature(True)
def hipFuncSetAttribute(object func, object attr, int value):
    r"""Set attribute for a specific function

    Note: AMD devices and some Nvidia GPUS do not support shared cache banking, and the hint is
    ignored on those architectures.

    Args:
        func: **[in]** ;

        attr: **[in]** ;

        value: **[in]** ;

    Returns:
        A ``tuple`` of size 1 that contains (in that order):
        - #hipSuccess, #hipErrorInvalidDeviceFunction, #hipErrorInvalidValue
    """
    if not isinstance(attr,_hipFuncAttribute__Base):
        raise TypeError("argument 'attr' must be of type '_hipFuncAttribute__Base'")
    _hipFuncSetAttribute__retval = hipError_t(chip.hipFuncSetAttribute(
        <const void *>hip._util.types.DataHandle.from_pyobj(func)._ptr,attr.value,value))    # fully specified
    return (_hipFuncSetAttribute__retval,)


@cython.embedsignature(True)
def hipFuncSetCacheConfig(object func, object config):
    r"""Set Cache configuration for a specific function

    Args:
        config: **[in]** ;

    Returns:
        A ``tuple`` of size 1 that contains (in that order):
        - #hipSuccess, #hipErrorNotInitialized
            Note: AMD devices and some Nvidia GPUS do not support reconfigurable cache.  This hint is ignored
            on those architectures.
    """
    if not isinstance(config,_hipFuncCache_t__Base):
        raise TypeError("argument 'config' must be of type '_hipFuncCache_t__Base'")
    _hipFuncSetCacheConfig__retval = hipError_t(chip.hipFuncSetCacheConfig(
        <const void *>hip._util.types.DataHandle.from_pyobj(func)._ptr,config.value))    # fully specified
    return (_hipFuncSetCacheConfig__retval,)


@cython.embedsignature(True)
def hipFuncSetSharedMemConfig(object func, object config):
    r"""Set shared memory configuation for a specific function

    Note: AMD devices and some Nvidia GPUS do not support shared cache banking, and the hint is
    ignored on those architectures.

    Args:
        func: **[in]** 

        config: **[in]** 

    Returns:
        A ``tuple`` of size 1 that contains (in that order):
        - #hipSuccess, #hipErrorInvalidDeviceFunction, #hipErrorInvalidValue
    """
    if not isinstance(config,_hipSharedMemConfig__Base):
        raise TypeError("argument 'config' must be of type '_hipSharedMemConfig__Base'")
    _hipFuncSetSharedMemConfig__retval = hipError_t(chip.hipFuncSetSharedMemConfig(
        <const void *>hip._util.types.DataHandle.from_pyobj(func)._ptr,config.value))    # fully specified
    return (_hipFuncSetSharedMemConfig__retval,)


@cython.embedsignature(True)
def hipGetLastError():
    r"""Return last error returned by any HIP runtime API call and resets the stored error code to
     #hipSuccess

    Returns the last error that has been returned by any of the runtime calls in the same host
    thread, and then resets the saved error to #hipSuccess.

    See:
        hipGetErrorString, hipGetLastError, hipPeakAtLastError, hipError_t

    Returns:
        A ``tuple`` of size 1 that contains (in that order):
        - return code from last HIP called from the active host thread
    """
    _hipGetLastError__retval = hipError_t(chip.hipGetLastError())    # fully specified
    return (_hipGetLastError__retval,)


@cython.embedsignature(True)
def hipPeekAtLastError():
    r"""Return last error returned by any HIP runtime API call.

    Returns the last error that has been returned by any of the runtime calls in the same host
    thread. Unlike hipGetLastError, this function does not reset the saved error code.

    See:
        hipGetErrorString, hipGetLastError, hipPeakAtLastError, hipError_t

    Returns:
        A ``tuple`` of size 1 that contains (in that order):
        - #hipSuccess
    """
    _hipPeekAtLastError__retval = hipError_t(chip.hipPeekAtLastError())    # fully specified
    return (_hipPeekAtLastError__retval,)


@cython.embedsignature(True)
def hipGetErrorName(object hip_error):
    r"""Return hip error as text string form.

    See:
        hipGetErrorString, hipGetLastError, hipPeakAtLastError, hipError_t

    Args:
        hip_error: Error code to convert to name.

    Returns:
        A ``tuple`` of size 1 that contains (in that order):
        - const char pointer to the NULL-terminated error name
    """
    if not isinstance(hip_error,_hipError_t__Base):
        raise TypeError("argument 'hip_error' must be of type '_hipError_t__Base'")
    cdef const char * _hipGetErrorName__retval = chip.hipGetErrorName(hip_error.value)    # fully specified
    return (_hipGetErrorName__retval,)


@cython.embedsignature(True)
def hipGetErrorString(object hipError):
    r"""Return handy text string message to explain the error which occurred

    See:
        hipGetErrorName, hipGetLastError, hipPeakAtLastError, hipError_t

    Args:
        hipError: Error code to convert to string.

    Returns:
        A ``tuple`` of size 1 that contains (in that order):
        - const char pointer to the NULL-terminated error string
    """
    if not isinstance(hipError,_hipError_t__Base):
        raise TypeError("argument 'hipError' must be of type '_hipError_t__Base'")
    cdef const char * _hipGetErrorString__retval = chip.hipGetErrorString(hipError.value)    # fully specified
    return (_hipGetErrorString__retval,)


@cython.embedsignature(True)
def hipDrvGetErrorName(object hipError, object errorString):
    r"""Return hip error as text string form.

    See:
        hipGetErrorName, hipGetLastError, hipPeakAtLastError, hipError_t

    Args:
        hipError: **[in]** Error code to convert to string.

        const: **[out]** char pointer to the NULL-terminated error string

    Returns:
        A ``tuple`` of size 1 that contains (in that order):
        - #hipSuccess, #hipErrorInvalidValue
    """
    if not isinstance(hipError,_hipError_t__Base):
        raise TypeError("argument 'hipError' must be of type '_hipError_t__Base'")
    _hipDrvGetErrorName__retval = hipError_t(chip.hipDrvGetErrorName(hipError.value,
        <const char **>hip._util.types.DataHandle.from_pyobj(errorString)._ptr))    # fully specified
    return (_hipDrvGetErrorName__retval,)


@cython.embedsignature(True)
def hipDrvGetErrorString(object hipError, object errorString):
    r"""Return handy text string message to explain the error which occurred

    See:
        hipGetErrorName, hipGetLastError, hipPeakAtLastError, hipError_t

    Args:
        hipError: **[in]** Error code to convert to string.

        const: **[out]** char pointer to the NULL-terminated error string

    Returns:
        A ``tuple`` of size 1 that contains (in that order):
        - #hipSuccess, #hipErrorInvalidValue
    """
    if not isinstance(hipError,_hipError_t__Base):
        raise TypeError("argument 'hipError' must be of type '_hipError_t__Base'")
    _hipDrvGetErrorString__retval = hipError_t(chip.hipDrvGetErrorString(hipError.value,
        <const char **>hip._util.types.DataHandle.from_pyobj(errorString)._ptr))    # fully specified
    return (_hipDrvGetErrorString__retval,)


@cython.embedsignature(True)
def hipStreamCreate():
    r"""Create an asynchronous stream.

    Create a new asynchronous stream.  ``stream`` returns an opaque handle that can be used to
    reference the newly created stream in subsequent hipStream* commands.  The stream is allocated on
    the heap and will remain allocated even if the handle goes out-of-scope.  To release the memory
    used by the stream, applicaiton must call hipStreamDestroy.

    See:
        hipStreamCreateWithFlags, hipStreamCreateWithPriority, hipStreamSynchronize, hipStreamWaitEvent, hipStreamDestroy

    Returns:
        A ``tuple`` of size 3 that contains (in that order):
        - #hipSuccess, #hipErrorInvalidValue
        - #hipSuccess, #hipErrorInvalidValue
        - stream: Valid pointer to hipStream_t.  This function writes the memory with the
                newly created stream.
    """
    stream = ihipStream_t.from_ptr(NULL)
    _hipStreamCreate__retval = hipError_t(chip.hipStreamCreate(&stream._ptr))    # fully specified
    return (_hipStreamCreate__retval,stream)


@cython.embedsignature(True)
def hipStreamCreateWithFlags(unsigned int flags):
    r"""Create an asynchronous stream.

    Create a new asynchronous stream.  ``stream`` returns an opaque handle that can be used to
    reference the newly created stream in subsequent hipStream* commands.  The stream is allocated on
    the heap and will remain allocated even if the handle goes out-of-scope.  To release the memory
    used by the stream, applicaiton must call hipStreamDestroy. Flags controls behavior of the
    stream.  See #hipStreamDefault, #hipStreamNonBlocking.

    See:
        hipStreamCreate, hipStreamCreateWithPriority, hipStreamSynchronize, hipStreamWaitEvent, hipStreamDestroy

    Args:
        flags: **[in]** to control stream creation.

    Returns:
        A ``tuple`` of size 2 that contains (in that order):
        - #hipSuccess, #hipErrorInvalidValue
        - stream: Pointer to new stream
    """
    stream = ihipStream_t.from_ptr(NULL)
    _hipStreamCreateWithFlags__retval = hipError_t(chip.hipStreamCreateWithFlags(&stream._ptr,flags))    # fully specified
    return (_hipStreamCreateWithFlags__retval,stream)


@cython.embedsignature(True)
def hipStreamCreateWithPriority(unsigned int flags, int priority):
    r"""Create an asynchronous stream with the specified priority.

    Create a new asynchronous stream with the specified priority.  ``stream`` returns an opaque handle
    that can be used to reference the newly created stream in subsequent hipStream* commands.  The
    stream is allocated on the heap and will remain allocated even if the handle goes out-of-scope.
    To release the memory used by the stream, applicaiton must call hipStreamDestroy. Flags controls
    behavior of the stream.  See #hipStreamDefault, #hipStreamNonBlocking.

    See:
        hipStreamCreate, hipStreamSynchronize, hipStreamWaitEvent, hipStreamDestroy

    Args:
        flags: **[in]** to control stream creation.

        priority: **[in]** of the stream. Lower numbers represent higher priorities.

    Returns:
        A ``tuple`` of size 2 that contains (in that order):
        - #hipSuccess, #hipErrorInvalidValue
        - stream: Pointer to new stream
    """
    stream = ihipStream_t.from_ptr(NULL)
    _hipStreamCreateWithPriority__retval = hipError_t(chip.hipStreamCreateWithPriority(&stream._ptr,flags,priority))    # fully specified
    return (_hipStreamCreateWithPriority__retval,stream)


@cython.embedsignature(True)
def hipDeviceGetStreamPriorityRange():
    r"""Returns numerical values that correspond to the least and greatest stream priority.

    Returns in *leastPriority and *greatestPriority the numerical values that correspond to the least
    and greatest stream priority respectively. Stream priorities follow a convention where lower numbers
    imply greater priorities. The range of meaningful stream priorities is given by
    [*greatestPriority, *leastPriority]. If the user attempts to create a stream with a priority value
    that is outside the the meaningful range as specified by this API, the priority is automatically
    clamped to within the valid range.

    Returns:
        A ``tuple`` of size 2 that contains (in that order):
        - leastPriority: pointer in which value corresponding to least priority is returned.
        - greatestPriority: pointer in which value corresponding to greatest priority is returned.
    """
    cdef int leastPriority
    cdef int greatestPriority
    _hipDeviceGetStreamPriorityRange__retval = hipError_t(chip.hipDeviceGetStreamPriorityRange(&leastPriority,&greatestPriority))    # fully specified
    return (_hipDeviceGetStreamPriorityRange__retval,leastPriority,greatestPriority)


@cython.embedsignature(True)
def hipStreamDestroy(object stream):
    r"""Destroys the specified stream.

    Destroys the specified stream.

    If commands are still executing on the specified stream, some may complete execution before the
    queue is deleted.

    The queue may be destroyed while some commands are still inflight, or may wait for all commands
    queued to the stream before destroying it.

    See:
        hipStreamCreate, hipStreamCreateWithFlags, hipStreamCreateWithPriority, hipStreamQuery, hipStreamWaitEvent,
        hipStreamSynchronize

    Args:
        stream: **[in,out]** Valid pointer to hipStream_t.  This function writes the memory with the
            newly created stream.

    Returns:
        A ``tuple`` of size 1 that contains (in that order):
        - #hipSuccess #hipErrorInvalidHandle
    """
    _hipStreamDestroy__retval = hipError_t(chip.hipStreamDestroy(
        ihipStream_t.from_pyobj(stream)._ptr))    # fully specified
    return (_hipStreamDestroy__retval,)


@cython.embedsignature(True)
def hipStreamQuery(object stream):
    r"""Return #hipSuccess if all of the operations in the specified ``stream`` have completed, or
    #hipErrorNotReady if not.

    This is thread-safe and returns a snapshot of the current state of the queue.  However, if other
    host threads are sending work to the stream, the status may change immediately after the function
    is called.  It is typically used for debug.

    See:
        hipStreamCreate, hipStreamCreateWithFlags, hipStreamCreateWithPriority, hipStreamWaitEvent, hipStreamSynchronize,
        hipStreamDestroy

    Args:
        stream: **[in]** stream to query

    Returns:
        A ``tuple`` of size 1 that contains (in that order):
        - #hipSuccess, #hipErrorNotReady, #hipErrorInvalidHandle
    """
    _hipStreamQuery__retval = hipError_t(chip.hipStreamQuery(
        ihipStream_t.from_pyobj(stream)._ptr))    # fully specified
    return (_hipStreamQuery__retval,)


@cython.embedsignature(True)
def hipStreamSynchronize(object stream):
    r"""Wait for all commands in stream to complete.

    This command is host-synchronous : the host will block until the specified stream is empty.

    This command follows standard null-stream semantics.  Specifically, specifying the null stream
    will cause the command to wait for other streams on the same device to complete all pending
    operations.

    This command honors the hipDeviceLaunchBlocking flag, which controls whether the wait is active
    or blocking.

    See:
        hipStreamCreate, hipStreamCreateWithFlags, hipStreamCreateWithPriority, hipStreamWaitEvent, hipStreamDestroy

    Args:
        stream: **[in]** stream identifier.

    Returns:
        A ``tuple`` of size 1 that contains (in that order):
        - #hipSuccess, #hipErrorInvalidHandle
    """
    _hipStreamSynchronize__retval = hipError_t(chip.hipStreamSynchronize(
        ihipStream_t.from_pyobj(stream)._ptr))    # fully specified
    return (_hipStreamSynchronize__retval,)


@cython.embedsignature(True)
def hipStreamWaitEvent(object stream, object event, unsigned int flags):
    r"""Make the specified compute stream wait for an event

    This function inserts a wait operation into the specified stream.
    All future work submitted to ``stream`` will wait until ``event`` reports completion before
    beginning execution.

    This function only waits for commands in the current stream to complete.  Notably,, this function
    does not impliciy wait for commands in the default stream to complete, even if the specified
    stream is created with hipStreamNonBlocking = 0.

    See:
        hipStreamCreate, hipStreamCreateWithFlags, hipStreamCreateWithPriority, hipStreamSynchronize, hipStreamDestroy

    Args:
        stream: **[in]** stream to make wait.

        event: **[in]** event to wait on

        flags: **[in]** control operation [must be 0]

    Returns:
        A ``tuple`` of size 1 that contains (in that order):
        - #hipSuccess, #hipErrorInvalidHandle
    """
    _hipStreamWaitEvent__retval = hipError_t(chip.hipStreamWaitEvent(
        ihipStream_t.from_pyobj(stream)._ptr,
        ihipEvent_t.from_pyobj(event)._ptr,flags))    # fully specified
    return (_hipStreamWaitEvent__retval,)


@cython.embedsignature(True)
def hipStreamGetFlags(object stream):
    r"""Return flags associated with this stream.

    Return flags associated with this stream in *``flags.``

    See:
        hipStreamCreateWithFlags

    Args:
        stream: **[in]** stream to be queried

    Returns:
        A ``tuple`` of size 3 that contains (in that order):
        - #hipSuccess, #hipErrorInvalidValue, #hipErrorInvalidHandle
        - #hipSuccess #hipErrorInvalidValue #hipErrorInvalidHandle
        - flags: Pointer to an unsigned integer in which the stream's flags are returned
    """
    cdef unsigned int flags
    _hipStreamGetFlags__retval = hipError_t(chip.hipStreamGetFlags(
        ihipStream_t.from_pyobj(stream)._ptr,&flags))    # fully specified
    return (_hipStreamGetFlags__retval,flags)


@cython.embedsignature(True)
def hipStreamGetPriority(object stream):
    r"""Query the priority of a stream.

    Query the priority of a stream. The priority is returned in in priority.

    See:
        hipStreamCreateWithFlags

    Args:
        stream: **[in]** stream to be queried

    Returns:
        A ``tuple`` of size 3 that contains (in that order):
        - #hipSuccess, #hipErrorInvalidValue, #hipErrorInvalidHandle
        - #hipSuccess #hipErrorInvalidValue #hipErrorInvalidHandle
        - priority: Pointer to an unsigned integer in which the stream's priority is returned
    """
    cdef int priority
    _hipStreamGetPriority__retval = hipError_t(chip.hipStreamGetPriority(
        ihipStream_t.from_pyobj(stream)._ptr,&priority))    # fully specified
    return (_hipStreamGetPriority__retval,priority)


@cython.embedsignature(True)
def hipExtStreamCreateWithCUMask(unsigned int cuMaskSize):
    r"""Create an asynchronous stream with the specified CU mask.

    Create a new asynchronous stream with the specified CU mask.  ``stream`` returns an opaque handle
    that can be used to reference the newly created stream in subsequent hipStream* commands.  The
    stream is allocated on the heap and will remain allocated even if the handle goes out-of-scope.
    To release the memory used by the stream, application must call hipStreamDestroy.

    See:
        hipStreamCreate, hipStreamSynchronize, hipStreamWaitEvent, hipStreamDestroy

    Args:
        cuMaskSize: **[in]** Size of CU mask bit array passed in.

    Returns:
        A ``tuple`` of size 3 that contains (in that order):
        - #hipSuccess, #hipErrorInvalidHandle, #hipErrorInvalidValue
        - stream: Pointer to new stream
        - cuMask: Bit-vector representing the CU mask. Each active bit represents using one CU.
                The first 32 bits represent the first 32 CUs, and so on. If its size is greater than physical
                CU number (i.e., multiProcessorCount member of hipDeviceProp_t), the extra elements are ignored.
                It is user's responsibility to make sure the input is meaningful.
    """
    stream = ihipStream_t.from_ptr(NULL)
    cdef const unsigned int cuMask
    _hipExtStreamCreateWithCUMask__retval = hipError_t(chip.hipExtStreamCreateWithCUMask(&stream._ptr,cuMaskSize,&cuMask))    # fully specified
    return (_hipExtStreamCreateWithCUMask__retval,stream,cuMask)


@cython.embedsignature(True)
def hipExtStreamGetCUMask(object stream, unsigned int cuMaskSize):
    r"""Get CU mask associated with an asynchronous stream

    See:
        hipStreamCreate, hipStreamSynchronize, hipStreamWaitEvent, hipStreamDestroy

    Args:
        stream: **[in]** stream to be queried

        cuMaskSize: **[in]** number of the block of memories (uint32_t *) allocated by user

    Returns:
        A ``tuple`` of size 2 that contains (in that order):
        - #hipSuccess, #hipErrorInvalidHandle, #hipErrorInvalidValue
        - cuMask: Pointer to a pre-allocated block of memories (uint32_t *) in which
                the stream's CU mask is returned. The CU mask is returned in a chunck of 32 bits where
                each active bit represents one active CU
    """
    cdef unsigned int cuMask
    _hipExtStreamGetCUMask__retval = hipError_t(chip.hipExtStreamGetCUMask(
        ihipStream_t.from_pyobj(stream)._ptr,cuMaskSize,&cuMask))    # fully specified
    return (_hipExtStreamGetCUMask__retval,cuMask)


cdef class hipStreamCallback_t:
    # members declared in pxd file

    def __cinit__(self):
        self._ptr = NULL
        self.ptr_owner = False
        self._py_buffer_acquired = False

    @staticmethod
    cdef hipStreamCallback_t from_ptr(chip.hipStreamCallback_t ptr, bint owner=False):
        """Factory function to create ``hipStreamCallback_t`` objects from
        given ``chip.hipStreamCallback_t`` pointer.
        """
        # Fast call to __new__() that bypasses the __init__() constructor.
        cdef hipStreamCallback_t wrapper = hipStreamCallback_t.__new__(hipStreamCallback_t)
        wrapper._ptr = ptr
        wrapper.ptr_owner = owner
        return wrapper

    @staticmethod
    cdef hipStreamCallback_t from_pyobj(object pyobj):
        """Derives a hipStreamCallback_t from a Python object.

        Derives a hipStreamCallback_t from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``hipStreamCallback_t`` reference, this method
        returns it directly. No new ``hipStreamCallback_t`` is created in this case.

        Args:
            pyobj (object): Must be either ``None``, a simple, contiguous buffer according to the buffer protocol,
                            or of type ``hipStreamCallback_t``, ``int``, or ``ctypes.c_void_p``

        Note:
            This routine does not perform a copy but returns the original ``pyobj``
            if ``pyobj`` is an instance of hipStreamCallback_t!
        """
        cdef hipStreamCallback_t wrapper = hipStreamCallback_t.__new__(hipStreamCallback_t)
        cdef dict cuda_array_interface = getattr(pyobj, "__cuda_array_interface__", None)

        if pyobj is None:
            wrapper._ptr = NULL
        elif isinstance(pyobj,hipStreamCallback_t):
            return pyobj
        elif isinstance(pyobj,int):
            wrapper._ptr = <chip.hipStreamCallback_t>cpython.long.PyLong_AsVoidPtr(pyobj)
        elif isinstance(pyobj,ctypes.c_void_p):
            wrapper._ptr = <chip.hipStreamCallback_t>cpython.long.PyLong_AsVoidPtr(pyobj.value) if pyobj.value != None else NULL
        elif str(type(pyobj)).startswith("<class 'ctypes.CFUNCTYPE.") and str(type(pyobj)).endswith(".CFunctionType'>" ):
            wrapper._ptr = <chip.hipStreamCallback_t>cpython.long.PyLong_AsVoidPtr(ctypes.cast(pyobj, ctypes.c_void_p).value)
        else:
            raise TypeError(f"unsupported input type: '{str(type(pyobj))}'")
        return wrapper
    def __dealloc__(self):
        # Release the buffer handle
        if self._py_buffer_acquired is True:
            cpython.buffer.PyBuffer_Release(&self._py_buffer)
    
    def __int__(self):
        """Returns the data's address as long integer."""
        return cpython.long.PyLong_FromVoidPtr(self._ptr)
    def __repr__(self):
        return f"<hipStreamCallback_t object, self.ptr={int(self)}>"
    def as_c_void_p(self):
        """Returns the data's address as `ctypes.c_void_p`"""
        return ctypes.c_void_p(int(self))


@cython.embedsignature(True)
def hipStreamAddCallback(object stream, object callback, object userData, unsigned int flags):
    r"""Adds a callback to be called on the host after all currently enqueued
    items in the stream have completed.  For each
    hipStreamAddCallback call, a callback will be executed exactly once.
    The callback will block later work in the stream until it is finished.

    See:
        hipStreamCreate, hipStreamCreateWithFlags, hipStreamQuery, hipStreamSynchronize,
        hipStreamWaitEvent, hipStreamDestroy, hipStreamCreateWithPriority

    Args:
        stream: **[in]**  Stream to add callback to

        callback: **[in]**  The function to call once preceding stream operations are complete

        userData: **[in]**  User specified data to be passed to the callback function

        flags: **[in]**  Reserved for future use, must be 0

    Returns:
        A ``tuple`` of size 1 that contains (in that order):
        - #hipSuccess, #hipErrorInvalidHandle, #hipErrorNotSupported
    """
    _hipStreamAddCallback__retval = hipError_t(chip.hipStreamAddCallback(
        ihipStream_t.from_pyobj(stream)._ptr,
        hipStreamCallback_t.from_pyobj(callback)._ptr,
        <void *>hip._util.types.DataHandle.from_pyobj(userData)._ptr,flags))    # fully specified
    return (_hipStreamAddCallback__retval,)


@cython.embedsignature(True)
def hipStreamWaitValue32(object stream, object ptr, unsigned int value, unsigned int flags, unsigned int mask):
    r"""Enqueues a wait command to the stream.[BETA]

    Enqueues a wait command to the stream, all operations enqueued  on this stream after this, will
    not execute until the defined wait condition is true.

    hipStreamWaitValueGte: waits until *ptr&mask >= value
    hipStreamWaitValueEq : waits until *ptr&mask == value
    hipStreamWaitValueAnd: waits until ((*ptr&mask) & value) != 0
    hipStreamWaitValueNor: waits until ~((*ptr&mask) | (value&mask)) != 0

    Note:
        when using 'hipStreamWaitValueNor', mask is applied on both 'value' and '*ptr'.

    Note:
        Support for hipStreamWaitValue32 can be queried using 'hipDeviceGetAttribute()' and
        'hipDeviceAttributeCanUseStreamWaitValue' flag.

    Beta:
        This API is marked as beta, meaning, while this is feature complete,
        it is still open to changes and may have outstanding issues.

    See:
        hipExtMallocWithFlags, hipFree, hipStreamWaitValue64, hipStreamWriteValue64,
        hipStreamWriteValue32, hipDeviceGetAttribute

    Args:
        stream: **[in]**  Stream identifier

        ptr: **[in]**  Pointer to memory object allocated using 'hipMallocSignalMemory' flag

        value: **[in]**  Value to be used in compare operation

        flags: **[in]**  Defines the compare operation, supported values are hipStreamWaitValueGte
            hipStreamWaitValueEq, hipStreamWaitValueAnd and hipStreamWaitValueNor

        mask: **[in]**  Mask to be applied on value at memory before it is compared with value,
            default value is set to enable every bit

    Returns:
        A ``tuple`` of size 1 that contains (in that order):
        - #hipSuccess, #hipErrorInvalidValue
    """
    _hipStreamWaitValue32__retval = hipError_t(chip.hipStreamWaitValue32(
        ihipStream_t.from_pyobj(stream)._ptr,
        <void *>hip._util.types.DataHandle.from_pyobj(ptr)._ptr,value,flags,mask))    # fully specified
    return (_hipStreamWaitValue32__retval,)


@cython.embedsignature(True)
def hipStreamWaitValue64(object stream, object ptr, unsigned long value, unsigned int flags, unsigned long mask):
    r"""Enqueues a wait command to the stream.[BETA]

    Enqueues a wait command to the stream, all operations enqueued  on this stream after this, will
    not execute until the defined wait condition is true.

    hipStreamWaitValueGte: waits until *ptr&mask >= value
    hipStreamWaitValueEq : waits until *ptr&mask == value
    hipStreamWaitValueAnd: waits until ((*ptr&mask) & value) != 0
    hipStreamWaitValueNor: waits until ~((*ptr&mask) | (value&mask)) != 0

    Note:
        when using 'hipStreamWaitValueNor', mask is applied on both 'value' and '*ptr'.

    Note:
        Support for hipStreamWaitValue64 can be queried using 'hipDeviceGetAttribute()' and
        'hipDeviceAttributeCanUseStreamWaitValue' flag.

    Beta:
        This API is marked as beta, meaning, while this is feature complete,
        it is still open to changes and may have outstanding issues.

    See:
        hipExtMallocWithFlags, hipFree, hipStreamWaitValue32, hipStreamWriteValue64,
        hipStreamWriteValue32, hipDeviceGetAttribute

    Args:
        stream: **[in]**  Stream identifier

        ptr: **[in]**  Pointer to memory object allocated using 'hipMallocSignalMemory' flag

        value: **[in]**  Value to be used in compare operation

        flags: **[in]**  Defines the compare operation, supported values are hipStreamWaitValueGte
            hipStreamWaitValueEq, hipStreamWaitValueAnd and hipStreamWaitValueNor.

        mask: **[in]**  Mask to be applied on value at memory before it is compared with value
            default value is set to enable every bit

    Returns:
        A ``tuple`` of size 1 that contains (in that order):
        - #hipSuccess, #hipErrorInvalidValue
    """
    _hipStreamWaitValue64__retval = hipError_t(chip.hipStreamWaitValue64(
        ihipStream_t.from_pyobj(stream)._ptr,
        <void *>hip._util.types.DataHandle.from_pyobj(ptr)._ptr,value,flags,mask))    # fully specified
    return (_hipStreamWaitValue64__retval,)


@cython.embedsignature(True)
def hipStreamWriteValue32(object stream, object ptr, unsigned int value, unsigned int flags):
    r"""Enqueues a write command to the stream.[BETA]

    Enqueues a write command to the stream, write operation is performed after all earlier commands
    on this stream have completed the execution.

    Beta:
        This API is marked as beta, meaning, while this is feature complete,
        it is still open to changes and may have outstanding issues.

    See:
        hipExtMallocWithFlags, hipFree, hipStreamWriteValue32, hipStreamWaitValue32,
        hipStreamWaitValue64

    Args:
        stream: **[in]**  Stream identifier

        ptr: **[in]**  Pointer to a GPU accessible memory object

        value: **[in]**  Value to be written

        flags: **[in]**  reserved, ignored for now, will be used in future releases

    Returns:
        A ``tuple`` of size 1 that contains (in that order):
        - #hipSuccess, #hipErrorInvalidValue
    """
    _hipStreamWriteValue32__retval = hipError_t(chip.hipStreamWriteValue32(
        ihipStream_t.from_pyobj(stream)._ptr,
        <void *>hip._util.types.DataHandle.from_pyobj(ptr)._ptr,value,flags))    # fully specified
    return (_hipStreamWriteValue32__retval,)


@cython.embedsignature(True)
def hipStreamWriteValue64(object stream, object ptr, unsigned long value, unsigned int flags):
    r"""Enqueues a write command to the stream.[BETA]

    Enqueues a write command to the stream, write operation is performed after all earlier commands
    on this stream have completed the execution.

    Beta:
        This API is marked as beta, meaning, while this is feature complete,
        it is still open to changes and may have outstanding issues.

    See:
        hipExtMallocWithFlags, hipFree, hipStreamWriteValue32, hipStreamWaitValue32,
        hipStreamWaitValue64

    Args:
        stream: **[in]**  Stream identifier

        ptr: **[in]**  Pointer to a GPU accessible memory object

        value: **[in]**  Value to be written

        flags: **[in]**  reserved, ignored for now, will be used in future releases

    Returns:
        A ``tuple`` of size 1 that contains (in that order):
        - #hipSuccess, #hipErrorInvalidValue
    """
    _hipStreamWriteValue64__retval = hipError_t(chip.hipStreamWriteValue64(
        ihipStream_t.from_pyobj(stream)._ptr,
        <void *>hip._util.types.DataHandle.from_pyobj(ptr)._ptr,value,flags))    # fully specified
    return (_hipStreamWriteValue64__retval,)


@cython.embedsignature(True)
def hipEventCreateWithFlags(unsigned int flags):
    r"""Create an event with the specified flags

    See:
        hipEventCreate, hipEventSynchronize, hipEventDestroy, hipEventElapsedTime

    Args:
        flags: **[in]** Flags to control event behavior.  Valid values are #hipEventDefault,
            #hipEventBlockingSync, #hipEventDisableTiming, #hipEventInterprocess
              #hipEventDefault : Default flag.  The event will use active synchronization and will support
            timing.  Blocking synchronization provides lowest possible latency at the expense of dedicating a
            CPU to poll on the event.
              #hipEventBlockingSync : The event will use blocking synchronization : if hipEventSynchronize is
            called on this event, the thread will block until the event completes.  This can increase latency
            for the synchroniation but can result in lower power and more resources for other CPU threads.
              #hipEventDisableTiming : Disable recording of timing information. Events created with this flag
            would not record profiling data and provide best performance if used for synchronization.
              #hipEventInterprocess : The event can be used as an interprocess event. hipEventDisableTiming
            flag also must be set when hipEventInterprocess flag is set.

    Returns:
        A ``tuple`` of size 2 that contains (in that order):
        - #hipSuccess, #hipErrorNotInitialized, #hipErrorInvalidValue,
            #hipErrorLaunchFailure, #hipErrorOutOfMemory
        - event: Returns the newly created event.
    """
    event = ihipEvent_t.from_ptr(NULL)
    _hipEventCreateWithFlags__retval = hipError_t(chip.hipEventCreateWithFlags(&event._ptr,flags))    # fully specified
    return (_hipEventCreateWithFlags__retval,event)


@cython.embedsignature(True)
def hipEventCreate():
    r"""(No short description)

    Create an event

    See:
        hipEventCreateWithFlags, hipEventRecord, hipEventQuery, hipEventSynchronize,
        hipEventDestroy, hipEventElapsedTime

    Returns:
        A ``tuple`` of size 2 that contains (in that order):
        - #hipSuccess, #hipErrorNotInitialized, #hipErrorInvalidValue,
            #hipErrorLaunchFailure, #hipErrorOutOfMemory
        - event: Returns the newly created event.
    """
    event = ihipEvent_t.from_ptr(NULL)
    _hipEventCreate__retval = hipError_t(chip.hipEventCreate(&event._ptr))    # fully specified
    return (_hipEventCreate__retval,event)


@cython.embedsignature(True)
def hipEventRecord(object event, object stream):
    r"""(No short description)
    """
    _hipEventRecord__retval = hipError_t(chip.hipEventRecord(
        ihipEvent_t.from_pyobj(event)._ptr,
        ihipStream_t.from_pyobj(stream)._ptr))    # fully specified
    return (_hipEventRecord__retval,)


@cython.embedsignature(True)
def hipEventDestroy(object event):
    r"""Destroy the specified event.

    Releases memory associated with the event.  If the event is recording but has not completed
    recording when hipEventDestroy() is called, the function will return immediately and the
    completion_future resources will be released later, when the hipDevice is synchronized.

    See:
        hipEventCreate, hipEventCreateWithFlags, hipEventQuery, hipEventSynchronize, hipEventRecord,
        hipEventElapsedTime

    Args:
        event: **[in]** Event to destroy.

    Returns:
        A ``tuple`` of size 2 that contains (in that order):
        - #hipSuccess, #hipErrorNotInitialized, #hipErrorInvalidValue,
            #hipErrorLaunchFailure
        - #hipSuccess
    """
    _hipEventDestroy__retval = hipError_t(chip.hipEventDestroy(
        ihipEvent_t.from_pyobj(event)._ptr))    # fully specified
    return (_hipEventDestroy__retval,)


@cython.embedsignature(True)
def hipEventSynchronize(object event):
    r"""Wait for an event to complete.

    This function will block until the event is ready, waiting for all previous work in the stream
    specified when event was recorded with hipEventRecord().

     If hipEventRecord() has not been called on ``event,`` this function returns immediately.

     TODO-hip- This function needs to support hipEventBlockingSync parameter.

    See:
        hipEventCreate, hipEventCreateWithFlags, hipEventQuery, hipEventDestroy, hipEventRecord,
        hipEventElapsedTime

    Args:
        event: **[in]** Event on which to wait.

    Returns:
        A ``tuple`` of size 1 that contains (in that order):
        - #hipSuccess, #hipErrorInvalidValue, #hipErrorNotInitialized,
            #hipErrorInvalidHandle, #hipErrorLaunchFailure
    """
    _hipEventSynchronize__retval = hipError_t(chip.hipEventSynchronize(
        ihipEvent_t.from_pyobj(event)._ptr))    # fully specified
    return (_hipEventSynchronize__retval,)


@cython.embedsignature(True)
def hipEventElapsedTime(object start, object stop):
    r"""Return the elapsed time between two events.

    Computes the elapsed time between two events. Time is computed in ms, with
    a resolution of approximately 1 us.

    Events which are recorded in a NULL stream will block until all commands
    on all other streams complete execution, and then record the timestamp.

    Events which are recorded in a non-NULL stream will record their timestamp
    when they reach the head of the specified stream, after all previous
    commands in that stream have completed executing.  Thus the time that
    the event recorded may be significantly after the host calls hipEventRecord().

    If hipEventRecord() has not been called on either event, then #hipErrorInvalidHandle is
    returned. If hipEventRecord() has been called on both events, but the timestamp has not yet been
    recorded on one or both events (that is, hipEventQuery() would return #hipErrorNotReady on at
    least one of the events), then #hipErrorNotReady is returned.

    See:
        hipEventCreate, hipEventCreateWithFlags, hipEventQuery, hipEventDestroy, hipEventRecord,
        hipEventSynchronize

    Args:
        start: **[in]** Start event.

        stop: **[in]** Stop event.

    Returns:
        A ``tuple`` of size 2 that contains (in that order):
        - #hipSuccess, #hipErrorInvalidValue, #hipErrorNotReady, #hipErrorInvalidHandle,
            #hipErrorNotInitialized, #hipErrorLaunchFailure
        - ms: Return time between start and stop in ms.
    """
    cdef float ms
    _hipEventElapsedTime__retval = hipError_t(chip.hipEventElapsedTime(&ms,
        ihipEvent_t.from_pyobj(start)._ptr,
        ihipEvent_t.from_pyobj(stop)._ptr))    # fully specified
    return (_hipEventElapsedTime__retval,ms)


@cython.embedsignature(True)
def hipEventQuery(object event):
    r"""Query event status

    Query the status of the specified event.  This function will return #hipSuccess if all
    commands in the appropriate stream (specified to hipEventRecord()) have completed.  If that work
    has not completed, or if hipEventRecord() was not called on the event, then #hipErrorNotReady is
    returned.

    See:
        hipEventCreate, hipEventCreateWithFlags, hipEventRecord, hipEventDestroy,
        hipEventSynchronize, hipEventElapsedTime

    Args:
        event: **[in]** Event to query.

    Returns:
        A ``tuple`` of size 1 that contains (in that order):
        - #hipSuccess, #hipErrorNotReady, #hipErrorInvalidHandle, #hipErrorInvalidValue,
            #hipErrorNotInitialized, #hipErrorLaunchFailure
    """
    _hipEventQuery__retval = hipError_t(chip.hipEventQuery(
        ihipEvent_t.from_pyobj(event)._ptr))    # fully specified
    return (_hipEventQuery__retval,)


@cython.embedsignature(True)
def hipPointerGetAttributes(object attributes, object ptr):
    r"""Return attributes for the specified pointer

    See:
        hipPointerGetAttribute

    Args:
        attributes: **[out]** attributes for the specified pointer

        ptr: **[in]** pointer to get attributes for

    Returns:
        A ``tuple`` of size 1 that contains (in that order):
        - #hipSuccess, #hipErrorInvalidDevice, #hipErrorInvalidValue
    """
    _hipPointerGetAttributes__retval = hipError_t(chip.hipPointerGetAttributes(
        hipPointerAttribute_t.from_pyobj(attributes)._ptr,
        <const void *>hip._util.types.DataHandle.from_pyobj(ptr)._ptr))    # fully specified
    return (_hipPointerGetAttributes__retval,)


@cython.embedsignature(True)
def hipPointerGetAttribute(object data, object attribute, object ptr):
    r"""Returns information about the specified pointer.[BETA]

    Beta:
        This API is marked as beta, meaning, while this is feature complete,
        it is still open to changes and may have outstanding issues.

    See:
        hipPointerGetAttributes

    Args:
        data: **[in,out]** returned pointer attribute value

        atribute: **[in]** attribute to query for

        ptr: **[in]** pointer to get attributes for

    Returns:
        A ``tuple`` of size 1 that contains (in that order):
        - #hipSuccess, #hipErrorInvalidDevice, #hipErrorInvalidValue
    """
    if not isinstance(attribute,_hipPointer_attribute__Base):
        raise TypeError("argument 'attribute' must be of type '_hipPointer_attribute__Base'")
    _hipPointerGetAttribute__retval = hipError_t(chip.hipPointerGetAttribute(
        <void *>hip._util.types.DataHandle.from_pyobj(data)._ptr,attribute.value,
        <void *>hip._util.types.DataHandle.from_pyobj(ptr)._ptr))    # fully specified
    return (_hipPointerGetAttribute__retval,)


@cython.embedsignature(True)
def hipDrvPointerGetAttributes(unsigned int numAttributes, object ptr):
    r"""Returns information about the specified pointer.[BETA]

    Beta:
        This API is marked as beta, meaning, while this is feature complete,
        it is still open to changes and may have outstanding issues.

    See:
        hipPointerGetAttribute

    Args:
        numAttributes: **[in]** number of attributes to query for

        ptr: **[in]** pointer to get attributes for

    Returns:
        A ``tuple`` of size 3 that contains (in that order):
        - #hipSuccess, #hipErrorInvalidDevice, #hipErrorInvalidValue
        - attributes: attributes to query for
        - data: a two-dimensional containing pointers to memory locations
                where the result of each attribute query will be written to
    """
    cdef chip.hipPointer_attribute attributes
    data = hip._util.types.DataHandle.from_ptr(NULL)
    _hipDrvPointerGetAttributes__retval = hipError_t(chip.hipDrvPointerGetAttributes(numAttributes,&attributes,
        <void **>&data._ptr,
        <void *>hip._util.types.DataHandle.from_pyobj(ptr)._ptr))    # fully specified
    return (_hipDrvPointerGetAttributes__retval,hipPointer_attribute(attributes),data)


@cython.embedsignature(True)
def hipImportExternalSemaphore(object extSem_out, object semHandleDesc):
    r"""Imports an external semaphore.

    See:

    Args:
        extSem_out: **[out]** External semaphores to be waited on

        semHandleDesc: **[in]** Semaphore import handle descriptor

    Returns:
        A ``tuple`` of size 1 that contains (in that order):
        - #hipSuccess, #hipErrorInvalidDevice, #hipErrorInvalidValue
    """
    _hipImportExternalSemaphore__retval = hipError_t(chip.hipImportExternalSemaphore(
        <void **>hip._util.types.DataHandle.from_pyobj(extSem_out)._ptr,
        hipExternalSemaphoreHandleDesc_st.from_pyobj(semHandleDesc)._ptr))    # fully specified
    return (_hipImportExternalSemaphore__retval,)


@cython.embedsignature(True)
def hipSignalExternalSemaphoresAsync(object extSemArray, object paramsArray, unsigned int numExtSems, object stream):
    r"""Signals a set of external semaphore objects.

    See:

    Args:
        extSem_out: **[in]** External semaphores to be waited on

        paramsArray: **[in]** Array of semaphore parameters

        numExtSems: **[in]** Number of semaphores to wait on

        stream: **[in]** Stream to enqueue the wait operations in

    Returns:
        A ``tuple`` of size 1 that contains (in that order):
        - #hipSuccess, #hipErrorInvalidDevice, #hipErrorInvalidValue
    """
    _hipSignalExternalSemaphoresAsync__retval = hipError_t(chip.hipSignalExternalSemaphoresAsync(
        <void *const *>hip._util.types.DataHandle.from_pyobj(extSemArray)._ptr,
        hipExternalSemaphoreSignalParams_st.from_pyobj(paramsArray)._ptr,numExtSems,
        ihipStream_t.from_pyobj(stream)._ptr))    # fully specified
    return (_hipSignalExternalSemaphoresAsync__retval,)


@cython.embedsignature(True)
def hipWaitExternalSemaphoresAsync(object extSemArray, object paramsArray, unsigned int numExtSems, object stream):
    r"""Waits on a set of external semaphore objects

    See:

    Args:
        extSem_out: **[in]** External semaphores to be waited on

        paramsArray: **[in]** Array of semaphore parameters

        numExtSems: **[in]** Number of semaphores to wait on

        stream: **[in]** Stream to enqueue the wait operations in

    Returns:
        A ``tuple`` of size 1 that contains (in that order):
        - #hipSuccess, #hipErrorInvalidDevice, #hipErrorInvalidValue
    """
    _hipWaitExternalSemaphoresAsync__retval = hipError_t(chip.hipWaitExternalSemaphoresAsync(
        <void *const *>hip._util.types.DataHandle.from_pyobj(extSemArray)._ptr,
        hipExternalSemaphoreWaitParams_st.from_pyobj(paramsArray)._ptr,numExtSems,
        ihipStream_t.from_pyobj(stream)._ptr))    # fully specified
    return (_hipWaitExternalSemaphoresAsync__retval,)


@cython.embedsignature(True)
def hipDestroyExternalSemaphore(object extSem):
    r"""Destroys an external semaphore object and releases any references to the underlying resource. Any outstanding signals or waits must have completed before the semaphore is destroyed.

    See:

    Args:
        extSem: **[in]** handle to an external memory object

    Returns:
        A ``tuple`` of size 1 that contains (in that order):
        - #hipSuccess, #hipErrorInvalidDevice, #hipErrorInvalidValue
    """
    _hipDestroyExternalSemaphore__retval = hipError_t(chip.hipDestroyExternalSemaphore(
        <void *>hip._util.types.DataHandle.from_pyobj(extSem)._ptr))    # fully specified
    return (_hipDestroyExternalSemaphore__retval,)


@cython.embedsignature(True)
def hipImportExternalMemory(object extMem_out, object memHandleDesc):
    r"""Imports an external memory object.

    See:
        /

    Args:
        extMem_out: **[out]** Returned handle to an external memory object

        memHandleDesc: **[in]** Memory import handle descriptor

    Returns:
        A ``tuple`` of size 1 that contains (in that order):
        - #hipSuccess, #hipErrorInvalidDevice, #hipErrorInvalidValue
    """
    _hipImportExternalMemory__retval = hipError_t(chip.hipImportExternalMemory(
        <void **>hip._util.types.DataHandle.from_pyobj(extMem_out)._ptr,
        hipExternalMemoryHandleDesc_st.from_pyobj(memHandleDesc)._ptr))    # fully specified
    return (_hipImportExternalMemory__retval,)


@cython.embedsignature(True)
def hipExternalMemoryGetMappedBuffer(object extMem, object bufferDesc):
    r"""Maps a buffer onto an imported memory object.

    See:
        /

    Args:
        extMem: **[in]** Handle to external memory object

        bufferDesc: **[in]** Buffer descriptor

    Returns:
        A ``tuple`` of size 2 that contains (in that order):
        - #hipSuccess, #hipErrorInvalidDevice, #hipErrorInvalidValue
        - devPtr: Returned device pointer to buffer
    """
    devPtr = hip._util.types.DataHandle.from_ptr(NULL)
    _hipExternalMemoryGetMappedBuffer__retval = hipError_t(chip.hipExternalMemoryGetMappedBuffer(
        <void **>&devPtr._ptr,
        <void *>hip._util.types.DataHandle.from_pyobj(extMem)._ptr,
        hipExternalMemoryBufferDesc_st.from_pyobj(bufferDesc)._ptr))    # fully specified
    return (_hipExternalMemoryGetMappedBuffer__retval,devPtr)


@cython.embedsignature(True)
def hipDestroyExternalMemory(object extMem):
    r"""Destroys an external memory object.

    See:
        /

    Args:
        extMem: **[in]** External memory object to be destroyed

    Returns:
        A ``tuple`` of size 1 that contains (in that order):
        - #hipSuccess, #hipErrorInvalidDevice, #hipErrorInvalidValue
    """
    _hipDestroyExternalMemory__retval = hipError_t(chip.hipDestroyExternalMemory(
        <void *>hip._util.types.DataHandle.from_pyobj(extMem)._ptr))    # fully specified
    return (_hipDestroyExternalMemory__retval,)


@cython.embedsignature(True)
def hipMalloc(unsigned long size):
    r"""Allocate memory on the default accelerator

    If size is 0, no memory is allocated, *ptr returns nullptr, and hipSuccess is returned.

    See:
        hipMallocPitch, hipFree, hipMallocArray, hipFreeArray, hipMalloc3D, hipMalloc3DArray,
        hipHostFree, hipHostMalloc

    Args:
        size: **[in]** Requested memory size

    Returns:
        A ``tuple`` of size 2 that contains (in that order):
        - #hipSuccess, #hipErrorOutOfMemory, #hipErrorInvalidValue (bad context, null *ptr)
        - ptr: Pointer to the allocated memory
    """
    ptr = hip._util.types.DeviceArray.from_ptr(NULL)
    _hipMalloc__retval = hipError_t(chip.hipMalloc(
        <void **>&ptr._ptr,size))    # fully specified
    ptr.configure(_force=True,shape=(cpython.long.PyLong_FromUnsignedLong(size),))
    return (_hipMalloc__retval,ptr)


@cython.embedsignature(True)
def hipExtMallocWithFlags(unsigned long sizeBytes, unsigned int flags):
    r"""Allocate memory on the default accelerator

    If size is 0, no memory is allocated, *ptr returns nullptr, and hipSuccess is returned.

    See:
        hipMallocPitch, hipFree, hipMallocArray, hipFreeArray, hipMalloc3D, hipMalloc3DArray,
        hipHostFree, hipHostMalloc

    Args:
        size: **[in]** Requested memory size

        flags: **[in]** Type of memory allocation

    Returns:
        A ``tuple`` of size 2 that contains (in that order):
        - #hipSuccess, #hipErrorOutOfMemory, #hipErrorInvalidValue (bad context, null *ptr)
        - ptr: Pointer to the allocated memory
    """
    ptr = hip._util.types.DeviceArray.from_ptr(NULL)
    _hipExtMallocWithFlags__retval = hipError_t(chip.hipExtMallocWithFlags(
        <void **>&ptr._ptr,sizeBytes,flags))    # fully specified
    ptr.configure(_force=True,shape=(cpython.long.PyLong_FromUnsignedLong(sizeBytes),))
    return (_hipExtMallocWithFlags__retval,ptr)


@cython.embedsignature(True)
def hipMallocHost(unsigned long size):
    r"""Allocate pinned host memory [Deprecated]

    If size is 0, no memory is allocated, *ptr returns nullptr, and hipSuccess is returned.

    Deprecated:
        use hipHostMalloc() instead

    Args:
        size: **[in]** Requested memory size

    Returns:
        A ``tuple`` of size 2 that contains (in that order):
        - #hipSuccess, #hipErrorOutOfMemory
        - ptr: Pointer to the allocated host pinned memory
    """
    ptr = hip._util.types.DataHandle.from_ptr(NULL)
    _hipMallocHost__retval = hipError_t(chip.hipMallocHost(
        <void **>&ptr._ptr,size))    # fully specified
    return (_hipMallocHost__retval,ptr)


@cython.embedsignature(True)
def hipMemAllocHost(unsigned long size):
    r"""Allocate pinned host memory [Deprecated]

    If size is 0, no memory is allocated, *ptr returns nullptr, and hipSuccess is returned.

    Deprecated:
        use hipHostMalloc() instead

    Args:
        size: **[in]** Requested memory size

    Returns:
        A ``tuple`` of size 2 that contains (in that order):
        - #hipSuccess, #hipErrorOutOfMemory
        - ptr: Pointer to the allocated host pinned memory
    """
    ptr = hip._util.types.DataHandle.from_ptr(NULL)
    _hipMemAllocHost__retval = hipError_t(chip.hipMemAllocHost(
        <void **>&ptr._ptr,size))    # fully specified
    return (_hipMemAllocHost__retval,ptr)


@cython.embedsignature(True)
def hipHostMalloc(unsigned long size, unsigned int flags):
    r"""Allocate device accessible page locked host memory

    If size is 0, no memory is allocated, *ptr returns nullptr, and hipSuccess is returned.

    See:
        hipSetDeviceFlags, hipHostFree

    Args:
        size: **[in]** Requested memory size

        flags: **[in]** Type of host memory allocation

    Returns:
        A ``tuple`` of size 2 that contains (in that order):
        - #hipSuccess, #hipErrorOutOfMemory
        - ptr: Pointer to the allocated host pinned memory
    """
    ptr = hip._util.types.DataHandle.from_ptr(NULL)
    _hipHostMalloc__retval = hipError_t(chip.hipHostMalloc(
        <void **>&ptr._ptr,size,flags))    # fully specified
    return (_hipHostMalloc__retval,ptr)


@cython.embedsignature(True)
def hipMallocManaged(unsigned long size, unsigned int flags):
    r"""Allocates memory that will be automatically managed by HIP.

    Args:
        size: **[in]**  requested allocation size in bytes

        flags: **[in]**  must be either hipMemAttachGlobal or hipMemAttachHost
            (defaults to hipMemAttachGlobal)

    Returns:
        A ``tuple`` of size 2 that contains (in that order):
        - #hipSuccess, #hipErrorMemoryAllocation, #hipErrorNotSupported, #hipErrorInvalidValue
        - dev_ptr:  pointer to allocated device memory
    """
    dev_ptr = hip._util.types.DeviceArray.from_ptr(NULL)
    _hipMallocManaged__retval = hipError_t(chip.hipMallocManaged(
        <void **>&dev_ptr._ptr,size,flags))    # fully specified
    dev_ptr.configure(_force=True,shape=(cpython.long.PyLong_FromUnsignedLong(size),))
    return (_hipMallocManaged__retval,dev_ptr)


@cython.embedsignature(True)
def hipMemPrefetchAsync(object dev_ptr, unsigned long count, int device, object stream):
    r"""Prefetches memory to the specified destination device using HIP.

    Args:
        dev_ptr: **[in]** pointer to be prefetched

        count: **[in]** size in bytes for prefetching

        device: **[in]** destination device to prefetch to

        stream: **[in]** stream to enqueue prefetch operation

    Returns:
        A ``tuple`` of size 1 that contains (in that order):
        - #hipSuccess, #hipErrorInvalidValue
    """
    _hipMemPrefetchAsync__retval = hipError_t(chip.hipMemPrefetchAsync(
        <const void *>hip._util.types.DataHandle.from_pyobj(dev_ptr)._ptr,count,device,
        ihipStream_t.from_pyobj(stream)._ptr))    # fully specified
    return (_hipMemPrefetchAsync__retval,)


@cython.embedsignature(True)
def hipMemAdvise(object dev_ptr, unsigned long count, object advice, int device):
    r"""Advise about the usage of a given memory range to HIP.

    Args:
        dev_ptr: **[in]** pointer to memory to set the advice for

        count: **[in]** size in bytes of the memory range

        advice: **[in]** advice to be applied for the specified memory range

        device: **[in]** device to apply the advice for

    Returns:
        A ``tuple`` of size 1 that contains (in that order):
        - #hipSuccess, #hipErrorInvalidValue
    """
    if not isinstance(advice,_hipMemoryAdvise__Base):
        raise TypeError("argument 'advice' must be of type '_hipMemoryAdvise__Base'")
    _hipMemAdvise__retval = hipError_t(chip.hipMemAdvise(
        <const void *>hip._util.types.DataHandle.from_pyobj(dev_ptr)._ptr,count,advice.value,device))    # fully specified
    return (_hipMemAdvise__retval,)


@cython.embedsignature(True)
def hipMemRangeGetAttribute(object data, unsigned long data_size, object attribute, object dev_ptr, unsigned long count):
    r"""Query an attribute of a given memory range in HIP.

    Args:
        data: **[in,out]** a pointer to a memory location where the result of each
            attribute query will be written to

        data_size: **[in]** the size of data

        attribute: **[in]** the attribute to query

        dev_ptr: **[in]** start of the range to query

        count: **[in]** size of the range to query

    Returns:
        A ``tuple`` of size 1 that contains (in that order):
        - #hipSuccess, #hipErrorInvalidValue
    """
    if not isinstance(attribute,_hipMemRangeAttribute__Base):
        raise TypeError("argument 'attribute' must be of type '_hipMemRangeAttribute__Base'")
    _hipMemRangeGetAttribute__retval = hipError_t(chip.hipMemRangeGetAttribute(
        <void *>hip._util.types.DataHandle.from_pyobj(data)._ptr,data_size,attribute.value,
        <const void *>hip._util.types.DataHandle.from_pyobj(dev_ptr)._ptr,count))    # fully specified
    return (_hipMemRangeGetAttribute__retval,)


@cython.embedsignature(True)
def hipMemRangeGetAttributes(unsigned long num_attributes, object dev_ptr, unsigned long count):
    r"""Query attributes of a given memory range in HIP.

    Args:
        num_attributes: **[in]** an array of attributes to query (numAttributes and the number
            of attributes in this array should match)

        dev_ptr: **[in]** start of the range to query

        count: **[in]** size of the range to query

    Returns:
        A ``tuple`` of size 4 that contains (in that order):
        - #hipSuccess, #hipErrorInvalidValue
        - data: a two-dimensional array containing pointers to memory locations
                where the result of each attribute query will be written to
        - data_sizes: an array, containing the sizes of each result
        - attributes: the attribute to query
    """
    data = hip._util.types.DataHandle.from_ptr(NULL)
    cdef unsigned long data_sizes
    cdef chip.hipMemRangeAttribute attributes
    _hipMemRangeGetAttributes__retval = hipError_t(chip.hipMemRangeGetAttributes(
        <void **>&data._ptr,&data_sizes,&attributes,num_attributes,
        <const void *>hip._util.types.DataHandle.from_pyobj(dev_ptr)._ptr,count))    # fully specified
    return (_hipMemRangeGetAttributes__retval,data,data_sizes,hipMemRangeAttribute(attributes))


@cython.embedsignature(True)
def hipStreamAttachMemAsync(object stream, object dev_ptr, unsigned long length, unsigned int flags):
    r"""Attach memory to a stream asynchronously in HIP.

    Args:
        stream: **[in]**  stream in which to enqueue the attach operation

        dev_ptr: **[in]**  pointer to memory (must be a pointer to managed memory or
            to a valid host-accessible region of system-allocated memory)

        length: **[in]**  length of memory (defaults to zero)

        flags: **[in]**  must be one of hipMemAttachGlobal, hipMemAttachHost or
            hipMemAttachSingle (defaults to hipMemAttachSingle)

    Returns:
        A ``tuple`` of size 1 that contains (in that order):
        - #hipSuccess, #hipErrorInvalidValue
    """
    _hipStreamAttachMemAsync__retval = hipError_t(chip.hipStreamAttachMemAsync(
        ihipStream_t.from_pyobj(stream)._ptr,
        <void *>hip._util.types.DataHandle.from_pyobj(dev_ptr)._ptr,length,flags))    # fully specified
    return (_hipStreamAttachMemAsync__retval,)


@cython.embedsignature(True)
def hipMallocAsync(unsigned long size, object stream):
    r"""Allocates memory with stream ordered semantics

    Inserts a memory allocation operation into ``stream.``
    A pointer to the allocated memory is returned immediately in *dptr.
    The allocation must not be accessed until the the allocation operation completes.
    The allocation comes from the memory pool associated with the stream's device.

    Note:
        The default memory pool of a device contains device memory from that device.

    Note:
        Basic stream ordering allows future work submitted into the same stream to use the allocation.
        Stream query, stream synchronize, and HIP events can be used to guarantee that the allocation
        operation completes before work submitted in a separate stream runs.

    Note:
        During stream capture, this function results in the creation of an allocation node. In this case,
        the allocation is owned by the graph instead of the memory pool. The memory pool's properties
        are used to set the node's creation parameters.

    See:
        hipMallocFromPoolAsync, hipFreeAsync, hipMemPoolTrimTo, hipMemPoolGetAttribute,
        hipDeviceSetMemPool, hipMemPoolSetAttribute, hipMemPoolSetAccess, hipMemPoolGetAccess

    Warning:
        This API is marked as beta, meaning, while this is feature complete,
        it is still open to changes and may have outstanding issues.

    Args:
        size: **[in]** Number of bytes to allocate

        stream: **[in]** The stream establishing the stream ordering contract and
            the memory pool to allocate from

    Returns:
        A ``tuple`` of size 2 that contains (in that order):
        - #hipSuccess, #hipErrorInvalidValue, #hipErrorNotSupported, #hipErrorOutOfMemory
        - dev_ptr: Returned device pointer of memory allocation
    """
    dev_ptr = hip._util.types.DeviceArray.from_ptr(NULL)
    _hipMallocAsync__retval = hipError_t(chip.hipMallocAsync(
        <void **>&dev_ptr._ptr,size,
        ihipStream_t.from_pyobj(stream)._ptr))    # fully specified
    dev_ptr.configure(_force=True,shape=(cpython.long.PyLong_FromUnsignedLong(size),))
    return (_hipMallocAsync__retval,dev_ptr)


@cython.embedsignature(True)
def hipFreeAsync(object dev_ptr, object stream):
    r"""Frees memory with stream ordered semantics

    Inserts a free operation into ``stream.``
    The allocation must not be used after stream execution reaches the free.
    After this API returns, accessing the memory from any subsequent work launched on the GPU
    or querying its pointer attributes results in undefined behavior.

    Note:
        During stream capture, this function results in the creation of a free node and
        must therefore be passed the address of a graph allocation.

    See:
        hipMallocFromPoolAsync, hipMallocAsync, hipMemPoolTrimTo, hipMemPoolGetAttribute,
        hipDeviceSetMemPool, hipMemPoolSetAttribute, hipMemPoolSetAccess, hipMemPoolGetAccess

    Warning:
        This API is marked as beta, meaning, while this is feature complete,
        it is still open to changes and may have outstanding issues.

    Args:
        dev_ptr: **[in]** Pointer to device memory to free

        stream: **[in]** The stream, where the destruciton will occur according to the execution order

    Returns:
        A ``tuple`` of size 1 that contains (in that order):
        - hipSuccess, hipErrorInvalidValue, hipErrorNotSupported
    """
    _hipFreeAsync__retval = hipError_t(chip.hipFreeAsync(
        <void *>hip._util.types.DataHandle.from_pyobj(dev_ptr)._ptr,
        ihipStream_t.from_pyobj(stream)._ptr))    # fully specified
    return (_hipFreeAsync__retval,)


@cython.embedsignature(True)
def hipMemPoolTrimTo(object mem_pool, unsigned long min_bytes_to_hold):
    r"""Releases freed memory back to the OS

    Releases memory back to the OS until the pool contains fewer than ``min_bytes_to_keep``
    reserved bytes, or there is no more memory that the allocator can safely release.
    The allocator cannot release OS allocations that back outstanding asynchronous allocations.
    The OS allocations may happen at different granularity from the user allocations.

    Note:
        Allocations that have not been freed count as outstanding.

    Note:
        Allocations that have been asynchronously freed but whose completion has
        not been observed on the host (eg. by a synchronize) can count as outstanding.

    See:
        hipMallocFromPoolAsync, hipMallocAsync, hipFreeAsync, hipMemPoolGetAttribute,
        hipDeviceSetMemPool, hipMemPoolSetAttribute, hipMemPoolSetAccess, hipMemPoolGetAccess

    Warning:
        This API is marked as beta, meaning, while this is feature complete,
        it is still open to changes and may have outstanding issues.

    Args:
        mem_pool: **[in]** The memory pool to trim allocations

        min_bytes_to_hold: **[in]** If the pool has less than min_bytes_to_hold reserved,
            then the TrimTo operation is a no-op.  Otherwise the memory pool will contain
            at least min_bytes_to_hold bytes reserved after the operation.

    Returns:
        A ``tuple`` of size 1 that contains (in that order):
        - #hipSuccess, #hipErrorInvalidValue
    """
    _hipMemPoolTrimTo__retval = hipError_t(chip.hipMemPoolTrimTo(
        ihipMemPoolHandle_t.from_pyobj(mem_pool)._ptr,min_bytes_to_hold))    # fully specified
    return (_hipMemPoolTrimTo__retval,)


@cython.embedsignature(True)
def hipMemPoolSetAttribute(object mem_pool, object attr, object value):
    r"""Sets attributes of a memory pool

    Supported attributes are:
    - ``hipMemPoolAttrReleaseThreshold:`` (value type = cuuint64_t)
                                     Amount of reserved memory in bytes to hold onto before trying
                                     to release memory back to the OS. When more than the release
                                     threshold bytes of memory are held by the memory pool, the
                                     allocator will try to release memory back to the OS on the
                                     next call to stream, event or context synchronize. (default 0)
    - ``hipMemPoolReuseFollowEventDependencies:`` (value type = int)
                                     Allow ``hipMallocAsync`` to use memory asynchronously freed
                                     in another stream as long as a stream ordering dependency
                                     of the allocating stream on the free action exists.
                                     HIP events and null stream interactions can create the required
                                     stream ordered dependencies. (default enabled)
    - ``hipMemPoolReuseAllowOpportunistic:`` (value type = int)
                                     Allow reuse of already completed frees when there is no dependency
                                     between the free and allocation. (default enabled)
    - ``hipMemPoolReuseAllowInternalDependencies:`` (value type = int)
                                     Allow ``hipMallocAsync`` to insert new stream dependencies
                                     in order to establish the stream ordering required to reuse
                                     a piece of memory released by ``hipFreeAsync`` (default enabled).

    See:
        hipMallocFromPoolAsync, hipMallocAsync, hipFreeAsync, hipMemPoolGetAttribute,
        hipMemPoolTrimTo, hipDeviceSetMemPool, hipMemPoolSetAccess, hipMemPoolGetAccess

    Warning:
        This API is marked as beta, meaning, while this is feature complete,
        it is still open to changes and may have outstanding issues.

    Args:
        mem_pool: **[in]** The memory pool to modify

        attr: **[in]** The attribute to modify

        value: **[in]** Pointer to the value to assign

    Returns:
        A ``tuple`` of size 1 that contains (in that order):
        - #hipSuccess, #hipErrorInvalidValue
    """
    if not isinstance(attr,_hipMemPoolAttr__Base):
        raise TypeError("argument 'attr' must be of type '_hipMemPoolAttr__Base'")
    _hipMemPoolSetAttribute__retval = hipError_t(chip.hipMemPoolSetAttribute(
        ihipMemPoolHandle_t.from_pyobj(mem_pool)._ptr,attr.value,
        <void *>hip._util.types.DataHandle.from_pyobj(value)._ptr))    # fully specified
    return (_hipMemPoolSetAttribute__retval,)


@cython.embedsignature(True)
def hipMemPoolGetAttribute(object mem_pool, object attr, object value):
    r"""Gets attributes of a memory pool

    Supported attributes are:
    - ``hipMemPoolAttrReleaseThreshold:`` (value type = cuuint64_t)
                                     Amount of reserved memory in bytes to hold onto before trying
                                     to release memory back to the OS. When more than the release
                                     threshold bytes of memory are held by the memory pool, the
                                     allocator will try to release memory back to the OS on the
                                     next call to stream, event or context synchronize. (default 0)
    - ``hipMemPoolReuseFollowEventDependencies:`` (value type = int)
                                     Allow ``hipMallocAsync`` to use memory asynchronously freed
                                     in another stream as long as a stream ordering dependency
                                     of the allocating stream on the free action exists.
                                     HIP events and null stream interactions can create the required
                                     stream ordered dependencies. (default enabled)
    - ``hipMemPoolReuseAllowOpportunistic:`` (value type = int)
                                     Allow reuse of already completed frees when there is no dependency
                                     between the free and allocation. (default enabled)
    - ``hipMemPoolReuseAllowInternalDependencies:`` (value type = int)
                                     Allow ``hipMallocAsync`` to insert new stream dependencies
                                     in order to establish the stream ordering required to reuse
                                     a piece of memory released by ``hipFreeAsync`` (default enabled).

    See:
        hipMallocFromPoolAsync, hipMallocAsync, hipFreeAsync,
        hipMemPoolTrimTo, hipDeviceSetMemPool, hipMemPoolSetAttribute, hipMemPoolSetAccess, hipMemPoolGetAccess

    Warning:
        This API is marked as beta, meaning, while this is feature complete,
        it is still open to changes and may have outstanding issues.

    Args:
        mem_pool: **[in]** The memory pool to get attributes of

        attr: **[in]** The attribute to get

        value: **[in]** Retrieved value

    Returns:
        A ``tuple`` of size 1 that contains (in that order):
        - #hipSuccess, #hipErrorInvalidValue
    """
    if not isinstance(attr,_hipMemPoolAttr__Base):
        raise TypeError("argument 'attr' must be of type '_hipMemPoolAttr__Base'")
    _hipMemPoolGetAttribute__retval = hipError_t(chip.hipMemPoolGetAttribute(
        ihipMemPoolHandle_t.from_pyobj(mem_pool)._ptr,attr.value,
        <void *>hip._util.types.DataHandle.from_pyobj(value)._ptr))    # fully specified
    return (_hipMemPoolGetAttribute__retval,)


@cython.embedsignature(True)
def hipMemPoolSetAccess(object mem_pool, object desc_list, unsigned long count):
    r"""Controls visibility of the specified pool between devices

    See:
        hipMallocFromPoolAsync, hipMallocAsync, hipFreeAsync, hipMemPoolGetAttribute,
        hipMemPoolTrimTo, hipDeviceSetMemPool, hipMemPoolSetAttribute, hipMemPoolGetAccess

    Warning:
        This API is marked as beta, meaning, while this is feature complete,
        it is still open to changes and may have outstanding issues.

    Args:
        mem_pool: **[in]** Memory pool for acccess change

        desc_list: **[in]** Array of access descriptors. Each descriptor instructs the access to enable for a single gpu

        count: **[in]** Number of descriptors in the map array.

    Returns:
        A ``tuple`` of size 1 that contains (in that order):
        - #hipSuccess, #hipErrorInvalidValue
    """
    _hipMemPoolSetAccess__retval = hipError_t(chip.hipMemPoolSetAccess(
        ihipMemPoolHandle_t.from_pyobj(mem_pool)._ptr,
        hipMemAccessDesc.from_pyobj(desc_list)._ptr,count))    # fully specified
    return (_hipMemPoolSetAccess__retval,)


@cython.embedsignature(True)
def hipMemPoolGetAccess(object mem_pool, object location):
    r"""Returns the accessibility of a pool from a device

    Returns the accessibility of the pool's memory from the specified location.

    See:
        hipMallocFromPoolAsync, hipMallocAsync, hipFreeAsync, hipMemPoolGetAttribute,
        hipMemPoolTrimTo, hipDeviceSetMemPool, hipMemPoolSetAttribute, hipMemPoolSetAccess

    Warning:
        This API is marked as beta, meaning, while this is feature complete,
        it is still open to changes and may have outstanding issues.

    Args:
        mem_pool: **[in]** Memory pool being queried

        location: **[in]** Location/device for memory pool access

    Returns:
        A ``tuple`` of size 2 that contains (in that order):
        - #hipSuccess, #hipErrorInvalidValue
        - flags: Accessibility of the memory pool from the specified location/device
    """
    cdef chip.hipMemAccessFlags flags
    _hipMemPoolGetAccess__retval = hipError_t(chip.hipMemPoolGetAccess(&flags,
        ihipMemPoolHandle_t.from_pyobj(mem_pool)._ptr,
        hipMemLocation.from_pyobj(location)._ptr))    # fully specified
    return (_hipMemPoolGetAccess__retval,hipMemAccessFlags(flags))


@cython.embedsignature(True)
def hipMemPoolCreate(object pool_props):
    r"""Creates a memory pool

    Creates a HIP memory pool and returns the handle in ``mem_pool.`` The ``pool_props`` determines
    the properties of the pool such as the backing device and IPC capabilities.

    By default, the memory pool will be accessible from the device it is allocated on.

    Note:
        Specifying hipMemHandleTypeNone creates a memory pool that will not support IPC.

    See:
        hipMallocFromPoolAsync, hipMallocAsync, hipFreeAsync, hipMemPoolGetAttribute, hipMemPoolDestroy,
        hipMemPoolTrimTo, hipDeviceSetMemPool, hipMemPoolSetAttribute, hipMemPoolSetAccess, hipMemPoolGetAccess

    Warning:
        This API is marked as beta, meaning, while this is feature complete,
        it is still open to changes and may have outstanding issues.

    Args:
        pool_props: **[in]** Memory pool properties

    Returns:
        A ``tuple`` of size 2 that contains (in that order):
        - #hipSuccess, #hipErrorInvalidValue, #hipErrorNotSupported
        - mem_pool: Contains createed memory pool
    """
    mem_pool = ihipMemPoolHandle_t.from_ptr(NULL)
    _hipMemPoolCreate__retval = hipError_t(chip.hipMemPoolCreate(&mem_pool._ptr,
        hipMemPoolProps.from_pyobj(pool_props)._ptr))    # fully specified
    return (_hipMemPoolCreate__retval,mem_pool)


@cython.embedsignature(True)
def hipMemPoolDestroy(object mem_pool):
    r"""Destroys the specified memory pool

    If any pointers obtained from this pool haven't been freed or
    the pool has free operations that haven't completed
    when ``hipMemPoolDestroy`` is invoked, the function will return immediately and the
    resources associated with the pool will be released automatically
    once there are no more outstanding allocations.

    Destroying the current mempool of a device sets the default mempool of
    that device as the current mempool for that device.

    Note:
        A device's default memory pool cannot be destroyed.

    See:
        hipMallocFromPoolAsync, hipMallocAsync, hipFreeAsync, hipMemPoolGetAttribute, hipMemPoolCreate
        hipMemPoolTrimTo, hipDeviceSetMemPool, hipMemPoolSetAttribute, hipMemPoolSetAccess, hipMemPoolGetAccess

    Warning:
        This API is marked as beta, meaning, while this is feature complete,
        it is still open to changes and may have outstanding issues.

    Args:
        mem_pool: **[in]** Memory pool for destruction

    Returns:
        A ``tuple`` of size 1 that contains (in that order):
        - #hipSuccess, #hipErrorInvalidValue
    """
    _hipMemPoolDestroy__retval = hipError_t(chip.hipMemPoolDestroy(
        ihipMemPoolHandle_t.from_pyobj(mem_pool)._ptr))    # fully specified
    return (_hipMemPoolDestroy__retval,)


@cython.embedsignature(True)
def hipMallocFromPoolAsync(unsigned long size, object mem_pool, object stream):
    r"""Allocates memory from a specified pool with stream ordered semantics.

    Inserts an allocation operation into ``stream.``
    A pointer to the allocated memory is returned immediately in ``dev_ptr.``
    The allocation must not be accessed until the the allocation operation completes.
    The allocation comes from the specified memory pool.

    Note:
        The specified memory pool may be from a device different than that of the specified ``stream.``

    Basic stream ordering allows future work submitted into the same stream to use the allocation.
    Stream query, stream synchronize, and HIP events can be used to guarantee that the allocation
    operation completes before work submitted in a separate stream runs.

    Note:
        During stream capture, this function results in the creation of an allocation node. In this case,
        the allocation is owned by the graph instead of the memory pool. The memory pool's properties
        are used to set the node's creation parameters.

    See:
        hipMallocAsync, hipFreeAsync, hipMemPoolGetAttribute, hipMemPoolCreate
        hipMemPoolTrimTo, hipDeviceSetMemPool, hipMemPoolSetAttribute, hipMemPoolSetAccess, hipMemPoolGetAccess,

    Warning:
        This API is marked as beta, meaning, while this is feature complete,
        it is still open to changes and may have outstanding issues.

    Args:
        size: **[in]** Number of bytes to allocate

        mem_pool: **[in]** The pool to allocate from

        stream: **[in]** The stream establishing the stream ordering semantic

    Returns:
        A ``tuple`` of size 2 that contains (in that order):
        - #hipSuccess, #hipErrorInvalidValue, #hipErrorNotSupported, #hipErrorOutOfMemory
        - dev_ptr: Returned device pointer
    """
    dev_ptr = hip._util.types.DeviceArray.from_ptr(NULL)
    _hipMallocFromPoolAsync__retval = hipError_t(chip.hipMallocFromPoolAsync(
        <void **>&dev_ptr._ptr,size,
        ihipMemPoolHandle_t.from_pyobj(mem_pool)._ptr,
        ihipStream_t.from_pyobj(stream)._ptr))    # fully specified
    dev_ptr.configure(_force=True,shape=(cpython.long.PyLong_FromUnsignedLong(size),))
    return (_hipMallocFromPoolAsync__retval,dev_ptr)


@cython.embedsignature(True)
def hipMemPoolExportToShareableHandle(object shared_handle, object mem_pool, object handle_type, unsigned int flags):
    r"""Exports a memory pool to the requested handle type.

    Given an IPC capable mempool, create an OS handle to share the pool with another process.
    A recipient process can convert the shareable handle into a mempool with ``hipMemPoolImportFromShareableHandle.``
    Individual pointers can then be shared with the ``hipMemPoolExportPointer`` and ``hipMemPoolImportPointer`` APIs.
    The implementation of what the shareable handle is and how it can be transferred is defined by the requested
    handle type.

    Note:
        To create an IPC capable mempool, create a mempool with a ``hipMemAllocationHandleType`` other
        than ``hipMemHandleTypeNone.``

    See:
        hipMemPoolImportFromShareableHandle

    Warning:
        This API is marked as beta, meaning, while this is feature complete,
        it is still open to changes and may have outstanding issues.

    Args:
        shared_handle: **[out]** Pointer to the location in which to store the requested handle

        mem_pool: **[in]** Pool to export

        handle_type: **[in]** The type of handle to create

        flags: **[in]** Must be 0

    Returns:
        A ``tuple`` of size 1 that contains (in that order):
        - #hipSuccess, #hipErrorInvalidValue, #hipErrorOutOfMemory
    """
    if not isinstance(handle_type,_hipMemAllocationHandleType__Base):
        raise TypeError("argument 'handle_type' must be of type '_hipMemAllocationHandleType__Base'")
    _hipMemPoolExportToShareableHandle__retval = hipError_t(chip.hipMemPoolExportToShareableHandle(
        <void *>hip._util.types.DataHandle.from_pyobj(shared_handle)._ptr,
        ihipMemPoolHandle_t.from_pyobj(mem_pool)._ptr,handle_type.value,flags))    # fully specified
    return (_hipMemPoolExportToShareableHandle__retval,)


@cython.embedsignature(True)
def hipMemPoolImportFromShareableHandle(object shared_handle, object handle_type, unsigned int flags):
    r"""Imports a memory pool from a shared handle.

    Specific allocations can be imported from the imported pool with ``hipMemPoolImportPointer.``

    Note:
        Imported memory pools do not support creating new allocations.
        As such imported memory pools may not be used in ``hipDeviceSetMemPool``
        or ``hipMallocFromPoolAsync`` calls.

    See:
        hipMemPoolExportToShareableHandle

    Warning:
        This API is marked as beta, meaning, while this is feature complete,
        it is still open to changes and may have outstanding issues.

    Args:
        shared_handle: **[in]** OS handle of the pool to open

        handle_type: **[in]** The type of handle being imported

        flags: **[in]** Must be 0

    Returns:
        A ``tuple`` of size 2 that contains (in that order):
        - #hipSuccess, #hipErrorInvalidValue, #hipErrorOutOfMemory
        - mem_pool: Returned memory pool
    """
    mem_pool = ihipMemPoolHandle_t.from_ptr(NULL)
    if not isinstance(handle_type,_hipMemAllocationHandleType__Base):
        raise TypeError("argument 'handle_type' must be of type '_hipMemAllocationHandleType__Base'")
    _hipMemPoolImportFromShareableHandle__retval = hipError_t(chip.hipMemPoolImportFromShareableHandle(&mem_pool._ptr,
        <void *>hip._util.types.DataHandle.from_pyobj(shared_handle)._ptr,handle_type.value,flags))    # fully specified
    return (_hipMemPoolImportFromShareableHandle__retval,mem_pool)


@cython.embedsignature(True)
def hipMemPoolExportPointer(object export_data, object dev_ptr):
    r"""Export data to share a memory pool allocation between processes.

    Constructs ``export_data`` for sharing a specific allocation from an already shared memory pool.
    The recipient process can import the allocation with the ``hipMemPoolImportPointer`` api.
    The data is not a handle and may be shared through any IPC mechanism.

    See:
        hipMemPoolImportPointer

    Warning:
        This API is marked as beta, meaning, while this is feature complete,
        it is still open to changes and may have outstanding issues.

    Args:
        export_data: **[out]** Returned export data

        dev_ptr: **[in]** Pointer to memory being exported

    Returns:
        A ``tuple`` of size 1 that contains (in that order):
        - #hipSuccess, #hipErrorInvalidValue, #hipErrorOutOfMemory
    """
    _hipMemPoolExportPointer__retval = hipError_t(chip.hipMemPoolExportPointer(
        hipMemPoolPtrExportData.from_pyobj(export_data)._ptr,
        <void *>hip._util.types.DataHandle.from_pyobj(dev_ptr)._ptr))    # fully specified
    return (_hipMemPoolExportPointer__retval,)


@cython.embedsignature(True)
def hipMemPoolImportPointer(object mem_pool, object export_data):
    r"""Import a memory pool allocation from another process.

    Returns in ``dev_ptr`` a pointer to the imported memory.
    The imported memory must not be accessed before the allocation operation completes
    in the exporting process. The imported memory must be freed from all importing processes before
    being freed in the exporting process. The pointer may be freed with ``hipFree``
    or ``hipFreeAsync.`` If ``hipFreeAsync`` is used, the free must be completed
    on the importing process before the free operation on the exporting process.

    Note:
        The ``hipFreeAsync`` api may be used in the exporting process before
        the ``hipFreeAsync`` operation completes in its stream as long as the
        ``hipFreeAsync`` in the exporting process specifies a stream with
        a stream dependency on the importing process's ``hipFreeAsync.``

    See:
        hipMemPoolExportPointer

    Warning:
        This API is marked as beta, meaning, while this is feature complete,
        it is still open to changes and may have outstanding issues.

    Args:
        mem_pool: **[in]** Memory pool from which to import a pointer

        export_data: **[in]** Data specifying the memory to import

    Returns:
        A ``tuple`` of size 2 that contains (in that order):
        - #hipSuccess, #hipErrorInvalidValue, #hipErrorNotInitialized, #hipErrorOutOfMemory
        - dev_ptr: Pointer to imported memory
    """
    dev_ptr = hip._util.types.DataHandle.from_ptr(NULL)
    _hipMemPoolImportPointer__retval = hipError_t(chip.hipMemPoolImportPointer(
        <void **>&dev_ptr._ptr,
        ihipMemPoolHandle_t.from_pyobj(mem_pool)._ptr,
        hipMemPoolPtrExportData.from_pyobj(export_data)._ptr))    # fully specified
    return (_hipMemPoolImportPointer__retval,dev_ptr)


@cython.embedsignature(True)
def hipHostAlloc(unsigned long size, unsigned int flags):
    r"""Allocate device accessible page locked host memory [Deprecated]

    If size is 0, no memory is allocated, *ptr returns nullptr, and hipSuccess is returned.

    Deprecated:
        use hipHostMalloc() instead

    Args:
        size: **[in]** Requested memory size

        flags: **[in]** Type of host memory allocation

    Returns:
        A ``tuple`` of size 2 that contains (in that order):
        - #hipSuccess, #hipErrorOutOfMemory
        - ptr: Pointer to the allocated host pinned memory
    """
    ptr = hip._util.types.DataHandle.from_ptr(NULL)
    _hipHostAlloc__retval = hipError_t(chip.hipHostAlloc(
        <void **>&ptr._ptr,size,flags))    # fully specified
    return (_hipHostAlloc__retval,ptr)


@cython.embedsignature(True)
def hipHostGetDevicePointer(object hstPtr, unsigned int flags):
    r"""Get Device pointer from Host Pointer allocated through hipHostMalloc

    See:
        hipSetDeviceFlags, hipHostMalloc

    Args:
        dstPtr: **[out]** Device Pointer mapped to passed host pointer

        hstPtr: **[in]** Host Pointer allocated through hipHostMalloc

        flags: **[in]** Flags to be passed for extension

    Returns:
        A ``tuple`` of size 1 that contains (in that order):
        - #hipSuccess, #hipErrorInvalidValue, #hipErrorOutOfMemory
    """
    devPtr = hip._util.types.DataHandle.from_ptr(NULL)
    _hipHostGetDevicePointer__retval = hipError_t(chip.hipHostGetDevicePointer(
        <void **>&devPtr._ptr,
        <void *>hip._util.types.DataHandle.from_pyobj(hstPtr)._ptr,flags))    # fully specified
    return (_hipHostGetDevicePointer__retval,devPtr)


@cython.embedsignature(True)
def hipHostGetFlags(object hostPtr):
    r"""Return flags associated with host pointer

    See:
        hipHostMalloc

    Args:
        hostPtr: **[in]** Host Pointer allocated through hipHostMalloc

    Returns:
        A ``tuple`` of size 2 that contains (in that order):
        - #hipSuccess, #hipErrorInvalidValue
        - flagsPtr: Memory location to store flags
    """
    cdef unsigned int flagsPtr
    _hipHostGetFlags__retval = hipError_t(chip.hipHostGetFlags(&flagsPtr,
        <void *>hip._util.types.DataHandle.from_pyobj(hostPtr)._ptr))    # fully specified
    return (_hipHostGetFlags__retval,flagsPtr)


@cython.embedsignature(True)
def hipHostRegister(object hostPtr, unsigned long sizeBytes, unsigned int flags):
    r"""Register host memory so it can be accessed from the current device.

    Flags:
     - #hipHostRegisterDefault   Memory is Mapped and Portable
     - #hipHostRegisterPortable  Memory is considered registered by all contexts.  HIP only supports
    one context so this is always assumed true.
     - #hipHostRegisterMapped    Map the allocation into the address space for the current device.
    The device pointer can be obtained with #hipHostGetDevicePointer.

     After registering the memory, use #hipHostGetDevicePointer to obtain the mapped device pointer.
     On many systems, the mapped device pointer will have a different value than the mapped host
    pointer.  Applications must use the device pointer in device code, and the host pointer in device
    code.

     On some systems, registered memory is pinned.  On some systems, registered memory may not be
    actually be pinned but uses OS or hardware facilities to all GPU access to the host memory.

     Developers are strongly encouraged to register memory blocks which are aligned to the host
    cache-line size. (typically 64-bytes but can be obtains from the CPUID instruction).

     If registering non-aligned pointers, the application must take care when register pointers from
    the same cache line on different devices.  HIP's coarse-grained synchronization model does not
    guarantee correct results if different devices write to different parts of the same cache block -
    typically one of the writes will "win" and overwrite data from the other registered memory
    region.

    See:
        hipHostUnregister, hipHostGetFlags, hipHostGetDevicePointer

    Args:
        hostPtr: **[out]** Pointer to host memory to be registered.

        sizeBytes: **[in]** size of the host memory

        flags: **[in]** .  See below.

    Returns:
        A ``tuple`` of size 1 that contains (in that order):
        - #hipSuccess, #hipErrorOutOfMemory
    """
    _hipHostRegister__retval = hipError_t(chip.hipHostRegister(
        <void *>hip._util.types.DataHandle.from_pyobj(hostPtr)._ptr,sizeBytes,flags))    # fully specified
    return (_hipHostRegister__retval,)


@cython.embedsignature(True)
def hipHostUnregister(object hostPtr):
    r"""Un-register host pointer

    See:
        hipHostRegister

    Args:
        hostPtr: **[in]** Host pointer previously registered with #hipHostRegister

    Returns:
        A ``tuple`` of size 1 that contains (in that order):
        - Error code
    """
    _hipHostUnregister__retval = hipError_t(chip.hipHostUnregister(
        <void *>hip._util.types.DataHandle.from_pyobj(hostPtr)._ptr))    # fully specified
    return (_hipHostUnregister__retval,)


@cython.embedsignature(True)
def hipMallocPitch(unsigned long width, unsigned long height):
    r"""(No short description)

    Allocates at least width (in bytes) * height bytes of linear memory
    Padding may occur to ensure alighnment requirements are met for the given row
    The change in width size due to padding will be returned in *pitch.
    Currently the alignment is set to 128 bytes

    If size is 0, no memory is allocated, *ptr returns nullptr, and hipSuccess is returned.

    See:
        hipMalloc, hipFree, hipMallocArray, hipFreeArray, hipHostFree, hipMalloc3D,
        hipMalloc3DArray, hipHostMalloc

    Args:
        width: **[in]** Requested pitched allocation width (in bytes)

        height: **[in]** Requested pitched allocation height

    Returns:
        A ``tuple`` of size 3 that contains (in that order):
        - Error code
        - ptr: Pointer to the allocated device memory
        - pitch: Pitch for allocation (in bytes)
    """
    ptr = hip._util.types.DataHandle.from_ptr(NULL)
    cdef unsigned long pitch
    _hipMallocPitch__retval = hipError_t(chip.hipMallocPitch(
        <void **>&ptr._ptr,&pitch,width,height))    # fully specified
    return (_hipMallocPitch__retval,ptr,pitch)


@cython.embedsignature(True)
def hipMemAllocPitch(unsigned long widthInBytes, unsigned long height, unsigned int elementSizeBytes):
    r"""(No short description)

    Allocates at least width (in bytes) * height bytes of linear memory
    Padding may occur to ensure alighnment requirements are met for the given row
    The change in width size due to padding will be returned in *pitch.
    Currently the alignment is set to 128 bytes

    If size is 0, no memory is allocated, *ptr returns nullptr, and hipSuccess is returned.
    The intended usage of pitch is as a separate parameter of the allocation, used to compute addresses within the 2D array.
    Given the row and column of an array element of type T, the address is computed as:
    T* pElement = (T*)((char*)BaseAddress + Row * Pitch) + Column;

    See:
        hipMalloc, hipFree, hipMallocArray, hipFreeArray, hipHostFree, hipMalloc3D,
        hipMalloc3DArray, hipHostMalloc

    Args:
        width: **[in]** Requested pitched allocation width (in bytes)

        height: **[in]** Requested pitched allocation height

    Returns:
        A ``tuple`` of size 3 that contains (in that order):
        - Error code
        - dptr: Pointer to the allocated device memory
        - pitch: Pitch for allocation (in bytes)
    """
    dptr = hip._util.types.DataHandle.from_ptr(NULL)
    cdef unsigned long pitch
    _hipMemAllocPitch__retval = hipError_t(chip.hipMemAllocPitch(
        <void **>&dptr._ptr,&pitch,widthInBytes,height,elementSizeBytes))    # fully specified
    return (_hipMemAllocPitch__retval,dptr,pitch)


@cython.embedsignature(True)
def hipFree(object ptr):
    r"""Free memory allocated by the hcc hip memory allocation API.
     This API performs an implicit hipDeviceSynchronize() call.
     If pointer is NULL, the hip runtime is initialized and hipSuccess is returned.

    See:
        hipMalloc, hipMallocPitch, hipMallocArray, hipFreeArray, hipHostFree, hipMalloc3D,
        hipMalloc3DArray, hipHostMalloc

    Args:
        ptr: **[in]** Pointer to memory to be freed

    Returns:
        A ``tuple`` of size 2 that contains (in that order):
        - #hipSuccess
        - #hipErrorInvalidDevicePointer (if pointer is invalid, including host pointers allocated
            with hipHostMalloc)
    """
    _hipFree__retval = hipError_t(chip.hipFree(
        <void *>hip._util.types.DataHandle.from_pyobj(ptr)._ptr))    # fully specified
    return (_hipFree__retval,)


@cython.embedsignature(True)
def hipFreeHost(object ptr):
    r"""Free memory allocated by the hcc hip host memory allocation API.  [Deprecated]

    Deprecated:
        use hipHostFree() instead

    Args:
        ptr: **[in]** Pointer to memory to be freed

    Returns:
        A ``tuple`` of size 1 that contains (in that order):
        - #hipSuccess,
                       #hipErrorInvalidValue (if pointer is invalid, including device pointers allocated with
            hipMalloc)
    """
    _hipFreeHost__retval = hipError_t(chip.hipFreeHost(
        <void *>hip._util.types.DataHandle.from_pyobj(ptr)._ptr))    # fully specified
    return (_hipFreeHost__retval,)


@cython.embedsignature(True)
def hipHostFree(object ptr):
    r"""Free memory allocated by the hcc hip host memory allocation API
     This API performs an implicit hipDeviceSynchronize() call.
     If pointer is NULL, the hip runtime is initialized and hipSuccess is returned.

    See:
        hipMalloc, hipMallocPitch, hipFree, hipMallocArray, hipFreeArray, hipMalloc3D,
        hipMalloc3DArray, hipHostMalloc

    Args:
        ptr: **[in]** Pointer to memory to be freed

    Returns:
        A ``tuple`` of size 1 that contains (in that order):
        - #hipSuccess,
                     #hipErrorInvalidValue (if pointer is invalid, including device pointers allocated with
            hipMalloc)
    """
    _hipHostFree__retval = hipError_t(chip.hipHostFree(
        <void *>hip._util.types.DataHandle.from_pyobj(ptr)._ptr))    # fully specified
    return (_hipHostFree__retval,)


@cython.embedsignature(True)
def hipMemcpy(object dst, object src, unsigned long sizeBytes, object kind):
    r"""Copy data from src to dst.

    It supports memory from host to device,
    device to host, device to device and host to host
    The src and dst must not overlap.

    For hipMemcpy, the copy is always performed by the current device (set by hipSetDevice).
    For multi-gpu or peer-to-peer configurations, it is recommended to set the current device to the
    device where the src data is physically located. For optimal peer-to-peer copies, the copy device
    must be able to access the src and dst pointers (by calling hipDeviceEnablePeerAccess with copy
    agent as the current device and src/dest as the peerDevice argument.  if this is not done, the
    hipMemcpy will still work, but will perform the copy using a staging buffer on the host.
    Calling hipMemcpy with dst and src pointers that do not match the hipMemcpyKind results in
    undefined behavior.

    See:
        hipArrayCreate, hipArrayDestroy, hipArrayGetDescriptor, hipMemAlloc, hipMemAllocHost,
        hipMemAllocPitch, hipMemcpy2D, hipMemcpy2DAsync, hipMemcpy2DUnaligned, hipMemcpyAtoA,
        hipMemcpyAtoD, hipMemcpyAtoH, hipMemcpyAtoHAsync, hipMemcpyDtoA, hipMemcpyDtoD,
        hipMemcpyDtoDAsync, hipMemcpyDtoH, hipMemcpyDtoHAsync, hipMemcpyHtoA, hipMemcpyHtoAAsync,
        hipMemcpyHtoDAsync, hipMemFree, hipMemFreeHost, hipMemGetAddressRange, hipMemGetInfo,
        hipMemHostAlloc, hipMemHostGetDevicePointer

    Args:
        dst: **[out]** Data being copy to

        src: **[in]** Data being copy from

        sizeBytes: **[in]** Data size in bytes

        copyType: **[in]** Memory copy type

    Returns:
        A ``tuple`` of size 1 that contains (in that order):
        - #hipSuccess, #hipErrorInvalidValue, #hipErrorMemoryFree, #hipErrorUnknowni
    """
    if not isinstance(kind,_hipMemcpyKind__Base):
        raise TypeError("argument 'kind' must be of type '_hipMemcpyKind__Base'")
    _hipMemcpy__retval = hipError_t(chip.hipMemcpy(
        <void *>hip._util.types.DataHandle.from_pyobj(dst)._ptr,
        <const void *>hip._util.types.DataHandle.from_pyobj(src)._ptr,sizeBytes,kind.value))    # fully specified
    return (_hipMemcpy__retval,)


@cython.embedsignature(True)
def hipMemcpyWithStream(object dst, object src, unsigned long sizeBytes, object kind, object stream):
    r"""(No short description)
    """
    if not isinstance(kind,_hipMemcpyKind__Base):
        raise TypeError("argument 'kind' must be of type '_hipMemcpyKind__Base'")
    _hipMemcpyWithStream__retval = hipError_t(chip.hipMemcpyWithStream(
        <void *>hip._util.types.DataHandle.from_pyobj(dst)._ptr,
        <const void *>hip._util.types.DataHandle.from_pyobj(src)._ptr,sizeBytes,kind.value,
        ihipStream_t.from_pyobj(stream)._ptr))    # fully specified
    return (_hipMemcpyWithStream__retval,)


@cython.embedsignature(True)
def hipMemcpyHtoD(object dst, object src, unsigned long sizeBytes):
    r"""Copy data from Host to Device

    See:
        hipArrayCreate, hipArrayDestroy, hipArrayGetDescriptor, hipMemAlloc, hipMemAllocHost,
        hipMemAllocPitch, hipMemcpy2D, hipMemcpy2DAsync, hipMemcpy2DUnaligned, hipMemcpyAtoA,
        hipMemcpyAtoD, hipMemcpyAtoH, hipMemcpyAtoHAsync, hipMemcpyDtoA, hipMemcpyDtoD,
        hipMemcpyDtoDAsync, hipMemcpyDtoH, hipMemcpyDtoHAsync, hipMemcpyHtoA, hipMemcpyHtoAAsync,
        hipMemcpyHtoDAsync, hipMemFree, hipMemFreeHost, hipMemGetAddressRange, hipMemGetInfo,
        hipMemHostAlloc, hipMemHostGetDevicePointer

    Args:
        dst: **[out]** Data being copy to

        src: **[in]** Data being copy from

        sizeBytes: **[in]** Data size in bytes

    Returns:
        A ``tuple`` of size 1 that contains (in that order):
        - #hipSuccess, #hipErrorDeinitialized, #hipErrorNotInitialized, #hipErrorInvalidContext,
            #hipErrorInvalidValue
    """
    _hipMemcpyHtoD__retval = hipError_t(chip.hipMemcpyHtoD(
        <void *>hip._util.types.DataHandle.from_pyobj(dst)._ptr,
        <void *>hip._util.types.DataHandle.from_pyobj(src)._ptr,sizeBytes))    # fully specified
    return (_hipMemcpyHtoD__retval,)


@cython.embedsignature(True)
def hipMemcpyDtoH(object dst, object src, unsigned long sizeBytes):
    r"""Copy data from Device to Host

    See:
        hipArrayCreate, hipArrayDestroy, hipArrayGetDescriptor, hipMemAlloc, hipMemAllocHost,
        hipMemAllocPitch, hipMemcpy2D, hipMemcpy2DAsync, hipMemcpy2DUnaligned, hipMemcpyAtoA,
        hipMemcpyAtoD, hipMemcpyAtoH, hipMemcpyAtoHAsync, hipMemcpyDtoA, hipMemcpyDtoD,
        hipMemcpyDtoDAsync, hipMemcpyDtoH, hipMemcpyDtoHAsync, hipMemcpyHtoA, hipMemcpyHtoAAsync,
        hipMemcpyHtoDAsync, hipMemFree, hipMemFreeHost, hipMemGetAddressRange, hipMemGetInfo,
        hipMemHostAlloc, hipMemHostGetDevicePointer

    Args:
        dst: **[out]** Data being copy to

        src: **[in]** Data being copy from

        sizeBytes: **[in]** Data size in bytes

    Returns:
        A ``tuple`` of size 1 that contains (in that order):
        - #hipSuccess, #hipErrorDeinitialized, #hipErrorNotInitialized, #hipErrorInvalidContext,
            #hipErrorInvalidValue
    """
    _hipMemcpyDtoH__retval = hipError_t(chip.hipMemcpyDtoH(
        <void *>hip._util.types.DataHandle.from_pyobj(dst)._ptr,
        <void *>hip._util.types.DataHandle.from_pyobj(src)._ptr,sizeBytes))    # fully specified
    return (_hipMemcpyDtoH__retval,)


@cython.embedsignature(True)
def hipMemcpyDtoD(object dst, object src, unsigned long sizeBytes):
    r"""Copy data from Device to Device

    See:
        hipArrayCreate, hipArrayDestroy, hipArrayGetDescriptor, hipMemAlloc, hipMemAllocHost,
        hipMemAllocPitch, hipMemcpy2D, hipMemcpy2DAsync, hipMemcpy2DUnaligned, hipMemcpyAtoA,
        hipMemcpyAtoD, hipMemcpyAtoH, hipMemcpyAtoHAsync, hipMemcpyDtoA, hipMemcpyDtoD,
        hipMemcpyDtoDAsync, hipMemcpyDtoH, hipMemcpyDtoHAsync, hipMemcpyHtoA, hipMemcpyHtoAAsync,
        hipMemcpyHtoDAsync, hipMemFree, hipMemFreeHost, hipMemGetAddressRange, hipMemGetInfo,
        hipMemHostAlloc, hipMemHostGetDevicePointer

    Args:
        dst: **[out]** Data being copy to

        src: **[in]** Data being copy from

        sizeBytes: **[in]** Data size in bytes

    Returns:
        A ``tuple`` of size 1 that contains (in that order):
        - #hipSuccess, #hipErrorDeinitialized, #hipErrorNotInitialized, #hipErrorInvalidContext,
            #hipErrorInvalidValue
    """
    _hipMemcpyDtoD__retval = hipError_t(chip.hipMemcpyDtoD(
        <void *>hip._util.types.DataHandle.from_pyobj(dst)._ptr,
        <void *>hip._util.types.DataHandle.from_pyobj(src)._ptr,sizeBytes))    # fully specified
    return (_hipMemcpyDtoD__retval,)


@cython.embedsignature(True)
def hipMemcpyHtoDAsync(object dst, object src, unsigned long sizeBytes, object stream):
    r"""Copy data from Host to Device asynchronously

    See:
        hipArrayCreate, hipArrayDestroy, hipArrayGetDescriptor, hipMemAlloc, hipMemAllocHost,
        hipMemAllocPitch, hipMemcpy2D, hipMemcpy2DAsync, hipMemcpy2DUnaligned, hipMemcpyAtoA,
        hipMemcpyAtoD, hipMemcpyAtoH, hipMemcpyAtoHAsync, hipMemcpyDtoA, hipMemcpyDtoD,
        hipMemcpyDtoDAsync, hipMemcpyDtoH, hipMemcpyDtoHAsync, hipMemcpyHtoA, hipMemcpyHtoAAsync,
        hipMemcpyHtoDAsync, hipMemFree, hipMemFreeHost, hipMemGetAddressRange, hipMemGetInfo,
        hipMemHostAlloc, hipMemHostGetDevicePointer

    Args:
        dst: **[out]** Data being copy to

        src: **[in]** Data being copy from

        sizeBytes: **[in]** Data size in bytes

    Returns:
        A ``tuple`` of size 1 that contains (in that order):
        - #hipSuccess, #hipErrorDeinitialized, #hipErrorNotInitialized, #hipErrorInvalidContext,
            #hipErrorInvalidValue
    """
    _hipMemcpyHtoDAsync__retval = hipError_t(chip.hipMemcpyHtoDAsync(
        <void *>hip._util.types.DataHandle.from_pyobj(dst)._ptr,
        <void *>hip._util.types.DataHandle.from_pyobj(src)._ptr,sizeBytes,
        ihipStream_t.from_pyobj(stream)._ptr))    # fully specified
    return (_hipMemcpyHtoDAsync__retval,)


@cython.embedsignature(True)
def hipMemcpyDtoHAsync(object dst, object src, unsigned long sizeBytes, object stream):
    r"""Copy data from Device to Host asynchronously

    See:
        hipArrayCreate, hipArrayDestroy, hipArrayGetDescriptor, hipMemAlloc, hipMemAllocHost,
        hipMemAllocPitch, hipMemcpy2D, hipMemcpy2DAsync, hipMemcpy2DUnaligned, hipMemcpyAtoA,
        hipMemcpyAtoD, hipMemcpyAtoH, hipMemcpyAtoHAsync, hipMemcpyDtoA, hipMemcpyDtoD,
        hipMemcpyDtoDAsync, hipMemcpyDtoH, hipMemcpyDtoHAsync, hipMemcpyHtoA, hipMemcpyHtoAAsync,
        hipMemcpyHtoDAsync, hipMemFree, hipMemFreeHost, hipMemGetAddressRange, hipMemGetInfo,
        hipMemHostAlloc, hipMemHostGetDevicePointer

    Args:
        dst: **[out]** Data being copy to

        src: **[in]** Data being copy from

        sizeBytes: **[in]** Data size in bytes

    Returns:
        A ``tuple`` of size 1 that contains (in that order):
        - #hipSuccess, #hipErrorDeinitialized, #hipErrorNotInitialized, #hipErrorInvalidContext,
            #hipErrorInvalidValue
    """
    _hipMemcpyDtoHAsync__retval = hipError_t(chip.hipMemcpyDtoHAsync(
        <void *>hip._util.types.DataHandle.from_pyobj(dst)._ptr,
        <void *>hip._util.types.DataHandle.from_pyobj(src)._ptr,sizeBytes,
        ihipStream_t.from_pyobj(stream)._ptr))    # fully specified
    return (_hipMemcpyDtoHAsync__retval,)


@cython.embedsignature(True)
def hipMemcpyDtoDAsync(object dst, object src, unsigned long sizeBytes, object stream):
    r"""Copy data from Device to Device asynchronously

    See:
        hipArrayCreate, hipArrayDestroy, hipArrayGetDescriptor, hipMemAlloc, hipMemAllocHost,
        hipMemAllocPitch, hipMemcpy2D, hipMemcpy2DAsync, hipMemcpy2DUnaligned, hipMemcpyAtoA,
        hipMemcpyAtoD, hipMemcpyAtoH, hipMemcpyAtoHAsync, hipMemcpyDtoA, hipMemcpyDtoD,
        hipMemcpyDtoDAsync, hipMemcpyDtoH, hipMemcpyDtoHAsync, hipMemcpyHtoA, hipMemcpyHtoAAsync,
        hipMemcpyHtoDAsync, hipMemFree, hipMemFreeHost, hipMemGetAddressRange, hipMemGetInfo,
        hipMemHostAlloc, hipMemHostGetDevicePointer

    Args:
        dst: **[out]** Data being copy to

        src: **[in]** Data being copy from

        sizeBytes: **[in]** Data size in bytes

    Returns:
        A ``tuple`` of size 1 that contains (in that order):
        - #hipSuccess, #hipErrorDeinitialized, #hipErrorNotInitialized, #hipErrorInvalidContext,
            #hipErrorInvalidValue
    """
    _hipMemcpyDtoDAsync__retval = hipError_t(chip.hipMemcpyDtoDAsync(
        <void *>hip._util.types.DataHandle.from_pyobj(dst)._ptr,
        <void *>hip._util.types.DataHandle.from_pyobj(src)._ptr,sizeBytes,
        ihipStream_t.from_pyobj(stream)._ptr))    # fully specified
    return (_hipMemcpyDtoDAsync__retval,)


@cython.embedsignature(True)
def hipModuleGetGlobal(object hmod, const char * name):
    r"""Returns a global pointer from a module.
    Returns in *dptr and *bytes the pointer and size of the global of name name located in module hmod.
    If no variable of that name exists, it returns hipErrorNotFound. Both parameters dptr and bytes are optional.
    If one of them is NULL, it is ignored and hipSuccess is returned.

    Args:
        hmod: **[in]** Module to retrieve global from

        name: **[in]** Name of global to retrieve

    Returns:
        A ``tuple`` of size 3 that contains (in that order):
        - #hipSuccess, #hipErrorInvalidValue, #hipErrorNotFound, #hipErrorInvalidContext
        - dptr: Returns global device pointer
        - bytes: Returns global size in bytes
    """
    dptr = hip._util.types.DataHandle.from_ptr(NULL)
    cdef unsigned long bytes
    _hipModuleGetGlobal__retval = hipError_t(chip.hipModuleGetGlobal(
        <void **>&dptr._ptr,&bytes,
        ihipModule_t.from_pyobj(hmod)._ptr,name))    # fully specified
    return (_hipModuleGetGlobal__retval,dptr,bytes)


@cython.embedsignature(True)
def hipGetSymbolAddress(object symbol):
    r"""Gets device pointer associated with symbol on the device.

    Args:
        symbol: **[in]** pointer to the symbole of the device

    Returns:
        A ``tuple`` of size 2 that contains (in that order):
        - #hipSuccess, #hipErrorInvalidValue
        - devPtr: pointer to the device associated the symbole
    """
    devPtr = hip._util.types.DataHandle.from_ptr(NULL)
    _hipGetSymbolAddress__retval = hipError_t(chip.hipGetSymbolAddress(
        <void **>&devPtr._ptr,
        <const void *>hip._util.types.DataHandle.from_pyobj(symbol)._ptr))    # fully specified
    return (_hipGetSymbolAddress__retval,devPtr)


@cython.embedsignature(True)
def hipGetSymbolSize(object symbol):
    r"""Gets the size of the given symbol on the device.

    Args:
        symbol: **[in]** pointer to the device symbole

    Returns:
        A ``tuple`` of size 2 that contains (in that order):
        - #hipSuccess, #hipErrorInvalidValue
        - size: pointer to the size
    """
    cdef unsigned long size
    _hipGetSymbolSize__retval = hipError_t(chip.hipGetSymbolSize(&size,
        <const void *>hip._util.types.DataHandle.from_pyobj(symbol)._ptr))    # fully specified
    return (_hipGetSymbolSize__retval,size)


@cython.embedsignature(True)
def hipMemcpyToSymbol(object symbol, object src, unsigned long sizeBytes, unsigned long offset, object kind):
    r"""Copies data to the given symbol on the device.
    Symbol HIP APIs allow a kernel to define a device-side data symbol which can be accessed on
    the host side. The symbol can be in __constant or device space.
    Note that the symbol name needs to be encased in the HIP_SYMBOL macro.
    This also applies to hipMemcpyFromSymbol, hipGetSymbolAddress, and hipGetSymbolSize.
    For detail usage, see the example at
    https://github.com/ROCm-Developer-Tools/HIP/blob/rocm-5.0.x/docs/markdown/hip_porting_guide.md

    Args:
        symbol: **[out]** pointer to the device symbole

        src: **[in]** pointer to the source address

        sizeBytes: **[in]** size in bytes to copy

        offset: **[in]** offset in bytes from start of symbole

        kind: **[in]** type of memory transfer

    Returns:
        A ``tuple`` of size 1 that contains (in that order):
        - #hipSuccess, #hipErrorInvalidValue
    """
    if not isinstance(kind,_hipMemcpyKind__Base):
        raise TypeError("argument 'kind' must be of type '_hipMemcpyKind__Base'")
    _hipMemcpyToSymbol__retval = hipError_t(chip.hipMemcpyToSymbol(
        <const void *>hip._util.types.DataHandle.from_pyobj(symbol)._ptr,
        <const void *>hip._util.types.DataHandle.from_pyobj(src)._ptr,sizeBytes,offset,kind.value))    # fully specified
    return (_hipMemcpyToSymbol__retval,)


@cython.embedsignature(True)
def hipMemcpyToSymbolAsync(object symbol, object src, unsigned long sizeBytes, unsigned long offset, object kind, object stream):
    r"""Copies data to the given symbol on the device asynchronously.

    Args:
        symbol: **[out]** pointer to the device symbole

        src: **[in]** pointer to the source address

        sizeBytes: **[in]** size in bytes to copy

        offset: **[in]** offset in bytes from start of symbole

        kind: **[in]** type of memory transfer

        stream: **[in]** stream identifier

    Returns:
        A ``tuple`` of size 1 that contains (in that order):
        - #hipSuccess, #hipErrorInvalidValue
    """
    if not isinstance(kind,_hipMemcpyKind__Base):
        raise TypeError("argument 'kind' must be of type '_hipMemcpyKind__Base'")
    _hipMemcpyToSymbolAsync__retval = hipError_t(chip.hipMemcpyToSymbolAsync(
        <const void *>hip._util.types.DataHandle.from_pyobj(symbol)._ptr,
        <const void *>hip._util.types.DataHandle.from_pyobj(src)._ptr,sizeBytes,offset,kind.value,
        ihipStream_t.from_pyobj(stream)._ptr))    # fully specified
    return (_hipMemcpyToSymbolAsync__retval,)


@cython.embedsignature(True)
def hipMemcpyFromSymbol(object dst, object symbol, unsigned long sizeBytes, unsigned long offset, object kind):
    r"""Copies data from the given symbol on the device.

    Args:
        dptr: **[out]** Returns pointer to destinition memory address

        symbol: **[in]** pointer to the symbole address on the device

        sizeBytes: **[in]** size in bytes to copy

        offset: **[in]** offset in bytes from the start of symbole

        kind: **[in]** type of memory transfer

    Returns:
        A ``tuple`` of size 1 that contains (in that order):
        - #hipSuccess, #hipErrorInvalidValue
    """
    if not isinstance(kind,_hipMemcpyKind__Base):
        raise TypeError("argument 'kind' must be of type '_hipMemcpyKind__Base'")
    _hipMemcpyFromSymbol__retval = hipError_t(chip.hipMemcpyFromSymbol(
        <void *>hip._util.types.DataHandle.from_pyobj(dst)._ptr,
        <const void *>hip._util.types.DataHandle.from_pyobj(symbol)._ptr,sizeBytes,offset,kind.value))    # fully specified
    return (_hipMemcpyFromSymbol__retval,)


@cython.embedsignature(True)
def hipMemcpyFromSymbolAsync(object dst, object symbol, unsigned long sizeBytes, unsigned long offset, object kind, object stream):
    r"""Copies data from the given symbol on the device asynchronously.

    Args:
        dptr: **[out]** Returns pointer to destinition memory address

        symbol: **[in]** pointer to the symbole address on the device

        sizeBytes: **[in]** size in bytes to copy

        offset: **[in]** offset in bytes from the start of symbole

        kind: **[in]** type of memory transfer

        stream: **[in]** stream identifier

    Returns:
        A ``tuple`` of size 1 that contains (in that order):
        - #hipSuccess, #hipErrorInvalidValue
    """
    if not isinstance(kind,_hipMemcpyKind__Base):
        raise TypeError("argument 'kind' must be of type '_hipMemcpyKind__Base'")
    _hipMemcpyFromSymbolAsync__retval = hipError_t(chip.hipMemcpyFromSymbolAsync(
        <void *>hip._util.types.DataHandle.from_pyobj(dst)._ptr,
        <const void *>hip._util.types.DataHandle.from_pyobj(symbol)._ptr,sizeBytes,offset,kind.value,
        ihipStream_t.from_pyobj(stream)._ptr))    # fully specified
    return (_hipMemcpyFromSymbolAsync__retval,)


@cython.embedsignature(True)
def hipMemcpyAsync(object dst, object src, unsigned long sizeBytes, object kind, object stream):
    r"""Copy data from src to dst asynchronously.

    Warning:
        If host or dest are not pinned, the memory copy will be performed synchronously.  For
        best performance, use hipHostMalloc to allocate host memory that is transferred asynchronously.

    Warning:
        on HCC hipMemcpyAsync does not support overlapped H2D and D2H copies.
        For hipMemcpy, the copy is always performed by the device associated with the specified stream.

    For multi-gpu or peer-to-peer configurations, it is recommended to use a stream which is a
    attached to the device where the src data is physically located. For optimal peer-to-peer copies,
    the copy device must be able to access the src and dst pointers (by calling
    hipDeviceEnablePeerAccess with copy agent as the current device and src/dest as the peerDevice
    argument.  if this is not done, the hipMemcpy will still work, but will perform the copy using a
    staging buffer on the host.

    See:
        hipMemcpy, hipMemcpy2D, hipMemcpyToArray, hipMemcpy2DToArray, hipMemcpyFromArray,
        hipMemcpy2DFromArray, hipMemcpyArrayToArray, hipMemcpy2DArrayToArray, hipMemcpyToSymbol,
        hipMemcpyFromSymbol, hipMemcpy2DAsync, hipMemcpyToArrayAsync, hipMemcpy2DToArrayAsync,
        hipMemcpyFromArrayAsync, hipMemcpy2DFromArrayAsync, hipMemcpyToSymbolAsync,
        hipMemcpyFromSymbolAsync

    Args:
        dst: **[out]** Data being copy to

        src: **[in]** Data being copy from

        sizeBytes: **[in]** Data size in bytes

        accelerator_view: **[in]** Accelerator view which the copy is being enqueued

    Returns:
        A ``tuple`` of size 1 that contains (in that order):
        - #hipSuccess, #hipErrorInvalidValue, #hipErrorMemoryFree, #hipErrorUnknown
    """
    if not isinstance(kind,_hipMemcpyKind__Base):
        raise TypeError("argument 'kind' must be of type '_hipMemcpyKind__Base'")
    _hipMemcpyAsync__retval = hipError_t(chip.hipMemcpyAsync(
        <void *>hip._util.types.DataHandle.from_pyobj(dst)._ptr,
        <const void *>hip._util.types.DataHandle.from_pyobj(src)._ptr,sizeBytes,kind.value,
        ihipStream_t.from_pyobj(stream)._ptr))    # fully specified
    return (_hipMemcpyAsync__retval,)


@cython.embedsignature(True)
def hipMemset(object dst, int value, unsigned long sizeBytes):
    r"""Fills the first sizeBytes bytes of the memory area pointed to by dest with the constant
    byte value value.

    Args:
        dst: **[out]** Data being filled

        constant: **[in]** value to be set

        sizeBytes: **[in]** Data size in bytes

    Returns:
        A ``tuple`` of size 1 that contains (in that order):
        - #hipSuccess, #hipErrorInvalidValue, #hipErrorNotInitialized
    """
    _hipMemset__retval = hipError_t(chip.hipMemset(
        <void *>hip._util.types.DataHandle.from_pyobj(dst)._ptr,value,sizeBytes))    # fully specified
    return (_hipMemset__retval,)


@cython.embedsignature(True)
def hipMemsetD8(object dest, unsigned char value, unsigned long count):
    r"""Fills the first sizeBytes bytes of the memory area pointed to by dest with the constant
    byte value value.

    Args:
        dst: **[out]** Data ptr to be filled

        constant: **[in]** value to be set

        number: **[in]** of values to be set

    Returns:
        A ``tuple`` of size 1 that contains (in that order):
        - #hipSuccess, #hipErrorInvalidValue, #hipErrorNotInitialized
    """
    _hipMemsetD8__retval = hipError_t(chip.hipMemsetD8(
        <void *>hip._util.types.DataHandle.from_pyobj(dest)._ptr,value,count))    # fully specified
    return (_hipMemsetD8__retval,)


@cython.embedsignature(True)
def hipMemsetD8Async(object dest, unsigned char value, unsigned long count, object stream):
    r"""Fills the first sizeBytes bytes of the memory area pointed to by dest with the constant
    byte value value.

    hipMemsetD8Async() is asynchronous with respect to the host, so the call may return before the
    memset is complete. The operation can optionally be associated to a stream by passing a non-zero
    stream argument. If stream is non-zero, the operation may overlap with operations in other
    streams.

    Args:
        dst: **[out]** Data ptr to be filled

        constant: **[in]** value to be set

        number: **[in]** of values to be set

        stream: **[in]**  Stream identifier

    Returns:
        A ``tuple`` of size 1 that contains (in that order):
        - #hipSuccess, #hipErrorInvalidValue, #hipErrorNotInitialized
    """
    _hipMemsetD8Async__retval = hipError_t(chip.hipMemsetD8Async(
        <void *>hip._util.types.DataHandle.from_pyobj(dest)._ptr,value,count,
        ihipStream_t.from_pyobj(stream)._ptr))    # fully specified
    return (_hipMemsetD8Async__retval,)


@cython.embedsignature(True)
def hipMemsetD16(object dest, unsigned short value, unsigned long count):
    r"""Fills the first sizeBytes bytes of the memory area pointed to by dest with the constant
    short value value.

    Args:
        dst: **[out]** Data ptr to be filled

        constant: **[in]** value to be set

        number: **[in]** of values to be set

    Returns:
        A ``tuple`` of size 1 that contains (in that order):
        - #hipSuccess, #hipErrorInvalidValue, #hipErrorNotInitialized
    """
    _hipMemsetD16__retval = hipError_t(chip.hipMemsetD16(
        <void *>hip._util.types.DataHandle.from_pyobj(dest)._ptr,value,count))    # fully specified
    return (_hipMemsetD16__retval,)


@cython.embedsignature(True)
def hipMemsetD16Async(object dest, unsigned short value, unsigned long count, object stream):
    r"""Fills the first sizeBytes bytes of the memory area pointed to by dest with the constant
    short value value.

    hipMemsetD16Async() is asynchronous with respect to the host, so the call may return before the
    memset is complete. The operation can optionally be associated to a stream by passing a non-zero
    stream argument. If stream is non-zero, the operation may overlap with operations in other
    streams.

    Args:
        dst: **[out]** Data ptr to be filled

        constant: **[in]** value to be set

        number: **[in]** of values to be set

        stream: **[in]**  Stream identifier

    Returns:
        A ``tuple`` of size 1 that contains (in that order):
        - #hipSuccess, #hipErrorInvalidValue, #hipErrorNotInitialized
    """
    _hipMemsetD16Async__retval = hipError_t(chip.hipMemsetD16Async(
        <void *>hip._util.types.DataHandle.from_pyobj(dest)._ptr,value,count,
        ihipStream_t.from_pyobj(stream)._ptr))    # fully specified
    return (_hipMemsetD16Async__retval,)


@cython.embedsignature(True)
def hipMemsetD32(object dest, int value, unsigned long count):
    r"""Fills the memory area pointed to by dest with the constant integer
    value for specified number of times.

    Args:
        dst: **[out]** Data being filled

        constant: **[in]** value to be set

        number: **[in]** of values to be set

    Returns:
        A ``tuple`` of size 1 that contains (in that order):
        - #hipSuccess, #hipErrorInvalidValue, #hipErrorNotInitialized
    """
    _hipMemsetD32__retval = hipError_t(chip.hipMemsetD32(
        <void *>hip._util.types.DataHandle.from_pyobj(dest)._ptr,value,count))    # fully specified
    return (_hipMemsetD32__retval,)


@cython.embedsignature(True)
def hipMemsetAsync(object dst, int value, unsigned long sizeBytes, object stream):
    r"""Fills the first sizeBytes bytes of the memory area pointed to by dev with the constant
    byte value value.

    hipMemsetAsync() is asynchronous with respect to the host, so the call may return before the
    memset is complete. The operation can optionally be associated to a stream by passing a non-zero
    stream argument. If stream is non-zero, the operation may overlap with operations in other
    streams.

    Args:
        dst: **[out]** Pointer to device memory

        value: **[in]**  Value to set for each byte of specified memory

        sizeBytes: **[in]**  Size in bytes to set

        stream: **[in]**  Stream identifier

    Returns:
        A ``tuple`` of size 1 that contains (in that order):
        - #hipSuccess, #hipErrorInvalidValue, #hipErrorMemoryFree
    """
    _hipMemsetAsync__retval = hipError_t(chip.hipMemsetAsync(
        <void *>hip._util.types.DataHandle.from_pyobj(dst)._ptr,value,sizeBytes,
        ihipStream_t.from_pyobj(stream)._ptr))    # fully specified
    return (_hipMemsetAsync__retval,)


@cython.embedsignature(True)
def hipMemsetD32Async(object dst, int value, unsigned long count, object stream):
    r"""Fills the memory area pointed to by dev with the constant integer
    value for specified number of times.

    hipMemsetD32Async() is asynchronous with respect to the host, so the call may return before the
    memset is complete. The operation can optionally be associated to a stream by passing a non-zero
    stream argument. If stream is non-zero, the operation may overlap with operations in other
    streams.

    Args:
        dst: **[out]** Pointer to device memory

        value: **[in]**  Value to set for each byte of specified memory

        count: **[in]**  number of values to be set

        stream: **[in]**  Stream identifier

    Returns:
        A ``tuple`` of size 1 that contains (in that order):
        - #hipSuccess, #hipErrorInvalidValue, #hipErrorMemoryFree
    """
    _hipMemsetD32Async__retval = hipError_t(chip.hipMemsetD32Async(
        <void *>hip._util.types.DataHandle.from_pyobj(dst)._ptr,value,count,
        ihipStream_t.from_pyobj(stream)._ptr))    # fully specified
    return (_hipMemsetD32Async__retval,)


@cython.embedsignature(True)
def hipMemset2D(object dst, unsigned long pitch, int value, unsigned long width, unsigned long height):
    r"""Fills the memory area pointed to by dst with the constant value.

    Args:
        dst: **[out]** Pointer to device memory

        pitch: **[in]**  data size in bytes

        value: **[in]**  constant value to be set

        width: **[in]** 

        height: **[in]** 

    Returns:
        A ``tuple`` of size 1 that contains (in that order):
        - #hipSuccess, #hipErrorInvalidValue, #hipErrorMemoryFree
    """
    _hipMemset2D__retval = hipError_t(chip.hipMemset2D(
        <void *>hip._util.types.DataHandle.from_pyobj(dst)._ptr,pitch,value,width,height))    # fully specified
    return (_hipMemset2D__retval,)


@cython.embedsignature(True)
def hipMemset2DAsync(object dst, unsigned long pitch, int value, unsigned long width, unsigned long height, object stream):
    r"""Fills asynchronously the memory area pointed to by dst with the constant value.

    Args:
        dst: **[in]** Pointer to device memory

        pitch: **[in]**  data size in bytes

        value: **[in]**  constant value to be set

        width: **[in]** 

        height: **[in]** 

        stream: **[in]** 

    Returns:
        A ``tuple`` of size 1 that contains (in that order):
        - #hipSuccess, #hipErrorInvalidValue, #hipErrorMemoryFree
    """
    _hipMemset2DAsync__retval = hipError_t(chip.hipMemset2DAsync(
        <void *>hip._util.types.DataHandle.from_pyobj(dst)._ptr,pitch,value,width,height,
        ihipStream_t.from_pyobj(stream)._ptr))    # fully specified
    return (_hipMemset2DAsync__retval,)


@cython.embedsignature(True)
def hipMemset3D(object pitchedDevPtr, int value, object extent):
    r"""Fills synchronously the memory area pointed to by pitchedDevPtr with the constant value.

    Args:
        pitchedDevPtr: **[in]** 

        value: **[in]**  constant value to be set

        extent: **[in]** 

    Returns:
        A ``tuple`` of size 1 that contains (in that order):
        - #hipSuccess, #hipErrorInvalidValue, #hipErrorMemoryFree
    """
    _hipMemset3D__retval = hipError_t(chip.hipMemset3D(
        hipPitchedPtr.from_pyobj(pitchedDevPtr)._ptr[0],value,
        hipExtent.from_pyobj(extent)._ptr[0]))    # fully specified
    return (_hipMemset3D__retval,)


@cython.embedsignature(True)
def hipMemset3DAsync(object pitchedDevPtr, int value, object extent, object stream):
    r"""Fills asynchronously the memory area pointed to by pitchedDevPtr with the constant value.

    Args:
        pitchedDevPtr: **[in]** 

        value: **[in]**  constant value to be set

        extent: **[in]** 

        stream: **[in]** 

    Returns:
        A ``tuple`` of size 1 that contains (in that order):
        - #hipSuccess, #hipErrorInvalidValue, #hipErrorMemoryFree
    """
    _hipMemset3DAsync__retval = hipError_t(chip.hipMemset3DAsync(
        hipPitchedPtr.from_pyobj(pitchedDevPtr)._ptr[0],value,
        hipExtent.from_pyobj(extent)._ptr[0],
        ihipStream_t.from_pyobj(stream)._ptr))    # fully specified
    return (_hipMemset3DAsync__retval,)


@cython.embedsignature(True)
def hipMemGetInfo():
    r"""Query memory info.
     Return snapshot of free memory, and total allocatable memory on the device.

    Returns in *free a snapshot of the current free memory.

    Warning:
        On HCC, the free memory only accounts for memory allocated by this process and may be
        optimistic.

    Returns:
        A ``tuple`` of size 1 that contains (in that order):
        - #hipSuccess, #hipErrorInvalidDevice, #hipErrorInvalidValue
    """
    cdef unsigned long free
    cdef unsigned long total
    _hipMemGetInfo__retval = hipError_t(chip.hipMemGetInfo(&free,&total))    # fully specified
    return (_hipMemGetInfo__retval,free,total)


@cython.embedsignature(True)
def hipMemPtrGetInfo(object ptr):
    r"""(No short description)
    """
    cdef unsigned long size
    _hipMemPtrGetInfo__retval = hipError_t(chip.hipMemPtrGetInfo(
        <void *>hip._util.types.DataHandle.from_pyobj(ptr)._ptr,&size))    # fully specified
    return (_hipMemPtrGetInfo__retval,size)


@cython.embedsignature(True)
def hipMallocArray(object desc, unsigned long width, unsigned long height, unsigned int flags):
    r"""Allocate an array on the device.

    See:
        hipMalloc, hipMallocPitch, hipFree, hipFreeArray, hipHostMalloc, hipHostFree

    Args:
        desc: **[in]** Requested channel format

        width: **[in]** Requested array allocation width

        height: **[in]** Requested array allocation height

        flags: **[in]** Requested properties of allocated array

    Returns:
        A ``tuple`` of size 2 that contains (in that order):
        - #hipSuccess, #hipErrorOutOfMemory
        - array: Pointer to allocated array in device memory
    """
    array = hipArray.from_ptr(NULL)
    _hipMallocArray__retval = hipError_t(chip.hipMallocArray(&array._ptr,
        hipChannelFormatDesc.from_pyobj(desc)._ptr,width,height,flags))    # fully specified
    return (_hipMallocArray__retval,array)


@cython.embedsignature(True)
def hipArrayCreate(object pAllocateArray):
    r"""(No short description)
    """
    pHandle = hipArray.from_ptr(NULL)
    _hipArrayCreate__retval = hipError_t(chip.hipArrayCreate(&pHandle._ptr,
        HIP_ARRAY_DESCRIPTOR.from_pyobj(pAllocateArray)._ptr))    # fully specified
    return (_hipArrayCreate__retval,pHandle)


@cython.embedsignature(True)
def hipArrayDestroy(object array):
    r"""(No short description)
    """
    _hipArrayDestroy__retval = hipError_t(chip.hipArrayDestroy(
        hipArray.from_pyobj(array)._ptr))    # fully specified
    return (_hipArrayDestroy__retval,)


@cython.embedsignature(True)
def hipArray3DCreate(object pAllocateArray):
    r"""(No short description)
    """
    array = hipArray.from_ptr(NULL)
    _hipArray3DCreate__retval = hipError_t(chip.hipArray3DCreate(&array._ptr,
        HIP_ARRAY3D_DESCRIPTOR.from_pyobj(pAllocateArray)._ptr))    # fully specified
    return (_hipArray3DCreate__retval,array)


@cython.embedsignature(True)
def hipMalloc3D(object pitchedDevPtr, object extent):
    r"""(No short description)
    """
    _hipMalloc3D__retval = hipError_t(chip.hipMalloc3D(
        hipPitchedPtr.from_pyobj(pitchedDevPtr)._ptr,
        hipExtent.from_pyobj(extent)._ptr[0]))    # fully specified
    return (_hipMalloc3D__retval,)


@cython.embedsignature(True)
def hipFreeArray(object array):
    r"""Frees an array on the device.

    See:
        hipMalloc, hipMallocPitch, hipFree, hipMallocArray, hipHostMalloc, hipHostFree

    Args:
        array: **[in]** Pointer to array to free

    Returns:
        A ``tuple`` of size 1 that contains (in that order):
        - #hipSuccess, #hipErrorInvalidValue, #hipErrorNotInitialized
    """
    _hipFreeArray__retval = hipError_t(chip.hipFreeArray(
        hipArray.from_pyobj(array)._ptr))    # fully specified
    return (_hipFreeArray__retval,)


@cython.embedsignature(True)
def hipFreeMipmappedArray(object mipmappedArray):
    r"""Frees a mipmapped array on the device

    Args:
        mipmappedArray: **[in]**  Pointer to mipmapped array to free

    Returns:
        A ``tuple`` of size 1 that contains (in that order):
        - #hipSuccess, #hipErrorInvalidValue
    """
    _hipFreeMipmappedArray__retval = hipError_t(chip.hipFreeMipmappedArray(
        hipMipmappedArray.from_pyobj(mipmappedArray)._ptr))    # fully specified
    return (_hipFreeMipmappedArray__retval,)


@cython.embedsignature(True)
def hipMalloc3DArray(object desc, object extent, unsigned int flags):
    r"""Allocate an array on the device.

    See:
        hipMalloc, hipMallocPitch, hipFree, hipFreeArray, hipHostMalloc, hipHostFree

    Args:
        desc: **[in]** Requested channel format

        extent: **[in]** Requested array allocation width, height and depth

        flags: **[in]** Requested properties of allocated array

    Returns:
        A ``tuple`` of size 2 that contains (in that order):
        - #hipSuccess, #hipErrorOutOfMemory
        - array: Pointer to allocated array in device memory
    """
    array = hipArray.from_ptr(NULL)
    _hipMalloc3DArray__retval = hipError_t(chip.hipMalloc3DArray(&array._ptr,
        hipChannelFormatDesc.from_pyobj(desc)._ptr,
        hipExtent.from_pyobj(extent)._ptr[0],flags))    # fully specified
    return (_hipMalloc3DArray__retval,array)


@cython.embedsignature(True)
def hipMallocMipmappedArray(object desc, object extent, unsigned int numLevels, unsigned int flags):
    r"""Allocate a mipmapped array on the device

    Args:
        desc: **[in]**  Requested channel format

        extent: **[in]**  Requested allocation size (width field in elements)

        numLevels: **[in]**  Number of mipmap levels to allocate

        flags: **[in]**  Flags for extensions

    Returns:
        A ``tuple`` of size 2 that contains (in that order):
        - #hipSuccess, #hipErrorInvalidValue, #hipErrorMemoryAllocation
        - mipmappedArray:  Pointer to allocated mipmapped array in device memory
    """
    mipmappedArray = hipMipmappedArray.from_ptr(NULL)
    _hipMallocMipmappedArray__retval = hipError_t(chip.hipMallocMipmappedArray(&mipmappedArray._ptr,
        hipChannelFormatDesc.from_pyobj(desc)._ptr,
        hipExtent.from_pyobj(extent)._ptr[0],numLevels,flags))    # fully specified
    return (_hipMallocMipmappedArray__retval,mipmappedArray)


@cython.embedsignature(True)
def hipGetMipmappedArrayLevel(object mipmappedArray, unsigned int level):
    r"""Gets a mipmap level of a HIP mipmapped array

    Args:
        mipmappedArray: **[in]**  HIP mipmapped array

        level: **[in]**  Mipmap level

    Returns:
        A ``tuple`` of size 2 that contains (in that order):
        - #hipSuccess, #hipErrorInvalidValue
        - levelArray:  Returned mipmap level HIP array
    """
    levelArray = hipArray.from_ptr(NULL)
    _hipGetMipmappedArrayLevel__retval = hipError_t(chip.hipGetMipmappedArrayLevel(&levelArray._ptr,
        hipMipmappedArray.from_pyobj(mipmappedArray)._ptr,level))    # fully specified
    return (_hipGetMipmappedArrayLevel__retval,levelArray)


@cython.embedsignature(True)
def hipMemcpy2D(object dst, unsigned long dpitch, object src, unsigned long spitch, unsigned long width, unsigned long height, object kind):
    r"""Copies data between host and device.

    See:
        hipMemcpy, hipMemcpyToArray, hipMemcpy2DToArray, hipMemcpyFromArray, hipMemcpyToSymbol,
        hipMemcpyAsync

    Args:
        dst: **[in]** Destination memory address

        dpitch: **[in]** Pitch of destination memory

        src: **[in]** Source memory address

        spitch: **[in]** Pitch of source memory

        width: **[in]** Width of matrix transfer (columns in bytes)

        height: **[in]** Height of matrix transfer (rows)

        kind: **[in]** Type of transfer

    Returns:
        A ``tuple`` of size 1 that contains (in that order):
        - #hipSuccess, #hipErrorInvalidValue, #hipErrorInvalidPitchValue,
            #hipErrorInvalidDevicePointer, #hipErrorInvalidMemcpyDirection
    """
    if not isinstance(kind,_hipMemcpyKind__Base):
        raise TypeError("argument 'kind' must be of type '_hipMemcpyKind__Base'")
    _hipMemcpy2D__retval = hipError_t(chip.hipMemcpy2D(
        <void *>hip._util.types.DataHandle.from_pyobj(dst)._ptr,dpitch,
        <const void *>hip._util.types.DataHandle.from_pyobj(src)._ptr,spitch,width,height,kind.value))    # fully specified
    return (_hipMemcpy2D__retval,)


@cython.embedsignature(True)
def hipMemcpyParam2D(object pCopy):
    r"""Copies memory for 2D arrays.

    See:
        hipMemcpy, hipMemcpy2D, hipMemcpyToArray, hipMemcpy2DToArray, hipMemcpyFromArray,
          hipMemcpyToSymbol, hipMemcpyAsync
        /

    Args:
        pCopy: **[in]** Parameters for the memory copy

    Returns:
        A ``tuple`` of size 1 that contains (in that order):
        - #hipSuccess, #hipErrorInvalidValue, #hipErrorInvalidPitchValue,
            #hipErrorInvalidDevicePointer, #hipErrorInvalidMemcpyDirection
    """
    _hipMemcpyParam2D__retval = hipError_t(chip.hipMemcpyParam2D(
        hip_Memcpy2D.from_pyobj(pCopy)._ptr))    # fully specified
    return (_hipMemcpyParam2D__retval,)


@cython.embedsignature(True)
def hipMemcpyParam2DAsync(object pCopy, object stream):
    r"""Copies memory for 2D arrays.

    See:
        hipMemcpy, hipMemcpy2D, hipMemcpyToArray, hipMemcpy2DToArray, hipMemcpyFromArray,
          hipMemcpyToSymbol, hipMemcpyAsync
        /

    Args:
        pCopy: **[in]** Parameters for the memory copy

        stream: **[in]** Stream to use

    Returns:
        A ``tuple`` of size 1 that contains (in that order):
        - #hipSuccess, #hipErrorInvalidValue, #hipErrorInvalidPitchValue,
            #hipErrorInvalidDevicePointer, #hipErrorInvalidMemcpyDirection
    """
    _hipMemcpyParam2DAsync__retval = hipError_t(chip.hipMemcpyParam2DAsync(
        hip_Memcpy2D.from_pyobj(pCopy)._ptr,
        ihipStream_t.from_pyobj(stream)._ptr))    # fully specified
    return (_hipMemcpyParam2DAsync__retval,)


@cython.embedsignature(True)
def hipMemcpy2DAsync(object dst, unsigned long dpitch, object src, unsigned long spitch, unsigned long width, unsigned long height, object kind, object stream):
    r"""Copies data between host and device.

    See:
        hipMemcpy, hipMemcpyToArray, hipMemcpy2DToArray, hipMemcpyFromArray, hipMemcpyToSymbol,
        hipMemcpyAsync

    Args:
        dst: **[in]** Destination memory address

        dpitch: **[in]** Pitch of destination memory

        src: **[in]** Source memory address

        spitch: **[in]** Pitch of source memory

        width: **[in]** Width of matrix transfer (columns in bytes)

        height: **[in]** Height of matrix transfer (rows)

        kind: **[in]** Type of transfer

        stream: **[in]** Stream to use

    Returns:
        A ``tuple`` of size 1 that contains (in that order):
        - #hipSuccess, #hipErrorInvalidValue, #hipErrorInvalidPitchValue,
            #hipErrorInvalidDevicePointer, #hipErrorInvalidMemcpyDirection
    """
    if not isinstance(kind,_hipMemcpyKind__Base):
        raise TypeError("argument 'kind' must be of type '_hipMemcpyKind__Base'")
    _hipMemcpy2DAsync__retval = hipError_t(chip.hipMemcpy2DAsync(
        <void *>hip._util.types.DataHandle.from_pyobj(dst)._ptr,dpitch,
        <const void *>hip._util.types.DataHandle.from_pyobj(src)._ptr,spitch,width,height,kind.value,
        ihipStream_t.from_pyobj(stream)._ptr))    # fully specified
    return (_hipMemcpy2DAsync__retval,)


@cython.embedsignature(True)
def hipMemcpy2DToArray(object dst, unsigned long wOffset, unsigned long hOffset, object src, unsigned long spitch, unsigned long width, unsigned long height, object kind):
    r"""Copies data between host and device.

    See:
        hipMemcpy, hipMemcpyToArray, hipMemcpy2D, hipMemcpyFromArray, hipMemcpyToSymbol,
        hipMemcpyAsync

    Args:
        dst: **[in]** Destination memory address

        wOffset: **[in]** Destination starting X offset

        hOffset: **[in]** Destination starting Y offset

        src: **[in]** Source memory address

        spitch: **[in]** Pitch of source memory

        width: **[in]** Width of matrix transfer (columns in bytes)

        height: **[in]** Height of matrix transfer (rows)

        kind: **[in]** Type of transfer

    Returns:
        A ``tuple`` of size 1 that contains (in that order):
        - #hipSuccess, #hipErrorInvalidValue, #hipErrorInvalidPitchValue,
            #hipErrorInvalidDevicePointer, #hipErrorInvalidMemcpyDirection
    """
    if not isinstance(kind,_hipMemcpyKind__Base):
        raise TypeError("argument 'kind' must be of type '_hipMemcpyKind__Base'")
    _hipMemcpy2DToArray__retval = hipError_t(chip.hipMemcpy2DToArray(
        hipArray.from_pyobj(dst)._ptr,wOffset,hOffset,
        <const void *>hip._util.types.DataHandle.from_pyobj(src)._ptr,spitch,width,height,kind.value))    # fully specified
    return (_hipMemcpy2DToArray__retval,)


@cython.embedsignature(True)
def hipMemcpy2DToArrayAsync(object dst, unsigned long wOffset, unsigned long hOffset, object src, unsigned long spitch, unsigned long width, unsigned long height, object kind, object stream):
    r"""Copies data between host and device.

    See:
        hipMemcpy, hipMemcpyToArray, hipMemcpy2D, hipMemcpyFromArray, hipMemcpyToSymbol,
        hipMemcpyAsync

    Args:
        dst: **[in]** Destination memory address

        wOffset: **[in]** Destination starting X offset

        hOffset: **[in]** Destination starting Y offset

        src: **[in]** Source memory address

        spitch: **[in]** Pitch of source memory

        width: **[in]** Width of matrix transfer (columns in bytes)

        height: **[in]** Height of matrix transfer (rows)

        kind: **[in]** Type of transfer

        stream: **[in]** Accelerator view which the copy is being enqueued

    Returns:
        A ``tuple`` of size 1 that contains (in that order):
        - #hipSuccess, #hipErrorInvalidValue, #hipErrorInvalidPitchValue,
            #hipErrorInvalidDevicePointer, #hipErrorInvalidMemcpyDirection
    """
    if not isinstance(kind,_hipMemcpyKind__Base):
        raise TypeError("argument 'kind' must be of type '_hipMemcpyKind__Base'")
    _hipMemcpy2DToArrayAsync__retval = hipError_t(chip.hipMemcpy2DToArrayAsync(
        hipArray.from_pyobj(dst)._ptr,wOffset,hOffset,
        <const void *>hip._util.types.DataHandle.from_pyobj(src)._ptr,spitch,width,height,kind.value,
        ihipStream_t.from_pyobj(stream)._ptr))    # fully specified
    return (_hipMemcpy2DToArrayAsync__retval,)


@cython.embedsignature(True)
def hipMemcpyToArray(object dst, unsigned long wOffset, unsigned long hOffset, object src, unsigned long count, object kind):
    r"""Copies data between host and device.

    See:
        hipMemcpy, hipMemcpy2DToArray, hipMemcpy2D, hipMemcpyFromArray, hipMemcpyToSymbol,
        hipMemcpyAsync

    Args:
        dst: **[in]** Destination memory address

        wOffset: **[in]** Destination starting X offset

        hOffset: **[in]** Destination starting Y offset

        src: **[in]** Source memory address

        count: **[in]** size in bytes to copy

        kind: **[in]** Type of transfer

    Returns:
        A ``tuple`` of size 1 that contains (in that order):
        - #hipSuccess, #hipErrorInvalidValue, #hipErrorInvalidPitchValue,
            #hipErrorInvalidDevicePointer, #hipErrorInvalidMemcpyDirection
    """
    if not isinstance(kind,_hipMemcpyKind__Base):
        raise TypeError("argument 'kind' must be of type '_hipMemcpyKind__Base'")
    _hipMemcpyToArray__retval = hipError_t(chip.hipMemcpyToArray(
        hipArray.from_pyobj(dst)._ptr,wOffset,hOffset,
        <const void *>hip._util.types.DataHandle.from_pyobj(src)._ptr,count,kind.value))    # fully specified
    return (_hipMemcpyToArray__retval,)


@cython.embedsignature(True)
def hipMemcpyFromArray(object dst, object srcArray, unsigned long wOffset, unsigned long hOffset, unsigned long count, object kind):
    r"""Copies data between host and device.

    See:
        hipMemcpy, hipMemcpy2DToArray, hipMemcpy2D, hipMemcpyFromArray, hipMemcpyToSymbol,
        hipMemcpyAsync

    Args:
        dst: **[in]** Destination memory address

        srcArray: **[in]** Source memory address

        woffset: **[in]** Source starting X offset

        hOffset: **[in]** Source starting Y offset

        count: **[in]** Size in bytes to copy

        kind: **[in]** Type of transfer

    Returns:
        A ``tuple`` of size 1 that contains (in that order):
        - #hipSuccess, #hipErrorInvalidValue, #hipErrorInvalidPitchValue,
            #hipErrorInvalidDevicePointer, #hipErrorInvalidMemcpyDirection
    """
    if not isinstance(kind,_hipMemcpyKind__Base):
        raise TypeError("argument 'kind' must be of type '_hipMemcpyKind__Base'")
    _hipMemcpyFromArray__retval = hipError_t(chip.hipMemcpyFromArray(
        <void *>hip._util.types.DataHandle.from_pyobj(dst)._ptr,
        hipArray.from_pyobj(srcArray)._ptr,wOffset,hOffset,count,kind.value))    # fully specified
    return (_hipMemcpyFromArray__retval,)


@cython.embedsignature(True)
def hipMemcpy2DFromArray(object dst, unsigned long dpitch, object src, unsigned long wOffset, unsigned long hOffset, unsigned long width, unsigned long height, object kind):
    r"""Copies data between host and device.

    See:
        hipMemcpy, hipMemcpy2DToArray, hipMemcpy2D, hipMemcpyFromArray, hipMemcpyToSymbol,
        hipMemcpyAsync

    Args:
        dst: **[in]** Destination memory address

        dpitch: **[in]** Pitch of destination memory

        src: **[in]** Source memory address

        wOffset: **[in]** Source starting X offset

        hOffset: **[in]** Source starting Y offset

        width: **[in]** Width of matrix transfer (columns in bytes)

        height: **[in]** Height of matrix transfer (rows)

        kind: **[in]** Type of transfer

    Returns:
        A ``tuple`` of size 1 that contains (in that order):
        - #hipSuccess, #hipErrorInvalidValue, #hipErrorInvalidPitchValue,
            #hipErrorInvalidDevicePointer, #hipErrorInvalidMemcpyDirection
    """
    if not isinstance(kind,_hipMemcpyKind__Base):
        raise TypeError("argument 'kind' must be of type '_hipMemcpyKind__Base'")
    _hipMemcpy2DFromArray__retval = hipError_t(chip.hipMemcpy2DFromArray(
        <void *>hip._util.types.DataHandle.from_pyobj(dst)._ptr,dpitch,
        hipArray.from_pyobj(src)._ptr,wOffset,hOffset,width,height,kind.value))    # fully specified
    return (_hipMemcpy2DFromArray__retval,)


@cython.embedsignature(True)
def hipMemcpy2DFromArrayAsync(object dst, unsigned long dpitch, object src, unsigned long wOffset, unsigned long hOffset, unsigned long width, unsigned long height, object kind, object stream):
    r"""Copies data between host and device asynchronously.

    See:
        hipMemcpy, hipMemcpy2DToArray, hipMemcpy2D, hipMemcpyFromArray, hipMemcpyToSymbol,
        hipMemcpyAsync

    Args:
        dst: **[in]** Destination memory address

        dpitch: **[in]** Pitch of destination memory

        src: **[in]** Source memory address

        wOffset: **[in]** Source starting X offset

        hOffset: **[in]** Source starting Y offset

        width: **[in]** Width of matrix transfer (columns in bytes)

        height: **[in]** Height of matrix transfer (rows)

        kind: **[in]** Type of transfer

        stream: **[in]** Accelerator view which the copy is being enqueued

    Returns:
        A ``tuple`` of size 1 that contains (in that order):
        - #hipSuccess, #hipErrorInvalidValue, #hipErrorInvalidPitchValue,
            #hipErrorInvalidDevicePointer, #hipErrorInvalidMemcpyDirection
    """
    if not isinstance(kind,_hipMemcpyKind__Base):
        raise TypeError("argument 'kind' must be of type '_hipMemcpyKind__Base'")
    _hipMemcpy2DFromArrayAsync__retval = hipError_t(chip.hipMemcpy2DFromArrayAsync(
        <void *>hip._util.types.DataHandle.from_pyobj(dst)._ptr,dpitch,
        hipArray.from_pyobj(src)._ptr,wOffset,hOffset,width,height,kind.value,
        ihipStream_t.from_pyobj(stream)._ptr))    # fully specified
    return (_hipMemcpy2DFromArrayAsync__retval,)


@cython.embedsignature(True)
def hipMemcpyAtoH(object dst, object srcArray, unsigned long srcOffset, unsigned long count):
    r"""Copies data between host and device.

    See:
        hipMemcpy, hipMemcpy2DToArray, hipMemcpy2D, hipMemcpyFromArray, hipMemcpyToSymbol,
        hipMemcpyAsync

    Args:
        dst: **[in]** Destination memory address

        srcArray: **[in]** Source array

        srcoffset: **[in]** Offset in bytes of source array

        count: **[in]** Size of memory copy in bytes

    Returns:
        A ``tuple`` of size 1 that contains (in that order):
        - #hipSuccess, #hipErrorInvalidValue, #hipErrorInvalidPitchValue,
            #hipErrorInvalidDevicePointer, #hipErrorInvalidMemcpyDirection
    """
    _hipMemcpyAtoH__retval = hipError_t(chip.hipMemcpyAtoH(
        <void *>hip._util.types.DataHandle.from_pyobj(dst)._ptr,
        hipArray.from_pyobj(srcArray)._ptr,srcOffset,count))    # fully specified
    return (_hipMemcpyAtoH__retval,)


@cython.embedsignature(True)
def hipMemcpyHtoA(object dstArray, unsigned long dstOffset, object srcHost, unsigned long count):
    r"""Copies data between host and device.

    See:
        hipMemcpy, hipMemcpy2DToArray, hipMemcpy2D, hipMemcpyFromArray, hipMemcpyToSymbol,
        hipMemcpyAsync

    Args:
        dstArray: **[in]** Destination memory address

        dstOffset: **[in]** Offset in bytes of destination array

        srcHost: **[in]** Source host pointer

        count: **[in]** Size of memory copy in bytes

    Returns:
        A ``tuple`` of size 1 that contains (in that order):
        - #hipSuccess, #hipErrorInvalidValue, #hipErrorInvalidPitchValue,
            #hipErrorInvalidDevicePointer, #hipErrorInvalidMemcpyDirection
    """
    _hipMemcpyHtoA__retval = hipError_t(chip.hipMemcpyHtoA(
        hipArray.from_pyobj(dstArray)._ptr,dstOffset,
        <const void *>hip._util.types.DataHandle.from_pyobj(srcHost)._ptr,count))    # fully specified
    return (_hipMemcpyHtoA__retval,)


@cython.embedsignature(True)
def hipMemcpy3D(object p):
    r"""Copies data between host and device.

    See:
        hipMemcpy, hipMemcpy2DToArray, hipMemcpy2D, hipMemcpyFromArray, hipMemcpyToSymbol,
        hipMemcpyAsync

    Args:
        p: **[in]** 3D memory copy parameters

    Returns:
        A ``tuple`` of size 1 that contains (in that order):
        - #hipSuccess, #hipErrorInvalidValue, #hipErrorInvalidPitchValue,
            #hipErrorInvalidDevicePointer, #hipErrorInvalidMemcpyDirection
    """
    _hipMemcpy3D__retval = hipError_t(chip.hipMemcpy3D(
        hipMemcpy3DParms.from_pyobj(p)._ptr))    # fully specified
    return (_hipMemcpy3D__retval,)


@cython.embedsignature(True)
def hipMemcpy3DAsync(object p, object stream):
    r"""Copies data between host and device asynchronously.

    See:
        hipMemcpy, hipMemcpy2DToArray, hipMemcpy2D, hipMemcpyFromArray, hipMemcpyToSymbol,
        hipMemcpyAsync

    Args:
        p: **[in]** 3D memory copy parameters

        stream: **[in]** Stream to use

    Returns:
        A ``tuple`` of size 1 that contains (in that order):
        - #hipSuccess, #hipErrorInvalidValue, #hipErrorInvalidPitchValue,
            #hipErrorInvalidDevicePointer, #hipErrorInvalidMemcpyDirection
    """
    _hipMemcpy3DAsync__retval = hipError_t(chip.hipMemcpy3DAsync(
        hipMemcpy3DParms.from_pyobj(p)._ptr,
        ihipStream_t.from_pyobj(stream)._ptr))    # fully specified
    return (_hipMemcpy3DAsync__retval,)


@cython.embedsignature(True)
def hipDrvMemcpy3D(object pCopy):
    r"""Copies data between host and device.

    See:
        hipMemcpy, hipMemcpy2DToArray, hipMemcpy2D, hipMemcpyFromArray, hipMemcpyToSymbol,
        hipMemcpyAsync

    Args:
        pCopy: **[in]** 3D memory copy parameters

    Returns:
        A ``tuple`` of size 1 that contains (in that order):
        - #hipSuccess, #hipErrorInvalidValue, #hipErrorInvalidPitchValue,
            #hipErrorInvalidDevicePointer, #hipErrorInvalidMemcpyDirection
    """
    _hipDrvMemcpy3D__retval = hipError_t(chip.hipDrvMemcpy3D(
        HIP_MEMCPY3D.from_pyobj(pCopy)._ptr))    # fully specified
    return (_hipDrvMemcpy3D__retval,)


@cython.embedsignature(True)
def hipDrvMemcpy3DAsync(object pCopy, object stream):
    r"""Copies data between host and device asynchronously.

    See:
        hipMemcpy, hipMemcpy2DToArray, hipMemcpy2D, hipMemcpyFromArray, hipMemcpyToSymbol,
        hipMemcpyAsync

    Args:
        pCopy: **[in]** 3D memory copy parameters

        stream: **[in]** Stream to use

    Returns:
        A ``tuple`` of size 1 that contains (in that order):
        - #hipSuccess, #hipErrorInvalidValue, #hipErrorInvalidPitchValue,
            #hipErrorInvalidDevicePointer, #hipErrorInvalidMemcpyDirection
    """
    _hipDrvMemcpy3DAsync__retval = hipError_t(chip.hipDrvMemcpy3DAsync(
        HIP_MEMCPY3D.from_pyobj(pCopy)._ptr,
        ihipStream_t.from_pyobj(stream)._ptr))    # fully specified
    return (_hipDrvMemcpy3DAsync__retval,)


@cython.embedsignature(True)
def hipDeviceCanAccessPeer(int deviceId, int peerDeviceId):
    r"""Determine if a device can access a peer's memory.

    Returns "1" in ``canAccessPeer`` if the specified ``device`` is capable
    of directly accessing memory physically located on peerDevice , or "0" if not.

    Returns "0" in ``canAccessPeer`` if deviceId == peerDeviceId, and both are valid devices : a
    device is not a peer of itself.

    Args:
        device: **[in]**  device from where memory may be accessed.

        peerDevice: **[in]**  device where memory is physically located

    Returns:
        A ``tuple`` of size 3 that contains (in that order):
        - #hipSuccess,
        - #hipErrorInvalidDevice if deviceId or peerDeviceId are not valid devices
        - canAccessPeer: Returns the peer access capability (0 or 1)
    """
    cdef int canAccessPeer
    _hipDeviceCanAccessPeer__retval = hipError_t(chip.hipDeviceCanAccessPeer(&canAccessPeer,deviceId,peerDeviceId))    # fully specified
    return (_hipDeviceCanAccessPeer__retval,canAccessPeer)


@cython.embedsignature(True)
def hipDeviceEnablePeerAccess(int peerDeviceId, unsigned int flags):
    r"""Enable direct access from current device's virtual address space to memory allocations
    physically located on a peer device.

    Memory which already allocated on peer device will be mapped into the address space of the
    current device.  In addition, all future memory allocations on peerDeviceId will be mapped into
    the address space of the current device when the memory is allocated. The peer memory remains
    accessible from the current device until a call to hipDeviceDisablePeerAccess or hipDeviceReset.

    Returns #hipSuccess, #hipErrorInvalidDevice, #hipErrorInvalidValue,

    Args:
        peerDeviceId: **[in]** 

        flags: **[in]** 

    Returns:
        A ``tuple`` of size 1 that contains (in that order):
        - #hipErrorPeerAccessAlreadyEnabled if peer access is already enabled for this device.
    """
    _hipDeviceEnablePeerAccess__retval = hipError_t(chip.hipDeviceEnablePeerAccess(peerDeviceId,flags))    # fully specified
    return (_hipDeviceEnablePeerAccess__retval,)


@cython.embedsignature(True)
def hipDeviceDisablePeerAccess(int peerDeviceId):
    r"""Disable direct access from current device's virtual address space to memory allocations
    physically located on a peer device.

    Returns hipErrorPeerAccessNotEnabled if direct access to memory on peerDevice has not yet been
    enabled from the current device.

    Args:
        peerDeviceId: **[in]** 

    Returns:
        A ``tuple`` of size 1 that contains (in that order):
        - #hipSuccess, #hipErrorPeerAccessNotEnabled
    """
    _hipDeviceDisablePeerAccess__retval = hipError_t(chip.hipDeviceDisablePeerAccess(peerDeviceId))    # fully specified
    return (_hipDeviceDisablePeerAccess__retval,)


@cython.embedsignature(True)
def hipMemGetAddressRange(object pbase, object dptr):
    r"""Get information on memory allocations.

    See:
        hipCtxCreate, hipCtxDestroy, hipCtxGetFlags, hipCtxPopCurrent, hipCtxGetCurrent,
        hipCtxSetCurrent, hipCtxPushCurrent, hipCtxSetCacheConfig, hipCtxSynchronize, hipCtxGetDevice

    Args:
        pbase: **[out]**  BAse pointer address

        dptr: **[in]**  Device Pointer

    Returns:
        A ``tuple`` of size 2 that contains (in that order):
        - #hipSuccess, #hipErrorInvalidDevicePointer
        - psize:  Size of allocation
    """
    cdef unsigned long psize
    _hipMemGetAddressRange__retval = hipError_t(chip.hipMemGetAddressRange(
        <void **>hip._util.types.DataHandle.from_pyobj(pbase)._ptr,&psize,
        <void *>hip._util.types.DataHandle.from_pyobj(dptr)._ptr))    # fully specified
    return (_hipMemGetAddressRange__retval,psize)


@cython.embedsignature(True)
def hipMemcpyPeer(object dst, int dstDeviceId, object src, int srcDeviceId, unsigned long sizeBytes):
    r"""Copies memory from one device to memory on another device.

    Args:
        dst: **[out]**  Destination device pointer.

        dstDeviceId: **[in]**  Destination device

        src: **[in]**  Source device pointer

        srcDeviceId: **[in]**  Source device

        sizeBytes: **[in]**  Size of memory copy in bytes

    Returns:
        A ``tuple`` of size 1 that contains (in that order):
        - #hipSuccess, #hipErrorInvalidValue, #hipErrorInvalidDevice
    """
    _hipMemcpyPeer__retval = hipError_t(chip.hipMemcpyPeer(
        <void *>hip._util.types.DataHandle.from_pyobj(dst)._ptr,dstDeviceId,
        <const void *>hip._util.types.DataHandle.from_pyobj(src)._ptr,srcDeviceId,sizeBytes))    # fully specified
    return (_hipMemcpyPeer__retval,)


@cython.embedsignature(True)
def hipMemcpyPeerAsync(object dst, int dstDeviceId, object src, int srcDevice, unsigned long sizeBytes, object stream):
    r"""Copies memory from one device to memory on another device.

    Args:
        dst: **[out]**  Destination device pointer.

        dstDevice: **[in]**  Destination device

        src: **[in]**  Source device pointer

        srcDevice: **[in]**  Source device

        sizeBytes: **[in]**  Size of memory copy in bytes

        stream: **[in]**  Stream identifier

    Returns:
        A ``tuple`` of size 1 that contains (in that order):
        - #hipSuccess, #hipErrorInvalidValue, #hipErrorInvalidDevice
    """
    _hipMemcpyPeerAsync__retval = hipError_t(chip.hipMemcpyPeerAsync(
        <void *>hip._util.types.DataHandle.from_pyobj(dst)._ptr,dstDeviceId,
        <const void *>hip._util.types.DataHandle.from_pyobj(src)._ptr,srcDevice,sizeBytes,
        ihipStream_t.from_pyobj(stream)._ptr))    # fully specified
    return (_hipMemcpyPeerAsync__retval,)


@cython.embedsignature(True)
def hipCtxCreate(unsigned int flags, int device):
    r"""Create a context and set it as current/ default context

    See:
        hipCtxDestroy, hipCtxGetFlags, hipCtxPopCurrent, hipCtxGetCurrent, hipCtxPushCurrent,
        hipCtxSetCacheConfig, hipCtxSynchronize, hipCtxGetDevice

    Args:
        flags: **[in]** 

        associated: **[in]** device handle

    Returns:
        A ``tuple`` of size 2 that contains (in that order):
        - #hipSuccess
        - ctx:
    """
    ctx = ihipCtx_t.from_ptr(NULL)
    _hipCtxCreate__retval = hipError_t(chip.hipCtxCreate(&ctx._ptr,flags,device))    # fully specified
    return (_hipCtxCreate__retval,ctx)


@cython.embedsignature(True)
def hipCtxDestroy(object ctx):
    r"""Destroy a HIP context.

    See:
        hipCtxCreate, hipCtxGetFlags, hipCtxPopCurrent, hipCtxGetCurrent,hipCtxSetCurrent,
        hipCtxPushCurrent, hipCtxSetCacheConfig, hipCtxSynchronize , hipCtxGetDevice

    Args:
        ctx: **[in]** Context to destroy

    Returns:
        A ``tuple`` of size 1 that contains (in that order):
        - #hipSuccess, #hipErrorInvalidValue
    """
    _hipCtxDestroy__retval = hipError_t(chip.hipCtxDestroy(
        ihipCtx_t.from_pyobj(ctx)._ptr))    # fully specified
    return (_hipCtxDestroy__retval,)


@cython.embedsignature(True)
def hipCtxPopCurrent():
    r"""Pop the current/default context and return the popped context.

    See:
        hipCtxCreate, hipCtxDestroy, hipCtxGetFlags, hipCtxSetCurrent, hipCtxGetCurrent,
        hipCtxPushCurrent, hipCtxSetCacheConfig, hipCtxSynchronize, hipCtxGetDevice

    Returns:
        A ``tuple`` of size 2 that contains (in that order):
        - #hipSuccess, #hipErrorInvalidContext
        - ctx:
    """
    ctx = ihipCtx_t.from_ptr(NULL)
    _hipCtxPopCurrent__retval = hipError_t(chip.hipCtxPopCurrent(&ctx._ptr))    # fully specified
    return (_hipCtxPopCurrent__retval,ctx)


@cython.embedsignature(True)
def hipCtxPushCurrent(object ctx):
    r"""Push the context to be set as current/ default context

    See:
        hipCtxCreate, hipCtxDestroy, hipCtxGetFlags, hipCtxPopCurrent, hipCtxGetCurrent,
        hipCtxPushCurrent, hipCtxSetCacheConfig, hipCtxSynchronize , hipCtxGetDevice

    Args:
        ctx: **[in]** 

    Returns:
        A ``tuple`` of size 1 that contains (in that order):
        - #hipSuccess, #hipErrorInvalidContext
    """
    _hipCtxPushCurrent__retval = hipError_t(chip.hipCtxPushCurrent(
        ihipCtx_t.from_pyobj(ctx)._ptr))    # fully specified
    return (_hipCtxPushCurrent__retval,)


@cython.embedsignature(True)
def hipCtxSetCurrent(object ctx):
    r"""Set the passed context as current/default

    See:
        hipCtxCreate, hipCtxDestroy, hipCtxGetFlags, hipCtxPopCurrent, hipCtxGetCurrent,
        hipCtxPushCurrent, hipCtxSetCacheConfig, hipCtxSynchronize , hipCtxGetDevice

    Args:
        ctx: **[in]** 

    Returns:
        A ``tuple`` of size 1 that contains (in that order):
        - #hipSuccess, #hipErrorInvalidContext
    """
    _hipCtxSetCurrent__retval = hipError_t(chip.hipCtxSetCurrent(
        ihipCtx_t.from_pyobj(ctx)._ptr))    # fully specified
    return (_hipCtxSetCurrent__retval,)


@cython.embedsignature(True)
def hipCtxGetCurrent():
    r"""Get the handle of the current/ default context

    See:
        hipCtxCreate, hipCtxDestroy, hipCtxGetDevice, hipCtxGetFlags, hipCtxPopCurrent,
        hipCtxPushCurrent, hipCtxSetCacheConfig, hipCtxSynchronize, hipCtxGetDevice

    Returns:
        A ``tuple`` of size 2 that contains (in that order):
        - #hipSuccess, #hipErrorInvalidContext
        - ctx:
    """
    ctx = ihipCtx_t.from_ptr(NULL)
    _hipCtxGetCurrent__retval = hipError_t(chip.hipCtxGetCurrent(&ctx._ptr))    # fully specified
    return (_hipCtxGetCurrent__retval,ctx)


@cython.embedsignature(True)
def hipCtxGetDevice():
    r"""Get the handle of the device associated with current/default context

    See:
        hipCtxCreate, hipCtxDestroy, hipCtxGetFlags, hipCtxPopCurrent, hipCtxGetCurrent,
        hipCtxPushCurrent, hipCtxSetCacheConfig, hipCtxSynchronize

    Returns:
        A ``tuple`` of size 2 that contains (in that order):
        - #hipSuccess, #hipErrorInvalidContext
        - device:
    """
    cdef int device
    _hipCtxGetDevice__retval = hipError_t(chip.hipCtxGetDevice(&device))    # fully specified
    return (_hipCtxGetDevice__retval,device)


@cython.embedsignature(True)
def hipCtxGetApiVersion(object ctx):
    r"""Returns the approximate HIP api version.

    Warning:
        The HIP feature set does not correspond to an exact CUDA SDK api revision.
        This function always set *apiVersion to 4 as an approximation though HIP supports
        some features which were introduced in later CUDA SDK revisions.
        HIP apps code should not rely on the api revision number here and should
        use arch feature flags to test device capabilities or conditional compilation.

    See:
        hipCtxCreate, hipCtxDestroy, hipCtxGetDevice, hipCtxGetFlags, hipCtxPopCurrent,
        hipCtxPushCurrent, hipCtxSetCacheConfig, hipCtxSynchronize, hipCtxGetDevice

    Args:
        ctx: **[in]** Context to check

    Returns:
        A ``tuple`` of size 2 that contains (in that order):
        - #hipSuccess
        - apiVersion:
    """
    cdef int apiVersion
    _hipCtxGetApiVersion__retval = hipError_t(chip.hipCtxGetApiVersion(
        ihipCtx_t.from_pyobj(ctx)._ptr,&apiVersion))    # fully specified
    return (_hipCtxGetApiVersion__retval,apiVersion)


@cython.embedsignature(True)
def hipCtxGetCacheConfig():
    r"""Set Cache configuration for a specific function

    Warning:
        AMD devices and some Nvidia GPUS do not support reconfigurable cache.  This hint is
        ignored on those architectures.

    See:
        hipCtxCreate, hipCtxDestroy, hipCtxGetFlags, hipCtxPopCurrent, hipCtxGetCurrent,
        hipCtxSetCurrent, hipCtxPushCurrent, hipCtxSetCacheConfig, hipCtxSynchronize, hipCtxGetDevice

    Args:
        cacheConfiguration: **[out]** 

    Returns:
        A ``tuple`` of size 1 that contains (in that order):
        - #hipSuccess
    """
    cdef chip.hipFuncCache_t cacheConfig
    _hipCtxGetCacheConfig__retval = hipError_t(chip.hipCtxGetCacheConfig(&cacheConfig))    # fully specified
    return (_hipCtxGetCacheConfig__retval,hipFuncCache_t(cacheConfig))


@cython.embedsignature(True)
def hipCtxSetCacheConfig(object cacheConfig):
    r"""Set L1/Shared cache partition.

    Warning:
        AMD devices and some Nvidia GPUS do not support reconfigurable cache.  This hint is
        ignored on those architectures.

    See:
        hipCtxCreate, hipCtxDestroy, hipCtxGetFlags, hipCtxPopCurrent, hipCtxGetCurrent,
        hipCtxSetCurrent, hipCtxPushCurrent, hipCtxSetCacheConfig, hipCtxSynchronize, hipCtxGetDevice

    Args:
        cacheConfiguration: **[in]** 

    Returns:
        A ``tuple`` of size 1 that contains (in that order):
        - #hipSuccess
    """
    if not isinstance(cacheConfig,_hipFuncCache_t__Base):
        raise TypeError("argument 'cacheConfig' must be of type '_hipFuncCache_t__Base'")
    _hipCtxSetCacheConfig__retval = hipError_t(chip.hipCtxSetCacheConfig(cacheConfig.value))    # fully specified
    return (_hipCtxSetCacheConfig__retval,)


@cython.embedsignature(True)
def hipCtxSetSharedMemConfig(object config):
    r"""Set Shared memory bank configuration.

    Warning:
        AMD devices and some Nvidia GPUS do not support shared cache banking, and the hint is
        ignored on those architectures.

    See:
        hipCtxCreate, hipCtxDestroy, hipCtxGetFlags, hipCtxPopCurrent, hipCtxGetCurrent,
        hipCtxSetCurrent, hipCtxPushCurrent, hipCtxSetCacheConfig, hipCtxSynchronize, hipCtxGetDevice

    Args:
        sharedMemoryConfiguration: **[in]** 

    Returns:
        A ``tuple`` of size 1 that contains (in that order):
        - #hipSuccess
    """
    if not isinstance(config,_hipSharedMemConfig__Base):
        raise TypeError("argument 'config' must be of type '_hipSharedMemConfig__Base'")
    _hipCtxSetSharedMemConfig__retval = hipError_t(chip.hipCtxSetSharedMemConfig(config.value))    # fully specified
    return (_hipCtxSetSharedMemConfig__retval,)


@cython.embedsignature(True)
def hipCtxGetSharedMemConfig():
    r"""Get Shared memory bank configuration.

    Warning:
        AMD devices and some Nvidia GPUS do not support shared cache banking, and the hint is
        ignored on those architectures.

    See:
        hipCtxCreate, hipCtxDestroy, hipCtxGetFlags, hipCtxPopCurrent, hipCtxGetCurrent,
        hipCtxSetCurrent, hipCtxPushCurrent, hipCtxSetCacheConfig, hipCtxSynchronize, hipCtxGetDevice

    Args:
        sharedMemoryConfiguration: **[out]** 

    Returns:
        A ``tuple`` of size 1 that contains (in that order):
        - #hipSuccess
    """
    cdef chip.hipSharedMemConfig pConfig
    _hipCtxGetSharedMemConfig__retval = hipError_t(chip.hipCtxGetSharedMemConfig(&pConfig))    # fully specified
    return (_hipCtxGetSharedMemConfig__retval,hipSharedMemConfig(pConfig))


@cython.embedsignature(True)
def hipCtxSynchronize():
    r"""Blocks until the default context has completed all preceding requested tasks.

    Warning:
        This function waits for all streams on the default context to complete execution, and
        then returns.

    See:
        hipCtxCreate, hipCtxDestroy, hipCtxGetFlags, hipCtxPopCurrent, hipCtxGetCurrent,
        hipCtxSetCurrent, hipCtxPushCurrent, hipCtxSetCacheConfig, hipCtxGetDevice

    Returns:
        A ``tuple`` of size 1 that contains (in that order):
        - #hipSuccess
    """
    _hipCtxSynchronize__retval = hipError_t(chip.hipCtxSynchronize())    # fully specified
    return (_hipCtxSynchronize__retval,)


@cython.embedsignature(True)
def hipCtxGetFlags():
    r"""Return flags used for creating default context.

    See:
        hipCtxCreate, hipCtxDestroy, hipCtxPopCurrent, hipCtxGetCurrent, hipCtxGetCurrent,
        hipCtxSetCurrent, hipCtxPushCurrent, hipCtxSetCacheConfig, hipCtxSynchronize, hipCtxGetDevice

    Returns:
        A ``tuple`` of size 2 that contains (in that order):
        - #hipSuccess
        - flags:
    """
    cdef unsigned int flags
    _hipCtxGetFlags__retval = hipError_t(chip.hipCtxGetFlags(&flags))    # fully specified
    return (_hipCtxGetFlags__retval,flags)


@cython.embedsignature(True)
def hipCtxEnablePeerAccess(object peerCtx, unsigned int flags):
    r"""Enables direct access to memory allocations in a peer context.

    Memory which already allocated on peer device will be mapped into the address space of the
    current device.  In addition, all future memory allocations on peerDeviceId will be mapped into
    the address space of the current device when the memory is allocated. The peer memory remains
    accessible from the current device until a call to hipDeviceDisablePeerAccess or hipDeviceReset.

    See:
        hipCtxCreate, hipCtxDestroy, hipCtxGetFlags, hipCtxPopCurrent, hipCtxGetCurrent,
        hipCtxSetCurrent, hipCtxPushCurrent, hipCtxSetCacheConfig, hipCtxSynchronize, hipCtxGetDevice

    Warning:
        PeerToPeer support is experimental.

    Args:
        peerCtx: **[in]** 

        flags: **[in]** 

    Returns:
        A ``tuple`` of size 1 that contains (in that order):
        - #hipSuccess, #hipErrorInvalidDevice, #hipErrorInvalidValue,
            #hipErrorPeerAccessAlreadyEnabled
    """
    _hipCtxEnablePeerAccess__retval = hipError_t(chip.hipCtxEnablePeerAccess(
        ihipCtx_t.from_pyobj(peerCtx)._ptr,flags))    # fully specified
    return (_hipCtxEnablePeerAccess__retval,)


@cython.embedsignature(True)
def hipCtxDisablePeerAccess(object peerCtx):
    r"""Disable direct access from current context's virtual address space to memory allocations
    physically located on a peer context.Disables direct access to memory allocations in a peer
    context and unregisters any registered allocations.

    Returns hipErrorPeerAccessNotEnabled if direct access to memory on peerDevice has not yet been
    enabled from the current device.

    See:
        hipCtxCreate, hipCtxDestroy, hipCtxGetFlags, hipCtxPopCurrent, hipCtxGetCurrent,
        hipCtxSetCurrent, hipCtxPushCurrent, hipCtxSetCacheConfig, hipCtxSynchronize, hipCtxGetDevice

    Warning:
        PeerToPeer support is experimental.

    Args:
        peerCtx: **[in]** 

    Returns:
        A ``tuple`` of size 1 that contains (in that order):
        - #hipSuccess, #hipErrorPeerAccessNotEnabled
    """
    _hipCtxDisablePeerAccess__retval = hipError_t(chip.hipCtxDisablePeerAccess(
        ihipCtx_t.from_pyobj(peerCtx)._ptr))    # fully specified
    return (_hipCtxDisablePeerAccess__retval,)


@cython.embedsignature(True)
def hipDevicePrimaryCtxGetState(int dev):
    r"""Get the state of the primary context.

    See:
        hipCtxCreate, hipCtxDestroy, hipCtxGetFlags, hipCtxPopCurrent, hipCtxGetCurrent,
        hipCtxSetCurrent, hipCtxPushCurrent, hipCtxSetCacheConfig, hipCtxSynchronize, hipCtxGetDevice

    Args:
        Device: **[in]** to get primary context flags for

        Pointer: **[out]** to store flags

        Pointer: **[out]** to store context state; 0 = inactive, 1 = active

    Returns:
        A ``tuple`` of size 1 that contains (in that order):
        - #hipSuccess
    """
    cdef unsigned int flags
    cdef int active
    _hipDevicePrimaryCtxGetState__retval = hipError_t(chip.hipDevicePrimaryCtxGetState(dev,&flags,&active))    # fully specified
    return (_hipDevicePrimaryCtxGetState__retval,flags,active)


@cython.embedsignature(True)
def hipDevicePrimaryCtxRelease(int dev):
    r"""Release the primary context on the GPU.

    See:
        hipCtxCreate, hipCtxDestroy, hipCtxGetFlags, hipCtxPopCurrent, hipCtxGetCurrent,
        hipCtxSetCurrent, hipCtxPushCurrent, hipCtxSetCacheConfig, hipCtxSynchronize, hipCtxGetDevice

    Warning:
        This function return #hipSuccess though doesn't release the primaryCtx by design on
        HIP/HCC path.

    Args:
        Device: **[in]** which primary context is released

    Returns:
        A ``tuple`` of size 1 that contains (in that order):
        - #hipSuccess
    """
    _hipDevicePrimaryCtxRelease__retval = hipError_t(chip.hipDevicePrimaryCtxRelease(dev))    # fully specified
    return (_hipDevicePrimaryCtxRelease__retval,)


@cython.embedsignature(True)
def hipDevicePrimaryCtxRetain(int dev):
    r"""Retain the primary context on the GPU.

    See:
        hipCtxCreate, hipCtxDestroy, hipCtxGetFlags, hipCtxPopCurrent, hipCtxGetCurrent,
        hipCtxSetCurrent, hipCtxPushCurrent, hipCtxSetCacheConfig, hipCtxSynchronize, hipCtxGetDevice

    Args:
        Returned: **[out]** context handle of the new context

        Device: **[in]** which primary context is released

    Returns:
        A ``tuple`` of size 1 that contains (in that order):
        - #hipSuccess
    """
    pctx = ihipCtx_t.from_ptr(NULL)
    _hipDevicePrimaryCtxRetain__retval = hipError_t(chip.hipDevicePrimaryCtxRetain(&pctx._ptr,dev))    # fully specified
    return (_hipDevicePrimaryCtxRetain__retval,pctx)


@cython.embedsignature(True)
def hipDevicePrimaryCtxReset(int dev):
    r"""Resets the primary context on the GPU.

    See:
        hipCtxCreate, hipCtxDestroy, hipCtxGetFlags, hipCtxPopCurrent, hipCtxGetCurrent,
        hipCtxSetCurrent, hipCtxPushCurrent, hipCtxSetCacheConfig, hipCtxSynchronize, hipCtxGetDevice

    Args:
        Device: **[in]** which primary context is reset

    Returns:
        A ``tuple`` of size 1 that contains (in that order):
        - #hipSuccess
    """
    _hipDevicePrimaryCtxReset__retval = hipError_t(chip.hipDevicePrimaryCtxReset(dev))    # fully specified
    return (_hipDevicePrimaryCtxReset__retval,)


@cython.embedsignature(True)
def hipDevicePrimaryCtxSetFlags(int dev, unsigned int flags):
    r"""Set flags for the primary context.

    See:
        hipCtxCreate, hipCtxDestroy, hipCtxGetFlags, hipCtxPopCurrent, hipCtxGetCurrent,
        hipCtxSetCurrent, hipCtxPushCurrent, hipCtxSetCacheConfig, hipCtxSynchronize, hipCtxGetDevice

    Args:
        Device: **[in]** for which the primary context flags are set

        New: **[in]** flags for the device

    Returns:
        A ``tuple`` of size 1 that contains (in that order):
        - #hipSuccess, #hipErrorContextAlreadyInUse
    """
    _hipDevicePrimaryCtxSetFlags__retval = hipError_t(chip.hipDevicePrimaryCtxSetFlags(dev,flags))    # fully specified
    return (_hipDevicePrimaryCtxSetFlags__retval,)


@cython.embedsignature(True)
def hipModuleLoad(const char * fname):
    r"""Loads code object from file into a hipModule_t

    Warning:
        File/memory resources allocated in this function are released only in hipModuleUnload.

    Args:
        fname: **[in]** 

    Returns:
        A ``tuple`` of size 2 that contains (in that order):
        - hipSuccess, hipErrorInvalidValue, hipErrorInvalidContext, hipErrorFileNotFound,
            hipErrorOutOfMemory, hipErrorSharedObjectInitFailed, hipErrorNotInitialized
        - module:
    """
    module = ihipModule_t.from_ptr(NULL)
    _hipModuleLoad__retval = hipError_t(chip.hipModuleLoad(&module._ptr,fname))    # fully specified
    return (_hipModuleLoad__retval,module)


@cython.embedsignature(True)
def hipModuleUnload(object module):
    r"""Frees the module

    Args:
        module: **[in]** 

    Returns:
        A ``tuple`` of size 1 that contains (in that order):
        - hipSuccess, hipInvalidValue
            module is freed and the code objects associated with it are destroyed
    """
    _hipModuleUnload__retval = hipError_t(chip.hipModuleUnload(
        ihipModule_t.from_pyobj(module)._ptr))    # fully specified
    return (_hipModuleUnload__retval,)


@cython.embedsignature(True)
def hipModuleGetFunction(object module, const char * kname):
    r"""Function with kname will be extracted if present in module

    Args:
        module: **[in]** 

        kname: **[in]** 

    Returns:
        A ``tuple`` of size 2 that contains (in that order):
        - hipSuccess, hipErrorInvalidValue, hipErrorInvalidContext, hipErrorNotInitialized,
            hipErrorNotFound,
        - function:
    """
    function = ihipModuleSymbol_t.from_ptr(NULL)
    _hipModuleGetFunction__retval = hipError_t(chip.hipModuleGetFunction(&function._ptr,
        ihipModule_t.from_pyobj(module)._ptr,kname))    # fully specified
    return (_hipModuleGetFunction__retval,function)


@cython.embedsignature(True)
def hipFuncGetAttributes(object attr, object func):
    r"""Find out attributes for a given function.

    Args:
        attr: **[out]** 

        func: **[in]** 

    Returns:
        A ``tuple`` of size 1 that contains (in that order):
        - hipSuccess, hipErrorInvalidValue, hipErrorInvalidDeviceFunction
    """
    _hipFuncGetAttributes__retval = hipError_t(chip.hipFuncGetAttributes(
        hipFuncAttributes.from_pyobj(attr)._ptr,
        <const void *>hip._util.types.DataHandle.from_pyobj(func)._ptr))    # fully specified
    return (_hipFuncGetAttributes__retval,)


@cython.embedsignature(True)
def hipFuncGetAttribute(object attrib, object hfunc):
    r"""Find out a specific attribute for a given function.

    Args:
        attrib: **[in]** 

        hfunc: **[in]** 

    Returns:
        A ``tuple`` of size 2 that contains (in that order):
        - hipSuccess, hipErrorInvalidValue, hipErrorInvalidDeviceFunction
        - value:
    """
    cdef int value
    if not isinstance(attrib,_hipFunction_attribute__Base):
        raise TypeError("argument 'attrib' must be of type '_hipFunction_attribute__Base'")
    _hipFuncGetAttribute__retval = hipError_t(chip.hipFuncGetAttribute(&value,attrib.value,
        ihipModuleSymbol_t.from_pyobj(hfunc)._ptr))    # fully specified
    return (_hipFuncGetAttribute__retval,value)


@cython.embedsignature(True)
def hipModuleGetTexRef(object hmod, const char * name):
    r"""returns the handle of the texture reference with the name from the module.

    Args:
        hmod: **[in]** 

        name: **[in]** 

    Returns:
        A ``tuple`` of size 2 that contains (in that order):
        - hipSuccess, hipErrorNotInitialized, hipErrorNotFound, hipErrorInvalidValue
        - texRef:
    """
    texRef = textureReference.from_ptr(NULL)
    _hipModuleGetTexRef__retval = hipError_t(chip.hipModuleGetTexRef(&texRef._ptr,
        ihipModule_t.from_pyobj(hmod)._ptr,name))    # fully specified
    return (_hipModuleGetTexRef__retval,texRef)


@cython.embedsignature(True)
def hipModuleLoadData(object image):
    r"""builds module from code object which resides in host memory. Image is pointer to that
    location.

    Args:
        image: **[in]** 

    Returns:
        A ``tuple`` of size 2 that contains (in that order):
        - hipSuccess, hipErrorNotInitialized, hipErrorOutOfMemory, hipErrorNotInitialized
        - module:
    """
    module = ihipModule_t.from_ptr(NULL)
    _hipModuleLoadData__retval = hipError_t(chip.hipModuleLoadData(&module._ptr,
        <const void *>hip._util.types.DataHandle.from_pyobj(image)._ptr))    # fully specified
    return (_hipModuleLoadData__retval,module)


@cython.embedsignature(True)
def hipModuleLoadDataEx(object image, unsigned int numOptions, object optionValues):
    r"""builds module from code object which resides in host memory. Image is pointer to that
    location. Options are not used. hipModuleLoadData is called.

    Args:
        image: **[in]** 

        number: **[in]** of options

        option: **[in]** values for JIT

    Returns:
        A ``tuple`` of size 3 that contains (in that order):
        - hipSuccess, hipErrorNotInitialized, hipErrorOutOfMemory, hipErrorNotInitialized
        - module:
        - options: for JIT
    """
    module = ihipModule_t.from_ptr(NULL)
    cdef chip.hipJitOption options
    _hipModuleLoadDataEx__retval = hipError_t(chip.hipModuleLoadDataEx(&module._ptr,
        <const void *>hip._util.types.DataHandle.from_pyobj(image)._ptr,numOptions,&options,
        <void **>hip._util.types.DataHandle.from_pyobj(optionValues)._ptr))    # fully specified
    return (_hipModuleLoadDataEx__retval,module,hipJitOption(options))


@cython.embedsignature(True)
def hipModuleLaunchKernel(object f, unsigned int gridDimX, unsigned int gridDimY, unsigned int gridDimZ, unsigned int blockDimX, unsigned int blockDimY, unsigned int blockDimZ, unsigned int sharedMemBytes, object stream, object kernelParams, object extra):
    r"""launches kernel f with launch parameters and shared memory on stream with arguments passed
    to kernelparams or extra

    Please note, HIP does not support kernel launch with total work items defined in dimension with
    size gridDim x blockDim >= 2^32. So gridDim.x * blockDim.x, gridDim.y * blockDim.y
    and gridDim.z * blockDim.z are always less than 2^32.

    Warning:
        kernellParams argument is not yet implemented in HIP. Please use extra instead. Please
        refer to hip_porting_driver_api.md for sample usage.

    Args:
        f: **[in]** Kernel to launch.

        gridDimX: **[in]** X grid dimension specified as multiple of blockDimX.

        gridDimY: **[in]** Y grid dimension specified as multiple of blockDimY.

        gridDimZ: **[in]** Z grid dimension specified as multiple of blockDimZ.

        blockDimX: **[in]** X block dimensions specified in work-items

        blockDimY: **[in]** Y grid dimension specified in work-items

        blockDimZ: **[in]** Z grid dimension specified in work-items

        sharedMemBytes: **[in]** Amount of dynamic shared memory to allocate for this kernel. The
            HIP-Clang compiler provides support for extern shared declarations.

        stream: **[in]** Stream where the kernel should be dispatched.  May be 0, in which case th
            default stream is used with associated synchronization rules.

        kernelParams: **[in]** 

        extra: **[in]** Pointer to kernel arguments.   These are passed directly to the kernel and
            must be in the memory layout and alignment expected by the kernel.

    Returns:
        A ``tuple`` of size 1 that contains (in that order):
        - hipSuccess, hipInvalidDevice, hipErrorNotInitialized, hipErrorInvalidValue
    """
    _hipModuleLaunchKernel__retval = hipError_t(chip.hipModuleLaunchKernel(
        ihipModuleSymbol_t.from_pyobj(f)._ptr,gridDimX,gridDimY,gridDimZ,blockDimX,blockDimY,blockDimZ,sharedMemBytes,
        ihipStream_t.from_pyobj(stream)._ptr,
        <void **>hip._util.types.DataHandle.from_pyobj(kernelParams)._ptr,
        <void **>hip._hip_helpers.HipModuleLaunchKernel_extra.from_pyobj(extra)._ptr))    # fully specified
    return (_hipModuleLaunchKernel__retval,)


@cython.embedsignature(True)
def hipLaunchCooperativeKernel(object f, object gridDim, object blockDimX, object kernelParams, unsigned int sharedMemBytes, object stream):
    r"""launches kernel f with launch parameters and shared memory on stream with arguments passed
    to kernelparams or extra, where thread blocks can cooperate and synchronize as they execute

    Please note, HIP does not support kernel launch with total work items defined in dimension with
    size gridDim x blockDim >= 2^32.

    Args:
        f: **[in]** Kernel to launch.

        gridDim: **[in]** Grid dimensions specified as multiple of blockDim.

        blockDim: **[in]** Block dimensions specified in work-items

        kernelParams: **[in]** A list of kernel arguments

        sharedMemBytes: **[in]** Amount of dynamic shared memory to allocate for this kernel. The
            HIP-Clang compiler provides support for extern shared declarations.

        stream: **[in]** Stream where the kernel should be dispatched.  May be 0, in which case th
            default stream is used with associated synchronization rules.

    Returns:
        A ``tuple`` of size 1 that contains (in that order):
        - hipSuccess, hipInvalidDevice, hipErrorNotInitialized, hipErrorInvalidValue, hipErrorCooperativeLaunchTooLarge
    """
    _hipLaunchCooperativeKernel__retval = hipError_t(chip.hipLaunchCooperativeKernel(
        <const void *>hip._util.types.DataHandle.from_pyobj(f)._ptr,
        dim3.from_pyobj(gridDim)._ptr[0],
        dim3.from_pyobj(blockDimX)._ptr[0],
        <void **>hip._util.types.DataHandle.from_pyobj(kernelParams)._ptr,sharedMemBytes,
        ihipStream_t.from_pyobj(stream)._ptr))    # fully specified
    return (_hipLaunchCooperativeKernel__retval,)


@cython.embedsignature(True)
def hipLaunchCooperativeKernelMultiDevice(object launchParamsList, int numDevices, unsigned int flags):
    r"""Launches kernels on multiple devices where thread blocks can cooperate and
    synchronize as they execute.

    Args:
        launchParamsList: **[in]** List of launch parameters, one per device.

        numDevices: **[in]** Size of the launchParamsList array.

        flags: **[in]** Flags to control launch behavior.

    Returns:
        A ``tuple`` of size 1 that contains (in that order):
        - hipSuccess, hipInvalidDevice, hipErrorNotInitialized, hipErrorInvalidValue, hipErrorCooperativeLaunchTooLarge
    """
    _hipLaunchCooperativeKernelMultiDevice__retval = hipError_t(chip.hipLaunchCooperativeKernelMultiDevice(
        hipLaunchParams_t.from_pyobj(launchParamsList)._ptr,numDevices,flags))    # fully specified
    return (_hipLaunchCooperativeKernelMultiDevice__retval,)


@cython.embedsignature(True)
def hipExtLaunchMultiKernelMultiDevice(object launchParamsList, int numDevices, unsigned int flags):
    r"""Launches kernels on multiple devices and guarantees all specified kernels are dispatched
    on respective streams before enqueuing any other work on the specified streams from any other threads

    Args:
        hipLaunchParams: **[in]** List of launch parameters, one per device.

        numDevices: **[in]** Size of the launchParamsList array.

        flags: **[in]** Flags to control launch behavior.

    Returns:
        A ``tuple`` of size 1 that contains (in that order):
        - hipSuccess, hipInvalidDevice, hipErrorNotInitialized, hipErrorInvalidValue
    """
    _hipExtLaunchMultiKernelMultiDevice__retval = hipError_t(chip.hipExtLaunchMultiKernelMultiDevice(
        hipLaunchParams_t.from_pyobj(launchParamsList)._ptr,numDevices,flags))    # fully specified
    return (_hipExtLaunchMultiKernelMultiDevice__retval,)


@cython.embedsignature(True)
def hipModuleOccupancyMaxPotentialBlockSize(object f, unsigned long dynSharedMemPerBlk, int blockSizeLimit):
    r"""determine the grid and block sizes to achieves maximum occupancy for a kernel

    Please note, HIP does not support kernel launch with total work items defined in dimension with
    size gridDim x blockDim >= 2^32.

    Args:
        f: **[in]** kernel function for which occupancy is calulated

        dynSharedMemPerBlk: **[in]** dynamic shared memory usage (in bytes) intended for each block

        blockSizeLimit: **[in]** the maximum block size for the kernel, use 0 for no limit

    Returns:
        A ``tuple`` of size 3 that contains (in that order):
        - hipSuccess, hipInvalidDevice, hipErrorInvalidValue
        - gridSize: minimum grid size for maximum potential occupancy
        - blockSize: block size for maximum potential occupancy
    """
    cdef int gridSize
    cdef int blockSize
    _hipModuleOccupancyMaxPotentialBlockSize__retval = hipError_t(chip.hipModuleOccupancyMaxPotentialBlockSize(&gridSize,&blockSize,
        ihipModuleSymbol_t.from_pyobj(f)._ptr,dynSharedMemPerBlk,blockSizeLimit))    # fully specified
    return (_hipModuleOccupancyMaxPotentialBlockSize__retval,gridSize,blockSize)


@cython.embedsignature(True)
def hipModuleOccupancyMaxPotentialBlockSizeWithFlags(object f, unsigned long dynSharedMemPerBlk, int blockSizeLimit, unsigned int flags):
    r"""determine the grid and block sizes to achieves maximum occupancy for a kernel

    Please note, HIP does not support kernel launch with total work items defined in dimension with
    size gridDim x blockDim >= 2^32.

    Args:
        f: **[in]** kernel function for which occupancy is calulated

        dynSharedMemPerBlk: **[in]** dynamic shared memory usage (in bytes) intended for each block

        blockSizeLimit: **[in]** the maximum block size for the kernel, use 0 for no limit

        flags: **[in]** Extra flags for occupancy calculation (only default supported)

    Returns:
        A ``tuple`` of size 3 that contains (in that order):
        - hipSuccess, hipInvalidDevice, hipErrorInvalidValue
        - gridSize: minimum grid size for maximum potential occupancy
        - blockSize: block size for maximum potential occupancy
    """
    cdef int gridSize
    cdef int blockSize
    _hipModuleOccupancyMaxPotentialBlockSizeWithFlags__retval = hipError_t(chip.hipModuleOccupancyMaxPotentialBlockSizeWithFlags(&gridSize,&blockSize,
        ihipModuleSymbol_t.from_pyobj(f)._ptr,dynSharedMemPerBlk,blockSizeLimit,flags))    # fully specified
    return (_hipModuleOccupancyMaxPotentialBlockSizeWithFlags__retval,gridSize,blockSize)


@cython.embedsignature(True)
def hipModuleOccupancyMaxActiveBlocksPerMultiprocessor(object f, int blockSize, unsigned long dynSharedMemPerBlk):
    r"""Returns occupancy for a device function.

    Args:
        func: **[in]** Kernel function (hipFunction) for which occupancy is calulated

        blockSize: **[in]** Block size the kernel is intended to be launched with

        dynSharedMemPerBlk: **[in]** dynamic shared memory usage (in bytes) intended for each block

    Returns:
        A ``tuple`` of size 1 that contains (in that order):
        - numBlocks: Returned occupancy
    """
    cdef int numBlocks
    _hipModuleOccupancyMaxActiveBlocksPerMultiprocessor__retval = hipError_t(chip.hipModuleOccupancyMaxActiveBlocksPerMultiprocessor(&numBlocks,
        ihipModuleSymbol_t.from_pyobj(f)._ptr,blockSize,dynSharedMemPerBlk))    # fully specified
    return (_hipModuleOccupancyMaxActiveBlocksPerMultiprocessor__retval,numBlocks)


@cython.embedsignature(True)
def hipModuleOccupancyMaxActiveBlocksPerMultiprocessorWithFlags(object f, int blockSize, unsigned long dynSharedMemPerBlk, unsigned int flags):
    r"""Returns occupancy for a device function.

    Args:
        f: **[in]** Kernel function(hipFunction_t) for which occupancy is calulated

        blockSize: **[in]** Block size the kernel is intended to be launched with

        dynSharedMemPerBlk: **[in]** dynamic shared memory usage (in bytes) intended for each block

        flags: **[in]** Extra flags for occupancy calculation (only default supported)

    Returns:
        A ``tuple`` of size 1 that contains (in that order):
        - numBlocks: Returned occupancy
    """
    cdef int numBlocks
    _hipModuleOccupancyMaxActiveBlocksPerMultiprocessorWithFlags__retval = hipError_t(chip.hipModuleOccupancyMaxActiveBlocksPerMultiprocessorWithFlags(&numBlocks,
        ihipModuleSymbol_t.from_pyobj(f)._ptr,blockSize,dynSharedMemPerBlk,flags))    # fully specified
    return (_hipModuleOccupancyMaxActiveBlocksPerMultiprocessorWithFlags__retval,numBlocks)


@cython.embedsignature(True)
def hipOccupancyMaxActiveBlocksPerMultiprocessor(object f, int blockSize, unsigned long dynSharedMemPerBlk):
    r"""Returns occupancy for a device function.

    Args:
        func: **[in]** Kernel function for which occupancy is calulated

        blockSize: **[in]** Block size the kernel is intended to be launched with

        dynSharedMemPerBlk: **[in]** dynamic shared memory usage (in bytes) intended for each block

    Returns:
        A ``tuple`` of size 1 that contains (in that order):
        - numBlocks: Returned occupancy
    """
    cdef int numBlocks
    _hipOccupancyMaxActiveBlocksPerMultiprocessor__retval = hipError_t(chip.hipOccupancyMaxActiveBlocksPerMultiprocessor(&numBlocks,
        <const void *>hip._util.types.DataHandle.from_pyobj(f)._ptr,blockSize,dynSharedMemPerBlk))    # fully specified
    return (_hipOccupancyMaxActiveBlocksPerMultiprocessor__retval,numBlocks)


@cython.embedsignature(True)
def hipOccupancyMaxActiveBlocksPerMultiprocessorWithFlags(object f, int blockSize, unsigned long dynSharedMemPerBlk, unsigned int flags):
    r"""Returns occupancy for a device function.

    Args:
        f: **[in]** Kernel function for which occupancy is calulated

        blockSize: **[in]** Block size the kernel is intended to be launched with

        dynSharedMemPerBlk: **[in]** dynamic shared memory usage (in bytes) intended for each block

        flags: **[in]** Extra flags for occupancy calculation (currently ignored)

    Returns:
        A ``tuple`` of size 1 that contains (in that order):
        - numBlocks: Returned occupancy
    """
    cdef int numBlocks
    _hipOccupancyMaxActiveBlocksPerMultiprocessorWithFlags__retval = hipError_t(chip.hipOccupancyMaxActiveBlocksPerMultiprocessorWithFlags(&numBlocks,
        <const void *>hip._util.types.DataHandle.from_pyobj(f)._ptr,blockSize,dynSharedMemPerBlk,flags))    # fully specified
    return (_hipOccupancyMaxActiveBlocksPerMultiprocessorWithFlags__retval,numBlocks)


@cython.embedsignature(True)
def hipOccupancyMaxPotentialBlockSize(object f, unsigned long dynSharedMemPerBlk, int blockSizeLimit):
    r"""determine the grid and block sizes to achieves maximum occupancy for a kernel

    Please note, HIP does not support kernel launch with total work items defined in dimension with
    size gridDim x blockDim >= 2^32.

    Args:
        f: **[in]** kernel function for which occupancy is calulated

        dynSharedMemPerBlk: **[in]** dynamic shared memory usage (in bytes) intended for each block

        blockSizeLimit: **[in]** the maximum block size for the kernel, use 0 for no limit

    Returns:
        A ``tuple`` of size 3 that contains (in that order):
        - hipSuccess, hipInvalidDevice, hipErrorInvalidValue
        - gridSize: minimum grid size for maximum potential occupancy
        - blockSize: block size for maximum potential occupancy
    """
    cdef int gridSize
    cdef int blockSize
    _hipOccupancyMaxPotentialBlockSize__retval = hipError_t(chip.hipOccupancyMaxPotentialBlockSize(&gridSize,&blockSize,
        <const void *>hip._util.types.DataHandle.from_pyobj(f)._ptr,dynSharedMemPerBlk,blockSizeLimit))    # fully specified
    return (_hipOccupancyMaxPotentialBlockSize__retval,gridSize,blockSize)


@cython.embedsignature(True)
def hipProfilerStart():
    r"""Start recording of profiling information
    When using this API, start the profiler with profiling disabled.  (--startdisabled)

    Warning:
        hipProfilerStart API is under development.
    """
    _hipProfilerStart__retval = hipError_t(chip.hipProfilerStart())    # fully specified
    return (_hipProfilerStart__retval,)


@cython.embedsignature(True)
def hipProfilerStop():
    r"""Stop recording of profiling information.
    When using this API, start the profiler with profiling disabled.  (--startdisabled)

    Warning:
        hipProfilerStop API is under development.
    """
    _hipProfilerStop__retval = hipError_t(chip.hipProfilerStop())    # fully specified
    return (_hipProfilerStop__retval,)


@cython.embedsignature(True)
def hipConfigureCall(object gridDim, object blockDim, unsigned long sharedMem, object stream):
    r"""Configure a kernel launch.

    Please note, HIP does not support kernel launch with total work items defined in dimension with
    size gridDim x blockDim >= 2^32.

    Args:
        gridDim: **[in]** grid dimension specified as multiple of blockDim.

        blockDim: **[in]** block dimensions specified in work-items

        sharedMem: **[in]** Amount of dynamic shared memory to allocate for this kernel. The
            HIP-Clang compiler provides support for extern shared declarations.

        stream: **[in]** Stream where the kernel should be dispatched.  May be 0, in which case the
            default stream is used with associated synchronization rules.

    Returns:
        A ``tuple`` of size 1 that contains (in that order):
        - hipSuccess, hipInvalidDevice, hipErrorNotInitialized, hipErrorInvalidValue
    """
    _hipConfigureCall__retval = hipError_t(chip.hipConfigureCall(
        dim3.from_pyobj(gridDim)._ptr[0],
        dim3.from_pyobj(blockDim)._ptr[0],sharedMem,
        ihipStream_t.from_pyobj(stream)._ptr))    # fully specified
    return (_hipConfigureCall__retval,)


@cython.embedsignature(True)
def hipSetupArgument(object arg, unsigned long size, unsigned long offset):
    r"""Set a kernel argument.

    Args:
        arg: **[in]** Pointer the argument in host memory.

        size: **[in]** Size of the argument.

        offset: **[in]** Offset of the argument on the argument stack.

    Returns:
        A ``tuple`` of size 1 that contains (in that order):
        - hipSuccess, hipInvalidDevice, hipErrorNotInitialized, hipErrorInvalidValue
    """
    _hipSetupArgument__retval = hipError_t(chip.hipSetupArgument(
        <const void *>hip._util.types.DataHandle.from_pyobj(arg)._ptr,size,offset))    # fully specified
    return (_hipSetupArgument__retval,)


@cython.embedsignature(True)
def hipLaunchByPtr(object func):
    r"""Launch a kernel.

    Args:
        func: **[in]** Kernel to launch.

    Returns:
        A ``tuple`` of size 1 that contains (in that order):
        - hipSuccess, hipInvalidDevice, hipErrorNotInitialized, hipErrorInvalidValue
    """
    _hipLaunchByPtr__retval = hipError_t(chip.hipLaunchByPtr(
        <const void *>hip._util.types.DataHandle.from_pyobj(func)._ptr))    # fully specified
    return (_hipLaunchByPtr__retval,)


@cython.embedsignature(True)
def hipLaunchKernel(object function_address, object numBlocks, object dimBlocks, object args, unsigned long sharedMemBytes, object stream):
    r"""C compliant kernel launch API

    Args:
        function_address: **[in]**  kernel stub function pointer.

        numBlocks: **[in]**  number of blocks

        dimBlocks: **[in]**  dimension of a block

        args: **[in]**  kernel arguments

        sharedMemBytes: **[in]**  Amount of dynamic shared memory to allocate for this kernel. The
            HIP-Clang compiler provides support for extern shared declarations.

        stream: **[in]**  Stream where the kernel should be dispatched.  May be 0, in which case th
            default stream is used with associated synchronization rules.

    Returns:
        A ``tuple`` of size 1 that contains (in that order):
        - #hipSuccess, #hipErrorInvalidValue, hipInvalidDevice
    """
    _hipLaunchKernel__retval = hipError_t(chip.hipLaunchKernel(
        <const void *>hip._util.types.DataHandle.from_pyobj(function_address)._ptr,
        dim3.from_pyobj(numBlocks)._ptr[0],
        dim3.from_pyobj(dimBlocks)._ptr[0],
        <void **>hip._util.types.DataHandle.from_pyobj(args)._ptr,sharedMemBytes,
        ihipStream_t.from_pyobj(stream)._ptr))    # fully specified
    return (_hipLaunchKernel__retval,)


@cython.embedsignature(True)
def hipLaunchHostFunc(object stream, object fn, object userData):
    r"""Enqueues a host function call in a stream.

    Warning:
        This API is marked as beta, meaning, while this is feature complete,
        it is still open to changes and may have outstanding issues.

    Args:
        stream: **[in]**  stream to enqueue work to.

        fn: **[in]**  function to call once operations enqueued preceeding are complete.

        userData: **[in]**  User-specified data to be passed to the function.

    Returns:
        A ``tuple`` of size 1 that contains (in that order):
        - #hipSuccess, #hipErrorInvalidResourceHandle, #hipErrorInvalidValue,
            #hipErrorNotSupported
    """
    _hipLaunchHostFunc__retval = hipError_t(chip.hipLaunchHostFunc(
        ihipStream_t.from_pyobj(stream)._ptr,
        hipHostFn_t.from_pyobj(fn)._ptr,
        <void *>hip._util.types.DataHandle.from_pyobj(userData)._ptr))    # fully specified
    return (_hipLaunchHostFunc__retval,)


@cython.embedsignature(True)
def hipDrvMemcpy2DUnaligned(object pCopy):
    r"""(No short description)

    Copies memory for 2D arrays.

    Args:
        pCopy:  Parameters for the memory copy

    Returns:
        A ``tuple`` of size 1 that contains (in that order):
        - #hipSuccess, #hipErrorInvalidValue
    """
    _hipDrvMemcpy2DUnaligned__retval = hipError_t(chip.hipDrvMemcpy2DUnaligned(
        hip_Memcpy2D.from_pyobj(pCopy)._ptr))    # fully specified
    return (_hipDrvMemcpy2DUnaligned__retval,)


@cython.embedsignature(True)
def hipExtLaunchKernel(object function_address, object numBlocks, object dimBlocks, object args, unsigned long sharedMemBytes, object stream, object startEvent, object stopEvent, int flags):
    r"""Launches kernel from the pointer address, with arguments and shared memory on stream.

    Args:
        function_address: **[in]** pointer to the Kernel to launch.

        numBlocks: **[in]** number of blocks.

        dimBlocks: **[in]** dimension of a block.

        args: **[in]** pointer to kernel arguments.

        sharedMemBytes: **[in]** Amount of dynamic shared memory to allocate for this kernel.
            HIP-Clang compiler provides support for extern shared declarations.

        stream: **[in]** Stream where the kernel should be dispatched.

        startEvent: **[in]** If non-null, specified event will be updated to track the start time of
            the kernel launch. The event must be created before calling this API.

        stopEvent: **[in]** If non-null, specified event will be updated to track the stop time of
            the kernel launch. The event must be created before calling this API.
            May be 0, in which case the default stream is used with associated synchronization rules.

        flags: **[in]** . The value of hipExtAnyOrderLaunch, signifies if kernel can be
            launched in any order.

    Returns:
        A ``tuple`` of size 1 that contains (in that order):
        - hipSuccess, hipInvalidDevice, hipErrorNotInitialized, hipErrorInvalidValue.
    """
    _hipExtLaunchKernel__retval = hipError_t(chip.hipExtLaunchKernel(
        <const void *>hip._util.types.DataHandle.from_pyobj(function_address)._ptr,
        dim3.from_pyobj(numBlocks)._ptr[0],
        dim3.from_pyobj(dimBlocks)._ptr[0],
        <void **>hip._util.types.DataHandle.from_pyobj(args)._ptr,sharedMemBytes,
        ihipStream_t.from_pyobj(stream)._ptr,
        ihipEvent_t.from_pyobj(startEvent)._ptr,
        ihipEvent_t.from_pyobj(stopEvent)._ptr,flags))    # fully specified
    return (_hipExtLaunchKernel__retval,)


@cython.embedsignature(True)
def hipBindTextureToMipmappedArray(object tex, object mipmappedArray, object desc):
    r"""Binds a mipmapped array to a texture.

    Args:
        tex: **[in]** pointer to the texture reference to bind

        mipmappedArray: **[in]** memory mipmapped array on the device

        desc: **[in]** opointer to the channel format

    Returns:
        A ``tuple`` of size 1 that contains (in that order):
        - hipSuccess, hipErrorInvalidValue
    """
    _hipBindTextureToMipmappedArray__retval = hipError_t(chip.hipBindTextureToMipmappedArray(
        textureReference.from_pyobj(tex)._ptr,
        hipMipmappedArray.from_pyobj(mipmappedArray)._ptr,
        hipChannelFormatDesc.from_pyobj(desc)._ptr))    # fully specified
    return (_hipBindTextureToMipmappedArray__retval,)


@cython.embedsignature(True)
def hipCreateTextureObject(object pResDesc, object pTexDesc, object pResViewDesc):
    r"""Creates a texture object.

    Note:
        3D liner filter isn't supported on GFX90A boards, on which the API ``hipCreateTextureObject`` will
        return hipErrorNotSupported.

    Args:
        pResDesc: **[in]** pointer to resource descriptor

        pTexDesc: **[in]** pointer to texture descriptor

        pResViewDesc: **[in]** pointer to resource view descriptor

    Returns:
        A ``tuple`` of size 2 that contains (in that order):
        - hipSuccess, hipErrorInvalidValue, hipErrorNotSupported, hipErrorOutOfMemory
        - pTexObject: pointer to the texture object to create
    """
    pTexObject = __hip_texture.from_ptr(NULL)
    _hipCreateTextureObject__retval = hipError_t(chip.hipCreateTextureObject(&pTexObject._ptr,
        hipResourceDesc.from_pyobj(pResDesc)._ptr,
        hipTextureDesc.from_pyobj(pTexDesc)._ptr,
        hipResourceViewDesc.from_pyobj(pResViewDesc)._ptr))    # fully specified
    return (_hipCreateTextureObject__retval,pTexObject)


@cython.embedsignature(True)
def hipDestroyTextureObject(object textureObject):
    r"""Destroys a texture object.

    Args:
        textureObject: **[in]** texture object to destroy

    Returns:
        A ``tuple`` of size 1 that contains (in that order):
        - hipSuccess, hipErrorInvalidValue
    """
    _hipDestroyTextureObject__retval = hipError_t(chip.hipDestroyTextureObject(
        __hip_texture.from_pyobj(textureObject)._ptr))    # fully specified
    return (_hipDestroyTextureObject__retval,)


@cython.embedsignature(True)
def hipGetChannelDesc(object desc, object array):
    r"""Gets the channel descriptor in an array.

    Args:
        desc: **[in]** pointer to channel format descriptor

        array: **[out]** memory array on the device

    Returns:
        A ``tuple`` of size 1 that contains (in that order):
        - hipSuccess, hipErrorInvalidValue
    """
    _hipGetChannelDesc__retval = hipError_t(chip.hipGetChannelDesc(
        hipChannelFormatDesc.from_pyobj(desc)._ptr,
        hipArray.from_pyobj(array)._ptr))    # fully specified
    return (_hipGetChannelDesc__retval,)


@cython.embedsignature(True)
def hipGetTextureObjectResourceDesc(object pResDesc, object textureObject):
    r"""Gets resource descriptor for the texture object.

    Args:
        pResDesc: **[out]** pointer to resource descriptor

        textureObject: **[in]** texture object

    Returns:
        A ``tuple`` of size 1 that contains (in that order):
        - hipSuccess, hipErrorInvalidValue
    """
    _hipGetTextureObjectResourceDesc__retval = hipError_t(chip.hipGetTextureObjectResourceDesc(
        hipResourceDesc.from_pyobj(pResDesc)._ptr,
        __hip_texture.from_pyobj(textureObject)._ptr))    # fully specified
    return (_hipGetTextureObjectResourceDesc__retval,)


@cython.embedsignature(True)
def hipGetTextureObjectResourceViewDesc(object pResViewDesc, object textureObject):
    r"""Gets resource view descriptor for the texture object.

    Args:
        pResViewDesc: **[out]** pointer to resource view descriptor

        textureObject: **[in]** texture object

    Returns:
        A ``tuple`` of size 1 that contains (in that order):
        - hipSuccess, hipErrorInvalidValue
    """
    _hipGetTextureObjectResourceViewDesc__retval = hipError_t(chip.hipGetTextureObjectResourceViewDesc(
        hipResourceViewDesc.from_pyobj(pResViewDesc)._ptr,
        __hip_texture.from_pyobj(textureObject)._ptr))    # fully specified
    return (_hipGetTextureObjectResourceViewDesc__retval,)


@cython.embedsignature(True)
def hipGetTextureObjectTextureDesc(object pTexDesc, object textureObject):
    r"""Gets texture descriptor for the texture object.

    Args:
        pTexDesc: **[out]** pointer to texture descriptor

        textureObject: **[in]** texture object

    Returns:
        A ``tuple`` of size 1 that contains (in that order):
        - hipSuccess, hipErrorInvalidValue
    """
    _hipGetTextureObjectTextureDesc__retval = hipError_t(chip.hipGetTextureObjectTextureDesc(
        hipTextureDesc.from_pyobj(pTexDesc)._ptr,
        __hip_texture.from_pyobj(textureObject)._ptr))    # fully specified
    return (_hipGetTextureObjectTextureDesc__retval,)


@cython.embedsignature(True)
def hipTexObjectCreate(object pResDesc, object pTexDesc, object pResViewDesc):
    r"""Creates a texture object.

    Args:
        pResDesc: **[in]** pointer to resource descriptor

        pTexDesc: **[in]** pointer to texture descriptor

        pResViewDesc: **[in]** pointer to resource view descriptor

    Returns:
        A ``tuple`` of size 2 that contains (in that order):
        - hipSuccess, hipErrorInvalidValue
        - pTexObject: pointer to texture object to create
    """
    pTexObject = __hip_texture.from_ptr(NULL)
    _hipTexObjectCreate__retval = hipError_t(chip.hipTexObjectCreate(&pTexObject._ptr,
        HIP_RESOURCE_DESC_st.from_pyobj(pResDesc)._ptr,
        HIP_TEXTURE_DESC_st.from_pyobj(pTexDesc)._ptr,
        HIP_RESOURCE_VIEW_DESC_st.from_pyobj(pResViewDesc)._ptr))    # fully specified
    return (_hipTexObjectCreate__retval,pTexObject)


@cython.embedsignature(True)
def hipTexObjectDestroy(object texObject):
    r"""Destroys a texture object.

    Args:
        texObject: **[in]** texture object to destroy

    Returns:
        A ``tuple`` of size 1 that contains (in that order):
        - hipSuccess, hipErrorInvalidValue
    """
    _hipTexObjectDestroy__retval = hipError_t(chip.hipTexObjectDestroy(
        __hip_texture.from_pyobj(texObject)._ptr))    # fully specified
    return (_hipTexObjectDestroy__retval,)


@cython.embedsignature(True)
def hipTexObjectGetResourceDesc(object pResDesc, object texObject):
    r"""Gets resource descriptor of a texture object.

    Args:
        pResDesc: **[out]** pointer to resource descriptor

        texObject: **[in]** texture object

    Returns:
        A ``tuple`` of size 1 that contains (in that order):
        - hipSuccess, hipErrorNotSupported, hipErrorInvalidValue
    """
    _hipTexObjectGetResourceDesc__retval = hipError_t(chip.hipTexObjectGetResourceDesc(
        HIP_RESOURCE_DESC_st.from_pyobj(pResDesc)._ptr,
        __hip_texture.from_pyobj(texObject)._ptr))    # fully specified
    return (_hipTexObjectGetResourceDesc__retval,)


@cython.embedsignature(True)
def hipTexObjectGetResourceViewDesc(object pResViewDesc, object texObject):
    r"""Gets resource view descriptor of a texture object.

    Args:
        pResViewDesc: **[out]** pointer to resource view descriptor

        texObject: **[in]** texture object

    Returns:
        A ``tuple`` of size 1 that contains (in that order):
        - hipSuccess, hipErrorNotSupported, hipErrorInvalidValue
    """
    _hipTexObjectGetResourceViewDesc__retval = hipError_t(chip.hipTexObjectGetResourceViewDesc(
        HIP_RESOURCE_VIEW_DESC_st.from_pyobj(pResViewDesc)._ptr,
        __hip_texture.from_pyobj(texObject)._ptr))    # fully specified
    return (_hipTexObjectGetResourceViewDesc__retval,)


@cython.embedsignature(True)
def hipTexObjectGetTextureDesc(object pTexDesc, object texObject):
    r"""Gets texture descriptor of a texture object.

    Args:
        pTexDesc: **[out]** pointer to texture descriptor

        texObject: **[in]** texture object

    Returns:
        A ``tuple`` of size 1 that contains (in that order):
        - hipSuccess, hipErrorNotSupported, hipErrorInvalidValue
    """
    _hipTexObjectGetTextureDesc__retval = hipError_t(chip.hipTexObjectGetTextureDesc(
        HIP_TEXTURE_DESC_st.from_pyobj(pTexDesc)._ptr,
        __hip_texture.from_pyobj(texObject)._ptr))    # fully specified
    return (_hipTexObjectGetTextureDesc__retval,)


@cython.embedsignature(True)
def hipGetTextureReference(object symbol):
    r"""Gets the texture reference related with the symbol.

    Args:
        symbol: **[in]** pointer to the symbol related with the texture for the reference

    Returns:
        A ``tuple`` of size 2 that contains (in that order):
        - hipSuccess, hipErrorInvalidValue
        - texref: texture reference
    """
    texref = textureReference.from_ptr(NULL)
    _hipGetTextureReference__retval = hipError_t(chip.hipGetTextureReference(&texref._ptr,
        <const void *>hip._util.types.DataHandle.from_pyobj(symbol)._ptr))    # fully specified
    return (_hipGetTextureReference__retval,texref)


@cython.embedsignature(True)
def hipTexRefSetAddressMode(object texRef, int dim, object am):
    r"""(No short description)
    """
    if not isinstance(am,_hipTextureAddressMode__Base):
        raise TypeError("argument 'am' must be of type '_hipTextureAddressMode__Base'")
    _hipTexRefSetAddressMode__retval = hipError_t(chip.hipTexRefSetAddressMode(
        textureReference.from_pyobj(texRef)._ptr,dim,am.value))    # fully specified
    return (_hipTexRefSetAddressMode__retval,)


@cython.embedsignature(True)
def hipTexRefSetArray(object tex, object array, unsigned int flags):
    r"""(No short description)
    """
    _hipTexRefSetArray__retval = hipError_t(chip.hipTexRefSetArray(
        textureReference.from_pyobj(tex)._ptr,
        hipArray.from_pyobj(array)._ptr,flags))    # fully specified
    return (_hipTexRefSetArray__retval,)


@cython.embedsignature(True)
def hipTexRefSetFilterMode(object texRef, object fm):
    r"""(No short description)
    """
    if not isinstance(fm,_hipTextureFilterMode__Base):
        raise TypeError("argument 'fm' must be of type '_hipTextureFilterMode__Base'")
    _hipTexRefSetFilterMode__retval = hipError_t(chip.hipTexRefSetFilterMode(
        textureReference.from_pyobj(texRef)._ptr,fm.value))    # fully specified
    return (_hipTexRefSetFilterMode__retval,)


@cython.embedsignature(True)
def hipTexRefSetFlags(object texRef, unsigned int Flags):
    r"""(No short description)
    """
    _hipTexRefSetFlags__retval = hipError_t(chip.hipTexRefSetFlags(
        textureReference.from_pyobj(texRef)._ptr,Flags))    # fully specified
    return (_hipTexRefSetFlags__retval,)


@cython.embedsignature(True)
def hipTexRefSetFormat(object texRef, object fmt, int NumPackedComponents):
    r"""(No short description)
    """
    if not isinstance(fmt,_hipArray_Format__Base):
        raise TypeError("argument 'fmt' must be of type '_hipArray_Format__Base'")
    _hipTexRefSetFormat__retval = hipError_t(chip.hipTexRefSetFormat(
        textureReference.from_pyobj(texRef)._ptr,fmt.value,NumPackedComponents))    # fully specified
    return (_hipTexRefSetFormat__retval,)


@cython.embedsignature(True)
def hipBindTexture(object tex, object devPtr, object desc, unsigned long size):
    r"""(No short description)
    """
    cdef unsigned long offset
    _hipBindTexture__retval = hipError_t(chip.hipBindTexture(&offset,
        textureReference.from_pyobj(tex)._ptr,
        <const void *>hip._util.types.DataHandle.from_pyobj(devPtr)._ptr,
        hipChannelFormatDesc.from_pyobj(desc)._ptr,size))    # fully specified
    return (_hipBindTexture__retval,offset)


@cython.embedsignature(True)
def hipBindTexture2D(object tex, object devPtr, object desc, unsigned long width, unsigned long height, unsigned long pitch):
    r"""(No short description)
    """
    cdef unsigned long offset
    _hipBindTexture2D__retval = hipError_t(chip.hipBindTexture2D(&offset,
        textureReference.from_pyobj(tex)._ptr,
        <const void *>hip._util.types.DataHandle.from_pyobj(devPtr)._ptr,
        hipChannelFormatDesc.from_pyobj(desc)._ptr,width,height,pitch))    # fully specified
    return (_hipBindTexture2D__retval,offset)


@cython.embedsignature(True)
def hipBindTextureToArray(object tex, object array, object desc):
    r"""(No short description)
    """
    _hipBindTextureToArray__retval = hipError_t(chip.hipBindTextureToArray(
        textureReference.from_pyobj(tex)._ptr,
        hipArray.from_pyobj(array)._ptr,
        hipChannelFormatDesc.from_pyobj(desc)._ptr))    # fully specified
    return (_hipBindTextureToArray__retval,)


@cython.embedsignature(True)
def hipGetTextureAlignmentOffset(object texref):
    r"""(No short description)
    """
    cdef unsigned long offset
    _hipGetTextureAlignmentOffset__retval = hipError_t(chip.hipGetTextureAlignmentOffset(&offset,
        textureReference.from_pyobj(texref)._ptr))    # fully specified
    return (_hipGetTextureAlignmentOffset__retval,offset)


@cython.embedsignature(True)
def hipUnbindTexture(object tex):
    r"""(No short description)
    """
    _hipUnbindTexture__retval = hipError_t(chip.hipUnbindTexture(
        textureReference.from_pyobj(tex)._ptr))    # fully specified
    return (_hipUnbindTexture__retval,)


@cython.embedsignature(True)
def hipTexRefGetAddress(object texRef):
    r"""(No short description)
    """
    dev_ptr = hip._util.types.DataHandle.from_ptr(NULL)
    _hipTexRefGetAddress__retval = hipError_t(chip.hipTexRefGetAddress(
        <void **>&dev_ptr._ptr,
        textureReference.from_pyobj(texRef)._ptr))    # fully specified
    return (_hipTexRefGetAddress__retval,dev_ptr)


@cython.embedsignature(True)
def hipTexRefGetAddressMode(object texRef, int dim):
    r"""(No short description)
    """
    cdef chip.hipTextureAddressMode pam
    _hipTexRefGetAddressMode__retval = hipError_t(chip.hipTexRefGetAddressMode(&pam,
        textureReference.from_pyobj(texRef)._ptr,dim))    # fully specified
    return (_hipTexRefGetAddressMode__retval,hipTextureAddressMode(pam))


@cython.embedsignature(True)
def hipTexRefGetFilterMode(object texRef):
    r"""(No short description)
    """
    cdef chip.hipTextureFilterMode pfm
    _hipTexRefGetFilterMode__retval = hipError_t(chip.hipTexRefGetFilterMode(&pfm,
        textureReference.from_pyobj(texRef)._ptr))    # fully specified
    return (_hipTexRefGetFilterMode__retval,hipTextureFilterMode(pfm))


@cython.embedsignature(True)
def hipTexRefGetFlags(object texRef):
    r"""(No short description)
    """
    cdef unsigned int pFlags
    _hipTexRefGetFlags__retval = hipError_t(chip.hipTexRefGetFlags(&pFlags,
        textureReference.from_pyobj(texRef)._ptr))    # fully specified
    return (_hipTexRefGetFlags__retval,pFlags)


@cython.embedsignature(True)
def hipTexRefGetFormat(object texRef):
    r"""(No short description)
    """
    cdef chip.hipArray_Format pFormat
    cdef int pNumChannels
    _hipTexRefGetFormat__retval = hipError_t(chip.hipTexRefGetFormat(&pFormat,&pNumChannels,
        textureReference.from_pyobj(texRef)._ptr))    # fully specified
    return (_hipTexRefGetFormat__retval,hipArray_Format(pFormat),pNumChannels)


@cython.embedsignature(True)
def hipTexRefGetMaxAnisotropy(object texRef):
    r"""(No short description)
    """
    cdef int pmaxAnsio
    _hipTexRefGetMaxAnisotropy__retval = hipError_t(chip.hipTexRefGetMaxAnisotropy(&pmaxAnsio,
        textureReference.from_pyobj(texRef)._ptr))    # fully specified
    return (_hipTexRefGetMaxAnisotropy__retval,pmaxAnsio)


@cython.embedsignature(True)
def hipTexRefGetMipmapFilterMode(object texRef):
    r"""(No short description)
    """
    cdef chip.hipTextureFilterMode pfm
    _hipTexRefGetMipmapFilterMode__retval = hipError_t(chip.hipTexRefGetMipmapFilterMode(&pfm,
        textureReference.from_pyobj(texRef)._ptr))    # fully specified
    return (_hipTexRefGetMipmapFilterMode__retval,hipTextureFilterMode(pfm))


@cython.embedsignature(True)
def hipTexRefGetMipmapLevelBias(object texRef):
    r"""(No short description)
    """
    cdef float pbias
    _hipTexRefGetMipmapLevelBias__retval = hipError_t(chip.hipTexRefGetMipmapLevelBias(&pbias,
        textureReference.from_pyobj(texRef)._ptr))    # fully specified
    return (_hipTexRefGetMipmapLevelBias__retval,pbias)


@cython.embedsignature(True)
def hipTexRefGetMipmapLevelClamp(object texRef):
    r"""(No short description)
    """
    cdef float pminMipmapLevelClamp
    cdef float pmaxMipmapLevelClamp
    _hipTexRefGetMipmapLevelClamp__retval = hipError_t(chip.hipTexRefGetMipmapLevelClamp(&pminMipmapLevelClamp,&pmaxMipmapLevelClamp,
        textureReference.from_pyobj(texRef)._ptr))    # fully specified
    return (_hipTexRefGetMipmapLevelClamp__retval,pminMipmapLevelClamp,pmaxMipmapLevelClamp)


@cython.embedsignature(True)
def hipTexRefGetMipMappedArray(object texRef):
    r"""(No short description)
    """
    pArray = hipMipmappedArray.from_ptr(NULL)
    _hipTexRefGetMipMappedArray__retval = hipError_t(chip.hipTexRefGetMipMappedArray(&pArray._ptr,
        textureReference.from_pyobj(texRef)._ptr))    # fully specified
    return (_hipTexRefGetMipMappedArray__retval,pArray)


@cython.embedsignature(True)
def hipTexRefSetAddress(object texRef, object dptr, unsigned long bytes):
    r"""(No short description)
    """
    cdef unsigned long ByteOffset
    _hipTexRefSetAddress__retval = hipError_t(chip.hipTexRefSetAddress(&ByteOffset,
        textureReference.from_pyobj(texRef)._ptr,
        <void *>hip._util.types.DataHandle.from_pyobj(dptr)._ptr,bytes))    # fully specified
    return (_hipTexRefSetAddress__retval,ByteOffset)


@cython.embedsignature(True)
def hipTexRefSetAddress2D(object texRef, object desc, object dptr, unsigned long Pitch):
    r"""(No short description)
    """
    _hipTexRefSetAddress2D__retval = hipError_t(chip.hipTexRefSetAddress2D(
        textureReference.from_pyobj(texRef)._ptr,
        HIP_ARRAY_DESCRIPTOR.from_pyobj(desc)._ptr,
        <void *>hip._util.types.DataHandle.from_pyobj(dptr)._ptr,Pitch))    # fully specified
    return (_hipTexRefSetAddress2D__retval,)


@cython.embedsignature(True)
def hipTexRefSetMaxAnisotropy(object texRef, unsigned int maxAniso):
    r"""(No short description)
    """
    _hipTexRefSetMaxAnisotropy__retval = hipError_t(chip.hipTexRefSetMaxAnisotropy(
        textureReference.from_pyobj(texRef)._ptr,maxAniso))    # fully specified
    return (_hipTexRefSetMaxAnisotropy__retval,)


@cython.embedsignature(True)
def hipTexRefSetBorderColor(object texRef):
    r"""(No short description)
    """
    cdef float pBorderColor
    _hipTexRefSetBorderColor__retval = hipError_t(chip.hipTexRefSetBorderColor(
        textureReference.from_pyobj(texRef)._ptr,&pBorderColor))    # fully specified
    return (_hipTexRefSetBorderColor__retval,pBorderColor)


@cython.embedsignature(True)
def hipTexRefSetMipmapFilterMode(object texRef, object fm):
    r"""(No short description)
    """
    if not isinstance(fm,_hipTextureFilterMode__Base):
        raise TypeError("argument 'fm' must be of type '_hipTextureFilterMode__Base'")
    _hipTexRefSetMipmapFilterMode__retval = hipError_t(chip.hipTexRefSetMipmapFilterMode(
        textureReference.from_pyobj(texRef)._ptr,fm.value))    # fully specified
    return (_hipTexRefSetMipmapFilterMode__retval,)


@cython.embedsignature(True)
def hipTexRefSetMipmapLevelBias(object texRef, float bias):
    r"""(No short description)
    """
    _hipTexRefSetMipmapLevelBias__retval = hipError_t(chip.hipTexRefSetMipmapLevelBias(
        textureReference.from_pyobj(texRef)._ptr,bias))    # fully specified
    return (_hipTexRefSetMipmapLevelBias__retval,)


@cython.embedsignature(True)
def hipTexRefSetMipmapLevelClamp(object texRef, float minMipMapLevelClamp, float maxMipMapLevelClamp):
    r"""(No short description)
    """
    _hipTexRefSetMipmapLevelClamp__retval = hipError_t(chip.hipTexRefSetMipmapLevelClamp(
        textureReference.from_pyobj(texRef)._ptr,minMipMapLevelClamp,maxMipMapLevelClamp))    # fully specified
    return (_hipTexRefSetMipmapLevelClamp__retval,)


@cython.embedsignature(True)
def hipTexRefSetMipmappedArray(object texRef, object mipmappedArray, unsigned int Flags):
    r"""(No short description)
    """
    _hipTexRefSetMipmappedArray__retval = hipError_t(chip.hipTexRefSetMipmappedArray(
        textureReference.from_pyobj(texRef)._ptr,
        hipMipmappedArray.from_pyobj(mipmappedArray)._ptr,Flags))    # fully specified
    return (_hipTexRefSetMipmappedArray__retval,)


@cython.embedsignature(True)
def hipMipmappedArrayCreate(object pMipmappedArrayDesc, unsigned int numMipmapLevels):
    r"""(No short description)

    @{

    This section describes the texture management functions currently unsupported in HIP runtime.
    """
    pHandle = hipMipmappedArray.from_ptr(NULL)
    _hipMipmappedArrayCreate__retval = hipError_t(chip.hipMipmappedArrayCreate(&pHandle._ptr,
        HIP_ARRAY3D_DESCRIPTOR.from_pyobj(pMipmappedArrayDesc)._ptr,numMipmapLevels))    # fully specified
    return (_hipMipmappedArrayCreate__retval,pHandle)


@cython.embedsignature(True)
def hipMipmappedArrayDestroy(object hMipmappedArray):
    r"""(No short description)
    """
    _hipMipmappedArrayDestroy__retval = hipError_t(chip.hipMipmappedArrayDestroy(
        hipMipmappedArray.from_pyobj(hMipmappedArray)._ptr))    # fully specified
    return (_hipMipmappedArrayDestroy__retval,)


@cython.embedsignature(True)
def hipMipmappedArrayGetLevel(object hMipMappedArray, unsigned int level):
    r"""(No short description)
    """
    pLevelArray = hipArray.from_ptr(NULL)
    _hipMipmappedArrayGetLevel__retval = hipError_t(chip.hipMipmappedArrayGetLevel(&pLevelArray._ptr,
        hipMipmappedArray.from_pyobj(hMipMappedArray)._ptr,level))    # fully specified
    return (_hipMipmappedArrayGetLevel__retval,pLevelArray)


@cython.embedsignature(True)
def hipApiName(unsigned int id):
    r"""(No short description)

    @{
    This section describes the callback/Activity of HIP runtime API.
    """
    cdef const char * _hipApiName__retval = chip.hipApiName(id)    # fully specified
    return (_hipApiName__retval,)


@cython.embedsignature(True)
def hipKernelNameRef(object f):
    r"""(No short description)
    """
    cdef const char * _hipKernelNameRef__retval = chip.hipKernelNameRef(
        ihipModuleSymbol_t.from_pyobj(f)._ptr)    # fully specified
    return (_hipKernelNameRef__retval,)


@cython.embedsignature(True)
def hipKernelNameRefByPtr(object hostFunction, object stream):
    r"""(No short description)
    """
    cdef const char * _hipKernelNameRefByPtr__retval = chip.hipKernelNameRefByPtr(
        <const void *>hip._util.types.DataHandle.from_pyobj(hostFunction)._ptr,
        ihipStream_t.from_pyobj(stream)._ptr)    # fully specified
    return (_hipKernelNameRefByPtr__retval,)


@cython.embedsignature(True)
def hipGetStreamDeviceId(object stream):
    r"""(No short description)
    """
    cdef int _hipGetStreamDeviceId__retval = chip.hipGetStreamDeviceId(
        ihipStream_t.from_pyobj(stream)._ptr)    # fully specified
    return (_hipGetStreamDeviceId__retval,)


@cython.embedsignature(True)
def hipStreamBeginCapture(object stream, object mode):
    r"""Begins graph capture on a stream.

    Warning:
        This API is marked as beta, meaning, while this is feature complete,
        it is still open to changes and may have outstanding issues.

    Args:
        stream: **[in]**  Stream to initiate capture.

        mode: **[in]**  Controls the interaction of this capture sequence with other API calls that
            are not safe.

    Returns:
        A ``tuple`` of size 1 that contains (in that order):
        - #hipSuccess, #hipErrorInvalidValue
    """
    if not isinstance(mode,_hipStreamCaptureMode__Base):
        raise TypeError("argument 'mode' must be of type '_hipStreamCaptureMode__Base'")
    _hipStreamBeginCapture__retval = hipError_t(chip.hipStreamBeginCapture(
        ihipStream_t.from_pyobj(stream)._ptr,mode.value))    # fully specified
    return (_hipStreamBeginCapture__retval,)


@cython.embedsignature(True)
def hipStreamEndCapture(object stream):
    r"""Ends capture on a stream, returning the captured graph.

    Warning:
        This API is marked as beta, meaning, while this is feature complete,
        it is still open to changes and may have outstanding issues.

    Args:
        stream: **[in]**  Stream to end capture.

    Returns:
        A ``tuple`` of size 2 that contains (in that order):
        - #hipSuccess, #hipErrorInvalidValue
        - pGraph:  returns the graph captured.
    """
    pGraph = ihipGraph.from_ptr(NULL)
    _hipStreamEndCapture__retval = hipError_t(chip.hipStreamEndCapture(
        ihipStream_t.from_pyobj(stream)._ptr,&pGraph._ptr))    # fully specified
    return (_hipStreamEndCapture__retval,pGraph)


@cython.embedsignature(True)
def hipStreamGetCaptureInfo(object stream):
    r"""Get capture status of a stream.

    Warning:
        This API is marked as beta, meaning, while this is feature complete,
        it is still open to changes and may have outstanding issues.

    Args:
        stream: **[in]**  Stream under capture.

    Returns:
        A ``tuple`` of size 3 that contains (in that order):
        - #hipSuccess, #hipErrorStreamCaptureImplicit
        - pCaptureStatus:  returns current status of the capture.
        - pId:  unique ID of the capture.
    """
    cdef chip.hipStreamCaptureStatus pCaptureStatus
    cdef unsigned long long pId
    _hipStreamGetCaptureInfo__retval = hipError_t(chip.hipStreamGetCaptureInfo(
        ihipStream_t.from_pyobj(stream)._ptr,&pCaptureStatus,&pId))    # fully specified
    return (_hipStreamGetCaptureInfo__retval,hipStreamCaptureStatus(pCaptureStatus),pId)


@cython.embedsignature(True)
def hipStreamGetCaptureInfo_v2(object stream, object dependencies_out):
    r"""Get stream's capture state

    Warning:
        This API is marked as beta, meaning, while this is feature complete,
        it is still open to changes and may have outstanding issues.

    Args:
        stream: **[in]**  Stream under capture.

        dependencies_out: **[out]**  returns pointer to an array of nodes.

    Returns:
        A ``tuple`` of size 5 that contains (in that order):
        - #hipSuccess, #hipErrorInvalidValue, #hipErrorStreamCaptureImplicit
        - captureStatus_out:  returns current status of the capture.
        - id_out:  unique ID of the capture.
        - graph_out:  returns the graph being captured into.
        - numDependencies_out:  returns size of the array returned in dependencies_out.
    """
    cdef chip.hipStreamCaptureStatus captureStatus_out
    cdef unsigned long long id_out
    graph_out = ihipGraph.from_ptr(NULL)
    cdef unsigned long numDependencies_out
    _hipStreamGetCaptureInfo_v2__retval = hipError_t(chip.hipStreamGetCaptureInfo_v2(
        ihipStream_t.from_pyobj(stream)._ptr,&captureStatus_out,&id_out,&graph_out._ptr,
        <chip.hipGraphNode_t **>hip._util.types.DataHandle.from_pyobj(dependencies_out)._ptr,&numDependencies_out))    # fully specified
    return (_hipStreamGetCaptureInfo_v2__retval,hipStreamCaptureStatus(captureStatus_out),id_out,graph_out,numDependencies_out)


@cython.embedsignature(True)
def hipStreamIsCapturing(object stream):
    r"""Get stream's capture state

    Warning:
        This API is marked as beta, meaning, while this is feature complete,
        it is still open to changes and may have outstanding issues.

    Args:
        stream: **[in]**  Stream under capture.

    Returns:
        A ``tuple`` of size 2 that contains (in that order):
        - #hipSuccess, #hipErrorInvalidValue, #hipErrorStreamCaptureImplicit
        - pCaptureStatus:  returns current status of the capture.
    """
    cdef chip.hipStreamCaptureStatus pCaptureStatus
    _hipStreamIsCapturing__retval = hipError_t(chip.hipStreamIsCapturing(
        ihipStream_t.from_pyobj(stream)._ptr,&pCaptureStatus))    # fully specified
    return (_hipStreamIsCapturing__retval,hipStreamCaptureStatus(pCaptureStatus))


@cython.embedsignature(True)
def hipStreamUpdateCaptureDependencies(object stream, unsigned long numDependencies, unsigned int flags):
    r"""Update the set of dependencies in a capturing stream

    Warning:
        This API is marked as beta, meaning, while this is feature complete,
        it is still open to changes and may have outstanding issues.

    Args:
        stream: **[in]**  Stream under capture.

        numDependencies: **[in]**  size of the array in dependencies.

    Returns:
        A ``tuple`` of size 2 that contains (in that order):
        - #hipSuccess, #hipErrorInvalidValue, #hipErrorIllegalState
        - dependencies:  pointer to an array of nodes to Add/Replace.
    """
    dependencies = hipGraphNode.from_ptr(NULL)
    _hipStreamUpdateCaptureDependencies__retval = hipError_t(chip.hipStreamUpdateCaptureDependencies(
        ihipStream_t.from_pyobj(stream)._ptr,&dependencies._ptr,numDependencies,flags))    # fully specified
    return (_hipStreamUpdateCaptureDependencies__retval,dependencies)


@cython.embedsignature(True)
def hipThreadExchangeStreamCaptureMode():
    r"""Swaps the stream capture mode of a thread.

    Warning:
        This API is marked as beta, meaning, while this is feature complete,
        it is still open to changes and may have outstanding issues.

    Returns:
        A ``tuple`` of size 2 that contains (in that order):
        - #hipSuccess, #hipErrorInvalidValue
        - mode:  Pointer to mode value to swap with the current mode
    """
    cdef chip.hipStreamCaptureMode mode
    _hipThreadExchangeStreamCaptureMode__retval = hipError_t(chip.hipThreadExchangeStreamCaptureMode(&mode))    # fully specified
    return (_hipThreadExchangeStreamCaptureMode__retval,hipStreamCaptureMode(mode))


@cython.embedsignature(True)
def hipGraphCreate(unsigned int flags):
    r"""Creates a graph

    Warning:
        This API is marked as beta, meaning, while this is feature complete,
        it is still open to changes and may have outstanding issues.

    Args:
        flags: **[in]**  flags for graph creation, must be 0.

    Returns:
        A ``tuple`` of size 2 that contains (in that order):
        - #hipSuccess, #hipErrorInvalidValue, #hipErrorMemoryAllocation
        - pGraph:  pointer to graph to create.
    """
    pGraph = ihipGraph.from_ptr(NULL)
    _hipGraphCreate__retval = hipError_t(chip.hipGraphCreate(&pGraph._ptr,flags))    # fully specified
    return (_hipGraphCreate__retval,pGraph)


@cython.embedsignature(True)
def hipGraphDestroy(object graph):
    r"""Destroys a graph

    Warning:
        This API is marked as beta, meaning, while this is feature complete,
        it is still open to changes and may have outstanding issues.

    Args:
        graph: **[in]**  instance of graph to destroy.

    Returns:
        A ``tuple`` of size 1 that contains (in that order):
        - #hipSuccess, #hipErrorInvalidValue
    """
    _hipGraphDestroy__retval = hipError_t(chip.hipGraphDestroy(
        ihipGraph.from_pyobj(graph)._ptr))    # fully specified
    return (_hipGraphDestroy__retval,)


@cython.embedsignature(True)
def hipGraphAddDependencies(object graph, unsigned long numDependencies):
    r"""Adds dependency edges to a graph.

    Warning:
        This API is marked as beta, meaning, while this is feature complete,
        it is still open to changes and may have outstanding issues.

    Args:
        graph: **[in]**  instance of the graph to add dependencies.

        numDependencies: **[in]**  the number of dependencies to add.

    Returns:
        A ``tuple`` of size 3 that contains (in that order):
        - #hipSuccess, #hipErrorInvalidValue
        - from_:  pointer to the graph nodes with dependenties to add from.
        - to:  pointer to the graph nodes to add dependenties to.
    """
    from_ = hipGraphNode.from_ptr(NULL)
    to = hipGraphNode.from_ptr(NULL)
    _hipGraphAddDependencies__retval = hipError_t(chip.hipGraphAddDependencies(
        ihipGraph.from_pyobj(graph)._ptr,&from_._ptr,&to._ptr,numDependencies))    # fully specified
    return (_hipGraphAddDependencies__retval,from_,to)


@cython.embedsignature(True)
def hipGraphRemoveDependencies(object graph, unsigned long numDependencies):
    r"""Removes dependency edges from a graph.

    Warning:
        This API is marked as beta, meaning, while this is feature complete,
        it is still open to changes and may have outstanding issues.

    Args:
        graph: **[in]**  instance of the graph to remove dependencies.

        numDependencies: **[in]**  the number of dependencies to remove.

    Returns:
        A ``tuple`` of size 3 that contains (in that order):
        - #hipSuccess, #hipErrorInvalidValue
        - from_:  Array of nodes that provide the dependencies.
        - to:  Array of dependent nodes.
    """
    from_ = hipGraphNode.from_ptr(NULL)
    to = hipGraphNode.from_ptr(NULL)
    _hipGraphRemoveDependencies__retval = hipError_t(chip.hipGraphRemoveDependencies(
        ihipGraph.from_pyobj(graph)._ptr,&from_._ptr,&to._ptr,numDependencies))    # fully specified
    return (_hipGraphRemoveDependencies__retval,from_,to)


@cython.embedsignature(True)
def hipGraphGetEdges(object graph):
    r"""Returns a graph's dependency edges.

    from and to may both be NULL, in which case this function only returns the number of edges in
    numEdges. Otherwise, numEdges entries will be filled in. If numEdges is higher than the actual
    number of edges, the remaining entries in from and to will be set to NULL, and the number of
    edges actually returned will be written to numEdges

    Warning:
        This API is marked as beta, meaning, while this is feature complete,
        it is still open to changes and may have outstanding issues.

    Args:
        graph: **[in]**  instance of the graph to get the edges from.

    Returns:
        A ``tuple`` of size 4 that contains (in that order):
        - #hipSuccess, #hipErrorInvalidValue
        - from_:  pointer to the graph nodes to return edge endpoints.
        - to:  pointer to the graph nodes to return edge endpoints.
        - numEdges:  returns number of edges.
    """
    from_ = hipGraphNode.from_ptr(NULL)
    to = hipGraphNode.from_ptr(NULL)
    cdef unsigned long numEdges
    _hipGraphGetEdges__retval = hipError_t(chip.hipGraphGetEdges(
        ihipGraph.from_pyobj(graph)._ptr,&from_._ptr,&to._ptr,&numEdges))    # fully specified
    return (_hipGraphGetEdges__retval,from_,to,numEdges)


@cython.embedsignature(True)
def hipGraphGetNodes(object graph):
    r"""Returns graph nodes.

    nodes may be NULL, in which case this function will return the number of nodes in numNodes.
    Otherwise, numNodes entries will be filled in. If numNodes is higher than the actual number of
    nodes, the remaining entries in nodes will be set to NULL, and the number of nodes actually
    obtained will be returned in numNodes.

    Warning:
        This API is marked as beta, meaning, while this is feature complete,
        it is still open to changes and may have outstanding issues.

    Args:
        graph: **[in]**  instance of graph to get the nodes.

    Returns:
        A ``tuple`` of size 3 that contains (in that order):
        - #hipSuccess, #hipErrorInvalidValue
        - nodes:  pointer to return the  graph nodes.
        - numNodes:  returns number of graph nodes.
    """
    nodes = hipGraphNode.from_ptr(NULL)
    cdef unsigned long numNodes
    _hipGraphGetNodes__retval = hipError_t(chip.hipGraphGetNodes(
        ihipGraph.from_pyobj(graph)._ptr,&nodes._ptr,&numNodes))    # fully specified
    return (_hipGraphGetNodes__retval,nodes,numNodes)


@cython.embedsignature(True)
def hipGraphGetRootNodes(object graph):
    r"""Returns graph's root nodes.

    pRootNodes may be NULL, in which case this function will return the number of root nodes in
    pNumRootNodes. Otherwise, pNumRootNodes entries will be filled in. If pNumRootNodes is higher
    than the actual number of root nodes, the remaining entries in pRootNodes will be set to NULL,
    and the number of nodes actually obtained will be returned in pNumRootNodes.

    Warning:
        This API is marked as beta, meaning, while this is feature complete,
        it is still open to changes and may have outstanding issues.

    Args:
        graph: **[in]**  instance of the graph to get the nodes.

    Returns:
        A ``tuple`` of size 3 that contains (in that order):
        - #hipSuccess, #hipErrorInvalidValue
        - pRootNodes:  pointer to return the graph's root nodes.
        - pNumRootNodes:  returns the number of graph's root nodes.
    """
    pRootNodes = hipGraphNode.from_ptr(NULL)
    cdef unsigned long pNumRootNodes
    _hipGraphGetRootNodes__retval = hipError_t(chip.hipGraphGetRootNodes(
        ihipGraph.from_pyobj(graph)._ptr,&pRootNodes._ptr,&pNumRootNodes))    # fully specified
    return (_hipGraphGetRootNodes__retval,pRootNodes,pNumRootNodes)


@cython.embedsignature(True)
def hipGraphNodeGetDependencies(object node):
    r"""Returns a node's dependencies.

    pDependencies may be NULL, in which case this function will return the number of dependencies in
    pNumDependencies. Otherwise, pNumDependencies entries will be filled in. If pNumDependencies is
    higher than the actual number of dependencies, the remaining entries in pDependencies will be set
    to NULL, and the number of nodes actually obtained will be returned in pNumDependencies.

    Warning:
        This API is marked as beta, meaning, while this is feature complete,
        it is still open to changes and may have outstanding issues.

    Args:
        node: **[in]**  graph node to get the dependencies from.

    Returns:
        A ``tuple`` of size 3 that contains (in that order):
        - #hipSuccess, #hipErrorInvalidValue
        - pDependencies:  pointer to to return the dependencies.
        - pNumDependencies:   returns the number of graph node dependencies.
    """
    pDependencies = hipGraphNode.from_ptr(NULL)
    cdef unsigned long pNumDependencies
    _hipGraphNodeGetDependencies__retval = hipError_t(chip.hipGraphNodeGetDependencies(
        hipGraphNode.from_pyobj(node)._ptr,&pDependencies._ptr,&pNumDependencies))    # fully specified
    return (_hipGraphNodeGetDependencies__retval,pDependencies,pNumDependencies)


@cython.embedsignature(True)
def hipGraphNodeGetDependentNodes(object node):
    r"""Returns a node's dependent nodes.

    DependentNodes may be NULL, in which case this function will return the number of dependent nodes
    in pNumDependentNodes. Otherwise, pNumDependentNodes entries will be filled in. If
    pNumDependentNodes is higher than the actual number of dependent nodes, the remaining entries in
    pDependentNodes will be set to NULL, and the number of nodes actually obtained will be returned
    in pNumDependentNodes.

    Warning:
        This API is marked as beta, meaning, while this is feature complete,
        it is still open to changes and may have outstanding issues.

    Args:
        node: **[in]**  graph node to get the Dependent nodes from.

    Returns:
        A ``tuple`` of size 3 that contains (in that order):
        - #hipSuccess, #hipErrorInvalidValue
        - pDependentNodes:  pointer to return the graph dependent nodes.
        - pNumDependentNodes:  returns the number of graph node dependent nodes.
    """
    pDependentNodes = hipGraphNode.from_ptr(NULL)
    cdef unsigned long pNumDependentNodes
    _hipGraphNodeGetDependentNodes__retval = hipError_t(chip.hipGraphNodeGetDependentNodes(
        hipGraphNode.from_pyobj(node)._ptr,&pDependentNodes._ptr,&pNumDependentNodes))    # fully specified
    return (_hipGraphNodeGetDependentNodes__retval,pDependentNodes,pNumDependentNodes)


@cython.embedsignature(True)
def hipGraphNodeGetType(object node):
    r"""Returns a node's type.

    Warning:
        This API is marked as beta, meaning, while this is feature complete,
        it is still open to changes and may have outstanding issues.

    Args:
        node: **[in]**  instance of the graph to add dependencies.

    Returns:
        A ``tuple`` of size 2 that contains (in that order):
        - #hipSuccess, #hipErrorInvalidValue
        - pType:  pointer to the return the type
    """
    cdef chip.hipGraphNodeType pType
    _hipGraphNodeGetType__retval = hipError_t(chip.hipGraphNodeGetType(
        hipGraphNode.from_pyobj(node)._ptr,&pType))    # fully specified
    return (_hipGraphNodeGetType__retval,hipGraphNodeType(pType))


@cython.embedsignature(True)
def hipGraphDestroyNode(object node):
    r"""Remove a node from the graph.

    Warning:
        This API is marked as beta, meaning, while this is feature complete,
        it is still open to changes and may have outstanding issues.

    Args:
        node: **[in]**  graph node to remove

    Returns:
        A ``tuple`` of size 1 that contains (in that order):
        - #hipSuccess, #hipErrorInvalidValue
    """
    _hipGraphDestroyNode__retval = hipError_t(chip.hipGraphDestroyNode(
        hipGraphNode.from_pyobj(node)._ptr))    # fully specified
    return (_hipGraphDestroyNode__retval,)


@cython.embedsignature(True)
def hipGraphClone(object originalGraph):
    r"""Clones a graph.

    Warning:
        This API is marked as beta, meaning, while this is feature complete,
        it is still open to changes and may have outstanding issues.

    Args:
        originalGraph: **[in]**  original graph to clone from.

    Returns:
        A ``tuple`` of size 2 that contains (in that order):
        - #hipSuccess, #hipErrorInvalidValue, #hipErrorMemoryAllocation
        - pGraphClone:  Returns newly created cloned graph.
    """
    pGraphClone = ihipGraph.from_ptr(NULL)
    _hipGraphClone__retval = hipError_t(chip.hipGraphClone(&pGraphClone._ptr,
        ihipGraph.from_pyobj(originalGraph)._ptr))    # fully specified
    return (_hipGraphClone__retval,pGraphClone)


@cython.embedsignature(True)
def hipGraphNodeFindInClone(object originalNode, object clonedGraph):
    r"""Finds a cloned version of a node.

    Warning:
        This API is marked as beta, meaning, while this is feature complete,
        it is still open to changes and may have outstanding issues.

    Args:
        originalNode: **[in]**  original node handle.

        clonedGraph: **[in]**  Cloned graph to query.

    Returns:
        A ``tuple`` of size 2 that contains (in that order):
        - #hipSuccess, #hipErrorInvalidValue
        - pNode:  Returns the cloned node.
    """
    pNode = hipGraphNode.from_ptr(NULL)
    _hipGraphNodeFindInClone__retval = hipError_t(chip.hipGraphNodeFindInClone(&pNode._ptr,
        hipGraphNode.from_pyobj(originalNode)._ptr,
        ihipGraph.from_pyobj(clonedGraph)._ptr))    # fully specified
    return (_hipGraphNodeFindInClone__retval,pNode)


@cython.embedsignature(True)
def hipGraphInstantiate(object graph, char * pLogBuffer, unsigned long bufferSize):
    r"""Creates an executable graph from a graph

    Warning:
        This API is marked as beta, meaning, while this is feature complete,
        it is still open to changes and may have outstanding issues.

    Args:
        graph: **[in]**  instance of graph to instantiate.

        pLogBuffer: **[out]**  pointer to log buffer.

        bufferSize: **[out]**  the size of log buffer.

    Returns:
        A ``tuple`` of size 3 that contains (in that order):
        - #hipSuccess, #hipErrorOutOfMemory
        - pGraphExec:  pointer to instantiated executable graph that is created.
        - pErrorNode:  pointer to error node in case error occured in graph instantiation,
                it could modify the correponding node.
    """
    pGraphExec = hipGraphExec.from_ptr(NULL)
    pErrorNode = hipGraphNode.from_ptr(NULL)
    _hipGraphInstantiate__retval = hipError_t(chip.hipGraphInstantiate(&pGraphExec._ptr,
        ihipGraph.from_pyobj(graph)._ptr,&pErrorNode._ptr,pLogBuffer,bufferSize))    # fully specified
    return (_hipGraphInstantiate__retval,pGraphExec,pErrorNode)


@cython.embedsignature(True)
def hipGraphInstantiateWithFlags(object graph, unsigned long long flags):
    r"""Creates an executable graph from a graph.

    Warning:
        This API is marked as beta, meaning, while this is feature complete,
        it is still open to changes and may have outstanding issues.

    Args:
        graph: **[in]**  instance of graph to instantiate.

        flags: **[in]**  Flags to control instantiation.

    Returns:
        A ``tuple`` of size 2 that contains (in that order):
        - #hipSuccess, #hipErrorInvalidValue
        - pGraphExec:  pointer to instantiated executable graph that is created.
    """
    pGraphExec = hipGraphExec.from_ptr(NULL)
    _hipGraphInstantiateWithFlags__retval = hipError_t(chip.hipGraphInstantiateWithFlags(&pGraphExec._ptr,
        ihipGraph.from_pyobj(graph)._ptr,flags))    # fully specified
    return (_hipGraphInstantiateWithFlags__retval,pGraphExec)


@cython.embedsignature(True)
def hipGraphLaunch(object graphExec, object stream):
    r"""launches an executable graph in a stream

    Warning:
        This API is marked as beta, meaning, while this is feature complete,
        it is still open to changes and may have outstanding issues.

    Args:
        graphExec: **[in]**  instance of executable graph to launch.

        stream: **[in]**  instance of stream in which to launch executable graph.

    Returns:
        A ``tuple`` of size 1 that contains (in that order):
        - #hipSuccess, #hipErrorInvalidValue
    """
    _hipGraphLaunch__retval = hipError_t(chip.hipGraphLaunch(
        hipGraphExec.from_pyobj(graphExec)._ptr,
        ihipStream_t.from_pyobj(stream)._ptr))    # fully specified
    return (_hipGraphLaunch__retval,)


@cython.embedsignature(True)
def hipGraphUpload(object graphExec, object stream):
    r"""uploads an executable graph in a stream

    Warning:
        This API is marked as beta, meaning, while this is feature complete,
        it is still open to changes and may have outstanding issues.

    Args:
        graphExec: **[in]**  instance of executable graph to launch.

        stream: **[in]**  instance of stream in which to launch executable graph.

    Returns:
        A ``tuple`` of size 1 that contains (in that order):
        - #hipSuccess, #hipErrorInvalidValue
    """
    _hipGraphUpload__retval = hipError_t(chip.hipGraphUpload(
        hipGraphExec.from_pyobj(graphExec)._ptr,
        ihipStream_t.from_pyobj(stream)._ptr))    # fully specified
    return (_hipGraphUpload__retval,)


@cython.embedsignature(True)
def hipGraphExecDestroy(object graphExec):
    r"""Destroys an executable graph

    Warning:
        This API is marked as beta, meaning, while this is feature complete,
        it is still open to changes and may have outstanding issues.

    Args:
        pGraphExec: **[in]**  instance of executable graph to destry.

    Returns:
        A ``tuple`` of size 1 that contains (in that order):
        - #hipSuccess.
    """
    _hipGraphExecDestroy__retval = hipError_t(chip.hipGraphExecDestroy(
        hipGraphExec.from_pyobj(graphExec)._ptr))    # fully specified
    return (_hipGraphExecDestroy__retval,)


@cython.embedsignature(True)
def hipGraphExecUpdate(object hGraphExec, object hGraph):
    r"""Check whether an executable graph can be updated with a graph and perform the update if  *
    possible.

    Warning:
        This API is marked as beta, meaning, while this is feature complete,
        it is still open to changes and may have outstanding issues.

    Args:
        hGraphExec: **[in]**  instance of executable graph to update.

        hGraph: **[in]**  graph that contains the updated parameters.

    Returns:
        A ``tuple`` of size 3 that contains (in that order):
        - #hipSuccess, #hipErrorGraphExecUpdateFailure
        - hErrorNode_out:   node which caused the permissibility check to forbid the update.
        - updateResult_out:  Whether the graph update was permitted.
    """
    hErrorNode_out = hipGraphNode.from_ptr(NULL)
    cdef chip.hipGraphExecUpdateResult updateResult_out
    _hipGraphExecUpdate__retval = hipError_t(chip.hipGraphExecUpdate(
        hipGraphExec.from_pyobj(hGraphExec)._ptr,
        ihipGraph.from_pyobj(hGraph)._ptr,&hErrorNode_out._ptr,&updateResult_out))    # fully specified
    return (_hipGraphExecUpdate__retval,hErrorNode_out,hipGraphExecUpdateResult(updateResult_out))


@cython.embedsignature(True)
def hipGraphAddKernelNode(object graph, unsigned long numDependencies, object pNodeParams):
    r"""Creates a kernel execution node and adds it to a graph.

    Warning:
        This API is marked as beta, meaning, while this is feature complete,
        it is still open to changes and may have outstanding issues.

    Args:
        graph: **[in]**  instance of graph to add the created node.

        numDependencies: **[in]**  the number of the dependencies.

        pNodeParams: **[in]**  pointer to the parameters to the kernel execution node on the GPU.

    Returns:
        A ``tuple`` of size 3 that contains (in that order):
        - #hipSuccess, #hipErrorInvalidValue, #hipErrorInvalidDeviceFunction
        - pGraphNode:  pointer to graph node to create.
        - pDependencies:  pointer to the dependencies on the kernel execution node.
    """
    pGraphNode = hipGraphNode.from_ptr(NULL)
    pDependencies = hipGraphNode.from_ptr(NULL)
    _hipGraphAddKernelNode__retval = hipError_t(chip.hipGraphAddKernelNode(&pGraphNode._ptr,
        ihipGraph.from_pyobj(graph)._ptr,&pDependencies._ptr,numDependencies,
        hipKernelNodeParams.from_pyobj(pNodeParams)._ptr))    # fully specified
    return (_hipGraphAddKernelNode__retval,pGraphNode,pDependencies)


@cython.embedsignature(True)
def hipGraphKernelNodeGetParams(object node, object pNodeParams):
    r"""Gets kernel node's parameters.

    Warning:
        This API is marked as beta, meaning, while this is feature complete,
        it is still open to changes and may have outstanding issues.

    Args:
        node: **[in]**  instance of the node to get parameters from.

        pNodeParams: **[out]**  pointer to the parameters

    Returns:
        A ``tuple`` of size 1 that contains (in that order):
        - #hipSuccess, #hipErrorInvalidValue
    """
    _hipGraphKernelNodeGetParams__retval = hipError_t(chip.hipGraphKernelNodeGetParams(
        hipGraphNode.from_pyobj(node)._ptr,
        hipKernelNodeParams.from_pyobj(pNodeParams)._ptr))    # fully specified
    return (_hipGraphKernelNodeGetParams__retval,)


@cython.embedsignature(True)
def hipGraphKernelNodeSetParams(object node, object pNodeParams):
    r"""Sets a kernel node's parameters.

    Warning:
        This API is marked as beta, meaning, while this is feature complete,
        it is still open to changes and may have outstanding issues.

    Args:
        node: **[in]**  instance of the node to set parameters to.

        pNodeParams: **[in]**  const pointer to the parameters.

    Returns:
        A ``tuple`` of size 1 that contains (in that order):
        - #hipSuccess, #hipErrorInvalidValue
    """
    _hipGraphKernelNodeSetParams__retval = hipError_t(chip.hipGraphKernelNodeSetParams(
        hipGraphNode.from_pyobj(node)._ptr,
        hipKernelNodeParams.from_pyobj(pNodeParams)._ptr))    # fully specified
    return (_hipGraphKernelNodeSetParams__retval,)


@cython.embedsignature(True)
def hipGraphExecKernelNodeSetParams(object hGraphExec, object node, object pNodeParams):
    r"""Sets the parameters for a kernel node in the given graphExec.

    Warning:
        This API is marked as beta, meaning, while this is feature complete,
        it is still open to changes and may have outstanding issues.

    Args:
        hGraphExec: **[in]**  instance of the executable graph with the node.

        node: **[in]**  instance of the node to set parameters to.

        pNodeParams: **[in]**  const pointer to the kernel node parameters.

    Returns:
        A ``tuple`` of size 1 that contains (in that order):
        - #hipSuccess, #hipErrorInvalidValue
    """
    _hipGraphExecKernelNodeSetParams__retval = hipError_t(chip.hipGraphExecKernelNodeSetParams(
        hipGraphExec.from_pyobj(hGraphExec)._ptr,
        hipGraphNode.from_pyobj(node)._ptr,
        hipKernelNodeParams.from_pyobj(pNodeParams)._ptr))    # fully specified
    return (_hipGraphExecKernelNodeSetParams__retval,)


@cython.embedsignature(True)
def hipGraphAddMemcpyNode(object graph, unsigned long numDependencies, object pCopyParams):
    r"""Creates a memcpy node and adds it to a graph.

    Warning:
        This API is marked as beta, meaning, while this is feature complete,
        it is still open to changes and may have outstanding issues.

    Args:
        graph: **[in]**  instance of graph to add the created node.

        numDependencies: **[in]**  the number of the dependencies.

        pCopyParams: **[in]**  const pointer to the parameters for the memory copy.

    Returns:
        A ``tuple`` of size 3 that contains (in that order):
        - #hipSuccess, #hipErrorInvalidValue
        - pGraphNode:  pointer to graph node to create.
        - pDependencies:  const pointer to the dependencies on the memcpy execution node.
    """
    pGraphNode = hipGraphNode.from_ptr(NULL)
    pDependencies = hipGraphNode.from_ptr(NULL)
    _hipGraphAddMemcpyNode__retval = hipError_t(chip.hipGraphAddMemcpyNode(&pGraphNode._ptr,
        ihipGraph.from_pyobj(graph)._ptr,&pDependencies._ptr,numDependencies,
        hipMemcpy3DParms.from_pyobj(pCopyParams)._ptr))    # fully specified
    return (_hipGraphAddMemcpyNode__retval,pGraphNode,pDependencies)


@cython.embedsignature(True)
def hipGraphMemcpyNodeGetParams(object node, object pNodeParams):
    r"""Gets a memcpy node's parameters.

    Warning:
        This API is marked as beta, meaning, while this is feature complete,
        it is still open to changes and may have outstanding issues.

    Args:
        node: **[in]**  instance of the node to get parameters from.

        pNodeParams: **[out]**  pointer to the parameters.

    Returns:
        A ``tuple`` of size 1 that contains (in that order):
        - #hipSuccess, #hipErrorInvalidValue
    """
    _hipGraphMemcpyNodeGetParams__retval = hipError_t(chip.hipGraphMemcpyNodeGetParams(
        hipGraphNode.from_pyobj(node)._ptr,
        hipMemcpy3DParms.from_pyobj(pNodeParams)._ptr))    # fully specified
    return (_hipGraphMemcpyNodeGetParams__retval,)


@cython.embedsignature(True)
def hipGraphMemcpyNodeSetParams(object node, object pNodeParams):
    r"""Sets a memcpy node's parameters.

    Warning:
        This API is marked as beta, meaning, while this is feature complete,
        it is still open to changes and may have outstanding issues.

    Args:
        node: **[in]**  instance of the node to set parameters to.

        pNodeParams: **[in]**  const pointer to the parameters.

    Returns:
        A ``tuple`` of size 1 that contains (in that order):
        - #hipSuccess, #hipErrorInvalidValue
    """
    _hipGraphMemcpyNodeSetParams__retval = hipError_t(chip.hipGraphMemcpyNodeSetParams(
        hipGraphNode.from_pyobj(node)._ptr,
        hipMemcpy3DParms.from_pyobj(pNodeParams)._ptr))    # fully specified
    return (_hipGraphMemcpyNodeSetParams__retval,)


@cython.embedsignature(True)
def hipGraphKernelNodeSetAttribute(object hNode, object attr, object value):
    r"""Sets a node attribute.

    Warning:
        This API is marked as beta, meaning, while this is feature complete,
        it is still open to changes and may have outstanding issues.

    Args:
        hNode: **[in]**  instance of the node to set parameters to.

        attr: **[in]**  the attribute node is set to.

        value: **[in]**  const pointer to the parameters.

    Returns:
        A ``tuple`` of size 1 that contains (in that order):
        - #hipSuccess, #hipErrorInvalidValue
    """
    if not isinstance(attr,_hipKernelNodeAttrID__Base):
        raise TypeError("argument 'attr' must be of type '_hipKernelNodeAttrID__Base'")
    _hipGraphKernelNodeSetAttribute__retval = hipError_t(chip.hipGraphKernelNodeSetAttribute(
        hipGraphNode.from_pyobj(hNode)._ptr,attr.value,
        hipKernelNodeAttrValue.from_pyobj(value)._ptr))    # fully specified
    return (_hipGraphKernelNodeSetAttribute__retval,)


@cython.embedsignature(True)
def hipGraphKernelNodeGetAttribute(object hNode, object attr, object value):
    r"""Gets a node attribute.

    Warning:
        This API is marked as beta, meaning, while this is feature complete,
        it is still open to changes and may have outstanding issues.

    Args:
        hNode: **[in]**  instance of the node to set parameters to.

        attr: **[in]**  the attribute node is set to.

        value: **[in]**  const pointer to the parameters.

    Returns:
        A ``tuple`` of size 1 that contains (in that order):
        - #hipSuccess, #hipErrorInvalidValue
    """
    if not isinstance(attr,_hipKernelNodeAttrID__Base):
        raise TypeError("argument 'attr' must be of type '_hipKernelNodeAttrID__Base'")
    _hipGraphKernelNodeGetAttribute__retval = hipError_t(chip.hipGraphKernelNodeGetAttribute(
        hipGraphNode.from_pyobj(hNode)._ptr,attr.value,
        hipKernelNodeAttrValue.from_pyobj(value)._ptr))    # fully specified
    return (_hipGraphKernelNodeGetAttribute__retval,)


@cython.embedsignature(True)
def hipGraphExecMemcpyNodeSetParams(object hGraphExec, object node, object pNodeParams):
    r"""Sets the parameters for a memcpy node in the given graphExec.

    Warning:
        This API is marked as beta, meaning, while this is feature complete,
        it is still open to changes and may have outstanding issues.

    Args:
        hGraphExec: **[in]**  instance of the executable graph with the node.

        node: **[in]**  instance of the node to set parameters to.

        pNodeParams: **[in]**  const pointer to the kernel node parameters.

    Returns:
        A ``tuple`` of size 1 that contains (in that order):
        - #hipSuccess, #hipErrorInvalidValue
    """
    _hipGraphExecMemcpyNodeSetParams__retval = hipError_t(chip.hipGraphExecMemcpyNodeSetParams(
        hipGraphExec.from_pyobj(hGraphExec)._ptr,
        hipGraphNode.from_pyobj(node)._ptr,
        hipMemcpy3DParms.from_pyobj(pNodeParams)._ptr))    # fully specified
    return (_hipGraphExecMemcpyNodeSetParams__retval,)


@cython.embedsignature(True)
def hipGraphAddMemcpyNode1D(object graph, unsigned long numDependencies, object dst, object src, unsigned long count, object kind):
    r"""Creates a 1D memcpy node and adds it to a graph.

    Warning:
        This API is marked as beta, meaning, while this is feature complete,
        it is still open to changes and may have outstanding issues.

    Args:
        graph: **[in]**  instance of graph to add the created node.

        numDependencies: **[in]**  the number of the dependencies.

        dst: **[in]**  pointer to memory address to the destination.

        src: **[in]**  pointer to memory address to the source.

        count: **[in]**  the size of the memory to copy.

        kind: **[in]**  the type of memory copy.

    Returns:
        A ``tuple`` of size 3 that contains (in that order):
        - #hipSuccess, #hipErrorInvalidValue
        - pGraphNode:  pointer to graph node to create.
        - pDependencies:  const pointer to the dependencies on the memcpy execution node.
    """
    pGraphNode = hipGraphNode.from_ptr(NULL)
    pDependencies = hipGraphNode.from_ptr(NULL)
    if not isinstance(kind,_hipMemcpyKind__Base):
        raise TypeError("argument 'kind' must be of type '_hipMemcpyKind__Base'")
    _hipGraphAddMemcpyNode1D__retval = hipError_t(chip.hipGraphAddMemcpyNode1D(&pGraphNode._ptr,
        ihipGraph.from_pyobj(graph)._ptr,&pDependencies._ptr,numDependencies,
        <void *>hip._util.types.DataHandle.from_pyobj(dst)._ptr,
        <const void *>hip._util.types.DataHandle.from_pyobj(src)._ptr,count,kind.value))    # fully specified
    return (_hipGraphAddMemcpyNode1D__retval,pGraphNode,pDependencies)


@cython.embedsignature(True)
def hipGraphMemcpyNodeSetParams1D(object node, object dst, object src, unsigned long count, object kind):
    r"""Sets a memcpy node's parameters to perform a 1-dimensional copy.

    Warning:
        This API is marked as beta, meaning, while this is feature complete,
        it is still open to changes and may have outstanding issues.

    Args:
        node: **[in]**  instance of the node to set parameters to.

        dst: **[in]**  pointer to memory address to the destination.

        src: **[in]**  pointer to memory address to the source.

        count: **[in]**  the size of the memory to copy.

        kind: **[in]**  the type of memory copy.

    Returns:
        A ``tuple`` of size 1 that contains (in that order):
        - #hipSuccess, #hipErrorInvalidValue
    """
    if not isinstance(kind,_hipMemcpyKind__Base):
        raise TypeError("argument 'kind' must be of type '_hipMemcpyKind__Base'")
    _hipGraphMemcpyNodeSetParams1D__retval = hipError_t(chip.hipGraphMemcpyNodeSetParams1D(
        hipGraphNode.from_pyobj(node)._ptr,
        <void *>hip._util.types.DataHandle.from_pyobj(dst)._ptr,
        <const void *>hip._util.types.DataHandle.from_pyobj(src)._ptr,count,kind.value))    # fully specified
    return (_hipGraphMemcpyNodeSetParams1D__retval,)


@cython.embedsignature(True)
def hipGraphExecMemcpyNodeSetParams1D(object hGraphExec, object node, object dst, object src, unsigned long count, object kind):
    r"""Sets the parameters for a memcpy node in the given graphExec to perform a 1-dimensional
    copy.

    Warning:
        This API is marked as beta, meaning, while this is feature complete,
        it is still open to changes and may have outstanding issues.

    Args:
        hGraphExec: **[in]**  instance of the executable graph with the node.

        node: **[in]**  instance of the node to set parameters to.

        dst: **[in]**  pointer to memory address to the destination.

        src: **[in]**  pointer to memory address to the source.

        count: **[in]**  the size of the memory to copy.

        kind: **[in]**  the type of memory copy.

    Returns:
        A ``tuple`` of size 1 that contains (in that order):
        - #hipSuccess, #hipErrorInvalidValue
    """
    if not isinstance(kind,_hipMemcpyKind__Base):
        raise TypeError("argument 'kind' must be of type '_hipMemcpyKind__Base'")
    _hipGraphExecMemcpyNodeSetParams1D__retval = hipError_t(chip.hipGraphExecMemcpyNodeSetParams1D(
        hipGraphExec.from_pyobj(hGraphExec)._ptr,
        hipGraphNode.from_pyobj(node)._ptr,
        <void *>hip._util.types.DataHandle.from_pyobj(dst)._ptr,
        <const void *>hip._util.types.DataHandle.from_pyobj(src)._ptr,count,kind.value))    # fully specified
    return (_hipGraphExecMemcpyNodeSetParams1D__retval,)


@cython.embedsignature(True)
def hipGraphAddMemcpyNodeFromSymbol(object graph, unsigned long numDependencies, object dst, object symbol, unsigned long count, unsigned long offset, object kind):
    r"""Creates a memcpy node to copy from a symbol on the device and adds it to a graph.

    Warning:
        This API is marked as beta, meaning, while this is feature complete,
        it is still open to changes and may have outstanding issues.

    Args:
        graph: **[in]**  instance of graph to add the created node.

        numDependencies: **[in]**  the number of the dependencies.

        dst: **[in]**  pointer to memory address to the destination.

        symbol: **[in]**  Device symbol address.

        count: **[in]**  the size of the memory to copy.

        offset: **[in]**  Offset from start of symbol in bytes.

        kind: **[in]**  the type of memory copy.

    Returns:
        A ``tuple`` of size 3 that contains (in that order):
        - #hipSuccess, #hipErrorInvalidValue
        - pGraphNode:  pointer to graph node to create.
        - pDependencies:  const pointer to the dependencies on the memcpy execution node.
    """
    pGraphNode = hipGraphNode.from_ptr(NULL)
    pDependencies = hipGraphNode.from_ptr(NULL)
    if not isinstance(kind,_hipMemcpyKind__Base):
        raise TypeError("argument 'kind' must be of type '_hipMemcpyKind__Base'")
    _hipGraphAddMemcpyNodeFromSymbol__retval = hipError_t(chip.hipGraphAddMemcpyNodeFromSymbol(&pGraphNode._ptr,
        ihipGraph.from_pyobj(graph)._ptr,&pDependencies._ptr,numDependencies,
        <void *>hip._util.types.DataHandle.from_pyobj(dst)._ptr,
        <const void *>hip._util.types.DataHandle.from_pyobj(symbol)._ptr,count,offset,kind.value))    # fully specified
    return (_hipGraphAddMemcpyNodeFromSymbol__retval,pGraphNode,pDependencies)


@cython.embedsignature(True)
def hipGraphMemcpyNodeSetParamsFromSymbol(object node, object dst, object symbol, unsigned long count, unsigned long offset, object kind):
    r"""Sets a memcpy node's parameters to copy from a symbol on the device.

    Warning:
        This API is marked as beta, meaning, while this is feature complete,
        it is still open to changes and may have outstanding issues.

    Args:
        node: **[in]**  instance of the node to set parameters to.

        dst: **[in]**  pointer to memory address to the destination.

        symbol: **[in]**  Device symbol address.

        count: **[in]**  the size of the memory to copy.

        offset: **[in]**  Offset from start of symbol in bytes.

        kind: **[in]**  the type of memory copy.

    Returns:
        A ``tuple`` of size 1 that contains (in that order):
        - #hipSuccess, #hipErrorInvalidValue
    """
    if not isinstance(kind,_hipMemcpyKind__Base):
        raise TypeError("argument 'kind' must be of type '_hipMemcpyKind__Base'")
    _hipGraphMemcpyNodeSetParamsFromSymbol__retval = hipError_t(chip.hipGraphMemcpyNodeSetParamsFromSymbol(
        hipGraphNode.from_pyobj(node)._ptr,
        <void *>hip._util.types.DataHandle.from_pyobj(dst)._ptr,
        <const void *>hip._util.types.DataHandle.from_pyobj(symbol)._ptr,count,offset,kind.value))    # fully specified
    return (_hipGraphMemcpyNodeSetParamsFromSymbol__retval,)


@cython.embedsignature(True)
def hipGraphExecMemcpyNodeSetParamsFromSymbol(object hGraphExec, object node, object dst, object symbol, unsigned long count, unsigned long offset, object kind):
    r"""Sets the parameters for a memcpy node in the given graphExec to copy from a symbol on the
    * device.

    Warning:
        This API is marked as beta, meaning, while this is feature complete,
        it is still open to changes and may have outstanding issues.

    Args:
        hGraphExec: **[in]**  instance of the executable graph with the node.

        node: **[in]**  instance of the node to set parameters to.

        dst: **[in]**  pointer to memory address to the destination.

        symbol: **[in]**  Device symbol address.

        count: **[in]**  the size of the memory to copy.

        offset: **[in]**  Offset from start of symbol in bytes.

        kind: **[in]**  the type of memory copy.

    Returns:
        A ``tuple`` of size 1 that contains (in that order):
        - #hipSuccess, #hipErrorInvalidValue
    """
    if not isinstance(kind,_hipMemcpyKind__Base):
        raise TypeError("argument 'kind' must be of type '_hipMemcpyKind__Base'")
    _hipGraphExecMemcpyNodeSetParamsFromSymbol__retval = hipError_t(chip.hipGraphExecMemcpyNodeSetParamsFromSymbol(
        hipGraphExec.from_pyobj(hGraphExec)._ptr,
        hipGraphNode.from_pyobj(node)._ptr,
        <void *>hip._util.types.DataHandle.from_pyobj(dst)._ptr,
        <const void *>hip._util.types.DataHandle.from_pyobj(symbol)._ptr,count,offset,kind.value))    # fully specified
    return (_hipGraphExecMemcpyNodeSetParamsFromSymbol__retval,)


@cython.embedsignature(True)
def hipGraphAddMemcpyNodeToSymbol(object graph, unsigned long numDependencies, object symbol, object src, unsigned long count, unsigned long offset, object kind):
    r"""Creates a memcpy node to copy to a symbol on the device and adds it to a graph.

    Warning:
        This API is marked as beta, meaning, while this is feature complete,
        it is still open to changes and may have outstanding issues.

    Args:
        graph: **[in]**  instance of graph to add the created node.

        numDependencies: **[in]**  the number of the dependencies.

        symbol: **[in]**  Device symbol address.

        src: **[in]**  pointer to memory address of the src.

        count: **[in]**  the size of the memory to copy.

        offset: **[in]**  Offset from start of symbol in bytes.

        kind: **[in]**  the type of memory copy.

    Returns:
        A ``tuple`` of size 3 that contains (in that order):
        - #hipSuccess, #hipErrorInvalidValue
        - pGraphNode:  pointer to graph node to create.
        - pDependencies:  const pointer to the dependencies on the memcpy execution node.
    """
    pGraphNode = hipGraphNode.from_ptr(NULL)
    pDependencies = hipGraphNode.from_ptr(NULL)
    if not isinstance(kind,_hipMemcpyKind__Base):
        raise TypeError("argument 'kind' must be of type '_hipMemcpyKind__Base'")
    _hipGraphAddMemcpyNodeToSymbol__retval = hipError_t(chip.hipGraphAddMemcpyNodeToSymbol(&pGraphNode._ptr,
        ihipGraph.from_pyobj(graph)._ptr,&pDependencies._ptr,numDependencies,
        <const void *>hip._util.types.DataHandle.from_pyobj(symbol)._ptr,
        <const void *>hip._util.types.DataHandle.from_pyobj(src)._ptr,count,offset,kind.value))    # fully specified
    return (_hipGraphAddMemcpyNodeToSymbol__retval,pGraphNode,pDependencies)


@cython.embedsignature(True)
def hipGraphMemcpyNodeSetParamsToSymbol(object node, object symbol, object src, unsigned long count, unsigned long offset, object kind):
    r"""Sets a memcpy node's parameters to copy to a symbol on the device.

    Warning:
        This API is marked as beta, meaning, while this is feature complete,
        it is still open to changes and may have outstanding issues.

    Args:
        node: **[in]**  instance of the node to set parameters to.

        symbol: **[in]**  Device symbol address.

        src: **[in]**  pointer to memory address of the src.

        count: **[in]**  the size of the memory to copy.

        offset: **[in]**  Offset from start of symbol in bytes.

        kind: **[in]**  the type of memory copy.

    Returns:
        A ``tuple`` of size 1 that contains (in that order):
        - #hipSuccess, #hipErrorInvalidValue
    """
    if not isinstance(kind,_hipMemcpyKind__Base):
        raise TypeError("argument 'kind' must be of type '_hipMemcpyKind__Base'")
    _hipGraphMemcpyNodeSetParamsToSymbol__retval = hipError_t(chip.hipGraphMemcpyNodeSetParamsToSymbol(
        hipGraphNode.from_pyobj(node)._ptr,
        <const void *>hip._util.types.DataHandle.from_pyobj(symbol)._ptr,
        <const void *>hip._util.types.DataHandle.from_pyobj(src)._ptr,count,offset,kind.value))    # fully specified
    return (_hipGraphMemcpyNodeSetParamsToSymbol__retval,)


@cython.embedsignature(True)
def hipGraphExecMemcpyNodeSetParamsToSymbol(object hGraphExec, object node, object symbol, object src, unsigned long count, unsigned long offset, object kind):
    r"""Sets the parameters for a memcpy node in the given graphExec to copy to a symbol on the
    device.

    Warning:
        This API is marked as beta, meaning, while this is feature complete,
        it is still open to changes and may have outstanding issues.

    Args:
        hGraphExec: **[in]**  instance of the executable graph with the node.

        node: **[in]**  instance of the node to set parameters to.

        symbol: **[in]**  Device symbol address.

        src: **[in]**  pointer to memory address of the src.

        count: **[in]**  the size of the memory to copy.

        offset: **[in]**  Offset from start of symbol in bytes.

        kind: **[in]**  the type of memory copy.

    Returns:
        A ``tuple`` of size 1 that contains (in that order):
        - #hipSuccess, #hipErrorInvalidValue
    """
    if not isinstance(kind,_hipMemcpyKind__Base):
        raise TypeError("argument 'kind' must be of type '_hipMemcpyKind__Base'")
    _hipGraphExecMemcpyNodeSetParamsToSymbol__retval = hipError_t(chip.hipGraphExecMemcpyNodeSetParamsToSymbol(
        hipGraphExec.from_pyobj(hGraphExec)._ptr,
        hipGraphNode.from_pyobj(node)._ptr,
        <const void *>hip._util.types.DataHandle.from_pyobj(symbol)._ptr,
        <const void *>hip._util.types.DataHandle.from_pyobj(src)._ptr,count,offset,kind.value))    # fully specified
    return (_hipGraphExecMemcpyNodeSetParamsToSymbol__retval,)


@cython.embedsignature(True)
def hipGraphAddMemsetNode(object graph, unsigned long numDependencies, object pMemsetParams):
    r"""Creates a memset node and adds it to a graph.

    Warning:
        This API is marked as beta, meaning, while this is feature complete,
        it is still open to changes and may have outstanding issues.

    Args:
        graph: **[in]**  instance of the graph to add the created node.

        numDependencies: **[in]**  the number of the dependencies.

        pMemsetParams: **[in]**  const pointer to the parameters for the memory set.

    Returns:
        A ``tuple`` of size 3 that contains (in that order):
        - #hipSuccess, #hipErrorInvalidValue
        - pGraphNode:  pointer to the graph node to create.
        - pDependencies:  const pointer to the dependencies on the memset execution node.
    """
    pGraphNode = hipGraphNode.from_ptr(NULL)
    pDependencies = hipGraphNode.from_ptr(NULL)
    _hipGraphAddMemsetNode__retval = hipError_t(chip.hipGraphAddMemsetNode(&pGraphNode._ptr,
        ihipGraph.from_pyobj(graph)._ptr,&pDependencies._ptr,numDependencies,
        hipMemsetParams.from_pyobj(pMemsetParams)._ptr))    # fully specified
    return (_hipGraphAddMemsetNode__retval,pGraphNode,pDependencies)


@cython.embedsignature(True)
def hipGraphMemsetNodeGetParams(object node, object pNodeParams):
    r"""Gets a memset node's parameters.

    Warning:
        This API is marked as beta, meaning, while this is feature complete,
        it is still open to changes and may have outstanding issues.

    Args:
        node: **[in]**  instane of the node to get parameters from.

        pNodeParams: **[out]**  pointer to the parameters.

    Returns:
        A ``tuple`` of size 1 that contains (in that order):
        - #hipSuccess, #hipErrorInvalidValue
    """
    _hipGraphMemsetNodeGetParams__retval = hipError_t(chip.hipGraphMemsetNodeGetParams(
        hipGraphNode.from_pyobj(node)._ptr,
        hipMemsetParams.from_pyobj(pNodeParams)._ptr))    # fully specified
    return (_hipGraphMemsetNodeGetParams__retval,)


@cython.embedsignature(True)
def hipGraphMemsetNodeSetParams(object node, object pNodeParams):
    r"""Sets a memset node's parameters.

    Warning:
        This API is marked as beta, meaning, while this is feature complete,
        it is still open to changes and may have outstanding issues.

    Args:
        node: **[in]**  instance of the node to set parameters to.

        pNodeParams: **[in]**  pointer to the parameters.

    Returns:
        A ``tuple`` of size 1 that contains (in that order):
        - #hipSuccess, #hipErrorInvalidValue
    """
    _hipGraphMemsetNodeSetParams__retval = hipError_t(chip.hipGraphMemsetNodeSetParams(
        hipGraphNode.from_pyobj(node)._ptr,
        hipMemsetParams.from_pyobj(pNodeParams)._ptr))    # fully specified
    return (_hipGraphMemsetNodeSetParams__retval,)


@cython.embedsignature(True)
def hipGraphExecMemsetNodeSetParams(object hGraphExec, object node, object pNodeParams):
    r"""Sets the parameters for a memset node in the given graphExec.

    Warning:
        This API is marked as beta, meaning, while this is feature complete,
        it is still open to changes and may have outstanding issues.

    Args:
        hGraphExec: **[in]**  instance of the executable graph with the node.

        node: **[in]**  instance of the node to set parameters to.

        pNodeParams: **[in]**  pointer to the parameters.

    Returns:
        A ``tuple`` of size 1 that contains (in that order):
        - #hipSuccess, #hipErrorInvalidValue
    """
    _hipGraphExecMemsetNodeSetParams__retval = hipError_t(chip.hipGraphExecMemsetNodeSetParams(
        hipGraphExec.from_pyobj(hGraphExec)._ptr,
        hipGraphNode.from_pyobj(node)._ptr,
        hipMemsetParams.from_pyobj(pNodeParams)._ptr))    # fully specified
    return (_hipGraphExecMemsetNodeSetParams__retval,)


@cython.embedsignature(True)
def hipGraphAddHostNode(object graph, unsigned long numDependencies, object pNodeParams):
    r"""Creates a host execution node and adds it to a graph.

    Warning:
        This API is marked as beta, meaning, while this is feature complete,
        it is still open to changes and may have outstanding issues.

    Args:
        graph: **[in]**  instance of the graph to add the created node.

        numDependencies: **[in]**  the number of the dependencies.

        pNodeParams: **[in]** pointer to the parameters.

    Returns:
        A ``tuple`` of size 3 that contains (in that order):
        - #hipSuccess, #hipErrorInvalidValue
        - pGraphNode:  pointer to the graph node to create.
        - pDependencies:  const pointer to the dependencies on the memset execution node.
    """
    pGraphNode = hipGraphNode.from_ptr(NULL)
    pDependencies = hipGraphNode.from_ptr(NULL)
    _hipGraphAddHostNode__retval = hipError_t(chip.hipGraphAddHostNode(&pGraphNode._ptr,
        ihipGraph.from_pyobj(graph)._ptr,&pDependencies._ptr,numDependencies,
        hipHostNodeParams.from_pyobj(pNodeParams)._ptr))    # fully specified
    return (_hipGraphAddHostNode__retval,pGraphNode,pDependencies)


@cython.embedsignature(True)
def hipGraphHostNodeGetParams(object node, object pNodeParams):
    r"""Returns a host node's parameters.

    Warning:
        This API is marked as beta, meaning, while this is feature complete,
        it is still open to changes and may have outstanding issues.

    Args:
        node: **[in]**  instane of the node to get parameters from.

        pNodeParams: **[out]**  pointer to the parameters.

    Returns:
        A ``tuple`` of size 1 that contains (in that order):
        - #hipSuccess, #hipErrorInvalidValue
    """
    _hipGraphHostNodeGetParams__retval = hipError_t(chip.hipGraphHostNodeGetParams(
        hipGraphNode.from_pyobj(node)._ptr,
        hipHostNodeParams.from_pyobj(pNodeParams)._ptr))    # fully specified
    return (_hipGraphHostNodeGetParams__retval,)


@cython.embedsignature(True)
def hipGraphHostNodeSetParams(object node, object pNodeParams):
    r"""Sets a host node's parameters.

    Warning:
        This API is marked as beta, meaning, while this is feature complete,
        it is still open to changes and may have outstanding issues.

    Args:
        node: **[in]**  instance of the node to set parameters to.

        pNodeParams: **[in]**  pointer to the parameters.

    Returns:
        A ``tuple`` of size 1 that contains (in that order):
        - #hipSuccess, #hipErrorInvalidValue
    """
    _hipGraphHostNodeSetParams__retval = hipError_t(chip.hipGraphHostNodeSetParams(
        hipGraphNode.from_pyobj(node)._ptr,
        hipHostNodeParams.from_pyobj(pNodeParams)._ptr))    # fully specified
    return (_hipGraphHostNodeSetParams__retval,)


@cython.embedsignature(True)
def hipGraphExecHostNodeSetParams(object hGraphExec, object node, object pNodeParams):
    r"""Sets the parameters for a host node in the given graphExec.

    Warning:
        This API is marked as beta, meaning, while this is feature complete,
        it is still open to changes and may have outstanding issues.

    Args:
        hGraphExec: **[in]**  instance of the executable graph with the node.

        node: **[in]**  instance of the node to set parameters to.

        pNodeParams: **[in]**  pointer to the parameters.

    Returns:
        A ``tuple`` of size 1 that contains (in that order):
        - #hipSuccess, #hipErrorInvalidValue
    """
    _hipGraphExecHostNodeSetParams__retval = hipError_t(chip.hipGraphExecHostNodeSetParams(
        hipGraphExec.from_pyobj(hGraphExec)._ptr,
        hipGraphNode.from_pyobj(node)._ptr,
        hipHostNodeParams.from_pyobj(pNodeParams)._ptr))    # fully specified
    return (_hipGraphExecHostNodeSetParams__retval,)


@cython.embedsignature(True)
def hipGraphAddChildGraphNode(object graph, unsigned long numDependencies, object childGraph):
    r"""Creates a child graph node and adds it to a graph.

    Warning:
        This API is marked as beta, meaning, while this is feature complete,
        it is still open to changes and may have outstanding issues.

    Args:
        graph: **[in]**  instance of the graph to add the created node.

        numDependencies: **[in]**  the number of the dependencies.

        childGraph: **[in]**  the graph to clone into this node

    Returns:
        A ``tuple`` of size 3 that contains (in that order):
        - #hipSuccess, #hipErrorInvalidValue
        - pGraphNode:  pointer to the graph node to create.
        - pDependencies:  const pointer to the dependencies on the memset execution node.
    """
    pGraphNode = hipGraphNode.from_ptr(NULL)
    pDependencies = hipGraphNode.from_ptr(NULL)
    _hipGraphAddChildGraphNode__retval = hipError_t(chip.hipGraphAddChildGraphNode(&pGraphNode._ptr,
        ihipGraph.from_pyobj(graph)._ptr,&pDependencies._ptr,numDependencies,
        ihipGraph.from_pyobj(childGraph)._ptr))    # fully specified
    return (_hipGraphAddChildGraphNode__retval,pGraphNode,pDependencies)


@cython.embedsignature(True)
def hipGraphChildGraphNodeGetGraph(object node):
    r"""Gets a handle to the embedded graph of a child graph node.

    Warning:
        This API is marked as beta, meaning, while this is feature complete,
        it is still open to changes and may have outstanding issues.

    Args:
        node: **[in]**  instane of the node to get child graph.

    Returns:
        A ``tuple`` of size 2 that contains (in that order):
        - #hipSuccess, #hipErrorInvalidValue
        - pGraph:  pointer to get the graph.
    """
    pGraph = ihipGraph.from_ptr(NULL)
    _hipGraphChildGraphNodeGetGraph__retval = hipError_t(chip.hipGraphChildGraphNodeGetGraph(
        hipGraphNode.from_pyobj(node)._ptr,&pGraph._ptr))    # fully specified
    return (_hipGraphChildGraphNodeGetGraph__retval,pGraph)


@cython.embedsignature(True)
def hipGraphExecChildGraphNodeSetParams(object hGraphExec, object node, object childGraph):
    r"""Updates node parameters in the child graph node in the given graphExec.

    Warning:
        This API is marked as beta, meaning, while this is feature complete,
        it is still open to changes and may have outstanding issues.

    Args:
        hGraphExec: **[in]**  instance of the executable graph with the node.

        node: **[in]**  node from the graph which was used to instantiate graphExec.

        childGraph: **[in]**  child graph with updated parameters.

    Returns:
        A ``tuple`` of size 1 that contains (in that order):
        - #hipSuccess, #hipErrorInvalidValue
    """
    _hipGraphExecChildGraphNodeSetParams__retval = hipError_t(chip.hipGraphExecChildGraphNodeSetParams(
        hipGraphExec.from_pyobj(hGraphExec)._ptr,
        hipGraphNode.from_pyobj(node)._ptr,
        ihipGraph.from_pyobj(childGraph)._ptr))    # fully specified
    return (_hipGraphExecChildGraphNodeSetParams__retval,)


@cython.embedsignature(True)
def hipGraphAddEmptyNode(object graph, unsigned long numDependencies):
    r"""Creates an empty node and adds it to a graph.

    Warning:
        This API is marked as beta, meaning, while this is feature complete,
        it is still open to changes and may have outstanding issues.

    Args:
        graph: **[in]**  instane of the graph the node is add to.

        numDependencies: **[in]**  the number of dependencies.

    Returns:
        A ``tuple`` of size 3 that contains (in that order):
        - #hipSuccess, #hipErrorInvalidValue
        - pGraphNode:  pointer to the graph node to create and add to the graph.
        - pDependencies:  const pointer to the node dependenties.
    """
    pGraphNode = hipGraphNode.from_ptr(NULL)
    pDependencies = hipGraphNode.from_ptr(NULL)
    _hipGraphAddEmptyNode__retval = hipError_t(chip.hipGraphAddEmptyNode(&pGraphNode._ptr,
        ihipGraph.from_pyobj(graph)._ptr,&pDependencies._ptr,numDependencies))    # fully specified
    return (_hipGraphAddEmptyNode__retval,pGraphNode,pDependencies)


@cython.embedsignature(True)
def hipGraphAddEventRecordNode(object graph, unsigned long numDependencies, object event):
    r"""Creates an event record node and adds it to a graph.

    Warning:
        This API is marked as beta, meaning, while this is feature complete,
        it is still open to changes and may have outstanding issues.

    Args:
        graph: **[in]**  instane of the graph the node to be added.

        numDependencies: **[in]**  the number of dependencies.

        event: **[in]**  Event for the node.

    Returns:
        A ``tuple`` of size 3 that contains (in that order):
        - #hipSuccess, #hipErrorInvalidValue
        - pGraphNode:  pointer to the graph node to create and add to the graph.
        - pDependencies:  const pointer to the node dependenties.
    """
    pGraphNode = hipGraphNode.from_ptr(NULL)
    pDependencies = hipGraphNode.from_ptr(NULL)
    _hipGraphAddEventRecordNode__retval = hipError_t(chip.hipGraphAddEventRecordNode(&pGraphNode._ptr,
        ihipGraph.from_pyobj(graph)._ptr,&pDependencies._ptr,numDependencies,
        ihipEvent_t.from_pyobj(event)._ptr))    # fully specified
    return (_hipGraphAddEventRecordNode__retval,pGraphNode,pDependencies)


@cython.embedsignature(True)
def hipGraphEventRecordNodeGetEvent(object node):
    r"""Returns the event associated with an event record node.

    Warning:
        This API is marked as beta, meaning, while this is feature complete,
        it is still open to changes and may have outstanding issues.

    Args:
        node: **[in]**   instane of the node to get event from.

    Returns:
        A ``tuple`` of size 2 that contains (in that order):
        - #hipSuccess, #hipErrorInvalidValue
        - event_out:  Pointer to return the event.
    """
    event_out = ihipEvent_t.from_ptr(NULL)
    _hipGraphEventRecordNodeGetEvent__retval = hipError_t(chip.hipGraphEventRecordNodeGetEvent(
        hipGraphNode.from_pyobj(node)._ptr,&event_out._ptr))    # fully specified
    return (_hipGraphEventRecordNodeGetEvent__retval,event_out)


@cython.embedsignature(True)
def hipGraphEventRecordNodeSetEvent(object node, object event):
    r"""Sets an event record node's event.

    Warning:
        This API is marked as beta, meaning, while this is feature complete,
        it is still open to changes and may have outstanding issues.

    Args:
        node: **[in]**  instane of the node to set event to.

        event: **[in]**  pointer to the event.

    Returns:
        A ``tuple`` of size 1 that contains (in that order):
        - #hipSuccess, #hipErrorInvalidValue
    """
    _hipGraphEventRecordNodeSetEvent__retval = hipError_t(chip.hipGraphEventRecordNodeSetEvent(
        hipGraphNode.from_pyobj(node)._ptr,
        ihipEvent_t.from_pyobj(event)._ptr))    # fully specified
    return (_hipGraphEventRecordNodeSetEvent__retval,)


@cython.embedsignature(True)
def hipGraphExecEventRecordNodeSetEvent(object hGraphExec, object hNode, object event):
    r"""Sets the event for an event record node in the given graphExec.

    Warning:
        This API is marked as beta, meaning, while this is feature complete,
        it is still open to changes and may have outstanding issues.

    Args:
        hGraphExec: **[in]**  instance of the executable graph with the node.

        hNode: **[in]**  node from the graph which was used to instantiate graphExec.

        event: **[in]**  pointer to the event.

    Returns:
        A ``tuple`` of size 1 that contains (in that order):
        - #hipSuccess, #hipErrorInvalidValue
    """
    _hipGraphExecEventRecordNodeSetEvent__retval = hipError_t(chip.hipGraphExecEventRecordNodeSetEvent(
        hipGraphExec.from_pyobj(hGraphExec)._ptr,
        hipGraphNode.from_pyobj(hNode)._ptr,
        ihipEvent_t.from_pyobj(event)._ptr))    # fully specified
    return (_hipGraphExecEventRecordNodeSetEvent__retval,)


@cython.embedsignature(True)
def hipGraphAddEventWaitNode(object graph, unsigned long numDependencies, object event):
    r"""Creates an event wait node and adds it to a graph.

    Warning:
        This API is marked as beta, meaning, while this is feature complete,
        it is still open to changes and may have outstanding issues.

    Args:
        graph: **[in]**  instane of the graph the node to be added.

        numDependencies: **[in]**  the number of dependencies.

        event: **[in]**  Event for the node.

    Returns:
        A ``tuple`` of size 3 that contains (in that order):
        - #hipSuccess, #hipErrorInvalidValue
        - pGraphNode:  pointer to the graph node to create and add to the graph.
        - pDependencies:  const pointer to the node dependenties.
    """
    pGraphNode = hipGraphNode.from_ptr(NULL)
    pDependencies = hipGraphNode.from_ptr(NULL)
    _hipGraphAddEventWaitNode__retval = hipError_t(chip.hipGraphAddEventWaitNode(&pGraphNode._ptr,
        ihipGraph.from_pyobj(graph)._ptr,&pDependencies._ptr,numDependencies,
        ihipEvent_t.from_pyobj(event)._ptr))    # fully specified
    return (_hipGraphAddEventWaitNode__retval,pGraphNode,pDependencies)


@cython.embedsignature(True)
def hipGraphEventWaitNodeGetEvent(object node):
    r"""Returns the event associated with an event wait node.

    Warning:
        This API is marked as beta, meaning, while this is feature complete,
        it is still open to changes and may have outstanding issues.

    Args:
        node: **[in]**   instane of the node to get event from.

    Returns:
        A ``tuple`` of size 2 that contains (in that order):
        - #hipSuccess, #hipErrorInvalidValue
        - event_out:  Pointer to return the event.
    """
    event_out = ihipEvent_t.from_ptr(NULL)
    _hipGraphEventWaitNodeGetEvent__retval = hipError_t(chip.hipGraphEventWaitNodeGetEvent(
        hipGraphNode.from_pyobj(node)._ptr,&event_out._ptr))    # fully specified
    return (_hipGraphEventWaitNodeGetEvent__retval,event_out)


@cython.embedsignature(True)
def hipGraphEventWaitNodeSetEvent(object node, object event):
    r"""Sets an event wait node's event.

    Warning:
        This API is marked as beta, meaning, while this is feature complete,
        it is still open to changes and may have outstanding issues.

    Args:
        node: **[in]**  instane of the node to set event to.

        event: **[in]**  pointer to the event.

    Returns:
        A ``tuple`` of size 1 that contains (in that order):
        - #hipSuccess, #hipErrorInvalidValue
    """
    _hipGraphEventWaitNodeSetEvent__retval = hipError_t(chip.hipGraphEventWaitNodeSetEvent(
        hipGraphNode.from_pyobj(node)._ptr,
        ihipEvent_t.from_pyobj(event)._ptr))    # fully specified
    return (_hipGraphEventWaitNodeSetEvent__retval,)


@cython.embedsignature(True)
def hipGraphExecEventWaitNodeSetEvent(object hGraphExec, object hNode, object event):
    r"""Sets the event for an event record node in the given graphExec.

    Warning:
        This API is marked as beta, meaning, while this is feature complete,
        it is still open to changes and may have outstanding issues.

    Args:
        hGraphExec: **[in]**  instance of the executable graph with the node.

        hNode: **[in]**  node from the graph which was used to instantiate graphExec.

        event: **[in]**  pointer to the event.

    Returns:
        A ``tuple`` of size 1 that contains (in that order):
        - #hipSuccess, #hipErrorInvalidValue
    """
    _hipGraphExecEventWaitNodeSetEvent__retval = hipError_t(chip.hipGraphExecEventWaitNodeSetEvent(
        hipGraphExec.from_pyobj(hGraphExec)._ptr,
        hipGraphNode.from_pyobj(hNode)._ptr,
        ihipEvent_t.from_pyobj(event)._ptr))    # fully specified
    return (_hipGraphExecEventWaitNodeSetEvent__retval,)


@cython.embedsignature(True)
def hipDeviceGetGraphMemAttribute(int device, object attr, object value):
    r"""Get the mem attribute for graphs.

    Warning:
        This API is marked as beta, meaning, while this is feature complete,
        it is still open to changes and may have outstanding issues.

    Args:
        device: **[in]**  device the attr is get for.

        attr: **[in]**  attr to get.

        value: **[out]**  value for specific attr.

    Returns:
        A ``tuple`` of size 1 that contains (in that order):
        - #hipSuccess, #hipErrorInvalidDevice
    """
    if not isinstance(attr,_hipGraphMemAttributeType__Base):
        raise TypeError("argument 'attr' must be of type '_hipGraphMemAttributeType__Base'")
    _hipDeviceGetGraphMemAttribute__retval = hipError_t(chip.hipDeviceGetGraphMemAttribute(device,attr.value,
        <void *>hip._util.types.DataHandle.from_pyobj(value)._ptr))    # fully specified
    return (_hipDeviceGetGraphMemAttribute__retval,)


@cython.embedsignature(True)
def hipDeviceSetGraphMemAttribute(int device, object attr, object value):
    r"""Set the mem attribute for graphs.

    Warning:
        This API is marked as beta, meaning, while this is feature complete,
        it is still open to changes and may have outstanding issues.

    Args:
        device: **[in]**  device the attr is set for.

        attr: **[in]**  attr to set.

        value: **[in]**  value for specific attr.

    Returns:
        A ``tuple`` of size 1 that contains (in that order):
        - #hipSuccess, #hipErrorInvalidDevice
    """
    if not isinstance(attr,_hipGraphMemAttributeType__Base):
        raise TypeError("argument 'attr' must be of type '_hipGraphMemAttributeType__Base'")
    _hipDeviceSetGraphMemAttribute__retval = hipError_t(chip.hipDeviceSetGraphMemAttribute(device,attr.value,
        <void *>hip._util.types.DataHandle.from_pyobj(value)._ptr))    # fully specified
    return (_hipDeviceSetGraphMemAttribute__retval,)


@cython.embedsignature(True)
def hipDeviceGraphMemTrim(int device):
    r"""Free unused memory on specific device used for graph back to OS.

    Warning:
        This API is marked as beta, meaning, while this is feature complete,
        it is still open to changes and may have outstanding issues.

    Args:
        device: **[in]**  device the memory is used for graphs
    """
    _hipDeviceGraphMemTrim__retval = hipError_t(chip.hipDeviceGraphMemTrim(device))    # fully specified
    return (_hipDeviceGraphMemTrim__retval,)


@cython.embedsignature(True)
def hipUserObjectCreate(object ptr, object destroy, unsigned int initialRefcount, unsigned int flags):
    r"""Create an instance of userObject to manage lifetime of a resource.

    Warning:
        This API is marked as beta, meaning, while this is feature complete,
        it is still open to changes and may have outstanding issues.

    Args:
        ptr: **[in]**  pointer to pass to destroy function.

        destroy: **[in]**  destroy callback to remove resource.

        initialRefcount: **[in]**  reference to resource.

        flags: **[in]**  flags passed to API.

    Returns:
        A ``tuple`` of size 2 that contains (in that order):
        - #hipSuccess, #hipErrorInvalidValue
        - object_out:  pointer to instace of userobj.
    """
    object_out = hipUserObject.from_ptr(NULL)
    _hipUserObjectCreate__retval = hipError_t(chip.hipUserObjectCreate(&object_out._ptr,
        <void *>hip._util.types.DataHandle.from_pyobj(ptr)._ptr,
        hipHostFn_t.from_pyobj(destroy)._ptr,initialRefcount,flags))    # fully specified
    return (_hipUserObjectCreate__retval,object_out)


@cython.embedsignature(True)
def hipUserObjectRelease(object object, unsigned int count):
    r"""Release number of references to resource.

    Warning:
        This API is marked as beta, meaning, while this is feature complete,
        it is still open to changes and may have outstanding issues.

    Args:
        object: **[in]**  pointer to instace of userobj.

        count: **[in]**  reference to resource to be retained.

    Returns:
        A ``tuple`` of size 1 that contains (in that order):
        - #hipSuccess, #hipErrorInvalidValue
    """
    _hipUserObjectRelease__retval = hipError_t(chip.hipUserObjectRelease(
        hipUserObject.from_pyobj(object)._ptr,count))    # fully specified
    return (_hipUserObjectRelease__retval,)


@cython.embedsignature(True)
def hipUserObjectRetain(object object, unsigned int count):
    r"""Retain number of references to resource.

    Warning:
        This API is marked as beta, meaning, while this is feature complete,
        it is still open to changes and may have outstanding issues.

    Args:
        object: **[in]**  pointer to instace of userobj.

        count: **[in]**  reference to resource to be retained.

    Returns:
        A ``tuple`` of size 1 that contains (in that order):
        - #hipSuccess, #hipErrorInvalidValue
    """
    _hipUserObjectRetain__retval = hipError_t(chip.hipUserObjectRetain(
        hipUserObject.from_pyobj(object)._ptr,count))    # fully specified
    return (_hipUserObjectRetain__retval,)


@cython.embedsignature(True)
def hipGraphRetainUserObject(object graph, object object, unsigned int count, unsigned int flags):
    r"""Retain user object for graphs.

    Warning:
        This API is marked as beta, meaning, while this is feature complete,
        it is still open to changes and may have outstanding issues.

    Args:
        graph: **[in]**  pointer to graph to retain the user object for.

        object: **[in]**  pointer to instace of userobj.

        count: **[in]**  reference to resource to be retained.

        flags: **[in]**  flags passed to API.

    Returns:
        A ``tuple`` of size 1 that contains (in that order):
        - #hipSuccess, #hipErrorInvalidValue
    """
    _hipGraphRetainUserObject__retval = hipError_t(chip.hipGraphRetainUserObject(
        ihipGraph.from_pyobj(graph)._ptr,
        hipUserObject.from_pyobj(object)._ptr,count,flags))    # fully specified
    return (_hipGraphRetainUserObject__retval,)


@cython.embedsignature(True)
def hipGraphReleaseUserObject(object graph, object object, unsigned int count):
    r"""Release user object from graphs.

    Warning:
        This API is marked as beta, meaning, while this is feature complete,
        it is still open to changes and may have outstanding issues.

    Args:
        graph: **[in]**  pointer to graph to retain the user object for.

        object: **[in]**  pointer to instace of userobj.

        count: **[in]**  reference to resource to be retained.

    Returns:
        A ``tuple`` of size 1 that contains (in that order):
        - #hipSuccess, #hipErrorInvalidValue
    """
    _hipGraphReleaseUserObject__retval = hipError_t(chip.hipGraphReleaseUserObject(
        ihipGraph.from_pyobj(graph)._ptr,
        hipUserObject.from_pyobj(object)._ptr,count))    # fully specified
    return (_hipGraphReleaseUserObject__retval,)


@cython.embedsignature(True)
def hipMemAddressFree(object devPtr, unsigned long size):
    r"""Frees an address range reservation made via hipMemAddressReserve

    Warning:
        This API is marked as beta, meaning, while this is feature complete,
        it is still open to changes and may have outstanding issues.

    Args:
        devPtr: **[in]**  starting address of the range.

        size: **[in]**  size of the range.

    Returns:
        A ``tuple`` of size 1 that contains (in that order):
        - #hipSuccess, #hipErrorInvalidValue, #hipErrorNotSupported
    """
    _hipMemAddressFree__retval = hipError_t(chip.hipMemAddressFree(
        <void *>hip._util.types.DataHandle.from_pyobj(devPtr)._ptr,size))    # fully specified
    return (_hipMemAddressFree__retval,)


@cython.embedsignature(True)
def hipMemAddressReserve(unsigned long size, unsigned long alignment, object addr, unsigned long long flags):
    r"""Reserves an address range

    Warning:
        This API is marked as beta, meaning, while this is feature complete,
        it is still open to changes and may have outstanding issues.

    Args:
        size: **[in]**  size of the reservation.

        alignment: **[in]**  alignment of the address.

        addr: **[in]**  requested starting address of the range.

        flags: **[in]**  currently unused, must be zero.

    Returns:
        A ``tuple`` of size 2 that contains (in that order):
        - #hipSuccess, #hipErrorInvalidValue, #hipErrorNotSupported
        - ptr:  starting address of the reserved range.
    """
    ptr = hip._util.types.DataHandle.from_ptr(NULL)
    _hipMemAddressReserve__retval = hipError_t(chip.hipMemAddressReserve(
        <void **>&ptr._ptr,size,alignment,
        <void *>hip._util.types.DataHandle.from_pyobj(addr)._ptr,flags))    # fully specified
    return (_hipMemAddressReserve__retval,ptr)


@cython.embedsignature(True)
def hipMemCreate(unsigned long size, object prop, unsigned long long flags):
    r"""Creates a memory allocation described by the properties and size

    Warning:
        This API is marked as beta, meaning, while this is feature complete,
        it is still open to changes and may have outstanding issues.

    Args:
        size: **[in]**  size of the allocation.

        prop: **[in]**  properties of the allocation.

        flags: **[in]**  currently unused, must be zero.

    Returns:
        A ``tuple`` of size 2 that contains (in that order):
        - #hipSuccess, #hipErrorInvalidValue, #hipErrorNotSupported
        - handle:  value of the returned handle.
    """
    handle = ihipMemGenericAllocationHandle.from_ptr(NULL)
    _hipMemCreate__retval = hipError_t(chip.hipMemCreate(&handle._ptr,size,
        hipMemAllocationProp.from_pyobj(prop)._ptr,flags))    # fully specified
    return (_hipMemCreate__retval,handle)


@cython.embedsignature(True)
def hipMemExportToShareableHandle(object shareableHandle, object handle, object handleType, unsigned long long flags):
    r"""Exports an allocation to a requested shareable handle type.

    Warning:
        This API is marked as beta, meaning, while this is feature complete,
        it is still open to changes and may have outstanding issues.

    Args:
        shareableHandle: **[out]**  value of the returned handle.

        handle: **[in]**  handle to share.

        handleType: **[in]**  type of the shareable handle.

        flags: **[in]**  currently unused, must be zero.

    Returns:
        A ``tuple`` of size 1 that contains (in that order):
        - #hipSuccess, #hipErrorInvalidValue, #hipErrorNotSupported
    """
    if not isinstance(handleType,_hipMemAllocationHandleType__Base):
        raise TypeError("argument 'handleType' must be of type '_hipMemAllocationHandleType__Base'")
    _hipMemExportToShareableHandle__retval = hipError_t(chip.hipMemExportToShareableHandle(
        <void *>hip._util.types.DataHandle.from_pyobj(shareableHandle)._ptr,
        ihipMemGenericAllocationHandle.from_pyobj(handle)._ptr,handleType.value,flags))    # fully specified
    return (_hipMemExportToShareableHandle__retval,)


@cython.embedsignature(True)
def hipMemGetAccess(object location, object ptr):
    r"""Get the access flags set for the given location and ptr.

    Warning:
        This API is marked as beta, meaning, while this is feature complete,
        it is still open to changes and may have outstanding issues.

    Args:
        location: **[in]**  target location.

        ptr: **[in]**  address to check the access flags.

    Returns:
        A ``tuple`` of size 2 that contains (in that order):
        - #hipSuccess, #hipErrorInvalidValue, #hipErrorNotSupported
        - flags:  flags for this location.
    """
    cdef unsigned long long flags
    _hipMemGetAccess__retval = hipError_t(chip.hipMemGetAccess(&flags,
        hipMemLocation.from_pyobj(location)._ptr,
        <void *>hip._util.types.DataHandle.from_pyobj(ptr)._ptr))    # fully specified
    return (_hipMemGetAccess__retval,flags)


@cython.embedsignature(True)
def hipMemGetAllocationGranularity(object prop, object option):
    r"""Calculates either the minimal or recommended granularity.

    Warning:
        This API is marked as beta, meaning, while this is feature complete,
        it is still open to changes and may have outstanding issues.

    Args:
        prop: **[in]**  location properties.

        option: **[in]**  determines which granularity to return.

    Returns:
        A ``tuple`` of size 2 that contains (in that order):
        - #hipSuccess, #hipErrorInvalidValue, #hipErrorNotSupported
        - granularity:  returned granularity.
    """
    cdef unsigned long granularity
    if not isinstance(option,_hipMemAllocationGranularity_flags__Base):
        raise TypeError("argument 'option' must be of type '_hipMemAllocationGranularity_flags__Base'")
    _hipMemGetAllocationGranularity__retval = hipError_t(chip.hipMemGetAllocationGranularity(&granularity,
        hipMemAllocationProp.from_pyobj(prop)._ptr,option.value))    # fully specified
    return (_hipMemGetAllocationGranularity__retval,granularity)


@cython.embedsignature(True)
def hipMemGetAllocationPropertiesFromHandle(object prop, object handle):
    r"""Retrieve the property structure of the given handle.

    Warning:
        This API is marked as beta, meaning, while this is feature complete,
        it is still open to changes and may have outstanding issues.

    Args:
        prop: **[out]**  properties of the given handle.

        handle: **[in]**  handle to perform the query on.

    Returns:
        A ``tuple`` of size 1 that contains (in that order):
        - #hipSuccess, #hipErrorInvalidValue, #hipErrorNotSupported
    """
    _hipMemGetAllocationPropertiesFromHandle__retval = hipError_t(chip.hipMemGetAllocationPropertiesFromHandle(
        hipMemAllocationProp.from_pyobj(prop)._ptr,
        ihipMemGenericAllocationHandle.from_pyobj(handle)._ptr))    # fully specified
    return (_hipMemGetAllocationPropertiesFromHandle__retval,)


@cython.embedsignature(True)
def hipMemImportFromShareableHandle(object osHandle, object shHandleType):
    r"""Imports an allocation from a requested shareable handle type.

    Warning:
        This API is marked as beta, meaning, while this is feature complete,
        it is still open to changes and may have outstanding issues.

    Args:
        osHandle: **[in]**  shareable handle representing the memory allocation.

        shHandleType: **[in]**  handle type.

    Returns:
        A ``tuple`` of size 2 that contains (in that order):
        - #hipSuccess, #hipErrorInvalidValue, #hipErrorNotSupported
        - handle:  returned value.
    """
    handle = ihipMemGenericAllocationHandle.from_ptr(NULL)
    if not isinstance(shHandleType,_hipMemAllocationHandleType__Base):
        raise TypeError("argument 'shHandleType' must be of type '_hipMemAllocationHandleType__Base'")
    _hipMemImportFromShareableHandle__retval = hipError_t(chip.hipMemImportFromShareableHandle(&handle._ptr,
        <void *>hip._util.types.DataHandle.from_pyobj(osHandle)._ptr,shHandleType.value))    # fully specified
    return (_hipMemImportFromShareableHandle__retval,handle)


@cython.embedsignature(True)
def hipMemMap(object ptr, unsigned long size, unsigned long offset, object handle, unsigned long long flags):
    r"""Maps an allocation handle to a reserved virtual address range.

    Warning:
        This API is marked as beta, meaning, while this is feature complete,
        it is still open to changes and may have outstanding issues.

    Args:
        ptr: **[in]**  address where the memory will be mapped.

        size: **[in]**  size of the mapping.

        offset: **[in]**  offset into the memory, currently must be zero.

        handle: **[in]**  memory allocation to be mapped.

        flags: **[in]**  currently unused, must be zero.

    Returns:
        A ``tuple`` of size 1 that contains (in that order):
        - #hipSuccess, #hipErrorInvalidValue, #hipErrorNotSupported
    """
    _hipMemMap__retval = hipError_t(chip.hipMemMap(
        <void *>hip._util.types.DataHandle.from_pyobj(ptr)._ptr,size,offset,
        ihipMemGenericAllocationHandle.from_pyobj(handle)._ptr,flags))    # fully specified
    return (_hipMemMap__retval,)


@cython.embedsignature(True)
def hipMemMapArrayAsync(object mapInfoList, unsigned int count, object stream):
    r"""Maps or unmaps subregions of sparse HIP arrays and sparse HIP mipmapped arrays.

    Warning:
        This API is marked as beta, meaning, while this is feature complete,
        it is still open to changes and may have outstanding issues.

    Args:
        mapInfoList: **[in]**  list of hipArrayMapInfo.

        count: **[in]**  number of hipArrayMapInfo in mapInfoList.

        stream: **[in]**  stream identifier for the stream to use for map or unmap operations.

    Returns:
        A ``tuple`` of size 1 that contains (in that order):
        - #hipSuccess, #hipErrorInvalidValue, #hipErrorNotSupported
    """
    _hipMemMapArrayAsync__retval = hipError_t(chip.hipMemMapArrayAsync(
        hipArrayMapInfo.from_pyobj(mapInfoList)._ptr,count,
        ihipStream_t.from_pyobj(stream)._ptr))    # fully specified
    return (_hipMemMapArrayAsync__retval,)


@cython.embedsignature(True)
def hipMemRelease(object handle):
    r"""Release a memory handle representing a memory allocation which was previously allocated through hipMemCreate.

    Warning:
        This API is marked as beta, meaning, while this is feature complete,
        it is still open to changes and may have outstanding issues.

    Args:
        handle: **[in]**  handle of the memory allocation.

    Returns:
        A ``tuple`` of size 1 that contains (in that order):
        - #hipSuccess, #hipErrorInvalidValue, #hipErrorNotSupported
    """
    _hipMemRelease__retval = hipError_t(chip.hipMemRelease(
        ihipMemGenericAllocationHandle.from_pyobj(handle)._ptr))    # fully specified
    return (_hipMemRelease__retval,)


@cython.embedsignature(True)
def hipMemRetainAllocationHandle(object addr):
    r"""Returns the allocation handle of the backing memory allocation given the address.

    Warning:
        This API is marked as beta, meaning, while this is feature complete,
        it is still open to changes and may have outstanding issues.

    Args:
        addr: **[in]**  address to look up.

    Returns:
        A ``tuple`` of size 2 that contains (in that order):
        - #hipSuccess, #hipErrorInvalidValue, #hipErrorNotSupported
        - handle:  handle representing addr.
    """
    handle = ihipMemGenericAllocationHandle.from_ptr(NULL)
    _hipMemRetainAllocationHandle__retval = hipError_t(chip.hipMemRetainAllocationHandle(&handle._ptr,
        <void *>hip._util.types.DataHandle.from_pyobj(addr)._ptr))    # fully specified
    return (_hipMemRetainAllocationHandle__retval,handle)


@cython.embedsignature(True)
def hipMemSetAccess(object ptr, unsigned long size, object desc, unsigned long count):
    r"""Set the access flags for each location specified in desc for the given virtual address range.

    Warning:
        This API is marked as beta, meaning, while this is feature complete,
        it is still open to changes and may have outstanding issues.

    Args:
        ptr: **[in]**  starting address of the virtual address range.

        size: **[in]**  size of the range.

        desc: **[in]**  array of hipMemAccessDesc.

        count: **[in]**  number of hipMemAccessDesc in desc.

    Returns:
        A ``tuple`` of size 1 that contains (in that order):
        - #hipSuccess, #hipErrorInvalidValue, #hipErrorNotSupported
    """
    _hipMemSetAccess__retval = hipError_t(chip.hipMemSetAccess(
        <void *>hip._util.types.DataHandle.from_pyobj(ptr)._ptr,size,
        hipMemAccessDesc.from_pyobj(desc)._ptr,count))    # fully specified
    return (_hipMemSetAccess__retval,)


@cython.embedsignature(True)
def hipMemUnmap(object ptr, unsigned long size):
    r"""Unmap memory allocation of a given address range.

    Warning:
        This API is marked as beta, meaning, while this is feature complete,
        it is still open to changes and may have outstanding issues.

    Args:
        ptr: **[in]**  starting address of the range to unmap.

        size: **[in]**  size of the virtual address range.

    Returns:
        A ``tuple`` of size 1 that contains (in that order):
        - #hipSuccess, #hipErrorInvalidValue, #hipErrorNotSupported
    """
    _hipMemUnmap__retval = hipError_t(chip.hipMemUnmap(
        <void *>hip._util.types.DataHandle.from_pyobj(ptr)._ptr,size))    # fully specified
    return (_hipMemUnmap__retval,)


@cython.embedsignature(True)
def hipGLGetDevices(unsigned int hipDeviceCount, object deviceList):
    r"""(No short description)
    """
    cdef unsigned int pHipDeviceCount
    cdef int pHipDevices
    if not isinstance(deviceList,_hipGLDeviceList__Base):
        raise TypeError("argument 'deviceList' must be of type '_hipGLDeviceList__Base'")
    _hipGLGetDevices__retval = hipError_t(chip.hipGLGetDevices(&pHipDeviceCount,&pHipDevices,hipDeviceCount,deviceList.value))    # fully specified
    return (_hipGLGetDevices__retval,pHipDeviceCount,pHipDevices)


@cython.embedsignature(True)
def hipGraphicsGLRegisterBuffer(unsigned int buffer, unsigned int flags):
    r"""(No short description)
    """
    resource = _hipGraphicsResource.from_ptr(NULL)
    _hipGraphicsGLRegisterBuffer__retval = hipError_t(chip.hipGraphicsGLRegisterBuffer(&resource._ptr,buffer,flags))    # fully specified
    return (_hipGraphicsGLRegisterBuffer__retval,resource)


@cython.embedsignature(True)
def hipGraphicsGLRegisterImage(unsigned int image, unsigned int target, unsigned int flags):
    r"""(No short description)
    """
    resource = _hipGraphicsResource.from_ptr(NULL)
    _hipGraphicsGLRegisterImage__retval = hipError_t(chip.hipGraphicsGLRegisterImage(&resource._ptr,image,target,flags))    # fully specified
    return (_hipGraphicsGLRegisterImage__retval,resource)


@cython.embedsignature(True)
def hipGraphicsMapResources(int count, object stream):
    r"""(No short description)
    """
    resources = _hipGraphicsResource.from_ptr(NULL)
    _hipGraphicsMapResources__retval = hipError_t(chip.hipGraphicsMapResources(count,&resources._ptr,
        ihipStream_t.from_pyobj(stream)._ptr))    # fully specified
    return (_hipGraphicsMapResources__retval,resources)


@cython.embedsignature(True)
def hipGraphicsSubResourceGetMappedArray(object resource, unsigned int arrayIndex, unsigned int mipLevel):
    r"""(No short description)
    """
    array = hipArray.from_ptr(NULL)
    _hipGraphicsSubResourceGetMappedArray__retval = hipError_t(chip.hipGraphicsSubResourceGetMappedArray(&array._ptr,
        _hipGraphicsResource.from_pyobj(resource)._ptr,arrayIndex,mipLevel))    # fully specified
    return (_hipGraphicsSubResourceGetMappedArray__retval,array)


@cython.embedsignature(True)
def hipGraphicsResourceGetMappedPointer(object resource):
    r"""(No short description)
    """
    devPtr = hip._util.types.DataHandle.from_ptr(NULL)
    cdef unsigned long size
    _hipGraphicsResourceGetMappedPointer__retval = hipError_t(chip.hipGraphicsResourceGetMappedPointer(
        <void **>&devPtr._ptr,&size,
        _hipGraphicsResource.from_pyobj(resource)._ptr))    # fully specified
    return (_hipGraphicsResourceGetMappedPointer__retval,devPtr,size)


@cython.embedsignature(True)
def hipGraphicsUnmapResources(int count, object stream):
    r"""(No short description)
    """
    resources = _hipGraphicsResource.from_ptr(NULL)
    _hipGraphicsUnmapResources__retval = hipError_t(chip.hipGraphicsUnmapResources(count,&resources._ptr,
        ihipStream_t.from_pyobj(stream)._ptr))    # fully specified
    return (_hipGraphicsUnmapResources__retval,resources)


@cython.embedsignature(True)
def hipGraphicsUnregisterResource(object resource):
    r"""(No short description)
    """
    _hipGraphicsUnregisterResource__retval = hipError_t(chip.hipGraphicsUnregisterResource(
        _hipGraphicsResource.from_pyobj(resource)._ptr))    # fully specified
    return (_hipGraphicsUnregisterResource__retval,)


@cython.embedsignature(True)
def hipMemcpy_spt(object dst, object src, unsigned long sizeBytes, object kind):
    r"""(No short description)
    """
    if not isinstance(kind,_hipMemcpyKind__Base):
        raise TypeError("argument 'kind' must be of type '_hipMemcpyKind__Base'")
    _hipMemcpy_spt__retval = hipError_t(chip.hipMemcpy_spt(
        <void *>hip._util.types.DataHandle.from_pyobj(dst)._ptr,
        <const void *>hip._util.types.DataHandle.from_pyobj(src)._ptr,sizeBytes,kind.value))    # fully specified
    return (_hipMemcpy_spt__retval,)


@cython.embedsignature(True)
def hipMemcpyToSymbol_spt(object symbol, object src, unsigned long sizeBytes, unsigned long offset, object kind):
    r"""(No short description)
    """
    if not isinstance(kind,_hipMemcpyKind__Base):
        raise TypeError("argument 'kind' must be of type '_hipMemcpyKind__Base'")
    _hipMemcpyToSymbol_spt__retval = hipError_t(chip.hipMemcpyToSymbol_spt(
        <const void *>hip._util.types.DataHandle.from_pyobj(symbol)._ptr,
        <const void *>hip._util.types.DataHandle.from_pyobj(src)._ptr,sizeBytes,offset,kind.value))    # fully specified
    return (_hipMemcpyToSymbol_spt__retval,)


@cython.embedsignature(True)
def hipMemcpyFromSymbol_spt(object dst, object symbol, unsigned long sizeBytes, unsigned long offset, object kind):
    r"""(No short description)
    """
    if not isinstance(kind,_hipMemcpyKind__Base):
        raise TypeError("argument 'kind' must be of type '_hipMemcpyKind__Base'")
    _hipMemcpyFromSymbol_spt__retval = hipError_t(chip.hipMemcpyFromSymbol_spt(
        <void *>hip._util.types.DataHandle.from_pyobj(dst)._ptr,
        <const void *>hip._util.types.DataHandle.from_pyobj(symbol)._ptr,sizeBytes,offset,kind.value))    # fully specified
    return (_hipMemcpyFromSymbol_spt__retval,)


@cython.embedsignature(True)
def hipMemcpy2D_spt(object dst, unsigned long dpitch, object src, unsigned long spitch, unsigned long width, unsigned long height, object kind):
    r"""(No short description)
    """
    if not isinstance(kind,_hipMemcpyKind__Base):
        raise TypeError("argument 'kind' must be of type '_hipMemcpyKind__Base'")
    _hipMemcpy2D_spt__retval = hipError_t(chip.hipMemcpy2D_spt(
        <void *>hip._util.types.DataHandle.from_pyobj(dst)._ptr,dpitch,
        <const void *>hip._util.types.DataHandle.from_pyobj(src)._ptr,spitch,width,height,kind.value))    # fully specified
    return (_hipMemcpy2D_spt__retval,)


@cython.embedsignature(True)
def hipMemcpy2DFromArray_spt(object dst, unsigned long dpitch, object src, unsigned long wOffset, unsigned long hOffset, unsigned long width, unsigned long height, object kind):
    r"""(No short description)
    """
    if not isinstance(kind,_hipMemcpyKind__Base):
        raise TypeError("argument 'kind' must be of type '_hipMemcpyKind__Base'")
    _hipMemcpy2DFromArray_spt__retval = hipError_t(chip.hipMemcpy2DFromArray_spt(
        <void *>hip._util.types.DataHandle.from_pyobj(dst)._ptr,dpitch,
        hipArray.from_pyobj(src)._ptr,wOffset,hOffset,width,height,kind.value))    # fully specified
    return (_hipMemcpy2DFromArray_spt__retval,)


@cython.embedsignature(True)
def hipMemcpy3D_spt(object p):
    r"""(No short description)
    """
    _hipMemcpy3D_spt__retval = hipError_t(chip.hipMemcpy3D_spt(
        hipMemcpy3DParms.from_pyobj(p)._ptr))    # fully specified
    return (_hipMemcpy3D_spt__retval,)


@cython.embedsignature(True)
def hipMemset_spt(object dst, int value, unsigned long sizeBytes):
    r"""(No short description)
    """
    _hipMemset_spt__retval = hipError_t(chip.hipMemset_spt(
        <void *>hip._util.types.DataHandle.from_pyobj(dst)._ptr,value,sizeBytes))    # fully specified
    return (_hipMemset_spt__retval,)


@cython.embedsignature(True)
def hipMemsetAsync_spt(object dst, int value, unsigned long sizeBytes, object stream):
    r"""(No short description)
    """
    _hipMemsetAsync_spt__retval = hipError_t(chip.hipMemsetAsync_spt(
        <void *>hip._util.types.DataHandle.from_pyobj(dst)._ptr,value,sizeBytes,
        ihipStream_t.from_pyobj(stream)._ptr))    # fully specified
    return (_hipMemsetAsync_spt__retval,)


@cython.embedsignature(True)
def hipMemset2D_spt(object dst, unsigned long pitch, int value, unsigned long width, unsigned long height):
    r"""(No short description)
    """
    _hipMemset2D_spt__retval = hipError_t(chip.hipMemset2D_spt(
        <void *>hip._util.types.DataHandle.from_pyobj(dst)._ptr,pitch,value,width,height))    # fully specified
    return (_hipMemset2D_spt__retval,)


@cython.embedsignature(True)
def hipMemset2DAsync_spt(object dst, unsigned long pitch, int value, unsigned long width, unsigned long height, object stream):
    r"""(No short description)
    """
    _hipMemset2DAsync_spt__retval = hipError_t(chip.hipMemset2DAsync_spt(
        <void *>hip._util.types.DataHandle.from_pyobj(dst)._ptr,pitch,value,width,height,
        ihipStream_t.from_pyobj(stream)._ptr))    # fully specified
    return (_hipMemset2DAsync_spt__retval,)


@cython.embedsignature(True)
def hipMemset3DAsync_spt(object pitchedDevPtr, int value, object extent, object stream):
    r"""(No short description)
    """
    _hipMemset3DAsync_spt__retval = hipError_t(chip.hipMemset3DAsync_spt(
        hipPitchedPtr.from_pyobj(pitchedDevPtr)._ptr[0],value,
        hipExtent.from_pyobj(extent)._ptr[0],
        ihipStream_t.from_pyobj(stream)._ptr))    # fully specified
    return (_hipMemset3DAsync_spt__retval,)


@cython.embedsignature(True)
def hipMemset3D_spt(object pitchedDevPtr, int value, object extent):
    r"""(No short description)
    """
    _hipMemset3D_spt__retval = hipError_t(chip.hipMemset3D_spt(
        hipPitchedPtr.from_pyobj(pitchedDevPtr)._ptr[0],value,
        hipExtent.from_pyobj(extent)._ptr[0]))    # fully specified
    return (_hipMemset3D_spt__retval,)


@cython.embedsignature(True)
def hipMemcpyAsync_spt(object dst, object src, unsigned long sizeBytes, object kind, object stream):
    r"""(No short description)
    """
    if not isinstance(kind,_hipMemcpyKind__Base):
        raise TypeError("argument 'kind' must be of type '_hipMemcpyKind__Base'")
    _hipMemcpyAsync_spt__retval = hipError_t(chip.hipMemcpyAsync_spt(
        <void *>hip._util.types.DataHandle.from_pyobj(dst)._ptr,
        <const void *>hip._util.types.DataHandle.from_pyobj(src)._ptr,sizeBytes,kind.value,
        ihipStream_t.from_pyobj(stream)._ptr))    # fully specified
    return (_hipMemcpyAsync_spt__retval,)


@cython.embedsignature(True)
def hipMemcpy3DAsync_spt(object p, object stream):
    r"""(No short description)
    """
    _hipMemcpy3DAsync_spt__retval = hipError_t(chip.hipMemcpy3DAsync_spt(
        hipMemcpy3DParms.from_pyobj(p)._ptr,
        ihipStream_t.from_pyobj(stream)._ptr))    # fully specified
    return (_hipMemcpy3DAsync_spt__retval,)


@cython.embedsignature(True)
def hipMemcpy2DAsync_spt(object dst, unsigned long dpitch, object src, unsigned long spitch, unsigned long width, unsigned long height, object kind, object stream):
    r"""(No short description)
    """
    if not isinstance(kind,_hipMemcpyKind__Base):
        raise TypeError("argument 'kind' must be of type '_hipMemcpyKind__Base'")
    _hipMemcpy2DAsync_spt__retval = hipError_t(chip.hipMemcpy2DAsync_spt(
        <void *>hip._util.types.DataHandle.from_pyobj(dst)._ptr,dpitch,
        <const void *>hip._util.types.DataHandle.from_pyobj(src)._ptr,spitch,width,height,kind.value,
        ihipStream_t.from_pyobj(stream)._ptr))    # fully specified
    return (_hipMemcpy2DAsync_spt__retval,)


@cython.embedsignature(True)
def hipMemcpyFromSymbolAsync_spt(object dst, object symbol, unsigned long sizeBytes, unsigned long offset, object kind, object stream):
    r"""(No short description)
    """
    if not isinstance(kind,_hipMemcpyKind__Base):
        raise TypeError("argument 'kind' must be of type '_hipMemcpyKind__Base'")
    _hipMemcpyFromSymbolAsync_spt__retval = hipError_t(chip.hipMemcpyFromSymbolAsync_spt(
        <void *>hip._util.types.DataHandle.from_pyobj(dst)._ptr,
        <const void *>hip._util.types.DataHandle.from_pyobj(symbol)._ptr,sizeBytes,offset,kind.value,
        ihipStream_t.from_pyobj(stream)._ptr))    # fully specified
    return (_hipMemcpyFromSymbolAsync_spt__retval,)


@cython.embedsignature(True)
def hipMemcpyToSymbolAsync_spt(object symbol, object src, unsigned long sizeBytes, unsigned long offset, object kind, object stream):
    r"""(No short description)
    """
    if not isinstance(kind,_hipMemcpyKind__Base):
        raise TypeError("argument 'kind' must be of type '_hipMemcpyKind__Base'")
    _hipMemcpyToSymbolAsync_spt__retval = hipError_t(chip.hipMemcpyToSymbolAsync_spt(
        <const void *>hip._util.types.DataHandle.from_pyobj(symbol)._ptr,
        <const void *>hip._util.types.DataHandle.from_pyobj(src)._ptr,sizeBytes,offset,kind.value,
        ihipStream_t.from_pyobj(stream)._ptr))    # fully specified
    return (_hipMemcpyToSymbolAsync_spt__retval,)


@cython.embedsignature(True)
def hipMemcpyFromArray_spt(object dst, object src, unsigned long wOffsetSrc, unsigned long hOffset, unsigned long count, object kind):
    r"""(No short description)
    """
    if not isinstance(kind,_hipMemcpyKind__Base):
        raise TypeError("argument 'kind' must be of type '_hipMemcpyKind__Base'")
    _hipMemcpyFromArray_spt__retval = hipError_t(chip.hipMemcpyFromArray_spt(
        <void *>hip._util.types.DataHandle.from_pyobj(dst)._ptr,
        hipArray.from_pyobj(src)._ptr,wOffsetSrc,hOffset,count,kind.value))    # fully specified
    return (_hipMemcpyFromArray_spt__retval,)


@cython.embedsignature(True)
def hipMemcpy2DToArray_spt(object dst, unsigned long wOffset, unsigned long hOffset, object src, unsigned long spitch, unsigned long width, unsigned long height, object kind):
    r"""(No short description)
    """
    if not isinstance(kind,_hipMemcpyKind__Base):
        raise TypeError("argument 'kind' must be of type '_hipMemcpyKind__Base'")
    _hipMemcpy2DToArray_spt__retval = hipError_t(chip.hipMemcpy2DToArray_spt(
        hipArray.from_pyobj(dst)._ptr,wOffset,hOffset,
        <const void *>hip._util.types.DataHandle.from_pyobj(src)._ptr,spitch,width,height,kind.value))    # fully specified
    return (_hipMemcpy2DToArray_spt__retval,)


@cython.embedsignature(True)
def hipMemcpy2DFromArrayAsync_spt(object dst, unsigned long dpitch, object src, unsigned long wOffsetSrc, unsigned long hOffsetSrc, unsigned long width, unsigned long height, object kind, object stream):
    r"""(No short description)
    """
    if not isinstance(kind,_hipMemcpyKind__Base):
        raise TypeError("argument 'kind' must be of type '_hipMemcpyKind__Base'")
    _hipMemcpy2DFromArrayAsync_spt__retval = hipError_t(chip.hipMemcpy2DFromArrayAsync_spt(
        <void *>hip._util.types.DataHandle.from_pyobj(dst)._ptr,dpitch,
        hipArray.from_pyobj(src)._ptr,wOffsetSrc,hOffsetSrc,width,height,kind.value,
        ihipStream_t.from_pyobj(stream)._ptr))    # fully specified
    return (_hipMemcpy2DFromArrayAsync_spt__retval,)


@cython.embedsignature(True)
def hipMemcpy2DToArrayAsync_spt(object dst, unsigned long wOffset, unsigned long hOffset, object src, unsigned long spitch, unsigned long width, unsigned long height, object kind, object stream):
    r"""(No short description)
    """
    if not isinstance(kind,_hipMemcpyKind__Base):
        raise TypeError("argument 'kind' must be of type '_hipMemcpyKind__Base'")
    _hipMemcpy2DToArrayAsync_spt__retval = hipError_t(chip.hipMemcpy2DToArrayAsync_spt(
        hipArray.from_pyobj(dst)._ptr,wOffset,hOffset,
        <const void *>hip._util.types.DataHandle.from_pyobj(src)._ptr,spitch,width,height,kind.value,
        ihipStream_t.from_pyobj(stream)._ptr))    # fully specified
    return (_hipMemcpy2DToArrayAsync_spt__retval,)


@cython.embedsignature(True)
def hipStreamQuery_spt(object stream):
    r"""(No short description)
    """
    _hipStreamQuery_spt__retval = hipError_t(chip.hipStreamQuery_spt(
        ihipStream_t.from_pyobj(stream)._ptr))    # fully specified
    return (_hipStreamQuery_spt__retval,)


@cython.embedsignature(True)
def hipStreamSynchronize_spt(object stream):
    r"""(No short description)
    """
    _hipStreamSynchronize_spt__retval = hipError_t(chip.hipStreamSynchronize_spt(
        ihipStream_t.from_pyobj(stream)._ptr))    # fully specified
    return (_hipStreamSynchronize_spt__retval,)


@cython.embedsignature(True)
def hipStreamGetPriority_spt(object stream):
    r"""(No short description)
    """
    cdef int priority
    _hipStreamGetPriority_spt__retval = hipError_t(chip.hipStreamGetPriority_spt(
        ihipStream_t.from_pyobj(stream)._ptr,&priority))    # fully specified
    return (_hipStreamGetPriority_spt__retval,priority)


@cython.embedsignature(True)
def hipStreamWaitEvent_spt(object stream, object event, unsigned int flags):
    r"""(No short description)
    """
    _hipStreamWaitEvent_spt__retval = hipError_t(chip.hipStreamWaitEvent_spt(
        ihipStream_t.from_pyobj(stream)._ptr,
        ihipEvent_t.from_pyobj(event)._ptr,flags))    # fully specified
    return (_hipStreamWaitEvent_spt__retval,)


@cython.embedsignature(True)
def hipStreamGetFlags_spt(object stream):
    r"""(No short description)
    """
    cdef unsigned int flags
    _hipStreamGetFlags_spt__retval = hipError_t(chip.hipStreamGetFlags_spt(
        ihipStream_t.from_pyobj(stream)._ptr,&flags))    # fully specified
    return (_hipStreamGetFlags_spt__retval,flags)


@cython.embedsignature(True)
def hipStreamAddCallback_spt(object stream, object callback, object userData, unsigned int flags):
    r"""(No short description)
    """
    _hipStreamAddCallback_spt__retval = hipError_t(chip.hipStreamAddCallback_spt(
        ihipStream_t.from_pyobj(stream)._ptr,
        hipStreamCallback_t.from_pyobj(callback)._ptr,
        <void *>hip._util.types.DataHandle.from_pyobj(userData)._ptr,flags))    # fully specified
    return (_hipStreamAddCallback_spt__retval,)


@cython.embedsignature(True)
def hipEventRecord_spt(object event, object stream):
    r"""(No short description)
    """
    _hipEventRecord_spt__retval = hipError_t(chip.hipEventRecord_spt(
        ihipEvent_t.from_pyobj(event)._ptr,
        ihipStream_t.from_pyobj(stream)._ptr))    # fully specified
    return (_hipEventRecord_spt__retval,)


@cython.embedsignature(True)
def hipLaunchCooperativeKernel_spt(object f, object gridDim, object blockDim, object kernelParams, unsigned int sharedMemBytes, object hStream):
    r"""(No short description)
    """
    _hipLaunchCooperativeKernel_spt__retval = hipError_t(chip.hipLaunchCooperativeKernel_spt(
        <const void *>hip._util.types.DataHandle.from_pyobj(f)._ptr,
        dim3.from_pyobj(gridDim)._ptr[0],
        dim3.from_pyobj(blockDim)._ptr[0],
        <void **>hip._util.types.DataHandle.from_pyobj(kernelParams)._ptr,sharedMemBytes,
        ihipStream_t.from_pyobj(hStream)._ptr))    # fully specified
    return (_hipLaunchCooperativeKernel_spt__retval,)


@cython.embedsignature(True)
def hipLaunchKernel_spt(object function_address, object numBlocks, object dimBlocks, object args, unsigned long sharedMemBytes, object stream):
    r"""(No short description)
    """
    _hipLaunchKernel_spt__retval = hipError_t(chip.hipLaunchKernel_spt(
        <const void *>hip._util.types.DataHandle.from_pyobj(function_address)._ptr,
        dim3.from_pyobj(numBlocks)._ptr[0],
        dim3.from_pyobj(dimBlocks)._ptr[0],
        <void **>hip._util.types.DataHandle.from_pyobj(args)._ptr,sharedMemBytes,
        ihipStream_t.from_pyobj(stream)._ptr))    # fully specified
    return (_hipLaunchKernel_spt__retval,)


@cython.embedsignature(True)
def hipGraphLaunch_spt(object graphExec, object stream):
    r"""(No short description)
    """
    _hipGraphLaunch_spt__retval = hipError_t(chip.hipGraphLaunch_spt(
        hipGraphExec.from_pyobj(graphExec)._ptr,
        ihipStream_t.from_pyobj(stream)._ptr))    # fully specified
    return (_hipGraphLaunch_spt__retval,)


@cython.embedsignature(True)
def hipStreamBeginCapture_spt(object stream, object mode):
    r"""(No short description)
    """
    if not isinstance(mode,_hipStreamCaptureMode__Base):
        raise TypeError("argument 'mode' must be of type '_hipStreamCaptureMode__Base'")
    _hipStreamBeginCapture_spt__retval = hipError_t(chip.hipStreamBeginCapture_spt(
        ihipStream_t.from_pyobj(stream)._ptr,mode.value))    # fully specified
    return (_hipStreamBeginCapture_spt__retval,)


@cython.embedsignature(True)
def hipStreamEndCapture_spt(object stream):
    r"""(No short description)
    """
    pGraph = ihipGraph.from_ptr(NULL)
    _hipStreamEndCapture_spt__retval = hipError_t(chip.hipStreamEndCapture_spt(
        ihipStream_t.from_pyobj(stream)._ptr,&pGraph._ptr))    # fully specified
    return (_hipStreamEndCapture_spt__retval,pGraph)


@cython.embedsignature(True)
def hipStreamIsCapturing_spt(object stream):
    r"""(No short description)
    """
    cdef chip.hipStreamCaptureStatus pCaptureStatus
    _hipStreamIsCapturing_spt__retval = hipError_t(chip.hipStreamIsCapturing_spt(
        ihipStream_t.from_pyobj(stream)._ptr,&pCaptureStatus))    # fully specified
    return (_hipStreamIsCapturing_spt__retval,hipStreamCaptureStatus(pCaptureStatus))


@cython.embedsignature(True)
def hipStreamGetCaptureInfo_spt(object stream):
    r"""(No short description)
    """
    cdef chip.hipStreamCaptureStatus pCaptureStatus
    cdef unsigned long long pId
    _hipStreamGetCaptureInfo_spt__retval = hipError_t(chip.hipStreamGetCaptureInfo_spt(
        ihipStream_t.from_pyobj(stream)._ptr,&pCaptureStatus,&pId))    # fully specified
    return (_hipStreamGetCaptureInfo_spt__retval,hipStreamCaptureStatus(pCaptureStatus),pId)


@cython.embedsignature(True)
def hipStreamGetCaptureInfo_v2_spt(object stream, object dependencies_out):
    r"""(No short description)
    """
    cdef chip.hipStreamCaptureStatus captureStatus_out
    cdef unsigned long long id_out
    graph_out = ihipGraph.from_ptr(NULL)
    cdef unsigned long numDependencies_out
    _hipStreamGetCaptureInfo_v2_spt__retval = hipError_t(chip.hipStreamGetCaptureInfo_v2_spt(
        ihipStream_t.from_pyobj(stream)._ptr,&captureStatus_out,&id_out,&graph_out._ptr,
        <chip.hipGraphNode_t **>hip._util.types.DataHandle.from_pyobj(dependencies_out)._ptr,&numDependencies_out))    # fully specified
    return (_hipStreamGetCaptureInfo_v2_spt__retval,hipStreamCaptureStatus(captureStatus_out),id_out,graph_out,numDependencies_out)


@cython.embedsignature(True)
def hipLaunchHostFunc_spt(object stream, object fn, object userData):
    r"""(No short description)
    """
    _hipLaunchHostFunc_spt__retval = hipError_t(chip.hipLaunchHostFunc_spt(
        ihipStream_t.from_pyobj(stream)._ptr,
        hipHostFn_t.from_pyobj(fn)._ptr,
        <void *>hip._util.types.DataHandle.from_pyobj(userData)._ptr))    # fully specified
    return (_hipLaunchHostFunc_spt__retval,)


class _hipDataType__Base(enum.IntEnum):
    """Empty enum base class that allows subclassing.
    """
    pass
class hipDataType(_hipDataType__Base):
    HIP_R_16F = chip.HIP_R_16F
    HIP_R_32F = chip.HIP_R_32F
    HIP_R_64F = chip.HIP_R_64F
    HIP_C_16F = chip.HIP_C_16F
    HIP_C_32F = chip.HIP_C_32F
    HIP_C_64F = chip.HIP_C_64F
    @staticmethod
    def ctypes_type():
        """The type of the enum constants as ctypes type."""
        return ctypes.c_uint 


class _hipLibraryPropertyType__Base(enum.IntEnum):
    """Empty enum base class that allows subclassing.
    """
    pass
class hipLibraryPropertyType(_hipLibraryPropertyType__Base):
    HIP_LIBRARY_MAJOR_VERSION = chip.HIP_LIBRARY_MAJOR_VERSION
    HIP_LIBRARY_MINOR_VERSION = chip.HIP_LIBRARY_MINOR_VERSION
    HIP_LIBRARY_PATCH_LEVEL = chip.HIP_LIBRARY_PATCH_LEVEL
    @staticmethod
    def ctypes_type():
        """The type of the enum constants as ctypes type."""
        return ctypes.c_uint 
