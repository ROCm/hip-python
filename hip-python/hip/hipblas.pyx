# MIT License
#
# Copyright (c) 2023-2024 Advanced Micro Devices, Inc.
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in all
# copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
# SOFTWARE.

# This file has been autogenerated, do not modify.


"""
(No short description)

Attributes:
    hipblasVersionMajor (`~.int`):
        Macro constant.

    hipblaseVersionMinor (`~.int`):
        Macro constant.

    hipblasVersionMinor (`~.int`):
        Macro constant.

    hipblasVersionPatch (`~.int`):
        Macro constant.

    FP_NAN:
        (undocumented)
    FP_INFINITE:
        (undocumented)
    FP_ZERO:
        (undocumented)
    FP_SUBNORMAL:
        (undocumented)
    FP_NORMAL:
        (undocumented)
    FP_NAN:
        (undocumented)
    FP_INFINITE:
        (undocumented)
    FP_ZERO:
        (undocumented)
    FP_SUBNORMAL:
        (undocumented)
    FP_NORMAL:
        (undocumented)
    FP_NAN:
        (undocumented)
    FP_INFINITE:
        (undocumented)
    FP_ZERO:
        (undocumented)
    FP_SUBNORMAL:
        (undocumented)
    FP_NORMAL:
        (undocumented)
    FP_NAN:
        (undocumented)
    FP_INFINITE:
        (undocumented)
    FP_ZERO:
        (undocumented)
    FP_SUBNORMAL:
        (undocumented)
    FP_NORMAL:
        (undocumented)
    FP_NAN:
        (undocumented)
    FP_INFINITE:
        (undocumented)
    FP_ZERO:
        (undocumented)
    FP_SUBNORMAL:
        (undocumented)
    FP_NORMAL:
        (undocumented)
    HIP_SUCCESS:
        (undocumented)
    HIP_ERROR_INVALID_VALUE:
        (undocumented)
    HIP_ERROR_NOT_INITIALIZED:
        (undocumented)
    HIP_ERROR_LAUNCH_OUT_OF_RESOURCES:
        (undocumented)
    HIP_SUCCESS:
        (undocumented)
    HIP_ERROR_INVALID_VALUE:
        (undocumented)
    HIP_ERROR_NOT_INITIALIZED:
        (undocumented)
    HIP_ERROR_LAUNCH_OUT_OF_RESOURCES:
        (undocumented)
    HIP_SUCCESS:
        (undocumented)
    HIP_ERROR_INVALID_VALUE:
        (undocumented)
    HIP_ERROR_NOT_INITIALIZED:
        (undocumented)
    HIP_ERROR_LAUNCH_OUT_OF_RESOURCES:
        (undocumented)
    HIP_SUCCESS:
        (undocumented)
    HIP_ERROR_INVALID_VALUE:
        (undocumented)
    HIP_ERROR_NOT_INITIALIZED:
        (undocumented)
    HIP_ERROR_LAUNCH_OUT_OF_RESOURCES:
        (undocumented)
"""

import cython
import ctypes
import enum
from .hip import _hipDataType__Base
hipblasVersionMajor = chipblas.hipblasVersionMajor

hipblaseVersionMinor = chipblas.hipblaseVersionMinor

hipblasVersionMinor = chipblas.hipblasVersionMinor

hipblasVersionPatch = chipblas.hipblasVersionPatch

FP_NAN = chipblas.FP_NAN
FP_INFINITE = chipblas.FP_INFINITE
FP_ZERO = chipblas.FP_ZERO
FP_SUBNORMAL = chipblas.FP_SUBNORMAL
FP_NORMAL = chipblas.FP_NORMAL

HIP_SUCCESS = chipblas.HIP_SUCCESS
HIP_ERROR_INVALID_VALUE = chipblas.HIP_ERROR_INVALID_VALUE
HIP_ERROR_NOT_INITIALIZED = chipblas.HIP_ERROR_NOT_INITIALIZED
HIP_ERROR_LAUNCH_OUT_OF_RESOURCES = chipblas.HIP_ERROR_LAUNCH_OUT_OF_RESOURCES

cdef class hipblasBfloat16(hip._util.types.Pointer):
    """Python wrapper for cdef class chipblas.hipblasBfloat16.

    Python wrapper for cdef class chipblas.hipblasBfloat16.

    If this type is initialized via its `__init__` method, it allocates a
    member of the underlying C type and destroys it again if the wrapper
    type is deallocated.

    This type also serves as adapter when appearing as argument type in a
    function signature. In this case, the type can further be initialized
    from a number of Python objects:

    * `None`:

      This will set the ``self._ptr`` attribute to ``NULL``.

    * `int`:

      Interprets the integer value as pointer address and writes it to ``self._ptr``.
      No ownership is transferred.

    * `ctypes.c_void_p`:

      Takes the pointer address ``pyobj.value`` and writes it to ``self._ptr``.
      No ownership is transferred.

    * `object` that implements the `CUDA Array Interface <https://numba.readthedocs.io/en/stable/cuda/cuda_array_interface.html>`_ protocol:

      Takes the integer-valued pointer address, i.e. the first entry of the `data` tuple
      from `pyobj`'s member ``__cuda_array_interface__``  and writes it to ``self._ptr``.

    * `object` that implements the Python buffer protocol:

      If the object represents a simple contiguous array,
      writes the `Py_buffer` associated with ``pyobj`` to `self._py_buffer`,
      sets the `self._py_buffer_acquired` flag to `True`, and
      writes `self._py_buffer.buf` to the data pointer `self._ptr`.

    * `hip._util.types.Pointer`:

      Takes the pointer address ``pyobj._ptr`` and writes it to ``self._ptr``.
      No ownership is transferred.

    Type checks are performed in the above order.

    C Attributes:
        _ptr (C type ``void *``, protected):
            Stores a pointer to the data of the original Python object.
        _is_ptr_owner (C type ``bint``, protected):
            If this wrapper is the owner of the underlying data.
        _py_buffer (C type ``Py_buffer`, protected):
            Stores a pointer to the data of the original Python object.
        _py_buffer_acquired (C type ``bint``, protected):
            Stores a pointer to the data of the original Python object.
    """
    # C members declared in pxd file

    def __cinit__(self):
        self._ptr = NULL
        self._is_ptr_owner = False
        self._py_buffer_acquired = False

    cdef chipblas.hipblasBfloat16* getElementPtr(self):
        return <chipblas.hipblasBfloat16*>self._ptr

    @staticmethod
    cdef hipblasBfloat16 fromPtr(void* ptr, bint owner=False):
        """Factory function to create ``hipblasBfloat16`` objects from
        given ``chipblas.hipblasBfloat16`` pointer.

        Setting ``owner`` flag to ``True`` causes
        the extension type to free the structure pointed to by ``ptr``
        when the wrapper object is deallocated.
        """
        # Fast call to __new__() that bypasses the __init__() constructor.
        cdef hipblasBfloat16 wrapper = hipblasBfloat16.__new__(hipblasBfloat16)
        wrapper._ptr = ptr
        wrapper._is_ptr_owner = owner
        return wrapper

    @staticmethod
    def fromObj(pyobj):
        """Creates a hipblasBfloat16 from a Python object.

        Derives a hipblasBfloat16 from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``hipblasBfloat16`` reference, this method
        returns it directly. No new ``hipblasBfloat16`` is created in this case.
        """
        return hipblasBfloat16.fromPyobj(pyobj)

    @staticmethod
    cdef hipblasBfloat16 fromPyobj(object pyobj):
        """Creates a hipblasBfloat16 from a Python object.

        Derives a hipblasBfloat16 from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``hipblasBfloat16`` reference, this method
        returns it directly. No new ``hipblasBfloat16`` is created in this case.

        Args:
            pyobj (object): Must be either `None`; a `hip._util.types.Pointer`; a simple, contiguous buffer according to the buffer protocol;
                            or of type `hipblasBfloat16`; `int`; or `ctypes.c_void_p`.

        Note:
            This routine does not perform a copy but returns the original ``pyobj``
            if ``pyobj`` is an instance of hipblasBfloat16!
        """
        cdef hipblasBfloat16 wrapper

        if isinstance(pyobj,hipblasBfloat16):
            return pyobj
        else:
            wrapper = hipblasBfloat16.__new__(hipblasBfloat16)
            wrapper.init_from_pyobj(pyobj)
            return wrapper

    def __dealloc__(self):
        # Release the buffer handle
        if self._py_buffer_acquired is True:
            cpython.buffer.PyBuffer_Release(&self._py_buffer)
        # De-allocate if not null and flag is set
        if self._ptr is not NULL and self._is_ptr_owner is True:
            stdlib.free(self._ptr)
            self._ptr = NULL

    @staticmethod
    cdef __allocate(void** ptr):
        ptr[0] = stdlib.malloc(sizeof(chipblas.hipblasBfloat16))
        string.memset(<void*>ptr[0], 0, sizeof(chipblas.hipblasBfloat16))

        if ptr[0] is NULL:
            raise MemoryError

    @staticmethod
    cdef hipblasBfloat16 new():
        """Factory function to create hipblasBfloat16 objects with
        newly allocated chipblas.hipblasBfloat16"""
        cdef void* ptr
        hipblasBfloat16.__allocate(&ptr)
        return hipblasBfloat16.fromPtr(ptr, owner=True)

    @staticmethod
    cdef hipblasBfloat16 fromValue(chipblas.hipblasBfloat16 other):
        """Allocate new C type and copy from ``other``.
        """
        wrapper = hipblasBfloat16.new()
        string.memcpy(wrapper._ptr, &other, sizeof(chipblas.hipblasBfloat16))
        return wrapper

    def c_sizeof(self):
        """Returns the size of the underlying C type in bytes.
        Note:
            Implemented as function to not collide with
            autogenerated property names.
        """
        return sizeof(chipblas.hipblasBfloat16)

    def __int__(self):
        """Returns the data's address as long integer.
        """
        return cpython.long.PyLong_FromVoidPtr(self._ptr)

    def __repr__(self):
        return f"<hipblasBfloat16 object, ptr: {int(self)}>"

    def as_c_void_p(self):
        """Returns the data's address as `ctypes.c_void_p`
        Note:
            Implemented as function to not collide with
            autogenerated property names.
        """
        return ctypes.c_void_p(int(self))

    def __init__(self,*args,**kwargs):
        """Constructor type hipblasBfloat16.

        Constructor for type hipblasBfloat16.

        Args:
            *args:
                Positional arguments. Initialize all or a subset of the member variables
                according to their order of declaration.
            **kwargs:
                Can be used to initialize member variables at construction,
                Just pass an argument expression of the form <member>=<value>
                per member that you want to initialize.
        """
        hipblasBfloat16.__allocate(&self._ptr)
        self._is_ptr_owner = True
        attribs = self.PROPERTIES()
        used_attribs = set()
        if len(args) > len(attribs):
            raise ValueError("More positional arguments specified than this type has properties.")
        for i,v in enumerate(args):
            setattr(self,attribs[i],v)
            used_attribs.add(attribs[i])
        valid_names = ", ".join(["'"+p+"'" for p in attribs])
        for k,v in kwargs.items():
            if k in used_attribs:
                raise KeyError(f"argument '{k}' has already been specified as positional argument.")
            elif k not in attribs:
                raise KeyError(f"'{k}' is no valid property name. Valid names: {valid_names}")
            setattr(self,k,v)
    def get_data(self, i):
        """Get value ``data`` of ``(<chipblas.hipblasBfloat16*>self._ptr)[i]``.
        """
        return (<chipblas.hipblasBfloat16*>self._ptr)[i].data
    def set_data(self, i, unsigned short value):
        """Set value ``data`` of ``(<chipblas.hipblasBfloat16*>self._ptr)[i]``.
        """
        (<chipblas.hipblasBfloat16*>self._ptr)[i].data = value
    @property
    def data(self):
        """(undocumented)"""
        return self.get_data(0)
    @data.setter
    def data(self, unsigned short value):
        self.set_data(0,value)

    @staticmethod
    def PROPERTIES():
        return ["data"]

    def __contains__(self,item):
        properties = self.PROPERTIES()
        return item in properties

    def __getitem__(self,item):
        properties = self.PROPERTIES()
        if isinstance(item,int):
            if item < 0 or item >= len(properties):
                raise IndexError()
            return getattr(self,properties[item])
        raise ValueError("'item' type must be 'int'")


cdef class hipblasComplex(hip._util.types.Pointer):
    """Python wrapper for cdef class chipblas.hipblasComplex.

    Python wrapper for cdef class chipblas.hipblasComplex.

    If this type is initialized via its `__init__` method, it allocates a
    member of the underlying C type and destroys it again if the wrapper
    type is deallocated.

    This type also serves as adapter when appearing as argument type in a
    function signature. In this case, the type can further be initialized
    from a number of Python objects:

    * `None`:

      This will set the ``self._ptr`` attribute to ``NULL``.

    * `int`:

      Interprets the integer value as pointer address and writes it to ``self._ptr``.
      No ownership is transferred.

    * `ctypes.c_void_p`:

      Takes the pointer address ``pyobj.value`` and writes it to ``self._ptr``.
      No ownership is transferred.

    * `object` that implements the `CUDA Array Interface <https://numba.readthedocs.io/en/stable/cuda/cuda_array_interface.html>`_ protocol:

      Takes the integer-valued pointer address, i.e. the first entry of the `data` tuple
      from `pyobj`'s member ``__cuda_array_interface__``  and writes it to ``self._ptr``.

    * `object` that implements the Python buffer protocol:

      If the object represents a simple contiguous array,
      writes the `Py_buffer` associated with ``pyobj`` to `self._py_buffer`,
      sets the `self._py_buffer_acquired` flag to `True`, and
      writes `self._py_buffer.buf` to the data pointer `self._ptr`.

    * `hip._util.types.Pointer`:

      Takes the pointer address ``pyobj._ptr`` and writes it to ``self._ptr``.
      No ownership is transferred.

    Type checks are performed in the above order.

    C Attributes:
        _ptr (C type ``void *``, protected):
            Stores a pointer to the data of the original Python object.
        _is_ptr_owner (C type ``bint``, protected):
            If this wrapper is the owner of the underlying data.
        _py_buffer (C type ``Py_buffer`, protected):
            Stores a pointer to the data of the original Python object.
        _py_buffer_acquired (C type ``bint``, protected):
            Stores a pointer to the data of the original Python object.
    """
    # C members declared in pxd file

    def __cinit__(self):
        self._ptr = NULL
        self._is_ptr_owner = False
        self._py_buffer_acquired = False

    cdef chipblas.hipblasComplex* getElementPtr(self):
        return <chipblas.hipblasComplex*>self._ptr

    @staticmethod
    cdef hipblasComplex fromPtr(void* ptr, bint owner=False):
        """Factory function to create ``hipblasComplex`` objects from
        given ``chipblas.hipblasComplex`` pointer.

        Setting ``owner`` flag to ``True`` causes
        the extension type to free the structure pointed to by ``ptr``
        when the wrapper object is deallocated.
        """
        # Fast call to __new__() that bypasses the __init__() constructor.
        cdef hipblasComplex wrapper = hipblasComplex.__new__(hipblasComplex)
        wrapper._ptr = ptr
        wrapper._is_ptr_owner = owner
        return wrapper

    @staticmethod
    def fromObj(pyobj):
        """Creates a hipblasComplex from a Python object.

        Derives a hipblasComplex from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``hipblasComplex`` reference, this method
        returns it directly. No new ``hipblasComplex`` is created in this case.
        """
        return hipblasComplex.fromPyobj(pyobj)

    @staticmethod
    cdef hipblasComplex fromPyobj(object pyobj):
        """Creates a hipblasComplex from a Python object.

        Derives a hipblasComplex from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``hipblasComplex`` reference, this method
        returns it directly. No new ``hipblasComplex`` is created in this case.

        Args:
            pyobj (object): Must be either `None`; a `hip._util.types.Pointer`; a simple, contiguous buffer according to the buffer protocol;
                            or of type `hipblasComplex`; `int`; or `ctypes.c_void_p`.

        Note:
            This routine does not perform a copy but returns the original ``pyobj``
            if ``pyobj`` is an instance of hipblasComplex!
        """
        cdef hipblasComplex wrapper

        if isinstance(pyobj,hipblasComplex):
            return pyobj
        else:
            wrapper = hipblasComplex.__new__(hipblasComplex)
            wrapper.init_from_pyobj(pyobj)
            return wrapper

    def __dealloc__(self):
        # Release the buffer handle
        if self._py_buffer_acquired is True:
            cpython.buffer.PyBuffer_Release(&self._py_buffer)
        # De-allocate if not null and flag is set
        if self._ptr is not NULL and self._is_ptr_owner is True:
            stdlib.free(self._ptr)
            self._ptr = NULL

    @staticmethod
    cdef __allocate(void** ptr):
        ptr[0] = stdlib.malloc(sizeof(chipblas.hipblasComplex))
        string.memset(<void*>ptr[0], 0, sizeof(chipblas.hipblasComplex))

        if ptr[0] is NULL:
            raise MemoryError

    @staticmethod
    cdef hipblasComplex new():
        """Factory function to create hipblasComplex objects with
        newly allocated chipblas.hipblasComplex"""
        cdef void* ptr
        hipblasComplex.__allocate(&ptr)
        return hipblasComplex.fromPtr(ptr, owner=True)

    @staticmethod
    cdef hipblasComplex fromValue(chipblas.hipblasComplex other):
        """Allocate new C type and copy from ``other``.
        """
        wrapper = hipblasComplex.new()
        string.memcpy(wrapper._ptr, &other, sizeof(chipblas.hipblasComplex))
        return wrapper

    def c_sizeof(self):
        """Returns the size of the underlying C type in bytes.
        Note:
            Implemented as function to not collide with
            autogenerated property names.
        """
        return sizeof(chipblas.hipblasComplex)

    def __int__(self):
        """Returns the data's address as long integer.
        """
        return cpython.long.PyLong_FromVoidPtr(self._ptr)

    def __repr__(self):
        return f"<hipblasComplex object, ptr: {int(self)}>"

    def as_c_void_p(self):
        """Returns the data's address as `ctypes.c_void_p`
        Note:
            Implemented as function to not collide with
            autogenerated property names.
        """
        return ctypes.c_void_p(int(self))

    def __init__(self,*args,**kwargs):
        """Constructor type hipblasComplex.

        Constructor for type hipblasComplex.

        Args:
            *args:
                Positional arguments. Initialize all or a subset of the member variables
                according to their order of declaration.
            **kwargs:
                Can be used to initialize member variables at construction,
                Just pass an argument expression of the form <member>=<value>
                per member that you want to initialize.
        """
        hipblasComplex.__allocate(&self._ptr)
        self._is_ptr_owner = True
        attribs = self.PROPERTIES()
        used_attribs = set()
        if len(args) > len(attribs):
            raise ValueError("More positional arguments specified than this type has properties.")
        for i,v in enumerate(args):
            setattr(self,attribs[i],v)
            used_attribs.add(attribs[i])
        valid_names = ", ".join(["'"+p+"'" for p in attribs])
        for k,v in kwargs.items():
            if k in used_attribs:
                raise KeyError(f"argument '{k}' has already been specified as positional argument.")
            elif k not in attribs:
                raise KeyError(f"'{k}' is no valid property name. Valid names: {valid_names}")
            setattr(self,k,v)
    def get_x(self, i):
        """Get value ``x`` of ``(<chipblas.hipblasComplex*>self._ptr)[i]``.
        """
        return (<chipblas.hipblasComplex*>self._ptr)[i].x
    def set_x(self, i, float value):
        """Set value ``x`` of ``(<chipblas.hipblasComplex*>self._ptr)[i]``.
        """
        (<chipblas.hipblasComplex*>self._ptr)[i].x = value
    @property
    def x(self):
        """(undocumented)"""
        return self.get_x(0)
    @x.setter
    def x(self, float value):
        self.set_x(0,value)

    def get_y(self, i):
        """Get value ``y`` of ``(<chipblas.hipblasComplex*>self._ptr)[i]``.
        """
        return (<chipblas.hipblasComplex*>self._ptr)[i].y
    def set_y(self, i, float value):
        """Set value ``y`` of ``(<chipblas.hipblasComplex*>self._ptr)[i]``.
        """
        (<chipblas.hipblasComplex*>self._ptr)[i].y = value
    @property
    def y(self):
        """(undocumented)"""
        return self.get_y(0)
    @y.setter
    def y(self, float value):
        self.set_y(0,value)

    @staticmethod
    def PROPERTIES():
        return ["x","y"]

    def __contains__(self,item):
        properties = self.PROPERTIES()
        return item in properties

    def __getitem__(self,item):
        properties = self.PROPERTIES()
        if isinstance(item,int):
            if item < 0 or item >= len(properties):
                raise IndexError()
            return getattr(self,properties[item])
        raise ValueError("'item' type must be 'int'")


cdef class hipblasDoubleComplex(hip._util.types.Pointer):
    """Python wrapper for cdef class chipblas.hipblasDoubleComplex.

    Python wrapper for cdef class chipblas.hipblasDoubleComplex.

    If this type is initialized via its `__init__` method, it allocates a
    member of the underlying C type and destroys it again if the wrapper
    type is deallocated.

    This type also serves as adapter when appearing as argument type in a
    function signature. In this case, the type can further be initialized
    from a number of Python objects:

    * `None`:

      This will set the ``self._ptr`` attribute to ``NULL``.

    * `int`:

      Interprets the integer value as pointer address and writes it to ``self._ptr``.
      No ownership is transferred.

    * `ctypes.c_void_p`:

      Takes the pointer address ``pyobj.value`` and writes it to ``self._ptr``.
      No ownership is transferred.

    * `object` that implements the `CUDA Array Interface <https://numba.readthedocs.io/en/stable/cuda/cuda_array_interface.html>`_ protocol:

      Takes the integer-valued pointer address, i.e. the first entry of the `data` tuple
      from `pyobj`'s member ``__cuda_array_interface__``  and writes it to ``self._ptr``.

    * `object` that implements the Python buffer protocol:

      If the object represents a simple contiguous array,
      writes the `Py_buffer` associated with ``pyobj`` to `self._py_buffer`,
      sets the `self._py_buffer_acquired` flag to `True`, and
      writes `self._py_buffer.buf` to the data pointer `self._ptr`.

    * `hip._util.types.Pointer`:

      Takes the pointer address ``pyobj._ptr`` and writes it to ``self._ptr``.
      No ownership is transferred.

    Type checks are performed in the above order.

    C Attributes:
        _ptr (C type ``void *``, protected):
            Stores a pointer to the data of the original Python object.
        _is_ptr_owner (C type ``bint``, protected):
            If this wrapper is the owner of the underlying data.
        _py_buffer (C type ``Py_buffer`, protected):
            Stores a pointer to the data of the original Python object.
        _py_buffer_acquired (C type ``bint``, protected):
            Stores a pointer to the data of the original Python object.
    """
    # C members declared in pxd file

    def __cinit__(self):
        self._ptr = NULL
        self._is_ptr_owner = False
        self._py_buffer_acquired = False

    cdef chipblas.hipblasDoubleComplex* getElementPtr(self):
        return <chipblas.hipblasDoubleComplex*>self._ptr

    @staticmethod
    cdef hipblasDoubleComplex fromPtr(void* ptr, bint owner=False):
        """Factory function to create ``hipblasDoubleComplex`` objects from
        given ``chipblas.hipblasDoubleComplex`` pointer.

        Setting ``owner`` flag to ``True`` causes
        the extension type to free the structure pointed to by ``ptr``
        when the wrapper object is deallocated.
        """
        # Fast call to __new__() that bypasses the __init__() constructor.
        cdef hipblasDoubleComplex wrapper = hipblasDoubleComplex.__new__(hipblasDoubleComplex)
        wrapper._ptr = ptr
        wrapper._is_ptr_owner = owner
        return wrapper

    @staticmethod
    def fromObj(pyobj):
        """Creates a hipblasDoubleComplex from a Python object.

        Derives a hipblasDoubleComplex from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``hipblasDoubleComplex`` reference, this method
        returns it directly. No new ``hipblasDoubleComplex`` is created in this case.
        """
        return hipblasDoubleComplex.fromPyobj(pyobj)

    @staticmethod
    cdef hipblasDoubleComplex fromPyobj(object pyobj):
        """Creates a hipblasDoubleComplex from a Python object.

        Derives a hipblasDoubleComplex from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``hipblasDoubleComplex`` reference, this method
        returns it directly. No new ``hipblasDoubleComplex`` is created in this case.

        Args:
            pyobj (object): Must be either `None`; a `hip._util.types.Pointer`; a simple, contiguous buffer according to the buffer protocol;
                            or of type `hipblasDoubleComplex`; `int`; or `ctypes.c_void_p`.

        Note:
            This routine does not perform a copy but returns the original ``pyobj``
            if ``pyobj`` is an instance of hipblasDoubleComplex!
        """
        cdef hipblasDoubleComplex wrapper

        if isinstance(pyobj,hipblasDoubleComplex):
            return pyobj
        else:
            wrapper = hipblasDoubleComplex.__new__(hipblasDoubleComplex)
            wrapper.init_from_pyobj(pyobj)
            return wrapper

    def __dealloc__(self):
        # Release the buffer handle
        if self._py_buffer_acquired is True:
            cpython.buffer.PyBuffer_Release(&self._py_buffer)
        # De-allocate if not null and flag is set
        if self._ptr is not NULL and self._is_ptr_owner is True:
            stdlib.free(self._ptr)
            self._ptr = NULL

    @staticmethod
    cdef __allocate(void** ptr):
        ptr[0] = stdlib.malloc(sizeof(chipblas.hipblasDoubleComplex))
        string.memset(<void*>ptr[0], 0, sizeof(chipblas.hipblasDoubleComplex))

        if ptr[0] is NULL:
            raise MemoryError

    @staticmethod
    cdef hipblasDoubleComplex new():
        """Factory function to create hipblasDoubleComplex objects with
        newly allocated chipblas.hipblasDoubleComplex"""
        cdef void* ptr
        hipblasDoubleComplex.__allocate(&ptr)
        return hipblasDoubleComplex.fromPtr(ptr, owner=True)

    @staticmethod
    cdef hipblasDoubleComplex fromValue(chipblas.hipblasDoubleComplex other):
        """Allocate new C type and copy from ``other``.
        """
        wrapper = hipblasDoubleComplex.new()
        string.memcpy(wrapper._ptr, &other, sizeof(chipblas.hipblasDoubleComplex))
        return wrapper

    def c_sizeof(self):
        """Returns the size of the underlying C type in bytes.
        Note:
            Implemented as function to not collide with
            autogenerated property names.
        """
        return sizeof(chipblas.hipblasDoubleComplex)

    def __int__(self):
        """Returns the data's address as long integer.
        """
        return cpython.long.PyLong_FromVoidPtr(self._ptr)

    def __repr__(self):
        return f"<hipblasDoubleComplex object, ptr: {int(self)}>"

    def as_c_void_p(self):
        """Returns the data's address as `ctypes.c_void_p`
        Note:
            Implemented as function to not collide with
            autogenerated property names.
        """
        return ctypes.c_void_p(int(self))

    def __init__(self,*args,**kwargs):
        """Constructor type hipblasDoubleComplex.

        Constructor for type hipblasDoubleComplex.

        Args:
            *args:
                Positional arguments. Initialize all or a subset of the member variables
                according to their order of declaration.
            **kwargs:
                Can be used to initialize member variables at construction,
                Just pass an argument expression of the form <member>=<value>
                per member that you want to initialize.
        """
        hipblasDoubleComplex.__allocate(&self._ptr)
        self._is_ptr_owner = True
        attribs = self.PROPERTIES()
        used_attribs = set()
        if len(args) > len(attribs):
            raise ValueError("More positional arguments specified than this type has properties.")
        for i,v in enumerate(args):
            setattr(self,attribs[i],v)
            used_attribs.add(attribs[i])
        valid_names = ", ".join(["'"+p+"'" for p in attribs])
        for k,v in kwargs.items():
            if k in used_attribs:
                raise KeyError(f"argument '{k}' has already been specified as positional argument.")
            elif k not in attribs:
                raise KeyError(f"'{k}' is no valid property name. Valid names: {valid_names}")
            setattr(self,k,v)
    def get_x(self, i):
        """Get value ``x`` of ``(<chipblas.hipblasDoubleComplex*>self._ptr)[i]``.
        """
        return (<chipblas.hipblasDoubleComplex*>self._ptr)[i].x
    def set_x(self, i, double value):
        """Set value ``x`` of ``(<chipblas.hipblasDoubleComplex*>self._ptr)[i]``.
        """
        (<chipblas.hipblasDoubleComplex*>self._ptr)[i].x = value
    @property
    def x(self):
        """(undocumented)"""
        return self.get_x(0)
    @x.setter
    def x(self, double value):
        self.set_x(0,value)

    def get_y(self, i):
        """Get value ``y`` of ``(<chipblas.hipblasDoubleComplex*>self._ptr)[i]``.
        """
        return (<chipblas.hipblasDoubleComplex*>self._ptr)[i].y
    def set_y(self, i, double value):
        """Set value ``y`` of ``(<chipblas.hipblasDoubleComplex*>self._ptr)[i]``.
        """
        (<chipblas.hipblasDoubleComplex*>self._ptr)[i].y = value
    @property
    def y(self):
        """(undocumented)"""
        return self.get_y(0)
    @y.setter
    def y(self, double value):
        self.set_y(0,value)

    @staticmethod
    def PROPERTIES():
        return ["x","y"]

    def __contains__(self,item):
        properties = self.PROPERTIES()
        return item in properties

    def __getitem__(self,item):
        properties = self.PROPERTIES()
        if isinstance(item,int):
            if item < 0 or item >= len(properties):
                raise IndexError()
            return getattr(self,properties[item])
        raise ValueError("'item' type must be 'int'")


class _hipblasStatus_t__Base(enum.IntEnum):
    """Empty enum base class that allows subclassing.
    """
    pass
class hipblasStatus_t(_hipblasStatus_t__Base):
    """hipblas status codes definition

    Attributes:
        HIPBLAS_STATUS_SUCCESS:
            Function succeeds
        HIPBLAS_STATUS_NOT_INITIALIZED:
            HIPBLAS library not initialized
        HIPBLAS_STATUS_ALLOC_FAILED:
            resource allocation failed
        HIPBLAS_STATUS_INVALID_VALUE:
            unsupported numerical value was passed to function
        HIPBLAS_STATUS_MAPPING_ERROR:
            access to GPU memory space failed
        HIPBLAS_STATUS_EXECUTION_FAILED:
            GPU program failed to execute
        HIPBLAS_STATUS_INTERNAL_ERROR:
            an internal HIPBLAS operation failed
        HIPBLAS_STATUS_NOT_SUPPORTED:
            function not implemented
        HIPBLAS_STATUS_ARCH_MISMATCH:
            architecture mismatch
        HIPBLAS_STATUS_HANDLE_IS_NULLPTR:
            hipBLAS handle is null pointer
        HIPBLAS_STATUS_INVALID_ENUM:
            unsupported enum value was passed to function
        HIPBLAS_STATUS_UNKNOWN:
            back-end returned an unsupported status code
    """
    HIPBLAS_STATUS_SUCCESS = chipblas.HIPBLAS_STATUS_SUCCESS
    HIPBLAS_STATUS_NOT_INITIALIZED = chipblas.HIPBLAS_STATUS_NOT_INITIALIZED
    HIPBLAS_STATUS_ALLOC_FAILED = chipblas.HIPBLAS_STATUS_ALLOC_FAILED
    HIPBLAS_STATUS_INVALID_VALUE = chipblas.HIPBLAS_STATUS_INVALID_VALUE
    HIPBLAS_STATUS_MAPPING_ERROR = chipblas.HIPBLAS_STATUS_MAPPING_ERROR
    HIPBLAS_STATUS_EXECUTION_FAILED = chipblas.HIPBLAS_STATUS_EXECUTION_FAILED
    HIPBLAS_STATUS_INTERNAL_ERROR = chipblas.HIPBLAS_STATUS_INTERNAL_ERROR
    HIPBLAS_STATUS_NOT_SUPPORTED = chipblas.HIPBLAS_STATUS_NOT_SUPPORTED
    HIPBLAS_STATUS_ARCH_MISMATCH = chipblas.HIPBLAS_STATUS_ARCH_MISMATCH
    HIPBLAS_STATUS_HANDLE_IS_NULLPTR = chipblas.HIPBLAS_STATUS_HANDLE_IS_NULLPTR
    HIPBLAS_STATUS_INVALID_ENUM = chipblas.HIPBLAS_STATUS_INVALID_ENUM
    HIPBLAS_STATUS_UNKNOWN = chipblas.HIPBLAS_STATUS_UNKNOWN
    @staticmethod
    def ctypes_type():
        """The type of the enum constants as ctypes type."""
        return ctypes.c_uint


class _hipblasPointerMode_t__Base(enum.IntEnum):
    """Empty enum base class that allows subclassing.
    """
    pass
class hipblasPointerMode_t(_hipblasPointerMode_t__Base):
    """Indicates if scalar pointers are on host or device. This is used for scalars alpha and beta and for scalar function return values.

    Attributes:
        HIPBLAS_POINTER_MODE_HOST:
            Scalar values affected by this variable will be located on the host.
        HIPBLAS_POINTER_MODE_DEVICE:
            Scalar values affected by this variable will be located on the device.
    """
    HIPBLAS_POINTER_MODE_HOST = chipblas.HIPBLAS_POINTER_MODE_HOST
    HIPBLAS_POINTER_MODE_DEVICE = chipblas.HIPBLAS_POINTER_MODE_DEVICE
    @staticmethod
    def ctypes_type():
        """The type of the enum constants as ctypes type."""
        return ctypes.c_uint


class _hipblasOperation_t__Base(enum.IntEnum):
    """Empty enum base class that allows subclassing.
    """
    pass
class hipblasOperation_t(_hipblasOperation_t__Base):
    """Used to specify whether the matrix is to be transposed or not.

    Attributes:
        HIPBLAS_OP_N:
            Operate with the matrix.
        HIPBLAS_OP_T:
            Operate with the transpose of the matrix.
        HIPBLAS_OP_C:
            Operate with the conjugate transpose of the matrix.
    """
    HIPBLAS_OP_N = chipblas.HIPBLAS_OP_N
    HIPBLAS_OP_T = chipblas.HIPBLAS_OP_T
    HIPBLAS_OP_C = chipblas.HIPBLAS_OP_C
    @staticmethod
    def ctypes_type():
        """The type of the enum constants as ctypes type."""
        return ctypes.c_uint


class _hipblasFillMode_t__Base(enum.IntEnum):
    """Empty enum base class that allows subclassing.
    """
    pass
class hipblasFillMode_t(_hipblasFillMode_t__Base):
    """Used by the Hermitian, symmetric and triangular matrix routines to specify whether the upper or lower triangle is being referenced.

    Attributes:
        HIPBLAS_FILL_MODE_UPPER:
            Upper triangle
        HIPBLAS_FILL_MODE_LOWER:
            Lower triangle
        HIPBLAS_FILL_MODE_FULL:
            (undocumented)
    """
    HIPBLAS_FILL_MODE_UPPER = chipblas.HIPBLAS_FILL_MODE_UPPER
    HIPBLAS_FILL_MODE_LOWER = chipblas.HIPBLAS_FILL_MODE_LOWER
    HIPBLAS_FILL_MODE_FULL = chipblas.HIPBLAS_FILL_MODE_FULL
    @staticmethod
    def ctypes_type():
        """The type of the enum constants as ctypes type."""
        return ctypes.c_uint


class _hipblasDiagType_t__Base(enum.IntEnum):
    """Empty enum base class that allows subclassing.
    """
    pass
class hipblasDiagType_t(_hipblasDiagType_t__Base):
    """It is used by the triangular matrix routines to specify whether the matrix is unit triangular.

    Attributes:
        HIPBLAS_DIAG_NON_UNIT:
            Non-unit triangular.
        HIPBLAS_DIAG_UNIT:
            Unit triangular.
    """
    HIPBLAS_DIAG_NON_UNIT = chipblas.HIPBLAS_DIAG_NON_UNIT
    HIPBLAS_DIAG_UNIT = chipblas.HIPBLAS_DIAG_UNIT
    @staticmethod
    def ctypes_type():
        """The type of the enum constants as ctypes type."""
        return ctypes.c_uint


class _hipblasSideMode_t__Base(enum.IntEnum):
    """Empty enum base class that allows subclassing.
    """
    pass
class hipblasSideMode_t(_hipblasSideMode_t__Base):
    """Indicates the side matrix A is located relative to matrix B during multiplication.

    Attributes:
        HIPBLAS_SIDE_LEFT:
            (undocumented)
        HIPBLAS_SIDE_RIGHT:
            (undocumented)
        HIPBLAS_SIDE_BOTH:
            (undocumented)
    """
    HIPBLAS_SIDE_LEFT = chipblas.HIPBLAS_SIDE_LEFT
    HIPBLAS_SIDE_RIGHT = chipblas.HIPBLAS_SIDE_RIGHT
    HIPBLAS_SIDE_BOTH = chipblas.HIPBLAS_SIDE_BOTH
    @staticmethod
    def ctypes_type():
        """The type of the enum constants as ctypes type."""
        return ctypes.c_uint


class _hipblasMath_t__Base(enum.IntEnum):
    """Empty enum base class that allows subclassing.
    """
    pass
class hipblasMath_t(_hipblasMath_t__Base):
    """hipblasMath_t

    Attributes:
        HIPBLAS_DEFAULT_MATH:
            (undocumented)
        HIPBLAS_XF32_XDL_MATH:
            (undocumented)
        HIPBLAS_PEDANTIC_MATH:
            (undocumented)
        HIPBLAS_TF32_TENSOR_OP_MATH:
            (undocumented)
        HIPBLAS_MATH_DISALLOW_REDUCED_PRECISION_REDUCTION:
            (undocumented)
        HIPBLAS_TENSOR_OP_MATH:
            (undocumented)
    """
    HIPBLAS_DEFAULT_MATH = chipblas.HIPBLAS_DEFAULT_MATH
    HIPBLAS_XF32_XDL_MATH = chipblas.HIPBLAS_XF32_XDL_MATH
    HIPBLAS_PEDANTIC_MATH = chipblas.HIPBLAS_PEDANTIC_MATH
    HIPBLAS_TF32_TENSOR_OP_MATH = chipblas.HIPBLAS_TF32_TENSOR_OP_MATH
    HIPBLAS_MATH_DISALLOW_REDUCED_PRECISION_REDUCTION = chipblas.HIPBLAS_MATH_DISALLOW_REDUCED_PRECISION_REDUCTION
    HIPBLAS_TENSOR_OP_MATH = chipblas.HIPBLAS_TENSOR_OP_MATH
    @staticmethod
    def ctypes_type():
        """The type of the enum constants as ctypes type."""
        return ctypes.c_uint


class _hipblasDatatype_t__Base(enum.IntEnum):
    """Empty enum base class that allows subclassing.
    """
    pass
class hipblasDatatype_t(_hipblasDatatype_t__Base):
    """Indicates the precision of data used. hipblasDatatype_t is deprecated as of hipBLAS 2.0.0 and will be removed in a future release as generally replaced by hipDataType.

    Attributes:
        HIPBLAS_R_16F:
            16 bit floating point, real
        HIPBLAS_R_32F:
            32 bit floating point, real
        HIPBLAS_R_64F:
            64 bit floating point, real
        HIPBLAS_C_16F:
            16 bit floating point, complex
        HIPBLAS_C_32F:
            32 bit floating point, complex
        HIPBLAS_C_64F:
            64 bit floating point, complex
        HIPBLAS_R_8I:
            8 bit signed integer, real
        HIPBLAS_R_8U:
            8 bit unsigned integer, real
        HIPBLAS_R_32I:
            32 bit signed integer, real
        HIPBLAS_R_32U:
            32 bit unsigned integer, real
        HIPBLAS_C_8I:
            8 bit signed integer, complex
        HIPBLAS_C_8U:
            8 bit unsigned integer, complex
        HIPBLAS_C_32I:
            32 bit signed integer, complex
        HIPBLAS_C_32U:
            32 bit unsigned integer, complex
        HIPBLAS_R_16B:
            16 bit bfloat, real
        HIPBLAS_C_16B:
            16 bit bfloat, complex
        HIPBLAS_DATATYPE_INVALID:
            Invalid datatype value, do not use
    """
    HIPBLAS_R_16F = chipblas.HIPBLAS_R_16F
    HIPBLAS_R_32F = chipblas.HIPBLAS_R_32F
    HIPBLAS_R_64F = chipblas.HIPBLAS_R_64F
    HIPBLAS_C_16F = chipblas.HIPBLAS_C_16F
    HIPBLAS_C_32F = chipblas.HIPBLAS_C_32F
    HIPBLAS_C_64F = chipblas.HIPBLAS_C_64F
    HIPBLAS_R_8I = chipblas.HIPBLAS_R_8I
    HIPBLAS_R_8U = chipblas.HIPBLAS_R_8U
    HIPBLAS_R_32I = chipblas.HIPBLAS_R_32I
    HIPBLAS_R_32U = chipblas.HIPBLAS_R_32U
    HIPBLAS_C_8I = chipblas.HIPBLAS_C_8I
    HIPBLAS_C_8U = chipblas.HIPBLAS_C_8U
    HIPBLAS_C_32I = chipblas.HIPBLAS_C_32I
    HIPBLAS_C_32U = chipblas.HIPBLAS_C_32U
    HIPBLAS_R_16B = chipblas.HIPBLAS_R_16B
    HIPBLAS_C_16B = chipblas.HIPBLAS_C_16B
    HIPBLAS_DATATYPE_INVALID = chipblas.HIPBLAS_DATATYPE_INVALID
    @staticmethod
    def ctypes_type():
        """The type of the enum constants as ctypes type."""
        return ctypes.c_uint


class _hipblasComputeType_t__Base(enum.IntEnum):
    """Empty enum base class that allows subclassing.
    """
    pass
class hipblasComputeType_t(_hipblasComputeType_t__Base):
    """The compute type to be used. Currently only used with GemmEx with the HIPBLAS_V2 interface. Note that support for compute types is largely dependent on backend.

    Attributes:
        HIPBLAS_COMPUTE_16F:
            compute will be at least 16-bit precision
        HIPBLAS_COMPUTE_16F_PEDANTIC:
            compute will be exactly 16-bit precision
        HIPBLAS_COMPUTE_32F:
            compute will be at least 32-bit precision
        HIPBLAS_COMPUTE_32F_PEDANTIC:
            compute will be exactly 32-bit precision
        HIPBLAS_COMPUTE_32F_FAST_16F:
            32-bit input can use 16-bit compute
        HIPBLAS_COMPUTE_32F_FAST_16BF:
            32-bit input can is bf16 compute
        HIPBLAS_COMPUTE_32F_FAST_TF32:
            (undocumented)
        HIPBLAS_COMPUTE_64F:
            compute will be at least 64-bit precision
        HIPBLAS_COMPUTE_64F_PEDANTIC:
            compute will be exactly 64-bit precision
        HIPBLAS_COMPUTE_32I:
            compute will be at least 32-bit integer precision
        HIPBLAS_COMPUTE_32I_PEDANTIC:
            compute will be exactly 32-bit integer precision
    """
    HIPBLAS_COMPUTE_16F = chipblas.HIPBLAS_COMPUTE_16F
    HIPBLAS_COMPUTE_16F_PEDANTIC = chipblas.HIPBLAS_COMPUTE_16F_PEDANTIC
    HIPBLAS_COMPUTE_32F = chipblas.HIPBLAS_COMPUTE_32F
    HIPBLAS_COMPUTE_32F_PEDANTIC = chipblas.HIPBLAS_COMPUTE_32F_PEDANTIC
    HIPBLAS_COMPUTE_32F_FAST_16F = chipblas.HIPBLAS_COMPUTE_32F_FAST_16F
    HIPBLAS_COMPUTE_32F_FAST_16BF = chipblas.HIPBLAS_COMPUTE_32F_FAST_16BF
    HIPBLAS_COMPUTE_32F_FAST_TF32 = chipblas.HIPBLAS_COMPUTE_32F_FAST_TF32
    HIPBLAS_COMPUTE_64F = chipblas.HIPBLAS_COMPUTE_64F
    HIPBLAS_COMPUTE_64F_PEDANTIC = chipblas.HIPBLAS_COMPUTE_64F_PEDANTIC
    HIPBLAS_COMPUTE_32I = chipblas.HIPBLAS_COMPUTE_32I
    HIPBLAS_COMPUTE_32I_PEDANTIC = chipblas.HIPBLAS_COMPUTE_32I_PEDANTIC
    @staticmethod
    def ctypes_type():
        """The type of the enum constants as ctypes type."""
        return ctypes.c_uint


class _hipblasGemmAlgo_t__Base(enum.IntEnum):
    """Empty enum base class that allows subclassing.
    """
    pass
class hipblasGemmAlgo_t(_hipblasGemmAlgo_t__Base):
    """Indicates if layer is active with bitmask.

    Attributes:
        HIPBLAS_GEMM_DEFAULT:
            enumerator rocblas_gemm_algo_standard
    """
    HIPBLAS_GEMM_DEFAULT = chipblas.HIPBLAS_GEMM_DEFAULT
    @staticmethod
    def ctypes_type():
        """The type of the enum constants as ctypes type."""
        return ctypes.c_uint


class _hipblasAtomicsMode_t__Base(enum.IntEnum):
    """Empty enum base class that allows subclassing.
    """
    pass
class hipblasAtomicsMode_t(_hipblasAtomicsMode_t__Base):
    """Indicates if atomics operations are allowed. Not allowing atomic operations may generally improve determinism and repeatability of results at a cost of performance. By default, the rocBLAS backend will allow atomic operations while the cuBLAS backend will disallow atomic operations. See backend documentation for more detail.

    Attributes:
        HIPBLAS_ATOMICS_NOT_ALLOWED:
            Algorithms will refrain from atomics where applicable.
        HIPBLAS_ATOMICS_ALLOWED:
            Algorithms will take advantage of atomics where applicable.
    """
    HIPBLAS_ATOMICS_NOT_ALLOWED = chipblas.HIPBLAS_ATOMICS_NOT_ALLOWED
    HIPBLAS_ATOMICS_ALLOWED = chipblas.HIPBLAS_ATOMICS_ALLOWED
    @staticmethod
    def ctypes_type():
        """The type of the enum constants as ctypes type."""
        return ctypes.c_uint


class _hipblasGemmFlags_t__Base(enum.IntEnum):
    """Empty enum base class that allows subclassing.
    """
    pass
class hipblasGemmFlags_t(_hipblasGemmFlags_t__Base):
    """Control flags passed into gemm ex with flags algorithms. Only relevant with rocBLAS backend. See rocBLAS documentation for more information.

    Attributes:
        HIPBLAS_GEMM_FLAGS_NONE:
            Default empty flags
        HIPBLAS_GEMM_FLAGS_USE_CU_EFFICIENCY:
            (undocumented)
        HIPBLAS_GEMM_FLAGS_FP16_ALT_IMPL:
            enumerator rocblas_gemm_flags_fp16_alt_impl
        HIPBLAS_GEMM_FLAGS_CHECK_SOLUTION_INDEX:
            (undocumented)
        HIPBLAS_GEMM_FLAGS_FP16_ALT_IMPL_RNZ:
            (undocumented)
    """
    HIPBLAS_GEMM_FLAGS_NONE = chipblas.HIPBLAS_GEMM_FLAGS_NONE
    HIPBLAS_GEMM_FLAGS_USE_CU_EFFICIENCY = chipblas.HIPBLAS_GEMM_FLAGS_USE_CU_EFFICIENCY
    HIPBLAS_GEMM_FLAGS_FP16_ALT_IMPL = chipblas.HIPBLAS_GEMM_FLAGS_FP16_ALT_IMPL
    HIPBLAS_GEMM_FLAGS_CHECK_SOLUTION_INDEX = chipblas.HIPBLAS_GEMM_FLAGS_CHECK_SOLUTION_INDEX
    HIPBLAS_GEMM_FLAGS_FP16_ALT_IMPL_RNZ = chipblas.HIPBLAS_GEMM_FLAGS_FP16_ALT_IMPL_RNZ
    @staticmethod
    def ctypes_type():
        """The type of the enum constants as ctypes type."""
        return ctypes.c_uint


@cython.embedsignature(True)
def hipblasCreate():
    r"""Create hipblas handle. */

    Returns:
        A `~.tuple` of size 1 that contains (in that order):

        * handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)
    """
    handle = hip._util.types.Pointer.fromPtr(NULL)
    _hipblasCreate__retval = hipblasStatus_t(chipblas.hipblasCreate(
        <void **>&handle._ptr))
    return (_hipblasCreate__retval,None if handle._ptr == NULL else handle)


@cython.embedsignature(True)
def hipblasDestroy(object handle):
    r"""Destroys the library context created using hipblasCreate() */

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)
    """
    _hipblasDestroy__retval = hipblasStatus_t(chipblas.hipblasDestroy(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr))
    return (_hipblasDestroy__retval,)


@cython.embedsignature(True)
def hipblasSetStream(object handle, object streamId):
    r"""Set stream for handle */

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        streamId (`~.ihipStream_t`/`~.object`):
            (undocumented)
    """
    _hipblasSetStream__retval = hipblasStatus_t(chipblas.hipblasSetStream(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,
        ihipStream_t.fromPyobj(streamId).getElementPtr()))
    return (_hipblasSetStream__retval,)


@cython.embedsignature(True)
def hipblasGetStream(object handle, object streamId):
    r"""Get stream[0] for handle */

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        streamId (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)
    """
    _hipblasGetStream__retval = hipblasStatus_t(chipblas.hipblasGetStream(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,
        <chipblas.hipStream_t*>hip._util.types.Pointer.fromPyobj(streamId)._ptr))
    return (_hipblasGetStream__retval,)


@cython.embedsignature(True)
def hipblasSetPointerMode(object handle, object mode):
    r"""Set hipblas pointer mode */

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        mode (`~.hipblasPointerMode_t`):
            (undocumented)
    """
    if not isinstance(mode,_hipblasPointerMode_t__Base):
        raise TypeError("argument 'mode' must be of type '_hipblasPointerMode_t__Base'")
    _hipblasSetPointerMode__retval = hipblasStatus_t(chipblas.hipblasSetPointerMode(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,mode.value))
    return (_hipblasSetPointerMode__retval,)


@cython.embedsignature(True)
def hipblasGetPointerMode(object handle, object mode):
    r"""Get hipblas pointer mode */

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        mode (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)
    """
    _hipblasGetPointerMode__retval = hipblasStatus_t(chipblas.hipblasGetPointerMode(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,
        <chipblas.hipblasPointerMode_t *>hip._util.types.Pointer.fromPyobj(mode)._ptr))
    return (_hipblasGetPointerMode__retval,)


@cython.embedsignature(True)
def hipblasSetMathMode(object handle, object mode):
    r"""Set hipblas math mode */

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        mode (`~.hipblasMath_t`):
            (undocumented)
    """
    if not isinstance(mode,_hipblasMath_t__Base):
        raise TypeError("argument 'mode' must be of type '_hipblasMath_t__Base'")
    _hipblasSetMathMode__retval = hipblasStatus_t(chipblas.hipblasSetMathMode(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,mode.value))
    return (_hipblasSetMathMode__retval,)


@cython.embedsignature(True)
def hipblasGetMathMode(object handle, object mode):
    r"""Get hipblas math mode */

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        mode (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)
    """
    _hipblasGetMathMode__retval = hipblasStatus_t(chipblas.hipblasGetMathMode(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,
        <chipblas.hipblasMath_t *>hip._util.types.Pointer.fromPyobj(mode)._ptr))
    return (_hipblasGetMathMode__retval,)


@cython.embedsignature(True)
def hipblasSetVector(int n, int elemSize, object x, int incx, object y, int incy):
    r"""copy vector from host to device

    Args:
        n (`~.int`) -- *IN*:
            [int]
            number of elements in the vector

        elemSize (`~.int`) -- *IN*:
            [int]
            Size of both vectors in bytes

        x (`~.hip._util.types.Pointer`/`~.object`) -- *IN*:
            pointer to vector on the host

        incx (`~.int`) -- *IN*:
            [int]
            specifies the increment for the elements of the vector

        y (`~.hip._util.types.Pointer`/`~.object`) -- *OUT*:
            pointer to vector on the device

        incy (`~.int`) -- *IN*:
            [int]
            specifies the increment for the elements of the vector
    """
    _hipblasSetVector__retval = hipblasStatus_t(chipblas.hipblasSetVector(n,elemSize,
        <const void *>hip._util.types.Pointer.fromPyobj(x)._ptr,incx,
        <void *>hip._util.types.Pointer.fromPyobj(y)._ptr,incy))
    return (_hipblasSetVector__retval,)


@cython.embedsignature(True)
def hipblasGetVector(int n, int elemSize, object x, int incx, object y, int incy):
    r"""copy vector from device to host

    Args:
        n (`~.int`) -- *IN*:
            [int]
            number of elements in the vector

        elemSize (`~.int`) -- *IN*:
            [int]
            Size of both vectors in bytes

        x (`~.hip._util.types.Pointer`/`~.object`) -- *IN*:
            pointer to vector on the device

        incx (`~.int`) -- *IN*:
            [int]
            specifies the increment for the elements of the vector

        y (`~.hip._util.types.Pointer`/`~.object`) -- *OUT*:
            pointer to vector on the host

        incy (`~.int`) -- *IN*:
            [int]
            specifies the increment for the elements of the vector
    """
    _hipblasGetVector__retval = hipblasStatus_t(chipblas.hipblasGetVector(n,elemSize,
        <const void *>hip._util.types.Pointer.fromPyobj(x)._ptr,incx,
        <void *>hip._util.types.Pointer.fromPyobj(y)._ptr,incy))
    return (_hipblasGetVector__retval,)


@cython.embedsignature(True)
def hipblasSetMatrix(int rows, int cols, int elemSize, object AP, int lda, object BP, int ldb):
    r"""copy matrix from host to device

    Args:
        rows (`~.int`) -- *IN*:
            [int]
            number of rows in matrices

        cols (`~.int`) -- *IN*:
            [int]
            number of columns in matrices

        elemSize (`~.int`) -- *IN*:
            [int]
            number of bytes per element in the matrix

        AP (`~.hip._util.types.Pointer`/`~.object`) -- *IN*:
            pointer to matrix on the host

        lda (`~.int`) -- *IN*:
            [int]
            specifies the leading dimension of A, lda >= rows

        BP (`~.hip._util.types.Pointer`/`~.object`) -- *OUT*:
            pointer to matrix on the GPU

        ldb (`~.int`) -- *IN*:
            [int]
            specifies the leading dimension of B, ldb >= rows
    """
    _hipblasSetMatrix__retval = hipblasStatus_t(chipblas.hipblasSetMatrix(rows,cols,elemSize,
        <const void *>hip._util.types.Pointer.fromPyobj(AP)._ptr,lda,
        <void *>hip._util.types.Pointer.fromPyobj(BP)._ptr,ldb))
    return (_hipblasSetMatrix__retval,)


@cython.embedsignature(True)
def hipblasGetMatrix(int rows, int cols, int elemSize, object AP, int lda, object BP, int ldb):
    r"""copy matrix from device to host

    Args:
        rows (`~.int`) -- *IN*:
            [int]
            number of rows in matrices

        cols (`~.int`) -- *IN*:
            [int]
            number of columns in matrices

        elemSize (`~.int`) -- *IN*:
            [int]
            number of bytes per element in the matrix

        AP (`~.hip._util.types.Pointer`/`~.object`) -- *IN*:
            pointer to matrix on the GPU

        lda (`~.int`) -- *IN*:
            [int]
            specifies the leading dimension of A, lda >= rows

        BP (`~.hip._util.types.Pointer`/`~.object`) -- *OUT*:
            pointer to matrix on the host

        ldb (`~.int`) -- *IN*:
            [int]
            specifies the leading dimension of B, ldb >= rows
    """
    _hipblasGetMatrix__retval = hipblasStatus_t(chipblas.hipblasGetMatrix(rows,cols,elemSize,
        <const void *>hip._util.types.Pointer.fromPyobj(AP)._ptr,lda,
        <void *>hip._util.types.Pointer.fromPyobj(BP)._ptr,ldb))
    return (_hipblasGetMatrix__retval,)


@cython.embedsignature(True)
def hipblasSetVectorAsync(int n, int elemSize, object x, int incx, object y, int incy, object stream):
    r"""asynchronously copy vector from host to device

    hipblasSetVectorAsync copies a vector from pinned host memory to device memory asynchronously.
    Memory on the host must be allocated with hipHostMalloc or the transfer will be synchronous.

    Args:
        n (`~.int`) -- *IN*:
            [int]
            number of elements in the vector

        elemSize (`~.int`) -- *IN*:
            [int]
            number of bytes per element in the matrix

        x (`~.hip._util.types.Pointer`/`~.object`) -- *IN*:
            pointer to vector on the host

        incx (`~.int`) -- *IN*:
            [int]
            specifies the increment for the elements of the vector

        y (`~.hip._util.types.Pointer`/`~.object`) -- *OUT*:
            pointer to vector on the device

        incy (`~.int`) -- *IN*:
            [int]
            specifies the increment for the elements of the vector

        stream (`~.ihipStream_t`/`~.object`) -- *IN*:
            specifies the stream into which this transfer request is queued
    """
    _hipblasSetVectorAsync__retval = hipblasStatus_t(chipblas.hipblasSetVectorAsync(n,elemSize,
        <const void *>hip._util.types.Pointer.fromPyobj(x)._ptr,incx,
        <void *>hip._util.types.Pointer.fromPyobj(y)._ptr,incy,
        ihipStream_t.fromPyobj(stream).getElementPtr()))
    return (_hipblasSetVectorAsync__retval,)


@cython.embedsignature(True)
def hipblasGetVectorAsync(int n, int elemSize, object x, int incx, object y, int incy, object stream):
    r"""asynchronously copy vector from device to host

    hipblasGetVectorAsync copies a vector from pinned host memory to device memory asynchronously.
    Memory on the host must be allocated with hipHostMalloc or the transfer will be synchronous.

    Args:
        n (`~.int`) -- *IN*:
            [int]
            number of elements in the vector

        elemSize (`~.int`) -- *IN*:
            [int]
            number of bytes per element in the matrix

        x (`~.hip._util.types.Pointer`/`~.object`) -- *IN*:
            pointer to vector on the device

        incx (`~.int`) -- *IN*:
            [int]
            specifies the increment for the elements of the vector

        y (`~.hip._util.types.Pointer`/`~.object`) -- *OUT*:
            pointer to vector on the host

        incy (`~.int`) -- *IN*:
            [int]
            specifies the increment for the elements of the vector

        stream (`~.ihipStream_t`/`~.object`) -- *IN*:
            specifies the stream into which this transfer request is queued
    """
    _hipblasGetVectorAsync__retval = hipblasStatus_t(chipblas.hipblasGetVectorAsync(n,elemSize,
        <const void *>hip._util.types.Pointer.fromPyobj(x)._ptr,incx,
        <void *>hip._util.types.Pointer.fromPyobj(y)._ptr,incy,
        ihipStream_t.fromPyobj(stream).getElementPtr()))
    return (_hipblasGetVectorAsync__retval,)


@cython.embedsignature(True)
def hipblasSetMatrixAsync(int rows, int cols, int elemSize, object AP, int lda, object BP, int ldb, object stream):
    r"""asynchronously copy matrix from host to device

    hipblasSetMatrixAsync copies a matrix from pinned host memory to device memory asynchronously.
    Memory on the host must be allocated with hipHostMalloc or the transfer will be synchronous.

    Args:
        rows (`~.int`) -- *IN*:
            [int]
            number of rows in matrices

        cols (`~.int`) -- *IN*:
            [int]
            number of columns in matrices

        elemSize (`~.int`) -- *IN*:
            [int]
            number of bytes per element in the matrix

        AP (`~.hip._util.types.Pointer`/`~.object`) -- *IN*:
            pointer to matrix on the host

        lda (`~.int`) -- *IN*:
            [int]
            specifies the leading dimension of A, lda >= rows

        BP (`~.hip._util.types.Pointer`/`~.object`) -- *OUT*:
            pointer to matrix on the GPU

        ldb (`~.int`) -- *IN*:
            [int]
            specifies the leading dimension of B, ldb >= rows

        stream (`~.ihipStream_t`/`~.object`) -- *IN*:
            specifies the stream into which this transfer request is queued
    """
    _hipblasSetMatrixAsync__retval = hipblasStatus_t(chipblas.hipblasSetMatrixAsync(rows,cols,elemSize,
        <const void *>hip._util.types.Pointer.fromPyobj(AP)._ptr,lda,
        <void *>hip._util.types.Pointer.fromPyobj(BP)._ptr,ldb,
        ihipStream_t.fromPyobj(stream).getElementPtr()))
    return (_hipblasSetMatrixAsync__retval,)


@cython.embedsignature(True)
def hipblasGetMatrixAsync(int rows, int cols, int elemSize, object AP, int lda, object BP, int ldb, object stream):
    r"""asynchronously copy matrix from device to host

    hipblasGetMatrixAsync copies a matrix from device memory to pinned host memory asynchronously.
    Memory on the host must be allocated with hipHostMalloc or the transfer will be synchronous.

    Args:
        rows (`~.int`) -- *IN*:
            [int]
            number of rows in matrices

        cols (`~.int`) -- *IN*:
            [int]
            number of columns in matrices

        elemSize (`~.int`) -- *IN*:
            [int]
            number of bytes per element in the matrix

        AP (`~.hip._util.types.Pointer`/`~.object`) -- *IN*:
            pointer to matrix on the GPU

        lda (`~.int`) -- *IN*:
            [int]
            specifies the leading dimension of A, lda >= rows

        BP (`~.hip._util.types.Pointer`/`~.object`) -- *OUT*:
            pointer to matrix on the host

        ldb (`~.int`) -- *IN*:
            [int]
            specifies the leading dimension of B, ldb >= rows

        stream (`~.ihipStream_t`/`~.object`) -- *IN*:
            specifies the stream into which this transfer request is queued
    """
    _hipblasGetMatrixAsync__retval = hipblasStatus_t(chipblas.hipblasGetMatrixAsync(rows,cols,elemSize,
        <const void *>hip._util.types.Pointer.fromPyobj(AP)._ptr,lda,
        <void *>hip._util.types.Pointer.fromPyobj(BP)._ptr,ldb,
        ihipStream_t.fromPyobj(stream).getElementPtr()))
    return (_hipblasGetMatrixAsync__retval,)


@cython.embedsignature(True)
def hipblasSetAtomicsMode(object handle, object atomics_mode):
    r"""Set hipblasSetAtomicsMode*/

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        atomics_mode (`~.hipblasAtomicsMode_t`):
            (undocumented)
    """
    if not isinstance(atomics_mode,_hipblasAtomicsMode_t__Base):
        raise TypeError("argument 'atomics_mode' must be of type '_hipblasAtomicsMode_t__Base'")
    _hipblasSetAtomicsMode__retval = hipblasStatus_t(chipblas.hipblasSetAtomicsMode(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,atomics_mode.value))
    return (_hipblasSetAtomicsMode__retval,)


@cython.embedsignature(True)
def hipblasGetAtomicsMode(object handle, object atomics_mode):
    r"""Get hipblasSetAtomicsMode*/

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        atomics_mode (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)
    """
    _hipblasGetAtomicsMode__retval = hipblasStatus_t(chipblas.hipblasGetAtomicsMode(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,
        <chipblas.hipblasAtomicsMode_t *>hip._util.types.Pointer.fromPyobj(atomics_mode)._ptr))
    return (_hipblasGetAtomicsMode__retval,)


@cython.embedsignature(True)
def hipblasIsamax(object handle, int n, object x, int incx, object result):
    r"""BLAS Level 1 API

    @{

    amax finds the first index of the element of maximum magnitude of a vector x.

    - Supported precisions in rocBLAS : s,d,c,z.
    - Supported precisions in cuBLAS  : s,d,c,z.

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`) -- *IN*:
            [hipblasHandle_t]
            handle to the hipblas library context queue.

        n (`~.int`) -- *IN*:
            [int]
            the number of elements in x.

        x (`~.hip._util.types.Pointer`/`~.object`) -- *IN*:
            device pointer storing vector x.

        incx (`~.int`) -- *IN*:
            [int]
            specifies the increment for the elements of y.

        result (`~.hip._util.types.ListOfInt`/`~.object`) -- *INOUT*:
            device pointer or host pointer to store the amax index.
            return is 0.0 if n, incx<=0.
    """
    _hipblasIsamax__retval = hipblasStatus_t(chipblas.hipblasIsamax(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,n,
        <const float *>hip._util.types.Pointer.fromPyobj(x)._ptr,incx,
        <int *>hip._util.types.ListOfInt.fromPyobj(result)._ptr))
    return (_hipblasIsamax__retval,)


@cython.embedsignature(True)
def hipblasIdamax(object handle, int n, object x, int incx, object result):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        x (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        result (`~.hip._util.types.ListOfInt`/`~.object`):
            (undocumented)
    """
    _hipblasIdamax__retval = hipblasStatus_t(chipblas.hipblasIdamax(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,n,
        <const double *>hip._util.types.Pointer.fromPyobj(x)._ptr,incx,
        <int *>hip._util.types.ListOfInt.fromPyobj(result)._ptr))
    return (_hipblasIdamax__retval,)


@cython.embedsignature(True)
def hipblasIcamax(object handle, int n, object x, int incx, object result):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        x (`~.hipblasComplex`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        result (`~.hip._util.types.ListOfInt`/`~.object`):
            (undocumented)
    """
    _hipblasIcamax__retval = hipblasStatus_t(chipblas.hipblasIcamax(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,n,
        hipblasComplex.fromPyobj(x).getElementPtr(),incx,
        <int *>hip._util.types.ListOfInt.fromPyobj(result)._ptr))
    return (_hipblasIcamax__retval,)


@cython.embedsignature(True)
def hipblasIzamax(object handle, int n, object x, int incx, object result):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        x (`~.hipblasDoubleComplex`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        result (`~.hip._util.types.ListOfInt`/`~.object`):
            (undocumented)
    """
    _hipblasIzamax__retval = hipblasStatus_t(chipblas.hipblasIzamax(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,n,
        hipblasDoubleComplex.fromPyobj(x).getElementPtr(),incx,
        <int *>hip._util.types.ListOfInt.fromPyobj(result)._ptr))
    return (_hipblasIzamax__retval,)


@cython.embedsignature(True)
def hipblasIcamax_v2(object handle, int n, object x, int incx, object result):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        x (`~.float2`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        result (`~.hip._util.types.ListOfInt`/`~.object`):
            (undocumented)
    """
    _hipblasIcamax_v2__retval = hipblasStatus_t(chipblas.hipblasIcamax_v2(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,n,
        float2.fromPyobj(x).getElementPtr(),incx,
        <int *>hip._util.types.ListOfInt.fromPyobj(result)._ptr))
    return (_hipblasIcamax_v2__retval,)


@cython.embedsignature(True)
def hipblasIzamax_v2(object handle, int n, object x, int incx, object result):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        x (`~.double2`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        result (`~.hip._util.types.ListOfInt`/`~.object`):
            (undocumented)
    """
    _hipblasIzamax_v2__retval = hipblasStatus_t(chipblas.hipblasIzamax_v2(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,n,
        double2.fromPyobj(x).getElementPtr(),incx,
        <int *>hip._util.types.ListOfInt.fromPyobj(result)._ptr))
    return (_hipblasIzamax_v2__retval,)


@cython.embedsignature(True)
def hipblasIsamax_64(object handle, long n, object x, long incx, object result):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        x (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        result (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)
    """
    _hipblasIsamax_64__retval = hipblasStatus_t(chipblas.hipblasIsamax_64(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,n,
        <const float *>hip._util.types.Pointer.fromPyobj(x)._ptr,incx,
        <long *>hip._util.types.Pointer.fromPyobj(result)._ptr))
    return (_hipblasIsamax_64__retval,)


@cython.embedsignature(True)
def hipblasIdamax_64(object handle, long n, object x, long incx, object result):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        x (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        result (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)
    """
    _hipblasIdamax_64__retval = hipblasStatus_t(chipblas.hipblasIdamax_64(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,n,
        <const double *>hip._util.types.Pointer.fromPyobj(x)._ptr,incx,
        <long *>hip._util.types.Pointer.fromPyobj(result)._ptr))
    return (_hipblasIdamax_64__retval,)


@cython.embedsignature(True)
def hipblasIcamax_64(object handle, long n, object x, long incx, object result):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        x (`~.hipblasComplex`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        result (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)
    """
    _hipblasIcamax_64__retval = hipblasStatus_t(chipblas.hipblasIcamax_64(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,n,
        hipblasComplex.fromPyobj(x).getElementPtr(),incx,
        <long *>hip._util.types.Pointer.fromPyobj(result)._ptr))
    return (_hipblasIcamax_64__retval,)


@cython.embedsignature(True)
def hipblasIzamax_64(object handle, long n, object x, long incx, object result):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        x (`~.hipblasDoubleComplex`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        result (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)
    """
    _hipblasIzamax_64__retval = hipblasStatus_t(chipblas.hipblasIzamax_64(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,n,
        hipblasDoubleComplex.fromPyobj(x).getElementPtr(),incx,
        <long *>hip._util.types.Pointer.fromPyobj(result)._ptr))
    return (_hipblasIzamax_64__retval,)


@cython.embedsignature(True)
def hipblasIcamax_v2_64(object handle, long n, object x, long incx, object result):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        x (`~.float2`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        result (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)
    """
    _hipblasIcamax_v2_64__retval = hipblasStatus_t(chipblas.hipblasIcamax_v2_64(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,n,
        float2.fromPyobj(x).getElementPtr(),incx,
        <long *>hip._util.types.Pointer.fromPyobj(result)._ptr))
    return (_hipblasIcamax_v2_64__retval,)


@cython.embedsignature(True)
def hipblasIzamax_v2_64(object handle, long n, object x, long incx, object result):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        x (`~.double2`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        result (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)
    """
    _hipblasIzamax_v2_64__retval = hipblasStatus_t(chipblas.hipblasIzamax_v2_64(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,n,
        double2.fromPyobj(x).getElementPtr(),incx,
        <long *>hip._util.types.Pointer.fromPyobj(result)._ptr))
    return (_hipblasIzamax_v2_64__retval,)


@cython.embedsignature(True)
def hipblasIsamaxBatched(object handle, int n, object x, int incx, int batchCount, object result):
    r"""BLAS Level 1 API

    @{

    amaxBatched finds the first index of the element of maximum magnitude of each vector x_i in a batch, for i = 1, ..., batchCount.

    - Supported precisions in rocBLAS : s,d,c,z.
    - Supported precisions in cuBLAS  : No support.

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`) -- *IN*:
            [hipblasHandle_t]
            handle to the hipblas library context queue.

        n (`~.int`) -- *IN*:
            [int]
            number of elements in each vector x_i

        x (`~.hip._util.types.ListOfPointer`/`~.object`) -- *IN*:
            device array of device pointers storing each vector x_i.

        incx (`~.int`) -- *IN*:
            [int]
            specifies the increment for the elements of each x_i. incx must be > 0.

        batchCount (`~.int`) -- *IN*:
            [int]
            number of instances in the batch, must be > 0.

        result (`~.hip._util.types.ListOfInt`/`~.object`) -- *OUT*:
            device or host array of pointers of batchCount size for results.
            return is 0 if n, incx<=0.
    """
    _hipblasIsamaxBatched__retval = hipblasStatus_t(chipblas.hipblasIsamaxBatched(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,n,
        <const float *const*>hip._util.types.ListOfPointer.fromPyobj(x)._ptr,incx,batchCount,
        <int *>hip._util.types.ListOfInt.fromPyobj(result)._ptr))
    return (_hipblasIsamaxBatched__retval,)


@cython.embedsignature(True)
def hipblasIdamaxBatched(object handle, int n, object x, int incx, int batchCount, object result):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        x (`~.hip._util.types.ListOfPointer`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)

        result (`~.hip._util.types.ListOfInt`/`~.object`):
            (undocumented)
    """
    _hipblasIdamaxBatched__retval = hipblasStatus_t(chipblas.hipblasIdamaxBatched(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,n,
        <const double *const*>hip._util.types.ListOfPointer.fromPyobj(x)._ptr,incx,batchCount,
        <int *>hip._util.types.ListOfInt.fromPyobj(result)._ptr))
    return (_hipblasIdamaxBatched__retval,)


@cython.embedsignature(True)
def hipblasIcamaxBatched(object handle, int n, object x, int incx, int batchCount, object result):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        x (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)

        result (`~.hip._util.types.ListOfInt`/`~.object`):
            (undocumented)
    """
    _hipblasIcamaxBatched__retval = hipblasStatus_t(chipblas.hipblasIcamaxBatched(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,n,
        <chipblas.hipblasComplex *const*>hip._util.types.Pointer.fromPyobj(x)._ptr,incx,batchCount,
        <int *>hip._util.types.ListOfInt.fromPyobj(result)._ptr))
    return (_hipblasIcamaxBatched__retval,)


@cython.embedsignature(True)
def hipblasIzamaxBatched(object handle, int n, object x, int incx, int batchCount, object result):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        x (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)

        result (`~.hip._util.types.ListOfInt`/`~.object`):
            (undocumented)
    """
    _hipblasIzamaxBatched__retval = hipblasStatus_t(chipblas.hipblasIzamaxBatched(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,n,
        <chipblas.hipblasDoubleComplex *const*>hip._util.types.Pointer.fromPyobj(x)._ptr,incx,batchCount,
        <int *>hip._util.types.ListOfInt.fromPyobj(result)._ptr))
    return (_hipblasIzamaxBatched__retval,)


@cython.embedsignature(True)
def hipblasIcamaxBatched_v2(object handle, int n, object x, int incx, int batchCount, object result):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        x (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)

        result (`~.hip._util.types.ListOfInt`/`~.object`):
            (undocumented)
    """
    _hipblasIcamaxBatched_v2__retval = hipblasStatus_t(chipblas.hipblasIcamaxBatched_v2(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,n,
        <chipblas.float2 *const*>hip._util.types.Pointer.fromPyobj(x)._ptr,incx,batchCount,
        <int *>hip._util.types.ListOfInt.fromPyobj(result)._ptr))
    return (_hipblasIcamaxBatched_v2__retval,)


@cython.embedsignature(True)
def hipblasIzamaxBatched_v2(object handle, int n, object x, int incx, int batchCount, object result):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        x (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)

        result (`~.hip._util.types.ListOfInt`/`~.object`):
            (undocumented)
    """
    _hipblasIzamaxBatched_v2__retval = hipblasStatus_t(chipblas.hipblasIzamaxBatched_v2(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,n,
        <chipblas.double2 *const*>hip._util.types.Pointer.fromPyobj(x)._ptr,incx,batchCount,
        <int *>hip._util.types.ListOfInt.fromPyobj(result)._ptr))
    return (_hipblasIzamaxBatched_v2__retval,)


@cython.embedsignature(True)
def hipblasIsamaxBatched_64(object handle, long n, object x, long incx, long batchCount, object result):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        x (`~.hip._util.types.ListOfPointer`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)

        result (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)
    """
    _hipblasIsamaxBatched_64__retval = hipblasStatus_t(chipblas.hipblasIsamaxBatched_64(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,n,
        <const float *const*>hip._util.types.ListOfPointer.fromPyobj(x)._ptr,incx,batchCount,
        <long *>hip._util.types.Pointer.fromPyobj(result)._ptr))
    return (_hipblasIsamaxBatched_64__retval,)


@cython.embedsignature(True)
def hipblasIdamaxBatched_64(object handle, long n, object x, long incx, long batchCount, object result):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        x (`~.hip._util.types.ListOfPointer`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)

        result (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)
    """
    _hipblasIdamaxBatched_64__retval = hipblasStatus_t(chipblas.hipblasIdamaxBatched_64(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,n,
        <const double *const*>hip._util.types.ListOfPointer.fromPyobj(x)._ptr,incx,batchCount,
        <long *>hip._util.types.Pointer.fromPyobj(result)._ptr))
    return (_hipblasIdamaxBatched_64__retval,)


@cython.embedsignature(True)
def hipblasIcamaxBatched_64(object handle, long n, object x, long incx, long batchCount, object result):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        x (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)

        result (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)
    """
    _hipblasIcamaxBatched_64__retval = hipblasStatus_t(chipblas.hipblasIcamaxBatched_64(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,n,
        <chipblas.hipblasComplex *const*>hip._util.types.Pointer.fromPyobj(x)._ptr,incx,batchCount,
        <long *>hip._util.types.Pointer.fromPyobj(result)._ptr))
    return (_hipblasIcamaxBatched_64__retval,)


@cython.embedsignature(True)
def hipblasIzamaxBatched_64(object handle, long n, object x, long incx, long batchCount, object result):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        x (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)

        result (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)
    """
    _hipblasIzamaxBatched_64__retval = hipblasStatus_t(chipblas.hipblasIzamaxBatched_64(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,n,
        <chipblas.hipblasDoubleComplex *const*>hip._util.types.Pointer.fromPyobj(x)._ptr,incx,batchCount,
        <long *>hip._util.types.Pointer.fromPyobj(result)._ptr))
    return (_hipblasIzamaxBatched_64__retval,)


@cython.embedsignature(True)
def hipblasIcamaxBatched_v2_64(object handle, long n, object x, long incx, long batchCount, object result):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        x (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)

        result (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)
    """
    _hipblasIcamaxBatched_v2_64__retval = hipblasStatus_t(chipblas.hipblasIcamaxBatched_v2_64(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,n,
        <chipblas.float2 *const*>hip._util.types.Pointer.fromPyobj(x)._ptr,incx,batchCount,
        <long *>hip._util.types.Pointer.fromPyobj(result)._ptr))
    return (_hipblasIcamaxBatched_v2_64__retval,)


@cython.embedsignature(True)
def hipblasIzamaxBatched_v2_64(object handle, long n, object x, long incx, long batchCount, object result):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        x (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)

        result (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)
    """
    _hipblasIzamaxBatched_v2_64__retval = hipblasStatus_t(chipblas.hipblasIzamaxBatched_v2_64(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,n,
        <chipblas.double2 *const*>hip._util.types.Pointer.fromPyobj(x)._ptr,incx,batchCount,
        <long *>hip._util.types.Pointer.fromPyobj(result)._ptr))
    return (_hipblasIzamaxBatched_v2_64__retval,)


@cython.embedsignature(True)
def hipblasIsamaxStridedBatched(object handle, int n, object x, int incx, long stridex, int batchCount, object result):
    r"""BLAS Level 1 API

    @{

    amaxStridedBatched finds the first index of the element of maximum magnitude of each vector x_i in a batch, for i = 1, ..., batchCount.

    - Supported precisions in rocBLAS : s,d,c,z
    - Supported precisions in cuBLAS  : No support

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`) -- *IN*:
            [hipblasHandle_t]
            handle to the hipblas library context queue.

        n (`~.int`) -- *IN*:
            [int]
            number of elements in each vector x_i

        x (`~.hip._util.types.Pointer`/`~.object`) -- *IN*:
            device pointer to the first vector x_1.

        incx (`~.int`) -- *IN*:
            [int]
            specifies the increment for the elements of each x_i. incx must be > 0.

        stridex (`~.int`) -- *IN*:
            [hipblasStride]
            specifies the pointer increment between one x_i and the next x_(i + 1).

        batchCount (`~.int`) -- *IN*:
            [int]
            number of instances in the batch

        result (`~.hip._util.types.ListOfInt`/`~.object`) -- *OUT*:
            device or host pointer for storing contiguous batchCount results.
            return is 0 if n <= 0, incx<=0.
    """
    _hipblasIsamaxStridedBatched__retval = hipblasStatus_t(chipblas.hipblasIsamaxStridedBatched(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,n,
        <const float *>hip._util.types.Pointer.fromPyobj(x)._ptr,incx,stridex,batchCount,
        <int *>hip._util.types.ListOfInt.fromPyobj(result)._ptr))
    return (_hipblasIsamaxStridedBatched__retval,)


@cython.embedsignature(True)
def hipblasIdamaxStridedBatched(object handle, int n, object x, int incx, long stridex, int batchCount, object result):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        x (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        stridex (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)

        result (`~.hip._util.types.ListOfInt`/`~.object`):
            (undocumented)
    """
    _hipblasIdamaxStridedBatched__retval = hipblasStatus_t(chipblas.hipblasIdamaxStridedBatched(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,n,
        <const double *>hip._util.types.Pointer.fromPyobj(x)._ptr,incx,stridex,batchCount,
        <int *>hip._util.types.ListOfInt.fromPyobj(result)._ptr))
    return (_hipblasIdamaxStridedBatched__retval,)


@cython.embedsignature(True)
def hipblasIcamaxStridedBatched(object handle, int n, object x, int incx, long stridex, int batchCount, object result):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        x (`~.hipblasComplex`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        stridex (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)

        result (`~.hip._util.types.ListOfInt`/`~.object`):
            (undocumented)
    """
    _hipblasIcamaxStridedBatched__retval = hipblasStatus_t(chipblas.hipblasIcamaxStridedBatched(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,n,
        hipblasComplex.fromPyobj(x).getElementPtr(),incx,stridex,batchCount,
        <int *>hip._util.types.ListOfInt.fromPyobj(result)._ptr))
    return (_hipblasIcamaxStridedBatched__retval,)


@cython.embedsignature(True)
def hipblasIzamaxStridedBatched(object handle, int n, object x, int incx, long stridex, int batchCount, object result):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        x (`~.hipblasDoubleComplex`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        stridex (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)

        result (`~.hip._util.types.ListOfInt`/`~.object`):
            (undocumented)
    """
    _hipblasIzamaxStridedBatched__retval = hipblasStatus_t(chipblas.hipblasIzamaxStridedBatched(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,n,
        hipblasDoubleComplex.fromPyobj(x).getElementPtr(),incx,stridex,batchCount,
        <int *>hip._util.types.ListOfInt.fromPyobj(result)._ptr))
    return (_hipblasIzamaxStridedBatched__retval,)


@cython.embedsignature(True)
def hipblasIcamaxStridedBatched_v2(object handle, int n, object x, int incx, long stridex, int batchCount, object result):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        x (`~.float2`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        stridex (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)

        result (`~.hip._util.types.ListOfInt`/`~.object`):
            (undocumented)
    """
    _hipblasIcamaxStridedBatched_v2__retval = hipblasStatus_t(chipblas.hipblasIcamaxStridedBatched_v2(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,n,
        float2.fromPyobj(x).getElementPtr(),incx,stridex,batchCount,
        <int *>hip._util.types.ListOfInt.fromPyobj(result)._ptr))
    return (_hipblasIcamaxStridedBatched_v2__retval,)


@cython.embedsignature(True)
def hipblasIzamaxStridedBatched_v2(object handle, int n, object x, int incx, long stridex, int batchCount, object result):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        x (`~.double2`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        stridex (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)

        result (`~.hip._util.types.ListOfInt`/`~.object`):
            (undocumented)
    """
    _hipblasIzamaxStridedBatched_v2__retval = hipblasStatus_t(chipblas.hipblasIzamaxStridedBatched_v2(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,n,
        double2.fromPyobj(x).getElementPtr(),incx,stridex,batchCount,
        <int *>hip._util.types.ListOfInt.fromPyobj(result)._ptr))
    return (_hipblasIzamaxStridedBatched_v2__retval,)


@cython.embedsignature(True)
def hipblasIsamaxStridedBatched_64(object handle, long n, object x, long incx, long stridex, long batchCount, object result):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        x (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        stridex (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)

        result (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)
    """
    _hipblasIsamaxStridedBatched_64__retval = hipblasStatus_t(chipblas.hipblasIsamaxStridedBatched_64(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,n,
        <const float *>hip._util.types.Pointer.fromPyobj(x)._ptr,incx,stridex,batchCount,
        <long *>hip._util.types.Pointer.fromPyobj(result)._ptr))
    return (_hipblasIsamaxStridedBatched_64__retval,)


@cython.embedsignature(True)
def hipblasIdamaxStridedBatched_64(object handle, long n, object x, long incx, long stridex, long batchCount, object result):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        x (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        stridex (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)

        result (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)
    """
    _hipblasIdamaxStridedBatched_64__retval = hipblasStatus_t(chipblas.hipblasIdamaxStridedBatched_64(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,n,
        <const double *>hip._util.types.Pointer.fromPyobj(x)._ptr,incx,stridex,batchCount,
        <long *>hip._util.types.Pointer.fromPyobj(result)._ptr))
    return (_hipblasIdamaxStridedBatched_64__retval,)


@cython.embedsignature(True)
def hipblasIcamaxStridedBatched_64(object handle, long n, object x, long incx, long stridex, long batchCount, object result):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        x (`~.hipblasComplex`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        stridex (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)

        result (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)
    """
    _hipblasIcamaxStridedBatched_64__retval = hipblasStatus_t(chipblas.hipblasIcamaxStridedBatched_64(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,n,
        hipblasComplex.fromPyobj(x).getElementPtr(),incx,stridex,batchCount,
        <long *>hip._util.types.Pointer.fromPyobj(result)._ptr))
    return (_hipblasIcamaxStridedBatched_64__retval,)


@cython.embedsignature(True)
def hipblasIzamaxStridedBatched_64(object handle, long n, object x, long incx, long stridex, long batchCount, object result):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        x (`~.hipblasDoubleComplex`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        stridex (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)

        result (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)
    """
    _hipblasIzamaxStridedBatched_64__retval = hipblasStatus_t(chipblas.hipblasIzamaxStridedBatched_64(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,n,
        hipblasDoubleComplex.fromPyobj(x).getElementPtr(),incx,stridex,batchCount,
        <long *>hip._util.types.Pointer.fromPyobj(result)._ptr))
    return (_hipblasIzamaxStridedBatched_64__retval,)


@cython.embedsignature(True)
def hipblasIcamaxStridedBatched_v2_64(object handle, long n, object x, long incx, long stridex, long batchCount, object result):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        x (`~.float2`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        stridex (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)

        result (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)
    """
    _hipblasIcamaxStridedBatched_v2_64__retval = hipblasStatus_t(chipblas.hipblasIcamaxStridedBatched_v2_64(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,n,
        float2.fromPyobj(x).getElementPtr(),incx,stridex,batchCount,
        <long *>hip._util.types.Pointer.fromPyobj(result)._ptr))
    return (_hipblasIcamaxStridedBatched_v2_64__retval,)


@cython.embedsignature(True)
def hipblasIzamaxStridedBatched_v2_64(object handle, long n, object x, long incx, long stridex, long batchCount, object result):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        x (`~.double2`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        stridex (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)

        result (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)
    """
    _hipblasIzamaxStridedBatched_v2_64__retval = hipblasStatus_t(chipblas.hipblasIzamaxStridedBatched_v2_64(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,n,
        double2.fromPyobj(x).getElementPtr(),incx,stridex,batchCount,
        <long *>hip._util.types.Pointer.fromPyobj(result)._ptr))
    return (_hipblasIzamaxStridedBatched_v2_64__retval,)


@cython.embedsignature(True)
def hipblasIsamin(object handle, int n, object x, int incx, object result):
    r"""BLAS Level 1 API

    @{

    amin finds the first index of the element of minimum magnitude of a vector x.

    - Supported precisions in rocBLAS : s,d,c,z
    - Supported precisions in cuBLAS  : s,d,c,z

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`) -- *IN*:
            [hipblasHandle_t]
            handle to the hipblas library context queue.

        n (`~.int`) -- *IN*:
            [int]
            the number of elements in x.

        x (`~.hip._util.types.Pointer`/`~.object`) -- *IN*:
            device pointer storing vector x.

        incx (`~.int`) -- *IN*:
            [int]
            specifies the increment for the elements of y.

        result (`~.hip._util.types.ListOfInt`/`~.object`) -- *INOUT*:
            device pointer or host pointer to store the amin index.
            return is 0.0 if n, incx<=0.
    """
    _hipblasIsamin__retval = hipblasStatus_t(chipblas.hipblasIsamin(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,n,
        <const float *>hip._util.types.Pointer.fromPyobj(x)._ptr,incx,
        <int *>hip._util.types.ListOfInt.fromPyobj(result)._ptr))
    return (_hipblasIsamin__retval,)


@cython.embedsignature(True)
def hipblasIdamin(object handle, int n, object x, int incx, object result):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        x (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        result (`~.hip._util.types.ListOfInt`/`~.object`):
            (undocumented)
    """
    _hipblasIdamin__retval = hipblasStatus_t(chipblas.hipblasIdamin(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,n,
        <const double *>hip._util.types.Pointer.fromPyobj(x)._ptr,incx,
        <int *>hip._util.types.ListOfInt.fromPyobj(result)._ptr))
    return (_hipblasIdamin__retval,)


@cython.embedsignature(True)
def hipblasIcamin(object handle, int n, object x, int incx, object result):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        x (`~.hipblasComplex`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        result (`~.hip._util.types.ListOfInt`/`~.object`):
            (undocumented)
    """
    _hipblasIcamin__retval = hipblasStatus_t(chipblas.hipblasIcamin(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,n,
        hipblasComplex.fromPyobj(x).getElementPtr(),incx,
        <int *>hip._util.types.ListOfInt.fromPyobj(result)._ptr))
    return (_hipblasIcamin__retval,)


@cython.embedsignature(True)
def hipblasIzamin(object handle, int n, object x, int incx, object result):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        x (`~.hipblasDoubleComplex`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        result (`~.hip._util.types.ListOfInt`/`~.object`):
            (undocumented)
    """
    _hipblasIzamin__retval = hipblasStatus_t(chipblas.hipblasIzamin(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,n,
        hipblasDoubleComplex.fromPyobj(x).getElementPtr(),incx,
        <int *>hip._util.types.ListOfInt.fromPyobj(result)._ptr))
    return (_hipblasIzamin__retval,)


@cython.embedsignature(True)
def hipblasIcamin_v2(object handle, int n, object x, int incx, object result):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        x (`~.float2`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        result (`~.hip._util.types.ListOfInt`/`~.object`):
            (undocumented)
    """
    _hipblasIcamin_v2__retval = hipblasStatus_t(chipblas.hipblasIcamin_v2(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,n,
        float2.fromPyobj(x).getElementPtr(),incx,
        <int *>hip._util.types.ListOfInt.fromPyobj(result)._ptr))
    return (_hipblasIcamin_v2__retval,)


@cython.embedsignature(True)
def hipblasIzamin_v2(object handle, int n, object x, int incx, object result):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        x (`~.double2`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        result (`~.hip._util.types.ListOfInt`/`~.object`):
            (undocumented)
    """
    _hipblasIzamin_v2__retval = hipblasStatus_t(chipblas.hipblasIzamin_v2(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,n,
        double2.fromPyobj(x).getElementPtr(),incx,
        <int *>hip._util.types.ListOfInt.fromPyobj(result)._ptr))
    return (_hipblasIzamin_v2__retval,)


@cython.embedsignature(True)
def hipblasIsamin_64(object handle, long n, object x, long incx, object result):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        x (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        result (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)
    """
    _hipblasIsamin_64__retval = hipblasStatus_t(chipblas.hipblasIsamin_64(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,n,
        <const float *>hip._util.types.Pointer.fromPyobj(x)._ptr,incx,
        <long *>hip._util.types.Pointer.fromPyobj(result)._ptr))
    return (_hipblasIsamin_64__retval,)


@cython.embedsignature(True)
def hipblasIdamin_64(object handle, long n, object x, long incx, object result):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        x (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        result (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)
    """
    _hipblasIdamin_64__retval = hipblasStatus_t(chipblas.hipblasIdamin_64(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,n,
        <const double *>hip._util.types.Pointer.fromPyobj(x)._ptr,incx,
        <long *>hip._util.types.Pointer.fromPyobj(result)._ptr))
    return (_hipblasIdamin_64__retval,)


@cython.embedsignature(True)
def hipblasIcamin_64(object handle, long n, object x, long incx, object result):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        x (`~.hipblasComplex`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        result (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)
    """
    _hipblasIcamin_64__retval = hipblasStatus_t(chipblas.hipblasIcamin_64(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,n,
        hipblasComplex.fromPyobj(x).getElementPtr(),incx,
        <long *>hip._util.types.Pointer.fromPyobj(result)._ptr))
    return (_hipblasIcamin_64__retval,)


@cython.embedsignature(True)
def hipblasIzamin_64(object handle, long n, object x, long incx, object result):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        x (`~.hipblasDoubleComplex`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        result (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)
    """
    _hipblasIzamin_64__retval = hipblasStatus_t(chipblas.hipblasIzamin_64(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,n,
        hipblasDoubleComplex.fromPyobj(x).getElementPtr(),incx,
        <long *>hip._util.types.Pointer.fromPyobj(result)._ptr))
    return (_hipblasIzamin_64__retval,)


@cython.embedsignature(True)
def hipblasIcamin_v2_64(object handle, long n, object x, long incx, object result):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        x (`~.float2`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        result (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)
    """
    _hipblasIcamin_v2_64__retval = hipblasStatus_t(chipblas.hipblasIcamin_v2_64(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,n,
        float2.fromPyobj(x).getElementPtr(),incx,
        <long *>hip._util.types.Pointer.fromPyobj(result)._ptr))
    return (_hipblasIcamin_v2_64__retval,)


@cython.embedsignature(True)
def hipblasIzamin_v2_64(object handle, long n, object x, long incx, object result):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        x (`~.double2`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        result (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)
    """
    _hipblasIzamin_v2_64__retval = hipblasStatus_t(chipblas.hipblasIzamin_v2_64(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,n,
        double2.fromPyobj(x).getElementPtr(),incx,
        <long *>hip._util.types.Pointer.fromPyobj(result)._ptr))
    return (_hipblasIzamin_v2_64__retval,)


@cython.embedsignature(True)
def hipblasIsaminBatched(object handle, int n, object x, int incx, int batchCount, object result):
    r"""BLAS Level 1 API

    @{

    aminBatched finds the first index of the element of minimum magnitude of each vector x_i in a batch, for i = 1, ..., batchCount.

    - Supported precisions in rocBLAS : s,d,c,z
    - Supported precisions in cuBLAS  : No support

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`) -- *IN*:
            [hipblasHandle_t]
            handle to the hipblas library context queue.

        n (`~.int`) -- *IN*:
            [int]
            number of elements in each vector x_i

        x (`~.hip._util.types.ListOfPointer`/`~.object`) -- *IN*:
            device array of device pointers storing each vector x_i.

        incx (`~.int`) -- *IN*:
            [int]
            specifies the increment for the elements of each x_i. incx must be > 0.

        batchCount (`~.int`) -- *IN*:
            [int]
            number of instances in the batch, must be > 0.

        result (`~.hip._util.types.ListOfInt`/`~.object`) -- *OUT*:
            device or host pointers to array of batchCount size for results.
            return is 0 if n, incx<=0.
    """
    _hipblasIsaminBatched__retval = hipblasStatus_t(chipblas.hipblasIsaminBatched(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,n,
        <const float *const*>hip._util.types.ListOfPointer.fromPyobj(x)._ptr,incx,batchCount,
        <int *>hip._util.types.ListOfInt.fromPyobj(result)._ptr))
    return (_hipblasIsaminBatched__retval,)


@cython.embedsignature(True)
def hipblasIdaminBatched(object handle, int n, object x, int incx, int batchCount, object result):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        x (`~.hip._util.types.ListOfPointer`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)

        result (`~.hip._util.types.ListOfInt`/`~.object`):
            (undocumented)
    """
    _hipblasIdaminBatched__retval = hipblasStatus_t(chipblas.hipblasIdaminBatched(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,n,
        <const double *const*>hip._util.types.ListOfPointer.fromPyobj(x)._ptr,incx,batchCount,
        <int *>hip._util.types.ListOfInt.fromPyobj(result)._ptr))
    return (_hipblasIdaminBatched__retval,)


@cython.embedsignature(True)
def hipblasIcaminBatched(object handle, int n, object x, int incx, int batchCount, object result):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        x (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)

        result (`~.hip._util.types.ListOfInt`/`~.object`):
            (undocumented)
    """
    _hipblasIcaminBatched__retval = hipblasStatus_t(chipblas.hipblasIcaminBatched(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,n,
        <chipblas.hipblasComplex *const*>hip._util.types.Pointer.fromPyobj(x)._ptr,incx,batchCount,
        <int *>hip._util.types.ListOfInt.fromPyobj(result)._ptr))
    return (_hipblasIcaminBatched__retval,)


@cython.embedsignature(True)
def hipblasIzaminBatched(object handle, int n, object x, int incx, int batchCount, object result):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        x (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)

        result (`~.hip._util.types.ListOfInt`/`~.object`):
            (undocumented)
    """
    _hipblasIzaminBatched__retval = hipblasStatus_t(chipblas.hipblasIzaminBatched(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,n,
        <chipblas.hipblasDoubleComplex *const*>hip._util.types.Pointer.fromPyobj(x)._ptr,incx,batchCount,
        <int *>hip._util.types.ListOfInt.fromPyobj(result)._ptr))
    return (_hipblasIzaminBatched__retval,)


@cython.embedsignature(True)
def hipblasIcaminBatched_v2(object handle, int n, object x, int incx, int batchCount, object result):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        x (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)

        result (`~.hip._util.types.ListOfInt`/`~.object`):
            (undocumented)
    """
    _hipblasIcaminBatched_v2__retval = hipblasStatus_t(chipblas.hipblasIcaminBatched_v2(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,n,
        <chipblas.float2 *const*>hip._util.types.Pointer.fromPyobj(x)._ptr,incx,batchCount,
        <int *>hip._util.types.ListOfInt.fromPyobj(result)._ptr))
    return (_hipblasIcaminBatched_v2__retval,)


@cython.embedsignature(True)
def hipblasIzaminBatched_v2(object handle, int n, object x, int incx, int batchCount, object result):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        x (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)

        result (`~.hip._util.types.ListOfInt`/`~.object`):
            (undocumented)
    """
    _hipblasIzaminBatched_v2__retval = hipblasStatus_t(chipblas.hipblasIzaminBatched_v2(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,n,
        <chipblas.double2 *const*>hip._util.types.Pointer.fromPyobj(x)._ptr,incx,batchCount,
        <int *>hip._util.types.ListOfInt.fromPyobj(result)._ptr))
    return (_hipblasIzaminBatched_v2__retval,)


@cython.embedsignature(True)
def hipblasIsaminBatched_64(object handle, long n, object x, long incx, long batchCount, object result):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        x (`~.hip._util.types.ListOfPointer`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)

        result (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)
    """
    _hipblasIsaminBatched_64__retval = hipblasStatus_t(chipblas.hipblasIsaminBatched_64(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,n,
        <const float *const*>hip._util.types.ListOfPointer.fromPyobj(x)._ptr,incx,batchCount,
        <long *>hip._util.types.Pointer.fromPyobj(result)._ptr))
    return (_hipblasIsaminBatched_64__retval,)


@cython.embedsignature(True)
def hipblasIdaminBatched_64(object handle, long n, object x, long incx, long batchCount, object result):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        x (`~.hip._util.types.ListOfPointer`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)

        result (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)
    """
    _hipblasIdaminBatched_64__retval = hipblasStatus_t(chipblas.hipblasIdaminBatched_64(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,n,
        <const double *const*>hip._util.types.ListOfPointer.fromPyobj(x)._ptr,incx,batchCount,
        <long *>hip._util.types.Pointer.fromPyobj(result)._ptr))
    return (_hipblasIdaminBatched_64__retval,)


@cython.embedsignature(True)
def hipblasIcaminBatched_64(object handle, long n, object x, long incx, long batchCount, object result):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        x (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)

        result (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)
    """
    _hipblasIcaminBatched_64__retval = hipblasStatus_t(chipblas.hipblasIcaminBatched_64(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,n,
        <chipblas.hipblasComplex *const*>hip._util.types.Pointer.fromPyobj(x)._ptr,incx,batchCount,
        <long *>hip._util.types.Pointer.fromPyobj(result)._ptr))
    return (_hipblasIcaminBatched_64__retval,)


@cython.embedsignature(True)
def hipblasIzaminBatched_64(object handle, long n, object x, long incx, long batchCount, object result):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        x (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)

        result (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)
    """
    _hipblasIzaminBatched_64__retval = hipblasStatus_t(chipblas.hipblasIzaminBatched_64(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,n,
        <chipblas.hipblasDoubleComplex *const*>hip._util.types.Pointer.fromPyobj(x)._ptr,incx,batchCount,
        <long *>hip._util.types.Pointer.fromPyobj(result)._ptr))
    return (_hipblasIzaminBatched_64__retval,)


@cython.embedsignature(True)
def hipblasIcaminBatched_v2_64(object handle, long n, object x, long incx, long batchCount, object result):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        x (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)

        result (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)
    """
    _hipblasIcaminBatched_v2_64__retval = hipblasStatus_t(chipblas.hipblasIcaminBatched_v2_64(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,n,
        <chipblas.float2 *const*>hip._util.types.Pointer.fromPyobj(x)._ptr,incx,batchCount,
        <long *>hip._util.types.Pointer.fromPyobj(result)._ptr))
    return (_hipblasIcaminBatched_v2_64__retval,)


@cython.embedsignature(True)
def hipblasIzaminBatched_v2_64(object handle, long n, object x, long incx, long batchCount, object result):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        x (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)

        result (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)
    """
    _hipblasIzaminBatched_v2_64__retval = hipblasStatus_t(chipblas.hipblasIzaminBatched_v2_64(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,n,
        <chipblas.double2 *const*>hip._util.types.Pointer.fromPyobj(x)._ptr,incx,batchCount,
        <long *>hip._util.types.Pointer.fromPyobj(result)._ptr))
    return (_hipblasIzaminBatched_v2_64__retval,)


@cython.embedsignature(True)
def hipblasIsaminStridedBatched(object handle, int n, object x, int incx, long stridex, int batchCount, object result):
    r"""BLAS Level 1 API

    @{

    aminStridedBatched finds the first index of the element of minimum magnitude of each vector x_i in a batch, for i = 1, ..., batchCount.

    - Supported precisions in rocBLAS : s,d,c,z
    - Supported precisions in cuBLAS  : No support

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`) -- *IN*:
            [hipblasHandle_t]
            handle to the hipblas library context queue.

        n (`~.int`) -- *IN*:
            [int]
            number of elements in each vector x_i

        x (`~.hip._util.types.Pointer`/`~.object`) -- *IN*:
            device pointer to the first vector x_1.

        incx (`~.int`) -- *IN*:
            [int]
            specifies the increment for the elements of each x_i. incx must be > 0.

        stridex (`~.int`) -- *IN*:
            [hipblasStride]
            specifies the pointer increment between one x_i and the next x_(i + 1)

        batchCount (`~.int`) -- *IN*:
            [int]
            number of instances in the batch

        result (`~.hip._util.types.ListOfInt`/`~.object`) -- *OUT*:
            device or host pointer to array for storing contiguous batchCount results.
            return is 0 if n <= 0, incx<=0.
    """
    _hipblasIsaminStridedBatched__retval = hipblasStatus_t(chipblas.hipblasIsaminStridedBatched(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,n,
        <const float *>hip._util.types.Pointer.fromPyobj(x)._ptr,incx,stridex,batchCount,
        <int *>hip._util.types.ListOfInt.fromPyobj(result)._ptr))
    return (_hipblasIsaminStridedBatched__retval,)


@cython.embedsignature(True)
def hipblasIdaminStridedBatched(object handle, int n, object x, int incx, long stridex, int batchCount, object result):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        x (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        stridex (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)

        result (`~.hip._util.types.ListOfInt`/`~.object`):
            (undocumented)
    """
    _hipblasIdaminStridedBatched__retval = hipblasStatus_t(chipblas.hipblasIdaminStridedBatched(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,n,
        <const double *>hip._util.types.Pointer.fromPyobj(x)._ptr,incx,stridex,batchCount,
        <int *>hip._util.types.ListOfInt.fromPyobj(result)._ptr))
    return (_hipblasIdaminStridedBatched__retval,)


@cython.embedsignature(True)
def hipblasIcaminStridedBatched(object handle, int n, object x, int incx, long stridex, int batchCount, object result):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        x (`~.hipblasComplex`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        stridex (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)

        result (`~.hip._util.types.ListOfInt`/`~.object`):
            (undocumented)
    """
    _hipblasIcaminStridedBatched__retval = hipblasStatus_t(chipblas.hipblasIcaminStridedBatched(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,n,
        hipblasComplex.fromPyobj(x).getElementPtr(),incx,stridex,batchCount,
        <int *>hip._util.types.ListOfInt.fromPyobj(result)._ptr))
    return (_hipblasIcaminStridedBatched__retval,)


@cython.embedsignature(True)
def hipblasIzaminStridedBatched(object handle, int n, object x, int incx, long stridex, int batchCount, object result):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        x (`~.hipblasDoubleComplex`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        stridex (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)

        result (`~.hip._util.types.ListOfInt`/`~.object`):
            (undocumented)
    """
    _hipblasIzaminStridedBatched__retval = hipblasStatus_t(chipblas.hipblasIzaminStridedBatched(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,n,
        hipblasDoubleComplex.fromPyobj(x).getElementPtr(),incx,stridex,batchCount,
        <int *>hip._util.types.ListOfInt.fromPyobj(result)._ptr))
    return (_hipblasIzaminStridedBatched__retval,)


@cython.embedsignature(True)
def hipblasIcaminStridedBatched_v2(object handle, int n, object x, int incx, long stridex, int batchCount, object result):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        x (`~.float2`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        stridex (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)

        result (`~.hip._util.types.ListOfInt`/`~.object`):
            (undocumented)
    """
    _hipblasIcaminStridedBatched_v2__retval = hipblasStatus_t(chipblas.hipblasIcaminStridedBatched_v2(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,n,
        float2.fromPyobj(x).getElementPtr(),incx,stridex,batchCount,
        <int *>hip._util.types.ListOfInt.fromPyobj(result)._ptr))
    return (_hipblasIcaminStridedBatched_v2__retval,)


@cython.embedsignature(True)
def hipblasIzaminStridedBatched_v2(object handle, int n, object x, int incx, long stridex, int batchCount, object result):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        x (`~.double2`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        stridex (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)

        result (`~.hip._util.types.ListOfInt`/`~.object`):
            (undocumented)
    """
    _hipblasIzaminStridedBatched_v2__retval = hipblasStatus_t(chipblas.hipblasIzaminStridedBatched_v2(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,n,
        double2.fromPyobj(x).getElementPtr(),incx,stridex,batchCount,
        <int *>hip._util.types.ListOfInt.fromPyobj(result)._ptr))
    return (_hipblasIzaminStridedBatched_v2__retval,)


@cython.embedsignature(True)
def hipblasIsaminStridedBatched_64(object handle, long n, object x, long incx, long stridex, long batchCount, object result):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        x (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        stridex (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)

        result (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)
    """
    _hipblasIsaminStridedBatched_64__retval = hipblasStatus_t(chipblas.hipblasIsaminStridedBatched_64(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,n,
        <const float *>hip._util.types.Pointer.fromPyobj(x)._ptr,incx,stridex,batchCount,
        <long *>hip._util.types.Pointer.fromPyobj(result)._ptr))
    return (_hipblasIsaminStridedBatched_64__retval,)


@cython.embedsignature(True)
def hipblasIdaminStridedBatched_64(object handle, long n, object x, long incx, long stridex, long batchCount, object result):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        x (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        stridex (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)

        result (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)
    """
    _hipblasIdaminStridedBatched_64__retval = hipblasStatus_t(chipblas.hipblasIdaminStridedBatched_64(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,n,
        <const double *>hip._util.types.Pointer.fromPyobj(x)._ptr,incx,stridex,batchCount,
        <long *>hip._util.types.Pointer.fromPyobj(result)._ptr))
    return (_hipblasIdaminStridedBatched_64__retval,)


@cython.embedsignature(True)
def hipblasIcaminStridedBatched_64(object handle, long n, object x, long incx, long stridex, long batchCount, object result):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        x (`~.hipblasComplex`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        stridex (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)

        result (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)
    """
    _hipblasIcaminStridedBatched_64__retval = hipblasStatus_t(chipblas.hipblasIcaminStridedBatched_64(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,n,
        hipblasComplex.fromPyobj(x).getElementPtr(),incx,stridex,batchCount,
        <long *>hip._util.types.Pointer.fromPyobj(result)._ptr))
    return (_hipblasIcaminStridedBatched_64__retval,)


@cython.embedsignature(True)
def hipblasIzaminStridedBatched_64(object handle, long n, object x, long incx, long stridex, long batchCount, object result):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        x (`~.hipblasDoubleComplex`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        stridex (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)

        result (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)
    """
    _hipblasIzaminStridedBatched_64__retval = hipblasStatus_t(chipblas.hipblasIzaminStridedBatched_64(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,n,
        hipblasDoubleComplex.fromPyobj(x).getElementPtr(),incx,stridex,batchCount,
        <long *>hip._util.types.Pointer.fromPyobj(result)._ptr))
    return (_hipblasIzaminStridedBatched_64__retval,)


@cython.embedsignature(True)
def hipblasIcaminStridedBatched_v2_64(object handle, long n, object x, long incx, long stridex, long batchCount, object result):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        x (`~.float2`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        stridex (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)

        result (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)
    """
    _hipblasIcaminStridedBatched_v2_64__retval = hipblasStatus_t(chipblas.hipblasIcaminStridedBatched_v2_64(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,n,
        float2.fromPyobj(x).getElementPtr(),incx,stridex,batchCount,
        <long *>hip._util.types.Pointer.fromPyobj(result)._ptr))
    return (_hipblasIcaminStridedBatched_v2_64__retval,)


@cython.embedsignature(True)
def hipblasIzaminStridedBatched_v2_64(object handle, long n, object x, long incx, long stridex, long batchCount, object result):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        x (`~.double2`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        stridex (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)

        result (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)
    """
    _hipblasIzaminStridedBatched_v2_64__retval = hipblasStatus_t(chipblas.hipblasIzaminStridedBatched_v2_64(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,n,
        double2.fromPyobj(x).getElementPtr(),incx,stridex,batchCount,
        <long *>hip._util.types.Pointer.fromPyobj(result)._ptr))
    return (_hipblasIzaminStridedBatched_v2_64__retval,)


@cython.embedsignature(True)
def hipblasSasum(object handle, int n, object x, int incx, object result):
    r"""BLAS Level 1 API

    @{

    asum computes the sum of the magnitudes of elements of a real vector x,
    or the sum of magnitudes of the real and imaginary parts of elements if x is a complex vector.

    - Supported precisions in rocBLAS : s,d,c,z
    - Supported precisions in cuBLAS  : s,d,c,z

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`) -- *IN*:
            [hipblasHandle_t]
            handle to the hipblas library context queue.

        n (`~.int`) -- *IN*:
            [int]
            the number of elements in x and y.

        x (`~.hip._util.types.Pointer`/`~.object`) -- *IN*:
            device pointer storing vector x.

        incx (`~.int`) -- *IN*:
            [int]
            specifies the increment for the elements of x. incx must be > 0.

        result (`~.hip._util.types.Pointer`/`~.object`) -- *INOUT*:
            device pointer or host pointer to store the asum product.
            return is 0.0 if n <= 0.
    """
    _hipblasSasum__retval = hipblasStatus_t(chipblas.hipblasSasum(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,n,
        <const float *>hip._util.types.Pointer.fromPyobj(x)._ptr,incx,
        <float *>hip._util.types.Pointer.fromPyobj(result)._ptr))
    return (_hipblasSasum__retval,)


@cython.embedsignature(True)
def hipblasDasum(object handle, int n, object x, int incx, object result):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        x (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        result (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)
    """
    _hipblasDasum__retval = hipblasStatus_t(chipblas.hipblasDasum(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,n,
        <const double *>hip._util.types.Pointer.fromPyobj(x)._ptr,incx,
        <double *>hip._util.types.Pointer.fromPyobj(result)._ptr))
    return (_hipblasDasum__retval,)


@cython.embedsignature(True)
def hipblasScasum(object handle, int n, object x, int incx, object result):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        x (`~.hipblasComplex`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        result (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)
    """
    _hipblasScasum__retval = hipblasStatus_t(chipblas.hipblasScasum(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,n,
        hipblasComplex.fromPyobj(x).getElementPtr(),incx,
        <float *>hip._util.types.Pointer.fromPyobj(result)._ptr))
    return (_hipblasScasum__retval,)


@cython.embedsignature(True)
def hipblasDzasum(object handle, int n, object x, int incx, object result):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        x (`~.hipblasDoubleComplex`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        result (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)
    """
    _hipblasDzasum__retval = hipblasStatus_t(chipblas.hipblasDzasum(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,n,
        hipblasDoubleComplex.fromPyobj(x).getElementPtr(),incx,
        <double *>hip._util.types.Pointer.fromPyobj(result)._ptr))
    return (_hipblasDzasum__retval,)


@cython.embedsignature(True)
def hipblasScasum_v2(object handle, int n, object x, int incx, object result):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        x (`~.float2`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        result (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)
    """
    _hipblasScasum_v2__retval = hipblasStatus_t(chipblas.hipblasScasum_v2(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,n,
        float2.fromPyobj(x).getElementPtr(),incx,
        <float *>hip._util.types.Pointer.fromPyobj(result)._ptr))
    return (_hipblasScasum_v2__retval,)


@cython.embedsignature(True)
def hipblasDzasum_v2(object handle, int n, object x, int incx, object result):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        x (`~.double2`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        result (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)
    """
    _hipblasDzasum_v2__retval = hipblasStatus_t(chipblas.hipblasDzasum_v2(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,n,
        double2.fromPyobj(x).getElementPtr(),incx,
        <double *>hip._util.types.Pointer.fromPyobj(result)._ptr))
    return (_hipblasDzasum_v2__retval,)


@cython.embedsignature(True)
def hipblasSasum_64(object handle, long n, object x, long incx, object result):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        x (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        result (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)
    """
    _hipblasSasum_64__retval = hipblasStatus_t(chipblas.hipblasSasum_64(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,n,
        <const float *>hip._util.types.Pointer.fromPyobj(x)._ptr,incx,
        <float *>hip._util.types.Pointer.fromPyobj(result)._ptr))
    return (_hipblasSasum_64__retval,)


@cython.embedsignature(True)
def hipblasDasum_64(object handle, long n, object x, long incx, object result):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        x (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        result (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)
    """
    _hipblasDasum_64__retval = hipblasStatus_t(chipblas.hipblasDasum_64(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,n,
        <const double *>hip._util.types.Pointer.fromPyobj(x)._ptr,incx,
        <double *>hip._util.types.Pointer.fromPyobj(result)._ptr))
    return (_hipblasDasum_64__retval,)


@cython.embedsignature(True)
def hipblasScasum_64(object handle, long n, object x, long incx, object result):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        x (`~.hipblasComplex`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        result (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)
    """
    _hipblasScasum_64__retval = hipblasStatus_t(chipblas.hipblasScasum_64(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,n,
        hipblasComplex.fromPyobj(x).getElementPtr(),incx,
        <float *>hip._util.types.Pointer.fromPyobj(result)._ptr))
    return (_hipblasScasum_64__retval,)


@cython.embedsignature(True)
def hipblasDzasum_64(object handle, long n, object x, long incx, object result):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        x (`~.hipblasDoubleComplex`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        result (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)
    """
    _hipblasDzasum_64__retval = hipblasStatus_t(chipblas.hipblasDzasum_64(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,n,
        hipblasDoubleComplex.fromPyobj(x).getElementPtr(),incx,
        <double *>hip._util.types.Pointer.fromPyobj(result)._ptr))
    return (_hipblasDzasum_64__retval,)


@cython.embedsignature(True)
def hipblasScasum_v2_64(object handle, long n, object x, long incx, object result):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        x (`~.float2`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        result (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)
    """
    _hipblasScasum_v2_64__retval = hipblasStatus_t(chipblas.hipblasScasum_v2_64(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,n,
        float2.fromPyobj(x).getElementPtr(),incx,
        <float *>hip._util.types.Pointer.fromPyobj(result)._ptr))
    return (_hipblasScasum_v2_64__retval,)


@cython.embedsignature(True)
def hipblasDzasum_v2_64(object handle, long n, object x, long incx, object result):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        x (`~.double2`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        result (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)
    """
    _hipblasDzasum_v2_64__retval = hipblasStatus_t(chipblas.hipblasDzasum_v2_64(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,n,
        double2.fromPyobj(x).getElementPtr(),incx,
        <double *>hip._util.types.Pointer.fromPyobj(result)._ptr))
    return (_hipblasDzasum_v2_64__retval,)


@cython.embedsignature(True)
def hipblasSasumBatched(object handle, int n, object x, int incx, int batchCount, object result):
    r"""BLAS Level 1 API

    @{

    asumBatched computes the sum of the magnitudes of the elements in a batch of real vectors x_i,
    or the sum of magnitudes of the real and imaginary parts of elements if x_i is a complex
    vector, for i = 1, ..., batchCount.

    - Supported precisions in rocBLAS : s,d,c,z
    - Supported precisions in cuBLAS  : No support

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`) -- *IN*:
            [hipblasHandle_t]
            handle to the hipblas library context queue.

        n (`~.int`) -- *IN*:
            [int]
            number of elements in each vector x_i

        x (`~.hip._util.types.ListOfPointer`/`~.object`) -- *IN*:
            device array of device pointers storing each vector x_i.

        incx (`~.int`) -- *IN*:
            [int]
            specifies the increment for the elements of each x_i. incx must be > 0.

        batchCount (`~.int`) -- *IN*:
            [int]
            number of instances in the batch.

        result (`~.hip._util.types.Pointer`/`~.object`) -- *OUT*:
            device array or host array of batchCount size for results.
            return is 0.0 if n, incx<=0.
    """
    _hipblasSasumBatched__retval = hipblasStatus_t(chipblas.hipblasSasumBatched(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,n,
        <const float *const*>hip._util.types.ListOfPointer.fromPyobj(x)._ptr,incx,batchCount,
        <float *>hip._util.types.Pointer.fromPyobj(result)._ptr))
    return (_hipblasSasumBatched__retval,)


@cython.embedsignature(True)
def hipblasDasumBatched(object handle, int n, object x, int incx, int batchCount, object result):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        x (`~.hip._util.types.ListOfPointer`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)

        result (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)
    """
    _hipblasDasumBatched__retval = hipblasStatus_t(chipblas.hipblasDasumBatched(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,n,
        <const double *const*>hip._util.types.ListOfPointer.fromPyobj(x)._ptr,incx,batchCount,
        <double *>hip._util.types.Pointer.fromPyobj(result)._ptr))
    return (_hipblasDasumBatched__retval,)


@cython.embedsignature(True)
def hipblasScasumBatched(object handle, int n, object x, int incx, int batchCount, object result):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        x (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)

        result (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)
    """
    _hipblasScasumBatched__retval = hipblasStatus_t(chipblas.hipblasScasumBatched(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,n,
        <chipblas.hipblasComplex *const*>hip._util.types.Pointer.fromPyobj(x)._ptr,incx,batchCount,
        <float *>hip._util.types.Pointer.fromPyobj(result)._ptr))
    return (_hipblasScasumBatched__retval,)


@cython.embedsignature(True)
def hipblasDzasumBatched(object handle, int n, object x, int incx, int batchCount, object result):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        x (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)

        result (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)
    """
    _hipblasDzasumBatched__retval = hipblasStatus_t(chipblas.hipblasDzasumBatched(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,n,
        <chipblas.hipblasDoubleComplex *const*>hip._util.types.Pointer.fromPyobj(x)._ptr,incx,batchCount,
        <double *>hip._util.types.Pointer.fromPyobj(result)._ptr))
    return (_hipblasDzasumBatched__retval,)


@cython.embedsignature(True)
def hipblasScasumBatched_v2(object handle, int n, object x, int incx, int batchCount, object result):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        x (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)

        result (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)
    """
    _hipblasScasumBatched_v2__retval = hipblasStatus_t(chipblas.hipblasScasumBatched_v2(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,n,
        <chipblas.float2 *const*>hip._util.types.Pointer.fromPyobj(x)._ptr,incx,batchCount,
        <float *>hip._util.types.Pointer.fromPyobj(result)._ptr))
    return (_hipblasScasumBatched_v2__retval,)


@cython.embedsignature(True)
def hipblasDzasumBatched_v2(object handle, int n, object x, int incx, int batchCount, object result):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        x (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)

        result (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)
    """
    _hipblasDzasumBatched_v2__retval = hipblasStatus_t(chipblas.hipblasDzasumBatched_v2(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,n,
        <chipblas.double2 *const*>hip._util.types.Pointer.fromPyobj(x)._ptr,incx,batchCount,
        <double *>hip._util.types.Pointer.fromPyobj(result)._ptr))
    return (_hipblasDzasumBatched_v2__retval,)


@cython.embedsignature(True)
def hipblasSasumBatched_64(object handle, long n, object x, long incx, long batchCount, object result):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        x (`~.hip._util.types.ListOfPointer`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)

        result (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)
    """
    _hipblasSasumBatched_64__retval = hipblasStatus_t(chipblas.hipblasSasumBatched_64(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,n,
        <const float *const*>hip._util.types.ListOfPointer.fromPyobj(x)._ptr,incx,batchCount,
        <float *>hip._util.types.Pointer.fromPyobj(result)._ptr))
    return (_hipblasSasumBatched_64__retval,)


@cython.embedsignature(True)
def hipblasDasumBatched_64(object handle, long n, object x, long incx, long batchCount, object result):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        x (`~.hip._util.types.ListOfPointer`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)

        result (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)
    """
    _hipblasDasumBatched_64__retval = hipblasStatus_t(chipblas.hipblasDasumBatched_64(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,n,
        <const double *const*>hip._util.types.ListOfPointer.fromPyobj(x)._ptr,incx,batchCount,
        <double *>hip._util.types.Pointer.fromPyobj(result)._ptr))
    return (_hipblasDasumBatched_64__retval,)


@cython.embedsignature(True)
def hipblasScasumBatched_64(object handle, long n, object x, long incx, long batchCount, object result):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        x (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)

        result (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)
    """
    _hipblasScasumBatched_64__retval = hipblasStatus_t(chipblas.hipblasScasumBatched_64(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,n,
        <chipblas.hipblasComplex *const*>hip._util.types.Pointer.fromPyobj(x)._ptr,incx,batchCount,
        <float *>hip._util.types.Pointer.fromPyobj(result)._ptr))
    return (_hipblasScasumBatched_64__retval,)


@cython.embedsignature(True)
def hipblasDzasumBatched_64(object handle, long n, object x, long incx, long batchCount, object result):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        x (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)

        result (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)
    """
    _hipblasDzasumBatched_64__retval = hipblasStatus_t(chipblas.hipblasDzasumBatched_64(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,n,
        <chipblas.hipblasDoubleComplex *const*>hip._util.types.Pointer.fromPyobj(x)._ptr,incx,batchCount,
        <double *>hip._util.types.Pointer.fromPyobj(result)._ptr))
    return (_hipblasDzasumBatched_64__retval,)


@cython.embedsignature(True)
def hipblasScasumBatched_v2_64(object handle, long n, object x, long incx, long batchCount, object result):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        x (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)

        result (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)
    """
    _hipblasScasumBatched_v2_64__retval = hipblasStatus_t(chipblas.hipblasScasumBatched_v2_64(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,n,
        <chipblas.float2 *const*>hip._util.types.Pointer.fromPyobj(x)._ptr,incx,batchCount,
        <float *>hip._util.types.Pointer.fromPyobj(result)._ptr))
    return (_hipblasScasumBatched_v2_64__retval,)


@cython.embedsignature(True)
def hipblasDzasumBatched_v2_64(object handle, long n, object x, long incx, long batchCount, object result):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        x (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)

        result (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)
    """
    _hipblasDzasumBatched_v2_64__retval = hipblasStatus_t(chipblas.hipblasDzasumBatched_v2_64(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,n,
        <chipblas.double2 *const*>hip._util.types.Pointer.fromPyobj(x)._ptr,incx,batchCount,
        <double *>hip._util.types.Pointer.fromPyobj(result)._ptr))
    return (_hipblasDzasumBatched_v2_64__retval,)


@cython.embedsignature(True)
def hipblasSasumStridedBatched(object handle, int n, object x, int incx, long stridex, int batchCount, object result):
    r"""BLAS Level 1 API

    @{

    asumStridedBatched computes the sum of the magnitudes of elements of a real vectors x_i,
    or the sum of magnitudes of the real and imaginary parts of elements if x_i is a complex
    vector, for i = 1, ..., batchCount.

    - Supported precisions in rocBLAS : s,d,c,z
    - Supported precisions in cuBLAS  : No support

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`) -- *IN*:
            [hipblasHandle_t]
            handle to the hipblas library context queue.

        n (`~.int`) -- *IN*:
            [int]
            number of elements in each vector x_i

        x (`~.hip._util.types.Pointer`/`~.object`) -- *IN*:
            device pointer to the first vector x_1.

        incx (`~.int`) -- *IN*:
            [int]
            specifies the increment for the elements of each x_i. incx must be > 0.

        stridex (`~.int`) -- *IN*:
            [hipblasStride]
            stride from the start of one vector (x_i) and the next one (x_i+1).
            There are no restrictions placed on stride_x, however the user should
            take care to ensure that stride_x is of appropriate size, for a typical
            case this means stride_x >= n * incx.

        batchCount (`~.int`) -- *IN*:
            [int]
            number of instances in the batch

        result (`~.hip._util.types.Pointer`/`~.object`) -- *OUT*:
            device pointer or host pointer to array for storing contiguous batchCount results.
            return is 0.0 if n, incx<=0.
    """
    _hipblasSasumStridedBatched__retval = hipblasStatus_t(chipblas.hipblasSasumStridedBatched(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,n,
        <const float *>hip._util.types.Pointer.fromPyobj(x)._ptr,incx,stridex,batchCount,
        <float *>hip._util.types.Pointer.fromPyobj(result)._ptr))
    return (_hipblasSasumStridedBatched__retval,)


@cython.embedsignature(True)
def hipblasDasumStridedBatched(object handle, int n, object x, int incx, long stridex, int batchCount, object result):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        x (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        stridex (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)

        result (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)
    """
    _hipblasDasumStridedBatched__retval = hipblasStatus_t(chipblas.hipblasDasumStridedBatched(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,n,
        <const double *>hip._util.types.Pointer.fromPyobj(x)._ptr,incx,stridex,batchCount,
        <double *>hip._util.types.Pointer.fromPyobj(result)._ptr))
    return (_hipblasDasumStridedBatched__retval,)


@cython.embedsignature(True)
def hipblasScasumStridedBatched(object handle, int n, object x, int incx, long stridex, int batchCount, object result):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        x (`~.hipblasComplex`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        stridex (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)

        result (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)
    """
    _hipblasScasumStridedBatched__retval = hipblasStatus_t(chipblas.hipblasScasumStridedBatched(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,n,
        hipblasComplex.fromPyobj(x).getElementPtr(),incx,stridex,batchCount,
        <float *>hip._util.types.Pointer.fromPyobj(result)._ptr))
    return (_hipblasScasumStridedBatched__retval,)


@cython.embedsignature(True)
def hipblasDzasumStridedBatched(object handle, int n, object x, int incx, long stridex, int batchCount, object result):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        x (`~.hipblasDoubleComplex`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        stridex (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)

        result (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)
    """
    _hipblasDzasumStridedBatched__retval = hipblasStatus_t(chipblas.hipblasDzasumStridedBatched(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,n,
        hipblasDoubleComplex.fromPyobj(x).getElementPtr(),incx,stridex,batchCount,
        <double *>hip._util.types.Pointer.fromPyobj(result)._ptr))
    return (_hipblasDzasumStridedBatched__retval,)


@cython.embedsignature(True)
def hipblasScasumStridedBatched_v2(object handle, int n, object x, int incx, long stridex, int batchCount, object result):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        x (`~.float2`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        stridex (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)

        result (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)
    """
    _hipblasScasumStridedBatched_v2__retval = hipblasStatus_t(chipblas.hipblasScasumStridedBatched_v2(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,n,
        float2.fromPyobj(x).getElementPtr(),incx,stridex,batchCount,
        <float *>hip._util.types.Pointer.fromPyobj(result)._ptr))
    return (_hipblasScasumStridedBatched_v2__retval,)


@cython.embedsignature(True)
def hipblasDzasumStridedBatched_v2(object handle, int n, object x, int incx, long stridex, int batchCount, object result):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        x (`~.double2`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        stridex (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)

        result (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)
    """
    _hipblasDzasumStridedBatched_v2__retval = hipblasStatus_t(chipblas.hipblasDzasumStridedBatched_v2(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,n,
        double2.fromPyobj(x).getElementPtr(),incx,stridex,batchCount,
        <double *>hip._util.types.Pointer.fromPyobj(result)._ptr))
    return (_hipblasDzasumStridedBatched_v2__retval,)


@cython.embedsignature(True)
def hipblasSasumStridedBatched_64(object handle, long n, object x, long incx, long stridex, long batchCount, object result):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        x (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        stridex (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)

        result (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)
    """
    _hipblasSasumStridedBatched_64__retval = hipblasStatus_t(chipblas.hipblasSasumStridedBatched_64(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,n,
        <const float *>hip._util.types.Pointer.fromPyobj(x)._ptr,incx,stridex,batchCount,
        <float *>hip._util.types.Pointer.fromPyobj(result)._ptr))
    return (_hipblasSasumStridedBatched_64__retval,)


@cython.embedsignature(True)
def hipblasDasumStridedBatched_64(object handle, long n, object x, long incx, long stridex, long batchCount, object result):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        x (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        stridex (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)

        result (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)
    """
    _hipblasDasumStridedBatched_64__retval = hipblasStatus_t(chipblas.hipblasDasumStridedBatched_64(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,n,
        <const double *>hip._util.types.Pointer.fromPyobj(x)._ptr,incx,stridex,batchCount,
        <double *>hip._util.types.Pointer.fromPyobj(result)._ptr))
    return (_hipblasDasumStridedBatched_64__retval,)


@cython.embedsignature(True)
def hipblasScasumStridedBatched_64(object handle, long n, object x, long incx, long stridex, long batchCount, object result):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        x (`~.hipblasComplex`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        stridex (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)

        result (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)
    """
    _hipblasScasumStridedBatched_64__retval = hipblasStatus_t(chipblas.hipblasScasumStridedBatched_64(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,n,
        hipblasComplex.fromPyobj(x).getElementPtr(),incx,stridex,batchCount,
        <float *>hip._util.types.Pointer.fromPyobj(result)._ptr))
    return (_hipblasScasumStridedBatched_64__retval,)


@cython.embedsignature(True)
def hipblasDzasumStridedBatched_64(object handle, long n, object x, long incx, long stridex, long batchCount, object result):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        x (`~.hipblasDoubleComplex`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        stridex (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)

        result (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)
    """
    _hipblasDzasumStridedBatched_64__retval = hipblasStatus_t(chipblas.hipblasDzasumStridedBatched_64(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,n,
        hipblasDoubleComplex.fromPyobj(x).getElementPtr(),incx,stridex,batchCount,
        <double *>hip._util.types.Pointer.fromPyobj(result)._ptr))
    return (_hipblasDzasumStridedBatched_64__retval,)


@cython.embedsignature(True)
def hipblasScasumStridedBatched_v2_64(object handle, long n, object x, long incx, long stridex, long batchCount, object result):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        x (`~.float2`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        stridex (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)

        result (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)
    """
    _hipblasScasumStridedBatched_v2_64__retval = hipblasStatus_t(chipblas.hipblasScasumStridedBatched_v2_64(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,n,
        float2.fromPyobj(x).getElementPtr(),incx,stridex,batchCount,
        <float *>hip._util.types.Pointer.fromPyobj(result)._ptr))
    return (_hipblasScasumStridedBatched_v2_64__retval,)


@cython.embedsignature(True)
def hipblasDzasumStridedBatched_v2_64(object handle, long n, object x, long incx, long stridex, long batchCount, object result):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        x (`~.double2`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        stridex (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)

        result (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)
    """
    _hipblasDzasumStridedBatched_v2_64__retval = hipblasStatus_t(chipblas.hipblasDzasumStridedBatched_v2_64(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,n,
        double2.fromPyobj(x).getElementPtr(),incx,stridex,batchCount,
        <double *>hip._util.types.Pointer.fromPyobj(result)._ptr))
    return (_hipblasDzasumStridedBatched_v2_64__retval,)


@cython.embedsignature(True)
def hipblasHaxpy(object handle, int n, object alpha, object x, int incx, object y, int incy):
    r"""BLAS Level 1 API

    @{

    axpy   computes constant alpha multiplied by vector x, plus vector y

    y := alpha * x + y

    - Supported precisions in rocBLAS : h,s,d,c,z
    - Supported precisions in cuBLAS  : s,d,c,z

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`) -- *IN*:
            [hipblasHandle_t]
            handle to the hipblas library context queue.

        n (`~.int`) -- *IN*:
            [int]
            the number of elements in x and y.

        alpha (`~.hip._util.types.Pointer`/`~.object`) -- *IN*:
            device pointer or host pointer to specify the scalar alpha.

        x (`~.hip._util.types.Pointer`/`~.object`) -- *IN*:
            device pointer storing vector x.

        incx (`~.int`) -- *IN*:
            [int]
            specifies the increment for the elements of x.

        y (`~.hip._util.types.Pointer`/`~.object`) -- *OUT*:
            device pointer storing vector y.

        incy (`~.int`) -- *INOUT*:
            [int]
            specifies the increment for the elements of y.
    """
    _hipblasHaxpy__retval = hipblasStatus_t(chipblas.hipblasHaxpy(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,n,
        <const unsigned short *>hip._util.types.Pointer.fromPyobj(alpha)._ptr,
        <const unsigned short *>hip._util.types.Pointer.fromPyobj(x)._ptr,incx,
        <unsigned short *>hip._util.types.Pointer.fromPyobj(y)._ptr,incy))
    return (_hipblasHaxpy__retval,)


@cython.embedsignature(True)
def hipblasSaxpy(object handle, int n, object alpha, object x, int incx, object y, int incy):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        alpha (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        x (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        y (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        incy (`~.int`):
            (undocumented)
    """
    _hipblasSaxpy__retval = hipblasStatus_t(chipblas.hipblasSaxpy(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,n,
        <const float *>hip._util.types.Pointer.fromPyobj(alpha)._ptr,
        <const float *>hip._util.types.Pointer.fromPyobj(x)._ptr,incx,
        <float *>hip._util.types.Pointer.fromPyobj(y)._ptr,incy))
    return (_hipblasSaxpy__retval,)


@cython.embedsignature(True)
def hipblasDaxpy(object handle, int n, object alpha, object x, int incx, object y, int incy):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        alpha (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        x (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        y (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        incy (`~.int`):
            (undocumented)
    """
    _hipblasDaxpy__retval = hipblasStatus_t(chipblas.hipblasDaxpy(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,n,
        <const double *>hip._util.types.Pointer.fromPyobj(alpha)._ptr,
        <const double *>hip._util.types.Pointer.fromPyobj(x)._ptr,incx,
        <double *>hip._util.types.Pointer.fromPyobj(y)._ptr,incy))
    return (_hipblasDaxpy__retval,)


@cython.embedsignature(True)
def hipblasCaxpy(object handle, int n, object alpha, object x, int incx, object y, int incy):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        alpha (`~.hipblasComplex`/`~.object`):
            (undocumented)

        x (`~.hipblasComplex`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        y (`~.hipblasComplex`/`~.object`):
            (undocumented)

        incy (`~.int`):
            (undocumented)
    """
    _hipblasCaxpy__retval = hipblasStatus_t(chipblas.hipblasCaxpy(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,n,
        hipblasComplex.fromPyobj(alpha).getElementPtr(),
        hipblasComplex.fromPyobj(x).getElementPtr(),incx,
        hipblasComplex.fromPyobj(y).getElementPtr(),incy))
    return (_hipblasCaxpy__retval,)


@cython.embedsignature(True)
def hipblasZaxpy(object handle, int n, object alpha, object x, int incx, object y, int incy):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        alpha (`~.hipblasDoubleComplex`/`~.object`):
            (undocumented)

        x (`~.hipblasDoubleComplex`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        y (`~.hipblasDoubleComplex`/`~.object`):
            (undocumented)

        incy (`~.int`):
            (undocumented)
    """
    _hipblasZaxpy__retval = hipblasStatus_t(chipblas.hipblasZaxpy(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,n,
        hipblasDoubleComplex.fromPyobj(alpha).getElementPtr(),
        hipblasDoubleComplex.fromPyobj(x).getElementPtr(),incx,
        hipblasDoubleComplex.fromPyobj(y).getElementPtr(),incy))
    return (_hipblasZaxpy__retval,)


@cython.embedsignature(True)
def hipblasCaxpy_v2(object handle, int n, object alpha, object x, int incx, object y, int incy):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        alpha (`~.float2`/`~.object`):
            (undocumented)

        x (`~.float2`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        y (`~.float2`/`~.object`):
            (undocumented)

        incy (`~.int`):
            (undocumented)
    """
    _hipblasCaxpy_v2__retval = hipblasStatus_t(chipblas.hipblasCaxpy_v2(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,n,
        float2.fromPyobj(alpha).getElementPtr(),
        float2.fromPyobj(x).getElementPtr(),incx,
        float2.fromPyobj(y).getElementPtr(),incy))
    return (_hipblasCaxpy_v2__retval,)


@cython.embedsignature(True)
def hipblasZaxpy_v2(object handle, int n, object alpha, object x, int incx, object y, int incy):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        alpha (`~.double2`/`~.object`):
            (undocumented)

        x (`~.double2`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        y (`~.double2`/`~.object`):
            (undocumented)

        incy (`~.int`):
            (undocumented)
    """
    _hipblasZaxpy_v2__retval = hipblasStatus_t(chipblas.hipblasZaxpy_v2(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,n,
        double2.fromPyobj(alpha).getElementPtr(),
        double2.fromPyobj(x).getElementPtr(),incx,
        double2.fromPyobj(y).getElementPtr(),incy))
    return (_hipblasZaxpy_v2__retval,)


@cython.embedsignature(True)
def hipblasHaxpy_64(object handle, long n, object alpha, object x, long incx, object y, long incy):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        alpha (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        x (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        y (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        incy (`~.int`):
            (undocumented)
    """
    _hipblasHaxpy_64__retval = hipblasStatus_t(chipblas.hipblasHaxpy_64(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,n,
        <const unsigned short *>hip._util.types.Pointer.fromPyobj(alpha)._ptr,
        <const unsigned short *>hip._util.types.Pointer.fromPyobj(x)._ptr,incx,
        <unsigned short *>hip._util.types.Pointer.fromPyobj(y)._ptr,incy))
    return (_hipblasHaxpy_64__retval,)


@cython.embedsignature(True)
def hipblasSaxpy_64(object handle, long n, object alpha, object x, long incx, object y, long incy):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        alpha (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        x (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        y (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        incy (`~.int`):
            (undocumented)
    """
    _hipblasSaxpy_64__retval = hipblasStatus_t(chipblas.hipblasSaxpy_64(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,n,
        <const float *>hip._util.types.Pointer.fromPyobj(alpha)._ptr,
        <const float *>hip._util.types.Pointer.fromPyobj(x)._ptr,incx,
        <float *>hip._util.types.Pointer.fromPyobj(y)._ptr,incy))
    return (_hipblasSaxpy_64__retval,)


@cython.embedsignature(True)
def hipblasDaxpy_64(object handle, long n, object alpha, object x, long incx, object y, long incy):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        alpha (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        x (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        y (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        incy (`~.int`):
            (undocumented)
    """
    _hipblasDaxpy_64__retval = hipblasStatus_t(chipblas.hipblasDaxpy_64(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,n,
        <const double *>hip._util.types.Pointer.fromPyobj(alpha)._ptr,
        <const double *>hip._util.types.Pointer.fromPyobj(x)._ptr,incx,
        <double *>hip._util.types.Pointer.fromPyobj(y)._ptr,incy))
    return (_hipblasDaxpy_64__retval,)


@cython.embedsignature(True)
def hipblasCaxpy_64(object handle, long n, object alpha, object x, long incx, object y, long incy):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        alpha (`~.hipblasComplex`/`~.object`):
            (undocumented)

        x (`~.hipblasComplex`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        y (`~.hipblasComplex`/`~.object`):
            (undocumented)

        incy (`~.int`):
            (undocumented)
    """
    _hipblasCaxpy_64__retval = hipblasStatus_t(chipblas.hipblasCaxpy_64(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,n,
        hipblasComplex.fromPyobj(alpha).getElementPtr(),
        hipblasComplex.fromPyobj(x).getElementPtr(),incx,
        hipblasComplex.fromPyobj(y).getElementPtr(),incy))
    return (_hipblasCaxpy_64__retval,)


@cython.embedsignature(True)
def hipblasZaxpy_64(object handle, long n, object alpha, object x, long incx, object y, long incy):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        alpha (`~.hipblasDoubleComplex`/`~.object`):
            (undocumented)

        x (`~.hipblasDoubleComplex`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        y (`~.hipblasDoubleComplex`/`~.object`):
            (undocumented)

        incy (`~.int`):
            (undocumented)
    """
    _hipblasZaxpy_64__retval = hipblasStatus_t(chipblas.hipblasZaxpy_64(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,n,
        hipblasDoubleComplex.fromPyobj(alpha).getElementPtr(),
        hipblasDoubleComplex.fromPyobj(x).getElementPtr(),incx,
        hipblasDoubleComplex.fromPyobj(y).getElementPtr(),incy))
    return (_hipblasZaxpy_64__retval,)


@cython.embedsignature(True)
def hipblasCaxpy_v2_64(object handle, long n, object alpha, object x, long incx, object y, long incy):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        alpha (`~.float2`/`~.object`):
            (undocumented)

        x (`~.float2`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        y (`~.float2`/`~.object`):
            (undocumented)

        incy (`~.int`):
            (undocumented)
    """
    _hipblasCaxpy_v2_64__retval = hipblasStatus_t(chipblas.hipblasCaxpy_v2_64(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,n,
        float2.fromPyobj(alpha).getElementPtr(),
        float2.fromPyobj(x).getElementPtr(),incx,
        float2.fromPyobj(y).getElementPtr(),incy))
    return (_hipblasCaxpy_v2_64__retval,)


@cython.embedsignature(True)
def hipblasZaxpy_v2_64(object handle, long n, object alpha, object x, long incx, object y, long incy):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        alpha (`~.double2`/`~.object`):
            (undocumented)

        x (`~.double2`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        y (`~.double2`/`~.object`):
            (undocumented)

        incy (`~.int`):
            (undocumented)
    """
    _hipblasZaxpy_v2_64__retval = hipblasStatus_t(chipblas.hipblasZaxpy_v2_64(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,n,
        double2.fromPyobj(alpha).getElementPtr(),
        double2.fromPyobj(x).getElementPtr(),incx,
        double2.fromPyobj(y).getElementPtr(),incy))
    return (_hipblasZaxpy_v2_64__retval,)


@cython.embedsignature(True)
def hipblasHaxpyBatched(object handle, int n, object alpha, object x, int incx, object y, int incy, int batchCount):
    r"""BLAS Level 1 API

    @{

    axpyBatched   compute y := alpha * x + y over a set of batched vectors.

    - Supported precisions in rocBLAS : h,s,d,c,z
    - Supported precisions in cuBLAS  : No support

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`) -- *IN*:
            [hipblasHandle_t]
            handle to the hipblas library context queue.

        n (`~.int`) -- *IN*:
            [int]
            the number of elements in x and y.

        alpha (`~.hip._util.types.Pointer`/`~.object`) -- *IN*:
            specifies the scalar alpha.

        x (`~.hip._util.types.ListOfPointer`/`~.object`) -- *IN*:
            pointer storing vector x on the GPU.

        incx (`~.int`) -- *IN*:
            [int]
            specifies the increment for the elements of x.

        y (`~.hip._util.types.ListOfPointer`/`~.object`) -- *OUT*:
            pointer storing vector y on the GPU.

        incy (`~.int`) -- *INOUT*:
            [int]
            specifies the increment for the elements of y.

        batchCount (`~.int`) -- *IN*:
            [int]
            number of instances in the batch
    """
    _hipblasHaxpyBatched__retval = hipblasStatus_t(chipblas.hipblasHaxpyBatched(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,n,
        <const unsigned short *>hip._util.types.Pointer.fromPyobj(alpha)._ptr,
        <const unsigned short *const*>hip._util.types.ListOfPointer.fromPyobj(x)._ptr,incx,
        <unsigned short *const*>hip._util.types.ListOfPointer.fromPyobj(y)._ptr,incy,batchCount))
    return (_hipblasHaxpyBatched__retval,)


@cython.embedsignature(True)
def hipblasSaxpyBatched(object handle, int n, object alpha, object x, int incx, object y, int incy, int batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        alpha (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        x (`~.hip._util.types.ListOfPointer`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        y (`~.hip._util.types.ListOfPointer`/`~.object`):
            (undocumented)

        incy (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    _hipblasSaxpyBatched__retval = hipblasStatus_t(chipblas.hipblasSaxpyBatched(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,n,
        <const float *>hip._util.types.Pointer.fromPyobj(alpha)._ptr,
        <const float *const*>hip._util.types.ListOfPointer.fromPyobj(x)._ptr,incx,
        <float *const*>hip._util.types.ListOfPointer.fromPyobj(y)._ptr,incy,batchCount))
    return (_hipblasSaxpyBatched__retval,)


@cython.embedsignature(True)
def hipblasDaxpyBatched(object handle, int n, object alpha, object x, int incx, object y, int incy, int batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        alpha (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        x (`~.hip._util.types.ListOfPointer`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        y (`~.hip._util.types.ListOfPointer`/`~.object`):
            (undocumented)

        incy (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    _hipblasDaxpyBatched__retval = hipblasStatus_t(chipblas.hipblasDaxpyBatched(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,n,
        <const double *>hip._util.types.Pointer.fromPyobj(alpha)._ptr,
        <const double *const*>hip._util.types.ListOfPointer.fromPyobj(x)._ptr,incx,
        <double *const*>hip._util.types.ListOfPointer.fromPyobj(y)._ptr,incy,batchCount))
    return (_hipblasDaxpyBatched__retval,)


@cython.embedsignature(True)
def hipblasCaxpyBatched(object handle, int n, object alpha, object x, int incx, object y, int incy, int batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        alpha (`~.hipblasComplex`/`~.object`):
            (undocumented)

        x (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        y (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        incy (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    _hipblasCaxpyBatched__retval = hipblasStatus_t(chipblas.hipblasCaxpyBatched(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,n,
        hipblasComplex.fromPyobj(alpha).getElementPtr(),
        <chipblas.hipblasComplex *const*>hip._util.types.Pointer.fromPyobj(x)._ptr,incx,
        <chipblas.hipblasComplex *const*>hip._util.types.Pointer.fromPyobj(y)._ptr,incy,batchCount))
    return (_hipblasCaxpyBatched__retval,)


@cython.embedsignature(True)
def hipblasZaxpyBatched(object handle, int n, object alpha, object x, int incx, object y, int incy, int batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        alpha (`~.hipblasDoubleComplex`/`~.object`):
            (undocumented)

        x (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        y (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        incy (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    _hipblasZaxpyBatched__retval = hipblasStatus_t(chipblas.hipblasZaxpyBatched(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,n,
        hipblasDoubleComplex.fromPyobj(alpha).getElementPtr(),
        <chipblas.hipblasDoubleComplex *const*>hip._util.types.Pointer.fromPyobj(x)._ptr,incx,
        <chipblas.hipblasDoubleComplex *const*>hip._util.types.Pointer.fromPyobj(y)._ptr,incy,batchCount))
    return (_hipblasZaxpyBatched__retval,)


@cython.embedsignature(True)
def hipblasCaxpyBatched_v2(object handle, int n, object alpha, object x, int incx, object y, int incy, int batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        alpha (`~.float2`/`~.object`):
            (undocumented)

        x (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        y (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        incy (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    _hipblasCaxpyBatched_v2__retval = hipblasStatus_t(chipblas.hipblasCaxpyBatched_v2(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,n,
        float2.fromPyobj(alpha).getElementPtr(),
        <chipblas.float2 *const*>hip._util.types.Pointer.fromPyobj(x)._ptr,incx,
        <chipblas.float2 *const*>hip._util.types.Pointer.fromPyobj(y)._ptr,incy,batchCount))
    return (_hipblasCaxpyBatched_v2__retval,)


@cython.embedsignature(True)
def hipblasZaxpyBatched_v2(object handle, int n, object alpha, object x, int incx, object y, int incy, int batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        alpha (`~.double2`/`~.object`):
            (undocumented)

        x (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        y (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        incy (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    _hipblasZaxpyBatched_v2__retval = hipblasStatus_t(chipblas.hipblasZaxpyBatched_v2(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,n,
        double2.fromPyobj(alpha).getElementPtr(),
        <chipblas.double2 *const*>hip._util.types.Pointer.fromPyobj(x)._ptr,incx,
        <chipblas.double2 *const*>hip._util.types.Pointer.fromPyobj(y)._ptr,incy,batchCount))
    return (_hipblasZaxpyBatched_v2__retval,)


@cython.embedsignature(True)
def hipblasHaxpyBatched_64(object handle, long n, object alpha, object x, long incx, object y, long incy, long batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        alpha (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        x (`~.hip._util.types.ListOfPointer`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        y (`~.hip._util.types.ListOfPointer`/`~.object`):
            (undocumented)

        incy (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    _hipblasHaxpyBatched_64__retval = hipblasStatus_t(chipblas.hipblasHaxpyBatched_64(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,n,
        <const unsigned short *>hip._util.types.Pointer.fromPyobj(alpha)._ptr,
        <const unsigned short *const*>hip._util.types.ListOfPointer.fromPyobj(x)._ptr,incx,
        <unsigned short *const*>hip._util.types.ListOfPointer.fromPyobj(y)._ptr,incy,batchCount))
    return (_hipblasHaxpyBatched_64__retval,)


@cython.embedsignature(True)
def hipblasSaxpyBatched_64(object handle, long n, object alpha, object x, long incx, object y, long incy, long batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        alpha (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        x (`~.hip._util.types.ListOfPointer`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        y (`~.hip._util.types.ListOfPointer`/`~.object`):
            (undocumented)

        incy (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    _hipblasSaxpyBatched_64__retval = hipblasStatus_t(chipblas.hipblasSaxpyBatched_64(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,n,
        <const float *>hip._util.types.Pointer.fromPyobj(alpha)._ptr,
        <const float *const*>hip._util.types.ListOfPointer.fromPyobj(x)._ptr,incx,
        <float *const*>hip._util.types.ListOfPointer.fromPyobj(y)._ptr,incy,batchCount))
    return (_hipblasSaxpyBatched_64__retval,)


@cython.embedsignature(True)
def hipblasDaxpyBatched_64(object handle, long n, object alpha, object x, long incx, object y, long incy, long batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        alpha (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        x (`~.hip._util.types.ListOfPointer`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        y (`~.hip._util.types.ListOfPointer`/`~.object`):
            (undocumented)

        incy (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    _hipblasDaxpyBatched_64__retval = hipblasStatus_t(chipblas.hipblasDaxpyBatched_64(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,n,
        <const double *>hip._util.types.Pointer.fromPyobj(alpha)._ptr,
        <const double *const*>hip._util.types.ListOfPointer.fromPyobj(x)._ptr,incx,
        <double *const*>hip._util.types.ListOfPointer.fromPyobj(y)._ptr,incy,batchCount))
    return (_hipblasDaxpyBatched_64__retval,)


@cython.embedsignature(True)
def hipblasCaxpyBatched_64(object handle, long n, object alpha, object x, long incx, object y, long incy, long batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        alpha (`~.hipblasComplex`/`~.object`):
            (undocumented)

        x (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        y (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        incy (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    _hipblasCaxpyBatched_64__retval = hipblasStatus_t(chipblas.hipblasCaxpyBatched_64(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,n,
        hipblasComplex.fromPyobj(alpha).getElementPtr(),
        <chipblas.hipblasComplex *const*>hip._util.types.Pointer.fromPyobj(x)._ptr,incx,
        <chipblas.hipblasComplex *const*>hip._util.types.Pointer.fromPyobj(y)._ptr,incy,batchCount))
    return (_hipblasCaxpyBatched_64__retval,)


@cython.embedsignature(True)
def hipblasZaxpyBatched_64(object handle, long n, object alpha, object x, long incx, object y, long incy, long batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        alpha (`~.hipblasDoubleComplex`/`~.object`):
            (undocumented)

        x (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        y (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        incy (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    _hipblasZaxpyBatched_64__retval = hipblasStatus_t(chipblas.hipblasZaxpyBatched_64(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,n,
        hipblasDoubleComplex.fromPyobj(alpha).getElementPtr(),
        <chipblas.hipblasDoubleComplex *const*>hip._util.types.Pointer.fromPyobj(x)._ptr,incx,
        <chipblas.hipblasDoubleComplex *const*>hip._util.types.Pointer.fromPyobj(y)._ptr,incy,batchCount))
    return (_hipblasZaxpyBatched_64__retval,)


@cython.embedsignature(True)
def hipblasCaxpyBatched_v2_64(object handle, long n, object alpha, object x, long incx, object y, long incy, long batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        alpha (`~.float2`/`~.object`):
            (undocumented)

        x (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        y (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        incy (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    _hipblasCaxpyBatched_v2_64__retval = hipblasStatus_t(chipblas.hipblasCaxpyBatched_v2_64(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,n,
        float2.fromPyobj(alpha).getElementPtr(),
        <chipblas.float2 *const*>hip._util.types.Pointer.fromPyobj(x)._ptr,incx,
        <chipblas.float2 *const*>hip._util.types.Pointer.fromPyobj(y)._ptr,incy,batchCount))
    return (_hipblasCaxpyBatched_v2_64__retval,)


@cython.embedsignature(True)
def hipblasZaxpyBatched_v2_64(object handle, long n, object alpha, object x, long incx, object y, long incy, long batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        alpha (`~.double2`/`~.object`):
            (undocumented)

        x (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        y (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        incy (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    _hipblasZaxpyBatched_v2_64__retval = hipblasStatus_t(chipblas.hipblasZaxpyBatched_v2_64(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,n,
        double2.fromPyobj(alpha).getElementPtr(),
        <chipblas.double2 *const*>hip._util.types.Pointer.fromPyobj(x)._ptr,incx,
        <chipblas.double2 *const*>hip._util.types.Pointer.fromPyobj(y)._ptr,incy,batchCount))
    return (_hipblasZaxpyBatched_v2_64__retval,)


@cython.embedsignature(True)
def hipblasHaxpyStridedBatched(object handle, int n, object alpha, object x, int incx, long stridex, object y, int incy, long stridey, int batchCount):
    r"""BLAS Level 1 API

    @{

    axpyStridedBatched   compute y := alpha * x + y over a set of strided batched vectors.

    - Supported precisions in rocBLAS : h,s,d,c,z
    - Supported precisions in cuBLAS  : No support

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`) -- *IN*:
            [hipblasHandle_t]
            handle to the hipblas library context queue.

        n (`~.int`) -- *IN*:
            [int]

        alpha (`~.hip._util.types.Pointer`/`~.object`) -- *IN*:
            specifies the scalar alpha.

        x (`~.hip._util.types.Pointer`/`~.object`) -- *IN*:
            pointer storing vector x on the GPU.

        incx (`~.int`) -- *IN*:
            [int]
            specifies the increment for the elements of x.

        stridex (`~.int`) -- *IN*:
            [hipblasStride]
            specifies the increment between vectors of x.

        y (`~.hip._util.types.Pointer`/`~.object`) -- *OUT*:
            pointer storing vector y on the GPU.

        incy (`~.int`) -- *INOUT*:
            [int]
            specifies the increment for the elements of y.

        stridey (`~.int`) -- *IN*:
            [hipblasStride]
            specifies the increment between vectors of y.

        batchCount (`~.int`) -- *IN*:
            [int]
            number of instances in the batch
    """
    _hipblasHaxpyStridedBatched__retval = hipblasStatus_t(chipblas.hipblasHaxpyStridedBatched(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,n,
        <const unsigned short *>hip._util.types.Pointer.fromPyobj(alpha)._ptr,
        <const unsigned short *>hip._util.types.Pointer.fromPyobj(x)._ptr,incx,stridex,
        <unsigned short *>hip._util.types.Pointer.fromPyobj(y)._ptr,incy,stridey,batchCount))
    return (_hipblasHaxpyStridedBatched__retval,)


@cython.embedsignature(True)
def hipblasSaxpyStridedBatched(object handle, int n, object alpha, object x, int incx, long stridex, object y, int incy, long stridey, int batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        alpha (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        x (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        stridex (`~.int`):
            (undocumented)

        y (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        incy (`~.int`):
            (undocumented)

        stridey (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    _hipblasSaxpyStridedBatched__retval = hipblasStatus_t(chipblas.hipblasSaxpyStridedBatched(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,n,
        <const float *>hip._util.types.Pointer.fromPyobj(alpha)._ptr,
        <const float *>hip._util.types.Pointer.fromPyobj(x)._ptr,incx,stridex,
        <float *>hip._util.types.Pointer.fromPyobj(y)._ptr,incy,stridey,batchCount))
    return (_hipblasSaxpyStridedBatched__retval,)


@cython.embedsignature(True)
def hipblasDaxpyStridedBatched(object handle, int n, object alpha, object x, int incx, long stridex, object y, int incy, long stridey, int batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        alpha (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        x (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        stridex (`~.int`):
            (undocumented)

        y (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        incy (`~.int`):
            (undocumented)

        stridey (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    _hipblasDaxpyStridedBatched__retval = hipblasStatus_t(chipblas.hipblasDaxpyStridedBatched(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,n,
        <const double *>hip._util.types.Pointer.fromPyobj(alpha)._ptr,
        <const double *>hip._util.types.Pointer.fromPyobj(x)._ptr,incx,stridex,
        <double *>hip._util.types.Pointer.fromPyobj(y)._ptr,incy,stridey,batchCount))
    return (_hipblasDaxpyStridedBatched__retval,)


@cython.embedsignature(True)
def hipblasCaxpyStridedBatched(object handle, int n, object alpha, object x, int incx, long stridex, object y, int incy, long stridey, int batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        alpha (`~.hipblasComplex`/`~.object`):
            (undocumented)

        x (`~.hipblasComplex`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        stridex (`~.int`):
            (undocumented)

        y (`~.hipblasComplex`/`~.object`):
            (undocumented)

        incy (`~.int`):
            (undocumented)

        stridey (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    _hipblasCaxpyStridedBatched__retval = hipblasStatus_t(chipblas.hipblasCaxpyStridedBatched(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,n,
        hipblasComplex.fromPyobj(alpha).getElementPtr(),
        hipblasComplex.fromPyobj(x).getElementPtr(),incx,stridex,
        hipblasComplex.fromPyobj(y).getElementPtr(),incy,stridey,batchCount))
    return (_hipblasCaxpyStridedBatched__retval,)


@cython.embedsignature(True)
def hipblasZaxpyStridedBatched(object handle, int n, object alpha, object x, int incx, long stridex, object y, int incy, long stridey, int batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        alpha (`~.hipblasDoubleComplex`/`~.object`):
            (undocumented)

        x (`~.hipblasDoubleComplex`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        stridex (`~.int`):
            (undocumented)

        y (`~.hipblasDoubleComplex`/`~.object`):
            (undocumented)

        incy (`~.int`):
            (undocumented)

        stridey (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    _hipblasZaxpyStridedBatched__retval = hipblasStatus_t(chipblas.hipblasZaxpyStridedBatched(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,n,
        hipblasDoubleComplex.fromPyobj(alpha).getElementPtr(),
        hipblasDoubleComplex.fromPyobj(x).getElementPtr(),incx,stridex,
        hipblasDoubleComplex.fromPyobj(y).getElementPtr(),incy,stridey,batchCount))
    return (_hipblasZaxpyStridedBatched__retval,)


@cython.embedsignature(True)
def hipblasCaxpyStridedBatched_v2(object handle, int n, object alpha, object x, int incx, long stridex, object y, int incy, long stridey, int batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        alpha (`~.float2`/`~.object`):
            (undocumented)

        x (`~.float2`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        stridex (`~.int`):
            (undocumented)

        y (`~.float2`/`~.object`):
            (undocumented)

        incy (`~.int`):
            (undocumented)

        stridey (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    _hipblasCaxpyStridedBatched_v2__retval = hipblasStatus_t(chipblas.hipblasCaxpyStridedBatched_v2(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,n,
        float2.fromPyobj(alpha).getElementPtr(),
        float2.fromPyobj(x).getElementPtr(),incx,stridex,
        float2.fromPyobj(y).getElementPtr(),incy,stridey,batchCount))
    return (_hipblasCaxpyStridedBatched_v2__retval,)


@cython.embedsignature(True)
def hipblasZaxpyStridedBatched_v2(object handle, int n, object alpha, object x, int incx, long stridex, object y, int incy, long stridey, int batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        alpha (`~.double2`/`~.object`):
            (undocumented)

        x (`~.double2`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        stridex (`~.int`):
            (undocumented)

        y (`~.double2`/`~.object`):
            (undocumented)

        incy (`~.int`):
            (undocumented)

        stridey (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    _hipblasZaxpyStridedBatched_v2__retval = hipblasStatus_t(chipblas.hipblasZaxpyStridedBatched_v2(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,n,
        double2.fromPyobj(alpha).getElementPtr(),
        double2.fromPyobj(x).getElementPtr(),incx,stridex,
        double2.fromPyobj(y).getElementPtr(),incy,stridey,batchCount))
    return (_hipblasZaxpyStridedBatched_v2__retval,)


@cython.embedsignature(True)
def hipblasHaxpyStridedBatched_64(object handle, long n, object alpha, object x, long incx, long stridex, object y, long incy, long stridey, long batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        alpha (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        x (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        stridex (`~.int`):
            (undocumented)

        y (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        incy (`~.int`):
            (undocumented)

        stridey (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    _hipblasHaxpyStridedBatched_64__retval = hipblasStatus_t(chipblas.hipblasHaxpyStridedBatched_64(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,n,
        <const unsigned short *>hip._util.types.Pointer.fromPyobj(alpha)._ptr,
        <const unsigned short *>hip._util.types.Pointer.fromPyobj(x)._ptr,incx,stridex,
        <unsigned short *>hip._util.types.Pointer.fromPyobj(y)._ptr,incy,stridey,batchCount))
    return (_hipblasHaxpyStridedBatched_64__retval,)


@cython.embedsignature(True)
def hipblasSaxpyStridedBatched_64(object handle, long n, object alpha, object x, long incx, long stridex, object y, long incy, long stridey, long batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        alpha (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        x (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        stridex (`~.int`):
            (undocumented)

        y (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        incy (`~.int`):
            (undocumented)

        stridey (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    _hipblasSaxpyStridedBatched_64__retval = hipblasStatus_t(chipblas.hipblasSaxpyStridedBatched_64(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,n,
        <const float *>hip._util.types.Pointer.fromPyobj(alpha)._ptr,
        <const float *>hip._util.types.Pointer.fromPyobj(x)._ptr,incx,stridex,
        <float *>hip._util.types.Pointer.fromPyobj(y)._ptr,incy,stridey,batchCount))
    return (_hipblasSaxpyStridedBatched_64__retval,)


@cython.embedsignature(True)
def hipblasDaxpyStridedBatched_64(object handle, long n, object alpha, object x, long incx, long stridex, object y, long incy, long stridey, long batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        alpha (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        x (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        stridex (`~.int`):
            (undocumented)

        y (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        incy (`~.int`):
            (undocumented)

        stridey (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    _hipblasDaxpyStridedBatched_64__retval = hipblasStatus_t(chipblas.hipblasDaxpyStridedBatched_64(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,n,
        <const double *>hip._util.types.Pointer.fromPyobj(alpha)._ptr,
        <const double *>hip._util.types.Pointer.fromPyobj(x)._ptr,incx,stridex,
        <double *>hip._util.types.Pointer.fromPyobj(y)._ptr,incy,stridey,batchCount))
    return (_hipblasDaxpyStridedBatched_64__retval,)


@cython.embedsignature(True)
def hipblasCaxpyStridedBatched_64(object handle, long n, object alpha, object x, long incx, long stridex, object y, long incy, long stridey, long batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        alpha (`~.hipblasComplex`/`~.object`):
            (undocumented)

        x (`~.hipblasComplex`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        stridex (`~.int`):
            (undocumented)

        y (`~.hipblasComplex`/`~.object`):
            (undocumented)

        incy (`~.int`):
            (undocumented)

        stridey (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    _hipblasCaxpyStridedBatched_64__retval = hipblasStatus_t(chipblas.hipblasCaxpyStridedBatched_64(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,n,
        hipblasComplex.fromPyobj(alpha).getElementPtr(),
        hipblasComplex.fromPyobj(x).getElementPtr(),incx,stridex,
        hipblasComplex.fromPyobj(y).getElementPtr(),incy,stridey,batchCount))
    return (_hipblasCaxpyStridedBatched_64__retval,)


@cython.embedsignature(True)
def hipblasZaxpyStridedBatched_64(object handle, long n, object alpha, object x, long incx, long stridex, object y, long incy, long stridey, long batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        alpha (`~.hipblasDoubleComplex`/`~.object`):
            (undocumented)

        x (`~.hipblasDoubleComplex`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        stridex (`~.int`):
            (undocumented)

        y (`~.hipblasDoubleComplex`/`~.object`):
            (undocumented)

        incy (`~.int`):
            (undocumented)

        stridey (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    _hipblasZaxpyStridedBatched_64__retval = hipblasStatus_t(chipblas.hipblasZaxpyStridedBatched_64(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,n,
        hipblasDoubleComplex.fromPyobj(alpha).getElementPtr(),
        hipblasDoubleComplex.fromPyobj(x).getElementPtr(),incx,stridex,
        hipblasDoubleComplex.fromPyobj(y).getElementPtr(),incy,stridey,batchCount))
    return (_hipblasZaxpyStridedBatched_64__retval,)


@cython.embedsignature(True)
def hipblasCaxpyStridedBatched_v2_64(object handle, long n, object alpha, object x, long incx, long stridex, object y, long incy, long stridey, long batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        alpha (`~.float2`/`~.object`):
            (undocumented)

        x (`~.float2`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        stridex (`~.int`):
            (undocumented)

        y (`~.float2`/`~.object`):
            (undocumented)

        incy (`~.int`):
            (undocumented)

        stridey (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    _hipblasCaxpyStridedBatched_v2_64__retval = hipblasStatus_t(chipblas.hipblasCaxpyStridedBatched_v2_64(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,n,
        float2.fromPyobj(alpha).getElementPtr(),
        float2.fromPyobj(x).getElementPtr(),incx,stridex,
        float2.fromPyobj(y).getElementPtr(),incy,stridey,batchCount))
    return (_hipblasCaxpyStridedBatched_v2_64__retval,)


@cython.embedsignature(True)
def hipblasZaxpyStridedBatched_v2_64(object handle, long n, object alpha, object x, long incx, long stridex, object y, long incy, long stridey, long batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        alpha (`~.double2`/`~.object`):
            (undocumented)

        x (`~.double2`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        stridex (`~.int`):
            (undocumented)

        y (`~.double2`/`~.object`):
            (undocumented)

        incy (`~.int`):
            (undocumented)

        stridey (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    _hipblasZaxpyStridedBatched_v2_64__retval = hipblasStatus_t(chipblas.hipblasZaxpyStridedBatched_v2_64(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,n,
        double2.fromPyobj(alpha).getElementPtr(),
        double2.fromPyobj(x).getElementPtr(),incx,stridex,
        double2.fromPyobj(y).getElementPtr(),incy,stridey,batchCount))
    return (_hipblasZaxpyStridedBatched_v2_64__retval,)


@cython.embedsignature(True)
def hipblasScopy(object handle, int n, object x, int incx, object y, int incy):
    r"""BLAS Level 1 API

    @{

    copy  copies each element x[i] into y[i], for  i = 1 , ... , n

    y := x,

    - Supported precisions in rocBLAS : s,d,c,z
    - Supported precisions in cuBLAS  : s,d,c,z

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`) -- *IN*:
            [hipblasHandle_t]
            handle to the hipblas library context queue.

        n (`~.int`) -- *IN*:
            [int]
            the number of elements in x to be copied to y.

        x (`~.hip._util.types.Pointer`/`~.object`) -- *IN*:
            device pointer storing vector x.

        incx (`~.int`) -- *IN*:
            [int]
            specifies the increment for the elements of x.

        y (`~.hip._util.types.Pointer`/`~.object`) -- *OUT*:
            device pointer storing vector y.

        incy (`~.int`) -- *IN*:
            [int]
            specifies the increment for the elements of y.
    """
    _hipblasScopy__retval = hipblasStatus_t(chipblas.hipblasScopy(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,n,
        <const float *>hip._util.types.Pointer.fromPyobj(x)._ptr,incx,
        <float *>hip._util.types.Pointer.fromPyobj(y)._ptr,incy))
    return (_hipblasScopy__retval,)


@cython.embedsignature(True)
def hipblasDcopy(object handle, int n, object x, int incx, object y, int incy):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        x (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        y (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        incy (`~.int`):
            (undocumented)
    """
    _hipblasDcopy__retval = hipblasStatus_t(chipblas.hipblasDcopy(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,n,
        <const double *>hip._util.types.Pointer.fromPyobj(x)._ptr,incx,
        <double *>hip._util.types.Pointer.fromPyobj(y)._ptr,incy))
    return (_hipblasDcopy__retval,)


@cython.embedsignature(True)
def hipblasCcopy(object handle, int n, object x, int incx, object y, int incy):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        x (`~.hipblasComplex`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        y (`~.hipblasComplex`/`~.object`):
            (undocumented)

        incy (`~.int`):
            (undocumented)
    """
    _hipblasCcopy__retval = hipblasStatus_t(chipblas.hipblasCcopy(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,n,
        hipblasComplex.fromPyobj(x).getElementPtr(),incx,
        hipblasComplex.fromPyobj(y).getElementPtr(),incy))
    return (_hipblasCcopy__retval,)


@cython.embedsignature(True)
def hipblasZcopy(object handle, int n, object x, int incx, object y, int incy):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        x (`~.hipblasDoubleComplex`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        y (`~.hipblasDoubleComplex`/`~.object`):
            (undocumented)

        incy (`~.int`):
            (undocumented)
    """
    _hipblasZcopy__retval = hipblasStatus_t(chipblas.hipblasZcopy(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,n,
        hipblasDoubleComplex.fromPyobj(x).getElementPtr(),incx,
        hipblasDoubleComplex.fromPyobj(y).getElementPtr(),incy))
    return (_hipblasZcopy__retval,)


@cython.embedsignature(True)
def hipblasCcopy_v2(object handle, int n, object x, int incx, object y, int incy):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        x (`~.float2`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        y (`~.float2`/`~.object`):
            (undocumented)

        incy (`~.int`):
            (undocumented)
    """
    _hipblasCcopy_v2__retval = hipblasStatus_t(chipblas.hipblasCcopy_v2(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,n,
        float2.fromPyobj(x).getElementPtr(),incx,
        float2.fromPyobj(y).getElementPtr(),incy))
    return (_hipblasCcopy_v2__retval,)


@cython.embedsignature(True)
def hipblasZcopy_v2(object handle, int n, object x, int incx, object y, int incy):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        x (`~.double2`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        y (`~.double2`/`~.object`):
            (undocumented)

        incy (`~.int`):
            (undocumented)
    """
    _hipblasZcopy_v2__retval = hipblasStatus_t(chipblas.hipblasZcopy_v2(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,n,
        double2.fromPyobj(x).getElementPtr(),incx,
        double2.fromPyobj(y).getElementPtr(),incy))
    return (_hipblasZcopy_v2__retval,)


@cython.embedsignature(True)
def hipblasScopy_64(object handle, long n, object x, long incx, object y, long incy):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        x (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        y (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        incy (`~.int`):
            (undocumented)
    """
    _hipblasScopy_64__retval = hipblasStatus_t(chipblas.hipblasScopy_64(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,n,
        <const float *>hip._util.types.Pointer.fromPyobj(x)._ptr,incx,
        <float *>hip._util.types.Pointer.fromPyobj(y)._ptr,incy))
    return (_hipblasScopy_64__retval,)


@cython.embedsignature(True)
def hipblasDcopy_64(object handle, long n, object x, long incx, object y, long incy):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        x (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        y (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        incy (`~.int`):
            (undocumented)
    """
    _hipblasDcopy_64__retval = hipblasStatus_t(chipblas.hipblasDcopy_64(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,n,
        <const double *>hip._util.types.Pointer.fromPyobj(x)._ptr,incx,
        <double *>hip._util.types.Pointer.fromPyobj(y)._ptr,incy))
    return (_hipblasDcopy_64__retval,)


@cython.embedsignature(True)
def hipblasCcopy_64(object handle, long n, object x, long incx, object y, long incy):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        x (`~.hipblasComplex`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        y (`~.hipblasComplex`/`~.object`):
            (undocumented)

        incy (`~.int`):
            (undocumented)
    """
    _hipblasCcopy_64__retval = hipblasStatus_t(chipblas.hipblasCcopy_64(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,n,
        hipblasComplex.fromPyobj(x).getElementPtr(),incx,
        hipblasComplex.fromPyobj(y).getElementPtr(),incy))
    return (_hipblasCcopy_64__retval,)


@cython.embedsignature(True)
def hipblasZcopy_64(object handle, long n, object x, long incx, object y, long incy):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        x (`~.hipblasDoubleComplex`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        y (`~.hipblasDoubleComplex`/`~.object`):
            (undocumented)

        incy (`~.int`):
            (undocumented)
    """
    _hipblasZcopy_64__retval = hipblasStatus_t(chipblas.hipblasZcopy_64(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,n,
        hipblasDoubleComplex.fromPyobj(x).getElementPtr(),incx,
        hipblasDoubleComplex.fromPyobj(y).getElementPtr(),incy))
    return (_hipblasZcopy_64__retval,)


@cython.embedsignature(True)
def hipblasCcopy_v2_64(object handle, long n, object x, long incx, object y, long incy):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        x (`~.float2`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        y (`~.float2`/`~.object`):
            (undocumented)

        incy (`~.int`):
            (undocumented)
    """
    _hipblasCcopy_v2_64__retval = hipblasStatus_t(chipblas.hipblasCcopy_v2_64(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,n,
        float2.fromPyobj(x).getElementPtr(),incx,
        float2.fromPyobj(y).getElementPtr(),incy))
    return (_hipblasCcopy_v2_64__retval,)


@cython.embedsignature(True)
def hipblasZcopy_v2_64(object handle, long n, object x, long incx, object y, long incy):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        x (`~.double2`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        y (`~.double2`/`~.object`):
            (undocumented)

        incy (`~.int`):
            (undocumented)
    """
    _hipblasZcopy_v2_64__retval = hipblasStatus_t(chipblas.hipblasZcopy_v2_64(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,n,
        double2.fromPyobj(x).getElementPtr(),incx,
        double2.fromPyobj(y).getElementPtr(),incy))
    return (_hipblasZcopy_v2_64__retval,)


@cython.embedsignature(True)
def hipblasScopyBatched(object handle, int n, object x, int incx, object y, int incy, int batchCount):
    r"""BLAS Level 1 API

    @{

    copyBatched copies each element x_i[j] into y_i[j], for  j = 1 , ... , n; i = 1 , ... , batchCount

    y_i := x_i,

    where (x_i, y_i) is the i-th instance of the batch.
    x_i and y_i are vectors.

    - Supported precisions in rocBLAS : s,d,c,z
    - Supported precisions in cuBLAS  : No support

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`) -- *IN*:
            [hipblasHandle_t]
            handle to the hipblas library context queue.

        n (`~.int`) -- *IN*:
            [int]
            the number of elements in each x_i to be copied to y_i.

        x (`~.hip._util.types.ListOfPointer`/`~.object`) -- *IN*:
            device array of device pointers storing each vector x_i.

        incx (`~.int`) -- *IN*:
            [int]
            specifies the increment for the elements of each vector x_i.

        y (`~.hip._util.types.ListOfPointer`/`~.object`) -- *OUT*:
            device array of device pointers storing each vector y_i.

        incy (`~.int`) -- *IN*:
            [int]
            specifies the increment for the elements of each vector y_i.

        batchCount (`~.int`) -- *IN*:
            [int]
            number of instances in the batch
    """
    _hipblasScopyBatched__retval = hipblasStatus_t(chipblas.hipblasScopyBatched(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,n,
        <const float *const*>hip._util.types.ListOfPointer.fromPyobj(x)._ptr,incx,
        <float *const*>hip._util.types.ListOfPointer.fromPyobj(y)._ptr,incy,batchCount))
    return (_hipblasScopyBatched__retval,)


@cython.embedsignature(True)
def hipblasDcopyBatched(object handle, int n, object x, int incx, object y, int incy, int batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        x (`~.hip._util.types.ListOfPointer`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        y (`~.hip._util.types.ListOfPointer`/`~.object`):
            (undocumented)

        incy (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    _hipblasDcopyBatched__retval = hipblasStatus_t(chipblas.hipblasDcopyBatched(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,n,
        <const double *const*>hip._util.types.ListOfPointer.fromPyobj(x)._ptr,incx,
        <double *const*>hip._util.types.ListOfPointer.fromPyobj(y)._ptr,incy,batchCount))
    return (_hipblasDcopyBatched__retval,)


@cython.embedsignature(True)
def hipblasCcopyBatched(object handle, int n, object x, int incx, object y, int incy, int batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        x (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        y (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        incy (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    _hipblasCcopyBatched__retval = hipblasStatus_t(chipblas.hipblasCcopyBatched(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,n,
        <chipblas.hipblasComplex *const*>hip._util.types.Pointer.fromPyobj(x)._ptr,incx,
        <chipblas.hipblasComplex *const*>hip._util.types.Pointer.fromPyobj(y)._ptr,incy,batchCount))
    return (_hipblasCcopyBatched__retval,)


@cython.embedsignature(True)
def hipblasZcopyBatched(object handle, int n, object x, int incx, object y, int incy, int batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        x (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        y (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        incy (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    _hipblasZcopyBatched__retval = hipblasStatus_t(chipblas.hipblasZcopyBatched(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,n,
        <chipblas.hipblasDoubleComplex *const*>hip._util.types.Pointer.fromPyobj(x)._ptr,incx,
        <chipblas.hipblasDoubleComplex *const*>hip._util.types.Pointer.fromPyobj(y)._ptr,incy,batchCount))
    return (_hipblasZcopyBatched__retval,)


@cython.embedsignature(True)
def hipblasCcopyBatched_v2(object handle, int n, object x, int incx, object y, int incy, int batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        x (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        y (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        incy (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    _hipblasCcopyBatched_v2__retval = hipblasStatus_t(chipblas.hipblasCcopyBatched_v2(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,n,
        <chipblas.float2 *const*>hip._util.types.Pointer.fromPyobj(x)._ptr,incx,
        <chipblas.float2 *const*>hip._util.types.Pointer.fromPyobj(y)._ptr,incy,batchCount))
    return (_hipblasCcopyBatched_v2__retval,)


@cython.embedsignature(True)
def hipblasZcopyBatched_v2(object handle, int n, object x, int incx, object y, int incy, int batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        x (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        y (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        incy (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    _hipblasZcopyBatched_v2__retval = hipblasStatus_t(chipblas.hipblasZcopyBatched_v2(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,n,
        <chipblas.double2 *const*>hip._util.types.Pointer.fromPyobj(x)._ptr,incx,
        <chipblas.double2 *const*>hip._util.types.Pointer.fromPyobj(y)._ptr,incy,batchCount))
    return (_hipblasZcopyBatched_v2__retval,)


@cython.embedsignature(True)
def hipblasScopyBatched_64(object handle, long n, object x, long incx, object y, long incy, long batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        x (`~.hip._util.types.ListOfPointer`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        y (`~.hip._util.types.ListOfPointer`/`~.object`):
            (undocumented)

        incy (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    _hipblasScopyBatched_64__retval = hipblasStatus_t(chipblas.hipblasScopyBatched_64(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,n,
        <const float *const*>hip._util.types.ListOfPointer.fromPyobj(x)._ptr,incx,
        <float *const*>hip._util.types.ListOfPointer.fromPyobj(y)._ptr,incy,batchCount))
    return (_hipblasScopyBatched_64__retval,)


@cython.embedsignature(True)
def hipblasDcopyBatched_64(object handle, long n, object x, long incx, object y, long incy, long batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        x (`~.hip._util.types.ListOfPointer`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        y (`~.hip._util.types.ListOfPointer`/`~.object`):
            (undocumented)

        incy (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    _hipblasDcopyBatched_64__retval = hipblasStatus_t(chipblas.hipblasDcopyBatched_64(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,n,
        <const double *const*>hip._util.types.ListOfPointer.fromPyobj(x)._ptr,incx,
        <double *const*>hip._util.types.ListOfPointer.fromPyobj(y)._ptr,incy,batchCount))
    return (_hipblasDcopyBatched_64__retval,)


@cython.embedsignature(True)
def hipblasCcopyBatched_64(object handle, long n, object x, long incx, object y, long incy, long batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        x (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        y (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        incy (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    _hipblasCcopyBatched_64__retval = hipblasStatus_t(chipblas.hipblasCcopyBatched_64(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,n,
        <chipblas.hipblasComplex *const*>hip._util.types.Pointer.fromPyobj(x)._ptr,incx,
        <chipblas.hipblasComplex *const*>hip._util.types.Pointer.fromPyobj(y)._ptr,incy,batchCount))
    return (_hipblasCcopyBatched_64__retval,)


@cython.embedsignature(True)
def hipblasZcopyBatched_64(object handle, long n, object x, long incx, object y, long incy, long batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        x (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        y (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        incy (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    _hipblasZcopyBatched_64__retval = hipblasStatus_t(chipblas.hipblasZcopyBatched_64(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,n,
        <chipblas.hipblasDoubleComplex *const*>hip._util.types.Pointer.fromPyobj(x)._ptr,incx,
        <chipblas.hipblasDoubleComplex *const*>hip._util.types.Pointer.fromPyobj(y)._ptr,incy,batchCount))
    return (_hipblasZcopyBatched_64__retval,)


@cython.embedsignature(True)
def hipblasCcopyBatched_v2_64(object handle, long n, object x, long incx, object y, long incy, long batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        x (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        y (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        incy (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    _hipblasCcopyBatched_v2_64__retval = hipblasStatus_t(chipblas.hipblasCcopyBatched_v2_64(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,n,
        <chipblas.float2 *const*>hip._util.types.Pointer.fromPyobj(x)._ptr,incx,
        <chipblas.float2 *const*>hip._util.types.Pointer.fromPyobj(y)._ptr,incy,batchCount))
    return (_hipblasCcopyBatched_v2_64__retval,)


@cython.embedsignature(True)
def hipblasZcopyBatched_v2_64(object handle, long n, object x, long incx, object y, long incy, long batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        x (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        y (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        incy (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    _hipblasZcopyBatched_v2_64__retval = hipblasStatus_t(chipblas.hipblasZcopyBatched_v2_64(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,n,
        <chipblas.double2 *const*>hip._util.types.Pointer.fromPyobj(x)._ptr,incx,
        <chipblas.double2 *const*>hip._util.types.Pointer.fromPyobj(y)._ptr,incy,batchCount))
    return (_hipblasZcopyBatched_v2_64__retval,)


@cython.embedsignature(True)
def hipblasScopyStridedBatched(object handle, int n, object x, int incx, long stridex, object y, int incy, long stridey, int batchCount):
    r"""BLAS Level 1 API

    @{

    copyStridedBatched copies each element x_i[j] into y_i[j], for  j = 1 , ... , n; i = 1 , ... , batchCount

    y_i := x_i,

    where (x_i, y_i) is the i-th instance of the batch.
    x_i and y_i are vectors.

    - Supported precisions in rocBLAS : s,d,c,z
    - Supported precisions in cuBLAS  : No support

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`) -- *IN*:
            [hipblasHandle_t]
            handle to the hipblas library context queue.

        n (`~.int`) -- *IN*:
            [int]
            the number of elements in each x_i to be copied to y_i.

        x (`~.hip._util.types.Pointer`/`~.object`) -- *IN*:
            device pointer to the first vector (x_1) in the batch.

        incx (`~.int`) -- *IN*:
            [int]
            specifies the increments for the elements of vectors x_i.

        stridex (`~.int`) -- *IN*:
            [hipblasStride]
            stride from the start of one vector (x_i) and the next one (x_i+1).
            There are no restrictions placed on stride_x, however the user should
            take care to ensure that stride_x is of appropriate size, for a typical
            case this means stride_x >= n * incx.

        y (`~.hip._util.types.Pointer`/`~.object`) -- *OUT*:
            device pointer to the first vector (y_1) in the batch.

        incy (`~.int`) -- *IN*:
            [int]
            specifies the increment for the elements of vectors y_i.

        stridey (`~.int`) -- *IN*:
            [hipblasStride]
            stride from the start of one vector (y_i) and the next one (y_i+1).
            There are no restrictions placed on stride_y, however the user should
            take care to ensure that stride_y is of appropriate size, for a typical
            case this means stride_y >= n * incy. stridey should be non zero.

        batchCount (`~.int`) -- *IN*:
            [int]
            number of instances in the batch
    """
    _hipblasScopyStridedBatched__retval = hipblasStatus_t(chipblas.hipblasScopyStridedBatched(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,n,
        <const float *>hip._util.types.Pointer.fromPyobj(x)._ptr,incx,stridex,
        <float *>hip._util.types.Pointer.fromPyobj(y)._ptr,incy,stridey,batchCount))
    return (_hipblasScopyStridedBatched__retval,)


@cython.embedsignature(True)
def hipblasDcopyStridedBatched(object handle, int n, object x, int incx, long stridex, object y, int incy, long stridey, int batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        x (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        stridex (`~.int`):
            (undocumented)

        y (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        incy (`~.int`):
            (undocumented)

        stridey (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    _hipblasDcopyStridedBatched__retval = hipblasStatus_t(chipblas.hipblasDcopyStridedBatched(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,n,
        <const double *>hip._util.types.Pointer.fromPyobj(x)._ptr,incx,stridex,
        <double *>hip._util.types.Pointer.fromPyobj(y)._ptr,incy,stridey,batchCount))
    return (_hipblasDcopyStridedBatched__retval,)


@cython.embedsignature(True)
def hipblasCcopyStridedBatched(object handle, int n, object x, int incx, long stridex, object y, int incy, long stridey, int batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        x (`~.hipblasComplex`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        stridex (`~.int`):
            (undocumented)

        y (`~.hipblasComplex`/`~.object`):
            (undocumented)

        incy (`~.int`):
            (undocumented)

        stridey (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    _hipblasCcopyStridedBatched__retval = hipblasStatus_t(chipblas.hipblasCcopyStridedBatched(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,n,
        hipblasComplex.fromPyobj(x).getElementPtr(),incx,stridex,
        hipblasComplex.fromPyobj(y).getElementPtr(),incy,stridey,batchCount))
    return (_hipblasCcopyStridedBatched__retval,)


@cython.embedsignature(True)
def hipblasZcopyStridedBatched(object handle, int n, object x, int incx, long stridex, object y, int incy, long stridey, int batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        x (`~.hipblasDoubleComplex`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        stridex (`~.int`):
            (undocumented)

        y (`~.hipblasDoubleComplex`/`~.object`):
            (undocumented)

        incy (`~.int`):
            (undocumented)

        stridey (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    _hipblasZcopyStridedBatched__retval = hipblasStatus_t(chipblas.hipblasZcopyStridedBatched(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,n,
        hipblasDoubleComplex.fromPyobj(x).getElementPtr(),incx,stridex,
        hipblasDoubleComplex.fromPyobj(y).getElementPtr(),incy,stridey,batchCount))
    return (_hipblasZcopyStridedBatched__retval,)


@cython.embedsignature(True)
def hipblasCcopyStridedBatched_v2(object handle, int n, object x, int incx, long stridex, object y, int incy, long stridey, int batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        x (`~.float2`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        stridex (`~.int`):
            (undocumented)

        y (`~.float2`/`~.object`):
            (undocumented)

        incy (`~.int`):
            (undocumented)

        stridey (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    _hipblasCcopyStridedBatched_v2__retval = hipblasStatus_t(chipblas.hipblasCcopyStridedBatched_v2(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,n,
        float2.fromPyobj(x).getElementPtr(),incx,stridex,
        float2.fromPyobj(y).getElementPtr(),incy,stridey,batchCount))
    return (_hipblasCcopyStridedBatched_v2__retval,)


@cython.embedsignature(True)
def hipblasZcopyStridedBatched_v2(object handle, int n, object x, int incx, long stridex, object y, int incy, long stridey, int batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        x (`~.double2`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        stridex (`~.int`):
            (undocumented)

        y (`~.double2`/`~.object`):
            (undocumented)

        incy (`~.int`):
            (undocumented)

        stridey (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    _hipblasZcopyStridedBatched_v2__retval = hipblasStatus_t(chipblas.hipblasZcopyStridedBatched_v2(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,n,
        double2.fromPyobj(x).getElementPtr(),incx,stridex,
        double2.fromPyobj(y).getElementPtr(),incy,stridey,batchCount))
    return (_hipblasZcopyStridedBatched_v2__retval,)


@cython.embedsignature(True)
def hipblasScopyStridedBatched_64(object handle, long n, object x, long incx, long stridex, object y, long incy, long stridey, long batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        x (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        stridex (`~.int`):
            (undocumented)

        y (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        incy (`~.int`):
            (undocumented)

        stridey (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    _hipblasScopyStridedBatched_64__retval = hipblasStatus_t(chipblas.hipblasScopyStridedBatched_64(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,n,
        <const float *>hip._util.types.Pointer.fromPyobj(x)._ptr,incx,stridex,
        <float *>hip._util.types.Pointer.fromPyobj(y)._ptr,incy,stridey,batchCount))
    return (_hipblasScopyStridedBatched_64__retval,)


@cython.embedsignature(True)
def hipblasDcopyStridedBatched_64(object handle, long n, object x, long incx, long stridex, object y, long incy, long stridey, long batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        x (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        stridex (`~.int`):
            (undocumented)

        y (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        incy (`~.int`):
            (undocumented)

        stridey (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    _hipblasDcopyStridedBatched_64__retval = hipblasStatus_t(chipblas.hipblasDcopyStridedBatched_64(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,n,
        <const double *>hip._util.types.Pointer.fromPyobj(x)._ptr,incx,stridex,
        <double *>hip._util.types.Pointer.fromPyobj(y)._ptr,incy,stridey,batchCount))
    return (_hipblasDcopyStridedBatched_64__retval,)


@cython.embedsignature(True)
def hipblasCcopyStridedBatched_64(object handle, long n, object x, long incx, long stridex, object y, long incy, long stridey, long batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        x (`~.hipblasComplex`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        stridex (`~.int`):
            (undocumented)

        y (`~.hipblasComplex`/`~.object`):
            (undocumented)

        incy (`~.int`):
            (undocumented)

        stridey (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    _hipblasCcopyStridedBatched_64__retval = hipblasStatus_t(chipblas.hipblasCcopyStridedBatched_64(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,n,
        hipblasComplex.fromPyobj(x).getElementPtr(),incx,stridex,
        hipblasComplex.fromPyobj(y).getElementPtr(),incy,stridey,batchCount))
    return (_hipblasCcopyStridedBatched_64__retval,)


@cython.embedsignature(True)
def hipblasZcopyStridedBatched_64(object handle, long n, object x, long incx, long stridex, object y, long incy, long stridey, long batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        x (`~.hipblasDoubleComplex`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        stridex (`~.int`):
            (undocumented)

        y (`~.hipblasDoubleComplex`/`~.object`):
            (undocumented)

        incy (`~.int`):
            (undocumented)

        stridey (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    _hipblasZcopyStridedBatched_64__retval = hipblasStatus_t(chipblas.hipblasZcopyStridedBatched_64(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,n,
        hipblasDoubleComplex.fromPyobj(x).getElementPtr(),incx,stridex,
        hipblasDoubleComplex.fromPyobj(y).getElementPtr(),incy,stridey,batchCount))
    return (_hipblasZcopyStridedBatched_64__retval,)


@cython.embedsignature(True)
def hipblasCcopyStridedBatched_v2_64(object handle, long n, object x, long incx, long stridex, object y, long incy, long stridey, long batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        x (`~.float2`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        stridex (`~.int`):
            (undocumented)

        y (`~.float2`/`~.object`):
            (undocumented)

        incy (`~.int`):
            (undocumented)

        stridey (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    _hipblasCcopyStridedBatched_v2_64__retval = hipblasStatus_t(chipblas.hipblasCcopyStridedBatched_v2_64(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,n,
        float2.fromPyobj(x).getElementPtr(),incx,stridex,
        float2.fromPyobj(y).getElementPtr(),incy,stridey,batchCount))
    return (_hipblasCcopyStridedBatched_v2_64__retval,)


@cython.embedsignature(True)
def hipblasZcopyStridedBatched_v2_64(object handle, long n, object x, long incx, long stridex, object y, long incy, long stridey, long batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        x (`~.double2`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        stridex (`~.int`):
            (undocumented)

        y (`~.double2`/`~.object`):
            (undocumented)

        incy (`~.int`):
            (undocumented)

        stridey (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    _hipblasZcopyStridedBatched_v2_64__retval = hipblasStatus_t(chipblas.hipblasZcopyStridedBatched_v2_64(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,n,
        double2.fromPyobj(x).getElementPtr(),incx,stridex,
        double2.fromPyobj(y).getElementPtr(),incy,stridey,batchCount))
    return (_hipblasZcopyStridedBatched_v2_64__retval,)


@cython.embedsignature(True)
def hipblasHdot(object handle, int n, object x, int incx, object y, int incy, object result):
    r"""BLAS Level 1 API

    @{

    dot(u)  performs the dot product of vectors x and y

    result = x * y;

    dotc  performs the dot product of the conjugate of complex vector x and complex vector y

        result = conjugate (x) * y;

    - Supported precisions in rocBLAS : h,bf,s,d,c,z
    - Supported precisions in cuBLAS  : s,d,c,z

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`) -- *IN*:
            [hipblasHandle_t]
            handle to the hipblas library context queue.

        n (`~.int`) -- *IN*:
            [int]
            the number of elements in x and y.

        x (`~.hip._util.types.Pointer`/`~.object`) -- *IN*:
            device pointer storing vector x.

        incx (`~.int`) -- *IN*:
            [int]
            specifies the increment for the elements of y.

        y (`~.hip._util.types.Pointer`/`~.object`) -- *IN*:
            device pointer storing vector y.

        incy (`~.int`) -- *IN*:
            [int]
            specifies the increment for the elements of y.

        result (`~.hip._util.types.Pointer`/`~.object`) -- *INOUT*:
            device pointer or host pointer to store the dot product.
            return is 0.0 if n <= 0.
    """
    _hipblasHdot__retval = hipblasStatus_t(chipblas.hipblasHdot(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,n,
        <const unsigned short *>hip._util.types.Pointer.fromPyobj(x)._ptr,incx,
        <const unsigned short *>hip._util.types.Pointer.fromPyobj(y)._ptr,incy,
        <unsigned short *>hip._util.types.Pointer.fromPyobj(result)._ptr))
    return (_hipblasHdot__retval,)


@cython.embedsignature(True)
def hipblasBfdot(object handle, int n, object x, int incx, object y, int incy, object result):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        x (`~.hipblasBfloat16`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        y (`~.hipblasBfloat16`/`~.object`):
            (undocumented)

        incy (`~.int`):
            (undocumented)

        result (`~.hipblasBfloat16`/`~.object`):
            (undocumented)
    """
    _hipblasBfdot__retval = hipblasStatus_t(chipblas.hipblasBfdot(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,n,
        hipblasBfloat16.fromPyobj(x).getElementPtr(),incx,
        hipblasBfloat16.fromPyobj(y).getElementPtr(),incy,
        hipblasBfloat16.fromPyobj(result).getElementPtr()))
    return (_hipblasBfdot__retval,)


@cython.embedsignature(True)
def hipblasSdot(object handle, int n, object x, int incx, object y, int incy, object result):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        x (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        y (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        incy (`~.int`):
            (undocumented)

        result (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)
    """
    _hipblasSdot__retval = hipblasStatus_t(chipblas.hipblasSdot(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,n,
        <const float *>hip._util.types.Pointer.fromPyobj(x)._ptr,incx,
        <const float *>hip._util.types.Pointer.fromPyobj(y)._ptr,incy,
        <float *>hip._util.types.Pointer.fromPyobj(result)._ptr))
    return (_hipblasSdot__retval,)


@cython.embedsignature(True)
def hipblasDdot(object handle, int n, object x, int incx, object y, int incy, object result):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        x (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        y (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        incy (`~.int`):
            (undocumented)

        result (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)
    """
    _hipblasDdot__retval = hipblasStatus_t(chipblas.hipblasDdot(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,n,
        <const double *>hip._util.types.Pointer.fromPyobj(x)._ptr,incx,
        <const double *>hip._util.types.Pointer.fromPyobj(y)._ptr,incy,
        <double *>hip._util.types.Pointer.fromPyobj(result)._ptr))
    return (_hipblasDdot__retval,)


@cython.embedsignature(True)
def hipblasCdotc(object handle, int n, object x, int incx, object y, int incy, object result):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        x (`~.hipblasComplex`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        y (`~.hipblasComplex`/`~.object`):
            (undocumented)

        incy (`~.int`):
            (undocumented)

        result (`~.hipblasComplex`/`~.object`):
            (undocumented)
    """
    _hipblasCdotc__retval = hipblasStatus_t(chipblas.hipblasCdotc(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,n,
        hipblasComplex.fromPyobj(x).getElementPtr(),incx,
        hipblasComplex.fromPyobj(y).getElementPtr(),incy,
        hipblasComplex.fromPyobj(result).getElementPtr()))
    return (_hipblasCdotc__retval,)


@cython.embedsignature(True)
def hipblasCdotu(object handle, int n, object x, int incx, object y, int incy, object result):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        x (`~.hipblasComplex`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        y (`~.hipblasComplex`/`~.object`):
            (undocumented)

        incy (`~.int`):
            (undocumented)

        result (`~.hipblasComplex`/`~.object`):
            (undocumented)
    """
    _hipblasCdotu__retval = hipblasStatus_t(chipblas.hipblasCdotu(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,n,
        hipblasComplex.fromPyobj(x).getElementPtr(),incx,
        hipblasComplex.fromPyobj(y).getElementPtr(),incy,
        hipblasComplex.fromPyobj(result).getElementPtr()))
    return (_hipblasCdotu__retval,)


@cython.embedsignature(True)
def hipblasZdotc(object handle, int n, object x, int incx, object y, int incy, object result):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        x (`~.hipblasDoubleComplex`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        y (`~.hipblasDoubleComplex`/`~.object`):
            (undocumented)

        incy (`~.int`):
            (undocumented)

        result (`~.hipblasDoubleComplex`/`~.object`):
            (undocumented)
    """
    _hipblasZdotc__retval = hipblasStatus_t(chipblas.hipblasZdotc(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,n,
        hipblasDoubleComplex.fromPyobj(x).getElementPtr(),incx,
        hipblasDoubleComplex.fromPyobj(y).getElementPtr(),incy,
        hipblasDoubleComplex.fromPyobj(result).getElementPtr()))
    return (_hipblasZdotc__retval,)


@cython.embedsignature(True)
def hipblasZdotu(object handle, int n, object x, int incx, object y, int incy, object result):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        x (`~.hipblasDoubleComplex`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        y (`~.hipblasDoubleComplex`/`~.object`):
            (undocumented)

        incy (`~.int`):
            (undocumented)

        result (`~.hipblasDoubleComplex`/`~.object`):
            (undocumented)
    """
    _hipblasZdotu__retval = hipblasStatus_t(chipblas.hipblasZdotu(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,n,
        hipblasDoubleComplex.fromPyobj(x).getElementPtr(),incx,
        hipblasDoubleComplex.fromPyobj(y).getElementPtr(),incy,
        hipblasDoubleComplex.fromPyobj(result).getElementPtr()))
    return (_hipblasZdotu__retval,)


@cython.embedsignature(True)
def hipblasCdotc_v2(object handle, int n, object x, int incx, object y, int incy, object result):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        x (`~.float2`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        y (`~.float2`/`~.object`):
            (undocumented)

        incy (`~.int`):
            (undocumented)

        result (`~.float2`/`~.object`):
            (undocumented)
    """
    _hipblasCdotc_v2__retval = hipblasStatus_t(chipblas.hipblasCdotc_v2(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,n,
        float2.fromPyobj(x).getElementPtr(),incx,
        float2.fromPyobj(y).getElementPtr(),incy,
        float2.fromPyobj(result).getElementPtr()))
    return (_hipblasCdotc_v2__retval,)


@cython.embedsignature(True)
def hipblasCdotu_v2(object handle, int n, object x, int incx, object y, int incy, object result):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        x (`~.float2`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        y (`~.float2`/`~.object`):
            (undocumented)

        incy (`~.int`):
            (undocumented)

        result (`~.float2`/`~.object`):
            (undocumented)
    """
    _hipblasCdotu_v2__retval = hipblasStatus_t(chipblas.hipblasCdotu_v2(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,n,
        float2.fromPyobj(x).getElementPtr(),incx,
        float2.fromPyobj(y).getElementPtr(),incy,
        float2.fromPyobj(result).getElementPtr()))
    return (_hipblasCdotu_v2__retval,)


@cython.embedsignature(True)
def hipblasZdotc_v2(object handle, int n, object x, int incx, object y, int incy, object result):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        x (`~.double2`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        y (`~.double2`/`~.object`):
            (undocumented)

        incy (`~.int`):
            (undocumented)

        result (`~.double2`/`~.object`):
            (undocumented)
    """
    _hipblasZdotc_v2__retval = hipblasStatus_t(chipblas.hipblasZdotc_v2(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,n,
        double2.fromPyobj(x).getElementPtr(),incx,
        double2.fromPyobj(y).getElementPtr(),incy,
        double2.fromPyobj(result).getElementPtr()))
    return (_hipblasZdotc_v2__retval,)


@cython.embedsignature(True)
def hipblasZdotu_v2(object handle, int n, object x, int incx, object y, int incy, object result):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        x (`~.double2`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        y (`~.double2`/`~.object`):
            (undocumented)

        incy (`~.int`):
            (undocumented)

        result (`~.double2`/`~.object`):
            (undocumented)
    """
    _hipblasZdotu_v2__retval = hipblasStatus_t(chipblas.hipblasZdotu_v2(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,n,
        double2.fromPyobj(x).getElementPtr(),incx,
        double2.fromPyobj(y).getElementPtr(),incy,
        double2.fromPyobj(result).getElementPtr()))
    return (_hipblasZdotu_v2__retval,)


@cython.embedsignature(True)
def hipblasHdot_64(object handle, long n, object x, long incx, object y, long incy, object result):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        x (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        y (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        incy (`~.int`):
            (undocumented)

        result (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)
    """
    _hipblasHdot_64__retval = hipblasStatus_t(chipblas.hipblasHdot_64(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,n,
        <const unsigned short *>hip._util.types.Pointer.fromPyobj(x)._ptr,incx,
        <const unsigned short *>hip._util.types.Pointer.fromPyobj(y)._ptr,incy,
        <unsigned short *>hip._util.types.Pointer.fromPyobj(result)._ptr))
    return (_hipblasHdot_64__retval,)


@cython.embedsignature(True)
def hipblasBfdot_64(object handle, long n, object x, long incx, object y, long incy, object result):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        x (`~.hipblasBfloat16`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        y (`~.hipblasBfloat16`/`~.object`):
            (undocumented)

        incy (`~.int`):
            (undocumented)

        result (`~.hipblasBfloat16`/`~.object`):
            (undocumented)
    """
    _hipblasBfdot_64__retval = hipblasStatus_t(chipblas.hipblasBfdot_64(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,n,
        hipblasBfloat16.fromPyobj(x).getElementPtr(),incx,
        hipblasBfloat16.fromPyobj(y).getElementPtr(),incy,
        hipblasBfloat16.fromPyobj(result).getElementPtr()))
    return (_hipblasBfdot_64__retval,)


@cython.embedsignature(True)
def hipblasSdot_64(object handle, long n, object x, long incx, object y, long incy, object result):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        x (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        y (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        incy (`~.int`):
            (undocumented)

        result (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)
    """
    _hipblasSdot_64__retval = hipblasStatus_t(chipblas.hipblasSdot_64(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,n,
        <const float *>hip._util.types.Pointer.fromPyobj(x)._ptr,incx,
        <const float *>hip._util.types.Pointer.fromPyobj(y)._ptr,incy,
        <float *>hip._util.types.Pointer.fromPyobj(result)._ptr))
    return (_hipblasSdot_64__retval,)


@cython.embedsignature(True)
def hipblasDdot_64(object handle, long n, object x, long incx, object y, long incy, object result):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        x (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        y (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        incy (`~.int`):
            (undocumented)

        result (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)
    """
    _hipblasDdot_64__retval = hipblasStatus_t(chipblas.hipblasDdot_64(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,n,
        <const double *>hip._util.types.Pointer.fromPyobj(x)._ptr,incx,
        <const double *>hip._util.types.Pointer.fromPyobj(y)._ptr,incy,
        <double *>hip._util.types.Pointer.fromPyobj(result)._ptr))
    return (_hipblasDdot_64__retval,)


@cython.embedsignature(True)
def hipblasCdotc_64(object handle, long n, object x, long incx, object y, long incy, object result):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        x (`~.hipblasComplex`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        y (`~.hipblasComplex`/`~.object`):
            (undocumented)

        incy (`~.int`):
            (undocumented)

        result (`~.hipblasComplex`/`~.object`):
            (undocumented)
    """
    _hipblasCdotc_64__retval = hipblasStatus_t(chipblas.hipblasCdotc_64(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,n,
        hipblasComplex.fromPyobj(x).getElementPtr(),incx,
        hipblasComplex.fromPyobj(y).getElementPtr(),incy,
        hipblasComplex.fromPyobj(result).getElementPtr()))
    return (_hipblasCdotc_64__retval,)


@cython.embedsignature(True)
def hipblasCdotu_64(object handle, long n, object x, long incx, object y, long incy, object result):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        x (`~.hipblasComplex`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        y (`~.hipblasComplex`/`~.object`):
            (undocumented)

        incy (`~.int`):
            (undocumented)

        result (`~.hipblasComplex`/`~.object`):
            (undocumented)
    """
    _hipblasCdotu_64__retval = hipblasStatus_t(chipblas.hipblasCdotu_64(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,n,
        hipblasComplex.fromPyobj(x).getElementPtr(),incx,
        hipblasComplex.fromPyobj(y).getElementPtr(),incy,
        hipblasComplex.fromPyobj(result).getElementPtr()))
    return (_hipblasCdotu_64__retval,)


@cython.embedsignature(True)
def hipblasZdotc_64(object handle, long n, object x, long incx, object y, long incy, object result):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        x (`~.hipblasDoubleComplex`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        y (`~.hipblasDoubleComplex`/`~.object`):
            (undocumented)

        incy (`~.int`):
            (undocumented)

        result (`~.hipblasDoubleComplex`/`~.object`):
            (undocumented)
    """
    _hipblasZdotc_64__retval = hipblasStatus_t(chipblas.hipblasZdotc_64(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,n,
        hipblasDoubleComplex.fromPyobj(x).getElementPtr(),incx,
        hipblasDoubleComplex.fromPyobj(y).getElementPtr(),incy,
        hipblasDoubleComplex.fromPyobj(result).getElementPtr()))
    return (_hipblasZdotc_64__retval,)


@cython.embedsignature(True)
def hipblasZdotu_64(object handle, long n, object x, long incx, object y, long incy, object result):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        x (`~.hipblasDoubleComplex`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        y (`~.hipblasDoubleComplex`/`~.object`):
            (undocumented)

        incy (`~.int`):
            (undocumented)

        result (`~.hipblasDoubleComplex`/`~.object`):
            (undocumented)
    """
    _hipblasZdotu_64__retval = hipblasStatus_t(chipblas.hipblasZdotu_64(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,n,
        hipblasDoubleComplex.fromPyobj(x).getElementPtr(),incx,
        hipblasDoubleComplex.fromPyobj(y).getElementPtr(),incy,
        hipblasDoubleComplex.fromPyobj(result).getElementPtr()))
    return (_hipblasZdotu_64__retval,)


@cython.embedsignature(True)
def hipblasCdotc_v2_64(object handle, long n, object x, long incx, object y, long incy, object result):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        x (`~.float2`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        y (`~.float2`/`~.object`):
            (undocumented)

        incy (`~.int`):
            (undocumented)

        result (`~.float2`/`~.object`):
            (undocumented)
    """
    _hipblasCdotc_v2_64__retval = hipblasStatus_t(chipblas.hipblasCdotc_v2_64(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,n,
        float2.fromPyobj(x).getElementPtr(),incx,
        float2.fromPyobj(y).getElementPtr(),incy,
        float2.fromPyobj(result).getElementPtr()))
    return (_hipblasCdotc_v2_64__retval,)


@cython.embedsignature(True)
def hipblasCdotu_v2_64(object handle, long n, object x, long incx, object y, long incy, object result):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        x (`~.float2`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        y (`~.float2`/`~.object`):
            (undocumented)

        incy (`~.int`):
            (undocumented)

        result (`~.float2`/`~.object`):
            (undocumented)
    """
    _hipblasCdotu_v2_64__retval = hipblasStatus_t(chipblas.hipblasCdotu_v2_64(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,n,
        float2.fromPyobj(x).getElementPtr(),incx,
        float2.fromPyobj(y).getElementPtr(),incy,
        float2.fromPyobj(result).getElementPtr()))
    return (_hipblasCdotu_v2_64__retval,)


@cython.embedsignature(True)
def hipblasZdotc_v2_64(object handle, long n, object x, long incx, object y, long incy, object result):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        x (`~.double2`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        y (`~.double2`/`~.object`):
            (undocumented)

        incy (`~.int`):
            (undocumented)

        result (`~.double2`/`~.object`):
            (undocumented)
    """
    _hipblasZdotc_v2_64__retval = hipblasStatus_t(chipblas.hipblasZdotc_v2_64(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,n,
        double2.fromPyobj(x).getElementPtr(),incx,
        double2.fromPyobj(y).getElementPtr(),incy,
        double2.fromPyobj(result).getElementPtr()))
    return (_hipblasZdotc_v2_64__retval,)


@cython.embedsignature(True)
def hipblasZdotu_v2_64(object handle, long n, object x, long incx, object y, long incy, object result):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        x (`~.double2`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        y (`~.double2`/`~.object`):
            (undocumented)

        incy (`~.int`):
            (undocumented)

        result (`~.double2`/`~.object`):
            (undocumented)
    """
    _hipblasZdotu_v2_64__retval = hipblasStatus_t(chipblas.hipblasZdotu_v2_64(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,n,
        double2.fromPyobj(x).getElementPtr(),incx,
        double2.fromPyobj(y).getElementPtr(),incy,
        double2.fromPyobj(result).getElementPtr()))
    return (_hipblasZdotu_v2_64__retval,)


@cython.embedsignature(True)
def hipblasHdotBatched(object handle, int n, object x, int incx, object y, int incy, int batchCount, object result):
    r"""BLAS Level 1 API

    @{

    dotBatched(u) performs a batch of dot products of vectors x and y

    result_i = x_i * y_i;

    dotcBatched  performs a batch of dot products of the conjugate of complex vector x and complex vector y

        result_i = conjugate (x_i) * y_i;

    where (x_i, y_i) is the i-th instance of the batch.
    x_i and y_i are vectors, for i = 1, ..., batchCount

    - Supported precisions in rocBLAS : h,bf,s,d,c,z
    - Supported precisions in cuBLAS  : No support

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`) -- *IN*:
            [hipblasHandle_t]
            handle to the hipblas library context queue.

        n (`~.int`) -- *IN*:
            [int]
            the number of elements in each x_i and y_i.

        x (`~.hip._util.types.ListOfPointer`/`~.object`) -- *IN*:
            device array of device pointers storing each vector x_i.

        incx (`~.int`) -- *IN*:
            [int]
            specifies the increment for the elements of each x_i.

        y (`~.hip._util.types.ListOfPointer`/`~.object`) -- *IN*:
            device array of device pointers storing each vector y_i.

        incy (`~.int`) -- *IN*:
            [int]
            specifies the increment for the elements of each y_i.

        batchCount (`~.int`) -- *IN*:
            [int]
            number of instances in the batch

        result (`~.hip._util.types.Pointer`/`~.object`) -- *INOUT*:
            device array or host array of batchCount size to store the dot products of each batch.
            return 0.0 for each element if n <= 0.
    """
    _hipblasHdotBatched__retval = hipblasStatus_t(chipblas.hipblasHdotBatched(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,n,
        <const unsigned short *const*>hip._util.types.ListOfPointer.fromPyobj(x)._ptr,incx,
        <const unsigned short *const*>hip._util.types.ListOfPointer.fromPyobj(y)._ptr,incy,batchCount,
        <unsigned short *>hip._util.types.Pointer.fromPyobj(result)._ptr))
    return (_hipblasHdotBatched__retval,)


@cython.embedsignature(True)
def hipblasBfdotBatched(object handle, int n, object x, int incx, object y, int incy, int batchCount, object result):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        x (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        y (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        incy (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)

        result (`~.hipblasBfloat16`/`~.object`):
            (undocumented)
    """
    _hipblasBfdotBatched__retval = hipblasStatus_t(chipblas.hipblasBfdotBatched(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,n,
        <chipblas.hipblasBfloat16 *const*>hip._util.types.Pointer.fromPyobj(x)._ptr,incx,
        <chipblas.hipblasBfloat16 *const*>hip._util.types.Pointer.fromPyobj(y)._ptr,incy,batchCount,
        hipblasBfloat16.fromPyobj(result).getElementPtr()))
    return (_hipblasBfdotBatched__retval,)


@cython.embedsignature(True)
def hipblasSdotBatched(object handle, int n, object x, int incx, object y, int incy, int batchCount, object result):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        x (`~.hip._util.types.ListOfPointer`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        y (`~.hip._util.types.ListOfPointer`/`~.object`):
            (undocumented)

        incy (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)

        result (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)
    """
    _hipblasSdotBatched__retval = hipblasStatus_t(chipblas.hipblasSdotBatched(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,n,
        <const float *const*>hip._util.types.ListOfPointer.fromPyobj(x)._ptr,incx,
        <const float *const*>hip._util.types.ListOfPointer.fromPyobj(y)._ptr,incy,batchCount,
        <float *>hip._util.types.Pointer.fromPyobj(result)._ptr))
    return (_hipblasSdotBatched__retval,)


@cython.embedsignature(True)
def hipblasDdotBatched(object handle, int n, object x, int incx, object y, int incy, int batchCount, object result):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        x (`~.hip._util.types.ListOfPointer`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        y (`~.hip._util.types.ListOfPointer`/`~.object`):
            (undocumented)

        incy (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)

        result (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)
    """
    _hipblasDdotBatched__retval = hipblasStatus_t(chipblas.hipblasDdotBatched(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,n,
        <const double *const*>hip._util.types.ListOfPointer.fromPyobj(x)._ptr,incx,
        <const double *const*>hip._util.types.ListOfPointer.fromPyobj(y)._ptr,incy,batchCount,
        <double *>hip._util.types.Pointer.fromPyobj(result)._ptr))
    return (_hipblasDdotBatched__retval,)


@cython.embedsignature(True)
def hipblasCdotcBatched(object handle, int n, object x, int incx, object y, int incy, int batchCount, object result):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        x (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        y (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        incy (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)

        result (`~.hipblasComplex`/`~.object`):
            (undocumented)
    """
    _hipblasCdotcBatched__retval = hipblasStatus_t(chipblas.hipblasCdotcBatched(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,n,
        <chipblas.hipblasComplex *const*>hip._util.types.Pointer.fromPyobj(x)._ptr,incx,
        <chipblas.hipblasComplex *const*>hip._util.types.Pointer.fromPyobj(y)._ptr,incy,batchCount,
        hipblasComplex.fromPyobj(result).getElementPtr()))
    return (_hipblasCdotcBatched__retval,)


@cython.embedsignature(True)
def hipblasCdotuBatched(object handle, int n, object x, int incx, object y, int incy, int batchCount, object result):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        x (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        y (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        incy (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)

        result (`~.hipblasComplex`/`~.object`):
            (undocumented)
    """
    _hipblasCdotuBatched__retval = hipblasStatus_t(chipblas.hipblasCdotuBatched(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,n,
        <chipblas.hipblasComplex *const*>hip._util.types.Pointer.fromPyobj(x)._ptr,incx,
        <chipblas.hipblasComplex *const*>hip._util.types.Pointer.fromPyobj(y)._ptr,incy,batchCount,
        hipblasComplex.fromPyobj(result).getElementPtr()))
    return (_hipblasCdotuBatched__retval,)


@cython.embedsignature(True)
def hipblasZdotcBatched(object handle, int n, object x, int incx, object y, int incy, int batchCount, object result):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        x (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        y (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        incy (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)

        result (`~.hipblasDoubleComplex`/`~.object`):
            (undocumented)
    """
    _hipblasZdotcBatched__retval = hipblasStatus_t(chipblas.hipblasZdotcBatched(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,n,
        <chipblas.hipblasDoubleComplex *const*>hip._util.types.Pointer.fromPyobj(x)._ptr,incx,
        <chipblas.hipblasDoubleComplex *const*>hip._util.types.Pointer.fromPyobj(y)._ptr,incy,batchCount,
        hipblasDoubleComplex.fromPyobj(result).getElementPtr()))
    return (_hipblasZdotcBatched__retval,)


@cython.embedsignature(True)
def hipblasZdotuBatched(object handle, int n, object x, int incx, object y, int incy, int batchCount, object result):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        x (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        y (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        incy (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)

        result (`~.hipblasDoubleComplex`/`~.object`):
            (undocumented)
    """
    _hipblasZdotuBatched__retval = hipblasStatus_t(chipblas.hipblasZdotuBatched(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,n,
        <chipblas.hipblasDoubleComplex *const*>hip._util.types.Pointer.fromPyobj(x)._ptr,incx,
        <chipblas.hipblasDoubleComplex *const*>hip._util.types.Pointer.fromPyobj(y)._ptr,incy,batchCount,
        hipblasDoubleComplex.fromPyobj(result).getElementPtr()))
    return (_hipblasZdotuBatched__retval,)


@cython.embedsignature(True)
def hipblasCdotcBatched_v2(object handle, int n, object x, int incx, object y, int incy, int batchCount, object result):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        x (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        y (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        incy (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)

        result (`~.float2`/`~.object`):
            (undocumented)
    """
    _hipblasCdotcBatched_v2__retval = hipblasStatus_t(chipblas.hipblasCdotcBatched_v2(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,n,
        <chipblas.float2 *const*>hip._util.types.Pointer.fromPyobj(x)._ptr,incx,
        <chipblas.float2 *const*>hip._util.types.Pointer.fromPyobj(y)._ptr,incy,batchCount,
        float2.fromPyobj(result).getElementPtr()))
    return (_hipblasCdotcBatched_v2__retval,)


@cython.embedsignature(True)
def hipblasCdotuBatched_v2(object handle, int n, object x, int incx, object y, int incy, int batchCount, object result):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        x (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        y (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        incy (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)

        result (`~.float2`/`~.object`):
            (undocumented)
    """
    _hipblasCdotuBatched_v2__retval = hipblasStatus_t(chipblas.hipblasCdotuBatched_v2(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,n,
        <chipblas.float2 *const*>hip._util.types.Pointer.fromPyobj(x)._ptr,incx,
        <chipblas.float2 *const*>hip._util.types.Pointer.fromPyobj(y)._ptr,incy,batchCount,
        float2.fromPyobj(result).getElementPtr()))
    return (_hipblasCdotuBatched_v2__retval,)


@cython.embedsignature(True)
def hipblasZdotcBatched_v2(object handle, int n, object x, int incx, object y, int incy, int batchCount, object result):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        x (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        y (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        incy (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)

        result (`~.double2`/`~.object`):
            (undocumented)
    """
    _hipblasZdotcBatched_v2__retval = hipblasStatus_t(chipblas.hipblasZdotcBatched_v2(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,n,
        <chipblas.double2 *const*>hip._util.types.Pointer.fromPyobj(x)._ptr,incx,
        <chipblas.double2 *const*>hip._util.types.Pointer.fromPyobj(y)._ptr,incy,batchCount,
        double2.fromPyobj(result).getElementPtr()))
    return (_hipblasZdotcBatched_v2__retval,)


@cython.embedsignature(True)
def hipblasZdotuBatched_v2(object handle, int n, object x, int incx, object y, int incy, int batchCount, object result):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        x (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        y (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        incy (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)

        result (`~.double2`/`~.object`):
            (undocumented)
    """
    _hipblasZdotuBatched_v2__retval = hipblasStatus_t(chipblas.hipblasZdotuBatched_v2(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,n,
        <chipblas.double2 *const*>hip._util.types.Pointer.fromPyobj(x)._ptr,incx,
        <chipblas.double2 *const*>hip._util.types.Pointer.fromPyobj(y)._ptr,incy,batchCount,
        double2.fromPyobj(result).getElementPtr()))
    return (_hipblasZdotuBatched_v2__retval,)


@cython.embedsignature(True)
def hipblasHdotBatched_64(object handle, long n, object x, long incx, object y, long incy, long batchCount, object result):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        x (`~.hip._util.types.ListOfPointer`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        y (`~.hip._util.types.ListOfPointer`/`~.object`):
            (undocumented)

        incy (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)

        result (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)
    """
    _hipblasHdotBatched_64__retval = hipblasStatus_t(chipblas.hipblasHdotBatched_64(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,n,
        <const unsigned short *const*>hip._util.types.ListOfPointer.fromPyobj(x)._ptr,incx,
        <const unsigned short *const*>hip._util.types.ListOfPointer.fromPyobj(y)._ptr,incy,batchCount,
        <unsigned short *>hip._util.types.Pointer.fromPyobj(result)._ptr))
    return (_hipblasHdotBatched_64__retval,)


@cython.embedsignature(True)
def hipblasBfdotBatched_64(object handle, long n, object x, long incx, object y, long incy, long batchCount, object result):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        x (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        y (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        incy (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)

        result (`~.hipblasBfloat16`/`~.object`):
            (undocumented)
    """
    _hipblasBfdotBatched_64__retval = hipblasStatus_t(chipblas.hipblasBfdotBatched_64(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,n,
        <chipblas.hipblasBfloat16 *const*>hip._util.types.Pointer.fromPyobj(x)._ptr,incx,
        <chipblas.hipblasBfloat16 *const*>hip._util.types.Pointer.fromPyobj(y)._ptr,incy,batchCount,
        hipblasBfloat16.fromPyobj(result).getElementPtr()))
    return (_hipblasBfdotBatched_64__retval,)


@cython.embedsignature(True)
def hipblasSdotBatched_64(object handle, long n, object x, long incx, object y, long incy, long batchCount, object result):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        x (`~.hip._util.types.ListOfPointer`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        y (`~.hip._util.types.ListOfPointer`/`~.object`):
            (undocumented)

        incy (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)

        result (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)
    """
    _hipblasSdotBatched_64__retval = hipblasStatus_t(chipblas.hipblasSdotBatched_64(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,n,
        <const float *const*>hip._util.types.ListOfPointer.fromPyobj(x)._ptr,incx,
        <const float *const*>hip._util.types.ListOfPointer.fromPyobj(y)._ptr,incy,batchCount,
        <float *>hip._util.types.Pointer.fromPyobj(result)._ptr))
    return (_hipblasSdotBatched_64__retval,)


@cython.embedsignature(True)
def hipblasDdotBatched_64(object handle, long n, object x, long incx, object y, long incy, long batchCount, object result):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        x (`~.hip._util.types.ListOfPointer`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        y (`~.hip._util.types.ListOfPointer`/`~.object`):
            (undocumented)

        incy (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)

        result (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)
    """
    _hipblasDdotBatched_64__retval = hipblasStatus_t(chipblas.hipblasDdotBatched_64(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,n,
        <const double *const*>hip._util.types.ListOfPointer.fromPyobj(x)._ptr,incx,
        <const double *const*>hip._util.types.ListOfPointer.fromPyobj(y)._ptr,incy,batchCount,
        <double *>hip._util.types.Pointer.fromPyobj(result)._ptr))
    return (_hipblasDdotBatched_64__retval,)


@cython.embedsignature(True)
def hipblasCdotcBatched_64(object handle, long n, object x, long incx, object y, long incy, long batchCount, object result):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        x (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        y (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        incy (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)

        result (`~.hipblasComplex`/`~.object`):
            (undocumented)
    """
    _hipblasCdotcBatched_64__retval = hipblasStatus_t(chipblas.hipblasCdotcBatched_64(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,n,
        <chipblas.hipblasComplex *const*>hip._util.types.Pointer.fromPyobj(x)._ptr,incx,
        <chipblas.hipblasComplex *const*>hip._util.types.Pointer.fromPyobj(y)._ptr,incy,batchCount,
        hipblasComplex.fromPyobj(result).getElementPtr()))
    return (_hipblasCdotcBatched_64__retval,)


@cython.embedsignature(True)
def hipblasCdotuBatched_64(object handle, long n, object x, long incx, object y, long incy, long batchCount, object result):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        x (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        y (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        incy (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)

        result (`~.hipblasComplex`/`~.object`):
            (undocumented)
    """
    _hipblasCdotuBatched_64__retval = hipblasStatus_t(chipblas.hipblasCdotuBatched_64(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,n,
        <chipblas.hipblasComplex *const*>hip._util.types.Pointer.fromPyobj(x)._ptr,incx,
        <chipblas.hipblasComplex *const*>hip._util.types.Pointer.fromPyobj(y)._ptr,incy,batchCount,
        hipblasComplex.fromPyobj(result).getElementPtr()))
    return (_hipblasCdotuBatched_64__retval,)


@cython.embedsignature(True)
def hipblasZdotcBatched_64(object handle, long n, object x, long incx, object y, long incy, long batchCount, object result):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        x (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        y (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        incy (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)

        result (`~.hipblasDoubleComplex`/`~.object`):
            (undocumented)
    """
    _hipblasZdotcBatched_64__retval = hipblasStatus_t(chipblas.hipblasZdotcBatched_64(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,n,
        <chipblas.hipblasDoubleComplex *const*>hip._util.types.Pointer.fromPyobj(x)._ptr,incx,
        <chipblas.hipblasDoubleComplex *const*>hip._util.types.Pointer.fromPyobj(y)._ptr,incy,batchCount,
        hipblasDoubleComplex.fromPyobj(result).getElementPtr()))
    return (_hipblasZdotcBatched_64__retval,)


@cython.embedsignature(True)
def hipblasZdotuBatched_64(object handle, long n, object x, long incx, object y, long incy, long batchCount, object result):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        x (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        y (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        incy (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)

        result (`~.hipblasDoubleComplex`/`~.object`):
            (undocumented)
    """
    _hipblasZdotuBatched_64__retval = hipblasStatus_t(chipblas.hipblasZdotuBatched_64(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,n,
        <chipblas.hipblasDoubleComplex *const*>hip._util.types.Pointer.fromPyobj(x)._ptr,incx,
        <chipblas.hipblasDoubleComplex *const*>hip._util.types.Pointer.fromPyobj(y)._ptr,incy,batchCount,
        hipblasDoubleComplex.fromPyobj(result).getElementPtr()))
    return (_hipblasZdotuBatched_64__retval,)


@cython.embedsignature(True)
def hipblasCdotcBatched_v2_64(object handle, long n, object x, long incx, object y, long incy, long batchCount, object result):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        x (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        y (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        incy (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)

        result (`~.float2`/`~.object`):
            (undocumented)
    """
    _hipblasCdotcBatched_v2_64__retval = hipblasStatus_t(chipblas.hipblasCdotcBatched_v2_64(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,n,
        <chipblas.float2 *const*>hip._util.types.Pointer.fromPyobj(x)._ptr,incx,
        <chipblas.float2 *const*>hip._util.types.Pointer.fromPyobj(y)._ptr,incy,batchCount,
        float2.fromPyobj(result).getElementPtr()))
    return (_hipblasCdotcBatched_v2_64__retval,)


@cython.embedsignature(True)
def hipblasCdotuBatched_v2_64(object handle, long n, object x, long incx, object y, long incy, long batchCount, object result):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        x (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        y (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        incy (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)

        result (`~.float2`/`~.object`):
            (undocumented)
    """
    _hipblasCdotuBatched_v2_64__retval = hipblasStatus_t(chipblas.hipblasCdotuBatched_v2_64(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,n,
        <chipblas.float2 *const*>hip._util.types.Pointer.fromPyobj(x)._ptr,incx,
        <chipblas.float2 *const*>hip._util.types.Pointer.fromPyobj(y)._ptr,incy,batchCount,
        float2.fromPyobj(result).getElementPtr()))
    return (_hipblasCdotuBatched_v2_64__retval,)


@cython.embedsignature(True)
def hipblasZdotcBatched_v2_64(object handle, long n, object x, long incx, object y, long incy, long batchCount, object result):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        x (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        y (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        incy (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)

        result (`~.double2`/`~.object`):
            (undocumented)
    """
    _hipblasZdotcBatched_v2_64__retval = hipblasStatus_t(chipblas.hipblasZdotcBatched_v2_64(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,n,
        <chipblas.double2 *const*>hip._util.types.Pointer.fromPyobj(x)._ptr,incx,
        <chipblas.double2 *const*>hip._util.types.Pointer.fromPyobj(y)._ptr,incy,batchCount,
        double2.fromPyobj(result).getElementPtr()))
    return (_hipblasZdotcBatched_v2_64__retval,)


@cython.embedsignature(True)
def hipblasZdotuBatched_v2_64(object handle, long n, object x, long incx, object y, long incy, long batchCount, object result):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        x (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        y (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        incy (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)

        result (`~.double2`/`~.object`):
            (undocumented)
    """
    _hipblasZdotuBatched_v2_64__retval = hipblasStatus_t(chipblas.hipblasZdotuBatched_v2_64(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,n,
        <chipblas.double2 *const*>hip._util.types.Pointer.fromPyobj(x)._ptr,incx,
        <chipblas.double2 *const*>hip._util.types.Pointer.fromPyobj(y)._ptr,incy,batchCount,
        double2.fromPyobj(result).getElementPtr()))
    return (_hipblasZdotuBatched_v2_64__retval,)


@cython.embedsignature(True)
def hipblasHdotStridedBatched(object handle, int n, object x, int incx, long stridex, object y, int incy, long stridey, int batchCount, object result):
    r"""BLAS Level 1 API

    @{

    dotStridedBatched(u)  performs a batch of dot products of vectors x and y

    result_i = x_i * y_i;

    dotcStridedBatched  performs a batch of dot products of the conjugate of complex vector x and complex vector y

        result_i = conjugate (x_i) * y_i;

    where (x_i, y_i) is the i-th instance of the batch.
    x_i and y_i are vectors, for i = 1, ..., batchCount

    - Supported precisions in rocBLAS : h,bf,s,d,c,z
    - Supported precisions in cuBLAS  : No support

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`) -- *IN*:
            [hipblasHandle_t]
            handle to the hipblas library context queue.

        n (`~.int`) -- *IN*:
            [int]
            the number of elements in each x_i and y_i.

        x (`~.hip._util.types.Pointer`/`~.object`) -- *IN*:
            device pointer to the first vector (x_1) in the batch.

        incx (`~.int`) -- *IN*:
            [int]
            specifies the increment for the elements of each x_i.

        stridex (`~.int`) -- *IN*:
            [hipblasStride]
            stride from the start of one vector (x_i) and the next one (x_i+1)

        y (`~.hip._util.types.Pointer`/`~.object`) -- *IN*:
            device pointer to the first vector (y_1) in the batch.

        incy (`~.int`) -- *IN*:
            [int]
            specifies the increment for the elements of each y_i.

        stridey (`~.int`) -- *IN*:
            [hipblasStride]
            stride from the start of one vector (y_i) and the next one (y_i+1)

        batchCount (`~.int`) -- *IN*:
            [int]
            number of instances in the batch

        result (`~.hip._util.types.Pointer`/`~.object`) -- *INOUT*:
            device array or host array of batchCount size to store the dot products of each batch.
            return 0.0 for each element if n <= 0.
    """
    _hipblasHdotStridedBatched__retval = hipblasStatus_t(chipblas.hipblasHdotStridedBatched(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,n,
        <const unsigned short *>hip._util.types.Pointer.fromPyobj(x)._ptr,incx,stridex,
        <const unsigned short *>hip._util.types.Pointer.fromPyobj(y)._ptr,incy,stridey,batchCount,
        <unsigned short *>hip._util.types.Pointer.fromPyobj(result)._ptr))
    return (_hipblasHdotStridedBatched__retval,)


@cython.embedsignature(True)
def hipblasBfdotStridedBatched(object handle, int n, object x, int incx, long stridex, object y, int incy, long stridey, int batchCount, object result):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        x (`~.hipblasBfloat16`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        stridex (`~.int`):
            (undocumented)

        y (`~.hipblasBfloat16`/`~.object`):
            (undocumented)

        incy (`~.int`):
            (undocumented)

        stridey (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)

        result (`~.hipblasBfloat16`/`~.object`):
            (undocumented)
    """
    _hipblasBfdotStridedBatched__retval = hipblasStatus_t(chipblas.hipblasBfdotStridedBatched(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,n,
        hipblasBfloat16.fromPyobj(x).getElementPtr(),incx,stridex,
        hipblasBfloat16.fromPyobj(y).getElementPtr(),incy,stridey,batchCount,
        hipblasBfloat16.fromPyobj(result).getElementPtr()))
    return (_hipblasBfdotStridedBatched__retval,)


@cython.embedsignature(True)
def hipblasSdotStridedBatched(object handle, int n, object x, int incx, long stridex, object y, int incy, long stridey, int batchCount, object result):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        x (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        stridex (`~.int`):
            (undocumented)

        y (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        incy (`~.int`):
            (undocumented)

        stridey (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)

        result (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)
    """
    _hipblasSdotStridedBatched__retval = hipblasStatus_t(chipblas.hipblasSdotStridedBatched(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,n,
        <const float *>hip._util.types.Pointer.fromPyobj(x)._ptr,incx,stridex,
        <const float *>hip._util.types.Pointer.fromPyobj(y)._ptr,incy,stridey,batchCount,
        <float *>hip._util.types.Pointer.fromPyobj(result)._ptr))
    return (_hipblasSdotStridedBatched__retval,)


@cython.embedsignature(True)
def hipblasDdotStridedBatched(object handle, int n, object x, int incx, long stridex, object y, int incy, long stridey, int batchCount, object result):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        x (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        stridex (`~.int`):
            (undocumented)

        y (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        incy (`~.int`):
            (undocumented)

        stridey (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)

        result (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)
    """
    _hipblasDdotStridedBatched__retval = hipblasStatus_t(chipblas.hipblasDdotStridedBatched(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,n,
        <const double *>hip._util.types.Pointer.fromPyobj(x)._ptr,incx,stridex,
        <const double *>hip._util.types.Pointer.fromPyobj(y)._ptr,incy,stridey,batchCount,
        <double *>hip._util.types.Pointer.fromPyobj(result)._ptr))
    return (_hipblasDdotStridedBatched__retval,)


@cython.embedsignature(True)
def hipblasCdotcStridedBatched(object handle, int n, object x, int incx, long stridex, object y, int incy, long stridey, int batchCount, object result):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        x (`~.hipblasComplex`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        stridex (`~.int`):
            (undocumented)

        y (`~.hipblasComplex`/`~.object`):
            (undocumented)

        incy (`~.int`):
            (undocumented)

        stridey (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)

        result (`~.hipblasComplex`/`~.object`):
            (undocumented)
    """
    _hipblasCdotcStridedBatched__retval = hipblasStatus_t(chipblas.hipblasCdotcStridedBatched(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,n,
        hipblasComplex.fromPyobj(x).getElementPtr(),incx,stridex,
        hipblasComplex.fromPyobj(y).getElementPtr(),incy,stridey,batchCount,
        hipblasComplex.fromPyobj(result).getElementPtr()))
    return (_hipblasCdotcStridedBatched__retval,)


@cython.embedsignature(True)
def hipblasCdotuStridedBatched(object handle, int n, object x, int incx, long stridex, object y, int incy, long stridey, int batchCount, object result):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        x (`~.hipblasComplex`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        stridex (`~.int`):
            (undocumented)

        y (`~.hipblasComplex`/`~.object`):
            (undocumented)

        incy (`~.int`):
            (undocumented)

        stridey (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)

        result (`~.hipblasComplex`/`~.object`):
            (undocumented)
    """
    _hipblasCdotuStridedBatched__retval = hipblasStatus_t(chipblas.hipblasCdotuStridedBatched(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,n,
        hipblasComplex.fromPyobj(x).getElementPtr(),incx,stridex,
        hipblasComplex.fromPyobj(y).getElementPtr(),incy,stridey,batchCount,
        hipblasComplex.fromPyobj(result).getElementPtr()))
    return (_hipblasCdotuStridedBatched__retval,)


@cython.embedsignature(True)
def hipblasZdotcStridedBatched(object handle, int n, object x, int incx, long stridex, object y, int incy, long stridey, int batchCount, object result):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        x (`~.hipblasDoubleComplex`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        stridex (`~.int`):
            (undocumented)

        y (`~.hipblasDoubleComplex`/`~.object`):
            (undocumented)

        incy (`~.int`):
            (undocumented)

        stridey (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)

        result (`~.hipblasDoubleComplex`/`~.object`):
            (undocumented)
    """
    _hipblasZdotcStridedBatched__retval = hipblasStatus_t(chipblas.hipblasZdotcStridedBatched(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,n,
        hipblasDoubleComplex.fromPyobj(x).getElementPtr(),incx,stridex,
        hipblasDoubleComplex.fromPyobj(y).getElementPtr(),incy,stridey,batchCount,
        hipblasDoubleComplex.fromPyobj(result).getElementPtr()))
    return (_hipblasZdotcStridedBatched__retval,)


@cython.embedsignature(True)
def hipblasZdotuStridedBatched(object handle, int n, object x, int incx, long stridex, object y, int incy, long stridey, int batchCount, object result):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        x (`~.hipblasDoubleComplex`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        stridex (`~.int`):
            (undocumented)

        y (`~.hipblasDoubleComplex`/`~.object`):
            (undocumented)

        incy (`~.int`):
            (undocumented)

        stridey (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)

        result (`~.hipblasDoubleComplex`/`~.object`):
            (undocumented)
    """
    _hipblasZdotuStridedBatched__retval = hipblasStatus_t(chipblas.hipblasZdotuStridedBatched(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,n,
        hipblasDoubleComplex.fromPyobj(x).getElementPtr(),incx,stridex,
        hipblasDoubleComplex.fromPyobj(y).getElementPtr(),incy,stridey,batchCount,
        hipblasDoubleComplex.fromPyobj(result).getElementPtr()))
    return (_hipblasZdotuStridedBatched__retval,)


@cython.embedsignature(True)
def hipblasCdotcStridedBatched_v2(object handle, int n, object x, int incx, long stridex, object y, int incy, long stridey, int batchCount, object result):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        x (`~.float2`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        stridex (`~.int`):
            (undocumented)

        y (`~.float2`/`~.object`):
            (undocumented)

        incy (`~.int`):
            (undocumented)

        stridey (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)

        result (`~.float2`/`~.object`):
            (undocumented)
    """
    _hipblasCdotcStridedBatched_v2__retval = hipblasStatus_t(chipblas.hipblasCdotcStridedBatched_v2(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,n,
        float2.fromPyobj(x).getElementPtr(),incx,stridex,
        float2.fromPyobj(y).getElementPtr(),incy,stridey,batchCount,
        float2.fromPyobj(result).getElementPtr()))
    return (_hipblasCdotcStridedBatched_v2__retval,)


@cython.embedsignature(True)
def hipblasCdotuStridedBatched_v2(object handle, int n, object x, int incx, long stridex, object y, int incy, long stridey, int batchCount, object result):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        x (`~.float2`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        stridex (`~.int`):
            (undocumented)

        y (`~.float2`/`~.object`):
            (undocumented)

        incy (`~.int`):
            (undocumented)

        stridey (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)

        result (`~.float2`/`~.object`):
            (undocumented)
    """
    _hipblasCdotuStridedBatched_v2__retval = hipblasStatus_t(chipblas.hipblasCdotuStridedBatched_v2(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,n,
        float2.fromPyobj(x).getElementPtr(),incx,stridex,
        float2.fromPyobj(y).getElementPtr(),incy,stridey,batchCount,
        float2.fromPyobj(result).getElementPtr()))
    return (_hipblasCdotuStridedBatched_v2__retval,)


@cython.embedsignature(True)
def hipblasZdotcStridedBatched_v2(object handle, int n, object x, int incx, long stridex, object y, int incy, long stridey, int batchCount, object result):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        x (`~.double2`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        stridex (`~.int`):
            (undocumented)

        y (`~.double2`/`~.object`):
            (undocumented)

        incy (`~.int`):
            (undocumented)

        stridey (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)

        result (`~.double2`/`~.object`):
            (undocumented)
    """
    _hipblasZdotcStridedBatched_v2__retval = hipblasStatus_t(chipblas.hipblasZdotcStridedBatched_v2(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,n,
        double2.fromPyobj(x).getElementPtr(),incx,stridex,
        double2.fromPyobj(y).getElementPtr(),incy,stridey,batchCount,
        double2.fromPyobj(result).getElementPtr()))
    return (_hipblasZdotcStridedBatched_v2__retval,)


@cython.embedsignature(True)
def hipblasZdotuStridedBatched_v2(object handle, int n, object x, int incx, long stridex, object y, int incy, long stridey, int batchCount, object result):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        x (`~.double2`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        stridex (`~.int`):
            (undocumented)

        y (`~.double2`/`~.object`):
            (undocumented)

        incy (`~.int`):
            (undocumented)

        stridey (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)

        result (`~.double2`/`~.object`):
            (undocumented)
    """
    _hipblasZdotuStridedBatched_v2__retval = hipblasStatus_t(chipblas.hipblasZdotuStridedBatched_v2(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,n,
        double2.fromPyobj(x).getElementPtr(),incx,stridex,
        double2.fromPyobj(y).getElementPtr(),incy,stridey,batchCount,
        double2.fromPyobj(result).getElementPtr()))
    return (_hipblasZdotuStridedBatched_v2__retval,)


@cython.embedsignature(True)
def hipblasHdotStridedBatched_64(object handle, long n, object x, long incx, long stridex, object y, long incy, long stridey, long batchCount, object result):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        x (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        stridex (`~.int`):
            (undocumented)

        y (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        incy (`~.int`):
            (undocumented)

        stridey (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)

        result (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)
    """
    _hipblasHdotStridedBatched_64__retval = hipblasStatus_t(chipblas.hipblasHdotStridedBatched_64(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,n,
        <const unsigned short *>hip._util.types.Pointer.fromPyobj(x)._ptr,incx,stridex,
        <const unsigned short *>hip._util.types.Pointer.fromPyobj(y)._ptr,incy,stridey,batchCount,
        <unsigned short *>hip._util.types.Pointer.fromPyobj(result)._ptr))
    return (_hipblasHdotStridedBatched_64__retval,)


@cython.embedsignature(True)
def hipblasBfdotStridedBatched_64(object handle, long n, object x, long incx, long stridex, object y, long incy, long stridey, long batchCount, object result):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        x (`~.hipblasBfloat16`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        stridex (`~.int`):
            (undocumented)

        y (`~.hipblasBfloat16`/`~.object`):
            (undocumented)

        incy (`~.int`):
            (undocumented)

        stridey (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)

        result (`~.hipblasBfloat16`/`~.object`):
            (undocumented)
    """
    _hipblasBfdotStridedBatched_64__retval = hipblasStatus_t(chipblas.hipblasBfdotStridedBatched_64(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,n,
        hipblasBfloat16.fromPyobj(x).getElementPtr(),incx,stridex,
        hipblasBfloat16.fromPyobj(y).getElementPtr(),incy,stridey,batchCount,
        hipblasBfloat16.fromPyobj(result).getElementPtr()))
    return (_hipblasBfdotStridedBatched_64__retval,)


@cython.embedsignature(True)
def hipblasSdotStridedBatched_64(object handle, long n, object x, long incx, long stridex, object y, long incy, long stridey, long batchCount, object result):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        x (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        stridex (`~.int`):
            (undocumented)

        y (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        incy (`~.int`):
            (undocumented)

        stridey (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)

        result (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)
    """
    _hipblasSdotStridedBatched_64__retval = hipblasStatus_t(chipblas.hipblasSdotStridedBatched_64(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,n,
        <const float *>hip._util.types.Pointer.fromPyobj(x)._ptr,incx,stridex,
        <const float *>hip._util.types.Pointer.fromPyobj(y)._ptr,incy,stridey,batchCount,
        <float *>hip._util.types.Pointer.fromPyobj(result)._ptr))
    return (_hipblasSdotStridedBatched_64__retval,)


@cython.embedsignature(True)
def hipblasDdotStridedBatched_64(object handle, long n, object x, long incx, long stridex, object y, long incy, long stridey, long batchCount, object result):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        x (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        stridex (`~.int`):
            (undocumented)

        y (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        incy (`~.int`):
            (undocumented)

        stridey (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)

        result (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)
    """
    _hipblasDdotStridedBatched_64__retval = hipblasStatus_t(chipblas.hipblasDdotStridedBatched_64(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,n,
        <const double *>hip._util.types.Pointer.fromPyobj(x)._ptr,incx,stridex,
        <const double *>hip._util.types.Pointer.fromPyobj(y)._ptr,incy,stridey,batchCount,
        <double *>hip._util.types.Pointer.fromPyobj(result)._ptr))
    return (_hipblasDdotStridedBatched_64__retval,)


@cython.embedsignature(True)
def hipblasCdotcStridedBatched_64(object handle, long n, object x, long incx, long stridex, object y, long incy, long stridey, long batchCount, object result):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        x (`~.hipblasComplex`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        stridex (`~.int`):
            (undocumented)

        y (`~.hipblasComplex`/`~.object`):
            (undocumented)

        incy (`~.int`):
            (undocumented)

        stridey (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)

        result (`~.hipblasComplex`/`~.object`):
            (undocumented)
    """
    _hipblasCdotcStridedBatched_64__retval = hipblasStatus_t(chipblas.hipblasCdotcStridedBatched_64(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,n,
        hipblasComplex.fromPyobj(x).getElementPtr(),incx,stridex,
        hipblasComplex.fromPyobj(y).getElementPtr(),incy,stridey,batchCount,
        hipblasComplex.fromPyobj(result).getElementPtr()))
    return (_hipblasCdotcStridedBatched_64__retval,)


@cython.embedsignature(True)
def hipblasCdotuStridedBatched_64(object handle, long n, object x, long incx, long stridex, object y, long incy, long stridey, long batchCount, object result):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        x (`~.hipblasComplex`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        stridex (`~.int`):
            (undocumented)

        y (`~.hipblasComplex`/`~.object`):
            (undocumented)

        incy (`~.int`):
            (undocumented)

        stridey (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)

        result (`~.hipblasComplex`/`~.object`):
            (undocumented)
    """
    _hipblasCdotuStridedBatched_64__retval = hipblasStatus_t(chipblas.hipblasCdotuStridedBatched_64(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,n,
        hipblasComplex.fromPyobj(x).getElementPtr(),incx,stridex,
        hipblasComplex.fromPyobj(y).getElementPtr(),incy,stridey,batchCount,
        hipblasComplex.fromPyobj(result).getElementPtr()))
    return (_hipblasCdotuStridedBatched_64__retval,)


@cython.embedsignature(True)
def hipblasZdotcStridedBatched_64(object handle, long n, object x, long incx, long stridex, object y, long incy, long stridey, long batchCount, object result):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        x (`~.hipblasDoubleComplex`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        stridex (`~.int`):
            (undocumented)

        y (`~.hipblasDoubleComplex`/`~.object`):
            (undocumented)

        incy (`~.int`):
            (undocumented)

        stridey (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)

        result (`~.hipblasDoubleComplex`/`~.object`):
            (undocumented)
    """
    _hipblasZdotcStridedBatched_64__retval = hipblasStatus_t(chipblas.hipblasZdotcStridedBatched_64(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,n,
        hipblasDoubleComplex.fromPyobj(x).getElementPtr(),incx,stridex,
        hipblasDoubleComplex.fromPyobj(y).getElementPtr(),incy,stridey,batchCount,
        hipblasDoubleComplex.fromPyobj(result).getElementPtr()))
    return (_hipblasZdotcStridedBatched_64__retval,)


@cython.embedsignature(True)
def hipblasZdotuStridedBatched_64(object handle, long n, object x, long incx, long stridex, object y, long incy, long stridey, long batchCount, object result):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        x (`~.hipblasDoubleComplex`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        stridex (`~.int`):
            (undocumented)

        y (`~.hipblasDoubleComplex`/`~.object`):
            (undocumented)

        incy (`~.int`):
            (undocumented)

        stridey (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)

        result (`~.hipblasDoubleComplex`/`~.object`):
            (undocumented)
    """
    _hipblasZdotuStridedBatched_64__retval = hipblasStatus_t(chipblas.hipblasZdotuStridedBatched_64(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,n,
        hipblasDoubleComplex.fromPyobj(x).getElementPtr(),incx,stridex,
        hipblasDoubleComplex.fromPyobj(y).getElementPtr(),incy,stridey,batchCount,
        hipblasDoubleComplex.fromPyobj(result).getElementPtr()))
    return (_hipblasZdotuStridedBatched_64__retval,)


@cython.embedsignature(True)
def hipblasCdotcStridedBatched_v2_64(object handle, long n, object x, long incx, long stridex, object y, long incy, long stridey, long batchCount, object result):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        x (`~.float2`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        stridex (`~.int`):
            (undocumented)

        y (`~.float2`/`~.object`):
            (undocumented)

        incy (`~.int`):
            (undocumented)

        stridey (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)

        result (`~.float2`/`~.object`):
            (undocumented)
    """
    _hipblasCdotcStridedBatched_v2_64__retval = hipblasStatus_t(chipblas.hipblasCdotcStridedBatched_v2_64(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,n,
        float2.fromPyobj(x).getElementPtr(),incx,stridex,
        float2.fromPyobj(y).getElementPtr(),incy,stridey,batchCount,
        float2.fromPyobj(result).getElementPtr()))
    return (_hipblasCdotcStridedBatched_v2_64__retval,)


@cython.embedsignature(True)
def hipblasCdotuStridedBatched_v2_64(object handle, long n, object x, long incx, long stridex, object y, long incy, long stridey, long batchCount, object result):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        x (`~.float2`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        stridex (`~.int`):
            (undocumented)

        y (`~.float2`/`~.object`):
            (undocumented)

        incy (`~.int`):
            (undocumented)

        stridey (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)

        result (`~.float2`/`~.object`):
            (undocumented)
    """
    _hipblasCdotuStridedBatched_v2_64__retval = hipblasStatus_t(chipblas.hipblasCdotuStridedBatched_v2_64(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,n,
        float2.fromPyobj(x).getElementPtr(),incx,stridex,
        float2.fromPyobj(y).getElementPtr(),incy,stridey,batchCount,
        float2.fromPyobj(result).getElementPtr()))
    return (_hipblasCdotuStridedBatched_v2_64__retval,)


@cython.embedsignature(True)
def hipblasZdotcStridedBatched_v2_64(object handle, long n, object x, long incx, long stridex, object y, long incy, long stridey, long batchCount, object result):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        x (`~.double2`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        stridex (`~.int`):
            (undocumented)

        y (`~.double2`/`~.object`):
            (undocumented)

        incy (`~.int`):
            (undocumented)

        stridey (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)

        result (`~.double2`/`~.object`):
            (undocumented)
    """
    _hipblasZdotcStridedBatched_v2_64__retval = hipblasStatus_t(chipblas.hipblasZdotcStridedBatched_v2_64(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,n,
        double2.fromPyobj(x).getElementPtr(),incx,stridex,
        double2.fromPyobj(y).getElementPtr(),incy,stridey,batchCount,
        double2.fromPyobj(result).getElementPtr()))
    return (_hipblasZdotcStridedBatched_v2_64__retval,)


@cython.embedsignature(True)
def hipblasZdotuStridedBatched_v2_64(object handle, long n, object x, long incx, long stridex, object y, long incy, long stridey, long batchCount, object result):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        x (`~.double2`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        stridex (`~.int`):
            (undocumented)

        y (`~.double2`/`~.object`):
            (undocumented)

        incy (`~.int`):
            (undocumented)

        stridey (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)

        result (`~.double2`/`~.object`):
            (undocumented)
    """
    _hipblasZdotuStridedBatched_v2_64__retval = hipblasStatus_t(chipblas.hipblasZdotuStridedBatched_v2_64(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,n,
        double2.fromPyobj(x).getElementPtr(),incx,stridex,
        double2.fromPyobj(y).getElementPtr(),incy,stridey,batchCount,
        double2.fromPyobj(result).getElementPtr()))
    return (_hipblasZdotuStridedBatched_v2_64__retval,)


@cython.embedsignature(True)
def hipblasSnrm2(object handle, int n, object x, int incx, object result):
    r"""BLAS Level 1 API

    @{

    nrm2 computes the euclidean norm of a real or complex vector

    result := sqrt( x'*x ) for real vectors
              result := sqrt( x**H*x ) for complex vectors

    - Supported precisions in rocBLAS : s,d,c,z,sc,dz
    - Supported precisions in cuBLAS  : s,d,sc,dz

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`) -- *IN*:
            [hipblasHandle_t]
            handle to the hipblas library context queue.

        n (`~.int`) -- *IN*:
            [int]
            the number of elements in x.

        x (`~.hip._util.types.Pointer`/`~.object`) -- *IN*:
            device pointer storing vector x.

        incx (`~.int`) -- *IN*:
            [int]
            specifies the increment for the elements of y.

        result (`~.hip._util.types.Pointer`/`~.object`) -- *INOUT*:
            device pointer or host pointer to store the nrm2 product.
            return is 0.0 if n, incx<=0.
    """
    _hipblasSnrm2__retval = hipblasStatus_t(chipblas.hipblasSnrm2(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,n,
        <const float *>hip._util.types.Pointer.fromPyobj(x)._ptr,incx,
        <float *>hip._util.types.Pointer.fromPyobj(result)._ptr))
    return (_hipblasSnrm2__retval,)


@cython.embedsignature(True)
def hipblasDnrm2(object handle, int n, object x, int incx, object result):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        x (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        result (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)
    """
    _hipblasDnrm2__retval = hipblasStatus_t(chipblas.hipblasDnrm2(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,n,
        <const double *>hip._util.types.Pointer.fromPyobj(x)._ptr,incx,
        <double *>hip._util.types.Pointer.fromPyobj(result)._ptr))
    return (_hipblasDnrm2__retval,)


@cython.embedsignature(True)
def hipblasScnrm2(object handle, int n, object x, int incx, object result):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        x (`~.hipblasComplex`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        result (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)
    """
    _hipblasScnrm2__retval = hipblasStatus_t(chipblas.hipblasScnrm2(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,n,
        hipblasComplex.fromPyobj(x).getElementPtr(),incx,
        <float *>hip._util.types.Pointer.fromPyobj(result)._ptr))
    return (_hipblasScnrm2__retval,)


@cython.embedsignature(True)
def hipblasDznrm2(object handle, int n, object x, int incx, object result):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        x (`~.hipblasDoubleComplex`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        result (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)
    """
    _hipblasDznrm2__retval = hipblasStatus_t(chipblas.hipblasDznrm2(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,n,
        hipblasDoubleComplex.fromPyobj(x).getElementPtr(),incx,
        <double *>hip._util.types.Pointer.fromPyobj(result)._ptr))
    return (_hipblasDznrm2__retval,)


@cython.embedsignature(True)
def hipblasScnrm2_v2(object handle, int n, object x, int incx, object result):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        x (`~.float2`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        result (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)
    """
    _hipblasScnrm2_v2__retval = hipblasStatus_t(chipblas.hipblasScnrm2_v2(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,n,
        float2.fromPyobj(x).getElementPtr(),incx,
        <float *>hip._util.types.Pointer.fromPyobj(result)._ptr))
    return (_hipblasScnrm2_v2__retval,)


@cython.embedsignature(True)
def hipblasDznrm2_v2(object handle, int n, object x, int incx, object result):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        x (`~.double2`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        result (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)
    """
    _hipblasDznrm2_v2__retval = hipblasStatus_t(chipblas.hipblasDznrm2_v2(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,n,
        double2.fromPyobj(x).getElementPtr(),incx,
        <double *>hip._util.types.Pointer.fromPyobj(result)._ptr))
    return (_hipblasDznrm2_v2__retval,)


@cython.embedsignature(True)
def hipblasSnrm2_64(object handle, long n, object x, long incx, object result):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        x (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        result (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)
    """
    _hipblasSnrm2_64__retval = hipblasStatus_t(chipblas.hipblasSnrm2_64(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,n,
        <const float *>hip._util.types.Pointer.fromPyobj(x)._ptr,incx,
        <float *>hip._util.types.Pointer.fromPyobj(result)._ptr))
    return (_hipblasSnrm2_64__retval,)


@cython.embedsignature(True)
def hipblasDnrm2_64(object handle, long n, object x, long incx, object result):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        x (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        result (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)
    """
    _hipblasDnrm2_64__retval = hipblasStatus_t(chipblas.hipblasDnrm2_64(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,n,
        <const double *>hip._util.types.Pointer.fromPyobj(x)._ptr,incx,
        <double *>hip._util.types.Pointer.fromPyobj(result)._ptr))
    return (_hipblasDnrm2_64__retval,)


@cython.embedsignature(True)
def hipblasScnrm2_64(object handle, long n, object x, long incx, object result):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        x (`~.hipblasComplex`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        result (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)
    """
    _hipblasScnrm2_64__retval = hipblasStatus_t(chipblas.hipblasScnrm2_64(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,n,
        hipblasComplex.fromPyobj(x).getElementPtr(),incx,
        <float *>hip._util.types.Pointer.fromPyobj(result)._ptr))
    return (_hipblasScnrm2_64__retval,)


@cython.embedsignature(True)
def hipblasDznrm2_64(object handle, long n, object x, long incx, object result):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        x (`~.hipblasDoubleComplex`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        result (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)
    """
    _hipblasDznrm2_64__retval = hipblasStatus_t(chipblas.hipblasDznrm2_64(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,n,
        hipblasDoubleComplex.fromPyobj(x).getElementPtr(),incx,
        <double *>hip._util.types.Pointer.fromPyobj(result)._ptr))
    return (_hipblasDznrm2_64__retval,)


@cython.embedsignature(True)
def hipblasScnrm2_v2_64(object handle, long n, object x, long incx, object result):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        x (`~.float2`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        result (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)
    """
    _hipblasScnrm2_v2_64__retval = hipblasStatus_t(chipblas.hipblasScnrm2_v2_64(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,n,
        float2.fromPyobj(x).getElementPtr(),incx,
        <float *>hip._util.types.Pointer.fromPyobj(result)._ptr))
    return (_hipblasScnrm2_v2_64__retval,)


@cython.embedsignature(True)
def hipblasDznrm2_v2_64(object handle, long n, object x, long incx, object result):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        x (`~.double2`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        result (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)
    """
    _hipblasDznrm2_v2_64__retval = hipblasStatus_t(chipblas.hipblasDznrm2_v2_64(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,n,
        double2.fromPyobj(x).getElementPtr(),incx,
        <double *>hip._util.types.Pointer.fromPyobj(result)._ptr))
    return (_hipblasDznrm2_v2_64__retval,)


@cython.embedsignature(True)
def hipblasSnrm2Batched(object handle, int n, object x, int incx, int batchCount, object result):
    r"""BLAS Level 1 API

    @{

    nrm2Batched computes the euclidean norm over a batch of real or complex vectors

    result := sqrt( x_i'*x_i ) for real vectors x, for i = 1, ..., batchCount
              result := sqrt( x_i**H*x_i ) for complex vectors x, for i = 1, ..., batchCount

    - Supported precisions in rocBLAS : s,d,c,z,sc,dz
    - Supported precisions in cuBLAS  : No support

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`) -- *IN*:
            [hipblasHandle_t]
            handle to the hipblas library context queue.

        n (`~.int`) -- *IN*:
            [int]
            number of elements in each x_i.

        x (`~.hip._util.types.ListOfPointer`/`~.object`) -- *IN*:
            device array of device pointers storing each vector x_i.

        incx (`~.int`) -- *IN*:
            [int]
            specifies the increment for the elements of each x_i. incx must be > 0.

        batchCount (`~.int`) -- *IN*:
            [int]
            number of instances in the batch

        result (`~.hip._util.types.Pointer`/`~.object`) -- *OUT*:
            device pointer or host pointer to array of batchCount size for nrm2 results.
            return is 0.0 for each element if n <= 0, incx<=0.
    """
    _hipblasSnrm2Batched__retval = hipblasStatus_t(chipblas.hipblasSnrm2Batched(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,n,
        <const float *const*>hip._util.types.ListOfPointer.fromPyobj(x)._ptr,incx,batchCount,
        <float *>hip._util.types.Pointer.fromPyobj(result)._ptr))
    return (_hipblasSnrm2Batched__retval,)


@cython.embedsignature(True)
def hipblasDnrm2Batched(object handle, int n, object x, int incx, int batchCount, object result):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        x (`~.hip._util.types.ListOfPointer`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)

        result (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)
    """
    _hipblasDnrm2Batched__retval = hipblasStatus_t(chipblas.hipblasDnrm2Batched(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,n,
        <const double *const*>hip._util.types.ListOfPointer.fromPyobj(x)._ptr,incx,batchCount,
        <double *>hip._util.types.Pointer.fromPyobj(result)._ptr))
    return (_hipblasDnrm2Batched__retval,)


@cython.embedsignature(True)
def hipblasScnrm2Batched(object handle, int n, object x, int incx, int batchCount, object result):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        x (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)

        result (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)
    """
    _hipblasScnrm2Batched__retval = hipblasStatus_t(chipblas.hipblasScnrm2Batched(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,n,
        <chipblas.hipblasComplex *const*>hip._util.types.Pointer.fromPyobj(x)._ptr,incx,batchCount,
        <float *>hip._util.types.Pointer.fromPyobj(result)._ptr))
    return (_hipblasScnrm2Batched__retval,)


@cython.embedsignature(True)
def hipblasDznrm2Batched(object handle, int n, object x, int incx, int batchCount, object result):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        x (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)

        result (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)
    """
    _hipblasDznrm2Batched__retval = hipblasStatus_t(chipblas.hipblasDznrm2Batched(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,n,
        <chipblas.hipblasDoubleComplex *const*>hip._util.types.Pointer.fromPyobj(x)._ptr,incx,batchCount,
        <double *>hip._util.types.Pointer.fromPyobj(result)._ptr))
    return (_hipblasDznrm2Batched__retval,)


@cython.embedsignature(True)
def hipblasScnrm2Batched_v2(object handle, int n, object x, int incx, int batchCount, object result):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        x (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)

        result (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)
    """
    _hipblasScnrm2Batched_v2__retval = hipblasStatus_t(chipblas.hipblasScnrm2Batched_v2(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,n,
        <chipblas.float2 *const*>hip._util.types.Pointer.fromPyobj(x)._ptr,incx,batchCount,
        <float *>hip._util.types.Pointer.fromPyobj(result)._ptr))
    return (_hipblasScnrm2Batched_v2__retval,)


@cython.embedsignature(True)
def hipblasDznrm2Batched_v2(object handle, int n, object x, int incx, int batchCount, object result):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        x (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)

        result (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)
    """
    _hipblasDznrm2Batched_v2__retval = hipblasStatus_t(chipblas.hipblasDznrm2Batched_v2(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,n,
        <chipblas.double2 *const*>hip._util.types.Pointer.fromPyobj(x)._ptr,incx,batchCount,
        <double *>hip._util.types.Pointer.fromPyobj(result)._ptr))
    return (_hipblasDznrm2Batched_v2__retval,)


@cython.embedsignature(True)
def hipblasSnrm2Batched_64(object handle, long n, object x, long incx, long batchCount, object result):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        x (`~.hip._util.types.ListOfPointer`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)

        result (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)
    """
    _hipblasSnrm2Batched_64__retval = hipblasStatus_t(chipblas.hipblasSnrm2Batched_64(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,n,
        <const float *const*>hip._util.types.ListOfPointer.fromPyobj(x)._ptr,incx,batchCount,
        <float *>hip._util.types.Pointer.fromPyobj(result)._ptr))
    return (_hipblasSnrm2Batched_64__retval,)


@cython.embedsignature(True)
def hipblasDnrm2Batched_64(object handle, long n, object x, long incx, long batchCount, object result):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        x (`~.hip._util.types.ListOfPointer`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)

        result (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)
    """
    _hipblasDnrm2Batched_64__retval = hipblasStatus_t(chipblas.hipblasDnrm2Batched_64(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,n,
        <const double *const*>hip._util.types.ListOfPointer.fromPyobj(x)._ptr,incx,batchCount,
        <double *>hip._util.types.Pointer.fromPyobj(result)._ptr))
    return (_hipblasDnrm2Batched_64__retval,)


@cython.embedsignature(True)
def hipblasScnrm2Batched_64(object handle, long n, object x, long incx, long batchCount, object result):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        x (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)

        result (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)
    """
    _hipblasScnrm2Batched_64__retval = hipblasStatus_t(chipblas.hipblasScnrm2Batched_64(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,n,
        <chipblas.hipblasComplex *const*>hip._util.types.Pointer.fromPyobj(x)._ptr,incx,batchCount,
        <float *>hip._util.types.Pointer.fromPyobj(result)._ptr))
    return (_hipblasScnrm2Batched_64__retval,)


@cython.embedsignature(True)
def hipblasDznrm2Batched_64(object handle, long n, object x, long incx, long batchCount, object result):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        x (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)

        result (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)
    """
    _hipblasDznrm2Batched_64__retval = hipblasStatus_t(chipblas.hipblasDznrm2Batched_64(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,n,
        <chipblas.hipblasDoubleComplex *const*>hip._util.types.Pointer.fromPyobj(x)._ptr,incx,batchCount,
        <double *>hip._util.types.Pointer.fromPyobj(result)._ptr))
    return (_hipblasDznrm2Batched_64__retval,)


@cython.embedsignature(True)
def hipblasScnrm2Batched_v2_64(object handle, long n, object x, long incx, long batchCount, object result):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        x (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)

        result (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)
    """
    _hipblasScnrm2Batched_v2_64__retval = hipblasStatus_t(chipblas.hipblasScnrm2Batched_v2_64(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,n,
        <chipblas.float2 *const*>hip._util.types.Pointer.fromPyobj(x)._ptr,incx,batchCount,
        <float *>hip._util.types.Pointer.fromPyobj(result)._ptr))
    return (_hipblasScnrm2Batched_v2_64__retval,)


@cython.embedsignature(True)
def hipblasDznrm2Batched_v2_64(object handle, long n, object x, long incx, long batchCount, object result):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        x (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)

        result (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)
    """
    _hipblasDznrm2Batched_v2_64__retval = hipblasStatus_t(chipblas.hipblasDznrm2Batched_v2_64(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,n,
        <chipblas.double2 *const*>hip._util.types.Pointer.fromPyobj(x)._ptr,incx,batchCount,
        <double *>hip._util.types.Pointer.fromPyobj(result)._ptr))
    return (_hipblasDznrm2Batched_v2_64__retval,)


@cython.embedsignature(True)
def hipblasSnrm2StridedBatched(object handle, int n, object x, int incx, long stridex, int batchCount, object result):
    r"""BLAS Level 1 API

    @{

    nrm2StridedBatched computes the euclidean norm over a batch of real or complex vectors

    = sqrt( x_i'*x_i ) for real vectors x, for i = 1, ..., batchCount
              := sqrt( x_i**H*x_i ) for complex vectors, for i = 1, ..., batchCount

    - Supported precisions in rocBLAS : s,d,c,z,sc,dz
    - Supported precisions in cuBLAS  : No support

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`) -- *IN*:
            [hipblasHandle_t]
            handle to the hipblas library context queue.

        n (`~.int`) -- *IN*:
            [int]
            number of elements in each x_i.

        x (`~.hip._util.types.Pointer`/`~.object`) -- *IN*:
            device pointer to the first vector x_1.

        incx (`~.int`) -- *IN*:
            [int]
            specifies the increment for the elements of each x_i. incx must be > 0.

        stridex (`~.int`) -- *IN*:
            [hipblasStride]
            stride from the start of one vector (x_i) and the next one (x_i+1).
            There are no restrictions placed on stride_x, however the user should
            take care to ensure that stride_x is of appropriate size, for a typical
            case this means stride_x >= n * incx.

        batchCount (`~.int`) -- *IN*:
            [int]
            number of instances in the batch

        result (`~.hip._util.types.Pointer`/`~.object`) -- *OUT*:
            device pointer or host pointer to array for storing contiguous batchCount results.
            return is 0.0 for each element if n <= 0, incx<=0.
    """
    _hipblasSnrm2StridedBatched__retval = hipblasStatus_t(chipblas.hipblasSnrm2StridedBatched(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,n,
        <const float *>hip._util.types.Pointer.fromPyobj(x)._ptr,incx,stridex,batchCount,
        <float *>hip._util.types.Pointer.fromPyobj(result)._ptr))
    return (_hipblasSnrm2StridedBatched__retval,)


@cython.embedsignature(True)
def hipblasDnrm2StridedBatched(object handle, int n, object x, int incx, long stridex, int batchCount, object result):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        x (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        stridex (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)

        result (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)
    """
    _hipblasDnrm2StridedBatched__retval = hipblasStatus_t(chipblas.hipblasDnrm2StridedBatched(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,n,
        <const double *>hip._util.types.Pointer.fromPyobj(x)._ptr,incx,stridex,batchCount,
        <double *>hip._util.types.Pointer.fromPyobj(result)._ptr))
    return (_hipblasDnrm2StridedBatched__retval,)


@cython.embedsignature(True)
def hipblasScnrm2StridedBatched(object handle, int n, object x, int incx, long stridex, int batchCount, object result):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        x (`~.hipblasComplex`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        stridex (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)

        result (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)
    """
    _hipblasScnrm2StridedBatched__retval = hipblasStatus_t(chipblas.hipblasScnrm2StridedBatched(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,n,
        hipblasComplex.fromPyobj(x).getElementPtr(),incx,stridex,batchCount,
        <float *>hip._util.types.Pointer.fromPyobj(result)._ptr))
    return (_hipblasScnrm2StridedBatched__retval,)


@cython.embedsignature(True)
def hipblasDznrm2StridedBatched(object handle, int n, object x, int incx, long stridex, int batchCount, object result):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        x (`~.hipblasDoubleComplex`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        stridex (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)

        result (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)
    """
    _hipblasDznrm2StridedBatched__retval = hipblasStatus_t(chipblas.hipblasDznrm2StridedBatched(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,n,
        hipblasDoubleComplex.fromPyobj(x).getElementPtr(),incx,stridex,batchCount,
        <double *>hip._util.types.Pointer.fromPyobj(result)._ptr))
    return (_hipblasDznrm2StridedBatched__retval,)


@cython.embedsignature(True)
def hipblasScnrm2StridedBatched_v2(object handle, int n, object x, int incx, long stridex, int batchCount, object result):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        x (`~.float2`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        stridex (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)

        result (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)
    """
    _hipblasScnrm2StridedBatched_v2__retval = hipblasStatus_t(chipblas.hipblasScnrm2StridedBatched_v2(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,n,
        float2.fromPyobj(x).getElementPtr(),incx,stridex,batchCount,
        <float *>hip._util.types.Pointer.fromPyobj(result)._ptr))
    return (_hipblasScnrm2StridedBatched_v2__retval,)


@cython.embedsignature(True)
def hipblasDznrm2StridedBatched_v2(object handle, int n, object x, int incx, long stridex, int batchCount, object result):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        x (`~.double2`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        stridex (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)

        result (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)
    """
    _hipblasDznrm2StridedBatched_v2__retval = hipblasStatus_t(chipblas.hipblasDznrm2StridedBatched_v2(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,n,
        double2.fromPyobj(x).getElementPtr(),incx,stridex,batchCount,
        <double *>hip._util.types.Pointer.fromPyobj(result)._ptr))
    return (_hipblasDznrm2StridedBatched_v2__retval,)


@cython.embedsignature(True)
def hipblasSnrm2StridedBatched_64(object handle, long n, object x, long incx, long stridex, long batchCount, object result):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        x (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        stridex (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)

        result (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)
    """
    _hipblasSnrm2StridedBatched_64__retval = hipblasStatus_t(chipblas.hipblasSnrm2StridedBatched_64(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,n,
        <const float *>hip._util.types.Pointer.fromPyobj(x)._ptr,incx,stridex,batchCount,
        <float *>hip._util.types.Pointer.fromPyobj(result)._ptr))
    return (_hipblasSnrm2StridedBatched_64__retval,)


@cython.embedsignature(True)
def hipblasDnrm2StridedBatched_64(object handle, long n, object x, long incx, long stridex, long batchCount, object result):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        x (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        stridex (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)

        result (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)
    """
    _hipblasDnrm2StridedBatched_64__retval = hipblasStatus_t(chipblas.hipblasDnrm2StridedBatched_64(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,n,
        <const double *>hip._util.types.Pointer.fromPyobj(x)._ptr,incx,stridex,batchCount,
        <double *>hip._util.types.Pointer.fromPyobj(result)._ptr))
    return (_hipblasDnrm2StridedBatched_64__retval,)


@cython.embedsignature(True)
def hipblasScnrm2StridedBatched_64(object handle, long n, object x, long incx, long stridex, long batchCount, object result):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        x (`~.hipblasComplex`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        stridex (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)

        result (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)
    """
    _hipblasScnrm2StridedBatched_64__retval = hipblasStatus_t(chipblas.hipblasScnrm2StridedBatched_64(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,n,
        hipblasComplex.fromPyobj(x).getElementPtr(),incx,stridex,batchCount,
        <float *>hip._util.types.Pointer.fromPyobj(result)._ptr))
    return (_hipblasScnrm2StridedBatched_64__retval,)


@cython.embedsignature(True)
def hipblasDznrm2StridedBatched_64(object handle, long n, object x, long incx, long stridex, long batchCount, object result):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        x (`~.hipblasDoubleComplex`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        stridex (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)

        result (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)
    """
    _hipblasDznrm2StridedBatched_64__retval = hipblasStatus_t(chipblas.hipblasDznrm2StridedBatched_64(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,n,
        hipblasDoubleComplex.fromPyobj(x).getElementPtr(),incx,stridex,batchCount,
        <double *>hip._util.types.Pointer.fromPyobj(result)._ptr))
    return (_hipblasDznrm2StridedBatched_64__retval,)


@cython.embedsignature(True)
def hipblasScnrm2StridedBatched_v2_64(object handle, long n, object x, long incx, long stridex, long batchCount, object result):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        x (`~.float2`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        stridex (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)

        result (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)
    """
    _hipblasScnrm2StridedBatched_v2_64__retval = hipblasStatus_t(chipblas.hipblasScnrm2StridedBatched_v2_64(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,n,
        float2.fromPyobj(x).getElementPtr(),incx,stridex,batchCount,
        <float *>hip._util.types.Pointer.fromPyobj(result)._ptr))
    return (_hipblasScnrm2StridedBatched_v2_64__retval,)


@cython.embedsignature(True)
def hipblasDznrm2StridedBatched_v2_64(object handle, long n, object x, long incx, long stridex, long batchCount, object result):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        x (`~.double2`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        stridex (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)

        result (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)
    """
    _hipblasDznrm2StridedBatched_v2_64__retval = hipblasStatus_t(chipblas.hipblasDznrm2StridedBatched_v2_64(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,n,
        double2.fromPyobj(x).getElementPtr(),incx,stridex,batchCount,
        <double *>hip._util.types.Pointer.fromPyobj(result)._ptr))
    return (_hipblasDznrm2StridedBatched_v2_64__retval,)


@cython.embedsignature(True)
def hipblasSrot(object handle, int n, object x, int incx, object y, int incy, object c, object s):
    r"""BLAS Level 1 API

    @{

    rot applies the Givens rotation matrix defined by c=cos(alpha) and s=sin(alpha) to vectors x and y.
    Scalars c and s may be stored in either host or device memory, location is specified by calling hipblasSetPointerMode.

    - Supported precisions in rocBLAS : s,d,c,z,sc,dz
    - Supported precisions in cuBLAS  : s,d,c,z,cs,zd

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`) -- *IN*:
            [hipblasHandle_t]
            handle to the hipblas library context queue.

        n (`~.int`) -- *IN*:
            [int]
            number of elements in the x and y vectors.

        x (`~.hip._util.types.Pointer`/`~.object`) -- *INOUT*:
            device pointer storing vector x.

        incx (`~.int`) -- *IN*:
            [int]
            specifies the increment between elements of x.

        y (`~.hip._util.types.Pointer`/`~.object`) -- *INOUT*:
            device pointer storing vector y.

        incy (`~.int`) -- *IN*:
            [int]
            specifies the increment between elements of y.

        c (`~.hip._util.types.Pointer`/`~.object`) -- *IN*:
            device pointer or host pointer storing scalar cosine component of the rotation matrix.

        s (`~.hip._util.types.Pointer`/`~.object`) -- *IN*:
            device pointer or host pointer storing scalar sine component of the rotation matrix.
    """
    _hipblasSrot__retval = hipblasStatus_t(chipblas.hipblasSrot(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,n,
        <float *>hip._util.types.Pointer.fromPyobj(x)._ptr,incx,
        <float *>hip._util.types.Pointer.fromPyobj(y)._ptr,incy,
        <const float *>hip._util.types.Pointer.fromPyobj(c)._ptr,
        <const float *>hip._util.types.Pointer.fromPyobj(s)._ptr))
    return (_hipblasSrot__retval,)


@cython.embedsignature(True)
def hipblasDrot(object handle, int n, object x, int incx, object y, int incy, object c, object s):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        x (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        y (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        incy (`~.int`):
            (undocumented)

        c (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        s (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)
    """
    _hipblasDrot__retval = hipblasStatus_t(chipblas.hipblasDrot(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,n,
        <double *>hip._util.types.Pointer.fromPyobj(x)._ptr,incx,
        <double *>hip._util.types.Pointer.fromPyobj(y)._ptr,incy,
        <const double *>hip._util.types.Pointer.fromPyobj(c)._ptr,
        <const double *>hip._util.types.Pointer.fromPyobj(s)._ptr))
    return (_hipblasDrot__retval,)


@cython.embedsignature(True)
def hipblasCrot(object handle, int n, object x, int incx, object y, int incy, object c, object s):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        x (`~.hipblasComplex`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        y (`~.hipblasComplex`/`~.object`):
            (undocumented)

        incy (`~.int`):
            (undocumented)

        c (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        s (`~.hipblasComplex`/`~.object`):
            (undocumented)
    """
    _hipblasCrot__retval = hipblasStatus_t(chipblas.hipblasCrot(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,n,
        hipblasComplex.fromPyobj(x).getElementPtr(),incx,
        hipblasComplex.fromPyobj(y).getElementPtr(),incy,
        <const float *>hip._util.types.Pointer.fromPyobj(c)._ptr,
        hipblasComplex.fromPyobj(s).getElementPtr()))
    return (_hipblasCrot__retval,)


@cython.embedsignature(True)
def hipblasCsrot(object handle, int n, object x, int incx, object y, int incy, object c, object s):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        x (`~.hipblasComplex`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        y (`~.hipblasComplex`/`~.object`):
            (undocumented)

        incy (`~.int`):
            (undocumented)

        c (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        s (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)
    """
    _hipblasCsrot__retval = hipblasStatus_t(chipblas.hipblasCsrot(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,n,
        hipblasComplex.fromPyobj(x).getElementPtr(),incx,
        hipblasComplex.fromPyobj(y).getElementPtr(),incy,
        <const float *>hip._util.types.Pointer.fromPyobj(c)._ptr,
        <const float *>hip._util.types.Pointer.fromPyobj(s)._ptr))
    return (_hipblasCsrot__retval,)


@cython.embedsignature(True)
def hipblasZrot(object handle, int n, object x, int incx, object y, int incy, object c, object s):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        x (`~.hipblasDoubleComplex`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        y (`~.hipblasDoubleComplex`/`~.object`):
            (undocumented)

        incy (`~.int`):
            (undocumented)

        c (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        s (`~.hipblasDoubleComplex`/`~.object`):
            (undocumented)
    """
    _hipblasZrot__retval = hipblasStatus_t(chipblas.hipblasZrot(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,n,
        hipblasDoubleComplex.fromPyobj(x).getElementPtr(),incx,
        hipblasDoubleComplex.fromPyobj(y).getElementPtr(),incy,
        <const double *>hip._util.types.Pointer.fromPyobj(c)._ptr,
        hipblasDoubleComplex.fromPyobj(s).getElementPtr()))
    return (_hipblasZrot__retval,)


@cython.embedsignature(True)
def hipblasZdrot(object handle, int n, object x, int incx, object y, int incy, object c, object s):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        x (`~.hipblasDoubleComplex`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        y (`~.hipblasDoubleComplex`/`~.object`):
            (undocumented)

        incy (`~.int`):
            (undocumented)

        c (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        s (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)
    """
    _hipblasZdrot__retval = hipblasStatus_t(chipblas.hipblasZdrot(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,n,
        hipblasDoubleComplex.fromPyobj(x).getElementPtr(),incx,
        hipblasDoubleComplex.fromPyobj(y).getElementPtr(),incy,
        <const double *>hip._util.types.Pointer.fromPyobj(c)._ptr,
        <const double *>hip._util.types.Pointer.fromPyobj(s)._ptr))
    return (_hipblasZdrot__retval,)


@cython.embedsignature(True)
def hipblasCrot_v2(object handle, int n, object x, int incx, object y, int incy, object c, object s):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        x (`~.float2`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        y (`~.float2`/`~.object`):
            (undocumented)

        incy (`~.int`):
            (undocumented)

        c (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        s (`~.float2`/`~.object`):
            (undocumented)
    """
    _hipblasCrot_v2__retval = hipblasStatus_t(chipblas.hipblasCrot_v2(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,n,
        float2.fromPyobj(x).getElementPtr(),incx,
        float2.fromPyobj(y).getElementPtr(),incy,
        <const float *>hip._util.types.Pointer.fromPyobj(c)._ptr,
        float2.fromPyobj(s).getElementPtr()))
    return (_hipblasCrot_v2__retval,)


@cython.embedsignature(True)
def hipblasCsrot_v2(object handle, int n, object x, int incx, object y, int incy, object c, object s):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        x (`~.float2`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        y (`~.float2`/`~.object`):
            (undocumented)

        incy (`~.int`):
            (undocumented)

        c (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        s (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)
    """
    _hipblasCsrot_v2__retval = hipblasStatus_t(chipblas.hipblasCsrot_v2(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,n,
        float2.fromPyobj(x).getElementPtr(),incx,
        float2.fromPyobj(y).getElementPtr(),incy,
        <const float *>hip._util.types.Pointer.fromPyobj(c)._ptr,
        <const float *>hip._util.types.Pointer.fromPyobj(s)._ptr))
    return (_hipblasCsrot_v2__retval,)


@cython.embedsignature(True)
def hipblasZrot_v2(object handle, int n, object x, int incx, object y, int incy, object c, object s):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        x (`~.double2`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        y (`~.double2`/`~.object`):
            (undocumented)

        incy (`~.int`):
            (undocumented)

        c (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        s (`~.double2`/`~.object`):
            (undocumented)
    """
    _hipblasZrot_v2__retval = hipblasStatus_t(chipblas.hipblasZrot_v2(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,n,
        double2.fromPyobj(x).getElementPtr(),incx,
        double2.fromPyobj(y).getElementPtr(),incy,
        <const double *>hip._util.types.Pointer.fromPyobj(c)._ptr,
        double2.fromPyobj(s).getElementPtr()))
    return (_hipblasZrot_v2__retval,)


@cython.embedsignature(True)
def hipblasZdrot_v2(object handle, int n, object x, int incx, object y, int incy, object c, object s):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        x (`~.double2`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        y (`~.double2`/`~.object`):
            (undocumented)

        incy (`~.int`):
            (undocumented)

        c (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        s (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)
    """
    _hipblasZdrot_v2__retval = hipblasStatus_t(chipblas.hipblasZdrot_v2(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,n,
        double2.fromPyobj(x).getElementPtr(),incx,
        double2.fromPyobj(y).getElementPtr(),incy,
        <const double *>hip._util.types.Pointer.fromPyobj(c)._ptr,
        <const double *>hip._util.types.Pointer.fromPyobj(s)._ptr))
    return (_hipblasZdrot_v2__retval,)


@cython.embedsignature(True)
def hipblasSrot_64(object handle, long n, object x, long incx, object y, long incy, object c, object s):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        x (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        y (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        incy (`~.int`):
            (undocumented)

        c (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        s (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)
    """
    _hipblasSrot_64__retval = hipblasStatus_t(chipblas.hipblasSrot_64(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,n,
        <float *>hip._util.types.Pointer.fromPyobj(x)._ptr,incx,
        <float *>hip._util.types.Pointer.fromPyobj(y)._ptr,incy,
        <const float *>hip._util.types.Pointer.fromPyobj(c)._ptr,
        <const float *>hip._util.types.Pointer.fromPyobj(s)._ptr))
    return (_hipblasSrot_64__retval,)


@cython.embedsignature(True)
def hipblasDrot_64(object handle, long n, object x, long incx, object y, long incy, object c, object s):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        x (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        y (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        incy (`~.int`):
            (undocumented)

        c (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        s (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)
    """
    _hipblasDrot_64__retval = hipblasStatus_t(chipblas.hipblasDrot_64(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,n,
        <double *>hip._util.types.Pointer.fromPyobj(x)._ptr,incx,
        <double *>hip._util.types.Pointer.fromPyobj(y)._ptr,incy,
        <const double *>hip._util.types.Pointer.fromPyobj(c)._ptr,
        <const double *>hip._util.types.Pointer.fromPyobj(s)._ptr))
    return (_hipblasDrot_64__retval,)


@cython.embedsignature(True)
def hipblasCrot_64(object handle, long n, object x, long incx, object y, long incy, object c, object s):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        x (`~.hipblasComplex`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        y (`~.hipblasComplex`/`~.object`):
            (undocumented)

        incy (`~.int`):
            (undocumented)

        c (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        s (`~.hipblasComplex`/`~.object`):
            (undocumented)
    """
    _hipblasCrot_64__retval = hipblasStatus_t(chipblas.hipblasCrot_64(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,n,
        hipblasComplex.fromPyobj(x).getElementPtr(),incx,
        hipblasComplex.fromPyobj(y).getElementPtr(),incy,
        <const float *>hip._util.types.Pointer.fromPyobj(c)._ptr,
        hipblasComplex.fromPyobj(s).getElementPtr()))
    return (_hipblasCrot_64__retval,)


@cython.embedsignature(True)
def hipblasCsrot_64(object handle, long n, object x, long incx, object y, long incy, object c, object s):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        x (`~.hipblasComplex`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        y (`~.hipblasComplex`/`~.object`):
            (undocumented)

        incy (`~.int`):
            (undocumented)

        c (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        s (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)
    """
    _hipblasCsrot_64__retval = hipblasStatus_t(chipblas.hipblasCsrot_64(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,n,
        hipblasComplex.fromPyobj(x).getElementPtr(),incx,
        hipblasComplex.fromPyobj(y).getElementPtr(),incy,
        <const float *>hip._util.types.Pointer.fromPyobj(c)._ptr,
        <const float *>hip._util.types.Pointer.fromPyobj(s)._ptr))
    return (_hipblasCsrot_64__retval,)


@cython.embedsignature(True)
def hipblasZrot_64(object handle, long n, object x, long incx, object y, long incy, object c, object s):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        x (`~.hipblasDoubleComplex`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        y (`~.hipblasDoubleComplex`/`~.object`):
            (undocumented)

        incy (`~.int`):
            (undocumented)

        c (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        s (`~.hipblasDoubleComplex`/`~.object`):
            (undocumented)
    """
    _hipblasZrot_64__retval = hipblasStatus_t(chipblas.hipblasZrot_64(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,n,
        hipblasDoubleComplex.fromPyobj(x).getElementPtr(),incx,
        hipblasDoubleComplex.fromPyobj(y).getElementPtr(),incy,
        <const double *>hip._util.types.Pointer.fromPyobj(c)._ptr,
        hipblasDoubleComplex.fromPyobj(s).getElementPtr()))
    return (_hipblasZrot_64__retval,)


@cython.embedsignature(True)
def hipblasZdrot_64(object handle, long n, object x, long incx, object y, long incy, object c, object s):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        x (`~.hipblasDoubleComplex`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        y (`~.hipblasDoubleComplex`/`~.object`):
            (undocumented)

        incy (`~.int`):
            (undocumented)

        c (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        s (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)
    """
    _hipblasZdrot_64__retval = hipblasStatus_t(chipblas.hipblasZdrot_64(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,n,
        hipblasDoubleComplex.fromPyobj(x).getElementPtr(),incx,
        hipblasDoubleComplex.fromPyobj(y).getElementPtr(),incy,
        <const double *>hip._util.types.Pointer.fromPyobj(c)._ptr,
        <const double *>hip._util.types.Pointer.fromPyobj(s)._ptr))
    return (_hipblasZdrot_64__retval,)


@cython.embedsignature(True)
def hipblasCrot_v2_64(object handle, long n, object x, long incx, object y, long incy, object c, object s):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        x (`~.float2`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        y (`~.float2`/`~.object`):
            (undocumented)

        incy (`~.int`):
            (undocumented)

        c (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        s (`~.float2`/`~.object`):
            (undocumented)
    """
    _hipblasCrot_v2_64__retval = hipblasStatus_t(chipblas.hipblasCrot_v2_64(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,n,
        float2.fromPyobj(x).getElementPtr(),incx,
        float2.fromPyobj(y).getElementPtr(),incy,
        <const float *>hip._util.types.Pointer.fromPyobj(c)._ptr,
        float2.fromPyobj(s).getElementPtr()))
    return (_hipblasCrot_v2_64__retval,)


@cython.embedsignature(True)
def hipblasCsrot_v2_64(object handle, long n, object x, long incx, object y, long incy, object c, object s):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        x (`~.float2`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        y (`~.float2`/`~.object`):
            (undocumented)

        incy (`~.int`):
            (undocumented)

        c (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        s (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)
    """
    _hipblasCsrot_v2_64__retval = hipblasStatus_t(chipblas.hipblasCsrot_v2_64(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,n,
        float2.fromPyobj(x).getElementPtr(),incx,
        float2.fromPyobj(y).getElementPtr(),incy,
        <const float *>hip._util.types.Pointer.fromPyobj(c)._ptr,
        <const float *>hip._util.types.Pointer.fromPyobj(s)._ptr))
    return (_hipblasCsrot_v2_64__retval,)


@cython.embedsignature(True)
def hipblasZrot_v2_64(object handle, long n, object x, long incx, object y, long incy, object c, object s):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        x (`~.double2`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        y (`~.double2`/`~.object`):
            (undocumented)

        incy (`~.int`):
            (undocumented)

        c (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        s (`~.double2`/`~.object`):
            (undocumented)
    """
    _hipblasZrot_v2_64__retval = hipblasStatus_t(chipblas.hipblasZrot_v2_64(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,n,
        double2.fromPyobj(x).getElementPtr(),incx,
        double2.fromPyobj(y).getElementPtr(),incy,
        <const double *>hip._util.types.Pointer.fromPyobj(c)._ptr,
        double2.fromPyobj(s).getElementPtr()))
    return (_hipblasZrot_v2_64__retval,)


@cython.embedsignature(True)
def hipblasZdrot_v2_64(object handle, long n, object x, long incx, object y, long incy, object c, object s):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        x (`~.double2`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        y (`~.double2`/`~.object`):
            (undocumented)

        incy (`~.int`):
            (undocumented)

        c (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        s (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)
    """
    _hipblasZdrot_v2_64__retval = hipblasStatus_t(chipblas.hipblasZdrot_v2_64(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,n,
        double2.fromPyobj(x).getElementPtr(),incx,
        double2.fromPyobj(y).getElementPtr(),incy,
        <const double *>hip._util.types.Pointer.fromPyobj(c)._ptr,
        <const double *>hip._util.types.Pointer.fromPyobj(s)._ptr))
    return (_hipblasZdrot_v2_64__retval,)


@cython.embedsignature(True)
def hipblasSrotBatched(object handle, int n, object x, int incx, object y, int incy, object c, object s, int batchCount):
    r"""BLAS Level 1 API

    @{

    rotBatched applies the Givens rotation matrix defined by c=cos(alpha) and s=sin(alpha) to batched vectors x_i and y_i, for i = 1, ..., batchCount.
    Scalars c and s may be stored in either host or device memory, location is specified by calling hipblasSetPointerMode.

    - Supported precisions in rocBLAS : s,d,sc,dz
    - Supported precisions in cuBLAS  : No support

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`) -- *IN*:
            [hipblasHandle_t]
            handle to the hipblas library context queue.

        n (`~.int`) -- *IN*:
            [int]
            number of elements in each x_i and y_i vectors.

        x (`~.hip._util.types.ListOfPointer`/`~.object`) -- *INOUT*:
            device array of device pointers storing each vector x_i.

        incx (`~.int`) -- *IN*:
            [int]
            specifies the increment between elements of each x_i.

        y (`~.hip._util.types.ListOfPointer`/`~.object`) -- *INOUT*:
            device array of device pointers storing each vector y_i.

        incy (`~.int`) -- *IN*:
            [int]
            specifies the increment between elements of each y_i.

        c (`~.hip._util.types.Pointer`/`~.object`) -- *IN*:
            device pointer or host pointer to scalar cosine component of the rotation matrix.

        s (`~.hip._util.types.Pointer`/`~.object`) -- *IN*:
            device pointer or host pointer to scalar sine component of the rotation matrix.

        batchCount (`~.int`) -- *IN*:
            [int]
            the number of x and y arrays, i.e. the number of batches.
    """
    _hipblasSrotBatched__retval = hipblasStatus_t(chipblas.hipblasSrotBatched(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,n,
        <float *const*>hip._util.types.ListOfPointer.fromPyobj(x)._ptr,incx,
        <float *const*>hip._util.types.ListOfPointer.fromPyobj(y)._ptr,incy,
        <const float *>hip._util.types.Pointer.fromPyobj(c)._ptr,
        <const float *>hip._util.types.Pointer.fromPyobj(s)._ptr,batchCount))
    return (_hipblasSrotBatched__retval,)


@cython.embedsignature(True)
def hipblasDrotBatched(object handle, int n, object x, int incx, object y, int incy, object c, object s, int batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        x (`~.hip._util.types.ListOfPointer`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        y (`~.hip._util.types.ListOfPointer`/`~.object`):
            (undocumented)

        incy (`~.int`):
            (undocumented)

        c (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        s (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    _hipblasDrotBatched__retval = hipblasStatus_t(chipblas.hipblasDrotBatched(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,n,
        <double *const*>hip._util.types.ListOfPointer.fromPyobj(x)._ptr,incx,
        <double *const*>hip._util.types.ListOfPointer.fromPyobj(y)._ptr,incy,
        <const double *>hip._util.types.Pointer.fromPyobj(c)._ptr,
        <const double *>hip._util.types.Pointer.fromPyobj(s)._ptr,batchCount))
    return (_hipblasDrotBatched__retval,)


@cython.embedsignature(True)
def hipblasCrotBatched(object handle, int n, object x, int incx, object y, int incy, object c, object s, int batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        x (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        y (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        incy (`~.int`):
            (undocumented)

        c (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        s (`~.hipblasComplex`/`~.object`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    _hipblasCrotBatched__retval = hipblasStatus_t(chipblas.hipblasCrotBatched(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,n,
        <chipblas.hipblasComplex *const*>hip._util.types.Pointer.fromPyobj(x)._ptr,incx,
        <chipblas.hipblasComplex *const*>hip._util.types.Pointer.fromPyobj(y)._ptr,incy,
        <const float *>hip._util.types.Pointer.fromPyobj(c)._ptr,
        hipblasComplex.fromPyobj(s).getElementPtr(),batchCount))
    return (_hipblasCrotBatched__retval,)


@cython.embedsignature(True)
def hipblasCsrotBatched(object handle, int n, object x, int incx, object y, int incy, object c, object s, int batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        x (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        y (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        incy (`~.int`):
            (undocumented)

        c (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        s (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    _hipblasCsrotBatched__retval = hipblasStatus_t(chipblas.hipblasCsrotBatched(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,n,
        <chipblas.hipblasComplex *const*>hip._util.types.Pointer.fromPyobj(x)._ptr,incx,
        <chipblas.hipblasComplex *const*>hip._util.types.Pointer.fromPyobj(y)._ptr,incy,
        <const float *>hip._util.types.Pointer.fromPyobj(c)._ptr,
        <const float *>hip._util.types.Pointer.fromPyobj(s)._ptr,batchCount))
    return (_hipblasCsrotBatched__retval,)


@cython.embedsignature(True)
def hipblasZrotBatched(object handle, int n, object x, int incx, object y, int incy, object c, object s, int batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        x (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        y (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        incy (`~.int`):
            (undocumented)

        c (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        s (`~.hipblasDoubleComplex`/`~.object`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    _hipblasZrotBatched__retval = hipblasStatus_t(chipblas.hipblasZrotBatched(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,n,
        <chipblas.hipblasDoubleComplex *const*>hip._util.types.Pointer.fromPyobj(x)._ptr,incx,
        <chipblas.hipblasDoubleComplex *const*>hip._util.types.Pointer.fromPyobj(y)._ptr,incy,
        <const double *>hip._util.types.Pointer.fromPyobj(c)._ptr,
        hipblasDoubleComplex.fromPyobj(s).getElementPtr(),batchCount))
    return (_hipblasZrotBatched__retval,)


@cython.embedsignature(True)
def hipblasZdrotBatched(object handle, int n, object x, int incx, object y, int incy, object c, object s, int batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        x (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        y (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        incy (`~.int`):
            (undocumented)

        c (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        s (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    _hipblasZdrotBatched__retval = hipblasStatus_t(chipblas.hipblasZdrotBatched(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,n,
        <chipblas.hipblasDoubleComplex *const*>hip._util.types.Pointer.fromPyobj(x)._ptr,incx,
        <chipblas.hipblasDoubleComplex *const*>hip._util.types.Pointer.fromPyobj(y)._ptr,incy,
        <const double *>hip._util.types.Pointer.fromPyobj(c)._ptr,
        <const double *>hip._util.types.Pointer.fromPyobj(s)._ptr,batchCount))
    return (_hipblasZdrotBatched__retval,)


@cython.embedsignature(True)
def hipblasCrotBatched_v2(object handle, int n, object x, int incx, object y, int incy, object c, object s, int batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        x (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        y (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        incy (`~.int`):
            (undocumented)

        c (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        s (`~.float2`/`~.object`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    _hipblasCrotBatched_v2__retval = hipblasStatus_t(chipblas.hipblasCrotBatched_v2(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,n,
        <chipblas.float2 *const*>hip._util.types.Pointer.fromPyobj(x)._ptr,incx,
        <chipblas.float2 *const*>hip._util.types.Pointer.fromPyobj(y)._ptr,incy,
        <const float *>hip._util.types.Pointer.fromPyobj(c)._ptr,
        float2.fromPyobj(s).getElementPtr(),batchCount))
    return (_hipblasCrotBatched_v2__retval,)


@cython.embedsignature(True)
def hipblasCsrotBatched_v2(object handle, int n, object x, int incx, object y, int incy, object c, object s, int batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        x (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        y (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        incy (`~.int`):
            (undocumented)

        c (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        s (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    _hipblasCsrotBatched_v2__retval = hipblasStatus_t(chipblas.hipblasCsrotBatched_v2(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,n,
        <chipblas.float2 *const*>hip._util.types.Pointer.fromPyobj(x)._ptr,incx,
        <chipblas.float2 *const*>hip._util.types.Pointer.fromPyobj(y)._ptr,incy,
        <const float *>hip._util.types.Pointer.fromPyobj(c)._ptr,
        <const float *>hip._util.types.Pointer.fromPyobj(s)._ptr,batchCount))
    return (_hipblasCsrotBatched_v2__retval,)


@cython.embedsignature(True)
def hipblasZrotBatched_v2(object handle, int n, object x, int incx, object y, int incy, object c, object s, int batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        x (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        y (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        incy (`~.int`):
            (undocumented)

        c (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        s (`~.double2`/`~.object`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    _hipblasZrotBatched_v2__retval = hipblasStatus_t(chipblas.hipblasZrotBatched_v2(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,n,
        <chipblas.double2 *const*>hip._util.types.Pointer.fromPyobj(x)._ptr,incx,
        <chipblas.double2 *const*>hip._util.types.Pointer.fromPyobj(y)._ptr,incy,
        <const double *>hip._util.types.Pointer.fromPyobj(c)._ptr,
        double2.fromPyobj(s).getElementPtr(),batchCount))
    return (_hipblasZrotBatched_v2__retval,)


@cython.embedsignature(True)
def hipblasZdrotBatched_v2(object handle, int n, object x, int incx, object y, int incy, object c, object s, int batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        x (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        y (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        incy (`~.int`):
            (undocumented)

        c (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        s (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    _hipblasZdrotBatched_v2__retval = hipblasStatus_t(chipblas.hipblasZdrotBatched_v2(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,n,
        <chipblas.double2 *const*>hip._util.types.Pointer.fromPyobj(x)._ptr,incx,
        <chipblas.double2 *const*>hip._util.types.Pointer.fromPyobj(y)._ptr,incy,
        <const double *>hip._util.types.Pointer.fromPyobj(c)._ptr,
        <const double *>hip._util.types.Pointer.fromPyobj(s)._ptr,batchCount))
    return (_hipblasZdrotBatched_v2__retval,)


@cython.embedsignature(True)
def hipblasSrotBatched_64(object handle, long n, object x, long incx, object y, long incy, object c, object s, long batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        x (`~.hip._util.types.ListOfPointer`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        y (`~.hip._util.types.ListOfPointer`/`~.object`):
            (undocumented)

        incy (`~.int`):
            (undocumented)

        c (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        s (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    _hipblasSrotBatched_64__retval = hipblasStatus_t(chipblas.hipblasSrotBatched_64(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,n,
        <float *const*>hip._util.types.ListOfPointer.fromPyobj(x)._ptr,incx,
        <float *const*>hip._util.types.ListOfPointer.fromPyobj(y)._ptr,incy,
        <const float *>hip._util.types.Pointer.fromPyobj(c)._ptr,
        <const float *>hip._util.types.Pointer.fromPyobj(s)._ptr,batchCount))
    return (_hipblasSrotBatched_64__retval,)


@cython.embedsignature(True)
def hipblasDrotBatched_64(object handle, long n, object x, long incx, object y, long incy, object c, object s, long batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        x (`~.hip._util.types.ListOfPointer`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        y (`~.hip._util.types.ListOfPointer`/`~.object`):
            (undocumented)

        incy (`~.int`):
            (undocumented)

        c (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        s (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    _hipblasDrotBatched_64__retval = hipblasStatus_t(chipblas.hipblasDrotBatched_64(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,n,
        <double *const*>hip._util.types.ListOfPointer.fromPyobj(x)._ptr,incx,
        <double *const*>hip._util.types.ListOfPointer.fromPyobj(y)._ptr,incy,
        <const double *>hip._util.types.Pointer.fromPyobj(c)._ptr,
        <const double *>hip._util.types.Pointer.fromPyobj(s)._ptr,batchCount))
    return (_hipblasDrotBatched_64__retval,)


@cython.embedsignature(True)
def hipblasCrotBatched_64(object handle, long n, object x, long incx, object y, long incy, object c, object s, long batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        x (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        y (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        incy (`~.int`):
            (undocumented)

        c (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        s (`~.hipblasComplex`/`~.object`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    _hipblasCrotBatched_64__retval = hipblasStatus_t(chipblas.hipblasCrotBatched_64(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,n,
        <chipblas.hipblasComplex *const*>hip._util.types.Pointer.fromPyobj(x)._ptr,incx,
        <chipblas.hipblasComplex *const*>hip._util.types.Pointer.fromPyobj(y)._ptr,incy,
        <const float *>hip._util.types.Pointer.fromPyobj(c)._ptr,
        hipblasComplex.fromPyobj(s).getElementPtr(),batchCount))
    return (_hipblasCrotBatched_64__retval,)


@cython.embedsignature(True)
def hipblasCsrotBatched_64(object handle, long n, object x, long incx, object y, long incy, object c, object s, long batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        x (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        y (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        incy (`~.int`):
            (undocumented)

        c (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        s (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    _hipblasCsrotBatched_64__retval = hipblasStatus_t(chipblas.hipblasCsrotBatched_64(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,n,
        <chipblas.hipblasComplex *const*>hip._util.types.Pointer.fromPyobj(x)._ptr,incx,
        <chipblas.hipblasComplex *const*>hip._util.types.Pointer.fromPyobj(y)._ptr,incy,
        <const float *>hip._util.types.Pointer.fromPyobj(c)._ptr,
        <const float *>hip._util.types.Pointer.fromPyobj(s)._ptr,batchCount))
    return (_hipblasCsrotBatched_64__retval,)


@cython.embedsignature(True)
def hipblasZrotBatched_64(object handle, long n, object x, long incx, object y, long incy, object c, object s, long batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        x (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        y (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        incy (`~.int`):
            (undocumented)

        c (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        s (`~.hipblasDoubleComplex`/`~.object`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    _hipblasZrotBatched_64__retval = hipblasStatus_t(chipblas.hipblasZrotBatched_64(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,n,
        <chipblas.hipblasDoubleComplex *const*>hip._util.types.Pointer.fromPyobj(x)._ptr,incx,
        <chipblas.hipblasDoubleComplex *const*>hip._util.types.Pointer.fromPyobj(y)._ptr,incy,
        <const double *>hip._util.types.Pointer.fromPyobj(c)._ptr,
        hipblasDoubleComplex.fromPyobj(s).getElementPtr(),batchCount))
    return (_hipblasZrotBatched_64__retval,)


@cython.embedsignature(True)
def hipblasZdrotBatched_64(object handle, long n, object x, long incx, object y, long incy, object c, object s, long batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        x (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        y (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        incy (`~.int`):
            (undocumented)

        c (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        s (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    _hipblasZdrotBatched_64__retval = hipblasStatus_t(chipblas.hipblasZdrotBatched_64(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,n,
        <chipblas.hipblasDoubleComplex *const*>hip._util.types.Pointer.fromPyobj(x)._ptr,incx,
        <chipblas.hipblasDoubleComplex *const*>hip._util.types.Pointer.fromPyobj(y)._ptr,incy,
        <const double *>hip._util.types.Pointer.fromPyobj(c)._ptr,
        <const double *>hip._util.types.Pointer.fromPyobj(s)._ptr,batchCount))
    return (_hipblasZdrotBatched_64__retval,)


@cython.embedsignature(True)
def hipblasCrotBatched_v2_64(object handle, long n, object x, long incx, object y, long incy, object c, object s, long batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        x (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        y (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        incy (`~.int`):
            (undocumented)

        c (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        s (`~.float2`/`~.object`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    _hipblasCrotBatched_v2_64__retval = hipblasStatus_t(chipblas.hipblasCrotBatched_v2_64(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,n,
        <chipblas.float2 *const*>hip._util.types.Pointer.fromPyobj(x)._ptr,incx,
        <chipblas.float2 *const*>hip._util.types.Pointer.fromPyobj(y)._ptr,incy,
        <const float *>hip._util.types.Pointer.fromPyobj(c)._ptr,
        float2.fromPyobj(s).getElementPtr(),batchCount))
    return (_hipblasCrotBatched_v2_64__retval,)


@cython.embedsignature(True)
def hipblasCsrotBatched_v2_64(object handle, long n, object x, long incx, object y, long incy, object c, object s, long batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        x (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        y (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        incy (`~.int`):
            (undocumented)

        c (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        s (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    _hipblasCsrotBatched_v2_64__retval = hipblasStatus_t(chipblas.hipblasCsrotBatched_v2_64(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,n,
        <chipblas.float2 *const*>hip._util.types.Pointer.fromPyobj(x)._ptr,incx,
        <chipblas.float2 *const*>hip._util.types.Pointer.fromPyobj(y)._ptr,incy,
        <const float *>hip._util.types.Pointer.fromPyobj(c)._ptr,
        <const float *>hip._util.types.Pointer.fromPyobj(s)._ptr,batchCount))
    return (_hipblasCsrotBatched_v2_64__retval,)


@cython.embedsignature(True)
def hipblasZrotBatched_v2_64(object handle, long n, object x, long incx, object y, long incy, object c, object s, long batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        x (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        y (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        incy (`~.int`):
            (undocumented)

        c (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        s (`~.double2`/`~.object`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    _hipblasZrotBatched_v2_64__retval = hipblasStatus_t(chipblas.hipblasZrotBatched_v2_64(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,n,
        <chipblas.double2 *const*>hip._util.types.Pointer.fromPyobj(x)._ptr,incx,
        <chipblas.double2 *const*>hip._util.types.Pointer.fromPyobj(y)._ptr,incy,
        <const double *>hip._util.types.Pointer.fromPyobj(c)._ptr,
        double2.fromPyobj(s).getElementPtr(),batchCount))
    return (_hipblasZrotBatched_v2_64__retval,)


@cython.embedsignature(True)
def hipblasZdrotBatched_v2_64(object handle, long n, object x, long incx, object y, long incy, object c, object s, long batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        x (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        y (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        incy (`~.int`):
            (undocumented)

        c (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        s (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    _hipblasZdrotBatched_v2_64__retval = hipblasStatus_t(chipblas.hipblasZdrotBatched_v2_64(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,n,
        <chipblas.double2 *const*>hip._util.types.Pointer.fromPyobj(x)._ptr,incx,
        <chipblas.double2 *const*>hip._util.types.Pointer.fromPyobj(y)._ptr,incy,
        <const double *>hip._util.types.Pointer.fromPyobj(c)._ptr,
        <const double *>hip._util.types.Pointer.fromPyobj(s)._ptr,batchCount))
    return (_hipblasZdrotBatched_v2_64__retval,)


@cython.embedsignature(True)
def hipblasSrotStridedBatched(object handle, int n, object x, int incx, long stridex, object y, int incy, long stridey, object c, object s, int batchCount):
    r"""BLAS Level 1 API

    @{

    rotStridedBatched applies the Givens rotation matrix defined by c=cos(alpha) and s=sin(alpha) to strided batched vectors x_i and y_i, for i = 1, ..., batchCount.
    Scalars c and s may be stored in either host or device memory, location is specified by calling hipblasSetPointerMode.

    - Supported precisions in rocBLAS : s,d,sc,dz
    - Supported precisions in cuBLAS  : No support

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`) -- *IN*:
            [hipblasHandle_t]
            handle to the hipblas library context queue.

        n (`~.int`) -- *IN*:
            [int]
            number of elements in each x_i and y_i vectors.

        x (`~.hip._util.types.Pointer`/`~.object`) -- *INOUT*:
            device pointer to the first vector x_1.

        incx (`~.int`) -- *IN*:
            [int]
            specifies the increment between elements of each x_i.

        stridex (`~.int`) -- *IN*:
            [hipblasStride]
            specifies the increment from the beginning of x_i to the beginning of x_(i+1)

        y (`~.hip._util.types.Pointer`/`~.object`) -- *INOUT*:
            device pointer to the first vector y_1.

        incy (`~.int`) -- *IN*:
            [int]
            specifies the increment between elements of each y_i.

        stridey (`~.int`) -- *IN*:
            [hipblasStride]
            specifies the increment from the beginning of y_i to the beginning of y_(i+1)

        c (`~.hip._util.types.Pointer`/`~.object`) -- *IN*:
            device pointer or host pointer to scalar cosine component of the rotation matrix.

        s (`~.hip._util.types.Pointer`/`~.object`) -- *IN*:
            device pointer or host pointer to scalar sine component of the rotation matrix.

        batchCount (`~.int`) -- *IN*:
            [int]
            the number of x and y arrays, i.e. the number of batches.
    """
    _hipblasSrotStridedBatched__retval = hipblasStatus_t(chipblas.hipblasSrotStridedBatched(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,n,
        <float *>hip._util.types.Pointer.fromPyobj(x)._ptr,incx,stridex,
        <float *>hip._util.types.Pointer.fromPyobj(y)._ptr,incy,stridey,
        <const float *>hip._util.types.Pointer.fromPyobj(c)._ptr,
        <const float *>hip._util.types.Pointer.fromPyobj(s)._ptr,batchCount))
    return (_hipblasSrotStridedBatched__retval,)


@cython.embedsignature(True)
def hipblasDrotStridedBatched(object handle, int n, object x, int incx, long stridex, object y, int incy, long stridey, object c, object s, int batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        x (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        stridex (`~.int`):
            (undocumented)

        y (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        incy (`~.int`):
            (undocumented)

        stridey (`~.int`):
            (undocumented)

        c (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        s (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    _hipblasDrotStridedBatched__retval = hipblasStatus_t(chipblas.hipblasDrotStridedBatched(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,n,
        <double *>hip._util.types.Pointer.fromPyobj(x)._ptr,incx,stridex,
        <double *>hip._util.types.Pointer.fromPyobj(y)._ptr,incy,stridey,
        <const double *>hip._util.types.Pointer.fromPyobj(c)._ptr,
        <const double *>hip._util.types.Pointer.fromPyobj(s)._ptr,batchCount))
    return (_hipblasDrotStridedBatched__retval,)


@cython.embedsignature(True)
def hipblasCrotStridedBatched(object handle, int n, object x, int incx, long stridex, object y, int incy, long stridey, object c, object s, int batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        x (`~.hipblasComplex`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        stridex (`~.int`):
            (undocumented)

        y (`~.hipblasComplex`/`~.object`):
            (undocumented)

        incy (`~.int`):
            (undocumented)

        stridey (`~.int`):
            (undocumented)

        c (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        s (`~.hipblasComplex`/`~.object`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    _hipblasCrotStridedBatched__retval = hipblasStatus_t(chipblas.hipblasCrotStridedBatched(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,n,
        hipblasComplex.fromPyobj(x).getElementPtr(),incx,stridex,
        hipblasComplex.fromPyobj(y).getElementPtr(),incy,stridey,
        <const float *>hip._util.types.Pointer.fromPyobj(c)._ptr,
        hipblasComplex.fromPyobj(s).getElementPtr(),batchCount))
    return (_hipblasCrotStridedBatched__retval,)


@cython.embedsignature(True)
def hipblasCsrotStridedBatched(object handle, int n, object x, int incx, long stridex, object y, int incy, long stridey, object c, object s, int batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        x (`~.hipblasComplex`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        stridex (`~.int`):
            (undocumented)

        y (`~.hipblasComplex`/`~.object`):
            (undocumented)

        incy (`~.int`):
            (undocumented)

        stridey (`~.int`):
            (undocumented)

        c (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        s (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    _hipblasCsrotStridedBatched__retval = hipblasStatus_t(chipblas.hipblasCsrotStridedBatched(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,n,
        hipblasComplex.fromPyobj(x).getElementPtr(),incx,stridex,
        hipblasComplex.fromPyobj(y).getElementPtr(),incy,stridey,
        <const float *>hip._util.types.Pointer.fromPyobj(c)._ptr,
        <const float *>hip._util.types.Pointer.fromPyobj(s)._ptr,batchCount))
    return (_hipblasCsrotStridedBatched__retval,)


@cython.embedsignature(True)
def hipblasZrotStridedBatched(object handle, int n, object x, int incx, long stridex, object y, int incy, long stridey, object c, object s, int batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        x (`~.hipblasDoubleComplex`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        stridex (`~.int`):
            (undocumented)

        y (`~.hipblasDoubleComplex`/`~.object`):
            (undocumented)

        incy (`~.int`):
            (undocumented)

        stridey (`~.int`):
            (undocumented)

        c (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        s (`~.hipblasDoubleComplex`/`~.object`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    _hipblasZrotStridedBatched__retval = hipblasStatus_t(chipblas.hipblasZrotStridedBatched(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,n,
        hipblasDoubleComplex.fromPyobj(x).getElementPtr(),incx,stridex,
        hipblasDoubleComplex.fromPyobj(y).getElementPtr(),incy,stridey,
        <const double *>hip._util.types.Pointer.fromPyobj(c)._ptr,
        hipblasDoubleComplex.fromPyobj(s).getElementPtr(),batchCount))
    return (_hipblasZrotStridedBatched__retval,)


@cython.embedsignature(True)
def hipblasZdrotStridedBatched(object handle, int n, object x, int incx, long stridex, object y, int incy, long stridey, object c, object s, int batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        x (`~.hipblasDoubleComplex`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        stridex (`~.int`):
            (undocumented)

        y (`~.hipblasDoubleComplex`/`~.object`):
            (undocumented)

        incy (`~.int`):
            (undocumented)

        stridey (`~.int`):
            (undocumented)

        c (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        s (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    _hipblasZdrotStridedBatched__retval = hipblasStatus_t(chipblas.hipblasZdrotStridedBatched(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,n,
        hipblasDoubleComplex.fromPyobj(x).getElementPtr(),incx,stridex,
        hipblasDoubleComplex.fromPyobj(y).getElementPtr(),incy,stridey,
        <const double *>hip._util.types.Pointer.fromPyobj(c)._ptr,
        <const double *>hip._util.types.Pointer.fromPyobj(s)._ptr,batchCount))
    return (_hipblasZdrotStridedBatched__retval,)


@cython.embedsignature(True)
def hipblasCrotStridedBatched_v2(object handle, int n, object x, int incx, long stridex, object y, int incy, long stridey, object c, object s, int batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        x (`~.float2`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        stridex (`~.int`):
            (undocumented)

        y (`~.float2`/`~.object`):
            (undocumented)

        incy (`~.int`):
            (undocumented)

        stridey (`~.int`):
            (undocumented)

        c (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        s (`~.float2`/`~.object`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    _hipblasCrotStridedBatched_v2__retval = hipblasStatus_t(chipblas.hipblasCrotStridedBatched_v2(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,n,
        float2.fromPyobj(x).getElementPtr(),incx,stridex,
        float2.fromPyobj(y).getElementPtr(),incy,stridey,
        <const float *>hip._util.types.Pointer.fromPyobj(c)._ptr,
        float2.fromPyobj(s).getElementPtr(),batchCount))
    return (_hipblasCrotStridedBatched_v2__retval,)


@cython.embedsignature(True)
def hipblasCsrotStridedBatched_v2(object handle, int n, object x, int incx, long stridex, object y, int incy, long stridey, object c, object s, int batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        x (`~.float2`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        stridex (`~.int`):
            (undocumented)

        y (`~.float2`/`~.object`):
            (undocumented)

        incy (`~.int`):
            (undocumented)

        stridey (`~.int`):
            (undocumented)

        c (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        s (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    _hipblasCsrotStridedBatched_v2__retval = hipblasStatus_t(chipblas.hipblasCsrotStridedBatched_v2(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,n,
        float2.fromPyobj(x).getElementPtr(),incx,stridex,
        float2.fromPyobj(y).getElementPtr(),incy,stridey,
        <const float *>hip._util.types.Pointer.fromPyobj(c)._ptr,
        <const float *>hip._util.types.Pointer.fromPyobj(s)._ptr,batchCount))
    return (_hipblasCsrotStridedBatched_v2__retval,)


@cython.embedsignature(True)
def hipblasZrotStridedBatched_v2(object handle, int n, object x, int incx, long stridex, object y, int incy, long stridey, object c, object s, int batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        x (`~.double2`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        stridex (`~.int`):
            (undocumented)

        y (`~.double2`/`~.object`):
            (undocumented)

        incy (`~.int`):
            (undocumented)

        stridey (`~.int`):
            (undocumented)

        c (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        s (`~.double2`/`~.object`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    _hipblasZrotStridedBatched_v2__retval = hipblasStatus_t(chipblas.hipblasZrotStridedBatched_v2(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,n,
        double2.fromPyobj(x).getElementPtr(),incx,stridex,
        double2.fromPyobj(y).getElementPtr(),incy,stridey,
        <const double *>hip._util.types.Pointer.fromPyobj(c)._ptr,
        double2.fromPyobj(s).getElementPtr(),batchCount))
    return (_hipblasZrotStridedBatched_v2__retval,)


@cython.embedsignature(True)
def hipblasZdrotStridedBatched_v2(object handle, int n, object x, int incx, long stridex, object y, int incy, long stridey, object c, object s, int batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        x (`~.double2`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        stridex (`~.int`):
            (undocumented)

        y (`~.double2`/`~.object`):
            (undocumented)

        incy (`~.int`):
            (undocumented)

        stridey (`~.int`):
            (undocumented)

        c (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        s (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    _hipblasZdrotStridedBatched_v2__retval = hipblasStatus_t(chipblas.hipblasZdrotStridedBatched_v2(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,n,
        double2.fromPyobj(x).getElementPtr(),incx,stridex,
        double2.fromPyobj(y).getElementPtr(),incy,stridey,
        <const double *>hip._util.types.Pointer.fromPyobj(c)._ptr,
        <const double *>hip._util.types.Pointer.fromPyobj(s)._ptr,batchCount))
    return (_hipblasZdrotStridedBatched_v2__retval,)


@cython.embedsignature(True)
def hipblasSrotStridedBatched_64(object handle, long n, object x, long incx, long stridex, object y, long incy, long stridey, object c, object s, long batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        x (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        stridex (`~.int`):
            (undocumented)

        y (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        incy (`~.int`):
            (undocumented)

        stridey (`~.int`):
            (undocumented)

        c (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        s (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    _hipblasSrotStridedBatched_64__retval = hipblasStatus_t(chipblas.hipblasSrotStridedBatched_64(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,n,
        <float *>hip._util.types.Pointer.fromPyobj(x)._ptr,incx,stridex,
        <float *>hip._util.types.Pointer.fromPyobj(y)._ptr,incy,stridey,
        <const float *>hip._util.types.Pointer.fromPyobj(c)._ptr,
        <const float *>hip._util.types.Pointer.fromPyobj(s)._ptr,batchCount))
    return (_hipblasSrotStridedBatched_64__retval,)


@cython.embedsignature(True)
def hipblasDrotStridedBatched_64(object handle, long n, object x, long incx, long stridex, object y, long incy, long stridey, object c, object s, long batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        x (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        stridex (`~.int`):
            (undocumented)

        y (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        incy (`~.int`):
            (undocumented)

        stridey (`~.int`):
            (undocumented)

        c (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        s (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    _hipblasDrotStridedBatched_64__retval = hipblasStatus_t(chipblas.hipblasDrotStridedBatched_64(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,n,
        <double *>hip._util.types.Pointer.fromPyobj(x)._ptr,incx,stridex,
        <double *>hip._util.types.Pointer.fromPyobj(y)._ptr,incy,stridey,
        <const double *>hip._util.types.Pointer.fromPyobj(c)._ptr,
        <const double *>hip._util.types.Pointer.fromPyobj(s)._ptr,batchCount))
    return (_hipblasDrotStridedBatched_64__retval,)


@cython.embedsignature(True)
def hipblasCrotStridedBatched_64(object handle, long n, object x, long incx, long stridex, object y, long incy, long stridey, object c, object s, long batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        x (`~.hipblasComplex`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        stridex (`~.int`):
            (undocumented)

        y (`~.hipblasComplex`/`~.object`):
            (undocumented)

        incy (`~.int`):
            (undocumented)

        stridey (`~.int`):
            (undocumented)

        c (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        s (`~.hipblasComplex`/`~.object`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    _hipblasCrotStridedBatched_64__retval = hipblasStatus_t(chipblas.hipblasCrotStridedBatched_64(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,n,
        hipblasComplex.fromPyobj(x).getElementPtr(),incx,stridex,
        hipblasComplex.fromPyobj(y).getElementPtr(),incy,stridey,
        <const float *>hip._util.types.Pointer.fromPyobj(c)._ptr,
        hipblasComplex.fromPyobj(s).getElementPtr(),batchCount))
    return (_hipblasCrotStridedBatched_64__retval,)


@cython.embedsignature(True)
def hipblasCsrotStridedBatched_64(object handle, long n, object x, long incx, long stridex, object y, long incy, long stridey, object c, object s, long batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        x (`~.hipblasComplex`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        stridex (`~.int`):
            (undocumented)

        y (`~.hipblasComplex`/`~.object`):
            (undocumented)

        incy (`~.int`):
            (undocumented)

        stridey (`~.int`):
            (undocumented)

        c (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        s (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    _hipblasCsrotStridedBatched_64__retval = hipblasStatus_t(chipblas.hipblasCsrotStridedBatched_64(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,n,
        hipblasComplex.fromPyobj(x).getElementPtr(),incx,stridex,
        hipblasComplex.fromPyobj(y).getElementPtr(),incy,stridey,
        <const float *>hip._util.types.Pointer.fromPyobj(c)._ptr,
        <const float *>hip._util.types.Pointer.fromPyobj(s)._ptr,batchCount))
    return (_hipblasCsrotStridedBatched_64__retval,)


@cython.embedsignature(True)
def hipblasZrotStridedBatched_64(object handle, long n, object x, long incx, long stridex, object y, long incy, long stridey, object c, object s, long batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        x (`~.hipblasDoubleComplex`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        stridex (`~.int`):
            (undocumented)

        y (`~.hipblasDoubleComplex`/`~.object`):
            (undocumented)

        incy (`~.int`):
            (undocumented)

        stridey (`~.int`):
            (undocumented)

        c (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        s (`~.hipblasDoubleComplex`/`~.object`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    _hipblasZrotStridedBatched_64__retval = hipblasStatus_t(chipblas.hipblasZrotStridedBatched_64(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,n,
        hipblasDoubleComplex.fromPyobj(x).getElementPtr(),incx,stridex,
        hipblasDoubleComplex.fromPyobj(y).getElementPtr(),incy,stridey,
        <const double *>hip._util.types.Pointer.fromPyobj(c)._ptr,
        hipblasDoubleComplex.fromPyobj(s).getElementPtr(),batchCount))
    return (_hipblasZrotStridedBatched_64__retval,)


@cython.embedsignature(True)
def hipblasZdrotStridedBatched_64(object handle, long n, object x, long incx, long stridex, object y, long incy, long stridey, object c, object s, long batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        x (`~.hipblasDoubleComplex`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        stridex (`~.int`):
            (undocumented)

        y (`~.hipblasDoubleComplex`/`~.object`):
            (undocumented)

        incy (`~.int`):
            (undocumented)

        stridey (`~.int`):
            (undocumented)

        c (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        s (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    _hipblasZdrotStridedBatched_64__retval = hipblasStatus_t(chipblas.hipblasZdrotStridedBatched_64(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,n,
        hipblasDoubleComplex.fromPyobj(x).getElementPtr(),incx,stridex,
        hipblasDoubleComplex.fromPyobj(y).getElementPtr(),incy,stridey,
        <const double *>hip._util.types.Pointer.fromPyobj(c)._ptr,
        <const double *>hip._util.types.Pointer.fromPyobj(s)._ptr,batchCount))
    return (_hipblasZdrotStridedBatched_64__retval,)


@cython.embedsignature(True)
def hipblasCrotStridedBatched_v2_64(object handle, long n, object x, long incx, long stridex, object y, long incy, long stridey, object c, object s, long batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        x (`~.float2`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        stridex (`~.int`):
            (undocumented)

        y (`~.float2`/`~.object`):
            (undocumented)

        incy (`~.int`):
            (undocumented)

        stridey (`~.int`):
            (undocumented)

        c (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        s (`~.float2`/`~.object`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    _hipblasCrotStridedBatched_v2_64__retval = hipblasStatus_t(chipblas.hipblasCrotStridedBatched_v2_64(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,n,
        float2.fromPyobj(x).getElementPtr(),incx,stridex,
        float2.fromPyobj(y).getElementPtr(),incy,stridey,
        <const float *>hip._util.types.Pointer.fromPyobj(c)._ptr,
        float2.fromPyobj(s).getElementPtr(),batchCount))
    return (_hipblasCrotStridedBatched_v2_64__retval,)


@cython.embedsignature(True)
def hipblasCsrotStridedBatched_v2_64(object handle, long n, object x, long incx, long stridex, object y, long incy, long stridey, object c, object s, long batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        x (`~.float2`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        stridex (`~.int`):
            (undocumented)

        y (`~.float2`/`~.object`):
            (undocumented)

        incy (`~.int`):
            (undocumented)

        stridey (`~.int`):
            (undocumented)

        c (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        s (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    _hipblasCsrotStridedBatched_v2_64__retval = hipblasStatus_t(chipblas.hipblasCsrotStridedBatched_v2_64(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,n,
        float2.fromPyobj(x).getElementPtr(),incx,stridex,
        float2.fromPyobj(y).getElementPtr(),incy,stridey,
        <const float *>hip._util.types.Pointer.fromPyobj(c)._ptr,
        <const float *>hip._util.types.Pointer.fromPyobj(s)._ptr,batchCount))
    return (_hipblasCsrotStridedBatched_v2_64__retval,)


@cython.embedsignature(True)
def hipblasZrotStridedBatched_v2_64(object handle, long n, object x, long incx, long stridex, object y, long incy, long stridey, object c, object s, long batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        x (`~.double2`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        stridex (`~.int`):
            (undocumented)

        y (`~.double2`/`~.object`):
            (undocumented)

        incy (`~.int`):
            (undocumented)

        stridey (`~.int`):
            (undocumented)

        c (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        s (`~.double2`/`~.object`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    _hipblasZrotStridedBatched_v2_64__retval = hipblasStatus_t(chipblas.hipblasZrotStridedBatched_v2_64(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,n,
        double2.fromPyobj(x).getElementPtr(),incx,stridex,
        double2.fromPyobj(y).getElementPtr(),incy,stridey,
        <const double *>hip._util.types.Pointer.fromPyobj(c)._ptr,
        double2.fromPyobj(s).getElementPtr(),batchCount))
    return (_hipblasZrotStridedBatched_v2_64__retval,)


@cython.embedsignature(True)
def hipblasZdrotStridedBatched_v2_64(object handle, long n, object x, long incx, long stridex, object y, long incy, long stridey, object c, object s, long batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        x (`~.double2`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        stridex (`~.int`):
            (undocumented)

        y (`~.double2`/`~.object`):
            (undocumented)

        incy (`~.int`):
            (undocumented)

        stridey (`~.int`):
            (undocumented)

        c (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        s (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    _hipblasZdrotStridedBatched_v2_64__retval = hipblasStatus_t(chipblas.hipblasZdrotStridedBatched_v2_64(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,n,
        double2.fromPyobj(x).getElementPtr(),incx,stridex,
        double2.fromPyobj(y).getElementPtr(),incy,stridey,
        <const double *>hip._util.types.Pointer.fromPyobj(c)._ptr,
        <const double *>hip._util.types.Pointer.fromPyobj(s)._ptr,batchCount))
    return (_hipblasZdrotStridedBatched_v2_64__retval,)


@cython.embedsignature(True)
def hipblasSrotg(object handle, object a, object b, object c, object s):
    r"""BLAS Level 1 API

    @{

    rotg creates the Givens rotation matrix for the vector (a b).
    Scalars c and s and arrays a and b may be stored in either host or device memory, location is specified by calling hipblasSetPointerMode.
    If the pointer mode is set to HIPBLAS_POINTER_MODE_HOST, this function blocks the CPU until the GPU has finished and the results are available in host memory.
    If the pointer mode is set to HIPBLAS_POINTER_MODE_DEVICE, this function returns immediately and synchronization is required to read the results.

    - Supported precisions in rocBLAS : s,d,c,z
    - Supported precisions in cuBLAS  : s,d,c,z

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`) -- *IN*:
            [hipblasHandle_t]
            handle to the hipblas library context queue.

        a (`~.hip._util.types.Pointer`/`~.object`) -- *INOUT*:
            device pointer or host pointer to input vector element, overwritten with r.

        b (`~.hip._util.types.Pointer`/`~.object`) -- *INOUT*:
            device pointer or host pointer to input vector element, overwritten with z.

        c (`~.hip._util.types.Pointer`/`~.object`) -- *INOUT*:
            device pointer or host pointer to cosine element of Givens rotation.

        s (`~.hip._util.types.Pointer`/`~.object`) -- *INOUT*:
            device pointer or host pointer sine element of Givens rotation.
    """
    _hipblasSrotg__retval = hipblasStatus_t(chipblas.hipblasSrotg(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,
        <float *>hip._util.types.Pointer.fromPyobj(a)._ptr,
        <float *>hip._util.types.Pointer.fromPyobj(b)._ptr,
        <float *>hip._util.types.Pointer.fromPyobj(c)._ptr,
        <float *>hip._util.types.Pointer.fromPyobj(s)._ptr))
    return (_hipblasSrotg__retval,)


@cython.embedsignature(True)
def hipblasDrotg(object handle, object a, object b, object c, object s):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        a (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        b (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        c (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        s (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)
    """
    _hipblasDrotg__retval = hipblasStatus_t(chipblas.hipblasDrotg(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,
        <double *>hip._util.types.Pointer.fromPyobj(a)._ptr,
        <double *>hip._util.types.Pointer.fromPyobj(b)._ptr,
        <double *>hip._util.types.Pointer.fromPyobj(c)._ptr,
        <double *>hip._util.types.Pointer.fromPyobj(s)._ptr))
    return (_hipblasDrotg__retval,)


@cython.embedsignature(True)
def hipblasCrotg(object handle, object a, object b, object c, object s):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        a (`~.hipblasComplex`/`~.object`):
            (undocumented)

        b (`~.hipblasComplex`/`~.object`):
            (undocumented)

        c (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        s (`~.hipblasComplex`/`~.object`):
            (undocumented)
    """
    _hipblasCrotg__retval = hipblasStatus_t(chipblas.hipblasCrotg(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,
        hipblasComplex.fromPyobj(a).getElementPtr(),
        hipblasComplex.fromPyobj(b).getElementPtr(),
        <float *>hip._util.types.Pointer.fromPyobj(c)._ptr,
        hipblasComplex.fromPyobj(s).getElementPtr()))
    return (_hipblasCrotg__retval,)


@cython.embedsignature(True)
def hipblasZrotg(object handle, object a, object b, object c, object s):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        a (`~.hipblasDoubleComplex`/`~.object`):
            (undocumented)

        b (`~.hipblasDoubleComplex`/`~.object`):
            (undocumented)

        c (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        s (`~.hipblasDoubleComplex`/`~.object`):
            (undocumented)
    """
    _hipblasZrotg__retval = hipblasStatus_t(chipblas.hipblasZrotg(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,
        hipblasDoubleComplex.fromPyobj(a).getElementPtr(),
        hipblasDoubleComplex.fromPyobj(b).getElementPtr(),
        <double *>hip._util.types.Pointer.fromPyobj(c)._ptr,
        hipblasDoubleComplex.fromPyobj(s).getElementPtr()))
    return (_hipblasZrotg__retval,)


@cython.embedsignature(True)
def hipblasCrotg_v2(object handle, object a, object b, object c, object s):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        a (`~.float2`/`~.object`):
            (undocumented)

        b (`~.float2`/`~.object`):
            (undocumented)

        c (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        s (`~.float2`/`~.object`):
            (undocumented)
    """
    _hipblasCrotg_v2__retval = hipblasStatus_t(chipblas.hipblasCrotg_v2(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,
        float2.fromPyobj(a).getElementPtr(),
        float2.fromPyobj(b).getElementPtr(),
        <float *>hip._util.types.Pointer.fromPyobj(c)._ptr,
        float2.fromPyobj(s).getElementPtr()))
    return (_hipblasCrotg_v2__retval,)


@cython.embedsignature(True)
def hipblasZrotg_v2(object handle, object a, object b, object c, object s):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        a (`~.double2`/`~.object`):
            (undocumented)

        b (`~.double2`/`~.object`):
            (undocumented)

        c (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        s (`~.double2`/`~.object`):
            (undocumented)
    """
    _hipblasZrotg_v2__retval = hipblasStatus_t(chipblas.hipblasZrotg_v2(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,
        double2.fromPyobj(a).getElementPtr(),
        double2.fromPyobj(b).getElementPtr(),
        <double *>hip._util.types.Pointer.fromPyobj(c)._ptr,
        double2.fromPyobj(s).getElementPtr()))
    return (_hipblasZrotg_v2__retval,)


@cython.embedsignature(True)
def hipblasSrotg_64(object handle, object a, object b, object c, object s):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        a (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        b (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        c (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        s (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)
    """
    _hipblasSrotg_64__retval = hipblasStatus_t(chipblas.hipblasSrotg_64(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,
        <float *>hip._util.types.Pointer.fromPyobj(a)._ptr,
        <float *>hip._util.types.Pointer.fromPyobj(b)._ptr,
        <float *>hip._util.types.Pointer.fromPyobj(c)._ptr,
        <float *>hip._util.types.Pointer.fromPyobj(s)._ptr))
    return (_hipblasSrotg_64__retval,)


@cython.embedsignature(True)
def hipblasDrotg_64(object handle, object a, object b, object c, object s):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        a (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        b (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        c (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        s (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)
    """
    _hipblasDrotg_64__retval = hipblasStatus_t(chipblas.hipblasDrotg_64(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,
        <double *>hip._util.types.Pointer.fromPyobj(a)._ptr,
        <double *>hip._util.types.Pointer.fromPyobj(b)._ptr,
        <double *>hip._util.types.Pointer.fromPyobj(c)._ptr,
        <double *>hip._util.types.Pointer.fromPyobj(s)._ptr))
    return (_hipblasDrotg_64__retval,)


@cython.embedsignature(True)
def hipblasCrotg_64(object handle, object a, object b, object c, object s):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        a (`~.hipblasComplex`/`~.object`):
            (undocumented)

        b (`~.hipblasComplex`/`~.object`):
            (undocumented)

        c (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        s (`~.hipblasComplex`/`~.object`):
            (undocumented)
    """
    _hipblasCrotg_64__retval = hipblasStatus_t(chipblas.hipblasCrotg_64(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,
        hipblasComplex.fromPyobj(a).getElementPtr(),
        hipblasComplex.fromPyobj(b).getElementPtr(),
        <float *>hip._util.types.Pointer.fromPyobj(c)._ptr,
        hipblasComplex.fromPyobj(s).getElementPtr()))
    return (_hipblasCrotg_64__retval,)


@cython.embedsignature(True)
def hipblasZrotg_64(object handle, object a, object b, object c, object s):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        a (`~.hipblasDoubleComplex`/`~.object`):
            (undocumented)

        b (`~.hipblasDoubleComplex`/`~.object`):
            (undocumented)

        c (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        s (`~.hipblasDoubleComplex`/`~.object`):
            (undocumented)
    """
    _hipblasZrotg_64__retval = hipblasStatus_t(chipblas.hipblasZrotg_64(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,
        hipblasDoubleComplex.fromPyobj(a).getElementPtr(),
        hipblasDoubleComplex.fromPyobj(b).getElementPtr(),
        <double *>hip._util.types.Pointer.fromPyobj(c)._ptr,
        hipblasDoubleComplex.fromPyobj(s).getElementPtr()))
    return (_hipblasZrotg_64__retval,)


@cython.embedsignature(True)
def hipblasCrotg_v2_64(object handle, object a, object b, object c, object s):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        a (`~.float2`/`~.object`):
            (undocumented)

        b (`~.float2`/`~.object`):
            (undocumented)

        c (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        s (`~.float2`/`~.object`):
            (undocumented)
    """
    _hipblasCrotg_v2_64__retval = hipblasStatus_t(chipblas.hipblasCrotg_v2_64(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,
        float2.fromPyobj(a).getElementPtr(),
        float2.fromPyobj(b).getElementPtr(),
        <float *>hip._util.types.Pointer.fromPyobj(c)._ptr,
        float2.fromPyobj(s).getElementPtr()))
    return (_hipblasCrotg_v2_64__retval,)


@cython.embedsignature(True)
def hipblasZrotg_v2_64(object handle, object a, object b, object c, object s):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        a (`~.double2`/`~.object`):
            (undocumented)

        b (`~.double2`/`~.object`):
            (undocumented)

        c (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        s (`~.double2`/`~.object`):
            (undocumented)
    """
    _hipblasZrotg_v2_64__retval = hipblasStatus_t(chipblas.hipblasZrotg_v2_64(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,
        double2.fromPyobj(a).getElementPtr(),
        double2.fromPyobj(b).getElementPtr(),
        <double *>hip._util.types.Pointer.fromPyobj(c)._ptr,
        double2.fromPyobj(s).getElementPtr()))
    return (_hipblasZrotg_v2_64__retval,)


@cython.embedsignature(True)
def hipblasSrotgBatched(object handle, object a, object b, object c, object s, int batchCount):
    r"""BLAS Level 1 API

    @{

    rotgBatched creates the Givens rotation matrix for the batched vectors (a_i b_i), for i = 1, ..., batchCount.
    a, b, c, and s may be stored in either host or device memory, location is specified by calling hipblasSetPointerMode.
    If the pointer mode is set to HIPBLAS_POINTER_MODE_HOST, this function blocks the CPU until the GPU has finished and the results are available in host memory.
    If the pointer mode is set to HIPBLAS_POINTER_MODE_DEVICE, this function returns immediately and synchronization is required to read the results.

    - Supported precisions in rocBLAS : s,d,c,z
    - Supported precisions in cuBLAS  : No support

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`) -- *IN*:
            [hipblasHandle_t]
            handle to the hipblas library context queue.

        a (`~.hip._util.types.ListOfPointer`/`~.object`) -- *INOUT*:
            device array of device pointers storing each single input vector element a_i, overwritten with r_i.

        b (`~.hip._util.types.ListOfPointer`/`~.object`) -- *INOUT*:
            device array of device pointers storing each single input vector element b_i, overwritten with z_i.

        c (`~.hip._util.types.ListOfPointer`/`~.object`) -- *INOUT*:
            device array of device pointers storing each cosine element of Givens rotation for the batch.

        s (`~.hip._util.types.ListOfPointer`/`~.object`) -- *INOUT*:
            device array of device pointers storing each sine element of Givens rotation for the batch.

        batchCount (`~.int`) -- *IN*:
            [int]
            number of batches (length of arrays a, b, c, and s).
    """
    _hipblasSrotgBatched__retval = hipblasStatus_t(chipblas.hipblasSrotgBatched(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,
        <float *const*>hip._util.types.ListOfPointer.fromPyobj(a)._ptr,
        <float *const*>hip._util.types.ListOfPointer.fromPyobj(b)._ptr,
        <float *const*>hip._util.types.ListOfPointer.fromPyobj(c)._ptr,
        <float *const*>hip._util.types.ListOfPointer.fromPyobj(s)._ptr,batchCount))
    return (_hipblasSrotgBatched__retval,)


@cython.embedsignature(True)
def hipblasDrotgBatched(object handle, object a, object b, object c, object s, int batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        a (`~.hip._util.types.ListOfPointer`/`~.object`):
            (undocumented)

        b (`~.hip._util.types.ListOfPointer`/`~.object`):
            (undocumented)

        c (`~.hip._util.types.ListOfPointer`/`~.object`):
            (undocumented)

        s (`~.hip._util.types.ListOfPointer`/`~.object`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    _hipblasDrotgBatched__retval = hipblasStatus_t(chipblas.hipblasDrotgBatched(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,
        <double *const*>hip._util.types.ListOfPointer.fromPyobj(a)._ptr,
        <double *const*>hip._util.types.ListOfPointer.fromPyobj(b)._ptr,
        <double *const*>hip._util.types.ListOfPointer.fromPyobj(c)._ptr,
        <double *const*>hip._util.types.ListOfPointer.fromPyobj(s)._ptr,batchCount))
    return (_hipblasDrotgBatched__retval,)


@cython.embedsignature(True)
def hipblasCrotgBatched(object handle, object a, object b, object c, object s, int batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        a (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        b (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        c (`~.hip._util.types.ListOfPointer`/`~.object`):
            (undocumented)

        s (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    _hipblasCrotgBatched__retval = hipblasStatus_t(chipblas.hipblasCrotgBatched(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,
        <chipblas.hipblasComplex *const*>hip._util.types.Pointer.fromPyobj(a)._ptr,
        <chipblas.hipblasComplex *const*>hip._util.types.Pointer.fromPyobj(b)._ptr,
        <float *const*>hip._util.types.ListOfPointer.fromPyobj(c)._ptr,
        <chipblas.hipblasComplex *const*>hip._util.types.Pointer.fromPyobj(s)._ptr,batchCount))
    return (_hipblasCrotgBatched__retval,)


@cython.embedsignature(True)
def hipblasZrotgBatched(object handle, object a, object b, object c, object s, int batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        a (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        b (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        c (`~.hip._util.types.ListOfPointer`/`~.object`):
            (undocumented)

        s (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    _hipblasZrotgBatched__retval = hipblasStatus_t(chipblas.hipblasZrotgBatched(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,
        <chipblas.hipblasDoubleComplex *const*>hip._util.types.Pointer.fromPyobj(a)._ptr,
        <chipblas.hipblasDoubleComplex *const*>hip._util.types.Pointer.fromPyobj(b)._ptr,
        <double *const*>hip._util.types.ListOfPointer.fromPyobj(c)._ptr,
        <chipblas.hipblasDoubleComplex *const*>hip._util.types.Pointer.fromPyobj(s)._ptr,batchCount))
    return (_hipblasZrotgBatched__retval,)


@cython.embedsignature(True)
def hipblasCrotgBatched_v2(object handle, object a, object b, object c, object s, int batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        a (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        b (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        c (`~.hip._util.types.ListOfPointer`/`~.object`):
            (undocumented)

        s (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    _hipblasCrotgBatched_v2__retval = hipblasStatus_t(chipblas.hipblasCrotgBatched_v2(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,
        <chipblas.float2 *const*>hip._util.types.Pointer.fromPyobj(a)._ptr,
        <chipblas.float2 *const*>hip._util.types.Pointer.fromPyobj(b)._ptr,
        <float *const*>hip._util.types.ListOfPointer.fromPyobj(c)._ptr,
        <chipblas.float2 *const*>hip._util.types.Pointer.fromPyobj(s)._ptr,batchCount))
    return (_hipblasCrotgBatched_v2__retval,)


@cython.embedsignature(True)
def hipblasZrotgBatched_v2(object handle, object a, object b, object c, object s, int batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        a (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        b (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        c (`~.hip._util.types.ListOfPointer`/`~.object`):
            (undocumented)

        s (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    _hipblasZrotgBatched_v2__retval = hipblasStatus_t(chipblas.hipblasZrotgBatched_v2(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,
        <chipblas.double2 *const*>hip._util.types.Pointer.fromPyobj(a)._ptr,
        <chipblas.double2 *const*>hip._util.types.Pointer.fromPyobj(b)._ptr,
        <double *const*>hip._util.types.ListOfPointer.fromPyobj(c)._ptr,
        <chipblas.double2 *const*>hip._util.types.Pointer.fromPyobj(s)._ptr,batchCount))
    return (_hipblasZrotgBatched_v2__retval,)


@cython.embedsignature(True)
def hipblasSrotgBatched_64(object handle, object a, object b, object c, object s, long batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        a (`~.hip._util.types.ListOfPointer`/`~.object`):
            (undocumented)

        b (`~.hip._util.types.ListOfPointer`/`~.object`):
            (undocumented)

        c (`~.hip._util.types.ListOfPointer`/`~.object`):
            (undocumented)

        s (`~.hip._util.types.ListOfPointer`/`~.object`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    _hipblasSrotgBatched_64__retval = hipblasStatus_t(chipblas.hipblasSrotgBatched_64(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,
        <float *const*>hip._util.types.ListOfPointer.fromPyobj(a)._ptr,
        <float *const*>hip._util.types.ListOfPointer.fromPyobj(b)._ptr,
        <float *const*>hip._util.types.ListOfPointer.fromPyobj(c)._ptr,
        <float *const*>hip._util.types.ListOfPointer.fromPyobj(s)._ptr,batchCount))
    return (_hipblasSrotgBatched_64__retval,)


@cython.embedsignature(True)
def hipblasDrotgBatched_64(object handle, object a, object b, object c, object s, long batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        a (`~.hip._util.types.ListOfPointer`/`~.object`):
            (undocumented)

        b (`~.hip._util.types.ListOfPointer`/`~.object`):
            (undocumented)

        c (`~.hip._util.types.ListOfPointer`/`~.object`):
            (undocumented)

        s (`~.hip._util.types.ListOfPointer`/`~.object`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    _hipblasDrotgBatched_64__retval = hipblasStatus_t(chipblas.hipblasDrotgBatched_64(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,
        <double *const*>hip._util.types.ListOfPointer.fromPyobj(a)._ptr,
        <double *const*>hip._util.types.ListOfPointer.fromPyobj(b)._ptr,
        <double *const*>hip._util.types.ListOfPointer.fromPyobj(c)._ptr,
        <double *const*>hip._util.types.ListOfPointer.fromPyobj(s)._ptr,batchCount))
    return (_hipblasDrotgBatched_64__retval,)


@cython.embedsignature(True)
def hipblasCrotgBatched_64(object handle, object a, object b, object c, object s, long batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        a (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        b (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        c (`~.hip._util.types.ListOfPointer`/`~.object`):
            (undocumented)

        s (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    _hipblasCrotgBatched_64__retval = hipblasStatus_t(chipblas.hipblasCrotgBatched_64(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,
        <chipblas.hipblasComplex *const*>hip._util.types.Pointer.fromPyobj(a)._ptr,
        <chipblas.hipblasComplex *const*>hip._util.types.Pointer.fromPyobj(b)._ptr,
        <float *const*>hip._util.types.ListOfPointer.fromPyobj(c)._ptr,
        <chipblas.hipblasComplex *const*>hip._util.types.Pointer.fromPyobj(s)._ptr,batchCount))
    return (_hipblasCrotgBatched_64__retval,)


@cython.embedsignature(True)
def hipblasZrotgBatched_64(object handle, object a, object b, object c, object s, long batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        a (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        b (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        c (`~.hip._util.types.ListOfPointer`/`~.object`):
            (undocumented)

        s (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    _hipblasZrotgBatched_64__retval = hipblasStatus_t(chipblas.hipblasZrotgBatched_64(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,
        <chipblas.hipblasDoubleComplex *const*>hip._util.types.Pointer.fromPyobj(a)._ptr,
        <chipblas.hipblasDoubleComplex *const*>hip._util.types.Pointer.fromPyobj(b)._ptr,
        <double *const*>hip._util.types.ListOfPointer.fromPyobj(c)._ptr,
        <chipblas.hipblasDoubleComplex *const*>hip._util.types.Pointer.fromPyobj(s)._ptr,batchCount))
    return (_hipblasZrotgBatched_64__retval,)


@cython.embedsignature(True)
def hipblasCrotgBatched_v2_64(object handle, object a, object b, object c, object s, long batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        a (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        b (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        c (`~.hip._util.types.ListOfPointer`/`~.object`):
            (undocumented)

        s (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    _hipblasCrotgBatched_v2_64__retval = hipblasStatus_t(chipblas.hipblasCrotgBatched_v2_64(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,
        <chipblas.float2 *const*>hip._util.types.Pointer.fromPyobj(a)._ptr,
        <chipblas.float2 *const*>hip._util.types.Pointer.fromPyobj(b)._ptr,
        <float *const*>hip._util.types.ListOfPointer.fromPyobj(c)._ptr,
        <chipblas.float2 *const*>hip._util.types.Pointer.fromPyobj(s)._ptr,batchCount))
    return (_hipblasCrotgBatched_v2_64__retval,)


@cython.embedsignature(True)
def hipblasZrotgBatched_v2_64(object handle, object a, object b, object c, object s, long batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        a (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        b (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        c (`~.hip._util.types.ListOfPointer`/`~.object`):
            (undocumented)

        s (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    _hipblasZrotgBatched_v2_64__retval = hipblasStatus_t(chipblas.hipblasZrotgBatched_v2_64(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,
        <chipblas.double2 *const*>hip._util.types.Pointer.fromPyobj(a)._ptr,
        <chipblas.double2 *const*>hip._util.types.Pointer.fromPyobj(b)._ptr,
        <double *const*>hip._util.types.ListOfPointer.fromPyobj(c)._ptr,
        <chipblas.double2 *const*>hip._util.types.Pointer.fromPyobj(s)._ptr,batchCount))
    return (_hipblasZrotgBatched_v2_64__retval,)


@cython.embedsignature(True)
def hipblasSrotgStridedBatched(object handle, object a, long stridea, object b, long strideb, object c, long stridec, object s, long strides, int batchCount):
    r"""BLAS Level 1 API

    @{

    rotgStridedBatched creates the Givens rotation matrix for the strided batched vectors (a_i b_i), for i = 1, ..., batchCount.
    a, b, c, and s may be stored in either host or device memory, location is specified by calling hipblasSetPointerMode.
    If the pointer mode is set to HIPBLAS_POINTER_MODE_HOST, this function blocks the CPU until the GPU has finished and the results are available in host memory.
    If the pointer mode is set to HIPBLAS_POINTER_MODE_HOST, this function returns immediately and synchronization is required to read the results.

    - Supported precisions in rocBLAS : s,d,c,z
    - Supported precisions in cuBLAS  : No support

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`) -- *IN*:
            [hipblasHandle_t]
            handle to the hipblas library context queue.

        a (`~.hip._util.types.Pointer`/`~.object`) -- *INOUT*:
            device strided_batched pointer or host strided_batched pointer to first single input vector element a_1, overwritten with r.

        stridea (`~.int`) -- *IN*:
            [hipblasStride]
            distance between elements of a in batch (distance between a_i and a_(i + 1))

        b (`~.hip._util.types.Pointer`/`~.object`) -- *INOUT*:
            device strided_batched pointer or host strided_batched pointer to first single input vector element b_1, overwritten with z.

        strideb (`~.int`) -- *IN*:
            [hipblasStride]
            distance between elements of b in batch (distance between b_i and b_(i + 1))

        c (`~.hip._util.types.Pointer`/`~.object`) -- *INOUT*:
            device strided_batched pointer or host strided_batched pointer to first cosine element of Givens rotations c_1.

        stridec (`~.int`) -- *IN*:
            [hipblasStride]
            distance between elements of c in batch (distance between c_i and c_(i + 1))

        s (`~.hip._util.types.Pointer`/`~.object`) -- *INOUT*:
            device strided_batched pointer or host strided_batched pointer to sine element of Givens rotations s_1.

        strides (`~.int`) -- *IN*:
            [hipblasStride]
            distance between elements of s in batch (distance between s_i and s_(i + 1))

        batchCount (`~.int`) -- *IN*:
            [int]
            number of batches (length of arrays a, b, c, and s).
    """
    _hipblasSrotgStridedBatched__retval = hipblasStatus_t(chipblas.hipblasSrotgStridedBatched(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,
        <float *>hip._util.types.Pointer.fromPyobj(a)._ptr,stridea,
        <float *>hip._util.types.Pointer.fromPyobj(b)._ptr,strideb,
        <float *>hip._util.types.Pointer.fromPyobj(c)._ptr,stridec,
        <float *>hip._util.types.Pointer.fromPyobj(s)._ptr,strides,batchCount))
    return (_hipblasSrotgStridedBatched__retval,)


@cython.embedsignature(True)
def hipblasDrotgStridedBatched(object handle, object a, long stridea, object b, long strideb, object c, long stridec, object s, long strides, int batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        a (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        stridea (`~.int`):
            (undocumented)

        b (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        strideb (`~.int`):
            (undocumented)

        c (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        stridec (`~.int`):
            (undocumented)

        s (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        strides (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    _hipblasDrotgStridedBatched__retval = hipblasStatus_t(chipblas.hipblasDrotgStridedBatched(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,
        <double *>hip._util.types.Pointer.fromPyobj(a)._ptr,stridea,
        <double *>hip._util.types.Pointer.fromPyobj(b)._ptr,strideb,
        <double *>hip._util.types.Pointer.fromPyobj(c)._ptr,stridec,
        <double *>hip._util.types.Pointer.fromPyobj(s)._ptr,strides,batchCount))
    return (_hipblasDrotgStridedBatched__retval,)


@cython.embedsignature(True)
def hipblasCrotgStridedBatched(object handle, object a, long stridea, object b, long strideb, object c, long stridec, object s, long strides, int batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        a (`~.hipblasComplex`/`~.object`):
            (undocumented)

        stridea (`~.int`):
            (undocumented)

        b (`~.hipblasComplex`/`~.object`):
            (undocumented)

        strideb (`~.int`):
            (undocumented)

        c (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        stridec (`~.int`):
            (undocumented)

        s (`~.hipblasComplex`/`~.object`):
            (undocumented)

        strides (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    _hipblasCrotgStridedBatched__retval = hipblasStatus_t(chipblas.hipblasCrotgStridedBatched(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,
        hipblasComplex.fromPyobj(a).getElementPtr(),stridea,
        hipblasComplex.fromPyobj(b).getElementPtr(),strideb,
        <float *>hip._util.types.Pointer.fromPyobj(c)._ptr,stridec,
        hipblasComplex.fromPyobj(s).getElementPtr(),strides,batchCount))
    return (_hipblasCrotgStridedBatched__retval,)


@cython.embedsignature(True)
def hipblasZrotgStridedBatched(object handle, object a, long stridea, object b, long strideb, object c, long stridec, object s, long strides, int batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        a (`~.hipblasDoubleComplex`/`~.object`):
            (undocumented)

        stridea (`~.int`):
            (undocumented)

        b (`~.hipblasDoubleComplex`/`~.object`):
            (undocumented)

        strideb (`~.int`):
            (undocumented)

        c (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        stridec (`~.int`):
            (undocumented)

        s (`~.hipblasDoubleComplex`/`~.object`):
            (undocumented)

        strides (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    _hipblasZrotgStridedBatched__retval = hipblasStatus_t(chipblas.hipblasZrotgStridedBatched(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,
        hipblasDoubleComplex.fromPyobj(a).getElementPtr(),stridea,
        hipblasDoubleComplex.fromPyobj(b).getElementPtr(),strideb,
        <double *>hip._util.types.Pointer.fromPyobj(c)._ptr,stridec,
        hipblasDoubleComplex.fromPyobj(s).getElementPtr(),strides,batchCount))
    return (_hipblasZrotgStridedBatched__retval,)


@cython.embedsignature(True)
def hipblasCrotgStridedBatched_v2(object handle, object a, long stridea, object b, long strideb, object c, long stridec, object s, long strides, int batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        a (`~.float2`/`~.object`):
            (undocumented)

        stridea (`~.int`):
            (undocumented)

        b (`~.float2`/`~.object`):
            (undocumented)

        strideb (`~.int`):
            (undocumented)

        c (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        stridec (`~.int`):
            (undocumented)

        s (`~.float2`/`~.object`):
            (undocumented)

        strides (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    _hipblasCrotgStridedBatched_v2__retval = hipblasStatus_t(chipblas.hipblasCrotgStridedBatched_v2(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,
        float2.fromPyobj(a).getElementPtr(),stridea,
        float2.fromPyobj(b).getElementPtr(),strideb,
        <float *>hip._util.types.Pointer.fromPyobj(c)._ptr,stridec,
        float2.fromPyobj(s).getElementPtr(),strides,batchCount))
    return (_hipblasCrotgStridedBatched_v2__retval,)


@cython.embedsignature(True)
def hipblasZrotgStridedBatched_v2(object handle, object a, long stridea, object b, long strideb, object c, long stridec, object s, long strides, int batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        a (`~.double2`/`~.object`):
            (undocumented)

        stridea (`~.int`):
            (undocumented)

        b (`~.double2`/`~.object`):
            (undocumented)

        strideb (`~.int`):
            (undocumented)

        c (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        stridec (`~.int`):
            (undocumented)

        s (`~.double2`/`~.object`):
            (undocumented)

        strides (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    _hipblasZrotgStridedBatched_v2__retval = hipblasStatus_t(chipblas.hipblasZrotgStridedBatched_v2(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,
        double2.fromPyobj(a).getElementPtr(),stridea,
        double2.fromPyobj(b).getElementPtr(),strideb,
        <double *>hip._util.types.Pointer.fromPyobj(c)._ptr,stridec,
        double2.fromPyobj(s).getElementPtr(),strides,batchCount))
    return (_hipblasZrotgStridedBatched_v2__retval,)


@cython.embedsignature(True)
def hipblasSrotgStridedBatched_64(object handle, object a, long stridea, object b, long strideb, object c, long stridec, object s, long strides, long batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        a (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        stridea (`~.int`):
            (undocumented)

        b (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        strideb (`~.int`):
            (undocumented)

        c (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        stridec (`~.int`):
            (undocumented)

        s (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        strides (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    _hipblasSrotgStridedBatched_64__retval = hipblasStatus_t(chipblas.hipblasSrotgStridedBatched_64(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,
        <float *>hip._util.types.Pointer.fromPyobj(a)._ptr,stridea,
        <float *>hip._util.types.Pointer.fromPyobj(b)._ptr,strideb,
        <float *>hip._util.types.Pointer.fromPyobj(c)._ptr,stridec,
        <float *>hip._util.types.Pointer.fromPyobj(s)._ptr,strides,batchCount))
    return (_hipblasSrotgStridedBatched_64__retval,)


@cython.embedsignature(True)
def hipblasDrotgStridedBatched_64(object handle, object a, long stridea, object b, long strideb, object c, long stridec, object s, long strides, long batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        a (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        stridea (`~.int`):
            (undocumented)

        b (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        strideb (`~.int`):
            (undocumented)

        c (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        stridec (`~.int`):
            (undocumented)

        s (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        strides (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    _hipblasDrotgStridedBatched_64__retval = hipblasStatus_t(chipblas.hipblasDrotgStridedBatched_64(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,
        <double *>hip._util.types.Pointer.fromPyobj(a)._ptr,stridea,
        <double *>hip._util.types.Pointer.fromPyobj(b)._ptr,strideb,
        <double *>hip._util.types.Pointer.fromPyobj(c)._ptr,stridec,
        <double *>hip._util.types.Pointer.fromPyobj(s)._ptr,strides,batchCount))
    return (_hipblasDrotgStridedBatched_64__retval,)


@cython.embedsignature(True)
def hipblasCrotgStridedBatched_64(object handle, object a, long stridea, object b, long strideb, object c, long stridec, object s, long strides, long batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        a (`~.hipblasComplex`/`~.object`):
            (undocumented)

        stridea (`~.int`):
            (undocumented)

        b (`~.hipblasComplex`/`~.object`):
            (undocumented)

        strideb (`~.int`):
            (undocumented)

        c (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        stridec (`~.int`):
            (undocumented)

        s (`~.hipblasComplex`/`~.object`):
            (undocumented)

        strides (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    _hipblasCrotgStridedBatched_64__retval = hipblasStatus_t(chipblas.hipblasCrotgStridedBatched_64(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,
        hipblasComplex.fromPyobj(a).getElementPtr(),stridea,
        hipblasComplex.fromPyobj(b).getElementPtr(),strideb,
        <float *>hip._util.types.Pointer.fromPyobj(c)._ptr,stridec,
        hipblasComplex.fromPyobj(s).getElementPtr(),strides,batchCount))
    return (_hipblasCrotgStridedBatched_64__retval,)


@cython.embedsignature(True)
def hipblasZrotgStridedBatched_64(object handle, object a, long stridea, object b, long strideb, object c, long stridec, object s, long strides, long batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        a (`~.hipblasDoubleComplex`/`~.object`):
            (undocumented)

        stridea (`~.int`):
            (undocumented)

        b (`~.hipblasDoubleComplex`/`~.object`):
            (undocumented)

        strideb (`~.int`):
            (undocumented)

        c (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        stridec (`~.int`):
            (undocumented)

        s (`~.hipblasDoubleComplex`/`~.object`):
            (undocumented)

        strides (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    _hipblasZrotgStridedBatched_64__retval = hipblasStatus_t(chipblas.hipblasZrotgStridedBatched_64(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,
        hipblasDoubleComplex.fromPyobj(a).getElementPtr(),stridea,
        hipblasDoubleComplex.fromPyobj(b).getElementPtr(),strideb,
        <double *>hip._util.types.Pointer.fromPyobj(c)._ptr,stridec,
        hipblasDoubleComplex.fromPyobj(s).getElementPtr(),strides,batchCount))
    return (_hipblasZrotgStridedBatched_64__retval,)


@cython.embedsignature(True)
def hipblasCrotgStridedBatched_v2_64(object handle, object a, long stridea, object b, long strideb, object c, long stridec, object s, long strides, long batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        a (`~.float2`/`~.object`):
            (undocumented)

        stridea (`~.int`):
            (undocumented)

        b (`~.float2`/`~.object`):
            (undocumented)

        strideb (`~.int`):
            (undocumented)

        c (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        stridec (`~.int`):
            (undocumented)

        s (`~.float2`/`~.object`):
            (undocumented)

        strides (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    _hipblasCrotgStridedBatched_v2_64__retval = hipblasStatus_t(chipblas.hipblasCrotgStridedBatched_v2_64(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,
        float2.fromPyobj(a).getElementPtr(),stridea,
        float2.fromPyobj(b).getElementPtr(),strideb,
        <float *>hip._util.types.Pointer.fromPyobj(c)._ptr,stridec,
        float2.fromPyobj(s).getElementPtr(),strides,batchCount))
    return (_hipblasCrotgStridedBatched_v2_64__retval,)


@cython.embedsignature(True)
def hipblasZrotgStridedBatched_v2_64(object handle, object a, long stridea, object b, long strideb, object c, long stridec, object s, long strides, long batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        a (`~.double2`/`~.object`):
            (undocumented)

        stridea (`~.int`):
            (undocumented)

        b (`~.double2`/`~.object`):
            (undocumented)

        strideb (`~.int`):
            (undocumented)

        c (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        stridec (`~.int`):
            (undocumented)

        s (`~.double2`/`~.object`):
            (undocumented)

        strides (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    _hipblasZrotgStridedBatched_v2_64__retval = hipblasStatus_t(chipblas.hipblasZrotgStridedBatched_v2_64(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,
        double2.fromPyobj(a).getElementPtr(),stridea,
        double2.fromPyobj(b).getElementPtr(),strideb,
        <double *>hip._util.types.Pointer.fromPyobj(c)._ptr,stridec,
        double2.fromPyobj(s).getElementPtr(),strides,batchCount))
    return (_hipblasZrotgStridedBatched_v2_64__retval,)


@cython.embedsignature(True)
def hipblasSrotm(object handle, int n, object x, int incx, object y, int incy, object param):
    r"""BLAS Level 1 API

    @{

    rotm applies the modified Givens rotation matrix defined by param to vectors x and y.

    - Supported precisions in rocBLAS : s,d
    - Supported precisions in cuBLAS  : s,d

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`) -- *IN*:
            [hipblasHandle_t]
            handle to the hipblas library context queue.

        n (`~.int`) -- *IN*:
            [int]
            number of elements in the x and y vectors.

        x (`~.hip._util.types.Pointer`/`~.object`) -- *INOUT*:
            device pointer storing vector x.

        incx (`~.int`) -- *IN*:
            [int]
            specifies the increment between elements of x.

        y (`~.hip._util.types.Pointer`/`~.object`) -- *INOUT*:
            device pointer storing vector y.

        incy (`~.int`) -- *IN*:
            [int]
            specifies the increment between elements of y.

        param (`~.hip._util.types.Pointer`/`~.object`) -- *IN*:
            device vector or host vector of 5 elements defining the rotation.
            param[0] = flag
            param[1] = H11
            param[2] = H21
            param[3] = H12
            param[4] = H22
            The flag parameter defines the form of H:
            flag = -1 => H = ( H11 H12 H21 H22 )
            flag =  0 => H = ( 1.0 H12 H21 1.0 )
            flag =  1 => H = ( H11 1.0 -1.0 H22 )
            flag = -2 => H = ( 1.0 0.0 0.0 1.0 )
            param may be stored in either host or device memory, location is specified by calling hipblasSetPointerMode.
    """
    _hipblasSrotm__retval = hipblasStatus_t(chipblas.hipblasSrotm(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,n,
        <float *>hip._util.types.Pointer.fromPyobj(x)._ptr,incx,
        <float *>hip._util.types.Pointer.fromPyobj(y)._ptr,incy,
        <const float *>hip._util.types.Pointer.fromPyobj(param)._ptr))
    return (_hipblasSrotm__retval,)


@cython.embedsignature(True)
def hipblasDrotm(object handle, int n, object x, int incx, object y, int incy, object param):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        x (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        y (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        incy (`~.int`):
            (undocumented)

        param (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)
    """
    _hipblasDrotm__retval = hipblasStatus_t(chipblas.hipblasDrotm(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,n,
        <double *>hip._util.types.Pointer.fromPyobj(x)._ptr,incx,
        <double *>hip._util.types.Pointer.fromPyobj(y)._ptr,incy,
        <const double *>hip._util.types.Pointer.fromPyobj(param)._ptr))
    return (_hipblasDrotm__retval,)


@cython.embedsignature(True)
def hipblasSrotm_64(object handle, long n, object x, long incx, object y, long incy, object param):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        x (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        y (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        incy (`~.int`):
            (undocumented)

        param (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)
    """
    _hipblasSrotm_64__retval = hipblasStatus_t(chipblas.hipblasSrotm_64(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,n,
        <float *>hip._util.types.Pointer.fromPyobj(x)._ptr,incx,
        <float *>hip._util.types.Pointer.fromPyobj(y)._ptr,incy,
        <const float *>hip._util.types.Pointer.fromPyobj(param)._ptr))
    return (_hipblasSrotm_64__retval,)


@cython.embedsignature(True)
def hipblasDrotm_64(object handle, long n, object x, long incx, object y, long incy, object param):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        x (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        y (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        incy (`~.int`):
            (undocumented)

        param (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)
    """
    _hipblasDrotm_64__retval = hipblasStatus_t(chipblas.hipblasDrotm_64(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,n,
        <double *>hip._util.types.Pointer.fromPyobj(x)._ptr,incx,
        <double *>hip._util.types.Pointer.fromPyobj(y)._ptr,incy,
        <const double *>hip._util.types.Pointer.fromPyobj(param)._ptr))
    return (_hipblasDrotm_64__retval,)


@cython.embedsignature(True)
def hipblasSrotmBatched(object handle, int n, object x, int incx, object y, int incy, object param, int batchCount):
    r"""BLAS Level 1 API

    @{

    rotmBatched applies the modified Givens rotation matrix defined by param_i to batched vectors x_i and y_i, for i = 1, ..., batchCount.

    - Supported precisions in rocBLAS : s,d
    - Supported precisions in cuBLAS  : No support

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`) -- *IN*:
            [hipblasHandle_t]
            handle to the hipblas library context queue.

        n (`~.int`) -- *IN*:
            [int]
            number of elements in the x and y vectors.

        x (`~.hip._util.types.ListOfPointer`/`~.object`) -- *INOUT*:
            device array of device pointers storing each vector x_i.

        incx (`~.int`) -- *IN*:
            [int]
            specifies the increment between elements of each x_i.

        y (`~.hip._util.types.ListOfPointer`/`~.object`) -- *INOUT*:
            device array of device pointers storing each vector y_1.

        incy (`~.int`) -- *IN*:
            [int]
            specifies the increment between elements of each y_i.

        param (`~.hip._util.types.Pointer`/`~.object`) -- *IN*:
            device array of device vectors of 5 elements defining the rotation.
            param[0] = flag
            param[1] = H11
            param[2] = H21
            param[3] = H12
            param[4] = H22
            The flag parameter defines the form of H:
            flag = -1 => H = ( H11 H12 H21 H22 )
            flag =  0 => H = ( 1.0 H12 H21 1.0 )
            flag =  1 => H = ( H11 1.0 -1.0 H22 )
            flag = -2 => H = ( 1.0 0.0 0.0 1.0 )
            param may ONLY be stored on the device for the batched version of this function.

        batchCount (`~.int`) -- *IN*:
            [int]
            the number of x and y arrays, i.e. the number of batches.
    """
    _hipblasSrotmBatched__retval = hipblasStatus_t(chipblas.hipblasSrotmBatched(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,n,
        <float *const*>hip._util.types.ListOfPointer.fromPyobj(x)._ptr,incx,
        <float *const*>hip._util.types.ListOfPointer.fromPyobj(y)._ptr,incy,
        <const float *const*>hip._util.types.Pointer.fromPyobj(param)._ptr,batchCount))
    return (_hipblasSrotmBatched__retval,)


@cython.embedsignature(True)
def hipblasDrotmBatched(object handle, int n, object x, int incx, object y, int incy, object param, int batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        x (`~.hip._util.types.ListOfPointer`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        y (`~.hip._util.types.ListOfPointer`/`~.object`):
            (undocumented)

        incy (`~.int`):
            (undocumented)

        param (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    _hipblasDrotmBatched__retval = hipblasStatus_t(chipblas.hipblasDrotmBatched(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,n,
        <double *const*>hip._util.types.ListOfPointer.fromPyobj(x)._ptr,incx,
        <double *const*>hip._util.types.ListOfPointer.fromPyobj(y)._ptr,incy,
        <const double *const*>hip._util.types.Pointer.fromPyobj(param)._ptr,batchCount))
    return (_hipblasDrotmBatched__retval,)


@cython.embedsignature(True)
def hipblasSrotmBatched_64(object handle, long n, object x, long incx, object y, long incy, object param, long batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        x (`~.hip._util.types.ListOfPointer`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        y (`~.hip._util.types.ListOfPointer`/`~.object`):
            (undocumented)

        incy (`~.int`):
            (undocumented)

        param (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    _hipblasSrotmBatched_64__retval = hipblasStatus_t(chipblas.hipblasSrotmBatched_64(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,n,
        <float *const*>hip._util.types.ListOfPointer.fromPyobj(x)._ptr,incx,
        <float *const*>hip._util.types.ListOfPointer.fromPyobj(y)._ptr,incy,
        <const float *const*>hip._util.types.Pointer.fromPyobj(param)._ptr,batchCount))
    return (_hipblasSrotmBatched_64__retval,)


@cython.embedsignature(True)
def hipblasDrotmBatched_64(object handle, long n, object x, long incx, object y, long incy, object param, long batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        x (`~.hip._util.types.ListOfPointer`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        y (`~.hip._util.types.ListOfPointer`/`~.object`):
            (undocumented)

        incy (`~.int`):
            (undocumented)

        param (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    _hipblasDrotmBatched_64__retval = hipblasStatus_t(chipblas.hipblasDrotmBatched_64(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,n,
        <double *const*>hip._util.types.ListOfPointer.fromPyobj(x)._ptr,incx,
        <double *const*>hip._util.types.ListOfPointer.fromPyobj(y)._ptr,incy,
        <const double *const*>hip._util.types.Pointer.fromPyobj(param)._ptr,batchCount))
    return (_hipblasDrotmBatched_64__retval,)


@cython.embedsignature(True)
def hipblasSrotmStridedBatched(object handle, int n, object x, int incx, long stridex, object y, int incy, long stridey, object param, long strideParam, int batchCount):
    r"""BLAS Level 1 API

    @{

    rotmStridedBatched applies the modified Givens rotation matrix defined by param_i to strided batched vectors x_i and y_i, for i = 1, ..., batchCount

    - Supported precisions in rocBLAS : s,d
    - Supported precisions in cuBLAS  : No support

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`) -- *IN*:
            [hipblasHandle_t]
            handle to the hipblas library context queue.

        n (`~.int`) -- *IN*:
            [int]
            number of elements in the x and y vectors.

        x (`~.hip._util.types.Pointer`/`~.object`) -- *INOUT*:
            device pointer pointing to first strided batched vector x_1.

        incx (`~.int`) -- *IN*:
            [int]
            specifies the increment between elements of each x_i.

        stridex (`~.int`) -- *IN*:
            [hipblasStride]
            specifies the increment between the beginning of x_i and x_(i + 1)

        y (`~.hip._util.types.Pointer`/`~.object`) -- *INOUT*:
            device pointer pointing to first strided batched vector y_1.

        incy (`~.int`) -- *IN*:
            [int]
            specifies the increment between elements of each y_i.

        stridey (`~.int`) -- *IN*:
            [hipblasStride]
            specifies the increment between the beginning of y_i and y_(i + 1)

        param (`~.hip._util.types.Pointer`/`~.object`) -- *IN*:
            device pointer pointing to first array of 5 elements defining the rotation (param_1).
            param[0] = flag
            param[1] = H11
            param[2] = H21
            param[3] = H12
            param[4] = H22
            The flag parameter defines the form of H:
            flag = -1 => H = ( H11 H12 H21 H22 )
            flag =  0 => H = ( 1.0 H12 H21 1.0 )
            flag =  1 => H = ( H11 1.0 -1.0 H22 )
            flag = -2 => H = ( 1.0 0.0 0.0 1.0 )
            param may ONLY be stored on the device for the strided_batched version of this function.

        strideParam (`~.int`) -- *IN*:
            [hipblasStride]
            specifies the increment between the beginning of param_i and param_(i + 1)

        batchCount (`~.int`) -- *IN*:
            [int]
            the number of x and y arrays, i.e. the number of batches.
    """
    _hipblasSrotmStridedBatched__retval = hipblasStatus_t(chipblas.hipblasSrotmStridedBatched(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,n,
        <float *>hip._util.types.Pointer.fromPyobj(x)._ptr,incx,stridex,
        <float *>hip._util.types.Pointer.fromPyobj(y)._ptr,incy,stridey,
        <const float *>hip._util.types.Pointer.fromPyobj(param)._ptr,strideParam,batchCount))
    return (_hipblasSrotmStridedBatched__retval,)


@cython.embedsignature(True)
def hipblasDrotmStridedBatched(object handle, int n, object x, int incx, long stridex, object y, int incy, long stridey, object param, long strideParam, int batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        x (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        stridex (`~.int`):
            (undocumented)

        y (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        incy (`~.int`):
            (undocumented)

        stridey (`~.int`):
            (undocumented)

        param (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        strideParam (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    _hipblasDrotmStridedBatched__retval = hipblasStatus_t(chipblas.hipblasDrotmStridedBatched(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,n,
        <double *>hip._util.types.Pointer.fromPyobj(x)._ptr,incx,stridex,
        <double *>hip._util.types.Pointer.fromPyobj(y)._ptr,incy,stridey,
        <const double *>hip._util.types.Pointer.fromPyobj(param)._ptr,strideParam,batchCount))
    return (_hipblasDrotmStridedBatched__retval,)


@cython.embedsignature(True)
def hipblasSrotmStridedBatched_64(object handle, long n, object x, long incx, long stridex, object y, long incy, long stridey, object param, long strideParam, long batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        x (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        stridex (`~.int`):
            (undocumented)

        y (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        incy (`~.int`):
            (undocumented)

        stridey (`~.int`):
            (undocumented)

        param (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        strideParam (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    _hipblasSrotmStridedBatched_64__retval = hipblasStatus_t(chipblas.hipblasSrotmStridedBatched_64(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,n,
        <float *>hip._util.types.Pointer.fromPyobj(x)._ptr,incx,stridex,
        <float *>hip._util.types.Pointer.fromPyobj(y)._ptr,incy,stridey,
        <const float *>hip._util.types.Pointer.fromPyobj(param)._ptr,strideParam,batchCount))
    return (_hipblasSrotmStridedBatched_64__retval,)


@cython.embedsignature(True)
def hipblasDrotmStridedBatched_64(object handle, long n, object x, long incx, long stridex, object y, long incy, long stridey, object param, long strideParam, long batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        x (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        stridex (`~.int`):
            (undocumented)

        y (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        incy (`~.int`):
            (undocumented)

        stridey (`~.int`):
            (undocumented)

        param (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        strideParam (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    _hipblasDrotmStridedBatched_64__retval = hipblasStatus_t(chipblas.hipblasDrotmStridedBatched_64(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,n,
        <double *>hip._util.types.Pointer.fromPyobj(x)._ptr,incx,stridex,
        <double *>hip._util.types.Pointer.fromPyobj(y)._ptr,incy,stridey,
        <const double *>hip._util.types.Pointer.fromPyobj(param)._ptr,strideParam,batchCount))
    return (_hipblasDrotmStridedBatched_64__retval,)


@cython.embedsignature(True)
def hipblasSrotmg(object handle, object d1, object d2, object x1, object y1, object param):
    r"""BLAS Level 1 API

    @{

    rotmg creates the modified Givens rotation matrix for the vector (d1 * x1, d2 * y1).
    Parameters may be stored in either host or device memory, location is specified by calling hipblasSetPointerMode.
    If the pointer mode is set to HIPBLAS_POINTER_MODE_HOST, this function blocks the CPU until the GPU has finished and the results are available in host memory.
    If the pointer mode is set to HIPBLAS_POINTER_MODE_DEVICE, this function returns immediately and synchronization is required to read the results.

    - Supported precisions in rocBLAS : s,d
    - Supported precisions in cuBLAS  : s,d

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`) -- *IN*:
            [hipblasHandle_t]
            handle to the hipblas library context queue.

        d1 (`~.hip._util.types.Pointer`/`~.object`) -- *INOUT*:
            device pointer or host pointer to input scalar that is overwritten.

        d2 (`~.hip._util.types.Pointer`/`~.object`) -- *INOUT*:
            device pointer or host pointer to input scalar that is overwritten.

        x1 (`~.hip._util.types.Pointer`/`~.object`) -- *INOUT*:
            device pointer or host pointer to input scalar that is overwritten.

        y1 (`~.hip._util.types.Pointer`/`~.object`) -- *IN*:
            device pointer or host pointer to input scalar.

        param (`~.hip._util.types.Pointer`/`~.object`) -- *OUT*:
            device vector or host vector of 5 elements defining the rotation.
            param[0] = flag
            param[1] = H11
            param[2] = H21
            param[3] = H12
            param[4] = H22
            The flag parameter defines the form of H:
            flag = -1 => H = ( H11 H12 H21 H22 )
            flag =  0 => H = ( 1.0 H12 H21 1.0 )
            flag =  1 => H = ( H11 1.0 -1.0 H22 )
            flag = -2 => H = ( 1.0 0.0 0.0 1.0 )
            param may be stored in either host or device memory, location is specified by calling hipblasSetPointerMode.
    """
    _hipblasSrotmg__retval = hipblasStatus_t(chipblas.hipblasSrotmg(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,
        <float *>hip._util.types.Pointer.fromPyobj(d1)._ptr,
        <float *>hip._util.types.Pointer.fromPyobj(d2)._ptr,
        <float *>hip._util.types.Pointer.fromPyobj(x1)._ptr,
        <const float *>hip._util.types.Pointer.fromPyobj(y1)._ptr,
        <float *>hip._util.types.Pointer.fromPyobj(param)._ptr))
    return (_hipblasSrotmg__retval,)


@cython.embedsignature(True)
def hipblasDrotmg(object handle, object d1, object d2, object x1, object y1, object param):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        d1 (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        d2 (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        x1 (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        y1 (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        param (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)
    """
    _hipblasDrotmg__retval = hipblasStatus_t(chipblas.hipblasDrotmg(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,
        <double *>hip._util.types.Pointer.fromPyobj(d1)._ptr,
        <double *>hip._util.types.Pointer.fromPyobj(d2)._ptr,
        <double *>hip._util.types.Pointer.fromPyobj(x1)._ptr,
        <const double *>hip._util.types.Pointer.fromPyobj(y1)._ptr,
        <double *>hip._util.types.Pointer.fromPyobj(param)._ptr))
    return (_hipblasDrotmg__retval,)


@cython.embedsignature(True)
def hipblasSrotmg_64(object handle, object d1, object d2, object x1, object y1, object param):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        d1 (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        d2 (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        x1 (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        y1 (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        param (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)
    """
    _hipblasSrotmg_64__retval = hipblasStatus_t(chipblas.hipblasSrotmg_64(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,
        <float *>hip._util.types.Pointer.fromPyobj(d1)._ptr,
        <float *>hip._util.types.Pointer.fromPyobj(d2)._ptr,
        <float *>hip._util.types.Pointer.fromPyobj(x1)._ptr,
        <const float *>hip._util.types.Pointer.fromPyobj(y1)._ptr,
        <float *>hip._util.types.Pointer.fromPyobj(param)._ptr))
    return (_hipblasSrotmg_64__retval,)


@cython.embedsignature(True)
def hipblasDrotmg_64(object handle, object d1, object d2, object x1, object y1, object param):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        d1 (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        d2 (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        x1 (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        y1 (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        param (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)
    """
    _hipblasDrotmg_64__retval = hipblasStatus_t(chipblas.hipblasDrotmg_64(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,
        <double *>hip._util.types.Pointer.fromPyobj(d1)._ptr,
        <double *>hip._util.types.Pointer.fromPyobj(d2)._ptr,
        <double *>hip._util.types.Pointer.fromPyobj(x1)._ptr,
        <const double *>hip._util.types.Pointer.fromPyobj(y1)._ptr,
        <double *>hip._util.types.Pointer.fromPyobj(param)._ptr))
    return (_hipblasDrotmg_64__retval,)


@cython.embedsignature(True)
def hipblasSrotmgBatched(object handle, object d1, object d2, object x1, object y1, object param, int batchCount):
    r"""BLAS Level 1 API

    @{

    rotmgBatched creates the modified Givens rotation matrix for the batched vectors (d1_i * x1_i, d2_i * y1_i), for i = 1, ..., batchCount.
    Parameters may be stored in either host or device memory, location is specified by calling hipblasSetPointerMode.
    If the pointer mode is set to HIPBLAS_POINTER_MODE_HOST, this function blocks the CPU until the GPU has finished and the results are available in host memory.
    If the pointer mode is set to HIPBLAS_POINTER_MODE_DEVICE, this function returns immediately and synchronization is required to read the results.

    - Supported precisions in rocBLAS : s,d
    - Supported precisions in cuBLAS  : No support

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`) -- *IN*:
            [hipblasHandle_t]
            handle to the hipblas library context queue.

        d1 (`~.hip._util.types.Pointer`/`~.object`) -- *INOUT*:
            device batched array or host batched array of input scalars that is overwritten.

        d2 (`~.hip._util.types.Pointer`/`~.object`) -- *INOUT*:
            device batched array or host batched array of input scalars that is overwritten.

        x1 (`~.hip._util.types.Pointer`/`~.object`) -- *INOUT*:
            device batched array or host batched array of input scalars that is overwritten.

        y1 (`~.hip._util.types.Pointer`/`~.object`) -- *IN*:
            device batched array or host batched array of input scalars.

        param (`~.hip._util.types.Pointer`/`~.object`) -- *OUT*:
            device batched array or host batched array of vectors of 5 elements defining the rotation.
            param[0] = flag
            param[1] = H11
            param[2] = H21
            param[3] = H12
            param[4] = H22
            The flag parameter defines the form of H:
            flag = -1 => H = ( H11 H12 H21 H22 )
            flag =  0 => H = ( 1.0 H12 H21 1.0 )
            flag =  1 => H = ( H11 1.0 -1.0 H22 )
            flag = -2 => H = ( 1.0 0.0 0.0 1.0 )
            param may be stored in either host or device memory, location is specified by calling hipblasSetPointerMode.

        batchCount (`~.int`) -- *IN*:
            [int]
            the number of instances in the batch.
    """
    _hipblasSrotmgBatched__retval = hipblasStatus_t(chipblas.hipblasSrotmgBatched(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,
        <float *const*>hip._util.types.Pointer.fromPyobj(d1)._ptr,
        <float *const*>hip._util.types.Pointer.fromPyobj(d2)._ptr,
        <float *const*>hip._util.types.Pointer.fromPyobj(x1)._ptr,
        <const float *const*>hip._util.types.Pointer.fromPyobj(y1)._ptr,
        <float *const*>hip._util.types.Pointer.fromPyobj(param)._ptr,batchCount))
    return (_hipblasSrotmgBatched__retval,)


@cython.embedsignature(True)
def hipblasDrotmgBatched(object handle, object d1, object d2, object x1, object y1, object param, int batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        d1 (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        d2 (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        x1 (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        y1 (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        param (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    _hipblasDrotmgBatched__retval = hipblasStatus_t(chipblas.hipblasDrotmgBatched(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,
        <double *const*>hip._util.types.Pointer.fromPyobj(d1)._ptr,
        <double *const*>hip._util.types.Pointer.fromPyobj(d2)._ptr,
        <double *const*>hip._util.types.Pointer.fromPyobj(x1)._ptr,
        <const double *const*>hip._util.types.Pointer.fromPyobj(y1)._ptr,
        <double *const*>hip._util.types.Pointer.fromPyobj(param)._ptr,batchCount))
    return (_hipblasDrotmgBatched__retval,)


@cython.embedsignature(True)
def hipblasSrotmgBatched_64(object handle, object d1, object d2, object x1, object y1, object param, long batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        d1 (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        d2 (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        x1 (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        y1 (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        param (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    _hipblasSrotmgBatched_64__retval = hipblasStatus_t(chipblas.hipblasSrotmgBatched_64(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,
        <float *const*>hip._util.types.Pointer.fromPyobj(d1)._ptr,
        <float *const*>hip._util.types.Pointer.fromPyobj(d2)._ptr,
        <float *const*>hip._util.types.Pointer.fromPyobj(x1)._ptr,
        <const float *const*>hip._util.types.Pointer.fromPyobj(y1)._ptr,
        <float *const*>hip._util.types.Pointer.fromPyobj(param)._ptr,batchCount))
    return (_hipblasSrotmgBatched_64__retval,)


@cython.embedsignature(True)
def hipblasDrotmgBatched_64(object handle, object d1, object d2, object x1, object y1, object param, long batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        d1 (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        d2 (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        x1 (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        y1 (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        param (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    _hipblasDrotmgBatched_64__retval = hipblasStatus_t(chipblas.hipblasDrotmgBatched_64(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,
        <double *const*>hip._util.types.Pointer.fromPyobj(d1)._ptr,
        <double *const*>hip._util.types.Pointer.fromPyobj(d2)._ptr,
        <double *const*>hip._util.types.Pointer.fromPyobj(x1)._ptr,
        <const double *const*>hip._util.types.Pointer.fromPyobj(y1)._ptr,
        <double *const*>hip._util.types.Pointer.fromPyobj(param)._ptr,batchCount))
    return (_hipblasDrotmgBatched_64__retval,)


@cython.embedsignature(True)
def hipblasSrotmgStridedBatched(object handle, object d1, long strided1, object d2, long strided2, object x1, long stridex1, object y1, long stridey1, object param, long strideParam, int batchCount):
    r"""BLAS Level 1 API

    @{

    rotmgStridedBatched creates the modified Givens rotation matrix for the strided batched vectors (d1_i * x1_i, d2_i * y1_i), for i = 1, ..., batchCount.
    Parameters may be stored in either host or device memory, location is specified by calling hipblasSetPointerMode.
    If the pointer mode is set to HIPBLAS_POINTER_MODE_HOST, this function blocks the CPU until the GPU has finished and the results are available in host memory.
    If the pointer mode is set to HIPBLAS_POINTER_MODE_DEVICE, this function returns immediately and synchronization is required to read the results.

    - Supported precisions in rocBLAS : s,d
    - Supported precisions in cuBLAS  : No support

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`) -- *IN*:
            [hipblasHandle_t]
            handle to the hipblas library context queue.

        d1 (`~.hip._util.types.Pointer`/`~.object`) -- *INOUT*:
            device strided_batched array or host strided_batched array of input scalars that is overwritten.

        strided1 (`~.int`) -- *IN*:
            [hipblasStride]
            specifies the increment between the beginning of d1_i and d1_(i+1)

        d2 (`~.hip._util.types.Pointer`/`~.object`) -- *INOUT*:
            device strided_batched array or host strided_batched array of input scalars that is overwritten.

        strided2 (`~.int`) -- *IN*:
            [hipblasStride]
            specifies the increment between the beginning of d2_i and d2_(i+1)

        x1 (`~.hip._util.types.Pointer`/`~.object`) -- *INOUT*:
            device strided_batched array or host strided_batched array of input scalars that is overwritten.

        stridex1 (`~.int`) -- *IN*:
            [hipblasStride]
            specifies the increment between the beginning of x1_i and x1_(i+1)

        y1 (`~.hip._util.types.Pointer`/`~.object`) -- *IN*:
            device strided_batched array or host strided_batched array of input scalars.

        stridey1 (`~.int`) -- *IN*:
            [hipblasStride]
            specifies the increment between the beginning of y1_i and y1_(i+1)

        param (`~.hip._util.types.Pointer`/`~.object`) -- *OUT*:
            device stridedBatched array or host stridedBatched array of vectors of 5 elements defining the rotation.
            param[0] = flag
            param[1] = H11
            param[2] = H21
            param[3] = H12
            param[4] = H22
            The flag parameter defines the form of H:
            flag = -1 => H = ( H11 H12 H21 H22 )
            flag =  0 => H = ( 1.0 H12 H21 1.0 )
            flag =  1 => H = ( H11 1.0 -1.0 H22 )
            flag = -2 => H = ( 1.0 0.0 0.0 1.0 )
            param may be stored in either host or device memory, location is specified by calling hipblasSetPointerMode.

        strideParam (`~.int`) -- *IN*:
            [hipblasStride]
            specifies the increment between the beginning of param_i and param_(i + 1)

        batchCount (`~.int`) -- *IN*:
            [int]
            the number of instances in the batch.
    """
    _hipblasSrotmgStridedBatched__retval = hipblasStatus_t(chipblas.hipblasSrotmgStridedBatched(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,
        <float *>hip._util.types.Pointer.fromPyobj(d1)._ptr,strided1,
        <float *>hip._util.types.Pointer.fromPyobj(d2)._ptr,strided2,
        <float *>hip._util.types.Pointer.fromPyobj(x1)._ptr,stridex1,
        <const float *>hip._util.types.Pointer.fromPyobj(y1)._ptr,stridey1,
        <float *>hip._util.types.Pointer.fromPyobj(param)._ptr,strideParam,batchCount))
    return (_hipblasSrotmgStridedBatched__retval,)


@cython.embedsignature(True)
def hipblasDrotmgStridedBatched(object handle, object d1, long strided1, object d2, long strided2, object x1, long stridex1, object y1, long stridey1, object param, long strideParam, int batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        d1 (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        strided1 (`~.int`):
            (undocumented)

        d2 (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        strided2 (`~.int`):
            (undocumented)

        x1 (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        stridex1 (`~.int`):
            (undocumented)

        y1 (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        stridey1 (`~.int`):
            (undocumented)

        param (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        strideParam (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    _hipblasDrotmgStridedBatched__retval = hipblasStatus_t(chipblas.hipblasDrotmgStridedBatched(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,
        <double *>hip._util.types.Pointer.fromPyobj(d1)._ptr,strided1,
        <double *>hip._util.types.Pointer.fromPyobj(d2)._ptr,strided2,
        <double *>hip._util.types.Pointer.fromPyobj(x1)._ptr,stridex1,
        <const double *>hip._util.types.Pointer.fromPyobj(y1)._ptr,stridey1,
        <double *>hip._util.types.Pointer.fromPyobj(param)._ptr,strideParam,batchCount))
    return (_hipblasDrotmgStridedBatched__retval,)


@cython.embedsignature(True)
def hipblasSrotmgStridedBatched_64(object handle, object d1, long strided1, object d2, long strided2, object x1, long stridex1, object y1, long stridey1, object param, long strideParam, long batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        d1 (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        strided1 (`~.int`):
            (undocumented)

        d2 (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        strided2 (`~.int`):
            (undocumented)

        x1 (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        stridex1 (`~.int`):
            (undocumented)

        y1 (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        stridey1 (`~.int`):
            (undocumented)

        param (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        strideParam (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    _hipblasSrotmgStridedBatched_64__retval = hipblasStatus_t(chipblas.hipblasSrotmgStridedBatched_64(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,
        <float *>hip._util.types.Pointer.fromPyobj(d1)._ptr,strided1,
        <float *>hip._util.types.Pointer.fromPyobj(d2)._ptr,strided2,
        <float *>hip._util.types.Pointer.fromPyobj(x1)._ptr,stridex1,
        <const float *>hip._util.types.Pointer.fromPyobj(y1)._ptr,stridey1,
        <float *>hip._util.types.Pointer.fromPyobj(param)._ptr,strideParam,batchCount))
    return (_hipblasSrotmgStridedBatched_64__retval,)


@cython.embedsignature(True)
def hipblasDrotmgStridedBatched_64(object handle, object d1, long strided1, object d2, long strided2, object x1, long stridex1, object y1, long stridey1, object param, long strideParam, long batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        d1 (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        strided1 (`~.int`):
            (undocumented)

        d2 (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        strided2 (`~.int`):
            (undocumented)

        x1 (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        stridex1 (`~.int`):
            (undocumented)

        y1 (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        stridey1 (`~.int`):
            (undocumented)

        param (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        strideParam (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    _hipblasDrotmgStridedBatched_64__retval = hipblasStatus_t(chipblas.hipblasDrotmgStridedBatched_64(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,
        <double *>hip._util.types.Pointer.fromPyobj(d1)._ptr,strided1,
        <double *>hip._util.types.Pointer.fromPyobj(d2)._ptr,strided2,
        <double *>hip._util.types.Pointer.fromPyobj(x1)._ptr,stridex1,
        <const double *>hip._util.types.Pointer.fromPyobj(y1)._ptr,stridey1,
        <double *>hip._util.types.Pointer.fromPyobj(param)._ptr,strideParam,batchCount))
    return (_hipblasDrotmgStridedBatched_64__retval,)


@cython.embedsignature(True)
def hipblasSscal(object handle, int n, object alpha, object x, int incx):
    r"""BLAS Level 1 API

    @{

    scal  scales each element of vector x with scalar alpha.

    x := alpha * x

    - Supported precisions in rocBLAS : s,d,c,z,cs,zd
    - Supported precisions in cuBLAS  : s,d,c,z,cs,zd

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`) -- *IN*:
            [hipblasHandle_t]
            handle to the hipblas library context queue.

        n (`~.int`) -- *IN*:
            [int]
            the number of elements in x.

        alpha (`~.hip._util.types.Pointer`/`~.object`) -- *IN*:
            device pointer or host pointer for the scalar alpha.

        x (`~.hip._util.types.Pointer`/`~.object`) -- *INOUT*:
            device pointer storing vector x.

        incx (`~.int`) -- *IN*:
            [int]
            specifies the increment for the elements of x.
    """
    _hipblasSscal__retval = hipblasStatus_t(chipblas.hipblasSscal(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,n,
        <const float *>hip._util.types.Pointer.fromPyobj(alpha)._ptr,
        <float *>hip._util.types.Pointer.fromPyobj(x)._ptr,incx))
    return (_hipblasSscal__retval,)


@cython.embedsignature(True)
def hipblasDscal(object handle, int n, object alpha, object x, int incx):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        alpha (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        x (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)
    """
    _hipblasDscal__retval = hipblasStatus_t(chipblas.hipblasDscal(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,n,
        <const double *>hip._util.types.Pointer.fromPyobj(alpha)._ptr,
        <double *>hip._util.types.Pointer.fromPyobj(x)._ptr,incx))
    return (_hipblasDscal__retval,)


@cython.embedsignature(True)
def hipblasCscal(object handle, int n, object alpha, object x, int incx):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        alpha (`~.hipblasComplex`/`~.object`):
            (undocumented)

        x (`~.hipblasComplex`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)
    """
    _hipblasCscal__retval = hipblasStatus_t(chipblas.hipblasCscal(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,n,
        hipblasComplex.fromPyobj(alpha).getElementPtr(),
        hipblasComplex.fromPyobj(x).getElementPtr(),incx))
    return (_hipblasCscal__retval,)


@cython.embedsignature(True)
def hipblasCsscal(object handle, int n, object alpha, object x, int incx):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        alpha (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        x (`~.hipblasComplex`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)
    """
    _hipblasCsscal__retval = hipblasStatus_t(chipblas.hipblasCsscal(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,n,
        <const float *>hip._util.types.Pointer.fromPyobj(alpha)._ptr,
        hipblasComplex.fromPyobj(x).getElementPtr(),incx))
    return (_hipblasCsscal__retval,)


@cython.embedsignature(True)
def hipblasZscal(object handle, int n, object alpha, object x, int incx):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        alpha (`~.hipblasDoubleComplex`/`~.object`):
            (undocumented)

        x (`~.hipblasDoubleComplex`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)
    """
    _hipblasZscal__retval = hipblasStatus_t(chipblas.hipblasZscal(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,n,
        hipblasDoubleComplex.fromPyobj(alpha).getElementPtr(),
        hipblasDoubleComplex.fromPyobj(x).getElementPtr(),incx))
    return (_hipblasZscal__retval,)


@cython.embedsignature(True)
def hipblasZdscal(object handle, int n, object alpha, object x, int incx):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        alpha (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        x (`~.hipblasDoubleComplex`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)
    """
    _hipblasZdscal__retval = hipblasStatus_t(chipblas.hipblasZdscal(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,n,
        <const double *>hip._util.types.Pointer.fromPyobj(alpha)._ptr,
        hipblasDoubleComplex.fromPyobj(x).getElementPtr(),incx))
    return (_hipblasZdscal__retval,)


@cython.embedsignature(True)
def hipblasCscal_v2(object handle, int n, object alpha, object x, int incx):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        alpha (`~.float2`/`~.object`):
            (undocumented)

        x (`~.float2`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)
    """
    _hipblasCscal_v2__retval = hipblasStatus_t(chipblas.hipblasCscal_v2(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,n,
        float2.fromPyobj(alpha).getElementPtr(),
        float2.fromPyobj(x).getElementPtr(),incx))
    return (_hipblasCscal_v2__retval,)


@cython.embedsignature(True)
def hipblasCsscal_v2(object handle, int n, object alpha, object x, int incx):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        alpha (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        x (`~.float2`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)
    """
    _hipblasCsscal_v2__retval = hipblasStatus_t(chipblas.hipblasCsscal_v2(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,n,
        <const float *>hip._util.types.Pointer.fromPyobj(alpha)._ptr,
        float2.fromPyobj(x).getElementPtr(),incx))
    return (_hipblasCsscal_v2__retval,)


@cython.embedsignature(True)
def hipblasZscal_v2(object handle, int n, object alpha, object x, int incx):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        alpha (`~.double2`/`~.object`):
            (undocumented)

        x (`~.double2`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)
    """
    _hipblasZscal_v2__retval = hipblasStatus_t(chipblas.hipblasZscal_v2(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,n,
        double2.fromPyobj(alpha).getElementPtr(),
        double2.fromPyobj(x).getElementPtr(),incx))
    return (_hipblasZscal_v2__retval,)


@cython.embedsignature(True)
def hipblasZdscal_v2(object handle, int n, object alpha, object x, int incx):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        alpha (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        x (`~.double2`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)
    """
    _hipblasZdscal_v2__retval = hipblasStatus_t(chipblas.hipblasZdscal_v2(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,n,
        <const double *>hip._util.types.Pointer.fromPyobj(alpha)._ptr,
        double2.fromPyobj(x).getElementPtr(),incx))
    return (_hipblasZdscal_v2__retval,)


@cython.embedsignature(True)
def hipblasSscal_64(object handle, long n, object alpha, object x, long incx):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        alpha (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        x (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)
    """
    _hipblasSscal_64__retval = hipblasStatus_t(chipblas.hipblasSscal_64(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,n,
        <const float *>hip._util.types.Pointer.fromPyobj(alpha)._ptr,
        <float *>hip._util.types.Pointer.fromPyobj(x)._ptr,incx))
    return (_hipblasSscal_64__retval,)


@cython.embedsignature(True)
def hipblasDscal_64(object handle, long n, object alpha, object x, long incx):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        alpha (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        x (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)
    """
    _hipblasDscal_64__retval = hipblasStatus_t(chipblas.hipblasDscal_64(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,n,
        <const double *>hip._util.types.Pointer.fromPyobj(alpha)._ptr,
        <double *>hip._util.types.Pointer.fromPyobj(x)._ptr,incx))
    return (_hipblasDscal_64__retval,)


@cython.embedsignature(True)
def hipblasCscal_64(object handle, long n, object alpha, object x, long incx):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        alpha (`~.hipblasComplex`/`~.object`):
            (undocumented)

        x (`~.hipblasComplex`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)
    """
    _hipblasCscal_64__retval = hipblasStatus_t(chipblas.hipblasCscal_64(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,n,
        hipblasComplex.fromPyobj(alpha).getElementPtr(),
        hipblasComplex.fromPyobj(x).getElementPtr(),incx))
    return (_hipblasCscal_64__retval,)


@cython.embedsignature(True)
def hipblasCsscal_64(object handle, long n, object alpha, object x, long incx):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        alpha (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        x (`~.hipblasComplex`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)
    """
    _hipblasCsscal_64__retval = hipblasStatus_t(chipblas.hipblasCsscal_64(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,n,
        <const float *>hip._util.types.Pointer.fromPyobj(alpha)._ptr,
        hipblasComplex.fromPyobj(x).getElementPtr(),incx))
    return (_hipblasCsscal_64__retval,)


@cython.embedsignature(True)
def hipblasZscal_64(object handle, long n, object alpha, object x, long incx):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        alpha (`~.hipblasDoubleComplex`/`~.object`):
            (undocumented)

        x (`~.hipblasDoubleComplex`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)
    """
    _hipblasZscal_64__retval = hipblasStatus_t(chipblas.hipblasZscal_64(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,n,
        hipblasDoubleComplex.fromPyobj(alpha).getElementPtr(),
        hipblasDoubleComplex.fromPyobj(x).getElementPtr(),incx))
    return (_hipblasZscal_64__retval,)


@cython.embedsignature(True)
def hipblasZdscal_64(object handle, long n, object alpha, object x, long incx):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        alpha (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        x (`~.hipblasDoubleComplex`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)
    """
    _hipblasZdscal_64__retval = hipblasStatus_t(chipblas.hipblasZdscal_64(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,n,
        <const double *>hip._util.types.Pointer.fromPyobj(alpha)._ptr,
        hipblasDoubleComplex.fromPyobj(x).getElementPtr(),incx))
    return (_hipblasZdscal_64__retval,)


@cython.embedsignature(True)
def hipblasCscal_v2_64(object handle, long n, object alpha, object x, long incx):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        alpha (`~.float2`/`~.object`):
            (undocumented)

        x (`~.float2`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)
    """
    _hipblasCscal_v2_64__retval = hipblasStatus_t(chipblas.hipblasCscal_v2_64(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,n,
        float2.fromPyobj(alpha).getElementPtr(),
        float2.fromPyobj(x).getElementPtr(),incx))
    return (_hipblasCscal_v2_64__retval,)


@cython.embedsignature(True)
def hipblasCsscal_v2_64(object handle, long n, object alpha, object x, long incx):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        alpha (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        x (`~.float2`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)
    """
    _hipblasCsscal_v2_64__retval = hipblasStatus_t(chipblas.hipblasCsscal_v2_64(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,n,
        <const float *>hip._util.types.Pointer.fromPyobj(alpha)._ptr,
        float2.fromPyobj(x).getElementPtr(),incx))
    return (_hipblasCsscal_v2_64__retval,)


@cython.embedsignature(True)
def hipblasZscal_v2_64(object handle, long n, object alpha, object x, long incx):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        alpha (`~.double2`/`~.object`):
            (undocumented)

        x (`~.double2`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)
    """
    _hipblasZscal_v2_64__retval = hipblasStatus_t(chipblas.hipblasZscal_v2_64(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,n,
        double2.fromPyobj(alpha).getElementPtr(),
        double2.fromPyobj(x).getElementPtr(),incx))
    return (_hipblasZscal_v2_64__retval,)


@cython.embedsignature(True)
def hipblasZdscal_v2_64(object handle, long n, object alpha, object x, long incx):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        alpha (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        x (`~.double2`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)
    """
    _hipblasZdscal_v2_64__retval = hipblasStatus_t(chipblas.hipblasZdscal_v2_64(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,n,
        <const double *>hip._util.types.Pointer.fromPyobj(alpha)._ptr,
        double2.fromPyobj(x).getElementPtr(),incx))
    return (_hipblasZdscal_v2_64__retval,)


@cython.embedsignature(True)
def hipblasSscalBatched(object handle, int n, object alpha, object x, int incx, int batchCount):
    r"""BLAS Level 1 API

    @{

    scalBatched  scales each element of vector x_i with scalar alpha, for i = 1, ... , batchCount.

    x_i := alpha * x_i

     where (x_i) is the i-th instance of the batch.

    - Supported precisions in rocBLAS : s,d,c,z,cs,zd
    - Supported precisions in cuBLAS  : No support

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`) -- *IN*:
            [hipblasHandle_t]
            handle to the hipblas library context queue.

        n (`~.int`) -- *IN*:
            [int]
            the number of elements in each x_i.

        alpha (`~.hip._util.types.Pointer`/`~.object`) -- *IN*:
            host pointer or device pointer for the scalar alpha.

        x (`~.hip._util.types.ListOfPointer`/`~.object`) -- *INOUT*:
            device array of device pointers storing each vector x_i.

        incx (`~.int`) -- *IN*:
            [int]
            specifies the increment for the elements of each x_i.

        batchCount (`~.int`) -- *IN*:
            [int]
            specifies the number of batches in x.
    """
    _hipblasSscalBatched__retval = hipblasStatus_t(chipblas.hipblasSscalBatched(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,n,
        <const float *>hip._util.types.Pointer.fromPyobj(alpha)._ptr,
        <float *const*>hip._util.types.ListOfPointer.fromPyobj(x)._ptr,incx,batchCount))
    return (_hipblasSscalBatched__retval,)


@cython.embedsignature(True)
def hipblasDscalBatched(object handle, int n, object alpha, object x, int incx, int batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        alpha (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        x (`~.hip._util.types.ListOfPointer`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    _hipblasDscalBatched__retval = hipblasStatus_t(chipblas.hipblasDscalBatched(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,n,
        <const double *>hip._util.types.Pointer.fromPyobj(alpha)._ptr,
        <double *const*>hip._util.types.ListOfPointer.fromPyobj(x)._ptr,incx,batchCount))
    return (_hipblasDscalBatched__retval,)


@cython.embedsignature(True)
def hipblasCscalBatched(object handle, int n, object alpha, object x, int incx, int batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        alpha (`~.hipblasComplex`/`~.object`):
            (undocumented)

        x (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    _hipblasCscalBatched__retval = hipblasStatus_t(chipblas.hipblasCscalBatched(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,n,
        hipblasComplex.fromPyobj(alpha).getElementPtr(),
        <chipblas.hipblasComplex *const*>hip._util.types.Pointer.fromPyobj(x)._ptr,incx,batchCount))
    return (_hipblasCscalBatched__retval,)


@cython.embedsignature(True)
def hipblasZscalBatched(object handle, int n, object alpha, object x, int incx, int batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        alpha (`~.hipblasDoubleComplex`/`~.object`):
            (undocumented)

        x (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    _hipblasZscalBatched__retval = hipblasStatus_t(chipblas.hipblasZscalBatched(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,n,
        hipblasDoubleComplex.fromPyobj(alpha).getElementPtr(),
        <chipblas.hipblasDoubleComplex *const*>hip._util.types.Pointer.fromPyobj(x)._ptr,incx,batchCount))
    return (_hipblasZscalBatched__retval,)


@cython.embedsignature(True)
def hipblasCsscalBatched(object handle, int n, object alpha, object x, int incx, int batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        alpha (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        x (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    _hipblasCsscalBatched__retval = hipblasStatus_t(chipblas.hipblasCsscalBatched(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,n,
        <const float *>hip._util.types.Pointer.fromPyobj(alpha)._ptr,
        <chipblas.hipblasComplex *const*>hip._util.types.Pointer.fromPyobj(x)._ptr,incx,batchCount))
    return (_hipblasCsscalBatched__retval,)


@cython.embedsignature(True)
def hipblasZdscalBatched(object handle, int n, object alpha, object x, int incx, int batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        alpha (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        x (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    _hipblasZdscalBatched__retval = hipblasStatus_t(chipblas.hipblasZdscalBatched(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,n,
        <const double *>hip._util.types.Pointer.fromPyobj(alpha)._ptr,
        <chipblas.hipblasDoubleComplex *const*>hip._util.types.Pointer.fromPyobj(x)._ptr,incx,batchCount))
    return (_hipblasZdscalBatched__retval,)


@cython.embedsignature(True)
def hipblasCscalBatched_v2(object handle, int n, object alpha, object x, int incx, int batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        alpha (`~.float2`/`~.object`):
            (undocumented)

        x (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    _hipblasCscalBatched_v2__retval = hipblasStatus_t(chipblas.hipblasCscalBatched_v2(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,n,
        float2.fromPyobj(alpha).getElementPtr(),
        <chipblas.float2 *const*>hip._util.types.Pointer.fromPyobj(x)._ptr,incx,batchCount))
    return (_hipblasCscalBatched_v2__retval,)


@cython.embedsignature(True)
def hipblasZscalBatched_v2(object handle, int n, object alpha, object x, int incx, int batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        alpha (`~.double2`/`~.object`):
            (undocumented)

        x (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    _hipblasZscalBatched_v2__retval = hipblasStatus_t(chipblas.hipblasZscalBatched_v2(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,n,
        double2.fromPyobj(alpha).getElementPtr(),
        <chipblas.double2 *const*>hip._util.types.Pointer.fromPyobj(x)._ptr,incx,batchCount))
    return (_hipblasZscalBatched_v2__retval,)


@cython.embedsignature(True)
def hipblasCsscalBatched_v2(object handle, int n, object alpha, object x, int incx, int batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        alpha (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        x (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    _hipblasCsscalBatched_v2__retval = hipblasStatus_t(chipblas.hipblasCsscalBatched_v2(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,n,
        <const float *>hip._util.types.Pointer.fromPyobj(alpha)._ptr,
        <chipblas.float2 *const*>hip._util.types.Pointer.fromPyobj(x)._ptr,incx,batchCount))
    return (_hipblasCsscalBatched_v2__retval,)


@cython.embedsignature(True)
def hipblasZdscalBatched_v2(object handle, int n, object alpha, object x, int incx, int batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        alpha (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        x (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    _hipblasZdscalBatched_v2__retval = hipblasStatus_t(chipblas.hipblasZdscalBatched_v2(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,n,
        <const double *>hip._util.types.Pointer.fromPyobj(alpha)._ptr,
        <chipblas.double2 *const*>hip._util.types.Pointer.fromPyobj(x)._ptr,incx,batchCount))
    return (_hipblasZdscalBatched_v2__retval,)


@cython.embedsignature(True)
def hipblasSscalBatched_64(object handle, long n, object alpha, object x, long incx, long batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        alpha (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        x (`~.hip._util.types.ListOfPointer`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    _hipblasSscalBatched_64__retval = hipblasStatus_t(chipblas.hipblasSscalBatched_64(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,n,
        <const float *>hip._util.types.Pointer.fromPyobj(alpha)._ptr,
        <float *const*>hip._util.types.ListOfPointer.fromPyobj(x)._ptr,incx,batchCount))
    return (_hipblasSscalBatched_64__retval,)


@cython.embedsignature(True)
def hipblasDscalBatched_64(object handle, long n, object alpha, object x, long incx, long batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        alpha (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        x (`~.hip._util.types.ListOfPointer`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    _hipblasDscalBatched_64__retval = hipblasStatus_t(chipblas.hipblasDscalBatched_64(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,n,
        <const double *>hip._util.types.Pointer.fromPyobj(alpha)._ptr,
        <double *const*>hip._util.types.ListOfPointer.fromPyobj(x)._ptr,incx,batchCount))
    return (_hipblasDscalBatched_64__retval,)


@cython.embedsignature(True)
def hipblasCscalBatched_64(object handle, long n, object alpha, object x, long incx, long batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        alpha (`~.hipblasComplex`/`~.object`):
            (undocumented)

        x (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    _hipblasCscalBatched_64__retval = hipblasStatus_t(chipblas.hipblasCscalBatched_64(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,n,
        hipblasComplex.fromPyobj(alpha).getElementPtr(),
        <chipblas.hipblasComplex *const*>hip._util.types.Pointer.fromPyobj(x)._ptr,incx,batchCount))
    return (_hipblasCscalBatched_64__retval,)


@cython.embedsignature(True)
def hipblasZscalBatched_64(object handle, long n, object alpha, object x, long incx, long batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        alpha (`~.hipblasDoubleComplex`/`~.object`):
            (undocumented)

        x (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    _hipblasZscalBatched_64__retval = hipblasStatus_t(chipblas.hipblasZscalBatched_64(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,n,
        hipblasDoubleComplex.fromPyobj(alpha).getElementPtr(),
        <chipblas.hipblasDoubleComplex *const*>hip._util.types.Pointer.fromPyobj(x)._ptr,incx,batchCount))
    return (_hipblasZscalBatched_64__retval,)


@cython.embedsignature(True)
def hipblasCsscalBatched_64(object handle, long n, object alpha, object x, long incx, long batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        alpha (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        x (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    _hipblasCsscalBatched_64__retval = hipblasStatus_t(chipblas.hipblasCsscalBatched_64(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,n,
        <const float *>hip._util.types.Pointer.fromPyobj(alpha)._ptr,
        <chipblas.hipblasComplex *const*>hip._util.types.Pointer.fromPyobj(x)._ptr,incx,batchCount))
    return (_hipblasCsscalBatched_64__retval,)


@cython.embedsignature(True)
def hipblasZdscalBatched_64(object handle, long n, object alpha, object x, long incx, long batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        alpha (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        x (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    _hipblasZdscalBatched_64__retval = hipblasStatus_t(chipblas.hipblasZdscalBatched_64(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,n,
        <const double *>hip._util.types.Pointer.fromPyobj(alpha)._ptr,
        <chipblas.hipblasDoubleComplex *const*>hip._util.types.Pointer.fromPyobj(x)._ptr,incx,batchCount))
    return (_hipblasZdscalBatched_64__retval,)


@cython.embedsignature(True)
def hipblasCscalBatched_v2_64(object handle, long n, object alpha, object x, long incx, long batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        alpha (`~.float2`/`~.object`):
            (undocumented)

        x (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    _hipblasCscalBatched_v2_64__retval = hipblasStatus_t(chipblas.hipblasCscalBatched_v2_64(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,n,
        float2.fromPyobj(alpha).getElementPtr(),
        <chipblas.float2 *const*>hip._util.types.Pointer.fromPyobj(x)._ptr,incx,batchCount))
    return (_hipblasCscalBatched_v2_64__retval,)


@cython.embedsignature(True)
def hipblasZscalBatched_v2_64(object handle, long n, object alpha, object x, long incx, long batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        alpha (`~.double2`/`~.object`):
            (undocumented)

        x (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    _hipblasZscalBatched_v2_64__retval = hipblasStatus_t(chipblas.hipblasZscalBatched_v2_64(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,n,
        double2.fromPyobj(alpha).getElementPtr(),
        <chipblas.double2 *const*>hip._util.types.Pointer.fromPyobj(x)._ptr,incx,batchCount))
    return (_hipblasZscalBatched_v2_64__retval,)


@cython.embedsignature(True)
def hipblasCsscalBatched_v2_64(object handle, long n, object alpha, object x, long incx, long batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        alpha (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        x (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    _hipblasCsscalBatched_v2_64__retval = hipblasStatus_t(chipblas.hipblasCsscalBatched_v2_64(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,n,
        <const float *>hip._util.types.Pointer.fromPyobj(alpha)._ptr,
        <chipblas.float2 *const*>hip._util.types.Pointer.fromPyobj(x)._ptr,incx,batchCount))
    return (_hipblasCsscalBatched_v2_64__retval,)


@cython.embedsignature(True)
def hipblasZdscalBatched_v2_64(object handle, long n, object alpha, object x, long incx, long batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        alpha (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        x (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    _hipblasZdscalBatched_v2_64__retval = hipblasStatus_t(chipblas.hipblasZdscalBatched_v2_64(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,n,
        <const double *>hip._util.types.Pointer.fromPyobj(alpha)._ptr,
        <chipblas.double2 *const*>hip._util.types.Pointer.fromPyobj(x)._ptr,incx,batchCount))
    return (_hipblasZdscalBatched_v2_64__retval,)


@cython.embedsignature(True)
def hipblasSscalStridedBatched(object handle, int n, object alpha, object x, int incx, long stridex, int batchCount):
    r"""BLAS Level 1 API

    @{

    scalStridedBatched  scales each element of vector x_i with scalar alpha, for i = 1, ... , batchCount.

    x_i := alpha * x_i ,

     where (x_i) is the i-th instance of the batch.

    - Supported precisions in rocBLAS : s,d,c,z,cs,zd
    - Supported precisions in cuBLAS  : No support

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`) -- *IN*:
            [hipblasHandle_t]
            handle to the hipblas library context queue.

        n (`~.int`) -- *IN*:
            [int]
            the number of elements in each x_i.

        alpha (`~.hip._util.types.Pointer`/`~.object`) -- *IN*:
            host pointer or device pointer for the scalar alpha.

        x (`~.hip._util.types.Pointer`/`~.object`) -- *INOUT*:
            device pointer to the first vector (x_1) in the batch.

        incx (`~.int`) -- *IN*:
            [int]
            specifies the increment for the elements of x.

        stridex (`~.int`) -- *IN*:
            [hipblasStride]
            stride from the start of one vector (x_i) and the next one (x_i+1).
            There are no restrictions placed on stride_x, however the user should
            take care to ensure that stride_x is of appropriate size, for a typical
            case this means stride_x >= n * incx.

        batchCount (`~.int`) -- *IN*:
            [int]
            specifies the number of batches in x.
    """
    _hipblasSscalStridedBatched__retval = hipblasStatus_t(chipblas.hipblasSscalStridedBatched(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,n,
        <const float *>hip._util.types.Pointer.fromPyobj(alpha)._ptr,
        <float *>hip._util.types.Pointer.fromPyobj(x)._ptr,incx,stridex,batchCount))
    return (_hipblasSscalStridedBatched__retval,)


@cython.embedsignature(True)
def hipblasDscalStridedBatched(object handle, int n, object alpha, object x, int incx, long stridex, int batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        alpha (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        x (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        stridex (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    _hipblasDscalStridedBatched__retval = hipblasStatus_t(chipblas.hipblasDscalStridedBatched(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,n,
        <const double *>hip._util.types.Pointer.fromPyobj(alpha)._ptr,
        <double *>hip._util.types.Pointer.fromPyobj(x)._ptr,incx,stridex,batchCount))
    return (_hipblasDscalStridedBatched__retval,)


@cython.embedsignature(True)
def hipblasCscalStridedBatched(object handle, int n, object alpha, object x, int incx, long stridex, int batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        alpha (`~.hipblasComplex`/`~.object`):
            (undocumented)

        x (`~.hipblasComplex`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        stridex (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    _hipblasCscalStridedBatched__retval = hipblasStatus_t(chipblas.hipblasCscalStridedBatched(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,n,
        hipblasComplex.fromPyobj(alpha).getElementPtr(),
        hipblasComplex.fromPyobj(x).getElementPtr(),incx,stridex,batchCount))
    return (_hipblasCscalStridedBatched__retval,)


@cython.embedsignature(True)
def hipblasZscalStridedBatched(object handle, int n, object alpha, object x, int incx, long stridex, int batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        alpha (`~.hipblasDoubleComplex`/`~.object`):
            (undocumented)

        x (`~.hipblasDoubleComplex`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        stridex (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    _hipblasZscalStridedBatched__retval = hipblasStatus_t(chipblas.hipblasZscalStridedBatched(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,n,
        hipblasDoubleComplex.fromPyobj(alpha).getElementPtr(),
        hipblasDoubleComplex.fromPyobj(x).getElementPtr(),incx,stridex,batchCount))
    return (_hipblasZscalStridedBatched__retval,)


@cython.embedsignature(True)
def hipblasCsscalStridedBatched(object handle, int n, object alpha, object x, int incx, long stridex, int batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        alpha (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        x (`~.hipblasComplex`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        stridex (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    _hipblasCsscalStridedBatched__retval = hipblasStatus_t(chipblas.hipblasCsscalStridedBatched(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,n,
        <const float *>hip._util.types.Pointer.fromPyobj(alpha)._ptr,
        hipblasComplex.fromPyobj(x).getElementPtr(),incx,stridex,batchCount))
    return (_hipblasCsscalStridedBatched__retval,)


@cython.embedsignature(True)
def hipblasZdscalStridedBatched(object handle, int n, object alpha, object x, int incx, long stridex, int batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        alpha (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        x (`~.hipblasDoubleComplex`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        stridex (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    _hipblasZdscalStridedBatched__retval = hipblasStatus_t(chipblas.hipblasZdscalStridedBatched(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,n,
        <const double *>hip._util.types.Pointer.fromPyobj(alpha)._ptr,
        hipblasDoubleComplex.fromPyobj(x).getElementPtr(),incx,stridex,batchCount))
    return (_hipblasZdscalStridedBatched__retval,)


@cython.embedsignature(True)
def hipblasCscalStridedBatched_v2(object handle, int n, object alpha, object x, int incx, long stridex, int batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        alpha (`~.float2`/`~.object`):
            (undocumented)

        x (`~.float2`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        stridex (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    _hipblasCscalStridedBatched_v2__retval = hipblasStatus_t(chipblas.hipblasCscalStridedBatched_v2(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,n,
        float2.fromPyobj(alpha).getElementPtr(),
        float2.fromPyobj(x).getElementPtr(),incx,stridex,batchCount))
    return (_hipblasCscalStridedBatched_v2__retval,)


@cython.embedsignature(True)
def hipblasZscalStridedBatched_v2(object handle, int n, object alpha, object x, int incx, long stridex, int batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        alpha (`~.double2`/`~.object`):
            (undocumented)

        x (`~.double2`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        stridex (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    _hipblasZscalStridedBatched_v2__retval = hipblasStatus_t(chipblas.hipblasZscalStridedBatched_v2(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,n,
        double2.fromPyobj(alpha).getElementPtr(),
        double2.fromPyobj(x).getElementPtr(),incx,stridex,batchCount))
    return (_hipblasZscalStridedBatched_v2__retval,)


@cython.embedsignature(True)
def hipblasCsscalStridedBatched_v2(object handle, int n, object alpha, object x, int incx, long stridex, int batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        alpha (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        x (`~.float2`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        stridex (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    _hipblasCsscalStridedBatched_v2__retval = hipblasStatus_t(chipblas.hipblasCsscalStridedBatched_v2(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,n,
        <const float *>hip._util.types.Pointer.fromPyobj(alpha)._ptr,
        float2.fromPyobj(x).getElementPtr(),incx,stridex,batchCount))
    return (_hipblasCsscalStridedBatched_v2__retval,)


@cython.embedsignature(True)
def hipblasZdscalStridedBatched_v2(object handle, int n, object alpha, object x, int incx, long stridex, int batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        alpha (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        x (`~.double2`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        stridex (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    _hipblasZdscalStridedBatched_v2__retval = hipblasStatus_t(chipblas.hipblasZdscalStridedBatched_v2(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,n,
        <const double *>hip._util.types.Pointer.fromPyobj(alpha)._ptr,
        double2.fromPyobj(x).getElementPtr(),incx,stridex,batchCount))
    return (_hipblasZdscalStridedBatched_v2__retval,)


@cython.embedsignature(True)
def hipblasSscalStridedBatched_64(object handle, long n, object alpha, object x, long incx, long stridex, long batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        alpha (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        x (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        stridex (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    _hipblasSscalStridedBatched_64__retval = hipblasStatus_t(chipblas.hipblasSscalStridedBatched_64(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,n,
        <const float *>hip._util.types.Pointer.fromPyobj(alpha)._ptr,
        <float *>hip._util.types.Pointer.fromPyobj(x)._ptr,incx,stridex,batchCount))
    return (_hipblasSscalStridedBatched_64__retval,)


@cython.embedsignature(True)
def hipblasDscalStridedBatched_64(object handle, long n, object alpha, object x, long incx, long stridex, long batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        alpha (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        x (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        stridex (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    _hipblasDscalStridedBatched_64__retval = hipblasStatus_t(chipblas.hipblasDscalStridedBatched_64(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,n,
        <const double *>hip._util.types.Pointer.fromPyobj(alpha)._ptr,
        <double *>hip._util.types.Pointer.fromPyobj(x)._ptr,incx,stridex,batchCount))
    return (_hipblasDscalStridedBatched_64__retval,)


@cython.embedsignature(True)
def hipblasCscalStridedBatched_64(object handle, long n, object alpha, object x, long incx, long stridex, long batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        alpha (`~.hipblasComplex`/`~.object`):
            (undocumented)

        x (`~.hipblasComplex`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        stridex (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    _hipblasCscalStridedBatched_64__retval = hipblasStatus_t(chipblas.hipblasCscalStridedBatched_64(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,n,
        hipblasComplex.fromPyobj(alpha).getElementPtr(),
        hipblasComplex.fromPyobj(x).getElementPtr(),incx,stridex,batchCount))
    return (_hipblasCscalStridedBatched_64__retval,)


@cython.embedsignature(True)
def hipblasZscalStridedBatched_64(object handle, long n, object alpha, object x, long incx, long stridex, long batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        alpha (`~.hipblasDoubleComplex`/`~.object`):
            (undocumented)

        x (`~.hipblasDoubleComplex`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        stridex (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    _hipblasZscalStridedBatched_64__retval = hipblasStatus_t(chipblas.hipblasZscalStridedBatched_64(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,n,
        hipblasDoubleComplex.fromPyobj(alpha).getElementPtr(),
        hipblasDoubleComplex.fromPyobj(x).getElementPtr(),incx,stridex,batchCount))
    return (_hipblasZscalStridedBatched_64__retval,)


@cython.embedsignature(True)
def hipblasCsscalStridedBatched_64(object handle, long n, object alpha, object x, long incx, long stridex, long batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        alpha (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        x (`~.hipblasComplex`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        stridex (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    _hipblasCsscalStridedBatched_64__retval = hipblasStatus_t(chipblas.hipblasCsscalStridedBatched_64(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,n,
        <const float *>hip._util.types.Pointer.fromPyobj(alpha)._ptr,
        hipblasComplex.fromPyobj(x).getElementPtr(),incx,stridex,batchCount))
    return (_hipblasCsscalStridedBatched_64__retval,)


@cython.embedsignature(True)
def hipblasZdscalStridedBatched_64(object handle, long n, object alpha, object x, long incx, long stridex, long batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        alpha (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        x (`~.hipblasDoubleComplex`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        stridex (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    _hipblasZdscalStridedBatched_64__retval = hipblasStatus_t(chipblas.hipblasZdscalStridedBatched_64(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,n,
        <const double *>hip._util.types.Pointer.fromPyobj(alpha)._ptr,
        hipblasDoubleComplex.fromPyobj(x).getElementPtr(),incx,stridex,batchCount))
    return (_hipblasZdscalStridedBatched_64__retval,)


@cython.embedsignature(True)
def hipblasCscalStridedBatched_v2_64(object handle, long n, object alpha, object x, long incx, long stridex, long batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        alpha (`~.float2`/`~.object`):
            (undocumented)

        x (`~.float2`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        stridex (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    _hipblasCscalStridedBatched_v2_64__retval = hipblasStatus_t(chipblas.hipblasCscalStridedBatched_v2_64(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,n,
        float2.fromPyobj(alpha).getElementPtr(),
        float2.fromPyobj(x).getElementPtr(),incx,stridex,batchCount))
    return (_hipblasCscalStridedBatched_v2_64__retval,)


@cython.embedsignature(True)
def hipblasZscalStridedBatched_v2_64(object handle, long n, object alpha, object x, long incx, long stridex, long batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        alpha (`~.double2`/`~.object`):
            (undocumented)

        x (`~.double2`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        stridex (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    _hipblasZscalStridedBatched_v2_64__retval = hipblasStatus_t(chipblas.hipblasZscalStridedBatched_v2_64(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,n,
        double2.fromPyobj(alpha).getElementPtr(),
        double2.fromPyobj(x).getElementPtr(),incx,stridex,batchCount))
    return (_hipblasZscalStridedBatched_v2_64__retval,)


@cython.embedsignature(True)
def hipblasCsscalStridedBatched_v2_64(object handle, long n, object alpha, object x, long incx, long stridex, long batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        alpha (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        x (`~.float2`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        stridex (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    _hipblasCsscalStridedBatched_v2_64__retval = hipblasStatus_t(chipblas.hipblasCsscalStridedBatched_v2_64(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,n,
        <const float *>hip._util.types.Pointer.fromPyobj(alpha)._ptr,
        float2.fromPyobj(x).getElementPtr(),incx,stridex,batchCount))
    return (_hipblasCsscalStridedBatched_v2_64__retval,)


@cython.embedsignature(True)
def hipblasZdscalStridedBatched_v2_64(object handle, long n, object alpha, object x, long incx, long stridex, long batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        alpha (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        x (`~.double2`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        stridex (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    _hipblasZdscalStridedBatched_v2_64__retval = hipblasStatus_t(chipblas.hipblasZdscalStridedBatched_v2_64(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,n,
        <const double *>hip._util.types.Pointer.fromPyobj(alpha)._ptr,
        double2.fromPyobj(x).getElementPtr(),incx,stridex,batchCount))
    return (_hipblasZdscalStridedBatched_v2_64__retval,)


@cython.embedsignature(True)
def hipblasSswap(object handle, int n, object x, int incx, object y, int incy):
    r"""BLAS Level 1 API

    @{

    swap  interchanges vectors x and y.

    y := x; x := y

    - Supported precisions in rocBLAS : s,d,c,z
    - Supported precisions in cuBLAS  : s,d,c,z

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`) -- *IN*:
            [hipblasHandle_t]
            handle to the hipblas library context queue.

        n (`~.int`) -- *IN*:
            [int]
            the number of elements in x and y.

        x (`~.hip._util.types.Pointer`/`~.object`) -- *INOUT*:
            device pointer storing vector x.

        incx (`~.int`) -- *IN*:
            [int]
            specifies the increment for the elements of x.

        y (`~.hip._util.types.Pointer`/`~.object`) -- *INOUT*:
            device pointer storing vector y.

        incy (`~.int`) -- *IN*:
            [int]
            specifies the increment for the elements of y.
    """
    _hipblasSswap__retval = hipblasStatus_t(chipblas.hipblasSswap(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,n,
        <float *>hip._util.types.Pointer.fromPyobj(x)._ptr,incx,
        <float *>hip._util.types.Pointer.fromPyobj(y)._ptr,incy))
    return (_hipblasSswap__retval,)


@cython.embedsignature(True)
def hipblasDswap(object handle, int n, object x, int incx, object y, int incy):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        x (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        y (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        incy (`~.int`):
            (undocumented)
    """
    _hipblasDswap__retval = hipblasStatus_t(chipblas.hipblasDswap(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,n,
        <double *>hip._util.types.Pointer.fromPyobj(x)._ptr,incx,
        <double *>hip._util.types.Pointer.fromPyobj(y)._ptr,incy))
    return (_hipblasDswap__retval,)


@cython.embedsignature(True)
def hipblasCswap(object handle, int n, object x, int incx, object y, int incy):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        x (`~.hipblasComplex`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        y (`~.hipblasComplex`/`~.object`):
            (undocumented)

        incy (`~.int`):
            (undocumented)
    """
    _hipblasCswap__retval = hipblasStatus_t(chipblas.hipblasCswap(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,n,
        hipblasComplex.fromPyobj(x).getElementPtr(),incx,
        hipblasComplex.fromPyobj(y).getElementPtr(),incy))
    return (_hipblasCswap__retval,)


@cython.embedsignature(True)
def hipblasZswap(object handle, int n, object x, int incx, object y, int incy):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        x (`~.hipblasDoubleComplex`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        y (`~.hipblasDoubleComplex`/`~.object`):
            (undocumented)

        incy (`~.int`):
            (undocumented)
    """
    _hipblasZswap__retval = hipblasStatus_t(chipblas.hipblasZswap(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,n,
        hipblasDoubleComplex.fromPyobj(x).getElementPtr(),incx,
        hipblasDoubleComplex.fromPyobj(y).getElementPtr(),incy))
    return (_hipblasZswap__retval,)


@cython.embedsignature(True)
def hipblasCswap_v2(object handle, int n, object x, int incx, object y, int incy):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        x (`~.float2`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        y (`~.float2`/`~.object`):
            (undocumented)

        incy (`~.int`):
            (undocumented)
    """
    _hipblasCswap_v2__retval = hipblasStatus_t(chipblas.hipblasCswap_v2(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,n,
        float2.fromPyobj(x).getElementPtr(),incx,
        float2.fromPyobj(y).getElementPtr(),incy))
    return (_hipblasCswap_v2__retval,)


@cython.embedsignature(True)
def hipblasZswap_v2(object handle, int n, object x, int incx, object y, int incy):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        x (`~.double2`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        y (`~.double2`/`~.object`):
            (undocumented)

        incy (`~.int`):
            (undocumented)
    """
    _hipblasZswap_v2__retval = hipblasStatus_t(chipblas.hipblasZswap_v2(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,n,
        double2.fromPyobj(x).getElementPtr(),incx,
        double2.fromPyobj(y).getElementPtr(),incy))
    return (_hipblasZswap_v2__retval,)


@cython.embedsignature(True)
def hipblasSswap_64(object handle, long n, object x, long incx, object y, long incy):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        x (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        y (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        incy (`~.int`):
            (undocumented)
    """
    _hipblasSswap_64__retval = hipblasStatus_t(chipblas.hipblasSswap_64(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,n,
        <float *>hip._util.types.Pointer.fromPyobj(x)._ptr,incx,
        <float *>hip._util.types.Pointer.fromPyobj(y)._ptr,incy))
    return (_hipblasSswap_64__retval,)


@cython.embedsignature(True)
def hipblasDswap_64(object handle, long n, object x, long incx, object y, long incy):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        x (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        y (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        incy (`~.int`):
            (undocumented)
    """
    _hipblasDswap_64__retval = hipblasStatus_t(chipblas.hipblasDswap_64(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,n,
        <double *>hip._util.types.Pointer.fromPyobj(x)._ptr,incx,
        <double *>hip._util.types.Pointer.fromPyobj(y)._ptr,incy))
    return (_hipblasDswap_64__retval,)


@cython.embedsignature(True)
def hipblasCswap_64(object handle, long n, object x, long incx, object y, long incy):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        x (`~.hipblasComplex`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        y (`~.hipblasComplex`/`~.object`):
            (undocumented)

        incy (`~.int`):
            (undocumented)
    """
    _hipblasCswap_64__retval = hipblasStatus_t(chipblas.hipblasCswap_64(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,n,
        hipblasComplex.fromPyobj(x).getElementPtr(),incx,
        hipblasComplex.fromPyobj(y).getElementPtr(),incy))
    return (_hipblasCswap_64__retval,)


@cython.embedsignature(True)
def hipblasZswap_64(object handle, long n, object x, long incx, object y, long incy):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        x (`~.hipblasDoubleComplex`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        y (`~.hipblasDoubleComplex`/`~.object`):
            (undocumented)

        incy (`~.int`):
            (undocumented)
    """
    _hipblasZswap_64__retval = hipblasStatus_t(chipblas.hipblasZswap_64(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,n,
        hipblasDoubleComplex.fromPyobj(x).getElementPtr(),incx,
        hipblasDoubleComplex.fromPyobj(y).getElementPtr(),incy))
    return (_hipblasZswap_64__retval,)


@cython.embedsignature(True)
def hipblasCswap_v2_64(object handle, long n, object x, long incx, object y, long incy):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        x (`~.float2`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        y (`~.float2`/`~.object`):
            (undocumented)

        incy (`~.int`):
            (undocumented)
    """
    _hipblasCswap_v2_64__retval = hipblasStatus_t(chipblas.hipblasCswap_v2_64(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,n,
        float2.fromPyobj(x).getElementPtr(),incx,
        float2.fromPyobj(y).getElementPtr(),incy))
    return (_hipblasCswap_v2_64__retval,)


@cython.embedsignature(True)
def hipblasZswap_v2_64(object handle, long n, object x, long incx, object y, long incy):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        x (`~.double2`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        y (`~.double2`/`~.object`):
            (undocumented)

        incy (`~.int`):
            (undocumented)
    """
    _hipblasZswap_v2_64__retval = hipblasStatus_t(chipblas.hipblasZswap_v2_64(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,n,
        double2.fromPyobj(x).getElementPtr(),incx,
        double2.fromPyobj(y).getElementPtr(),incy))
    return (_hipblasZswap_v2_64__retval,)


@cython.embedsignature(True)
def hipblasSswapBatched(object handle, int n, object x, int incx, object y, int incy, int batchCount):
    r"""BLAS Level 1 API

    @{

    swapBatched interchanges vectors x_i and y_i, for i = 1 , ... , batchCount

    y_i := x_i; x_i := y_i

    - Supported precisions in rocBLAS : s,d,c,z
    - Supported precisions in cuBLAS  : No support

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`) -- *IN*:
            [hipblasHandle_t]
            handle to the hipblas library context queue.

        n (`~.int`) -- *IN*:
            [int]
            the number of elements in each x_i and y_i.

        x (`~.hip._util.types.ListOfPointer`/`~.object`) -- *INOUT*:
            device array of device pointers storing each vector x_i.

        incx (`~.int`) -- *IN*:
            [int]
            specifies the increment for the elements of each x_i.

        y (`~.hip._util.types.ListOfPointer`/`~.object`) -- *INOUT*:
            device array of device pointers storing each vector y_i.

        incy (`~.int`) -- *IN*:
            [int]
            specifies the increment for the elements of each y_i.

        batchCount (`~.int`) -- *IN*:
            [int]
            number of instances in the batch.
    """
    _hipblasSswapBatched__retval = hipblasStatus_t(chipblas.hipblasSswapBatched(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,n,
        <float *const*>hip._util.types.ListOfPointer.fromPyobj(x)._ptr,incx,
        <float *const*>hip._util.types.ListOfPointer.fromPyobj(y)._ptr,incy,batchCount))
    return (_hipblasSswapBatched__retval,)


@cython.embedsignature(True)
def hipblasDswapBatched(object handle, int n, object x, int incx, object y, int incy, int batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        x (`~.hip._util.types.ListOfPointer`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        y (`~.hip._util.types.ListOfPointer`/`~.object`):
            (undocumented)

        incy (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    _hipblasDswapBatched__retval = hipblasStatus_t(chipblas.hipblasDswapBatched(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,n,
        <double *const*>hip._util.types.ListOfPointer.fromPyobj(x)._ptr,incx,
        <double *const*>hip._util.types.ListOfPointer.fromPyobj(y)._ptr,incy,batchCount))
    return (_hipblasDswapBatched__retval,)


@cython.embedsignature(True)
def hipblasCswapBatched(object handle, int n, object x, int incx, object y, int incy, int batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        x (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        y (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        incy (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    _hipblasCswapBatched__retval = hipblasStatus_t(chipblas.hipblasCswapBatched(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,n,
        <chipblas.hipblasComplex *const*>hip._util.types.Pointer.fromPyobj(x)._ptr,incx,
        <chipblas.hipblasComplex *const*>hip._util.types.Pointer.fromPyobj(y)._ptr,incy,batchCount))
    return (_hipblasCswapBatched__retval,)


@cython.embedsignature(True)
def hipblasZswapBatched(object handle, int n, object x, int incx, object y, int incy, int batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        x (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        y (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        incy (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    _hipblasZswapBatched__retval = hipblasStatus_t(chipblas.hipblasZswapBatched(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,n,
        <chipblas.hipblasDoubleComplex *const*>hip._util.types.Pointer.fromPyobj(x)._ptr,incx,
        <chipblas.hipblasDoubleComplex *const*>hip._util.types.Pointer.fromPyobj(y)._ptr,incy,batchCount))
    return (_hipblasZswapBatched__retval,)


@cython.embedsignature(True)
def hipblasCswapBatched_v2(object handle, int n, object x, int incx, object y, int incy, int batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        x (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        y (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        incy (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    _hipblasCswapBatched_v2__retval = hipblasStatus_t(chipblas.hipblasCswapBatched_v2(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,n,
        <chipblas.float2 *const*>hip._util.types.Pointer.fromPyobj(x)._ptr,incx,
        <chipblas.float2 *const*>hip._util.types.Pointer.fromPyobj(y)._ptr,incy,batchCount))
    return (_hipblasCswapBatched_v2__retval,)


@cython.embedsignature(True)
def hipblasZswapBatched_v2(object handle, int n, object x, int incx, object y, int incy, int batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        x (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        y (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        incy (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    _hipblasZswapBatched_v2__retval = hipblasStatus_t(chipblas.hipblasZswapBatched_v2(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,n,
        <chipblas.double2 *const*>hip._util.types.Pointer.fromPyobj(x)._ptr,incx,
        <chipblas.double2 *const*>hip._util.types.Pointer.fromPyobj(y)._ptr,incy,batchCount))
    return (_hipblasZswapBatched_v2__retval,)


@cython.embedsignature(True)
def hipblasSswapBatched_64(object handle, long n, object x, long incx, object y, long incy, long batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        x (`~.hip._util.types.ListOfPointer`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        y (`~.hip._util.types.ListOfPointer`/`~.object`):
            (undocumented)

        incy (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    _hipblasSswapBatched_64__retval = hipblasStatus_t(chipblas.hipblasSswapBatched_64(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,n,
        <float *const*>hip._util.types.ListOfPointer.fromPyobj(x)._ptr,incx,
        <float *const*>hip._util.types.ListOfPointer.fromPyobj(y)._ptr,incy,batchCount))
    return (_hipblasSswapBatched_64__retval,)


@cython.embedsignature(True)
def hipblasDswapBatched_64(object handle, long n, object x, long incx, object y, long incy, long batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        x (`~.hip._util.types.ListOfPointer`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        y (`~.hip._util.types.ListOfPointer`/`~.object`):
            (undocumented)

        incy (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    _hipblasDswapBatched_64__retval = hipblasStatus_t(chipblas.hipblasDswapBatched_64(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,n,
        <double *const*>hip._util.types.ListOfPointer.fromPyobj(x)._ptr,incx,
        <double *const*>hip._util.types.ListOfPointer.fromPyobj(y)._ptr,incy,batchCount))
    return (_hipblasDswapBatched_64__retval,)


@cython.embedsignature(True)
def hipblasCswapBatched_64(object handle, long n, object x, long incx, object y, long incy, long batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        x (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        y (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        incy (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    _hipblasCswapBatched_64__retval = hipblasStatus_t(chipblas.hipblasCswapBatched_64(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,n,
        <chipblas.hipblasComplex *const*>hip._util.types.Pointer.fromPyobj(x)._ptr,incx,
        <chipblas.hipblasComplex *const*>hip._util.types.Pointer.fromPyobj(y)._ptr,incy,batchCount))
    return (_hipblasCswapBatched_64__retval,)


@cython.embedsignature(True)
def hipblasZswapBatched_64(object handle, long n, object x, long incx, object y, long incy, long batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        x (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        y (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        incy (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    _hipblasZswapBatched_64__retval = hipblasStatus_t(chipblas.hipblasZswapBatched_64(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,n,
        <chipblas.hipblasDoubleComplex *const*>hip._util.types.Pointer.fromPyobj(x)._ptr,incx,
        <chipblas.hipblasDoubleComplex *const*>hip._util.types.Pointer.fromPyobj(y)._ptr,incy,batchCount))
    return (_hipblasZswapBatched_64__retval,)


@cython.embedsignature(True)
def hipblasCswapBatched_v2_64(object handle, long n, object x, long incx, object y, long incy, long batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        x (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        y (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        incy (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    _hipblasCswapBatched_v2_64__retval = hipblasStatus_t(chipblas.hipblasCswapBatched_v2_64(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,n,
        <chipblas.float2 *const*>hip._util.types.Pointer.fromPyobj(x)._ptr,incx,
        <chipblas.float2 *const*>hip._util.types.Pointer.fromPyobj(y)._ptr,incy,batchCount))
    return (_hipblasCswapBatched_v2_64__retval,)


@cython.embedsignature(True)
def hipblasZswapBatched_v2_64(object handle, long n, object x, long incx, object y, long incy, long batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        x (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        y (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        incy (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    _hipblasZswapBatched_v2_64__retval = hipblasStatus_t(chipblas.hipblasZswapBatched_v2_64(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,n,
        <chipblas.double2 *const*>hip._util.types.Pointer.fromPyobj(x)._ptr,incx,
        <chipblas.double2 *const*>hip._util.types.Pointer.fromPyobj(y)._ptr,incy,batchCount))
    return (_hipblasZswapBatched_v2_64__retval,)


@cython.embedsignature(True)
def hipblasSswapStridedBatched(object handle, int n, object x, int incx, long stridex, object y, int incy, long stridey, int batchCount):
    r"""BLAS Level 1 API

    @{

    swapStridedBatched interchanges vectors x_i and y_i, for i = 1 , ... , batchCount

    y_i := x_i; x_i := y_i

    - Supported precisions in rocBLAS : s,d,c,z
    - Supported precisions in cuBLAS  : No support

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`) -- *IN*:
            [hipblasHandle_t]
            handle to the hipblas library context queue.

        n (`~.int`) -- *IN*:
            [int]
            the number of elements in each x_i and y_i.

        x (`~.hip._util.types.Pointer`/`~.object`) -- *INOUT*:
            device pointer to the first vector x_1.

        incx (`~.int`) -- *IN*:
            [int]
            specifies the increment for the elements of x.

        stridex (`~.int`) -- *IN*:
            [hipblasStride]
            stride from the start of one vector (x_i) and the next one (x_i+1).
            There are no restrictions placed on stride_x, however the user should
            take care to ensure that stride_x is of appropriate size, for a typical
            case this means stride_x >= n * incx.

        y (`~.hip._util.types.Pointer`/`~.object`) -- *INOUT*:
            device pointer to the first vector y_1.

        incy (`~.int`) -- *IN*:
            [int]
            specifies the increment for the elements of y.

        stridey (`~.int`) -- *IN*:
            [hipblasStride]
            stride from the start of one vector (y_i) and the next one (y_i+1).
            There are no restrictions placed on stride_x, however the user should
            take care to ensure that stride_y is of appropriate size, for a typical
            case this means stride_y >= n * incy. stridey should be non zero.

        batchCount (`~.int`) -- *IN*:
            [int]
            number of instances in the batch.
    """
    _hipblasSswapStridedBatched__retval = hipblasStatus_t(chipblas.hipblasSswapStridedBatched(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,n,
        <float *>hip._util.types.Pointer.fromPyobj(x)._ptr,incx,stridex,
        <float *>hip._util.types.Pointer.fromPyobj(y)._ptr,incy,stridey,batchCount))
    return (_hipblasSswapStridedBatched__retval,)


@cython.embedsignature(True)
def hipblasDswapStridedBatched(object handle, int n, object x, int incx, long stridex, object y, int incy, long stridey, int batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        x (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        stridex (`~.int`):
            (undocumented)

        y (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        incy (`~.int`):
            (undocumented)

        stridey (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    _hipblasDswapStridedBatched__retval = hipblasStatus_t(chipblas.hipblasDswapStridedBatched(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,n,
        <double *>hip._util.types.Pointer.fromPyobj(x)._ptr,incx,stridex,
        <double *>hip._util.types.Pointer.fromPyobj(y)._ptr,incy,stridey,batchCount))
    return (_hipblasDswapStridedBatched__retval,)


@cython.embedsignature(True)
def hipblasCswapStridedBatched(object handle, int n, object x, int incx, long stridex, object y, int incy, long stridey, int batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        x (`~.hipblasComplex`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        stridex (`~.int`):
            (undocumented)

        y (`~.hipblasComplex`/`~.object`):
            (undocumented)

        incy (`~.int`):
            (undocumented)

        stridey (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    _hipblasCswapStridedBatched__retval = hipblasStatus_t(chipblas.hipblasCswapStridedBatched(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,n,
        hipblasComplex.fromPyobj(x).getElementPtr(),incx,stridex,
        hipblasComplex.fromPyobj(y).getElementPtr(),incy,stridey,batchCount))
    return (_hipblasCswapStridedBatched__retval,)


@cython.embedsignature(True)
def hipblasZswapStridedBatched(object handle, int n, object x, int incx, long stridex, object y, int incy, long stridey, int batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        x (`~.hipblasDoubleComplex`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        stridex (`~.int`):
            (undocumented)

        y (`~.hipblasDoubleComplex`/`~.object`):
            (undocumented)

        incy (`~.int`):
            (undocumented)

        stridey (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    _hipblasZswapStridedBatched__retval = hipblasStatus_t(chipblas.hipblasZswapStridedBatched(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,n,
        hipblasDoubleComplex.fromPyobj(x).getElementPtr(),incx,stridex,
        hipblasDoubleComplex.fromPyobj(y).getElementPtr(),incy,stridey,batchCount))
    return (_hipblasZswapStridedBatched__retval,)


@cython.embedsignature(True)
def hipblasCswapStridedBatched_v2(object handle, int n, object x, int incx, long stridex, object y, int incy, long stridey, int batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        x (`~.float2`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        stridex (`~.int`):
            (undocumented)

        y (`~.float2`/`~.object`):
            (undocumented)

        incy (`~.int`):
            (undocumented)

        stridey (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    _hipblasCswapStridedBatched_v2__retval = hipblasStatus_t(chipblas.hipblasCswapStridedBatched_v2(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,n,
        float2.fromPyobj(x).getElementPtr(),incx,stridex,
        float2.fromPyobj(y).getElementPtr(),incy,stridey,batchCount))
    return (_hipblasCswapStridedBatched_v2__retval,)


@cython.embedsignature(True)
def hipblasZswapStridedBatched_v2(object handle, int n, object x, int incx, long stridex, object y, int incy, long stridey, int batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        x (`~.double2`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        stridex (`~.int`):
            (undocumented)

        y (`~.double2`/`~.object`):
            (undocumented)

        incy (`~.int`):
            (undocumented)

        stridey (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    _hipblasZswapStridedBatched_v2__retval = hipblasStatus_t(chipblas.hipblasZswapStridedBatched_v2(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,n,
        double2.fromPyobj(x).getElementPtr(),incx,stridex,
        double2.fromPyobj(y).getElementPtr(),incy,stridey,batchCount))
    return (_hipblasZswapStridedBatched_v2__retval,)


@cython.embedsignature(True)
def hipblasSswapStridedBatched_64(object handle, long n, object x, long incx, long stridex, object y, long incy, long stridey, long batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        x (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        stridex (`~.int`):
            (undocumented)

        y (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        incy (`~.int`):
            (undocumented)

        stridey (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    _hipblasSswapStridedBatched_64__retval = hipblasStatus_t(chipblas.hipblasSswapStridedBatched_64(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,n,
        <float *>hip._util.types.Pointer.fromPyobj(x)._ptr,incx,stridex,
        <float *>hip._util.types.Pointer.fromPyobj(y)._ptr,incy,stridey,batchCount))
    return (_hipblasSswapStridedBatched_64__retval,)


@cython.embedsignature(True)
def hipblasDswapStridedBatched_64(object handle, long n, object x, long incx, long stridex, object y, long incy, long stridey, long batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        x (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        stridex (`~.int`):
            (undocumented)

        y (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        incy (`~.int`):
            (undocumented)

        stridey (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    _hipblasDswapStridedBatched_64__retval = hipblasStatus_t(chipblas.hipblasDswapStridedBatched_64(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,n,
        <double *>hip._util.types.Pointer.fromPyobj(x)._ptr,incx,stridex,
        <double *>hip._util.types.Pointer.fromPyobj(y)._ptr,incy,stridey,batchCount))
    return (_hipblasDswapStridedBatched_64__retval,)


@cython.embedsignature(True)
def hipblasCswapStridedBatched_64(object handle, long n, object x, long incx, long stridex, object y, long incy, long stridey, long batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        x (`~.hipblasComplex`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        stridex (`~.int`):
            (undocumented)

        y (`~.hipblasComplex`/`~.object`):
            (undocumented)

        incy (`~.int`):
            (undocumented)

        stridey (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    _hipblasCswapStridedBatched_64__retval = hipblasStatus_t(chipblas.hipblasCswapStridedBatched_64(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,n,
        hipblasComplex.fromPyobj(x).getElementPtr(),incx,stridex,
        hipblasComplex.fromPyobj(y).getElementPtr(),incy,stridey,batchCount))
    return (_hipblasCswapStridedBatched_64__retval,)


@cython.embedsignature(True)
def hipblasZswapStridedBatched_64(object handle, long n, object x, long incx, long stridex, object y, long incy, long stridey, long batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        x (`~.hipblasDoubleComplex`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        stridex (`~.int`):
            (undocumented)

        y (`~.hipblasDoubleComplex`/`~.object`):
            (undocumented)

        incy (`~.int`):
            (undocumented)

        stridey (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    _hipblasZswapStridedBatched_64__retval = hipblasStatus_t(chipblas.hipblasZswapStridedBatched_64(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,n,
        hipblasDoubleComplex.fromPyobj(x).getElementPtr(),incx,stridex,
        hipblasDoubleComplex.fromPyobj(y).getElementPtr(),incy,stridey,batchCount))
    return (_hipblasZswapStridedBatched_64__retval,)


@cython.embedsignature(True)
def hipblasCswapStridedBatched_v2_64(object handle, long n, object x, long incx, long stridex, object y, long incy, long stridey, long batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        x (`~.float2`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        stridex (`~.int`):
            (undocumented)

        y (`~.float2`/`~.object`):
            (undocumented)

        incy (`~.int`):
            (undocumented)

        stridey (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    _hipblasCswapStridedBatched_v2_64__retval = hipblasStatus_t(chipblas.hipblasCswapStridedBatched_v2_64(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,n,
        float2.fromPyobj(x).getElementPtr(),incx,stridex,
        float2.fromPyobj(y).getElementPtr(),incy,stridey,batchCount))
    return (_hipblasCswapStridedBatched_v2_64__retval,)


@cython.embedsignature(True)
def hipblasZswapStridedBatched_v2_64(object handle, long n, object x, long incx, long stridex, object y, long incy, long stridey, long batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        x (`~.double2`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        stridex (`~.int`):
            (undocumented)

        y (`~.double2`/`~.object`):
            (undocumented)

        incy (`~.int`):
            (undocumented)

        stridey (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    _hipblasZswapStridedBatched_v2_64__retval = hipblasStatus_t(chipblas.hipblasZswapStridedBatched_v2_64(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,n,
        double2.fromPyobj(x).getElementPtr(),incx,stridex,
        double2.fromPyobj(y).getElementPtr(),incy,stridey,batchCount))
    return (_hipblasZswapStridedBatched_v2_64__retval,)


@cython.embedsignature(True)
def hipblasSgbmv(object handle, object trans, int m, int n, int kl, int ku, object alpha, object AP, int lda, object x, int incx, object beta, object y, int incy):
    r"""BLAS Level 2 API

    @{

    gbmv performs one of the matrix-vector operations

    y := alpha*A*x    + beta*y,   or
        y := alpha*A**T*x + beta*y,   or
        y := alpha*A**H*x + beta*y,

    where alpha and beta are scalars, x and y are vectors and A is an
    m by n banded matrix with kl sub-diagonals and ku super-diagonals.

    - Supported precisions in rocBLAS : s,d,c,z
    - Supported precisions in cuBLAS  : s,d,c,z

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`) -- *IN*:
            [hipblasHandle_t]
            handle to the hipblas library context queue.

        trans (`~.hipblasOperation_t`) -- *IN*:
            [hipblasOperation_t]
            indicates whether matrix A is tranposed (conjugated) or not

        m (`~.int`) -- *IN*:
            [int]
            number of rows of matrix A

        n (`~.int`) -- *IN*:
            [int]
            number of columns of matrix A

        kl (`~.int`) -- *IN*:
            [int]
            number of sub-diagonals of A

        ku (`~.int`) -- *IN*:
            [int]
            number of super-diagonals of A

        alpha (`~.hip._util.types.Pointer`/`~.object`) -- *IN*:
            device pointer or host pointer to scalar alpha.

        AP (`~.hip._util.types.Pointer`/`~.object`) -- *IN*:
            device pointer storing banded matrix A.
            Leading (kl + ku + 1) by n part of the matrix contains the coefficients
            of the banded matrix. The leading diagonal resides in row (ku + 1) with
            the first super-diagonal above on the RHS of row ku. The first sub-diagonal
            resides below on the LHS of row ku + 2. This propagates up and down across
            sub/super-diagonals.
              Ex: (m = n = 7; ku = 2, kl = 2)
              1 2 3 0 0 0 0             0 0 3 3 3 3 3
              4 1 2 3 0 0 0             0 2 2 2 2 2 2
              5 4 1 2 3 0 0    ---->    1 1 1 1 1 1 1
              0 5 4 1 2 3 0             4 4 4 4 4 4 0
              0 0 5 4 1 2 0             5 5 5 5 5 0 0
              0 0 0 5 4 1 2             0 0 0 0 0 0 0
              0 0 0 0 5 4 1             0 0 0 0 0 0 0
            Note that the empty elements which don't correspond to data will not
            be referenced.

        lda (`~.int`) -- *IN*:
            [int]
            specifies the leading dimension of A. Must be >= (kl + ku + 1)

        x (`~.hip._util.types.Pointer`/`~.object`) -- *IN*:
            device pointer storing vector x.

        incx (`~.int`) -- *IN*:
            [int]
            specifies the increment for the elements of x.

        beta (`~.hip._util.types.Pointer`/`~.object`) -- *IN*:
            device pointer or host pointer to scalar beta.

        y (`~.hip._util.types.Pointer`/`~.object`) -- *INOUT*:
            device pointer storing vector y.

        incy (`~.int`) -- *IN*:
            [int]
            specifies the increment for the elements of y.
    """
    if not isinstance(trans,_hipblasOperation_t__Base):
        raise TypeError("argument 'trans' must be of type '_hipblasOperation_t__Base'")
    _hipblasSgbmv__retval = hipblasStatus_t(chipblas.hipblasSgbmv(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,trans.value,m,n,kl,ku,
        <const float *>hip._util.types.Pointer.fromPyobj(alpha)._ptr,
        <const float *>hip._util.types.Pointer.fromPyobj(AP)._ptr,lda,
        <const float *>hip._util.types.Pointer.fromPyobj(x)._ptr,incx,
        <const float *>hip._util.types.Pointer.fromPyobj(beta)._ptr,
        <float *>hip._util.types.Pointer.fromPyobj(y)._ptr,incy))
    return (_hipblasSgbmv__retval,)


@cython.embedsignature(True)
def hipblasDgbmv(object handle, object trans, int m, int n, int kl, int ku, object alpha, object AP, int lda, object x, int incx, object beta, object y, int incy):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        trans (`~.hipblasOperation_t`):
            (undocumented)

        m (`~.int`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        kl (`~.int`):
            (undocumented)

        ku (`~.int`):
            (undocumented)

        alpha (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        AP (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        x (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        beta (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        y (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        incy (`~.int`):
            (undocumented)
    """
    if not isinstance(trans,_hipblasOperation_t__Base):
        raise TypeError("argument 'trans' must be of type '_hipblasOperation_t__Base'")
    _hipblasDgbmv__retval = hipblasStatus_t(chipblas.hipblasDgbmv(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,trans.value,m,n,kl,ku,
        <const double *>hip._util.types.Pointer.fromPyobj(alpha)._ptr,
        <const double *>hip._util.types.Pointer.fromPyobj(AP)._ptr,lda,
        <const double *>hip._util.types.Pointer.fromPyobj(x)._ptr,incx,
        <const double *>hip._util.types.Pointer.fromPyobj(beta)._ptr,
        <double *>hip._util.types.Pointer.fromPyobj(y)._ptr,incy))
    return (_hipblasDgbmv__retval,)


@cython.embedsignature(True)
def hipblasCgbmv(object handle, object trans, int m, int n, int kl, int ku, object alpha, object AP, int lda, object x, int incx, object beta, object y, int incy):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        trans (`~.hipblasOperation_t`):
            (undocumented)

        m (`~.int`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        kl (`~.int`):
            (undocumented)

        ku (`~.int`):
            (undocumented)

        alpha (`~.hipblasComplex`/`~.object`):
            (undocumented)

        AP (`~.hipblasComplex`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        x (`~.hipblasComplex`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        beta (`~.hipblasComplex`/`~.object`):
            (undocumented)

        y (`~.hipblasComplex`/`~.object`):
            (undocumented)

        incy (`~.int`):
            (undocumented)
    """
    if not isinstance(trans,_hipblasOperation_t__Base):
        raise TypeError("argument 'trans' must be of type '_hipblasOperation_t__Base'")
    _hipblasCgbmv__retval = hipblasStatus_t(chipblas.hipblasCgbmv(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,trans.value,m,n,kl,ku,
        hipblasComplex.fromPyobj(alpha).getElementPtr(),
        hipblasComplex.fromPyobj(AP).getElementPtr(),lda,
        hipblasComplex.fromPyobj(x).getElementPtr(),incx,
        hipblasComplex.fromPyobj(beta).getElementPtr(),
        hipblasComplex.fromPyobj(y).getElementPtr(),incy))
    return (_hipblasCgbmv__retval,)


@cython.embedsignature(True)
def hipblasZgbmv(object handle, object trans, int m, int n, int kl, int ku, object alpha, object AP, int lda, object x, int incx, object beta, object y, int incy):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        trans (`~.hipblasOperation_t`):
            (undocumented)

        m (`~.int`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        kl (`~.int`):
            (undocumented)

        ku (`~.int`):
            (undocumented)

        alpha (`~.hipblasDoubleComplex`/`~.object`):
            (undocumented)

        AP (`~.hipblasDoubleComplex`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        x (`~.hipblasDoubleComplex`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        beta (`~.hipblasDoubleComplex`/`~.object`):
            (undocumented)

        y (`~.hipblasDoubleComplex`/`~.object`):
            (undocumented)

        incy (`~.int`):
            (undocumented)
    """
    if not isinstance(trans,_hipblasOperation_t__Base):
        raise TypeError("argument 'trans' must be of type '_hipblasOperation_t__Base'")
    _hipblasZgbmv__retval = hipblasStatus_t(chipblas.hipblasZgbmv(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,trans.value,m,n,kl,ku,
        hipblasDoubleComplex.fromPyobj(alpha).getElementPtr(),
        hipblasDoubleComplex.fromPyobj(AP).getElementPtr(),lda,
        hipblasDoubleComplex.fromPyobj(x).getElementPtr(),incx,
        hipblasDoubleComplex.fromPyobj(beta).getElementPtr(),
        hipblasDoubleComplex.fromPyobj(y).getElementPtr(),incy))
    return (_hipblasZgbmv__retval,)


@cython.embedsignature(True)
def hipblasCgbmv_v2(object handle, object trans, int m, int n, int kl, int ku, object alpha, object AP, int lda, object x, int incx, object beta, object y, int incy):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        trans (`~.hipblasOperation_t`):
            (undocumented)

        m (`~.int`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        kl (`~.int`):
            (undocumented)

        ku (`~.int`):
            (undocumented)

        alpha (`~.float2`/`~.object`):
            (undocumented)

        AP (`~.float2`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        x (`~.float2`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        beta (`~.float2`/`~.object`):
            (undocumented)

        y (`~.float2`/`~.object`):
            (undocumented)

        incy (`~.int`):
            (undocumented)
    """
    if not isinstance(trans,_hipblasOperation_t__Base):
        raise TypeError("argument 'trans' must be of type '_hipblasOperation_t__Base'")
    _hipblasCgbmv_v2__retval = hipblasStatus_t(chipblas.hipblasCgbmv_v2(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,trans.value,m,n,kl,ku,
        float2.fromPyobj(alpha).getElementPtr(),
        float2.fromPyobj(AP).getElementPtr(),lda,
        float2.fromPyobj(x).getElementPtr(),incx,
        float2.fromPyobj(beta).getElementPtr(),
        float2.fromPyobj(y).getElementPtr(),incy))
    return (_hipblasCgbmv_v2__retval,)


@cython.embedsignature(True)
def hipblasZgbmv_v2(object handle, object trans, int m, int n, int kl, int ku, object alpha, object AP, int lda, object x, int incx, object beta, object y, int incy):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        trans (`~.hipblasOperation_t`):
            (undocumented)

        m (`~.int`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        kl (`~.int`):
            (undocumented)

        ku (`~.int`):
            (undocumented)

        alpha (`~.double2`/`~.object`):
            (undocumented)

        AP (`~.double2`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        x (`~.double2`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        beta (`~.double2`/`~.object`):
            (undocumented)

        y (`~.double2`/`~.object`):
            (undocumented)

        incy (`~.int`):
            (undocumented)
    """
    if not isinstance(trans,_hipblasOperation_t__Base):
        raise TypeError("argument 'trans' must be of type '_hipblasOperation_t__Base'")
    _hipblasZgbmv_v2__retval = hipblasStatus_t(chipblas.hipblasZgbmv_v2(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,trans.value,m,n,kl,ku,
        double2.fromPyobj(alpha).getElementPtr(),
        double2.fromPyobj(AP).getElementPtr(),lda,
        double2.fromPyobj(x).getElementPtr(),incx,
        double2.fromPyobj(beta).getElementPtr(),
        double2.fromPyobj(y).getElementPtr(),incy))
    return (_hipblasZgbmv_v2__retval,)


@cython.embedsignature(True)
def hipblasSgbmv_64(object handle, object trans, long m, long n, long kl, long ku, object alpha, object AP, long lda, object x, long incx, object beta, object y, long incy):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        trans (`~.hipblasOperation_t`):
            (undocumented)

        m (`~.int`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        kl (`~.int`):
            (undocumented)

        ku (`~.int`):
            (undocumented)

        alpha (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        AP (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        x (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        beta (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        y (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        incy (`~.int`):
            (undocumented)
    """
    if not isinstance(trans,_hipblasOperation_t__Base):
        raise TypeError("argument 'trans' must be of type '_hipblasOperation_t__Base'")
    _hipblasSgbmv_64__retval = hipblasStatus_t(chipblas.hipblasSgbmv_64(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,trans.value,m,n,kl,ku,
        <const float *>hip._util.types.Pointer.fromPyobj(alpha)._ptr,
        <const float *>hip._util.types.Pointer.fromPyobj(AP)._ptr,lda,
        <const float *>hip._util.types.Pointer.fromPyobj(x)._ptr,incx,
        <const float *>hip._util.types.Pointer.fromPyobj(beta)._ptr,
        <float *>hip._util.types.Pointer.fromPyobj(y)._ptr,incy))
    return (_hipblasSgbmv_64__retval,)


@cython.embedsignature(True)
def hipblasDgbmv_64(object handle, object trans, long m, long n, long kl, long ku, object alpha, object AP, long lda, object x, long incx, object beta, object y, long incy):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        trans (`~.hipblasOperation_t`):
            (undocumented)

        m (`~.int`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        kl (`~.int`):
            (undocumented)

        ku (`~.int`):
            (undocumented)

        alpha (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        AP (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        x (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        beta (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        y (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        incy (`~.int`):
            (undocumented)
    """
    if not isinstance(trans,_hipblasOperation_t__Base):
        raise TypeError("argument 'trans' must be of type '_hipblasOperation_t__Base'")
    _hipblasDgbmv_64__retval = hipblasStatus_t(chipblas.hipblasDgbmv_64(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,trans.value,m,n,kl,ku,
        <const double *>hip._util.types.Pointer.fromPyobj(alpha)._ptr,
        <const double *>hip._util.types.Pointer.fromPyobj(AP)._ptr,lda,
        <const double *>hip._util.types.Pointer.fromPyobj(x)._ptr,incx,
        <const double *>hip._util.types.Pointer.fromPyobj(beta)._ptr,
        <double *>hip._util.types.Pointer.fromPyobj(y)._ptr,incy))
    return (_hipblasDgbmv_64__retval,)


@cython.embedsignature(True)
def hipblasCgbmv_64(object handle, object trans, long m, long n, long kl, long ku, object alpha, object AP, long lda, object x, long incx, object beta, object y, long incy):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        trans (`~.hipblasOperation_t`):
            (undocumented)

        m (`~.int`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        kl (`~.int`):
            (undocumented)

        ku (`~.int`):
            (undocumented)

        alpha (`~.hipblasComplex`/`~.object`):
            (undocumented)

        AP (`~.hipblasComplex`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        x (`~.hipblasComplex`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        beta (`~.hipblasComplex`/`~.object`):
            (undocumented)

        y (`~.hipblasComplex`/`~.object`):
            (undocumented)

        incy (`~.int`):
            (undocumented)
    """
    if not isinstance(trans,_hipblasOperation_t__Base):
        raise TypeError("argument 'trans' must be of type '_hipblasOperation_t__Base'")
    _hipblasCgbmv_64__retval = hipblasStatus_t(chipblas.hipblasCgbmv_64(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,trans.value,m,n,kl,ku,
        hipblasComplex.fromPyobj(alpha).getElementPtr(),
        hipblasComplex.fromPyobj(AP).getElementPtr(),lda,
        hipblasComplex.fromPyobj(x).getElementPtr(),incx,
        hipblasComplex.fromPyobj(beta).getElementPtr(),
        hipblasComplex.fromPyobj(y).getElementPtr(),incy))
    return (_hipblasCgbmv_64__retval,)


@cython.embedsignature(True)
def hipblasZgbmv_64(object handle, object trans, long m, long n, long kl, long ku, object alpha, object AP, long lda, object x, long incx, object beta, object y, long incy):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        trans (`~.hipblasOperation_t`):
            (undocumented)

        m (`~.int`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        kl (`~.int`):
            (undocumented)

        ku (`~.int`):
            (undocumented)

        alpha (`~.hipblasDoubleComplex`/`~.object`):
            (undocumented)

        AP (`~.hipblasDoubleComplex`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        x (`~.hipblasDoubleComplex`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        beta (`~.hipblasDoubleComplex`/`~.object`):
            (undocumented)

        y (`~.hipblasDoubleComplex`/`~.object`):
            (undocumented)

        incy (`~.int`):
            (undocumented)
    """
    if not isinstance(trans,_hipblasOperation_t__Base):
        raise TypeError("argument 'trans' must be of type '_hipblasOperation_t__Base'")
    _hipblasZgbmv_64__retval = hipblasStatus_t(chipblas.hipblasZgbmv_64(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,trans.value,m,n,kl,ku,
        hipblasDoubleComplex.fromPyobj(alpha).getElementPtr(),
        hipblasDoubleComplex.fromPyobj(AP).getElementPtr(),lda,
        hipblasDoubleComplex.fromPyobj(x).getElementPtr(),incx,
        hipblasDoubleComplex.fromPyobj(beta).getElementPtr(),
        hipblasDoubleComplex.fromPyobj(y).getElementPtr(),incy))
    return (_hipblasZgbmv_64__retval,)


@cython.embedsignature(True)
def hipblasCgbmv_v2_64(object handle, object trans, long m, long n, long kl, long ku, object alpha, object AP, long lda, object x, long incx, object beta, object y, long incy):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        trans (`~.hipblasOperation_t`):
            (undocumented)

        m (`~.int`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        kl (`~.int`):
            (undocumented)

        ku (`~.int`):
            (undocumented)

        alpha (`~.float2`/`~.object`):
            (undocumented)

        AP (`~.float2`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        x (`~.float2`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        beta (`~.float2`/`~.object`):
            (undocumented)

        y (`~.float2`/`~.object`):
            (undocumented)

        incy (`~.int`):
            (undocumented)
    """
    if not isinstance(trans,_hipblasOperation_t__Base):
        raise TypeError("argument 'trans' must be of type '_hipblasOperation_t__Base'")
    _hipblasCgbmv_v2_64__retval = hipblasStatus_t(chipblas.hipblasCgbmv_v2_64(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,trans.value,m,n,kl,ku,
        float2.fromPyobj(alpha).getElementPtr(),
        float2.fromPyobj(AP).getElementPtr(),lda,
        float2.fromPyobj(x).getElementPtr(),incx,
        float2.fromPyobj(beta).getElementPtr(),
        float2.fromPyobj(y).getElementPtr(),incy))
    return (_hipblasCgbmv_v2_64__retval,)


@cython.embedsignature(True)
def hipblasZgbmv_v2_64(object handle, object trans, long m, long n, long kl, long ku, object alpha, object AP, long lda, object x, long incx, object beta, object y, long incy):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        trans (`~.hipblasOperation_t`):
            (undocumented)

        m (`~.int`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        kl (`~.int`):
            (undocumented)

        ku (`~.int`):
            (undocumented)

        alpha (`~.double2`/`~.object`):
            (undocumented)

        AP (`~.double2`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        x (`~.double2`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        beta (`~.double2`/`~.object`):
            (undocumented)

        y (`~.double2`/`~.object`):
            (undocumented)

        incy (`~.int`):
            (undocumented)
    """
    if not isinstance(trans,_hipblasOperation_t__Base):
        raise TypeError("argument 'trans' must be of type '_hipblasOperation_t__Base'")
    _hipblasZgbmv_v2_64__retval = hipblasStatus_t(chipblas.hipblasZgbmv_v2_64(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,trans.value,m,n,kl,ku,
        double2.fromPyobj(alpha).getElementPtr(),
        double2.fromPyobj(AP).getElementPtr(),lda,
        double2.fromPyobj(x).getElementPtr(),incx,
        double2.fromPyobj(beta).getElementPtr(),
        double2.fromPyobj(y).getElementPtr(),incy))
    return (_hipblasZgbmv_v2_64__retval,)


@cython.embedsignature(True)
def hipblasSgbmvBatched(object handle, object trans, int m, int n, int kl, int ku, object alpha, object AP, int lda, object x, int incx, object beta, object y, int incy, int batchCount):
    r"""BLAS Level 2 API

    @{

    gbmvBatched performs one of the matrix-vector operations

    y_i := alpha*A_i*x_i    + beta*y_i,   or
        y_i := alpha*A_i**T*x_i + beta*y_i,   or
        y_i := alpha*A_i**H*x_i + beta*y_i,

    where (A_i, x_i, y_i) is the i-th instance of the batch.
    alpha and beta are scalars, x_i and y_i are vectors and A_i is an
    m by n banded matrix with kl sub-diagonals and ku super-diagonals,
    for i = 1, ..., batchCount.

    - Supported precisions in rocBLAS : s,d,c,z
    - Supported precisions in cuBLAS  : No support

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`) -- *IN*:
            [hipblasHandle_t]
            handle to the hipblas library context queue.

        trans (`~.hipblasOperation_t`) -- *IN*:
            [hipblasOperation_t]
            indicates whether matrix A is tranposed (conjugated) or not

        m (`~.int`) -- *IN*:
            [int]
            number of rows of each matrix A_i

        n (`~.int`) -- *IN*:
            [int]
            number of columns of each matrix A_i

        kl (`~.int`) -- *IN*:
            [int]
            number of sub-diagonals of each A_i

        ku (`~.int`) -- *IN*:
            [int]
            number of super-diagonals of each A_i

        alpha (`~.hip._util.types.Pointer`/`~.object`) -- *IN*:
            device pointer or host pointer to scalar alpha.

        AP (`~.hip._util.types.Pointer`/`~.object`) -- *IN*:
            device array of device pointers storing each banded matrix A_i.
            Leading (kl + ku + 1) by n part of the matrix contains the coefficients
            of the banded matrix. The leading diagonal resides in row (ku + 1) with
            the first super-diagonal above on the RHS of row ku. The first sub-diagonal
            resides below on the LHS of row ku + 2. This propagates up and down across
            sub/super-diagonals.
              Ex: (m = n = 7; ku = 2, kl = 2)
              1 2 3 0 0 0 0             0 0 3 3 3 3 3
              4 1 2 3 0 0 0             0 2 2 2 2 2 2
              5 4 1 2 3 0 0    ---->    1 1 1 1 1 1 1
              0 5 4 1 2 3 0             4 4 4 4 4 4 0
              0 0 5 4 1 2 0             5 5 5 5 5 0 0
              0 0 0 5 4 1 2             0 0 0 0 0 0 0
              0 0 0 0 5 4 1             0 0 0 0 0 0 0
            Note that the empty elements which don't correspond to data will not
            be referenced.

        lda (`~.int`) -- *IN*:
            [int]
            specifies the leading dimension of each A_i. Must be >= (kl + ku + 1)

        x (`~.hip._util.types.ListOfPointer`/`~.object`) -- *IN*:
            device array of device pointers storing each vector x_i.

        incx (`~.int`) -- *IN*:
            [int]
            specifies the increment for the elements of each x_i.

        beta (`~.hip._util.types.Pointer`/`~.object`) -- *IN*:
            device pointer or host pointer to scalar beta.

        y (`~.hip._util.types.ListOfPointer`/`~.object`) -- *INOUT*:
            device array of device pointers storing each vector y_i.

        incy (`~.int`) -- *IN*:
            [int]
            specifies the increment for the elements of each y_i.

        batchCount (`~.int`) -- *IN*:
            [int]
            specifies the number of instances in the batch.
    """
    if not isinstance(trans,_hipblasOperation_t__Base):
        raise TypeError("argument 'trans' must be of type '_hipblasOperation_t__Base'")
    _hipblasSgbmvBatched__retval = hipblasStatus_t(chipblas.hipblasSgbmvBatched(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,trans.value,m,n,kl,ku,
        <const float *>hip._util.types.Pointer.fromPyobj(alpha)._ptr,
        <const float *const*>hip._util.types.Pointer.fromPyobj(AP)._ptr,lda,
        <const float *const*>hip._util.types.ListOfPointer.fromPyobj(x)._ptr,incx,
        <const float *>hip._util.types.Pointer.fromPyobj(beta)._ptr,
        <float *const*>hip._util.types.ListOfPointer.fromPyobj(y)._ptr,incy,batchCount))
    return (_hipblasSgbmvBatched__retval,)


@cython.embedsignature(True)
def hipblasDgbmvBatched(object handle, object trans, int m, int n, int kl, int ku, object alpha, object AP, int lda, object x, int incx, object beta, object y, int incy, int batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        trans (`~.hipblasOperation_t`):
            (undocumented)

        m (`~.int`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        kl (`~.int`):
            (undocumented)

        ku (`~.int`):
            (undocumented)

        alpha (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        AP (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        x (`~.hip._util.types.ListOfPointer`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        beta (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        y (`~.hip._util.types.ListOfPointer`/`~.object`):
            (undocumented)

        incy (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    if not isinstance(trans,_hipblasOperation_t__Base):
        raise TypeError("argument 'trans' must be of type '_hipblasOperation_t__Base'")
    _hipblasDgbmvBatched__retval = hipblasStatus_t(chipblas.hipblasDgbmvBatched(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,trans.value,m,n,kl,ku,
        <const double *>hip._util.types.Pointer.fromPyobj(alpha)._ptr,
        <const double *const*>hip._util.types.Pointer.fromPyobj(AP)._ptr,lda,
        <const double *const*>hip._util.types.ListOfPointer.fromPyobj(x)._ptr,incx,
        <const double *>hip._util.types.Pointer.fromPyobj(beta)._ptr,
        <double *const*>hip._util.types.ListOfPointer.fromPyobj(y)._ptr,incy,batchCount))
    return (_hipblasDgbmvBatched__retval,)


@cython.embedsignature(True)
def hipblasCgbmvBatched(object handle, object trans, int m, int n, int kl, int ku, object alpha, object AP, int lda, object x, int incx, object beta, object y, int incy, int batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        trans (`~.hipblasOperation_t`):
            (undocumented)

        m (`~.int`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        kl (`~.int`):
            (undocumented)

        ku (`~.int`):
            (undocumented)

        alpha (`~.hipblasComplex`/`~.object`):
            (undocumented)

        AP (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        x (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        beta (`~.hipblasComplex`/`~.object`):
            (undocumented)

        y (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        incy (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    if not isinstance(trans,_hipblasOperation_t__Base):
        raise TypeError("argument 'trans' must be of type '_hipblasOperation_t__Base'")
    _hipblasCgbmvBatched__retval = hipblasStatus_t(chipblas.hipblasCgbmvBatched(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,trans.value,m,n,kl,ku,
        hipblasComplex.fromPyobj(alpha).getElementPtr(),
        <chipblas.hipblasComplex *const*>hip._util.types.Pointer.fromPyobj(AP)._ptr,lda,
        <chipblas.hipblasComplex *const*>hip._util.types.Pointer.fromPyobj(x)._ptr,incx,
        hipblasComplex.fromPyobj(beta).getElementPtr(),
        <chipblas.hipblasComplex *const*>hip._util.types.Pointer.fromPyobj(y)._ptr,incy,batchCount))
    return (_hipblasCgbmvBatched__retval,)


@cython.embedsignature(True)
def hipblasZgbmvBatched(object handle, object trans, int m, int n, int kl, int ku, object alpha, object AP, int lda, object x, int incx, object beta, object y, int incy, int batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        trans (`~.hipblasOperation_t`):
            (undocumented)

        m (`~.int`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        kl (`~.int`):
            (undocumented)

        ku (`~.int`):
            (undocumented)

        alpha (`~.hipblasDoubleComplex`/`~.object`):
            (undocumented)

        AP (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        x (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        beta (`~.hipblasDoubleComplex`/`~.object`):
            (undocumented)

        y (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        incy (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    if not isinstance(trans,_hipblasOperation_t__Base):
        raise TypeError("argument 'trans' must be of type '_hipblasOperation_t__Base'")
    _hipblasZgbmvBatched__retval = hipblasStatus_t(chipblas.hipblasZgbmvBatched(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,trans.value,m,n,kl,ku,
        hipblasDoubleComplex.fromPyobj(alpha).getElementPtr(),
        <chipblas.hipblasDoubleComplex *const*>hip._util.types.Pointer.fromPyobj(AP)._ptr,lda,
        <chipblas.hipblasDoubleComplex *const*>hip._util.types.Pointer.fromPyobj(x)._ptr,incx,
        hipblasDoubleComplex.fromPyobj(beta).getElementPtr(),
        <chipblas.hipblasDoubleComplex *const*>hip._util.types.Pointer.fromPyobj(y)._ptr,incy,batchCount))
    return (_hipblasZgbmvBatched__retval,)


@cython.embedsignature(True)
def hipblasCgbmvBatched_v2(object handle, object trans, int m, int n, int kl, int ku, object alpha, object AP, int lda, object x, int incx, object beta, object y, int incy, int batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        trans (`~.hipblasOperation_t`):
            (undocumented)

        m (`~.int`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        kl (`~.int`):
            (undocumented)

        ku (`~.int`):
            (undocumented)

        alpha (`~.float2`/`~.object`):
            (undocumented)

        AP (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        x (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        beta (`~.float2`/`~.object`):
            (undocumented)

        y (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        incy (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    if not isinstance(trans,_hipblasOperation_t__Base):
        raise TypeError("argument 'trans' must be of type '_hipblasOperation_t__Base'")
    _hipblasCgbmvBatched_v2__retval = hipblasStatus_t(chipblas.hipblasCgbmvBatched_v2(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,trans.value,m,n,kl,ku,
        float2.fromPyobj(alpha).getElementPtr(),
        <chipblas.float2 *const*>hip._util.types.Pointer.fromPyobj(AP)._ptr,lda,
        <chipblas.float2 *const*>hip._util.types.Pointer.fromPyobj(x)._ptr,incx,
        float2.fromPyobj(beta).getElementPtr(),
        <chipblas.float2 *const*>hip._util.types.Pointer.fromPyobj(y)._ptr,incy,batchCount))
    return (_hipblasCgbmvBatched_v2__retval,)


@cython.embedsignature(True)
def hipblasZgbmvBatched_v2(object handle, object trans, int m, int n, int kl, int ku, object alpha, object AP, int lda, object x, int incx, object beta, object y, int incy, int batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        trans (`~.hipblasOperation_t`):
            (undocumented)

        m (`~.int`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        kl (`~.int`):
            (undocumented)

        ku (`~.int`):
            (undocumented)

        alpha (`~.double2`/`~.object`):
            (undocumented)

        AP (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        x (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        beta (`~.double2`/`~.object`):
            (undocumented)

        y (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        incy (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    if not isinstance(trans,_hipblasOperation_t__Base):
        raise TypeError("argument 'trans' must be of type '_hipblasOperation_t__Base'")
    _hipblasZgbmvBatched_v2__retval = hipblasStatus_t(chipblas.hipblasZgbmvBatched_v2(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,trans.value,m,n,kl,ku,
        double2.fromPyobj(alpha).getElementPtr(),
        <chipblas.double2 *const*>hip._util.types.Pointer.fromPyobj(AP)._ptr,lda,
        <chipblas.double2 *const*>hip._util.types.Pointer.fromPyobj(x)._ptr,incx,
        double2.fromPyobj(beta).getElementPtr(),
        <chipblas.double2 *const*>hip._util.types.Pointer.fromPyobj(y)._ptr,incy,batchCount))
    return (_hipblasZgbmvBatched_v2__retval,)


@cython.embedsignature(True)
def hipblasSgbmvBatched_64(object handle, object trans, long m, long n, long kl, long ku, object alpha, object AP, long lda, object x, long incx, object beta, object y, long incy, long batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        trans (`~.hipblasOperation_t`):
            (undocumented)

        m (`~.int`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        kl (`~.int`):
            (undocumented)

        ku (`~.int`):
            (undocumented)

        alpha (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        AP (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        x (`~.hip._util.types.ListOfPointer`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        beta (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        y (`~.hip._util.types.ListOfPointer`/`~.object`):
            (undocumented)

        incy (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    if not isinstance(trans,_hipblasOperation_t__Base):
        raise TypeError("argument 'trans' must be of type '_hipblasOperation_t__Base'")
    _hipblasSgbmvBatched_64__retval = hipblasStatus_t(chipblas.hipblasSgbmvBatched_64(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,trans.value,m,n,kl,ku,
        <const float *>hip._util.types.Pointer.fromPyobj(alpha)._ptr,
        <const float *const*>hip._util.types.Pointer.fromPyobj(AP)._ptr,lda,
        <const float *const*>hip._util.types.ListOfPointer.fromPyobj(x)._ptr,incx,
        <const float *>hip._util.types.Pointer.fromPyobj(beta)._ptr,
        <float *const*>hip._util.types.ListOfPointer.fromPyobj(y)._ptr,incy,batchCount))
    return (_hipblasSgbmvBatched_64__retval,)


@cython.embedsignature(True)
def hipblasDgbmvBatched_64(object handle, object trans, long m, long n, long kl, long ku, object alpha, object AP, long lda, object x, long incx, object beta, object y, long incy, long batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        trans (`~.hipblasOperation_t`):
            (undocumented)

        m (`~.int`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        kl (`~.int`):
            (undocumented)

        ku (`~.int`):
            (undocumented)

        alpha (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        AP (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        x (`~.hip._util.types.ListOfPointer`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        beta (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        y (`~.hip._util.types.ListOfPointer`/`~.object`):
            (undocumented)

        incy (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    if not isinstance(trans,_hipblasOperation_t__Base):
        raise TypeError("argument 'trans' must be of type '_hipblasOperation_t__Base'")
    _hipblasDgbmvBatched_64__retval = hipblasStatus_t(chipblas.hipblasDgbmvBatched_64(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,trans.value,m,n,kl,ku,
        <const double *>hip._util.types.Pointer.fromPyobj(alpha)._ptr,
        <const double *const*>hip._util.types.Pointer.fromPyobj(AP)._ptr,lda,
        <const double *const*>hip._util.types.ListOfPointer.fromPyobj(x)._ptr,incx,
        <const double *>hip._util.types.Pointer.fromPyobj(beta)._ptr,
        <double *const*>hip._util.types.ListOfPointer.fromPyobj(y)._ptr,incy,batchCount))
    return (_hipblasDgbmvBatched_64__retval,)


@cython.embedsignature(True)
def hipblasCgbmvBatched_64(object handle, object trans, long m, long n, long kl, long ku, object alpha, object AP, long lda, object x, long incx, object beta, object y, long incy, long batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        trans (`~.hipblasOperation_t`):
            (undocumented)

        m (`~.int`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        kl (`~.int`):
            (undocumented)

        ku (`~.int`):
            (undocumented)

        alpha (`~.hipblasComplex`/`~.object`):
            (undocumented)

        AP (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        x (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        beta (`~.hipblasComplex`/`~.object`):
            (undocumented)

        y (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        incy (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    if not isinstance(trans,_hipblasOperation_t__Base):
        raise TypeError("argument 'trans' must be of type '_hipblasOperation_t__Base'")
    _hipblasCgbmvBatched_64__retval = hipblasStatus_t(chipblas.hipblasCgbmvBatched_64(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,trans.value,m,n,kl,ku,
        hipblasComplex.fromPyobj(alpha).getElementPtr(),
        <chipblas.hipblasComplex *const*>hip._util.types.Pointer.fromPyobj(AP)._ptr,lda,
        <chipblas.hipblasComplex *const*>hip._util.types.Pointer.fromPyobj(x)._ptr,incx,
        hipblasComplex.fromPyobj(beta).getElementPtr(),
        <chipblas.hipblasComplex *const*>hip._util.types.Pointer.fromPyobj(y)._ptr,incy,batchCount))
    return (_hipblasCgbmvBatched_64__retval,)


@cython.embedsignature(True)
def hipblasZgbmvBatched_64(object handle, object trans, long m, long n, long kl, long ku, object alpha, object AP, long lda, object x, long incx, object beta, object y, long incy, long batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        trans (`~.hipblasOperation_t`):
            (undocumented)

        m (`~.int`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        kl (`~.int`):
            (undocumented)

        ku (`~.int`):
            (undocumented)

        alpha (`~.hipblasDoubleComplex`/`~.object`):
            (undocumented)

        AP (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        x (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        beta (`~.hipblasDoubleComplex`/`~.object`):
            (undocumented)

        y (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        incy (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    if not isinstance(trans,_hipblasOperation_t__Base):
        raise TypeError("argument 'trans' must be of type '_hipblasOperation_t__Base'")
    _hipblasZgbmvBatched_64__retval = hipblasStatus_t(chipblas.hipblasZgbmvBatched_64(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,trans.value,m,n,kl,ku,
        hipblasDoubleComplex.fromPyobj(alpha).getElementPtr(),
        <chipblas.hipblasDoubleComplex *const*>hip._util.types.Pointer.fromPyobj(AP)._ptr,lda,
        <chipblas.hipblasDoubleComplex *const*>hip._util.types.Pointer.fromPyobj(x)._ptr,incx,
        hipblasDoubleComplex.fromPyobj(beta).getElementPtr(),
        <chipblas.hipblasDoubleComplex *const*>hip._util.types.Pointer.fromPyobj(y)._ptr,incy,batchCount))
    return (_hipblasZgbmvBatched_64__retval,)


@cython.embedsignature(True)
def hipblasCgbmvBatched_v2_64(object handle, object trans, long m, long n, long kl, long ku, object alpha, object AP, long lda, object x, long incx, object beta, object y, long incy, long batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        trans (`~.hipblasOperation_t`):
            (undocumented)

        m (`~.int`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        kl (`~.int`):
            (undocumented)

        ku (`~.int`):
            (undocumented)

        alpha (`~.float2`/`~.object`):
            (undocumented)

        AP (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        x (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        beta (`~.float2`/`~.object`):
            (undocumented)

        y (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        incy (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    if not isinstance(trans,_hipblasOperation_t__Base):
        raise TypeError("argument 'trans' must be of type '_hipblasOperation_t__Base'")
    _hipblasCgbmvBatched_v2_64__retval = hipblasStatus_t(chipblas.hipblasCgbmvBatched_v2_64(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,trans.value,m,n,kl,ku,
        float2.fromPyobj(alpha).getElementPtr(),
        <chipblas.float2 *const*>hip._util.types.Pointer.fromPyobj(AP)._ptr,lda,
        <chipblas.float2 *const*>hip._util.types.Pointer.fromPyobj(x)._ptr,incx,
        float2.fromPyobj(beta).getElementPtr(),
        <chipblas.float2 *const*>hip._util.types.Pointer.fromPyobj(y)._ptr,incy,batchCount))
    return (_hipblasCgbmvBatched_v2_64__retval,)


@cython.embedsignature(True)
def hipblasZgbmvBatched_v2_64(object handle, object trans, long m, long n, long kl, long ku, object alpha, object AP, long lda, object x, long incx, object beta, object y, long incy, long batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        trans (`~.hipblasOperation_t`):
            (undocumented)

        m (`~.int`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        kl (`~.int`):
            (undocumented)

        ku (`~.int`):
            (undocumented)

        alpha (`~.double2`/`~.object`):
            (undocumented)

        AP (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        x (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        beta (`~.double2`/`~.object`):
            (undocumented)

        y (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        incy (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    if not isinstance(trans,_hipblasOperation_t__Base):
        raise TypeError("argument 'trans' must be of type '_hipblasOperation_t__Base'")
    _hipblasZgbmvBatched_v2_64__retval = hipblasStatus_t(chipblas.hipblasZgbmvBatched_v2_64(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,trans.value,m,n,kl,ku,
        double2.fromPyobj(alpha).getElementPtr(),
        <chipblas.double2 *const*>hip._util.types.Pointer.fromPyobj(AP)._ptr,lda,
        <chipblas.double2 *const*>hip._util.types.Pointer.fromPyobj(x)._ptr,incx,
        double2.fromPyobj(beta).getElementPtr(),
        <chipblas.double2 *const*>hip._util.types.Pointer.fromPyobj(y)._ptr,incy,batchCount))
    return (_hipblasZgbmvBatched_v2_64__retval,)


@cython.embedsignature(True)
def hipblasSgbmvStridedBatched(object handle, object trans, int m, int n, int kl, int ku, object alpha, object AP, int lda, long strideA, object x, int incx, long stridex, object beta, object y, int incy, long stridey, int batchCount):
    r"""BLAS Level 2 API

    @{

    gbmvStridedBatched performs one of the matrix-vector operations

    y_i := alpha*A_i*x_i    + beta*y_i,   or
        y_i := alpha*A_i**T*x_i + beta*y_i,   or
        y_i := alpha*A_i**H*x_i + beta*y_i,

    where (A_i, x_i, y_i) is the i-th instance of the batch.
    alpha and beta are scalars, x_i and y_i are vectors and A_i is an
    m by n banded matrix with kl sub-diagonals and ku super-diagonals,
    for i = 1, ..., batchCount.

    - Supported precisions in rocBLAS : s,d,c,z
    - Supported precisions in cuBLAS  : No support

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`) -- *IN*:
            [hipblasHandle_t]
            handle to the hipblas library context queue.

        trans (`~.hipblasOperation_t`) -- *IN*:
            [hipblasOperation_t]
            indicates whether matrix A is tranposed (conjugated) or not

        m (`~.int`) -- *IN*:
            [int]
            number of rows of matrix A

        n (`~.int`) -- *IN*:
            [int]
            number of columns of matrix A

        kl (`~.int`) -- *IN*:
            [int]
            number of sub-diagonals of A

        ku (`~.int`) -- *IN*:
            [int]
            number of super-diagonals of A

        alpha (`~.hip._util.types.Pointer`/`~.object`) -- *IN*:
            device pointer or host pointer to scalar alpha.

        AP (`~.hip._util.types.Pointer`/`~.object`) -- *IN*:
            device pointer to first banded matrix (A_1).
            Leading (kl + ku + 1) by n part of the matrix contains the coefficients
            of the banded matrix. The leading diagonal resides in row (ku + 1) with
            the first super-diagonal above on the RHS of row ku. The first sub-diagonal
            resides below on the LHS of row ku + 2. This propagates up and down across
            sub/super-diagonals.
              Ex: (m = n = 7; ku = 2, kl = 2)
              1 2 3 0 0 0 0             0 0 3 3 3 3 3
              4 1 2 3 0 0 0             0 2 2 2 2 2 2
              5 4 1 2 3 0 0    ---->    1 1 1 1 1 1 1
              0 5 4 1 2 3 0             4 4 4 4 4 4 0
              0 0 5 4 1 2 0             5 5 5 5 5 0 0
              0 0 0 5 4 1 2             0 0 0 0 0 0 0
              0 0 0 0 5 4 1             0 0 0 0 0 0 0
            Note that the empty elements which don't correspond to data will not
            be referenced.

        lda (`~.int`) -- *IN*:
            [int]
            specifies the leading dimension of A. Must be >= (kl + ku + 1)

        strideA (`~.int`) -- *IN*:
            [hipblasStride]
            stride from the start of one matrix (A_i) and the next one (A_i+1)

        x (`~.hip._util.types.Pointer`/`~.object`) -- *IN*:
            device pointer to first vector (x_1).

        incx (`~.int`) -- *IN*:
            [int]
            specifies the increment for the elements of x.

        stridex (`~.int`) -- *IN*:
            [hipblasStride]
            stride from the start of one vector (x_i) and the next one (x_i+1)

        beta (`~.hip._util.types.Pointer`/`~.object`) -- *IN*:
            device pointer or host pointer to scalar beta.

        y (`~.hip._util.types.Pointer`/`~.object`) -- *INOUT*:
            device pointer to first vector (y_1).

        incy (`~.int`) -- *IN*:
            [int]
            specifies the increment for the elements of y.

        stridey (`~.int`) -- *IN*:
            [hipblasStride]
            stride from the start of one vector (y_i) and the next one (x_i+1)

        batchCount (`~.int`) -- *IN*:
            [int]
            specifies the number of instances in the batch.
    """
    if not isinstance(trans,_hipblasOperation_t__Base):
        raise TypeError("argument 'trans' must be of type '_hipblasOperation_t__Base'")
    _hipblasSgbmvStridedBatched__retval = hipblasStatus_t(chipblas.hipblasSgbmvStridedBatched(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,trans.value,m,n,kl,ku,
        <const float *>hip._util.types.Pointer.fromPyobj(alpha)._ptr,
        <const float *>hip._util.types.Pointer.fromPyobj(AP)._ptr,lda,strideA,
        <const float *>hip._util.types.Pointer.fromPyobj(x)._ptr,incx,stridex,
        <const float *>hip._util.types.Pointer.fromPyobj(beta)._ptr,
        <float *>hip._util.types.Pointer.fromPyobj(y)._ptr,incy,stridey,batchCount))
    return (_hipblasSgbmvStridedBatched__retval,)


@cython.embedsignature(True)
def hipblasDgbmvStridedBatched(object handle, object trans, int m, int n, int kl, int ku, object alpha, object AP, int lda, long strideA, object x, int incx, long stridex, object beta, object y, int incy, long stridey, int batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        trans (`~.hipblasOperation_t`):
            (undocumented)

        m (`~.int`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        kl (`~.int`):
            (undocumented)

        ku (`~.int`):
            (undocumented)

        alpha (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        AP (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        strideA (`~.int`):
            (undocumented)

        x (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        stridex (`~.int`):
            (undocumented)

        beta (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        y (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        incy (`~.int`):
            (undocumented)

        stridey (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    if not isinstance(trans,_hipblasOperation_t__Base):
        raise TypeError("argument 'trans' must be of type '_hipblasOperation_t__Base'")
    _hipblasDgbmvStridedBatched__retval = hipblasStatus_t(chipblas.hipblasDgbmvStridedBatched(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,trans.value,m,n,kl,ku,
        <const double *>hip._util.types.Pointer.fromPyobj(alpha)._ptr,
        <const double *>hip._util.types.Pointer.fromPyobj(AP)._ptr,lda,strideA,
        <const double *>hip._util.types.Pointer.fromPyobj(x)._ptr,incx,stridex,
        <const double *>hip._util.types.Pointer.fromPyobj(beta)._ptr,
        <double *>hip._util.types.Pointer.fromPyobj(y)._ptr,incy,stridey,batchCount))
    return (_hipblasDgbmvStridedBatched__retval,)


@cython.embedsignature(True)
def hipblasCgbmvStridedBatched(object handle, object trans, int m, int n, int kl, int ku, object alpha, object AP, int lda, long strideA, object x, int incx, long stridex, object beta, object y, int incy, long stridey, int batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        trans (`~.hipblasOperation_t`):
            (undocumented)

        m (`~.int`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        kl (`~.int`):
            (undocumented)

        ku (`~.int`):
            (undocumented)

        alpha (`~.hipblasComplex`/`~.object`):
            (undocumented)

        AP (`~.hipblasComplex`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        strideA (`~.int`):
            (undocumented)

        x (`~.hipblasComplex`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        stridex (`~.int`):
            (undocumented)

        beta (`~.hipblasComplex`/`~.object`):
            (undocumented)

        y (`~.hipblasComplex`/`~.object`):
            (undocumented)

        incy (`~.int`):
            (undocumented)

        stridey (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    if not isinstance(trans,_hipblasOperation_t__Base):
        raise TypeError("argument 'trans' must be of type '_hipblasOperation_t__Base'")
    _hipblasCgbmvStridedBatched__retval = hipblasStatus_t(chipblas.hipblasCgbmvStridedBatched(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,trans.value,m,n,kl,ku,
        hipblasComplex.fromPyobj(alpha).getElementPtr(),
        hipblasComplex.fromPyobj(AP).getElementPtr(),lda,strideA,
        hipblasComplex.fromPyobj(x).getElementPtr(),incx,stridex,
        hipblasComplex.fromPyobj(beta).getElementPtr(),
        hipblasComplex.fromPyobj(y).getElementPtr(),incy,stridey,batchCount))
    return (_hipblasCgbmvStridedBatched__retval,)


@cython.embedsignature(True)
def hipblasZgbmvStridedBatched(object handle, object trans, int m, int n, int kl, int ku, object alpha, object AP, int lda, long strideA, object x, int incx, long stridex, object beta, object y, int incy, long stridey, int batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        trans (`~.hipblasOperation_t`):
            (undocumented)

        m (`~.int`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        kl (`~.int`):
            (undocumented)

        ku (`~.int`):
            (undocumented)

        alpha (`~.hipblasDoubleComplex`/`~.object`):
            (undocumented)

        AP (`~.hipblasDoubleComplex`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        strideA (`~.int`):
            (undocumented)

        x (`~.hipblasDoubleComplex`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        stridex (`~.int`):
            (undocumented)

        beta (`~.hipblasDoubleComplex`/`~.object`):
            (undocumented)

        y (`~.hipblasDoubleComplex`/`~.object`):
            (undocumented)

        incy (`~.int`):
            (undocumented)

        stridey (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    if not isinstance(trans,_hipblasOperation_t__Base):
        raise TypeError("argument 'trans' must be of type '_hipblasOperation_t__Base'")
    _hipblasZgbmvStridedBatched__retval = hipblasStatus_t(chipblas.hipblasZgbmvStridedBatched(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,trans.value,m,n,kl,ku,
        hipblasDoubleComplex.fromPyobj(alpha).getElementPtr(),
        hipblasDoubleComplex.fromPyobj(AP).getElementPtr(),lda,strideA,
        hipblasDoubleComplex.fromPyobj(x).getElementPtr(),incx,stridex,
        hipblasDoubleComplex.fromPyobj(beta).getElementPtr(),
        hipblasDoubleComplex.fromPyobj(y).getElementPtr(),incy,stridey,batchCount))
    return (_hipblasZgbmvStridedBatched__retval,)


@cython.embedsignature(True)
def hipblasCgbmvStridedBatched_v2(object handle, object trans, int m, int n, int kl, int ku, object alpha, object AP, int lda, long strideA, object x, int incx, long stridex, object beta, object y, int incy, long stridey, int batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        trans (`~.hipblasOperation_t`):
            (undocumented)

        m (`~.int`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        kl (`~.int`):
            (undocumented)

        ku (`~.int`):
            (undocumented)

        alpha (`~.float2`/`~.object`):
            (undocumented)

        AP (`~.float2`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        strideA (`~.int`):
            (undocumented)

        x (`~.float2`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        stridex (`~.int`):
            (undocumented)

        beta (`~.float2`/`~.object`):
            (undocumented)

        y (`~.float2`/`~.object`):
            (undocumented)

        incy (`~.int`):
            (undocumented)

        stridey (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    if not isinstance(trans,_hipblasOperation_t__Base):
        raise TypeError("argument 'trans' must be of type '_hipblasOperation_t__Base'")
    _hipblasCgbmvStridedBatched_v2__retval = hipblasStatus_t(chipblas.hipblasCgbmvStridedBatched_v2(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,trans.value,m,n,kl,ku,
        float2.fromPyobj(alpha).getElementPtr(),
        float2.fromPyobj(AP).getElementPtr(),lda,strideA,
        float2.fromPyobj(x).getElementPtr(),incx,stridex,
        float2.fromPyobj(beta).getElementPtr(),
        float2.fromPyobj(y).getElementPtr(),incy,stridey,batchCount))
    return (_hipblasCgbmvStridedBatched_v2__retval,)


@cython.embedsignature(True)
def hipblasZgbmvStridedBatched_v2(object handle, object trans, int m, int n, int kl, int ku, object alpha, object AP, int lda, long strideA, object x, int incx, long stridex, object beta, object y, int incy, long stridey, int batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        trans (`~.hipblasOperation_t`):
            (undocumented)

        m (`~.int`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        kl (`~.int`):
            (undocumented)

        ku (`~.int`):
            (undocumented)

        alpha (`~.double2`/`~.object`):
            (undocumented)

        AP (`~.double2`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        strideA (`~.int`):
            (undocumented)

        x (`~.double2`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        stridex (`~.int`):
            (undocumented)

        beta (`~.double2`/`~.object`):
            (undocumented)

        y (`~.double2`/`~.object`):
            (undocumented)

        incy (`~.int`):
            (undocumented)

        stridey (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    if not isinstance(trans,_hipblasOperation_t__Base):
        raise TypeError("argument 'trans' must be of type '_hipblasOperation_t__Base'")
    _hipblasZgbmvStridedBatched_v2__retval = hipblasStatus_t(chipblas.hipblasZgbmvStridedBatched_v2(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,trans.value,m,n,kl,ku,
        double2.fromPyobj(alpha).getElementPtr(),
        double2.fromPyobj(AP).getElementPtr(),lda,strideA,
        double2.fromPyobj(x).getElementPtr(),incx,stridex,
        double2.fromPyobj(beta).getElementPtr(),
        double2.fromPyobj(y).getElementPtr(),incy,stridey,batchCount))
    return (_hipblasZgbmvStridedBatched_v2__retval,)


@cython.embedsignature(True)
def hipblasSgbmvStridedBatched_64(object handle, object trans, long m, long n, long kl, long ku, object alpha, object AP, long lda, long strideA, object x, long incx, long stridex, object beta, object y, long incy, long stridey, long batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        trans (`~.hipblasOperation_t`):
            (undocumented)

        m (`~.int`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        kl (`~.int`):
            (undocumented)

        ku (`~.int`):
            (undocumented)

        alpha (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        AP (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        strideA (`~.int`):
            (undocumented)

        x (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        stridex (`~.int`):
            (undocumented)

        beta (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        y (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        incy (`~.int`):
            (undocumented)

        stridey (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    if not isinstance(trans,_hipblasOperation_t__Base):
        raise TypeError("argument 'trans' must be of type '_hipblasOperation_t__Base'")
    _hipblasSgbmvStridedBatched_64__retval = hipblasStatus_t(chipblas.hipblasSgbmvStridedBatched_64(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,trans.value,m,n,kl,ku,
        <const float *>hip._util.types.Pointer.fromPyobj(alpha)._ptr,
        <const float *>hip._util.types.Pointer.fromPyobj(AP)._ptr,lda,strideA,
        <const float *>hip._util.types.Pointer.fromPyobj(x)._ptr,incx,stridex,
        <const float *>hip._util.types.Pointer.fromPyobj(beta)._ptr,
        <float *>hip._util.types.Pointer.fromPyobj(y)._ptr,incy,stridey,batchCount))
    return (_hipblasSgbmvStridedBatched_64__retval,)


@cython.embedsignature(True)
def hipblasDgbmvStridedBatched_64(object handle, object trans, long m, long n, long kl, long ku, object alpha, object AP, long lda, long strideA, object x, long incx, long stridex, object beta, object y, long incy, long stridey, long batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        trans (`~.hipblasOperation_t`):
            (undocumented)

        m (`~.int`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        kl (`~.int`):
            (undocumented)

        ku (`~.int`):
            (undocumented)

        alpha (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        AP (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        strideA (`~.int`):
            (undocumented)

        x (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        stridex (`~.int`):
            (undocumented)

        beta (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        y (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        incy (`~.int`):
            (undocumented)

        stridey (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    if not isinstance(trans,_hipblasOperation_t__Base):
        raise TypeError("argument 'trans' must be of type '_hipblasOperation_t__Base'")
    _hipblasDgbmvStridedBatched_64__retval = hipblasStatus_t(chipblas.hipblasDgbmvStridedBatched_64(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,trans.value,m,n,kl,ku,
        <const double *>hip._util.types.Pointer.fromPyobj(alpha)._ptr,
        <const double *>hip._util.types.Pointer.fromPyobj(AP)._ptr,lda,strideA,
        <const double *>hip._util.types.Pointer.fromPyobj(x)._ptr,incx,stridex,
        <const double *>hip._util.types.Pointer.fromPyobj(beta)._ptr,
        <double *>hip._util.types.Pointer.fromPyobj(y)._ptr,incy,stridey,batchCount))
    return (_hipblasDgbmvStridedBatched_64__retval,)


@cython.embedsignature(True)
def hipblasCgbmvStridedBatched_64(object handle, object trans, long m, long n, long kl, long ku, object alpha, object AP, long lda, long strideA, object x, long incx, long stridex, object beta, object y, long incy, long stridey, long batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        trans (`~.hipblasOperation_t`):
            (undocumented)

        m (`~.int`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        kl (`~.int`):
            (undocumented)

        ku (`~.int`):
            (undocumented)

        alpha (`~.hipblasComplex`/`~.object`):
            (undocumented)

        AP (`~.hipblasComplex`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        strideA (`~.int`):
            (undocumented)

        x (`~.hipblasComplex`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        stridex (`~.int`):
            (undocumented)

        beta (`~.hipblasComplex`/`~.object`):
            (undocumented)

        y (`~.hipblasComplex`/`~.object`):
            (undocumented)

        incy (`~.int`):
            (undocumented)

        stridey (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    if not isinstance(trans,_hipblasOperation_t__Base):
        raise TypeError("argument 'trans' must be of type '_hipblasOperation_t__Base'")
    _hipblasCgbmvStridedBatched_64__retval = hipblasStatus_t(chipblas.hipblasCgbmvStridedBatched_64(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,trans.value,m,n,kl,ku,
        hipblasComplex.fromPyobj(alpha).getElementPtr(),
        hipblasComplex.fromPyobj(AP).getElementPtr(),lda,strideA,
        hipblasComplex.fromPyobj(x).getElementPtr(),incx,stridex,
        hipblasComplex.fromPyobj(beta).getElementPtr(),
        hipblasComplex.fromPyobj(y).getElementPtr(),incy,stridey,batchCount))
    return (_hipblasCgbmvStridedBatched_64__retval,)


@cython.embedsignature(True)
def hipblasZgbmvStridedBatched_64(object handle, object trans, long m, long n, long kl, long ku, object alpha, object AP, long lda, long strideA, object x, long incx, long stridex, object beta, object y, long incy, long stridey, long batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        trans (`~.hipblasOperation_t`):
            (undocumented)

        m (`~.int`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        kl (`~.int`):
            (undocumented)

        ku (`~.int`):
            (undocumented)

        alpha (`~.hipblasDoubleComplex`/`~.object`):
            (undocumented)

        AP (`~.hipblasDoubleComplex`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        strideA (`~.int`):
            (undocumented)

        x (`~.hipblasDoubleComplex`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        stridex (`~.int`):
            (undocumented)

        beta (`~.hipblasDoubleComplex`/`~.object`):
            (undocumented)

        y (`~.hipblasDoubleComplex`/`~.object`):
            (undocumented)

        incy (`~.int`):
            (undocumented)

        stridey (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    if not isinstance(trans,_hipblasOperation_t__Base):
        raise TypeError("argument 'trans' must be of type '_hipblasOperation_t__Base'")
    _hipblasZgbmvStridedBatched_64__retval = hipblasStatus_t(chipblas.hipblasZgbmvStridedBatched_64(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,trans.value,m,n,kl,ku,
        hipblasDoubleComplex.fromPyobj(alpha).getElementPtr(),
        hipblasDoubleComplex.fromPyobj(AP).getElementPtr(),lda,strideA,
        hipblasDoubleComplex.fromPyobj(x).getElementPtr(),incx,stridex,
        hipblasDoubleComplex.fromPyobj(beta).getElementPtr(),
        hipblasDoubleComplex.fromPyobj(y).getElementPtr(),incy,stridey,batchCount))
    return (_hipblasZgbmvStridedBatched_64__retval,)


@cython.embedsignature(True)
def hipblasCgbmvStridedBatched_v2_64(object handle, object trans, long m, long n, long kl, long ku, object alpha, object AP, long lda, long strideA, object x, long incx, long stridex, object beta, object y, long incy, long stridey, long batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        trans (`~.hipblasOperation_t`):
            (undocumented)

        m (`~.int`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        kl (`~.int`):
            (undocumented)

        ku (`~.int`):
            (undocumented)

        alpha (`~.float2`/`~.object`):
            (undocumented)

        AP (`~.float2`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        strideA (`~.int`):
            (undocumented)

        x (`~.float2`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        stridex (`~.int`):
            (undocumented)

        beta (`~.float2`/`~.object`):
            (undocumented)

        y (`~.float2`/`~.object`):
            (undocumented)

        incy (`~.int`):
            (undocumented)

        stridey (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    if not isinstance(trans,_hipblasOperation_t__Base):
        raise TypeError("argument 'trans' must be of type '_hipblasOperation_t__Base'")
    _hipblasCgbmvStridedBatched_v2_64__retval = hipblasStatus_t(chipblas.hipblasCgbmvStridedBatched_v2_64(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,trans.value,m,n,kl,ku,
        float2.fromPyobj(alpha).getElementPtr(),
        float2.fromPyobj(AP).getElementPtr(),lda,strideA,
        float2.fromPyobj(x).getElementPtr(),incx,stridex,
        float2.fromPyobj(beta).getElementPtr(),
        float2.fromPyobj(y).getElementPtr(),incy,stridey,batchCount))
    return (_hipblasCgbmvStridedBatched_v2_64__retval,)


@cython.embedsignature(True)
def hipblasZgbmvStridedBatched_v2_64(object handle, object trans, long m, long n, long kl, long ku, object alpha, object AP, long lda, long strideA, object x, long incx, long stridex, object beta, object y, long incy, long stridey, long batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        trans (`~.hipblasOperation_t`):
            (undocumented)

        m (`~.int`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        kl (`~.int`):
            (undocumented)

        ku (`~.int`):
            (undocumented)

        alpha (`~.double2`/`~.object`):
            (undocumented)

        AP (`~.double2`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        strideA (`~.int`):
            (undocumented)

        x (`~.double2`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        stridex (`~.int`):
            (undocumented)

        beta (`~.double2`/`~.object`):
            (undocumented)

        y (`~.double2`/`~.object`):
            (undocumented)

        incy (`~.int`):
            (undocumented)

        stridey (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    if not isinstance(trans,_hipblasOperation_t__Base):
        raise TypeError("argument 'trans' must be of type '_hipblasOperation_t__Base'")
    _hipblasZgbmvStridedBatched_v2_64__retval = hipblasStatus_t(chipblas.hipblasZgbmvStridedBatched_v2_64(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,trans.value,m,n,kl,ku,
        double2.fromPyobj(alpha).getElementPtr(),
        double2.fromPyobj(AP).getElementPtr(),lda,strideA,
        double2.fromPyobj(x).getElementPtr(),incx,stridex,
        double2.fromPyobj(beta).getElementPtr(),
        double2.fromPyobj(y).getElementPtr(),incy,stridey,batchCount))
    return (_hipblasZgbmvStridedBatched_v2_64__retval,)


@cython.embedsignature(True)
def hipblasSgemv(object handle, object trans, int m, int n, object alpha, object AP, int lda, object x, int incx, object beta, object y, int incy):
    r"""BLAS Level 2 API

    @{

    gemv performs one of the matrix-vector operations

    y := alpha*A*x    + beta*y,   or
        y := alpha*A**T*x + beta*y,   or
        y := alpha*A**H*x + beta*y,

    where alpha and beta are scalars, x and y are vectors and A is an
    m by n matrix.

    - Supported precisions in rocBLAS : s,d,c,z
    - Supported precisions in cuBLAS  : s,d,c,z

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`) -- *IN*:
            [hipblasHandle_t]
            handle to the hipblas library context queue.

        trans (`~.hipblasOperation_t`) -- *IN*:
            [hipblasOperation_t]
            indicates whether matrix A is tranposed (conjugated) or not

        m (`~.int`) -- *IN*:
            [int]
            number of rows of matrix A

        n (`~.int`) -- *IN*:
            [int]
            number of columns of matrix A

        alpha (`~.hip._util.types.Pointer`/`~.object`) -- *IN*:
            device pointer or host pointer to scalar alpha.

        AP (`~.hip._util.types.Pointer`/`~.object`) -- *IN*:
            device pointer storing matrix A.

        lda (`~.int`) -- *IN*:
            [int]
            specifies the leading dimension of A.

        x (`~.hip._util.types.Pointer`/`~.object`) -- *IN*:
            device pointer storing vector x.

        incx (`~.int`) -- *IN*:
            [int]
            specifies the increment for the elements of x.

        beta (`~.hip._util.types.Pointer`/`~.object`) -- *IN*:
            device pointer or host pointer to scalar beta.

        y (`~.hip._util.types.Pointer`/`~.object`) -- *INOUT*:
            device pointer storing vector y.

        incy (`~.int`) -- *IN*:
            [int]
            specifies the increment for the elements of y.
    """
    if not isinstance(trans,_hipblasOperation_t__Base):
        raise TypeError("argument 'trans' must be of type '_hipblasOperation_t__Base'")
    _hipblasSgemv__retval = hipblasStatus_t(chipblas.hipblasSgemv(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,trans.value,m,n,
        <const float *>hip._util.types.Pointer.fromPyobj(alpha)._ptr,
        <const float *>hip._util.types.Pointer.fromPyobj(AP)._ptr,lda,
        <const float *>hip._util.types.Pointer.fromPyobj(x)._ptr,incx,
        <const float *>hip._util.types.Pointer.fromPyobj(beta)._ptr,
        <float *>hip._util.types.Pointer.fromPyobj(y)._ptr,incy))
    return (_hipblasSgemv__retval,)


@cython.embedsignature(True)
def hipblasDgemv(object handle, object trans, int m, int n, object alpha, object AP, int lda, object x, int incx, object beta, object y, int incy):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        trans (`~.hipblasOperation_t`):
            (undocumented)

        m (`~.int`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        alpha (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        AP (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        x (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        beta (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        y (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        incy (`~.int`):
            (undocumented)
    """
    if not isinstance(trans,_hipblasOperation_t__Base):
        raise TypeError("argument 'trans' must be of type '_hipblasOperation_t__Base'")
    _hipblasDgemv__retval = hipblasStatus_t(chipblas.hipblasDgemv(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,trans.value,m,n,
        <const double *>hip._util.types.Pointer.fromPyobj(alpha)._ptr,
        <const double *>hip._util.types.Pointer.fromPyobj(AP)._ptr,lda,
        <const double *>hip._util.types.Pointer.fromPyobj(x)._ptr,incx,
        <const double *>hip._util.types.Pointer.fromPyobj(beta)._ptr,
        <double *>hip._util.types.Pointer.fromPyobj(y)._ptr,incy))
    return (_hipblasDgemv__retval,)


@cython.embedsignature(True)
def hipblasCgemv(object handle, object trans, int m, int n, object alpha, object AP, int lda, object x, int incx, object beta, object y, int incy):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        trans (`~.hipblasOperation_t`):
            (undocumented)

        m (`~.int`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        alpha (`~.hipblasComplex`/`~.object`):
            (undocumented)

        AP (`~.hipblasComplex`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        x (`~.hipblasComplex`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        beta (`~.hipblasComplex`/`~.object`):
            (undocumented)

        y (`~.hipblasComplex`/`~.object`):
            (undocumented)

        incy (`~.int`):
            (undocumented)
    """
    if not isinstance(trans,_hipblasOperation_t__Base):
        raise TypeError("argument 'trans' must be of type '_hipblasOperation_t__Base'")
    _hipblasCgemv__retval = hipblasStatus_t(chipblas.hipblasCgemv(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,trans.value,m,n,
        hipblasComplex.fromPyobj(alpha).getElementPtr(),
        hipblasComplex.fromPyobj(AP).getElementPtr(),lda,
        hipblasComplex.fromPyobj(x).getElementPtr(),incx,
        hipblasComplex.fromPyobj(beta).getElementPtr(),
        hipblasComplex.fromPyobj(y).getElementPtr(),incy))
    return (_hipblasCgemv__retval,)


@cython.embedsignature(True)
def hipblasZgemv(object handle, object trans, int m, int n, object alpha, object AP, int lda, object x, int incx, object beta, object y, int incy):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        trans (`~.hipblasOperation_t`):
            (undocumented)

        m (`~.int`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        alpha (`~.hipblasDoubleComplex`/`~.object`):
            (undocumented)

        AP (`~.hipblasDoubleComplex`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        x (`~.hipblasDoubleComplex`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        beta (`~.hipblasDoubleComplex`/`~.object`):
            (undocumented)

        y (`~.hipblasDoubleComplex`/`~.object`):
            (undocumented)

        incy (`~.int`):
            (undocumented)
    """
    if not isinstance(trans,_hipblasOperation_t__Base):
        raise TypeError("argument 'trans' must be of type '_hipblasOperation_t__Base'")
    _hipblasZgemv__retval = hipblasStatus_t(chipblas.hipblasZgemv(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,trans.value,m,n,
        hipblasDoubleComplex.fromPyobj(alpha).getElementPtr(),
        hipblasDoubleComplex.fromPyobj(AP).getElementPtr(),lda,
        hipblasDoubleComplex.fromPyobj(x).getElementPtr(),incx,
        hipblasDoubleComplex.fromPyobj(beta).getElementPtr(),
        hipblasDoubleComplex.fromPyobj(y).getElementPtr(),incy))
    return (_hipblasZgemv__retval,)


@cython.embedsignature(True)
def hipblasCgemv_v2(object handle, object trans, int m, int n, object alpha, object AP, int lda, object x, int incx, object beta, object y, int incy):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        trans (`~.hipblasOperation_t`):
            (undocumented)

        m (`~.int`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        alpha (`~.float2`/`~.object`):
            (undocumented)

        AP (`~.float2`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        x (`~.float2`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        beta (`~.float2`/`~.object`):
            (undocumented)

        y (`~.float2`/`~.object`):
            (undocumented)

        incy (`~.int`):
            (undocumented)
    """
    if not isinstance(trans,_hipblasOperation_t__Base):
        raise TypeError("argument 'trans' must be of type '_hipblasOperation_t__Base'")
    _hipblasCgemv_v2__retval = hipblasStatus_t(chipblas.hipblasCgemv_v2(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,trans.value,m,n,
        float2.fromPyobj(alpha).getElementPtr(),
        float2.fromPyobj(AP).getElementPtr(),lda,
        float2.fromPyobj(x).getElementPtr(),incx,
        float2.fromPyobj(beta).getElementPtr(),
        float2.fromPyobj(y).getElementPtr(),incy))
    return (_hipblasCgemv_v2__retval,)


@cython.embedsignature(True)
def hipblasZgemv_v2(object handle, object trans, int m, int n, object alpha, object AP, int lda, object x, int incx, object beta, object y, int incy):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        trans (`~.hipblasOperation_t`):
            (undocumented)

        m (`~.int`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        alpha (`~.double2`/`~.object`):
            (undocumented)

        AP (`~.double2`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        x (`~.double2`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        beta (`~.double2`/`~.object`):
            (undocumented)

        y (`~.double2`/`~.object`):
            (undocumented)

        incy (`~.int`):
            (undocumented)
    """
    if not isinstance(trans,_hipblasOperation_t__Base):
        raise TypeError("argument 'trans' must be of type '_hipblasOperation_t__Base'")
    _hipblasZgemv_v2__retval = hipblasStatus_t(chipblas.hipblasZgemv_v2(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,trans.value,m,n,
        double2.fromPyobj(alpha).getElementPtr(),
        double2.fromPyobj(AP).getElementPtr(),lda,
        double2.fromPyobj(x).getElementPtr(),incx,
        double2.fromPyobj(beta).getElementPtr(),
        double2.fromPyobj(y).getElementPtr(),incy))
    return (_hipblasZgemv_v2__retval,)


@cython.embedsignature(True)
def hipblasSgemv_64(object handle, object trans, long m, long n, object alpha, object AP, long lda, object x, long incx, object beta, object y, long incy):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        trans (`~.hipblasOperation_t`):
            (undocumented)

        m (`~.int`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        alpha (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        AP (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        x (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        beta (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        y (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        incy (`~.int`):
            (undocumented)
    """
    if not isinstance(trans,_hipblasOperation_t__Base):
        raise TypeError("argument 'trans' must be of type '_hipblasOperation_t__Base'")
    _hipblasSgemv_64__retval = hipblasStatus_t(chipblas.hipblasSgemv_64(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,trans.value,m,n,
        <const float *>hip._util.types.Pointer.fromPyobj(alpha)._ptr,
        <const float *>hip._util.types.Pointer.fromPyobj(AP)._ptr,lda,
        <const float *>hip._util.types.Pointer.fromPyobj(x)._ptr,incx,
        <const float *>hip._util.types.Pointer.fromPyobj(beta)._ptr,
        <float *>hip._util.types.Pointer.fromPyobj(y)._ptr,incy))
    return (_hipblasSgemv_64__retval,)


@cython.embedsignature(True)
def hipblasDgemv_64(object handle, object trans, long m, long n, object alpha, object AP, long lda, object x, long incx, object beta, object y, long incy):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        trans (`~.hipblasOperation_t`):
            (undocumented)

        m (`~.int`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        alpha (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        AP (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        x (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        beta (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        y (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        incy (`~.int`):
            (undocumented)
    """
    if not isinstance(trans,_hipblasOperation_t__Base):
        raise TypeError("argument 'trans' must be of type '_hipblasOperation_t__Base'")
    _hipblasDgemv_64__retval = hipblasStatus_t(chipblas.hipblasDgemv_64(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,trans.value,m,n,
        <const double *>hip._util.types.Pointer.fromPyobj(alpha)._ptr,
        <const double *>hip._util.types.Pointer.fromPyobj(AP)._ptr,lda,
        <const double *>hip._util.types.Pointer.fromPyobj(x)._ptr,incx,
        <const double *>hip._util.types.Pointer.fromPyobj(beta)._ptr,
        <double *>hip._util.types.Pointer.fromPyobj(y)._ptr,incy))
    return (_hipblasDgemv_64__retval,)


@cython.embedsignature(True)
def hipblasCgemv_64(object handle, object trans, long m, long n, object alpha, object AP, long lda, object x, long incx, object beta, object y, long incy):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        trans (`~.hipblasOperation_t`):
            (undocumented)

        m (`~.int`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        alpha (`~.hipblasComplex`/`~.object`):
            (undocumented)

        AP (`~.hipblasComplex`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        x (`~.hipblasComplex`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        beta (`~.hipblasComplex`/`~.object`):
            (undocumented)

        y (`~.hipblasComplex`/`~.object`):
            (undocumented)

        incy (`~.int`):
            (undocumented)
    """
    if not isinstance(trans,_hipblasOperation_t__Base):
        raise TypeError("argument 'trans' must be of type '_hipblasOperation_t__Base'")
    _hipblasCgemv_64__retval = hipblasStatus_t(chipblas.hipblasCgemv_64(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,trans.value,m,n,
        hipblasComplex.fromPyobj(alpha).getElementPtr(),
        hipblasComplex.fromPyobj(AP).getElementPtr(),lda,
        hipblasComplex.fromPyobj(x).getElementPtr(),incx,
        hipblasComplex.fromPyobj(beta).getElementPtr(),
        hipblasComplex.fromPyobj(y).getElementPtr(),incy))
    return (_hipblasCgemv_64__retval,)


@cython.embedsignature(True)
def hipblasZgemv_64(object handle, object trans, long m, long n, object alpha, object AP, long lda, object x, long incx, object beta, object y, long incy):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        trans (`~.hipblasOperation_t`):
            (undocumented)

        m (`~.int`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        alpha (`~.hipblasDoubleComplex`/`~.object`):
            (undocumented)

        AP (`~.hipblasDoubleComplex`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        x (`~.hipblasDoubleComplex`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        beta (`~.hipblasDoubleComplex`/`~.object`):
            (undocumented)

        y (`~.hipblasDoubleComplex`/`~.object`):
            (undocumented)

        incy (`~.int`):
            (undocumented)
    """
    if not isinstance(trans,_hipblasOperation_t__Base):
        raise TypeError("argument 'trans' must be of type '_hipblasOperation_t__Base'")
    _hipblasZgemv_64__retval = hipblasStatus_t(chipblas.hipblasZgemv_64(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,trans.value,m,n,
        hipblasDoubleComplex.fromPyobj(alpha).getElementPtr(),
        hipblasDoubleComplex.fromPyobj(AP).getElementPtr(),lda,
        hipblasDoubleComplex.fromPyobj(x).getElementPtr(),incx,
        hipblasDoubleComplex.fromPyobj(beta).getElementPtr(),
        hipblasDoubleComplex.fromPyobj(y).getElementPtr(),incy))
    return (_hipblasZgemv_64__retval,)


@cython.embedsignature(True)
def hipblasCgemv_v2_64(object handle, object trans, long m, long n, object alpha, object AP, long lda, object x, long incx, object beta, object y, long incy):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        trans (`~.hipblasOperation_t`):
            (undocumented)

        m (`~.int`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        alpha (`~.float2`/`~.object`):
            (undocumented)

        AP (`~.float2`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        x (`~.float2`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        beta (`~.float2`/`~.object`):
            (undocumented)

        y (`~.float2`/`~.object`):
            (undocumented)

        incy (`~.int`):
            (undocumented)
    """
    if not isinstance(trans,_hipblasOperation_t__Base):
        raise TypeError("argument 'trans' must be of type '_hipblasOperation_t__Base'")
    _hipblasCgemv_v2_64__retval = hipblasStatus_t(chipblas.hipblasCgemv_v2_64(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,trans.value,m,n,
        float2.fromPyobj(alpha).getElementPtr(),
        float2.fromPyobj(AP).getElementPtr(),lda,
        float2.fromPyobj(x).getElementPtr(),incx,
        float2.fromPyobj(beta).getElementPtr(),
        float2.fromPyobj(y).getElementPtr(),incy))
    return (_hipblasCgemv_v2_64__retval,)


@cython.embedsignature(True)
def hipblasZgemv_v2_64(object handle, object trans, long m, long n, object alpha, object AP, long lda, object x, long incx, object beta, object y, long incy):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        trans (`~.hipblasOperation_t`):
            (undocumented)

        m (`~.int`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        alpha (`~.double2`/`~.object`):
            (undocumented)

        AP (`~.double2`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        x (`~.double2`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        beta (`~.double2`/`~.object`):
            (undocumented)

        y (`~.double2`/`~.object`):
            (undocumented)

        incy (`~.int`):
            (undocumented)
    """
    if not isinstance(trans,_hipblasOperation_t__Base):
        raise TypeError("argument 'trans' must be of type '_hipblasOperation_t__Base'")
    _hipblasZgemv_v2_64__retval = hipblasStatus_t(chipblas.hipblasZgemv_v2_64(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,trans.value,m,n,
        double2.fromPyobj(alpha).getElementPtr(),
        double2.fromPyobj(AP).getElementPtr(),lda,
        double2.fromPyobj(x).getElementPtr(),incx,
        double2.fromPyobj(beta).getElementPtr(),
        double2.fromPyobj(y).getElementPtr(),incy))
    return (_hipblasZgemv_v2_64__retval,)


@cython.embedsignature(True)
def hipblasSgemvBatched(object handle, object trans, int m, int n, object alpha, object AP, int lda, object x, int incx, object beta, object y, int incy, int batchCount):
    r"""BLAS Level 2 API

    @{

    gemvBatched performs a batch of matrix-vector operations

    y_i := alpha*A_i*x_i    + beta*y_i,   or
        y_i := alpha*A_i**T*x_i + beta*y_i,   or
        y_i := alpha*A_i**H*x_i + beta*y_i,

    where (A_i, x_i, y_i) is the i-th instance of the batch.
    alpha and beta are scalars, x_i and y_i are vectors and A_i is an
    m by n matrix, for i = 1, ..., batchCount.

    - Supported precisions in rocBLAS : s,d,c,z
    - Supported precisions in cuBLAS  : No support

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`) -- *IN*:
            [hipblasHandle_t]
            handle to the hipblas library context queue.

        trans (`~.hipblasOperation_t`) -- *IN*:
            [hipblasOperation_t]
            indicates whether matrices A_i are tranposed (conjugated) or not

        m (`~.int`) -- *IN*:
            [int]
            number of rows of each matrix A_i

        n (`~.int`) -- *IN*:
            [int]
            number of columns of each matrix A_i

        alpha (`~.hip._util.types.Pointer`/`~.object`) -- *IN*:
            device pointer or host pointer to scalar alpha.

        AP (`~.hip._util.types.Pointer`/`~.object`) -- *IN*:
            device array of device pointers storing each matrix A_i.

        lda (`~.int`) -- *IN*:
            [int]
            specifies the leading dimension of each matrix A_i.

        x (`~.hip._util.types.ListOfPointer`/`~.object`) -- *IN*:
            device array of device pointers storing each vector x_i.

        incx (`~.int`) -- *IN*:
            [int]
            specifies the increment for the elements of each vector x_i.

        beta (`~.hip._util.types.Pointer`/`~.object`) -- *IN*:
            device pointer or host pointer to scalar beta.

        y (`~.hip._util.types.ListOfPointer`/`~.object`) -- *INOUT*:
            device array of device pointers storing each vector y_i.

        incy (`~.int`) -- *IN*:
            [int]
            specifies the increment for the elements of each vector y_i.

        batchCount (`~.int`) -- *IN*:
            [int]
            number of instances in the batch
    """
    if not isinstance(trans,_hipblasOperation_t__Base):
        raise TypeError("argument 'trans' must be of type '_hipblasOperation_t__Base'")
    _hipblasSgemvBatched__retval = hipblasStatus_t(chipblas.hipblasSgemvBatched(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,trans.value,m,n,
        <const float *>hip._util.types.Pointer.fromPyobj(alpha)._ptr,
        <const float *const*>hip._util.types.Pointer.fromPyobj(AP)._ptr,lda,
        <const float *const*>hip._util.types.ListOfPointer.fromPyobj(x)._ptr,incx,
        <const float *>hip._util.types.Pointer.fromPyobj(beta)._ptr,
        <float *const*>hip._util.types.ListOfPointer.fromPyobj(y)._ptr,incy,batchCount))
    return (_hipblasSgemvBatched__retval,)


@cython.embedsignature(True)
def hipblasDgemvBatched(object handle, object trans, int m, int n, object alpha, object AP, int lda, object x, int incx, object beta, object y, int incy, int batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        trans (`~.hipblasOperation_t`):
            (undocumented)

        m (`~.int`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        alpha (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        AP (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        x (`~.hip._util.types.ListOfPointer`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        beta (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        y (`~.hip._util.types.ListOfPointer`/`~.object`):
            (undocumented)

        incy (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    if not isinstance(trans,_hipblasOperation_t__Base):
        raise TypeError("argument 'trans' must be of type '_hipblasOperation_t__Base'")
    _hipblasDgemvBatched__retval = hipblasStatus_t(chipblas.hipblasDgemvBatched(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,trans.value,m,n,
        <const double *>hip._util.types.Pointer.fromPyobj(alpha)._ptr,
        <const double *const*>hip._util.types.Pointer.fromPyobj(AP)._ptr,lda,
        <const double *const*>hip._util.types.ListOfPointer.fromPyobj(x)._ptr,incx,
        <const double *>hip._util.types.Pointer.fromPyobj(beta)._ptr,
        <double *const*>hip._util.types.ListOfPointer.fromPyobj(y)._ptr,incy,batchCount))
    return (_hipblasDgemvBatched__retval,)


@cython.embedsignature(True)
def hipblasCgemvBatched(object handle, object trans, int m, int n, object alpha, object AP, int lda, object x, int incx, object beta, object y, int incy, int batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        trans (`~.hipblasOperation_t`):
            (undocumented)

        m (`~.int`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        alpha (`~.hipblasComplex`/`~.object`):
            (undocumented)

        AP (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        x (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        beta (`~.hipblasComplex`/`~.object`):
            (undocumented)

        y (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        incy (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    if not isinstance(trans,_hipblasOperation_t__Base):
        raise TypeError("argument 'trans' must be of type '_hipblasOperation_t__Base'")
    _hipblasCgemvBatched__retval = hipblasStatus_t(chipblas.hipblasCgemvBatched(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,trans.value,m,n,
        hipblasComplex.fromPyobj(alpha).getElementPtr(),
        <chipblas.hipblasComplex *const*>hip._util.types.Pointer.fromPyobj(AP)._ptr,lda,
        <chipblas.hipblasComplex *const*>hip._util.types.Pointer.fromPyobj(x)._ptr,incx,
        hipblasComplex.fromPyobj(beta).getElementPtr(),
        <chipblas.hipblasComplex *const*>hip._util.types.Pointer.fromPyobj(y)._ptr,incy,batchCount))
    return (_hipblasCgemvBatched__retval,)


@cython.embedsignature(True)
def hipblasZgemvBatched(object handle, object trans, int m, int n, object alpha, object AP, int lda, object x, int incx, object beta, object y, int incy, int batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        trans (`~.hipblasOperation_t`):
            (undocumented)

        m (`~.int`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        alpha (`~.hipblasDoubleComplex`/`~.object`):
            (undocumented)

        AP (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        x (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        beta (`~.hipblasDoubleComplex`/`~.object`):
            (undocumented)

        y (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        incy (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    if not isinstance(trans,_hipblasOperation_t__Base):
        raise TypeError("argument 'trans' must be of type '_hipblasOperation_t__Base'")
    _hipblasZgemvBatched__retval = hipblasStatus_t(chipblas.hipblasZgemvBatched(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,trans.value,m,n,
        hipblasDoubleComplex.fromPyobj(alpha).getElementPtr(),
        <chipblas.hipblasDoubleComplex *const*>hip._util.types.Pointer.fromPyobj(AP)._ptr,lda,
        <chipblas.hipblasDoubleComplex *const*>hip._util.types.Pointer.fromPyobj(x)._ptr,incx,
        hipblasDoubleComplex.fromPyobj(beta).getElementPtr(),
        <chipblas.hipblasDoubleComplex *const*>hip._util.types.Pointer.fromPyobj(y)._ptr,incy,batchCount))
    return (_hipblasZgemvBatched__retval,)


@cython.embedsignature(True)
def hipblasCgemvBatched_v2(object handle, object trans, int m, int n, object alpha, object AP, int lda, object x, int incx, object beta, object y, int incy, int batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        trans (`~.hipblasOperation_t`):
            (undocumented)

        m (`~.int`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        alpha (`~.float2`/`~.object`):
            (undocumented)

        AP (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        x (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        beta (`~.float2`/`~.object`):
            (undocumented)

        y (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        incy (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    if not isinstance(trans,_hipblasOperation_t__Base):
        raise TypeError("argument 'trans' must be of type '_hipblasOperation_t__Base'")
    _hipblasCgemvBatched_v2__retval = hipblasStatus_t(chipblas.hipblasCgemvBatched_v2(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,trans.value,m,n,
        float2.fromPyobj(alpha).getElementPtr(),
        <chipblas.float2 *const*>hip._util.types.Pointer.fromPyobj(AP)._ptr,lda,
        <chipblas.float2 *const*>hip._util.types.Pointer.fromPyobj(x)._ptr,incx,
        float2.fromPyobj(beta).getElementPtr(),
        <chipblas.float2 *const*>hip._util.types.Pointer.fromPyobj(y)._ptr,incy,batchCount))
    return (_hipblasCgemvBatched_v2__retval,)


@cython.embedsignature(True)
def hipblasZgemvBatched_v2(object handle, object trans, int m, int n, object alpha, object AP, int lda, object x, int incx, object beta, object y, int incy, int batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        trans (`~.hipblasOperation_t`):
            (undocumented)

        m (`~.int`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        alpha (`~.double2`/`~.object`):
            (undocumented)

        AP (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        x (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        beta (`~.double2`/`~.object`):
            (undocumented)

        y (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        incy (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    if not isinstance(trans,_hipblasOperation_t__Base):
        raise TypeError("argument 'trans' must be of type '_hipblasOperation_t__Base'")
    _hipblasZgemvBatched_v2__retval = hipblasStatus_t(chipblas.hipblasZgemvBatched_v2(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,trans.value,m,n,
        double2.fromPyobj(alpha).getElementPtr(),
        <chipblas.double2 *const*>hip._util.types.Pointer.fromPyobj(AP)._ptr,lda,
        <chipblas.double2 *const*>hip._util.types.Pointer.fromPyobj(x)._ptr,incx,
        double2.fromPyobj(beta).getElementPtr(),
        <chipblas.double2 *const*>hip._util.types.Pointer.fromPyobj(y)._ptr,incy,batchCount))
    return (_hipblasZgemvBatched_v2__retval,)


@cython.embedsignature(True)
def hipblasSgemvBatched_64(object handle, object trans, long m, long n, object alpha, object AP, long lda, object x, long incx, object beta, object y, long incy, long batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        trans (`~.hipblasOperation_t`):
            (undocumented)

        m (`~.int`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        alpha (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        AP (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        x (`~.hip._util.types.ListOfPointer`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        beta (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        y (`~.hip._util.types.ListOfPointer`/`~.object`):
            (undocumented)

        incy (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    if not isinstance(trans,_hipblasOperation_t__Base):
        raise TypeError("argument 'trans' must be of type '_hipblasOperation_t__Base'")
    _hipblasSgemvBatched_64__retval = hipblasStatus_t(chipblas.hipblasSgemvBatched_64(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,trans.value,m,n,
        <const float *>hip._util.types.Pointer.fromPyobj(alpha)._ptr,
        <const float *const*>hip._util.types.Pointer.fromPyobj(AP)._ptr,lda,
        <const float *const*>hip._util.types.ListOfPointer.fromPyobj(x)._ptr,incx,
        <const float *>hip._util.types.Pointer.fromPyobj(beta)._ptr,
        <float *const*>hip._util.types.ListOfPointer.fromPyobj(y)._ptr,incy,batchCount))
    return (_hipblasSgemvBatched_64__retval,)


@cython.embedsignature(True)
def hipblasDgemvBatched_64(object handle, object trans, long m, long n, object alpha, object AP, long lda, object x, long incx, object beta, object y, long incy, long batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        trans (`~.hipblasOperation_t`):
            (undocumented)

        m (`~.int`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        alpha (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        AP (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        x (`~.hip._util.types.ListOfPointer`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        beta (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        y (`~.hip._util.types.ListOfPointer`/`~.object`):
            (undocumented)

        incy (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    if not isinstance(trans,_hipblasOperation_t__Base):
        raise TypeError("argument 'trans' must be of type '_hipblasOperation_t__Base'")
    _hipblasDgemvBatched_64__retval = hipblasStatus_t(chipblas.hipblasDgemvBatched_64(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,trans.value,m,n,
        <const double *>hip._util.types.Pointer.fromPyobj(alpha)._ptr,
        <const double *const*>hip._util.types.Pointer.fromPyobj(AP)._ptr,lda,
        <const double *const*>hip._util.types.ListOfPointer.fromPyobj(x)._ptr,incx,
        <const double *>hip._util.types.Pointer.fromPyobj(beta)._ptr,
        <double *const*>hip._util.types.ListOfPointer.fromPyobj(y)._ptr,incy,batchCount))
    return (_hipblasDgemvBatched_64__retval,)


@cython.embedsignature(True)
def hipblasCgemvBatched_64(object handle, object trans, long m, long n, object alpha, object AP, long lda, object x, long incx, object beta, object y, long incy, long batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        trans (`~.hipblasOperation_t`):
            (undocumented)

        m (`~.int`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        alpha (`~.hipblasComplex`/`~.object`):
            (undocumented)

        AP (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        x (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        beta (`~.hipblasComplex`/`~.object`):
            (undocumented)

        y (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        incy (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    if not isinstance(trans,_hipblasOperation_t__Base):
        raise TypeError("argument 'trans' must be of type '_hipblasOperation_t__Base'")
    _hipblasCgemvBatched_64__retval = hipblasStatus_t(chipblas.hipblasCgemvBatched_64(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,trans.value,m,n,
        hipblasComplex.fromPyobj(alpha).getElementPtr(),
        <chipblas.hipblasComplex *const*>hip._util.types.Pointer.fromPyobj(AP)._ptr,lda,
        <chipblas.hipblasComplex *const*>hip._util.types.Pointer.fromPyobj(x)._ptr,incx,
        hipblasComplex.fromPyobj(beta).getElementPtr(),
        <chipblas.hipblasComplex *const*>hip._util.types.Pointer.fromPyobj(y)._ptr,incy,batchCount))
    return (_hipblasCgemvBatched_64__retval,)


@cython.embedsignature(True)
def hipblasZgemvBatched_64(object handle, object trans, long m, long n, object alpha, object AP, long lda, object x, long incx, object beta, object y, long incy, long batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        trans (`~.hipblasOperation_t`):
            (undocumented)

        m (`~.int`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        alpha (`~.hipblasDoubleComplex`/`~.object`):
            (undocumented)

        AP (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        x (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        beta (`~.hipblasDoubleComplex`/`~.object`):
            (undocumented)

        y (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        incy (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    if not isinstance(trans,_hipblasOperation_t__Base):
        raise TypeError("argument 'trans' must be of type '_hipblasOperation_t__Base'")
    _hipblasZgemvBatched_64__retval = hipblasStatus_t(chipblas.hipblasZgemvBatched_64(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,trans.value,m,n,
        hipblasDoubleComplex.fromPyobj(alpha).getElementPtr(),
        <chipblas.hipblasDoubleComplex *const*>hip._util.types.Pointer.fromPyobj(AP)._ptr,lda,
        <chipblas.hipblasDoubleComplex *const*>hip._util.types.Pointer.fromPyobj(x)._ptr,incx,
        hipblasDoubleComplex.fromPyobj(beta).getElementPtr(),
        <chipblas.hipblasDoubleComplex *const*>hip._util.types.Pointer.fromPyobj(y)._ptr,incy,batchCount))
    return (_hipblasZgemvBatched_64__retval,)


@cython.embedsignature(True)
def hipblasCgemvBatched_v2_64(object handle, object trans, long m, long n, object alpha, object AP, long lda, object x, long incx, object beta, object y, long incy, long batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        trans (`~.hipblasOperation_t`):
            (undocumented)

        m (`~.int`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        alpha (`~.float2`/`~.object`):
            (undocumented)

        AP (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        x (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        beta (`~.float2`/`~.object`):
            (undocumented)

        y (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        incy (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    if not isinstance(trans,_hipblasOperation_t__Base):
        raise TypeError("argument 'trans' must be of type '_hipblasOperation_t__Base'")
    _hipblasCgemvBatched_v2_64__retval = hipblasStatus_t(chipblas.hipblasCgemvBatched_v2_64(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,trans.value,m,n,
        float2.fromPyobj(alpha).getElementPtr(),
        <chipblas.float2 *const*>hip._util.types.Pointer.fromPyobj(AP)._ptr,lda,
        <chipblas.float2 *const*>hip._util.types.Pointer.fromPyobj(x)._ptr,incx,
        float2.fromPyobj(beta).getElementPtr(),
        <chipblas.float2 *const*>hip._util.types.Pointer.fromPyobj(y)._ptr,incy,batchCount))
    return (_hipblasCgemvBatched_v2_64__retval,)


@cython.embedsignature(True)
def hipblasZgemvBatched_v2_64(object handle, object trans, long m, long n, object alpha, object AP, long lda, object x, long incx, object beta, object y, long incy, long batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        trans (`~.hipblasOperation_t`):
            (undocumented)

        m (`~.int`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        alpha (`~.double2`/`~.object`):
            (undocumented)

        AP (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        x (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        beta (`~.double2`/`~.object`):
            (undocumented)

        y (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        incy (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    if not isinstance(trans,_hipblasOperation_t__Base):
        raise TypeError("argument 'trans' must be of type '_hipblasOperation_t__Base'")
    _hipblasZgemvBatched_v2_64__retval = hipblasStatus_t(chipblas.hipblasZgemvBatched_v2_64(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,trans.value,m,n,
        double2.fromPyobj(alpha).getElementPtr(),
        <chipblas.double2 *const*>hip._util.types.Pointer.fromPyobj(AP)._ptr,lda,
        <chipblas.double2 *const*>hip._util.types.Pointer.fromPyobj(x)._ptr,incx,
        double2.fromPyobj(beta).getElementPtr(),
        <chipblas.double2 *const*>hip._util.types.Pointer.fromPyobj(y)._ptr,incy,batchCount))
    return (_hipblasZgemvBatched_v2_64__retval,)


@cython.embedsignature(True)
def hipblasSgemvStridedBatched(object handle, object transA, int m, int n, object alpha, object AP, int lda, long strideA, object x, int incx, long stridex, object beta, object y, int incy, long stridey, int batchCount):
    r"""BLAS Level 2 API

    @{

    gemvStridedBatched performs a batch of matrix-vector operations

    y_i := alpha*A_i*x_i    + beta*y_i,   or
        y_i := alpha*A_i**T*x_i + beta*y_i,   or
        y_i := alpha*A_i**H*x_i + beta*y_i,

    where (A_i, x_i, y_i) is the i-th instance of the batch.
    alpha and beta are scalars, x_i and y_i are vectors and A_i is an
    m by n matrix, for i = 1, ..., batchCount.

    - Supported precisions in rocBLAS : s,d,c,z
    - Supported precisions in cuBLAS  : No support

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`) -- *IN*:
            [hipblasHandle_t]
            handle to the hipblas library context queue.

        transA (`~.hipblasOperation_t`) -- *IN*:
            [hipblasOperation_t]
            indicates whether matrices A_i are tranposed (conjugated) or not

        m (`~.int`) -- *IN*:
            [int]
            number of rows of matrices A_i

        n (`~.int`) -- *IN*:
            [int]
            number of columns of matrices A_i

        alpha (`~.hip._util.types.Pointer`/`~.object`) -- *IN*:
            device pointer or host pointer to scalar alpha.

        AP (`~.hip._util.types.Pointer`/`~.object`) -- *IN*:
            device pointer to the first matrix (A_1) in the batch.

        lda (`~.int`) -- *IN*:
            [int]
            specifies the leading dimension of matrices A_i.

        strideA (`~.int`) -- *IN*:
            [hipblasStride]
            stride from the start of one matrix (A_i) and the next one (A_i+1)

        x (`~.hip._util.types.Pointer`/`~.object`) -- *IN*:
            device pointer to the first vector (x_1) in the batch.

        incx (`~.int`) -- *IN*:
            [int]
            specifies the increment for the elements of vectors x_i.

        stridex (`~.int`) -- *IN*:
            [hipblasStride]
            stride from the start of one vector (x_i) and the next one (x_i+1).
            There are no restrictions placed on stridex, however the user should
            take care to ensure that stridex is of appropriate size. When trans equals HIPBLAS_OP_N
            this typically means stridex >= n * incx, otherwise stridex >= m * incx.

        beta (`~.hip._util.types.Pointer`/`~.object`) -- *IN*:
            device pointer or host pointer to scalar beta.

        y (`~.hip._util.types.Pointer`/`~.object`) -- *INOUT*:
            device pointer to the first vector (y_1) in the batch.

        incy (`~.int`) -- *IN*:
            [int]
            specifies the increment for the elements of vectors y_i.

        stridey (`~.int`) -- *IN*:
            [hipblasStride]
            stride from the start of one vector (y_i) and the next one (y_i+1).
            There are no restrictions placed on stridey, however the user should
            take care to ensure that stridey is of appropriate size. When trans equals HIPBLAS_OP_N
            this typically means stridey >= m * incy, otherwise stridey >= n * incy. stridey should be non zero.

        batchCount (`~.int`) -- *IN*:
            [int]
            number of instances in the batch
    """
    if not isinstance(transA,_hipblasOperation_t__Base):
        raise TypeError("argument 'transA' must be of type '_hipblasOperation_t__Base'")
    _hipblasSgemvStridedBatched__retval = hipblasStatus_t(chipblas.hipblasSgemvStridedBatched(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,transA.value,m,n,
        <const float *>hip._util.types.Pointer.fromPyobj(alpha)._ptr,
        <const float *>hip._util.types.Pointer.fromPyobj(AP)._ptr,lda,strideA,
        <const float *>hip._util.types.Pointer.fromPyobj(x)._ptr,incx,stridex,
        <const float *>hip._util.types.Pointer.fromPyobj(beta)._ptr,
        <float *>hip._util.types.Pointer.fromPyobj(y)._ptr,incy,stridey,batchCount))
    return (_hipblasSgemvStridedBatched__retval,)


@cython.embedsignature(True)
def hipblasDgemvStridedBatched(object handle, object transA, int m, int n, object alpha, object AP, int lda, long strideA, object x, int incx, long stridex, object beta, object y, int incy, long stridey, int batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        transA (`~.hipblasOperation_t`):
            (undocumented)

        m (`~.int`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        alpha (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        AP (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        strideA (`~.int`):
            (undocumented)

        x (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        stridex (`~.int`):
            (undocumented)

        beta (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        y (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        incy (`~.int`):
            (undocumented)

        stridey (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    if not isinstance(transA,_hipblasOperation_t__Base):
        raise TypeError("argument 'transA' must be of type '_hipblasOperation_t__Base'")
    _hipblasDgemvStridedBatched__retval = hipblasStatus_t(chipblas.hipblasDgemvStridedBatched(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,transA.value,m,n,
        <const double *>hip._util.types.Pointer.fromPyobj(alpha)._ptr,
        <const double *>hip._util.types.Pointer.fromPyobj(AP)._ptr,lda,strideA,
        <const double *>hip._util.types.Pointer.fromPyobj(x)._ptr,incx,stridex,
        <const double *>hip._util.types.Pointer.fromPyobj(beta)._ptr,
        <double *>hip._util.types.Pointer.fromPyobj(y)._ptr,incy,stridey,batchCount))
    return (_hipblasDgemvStridedBatched__retval,)


@cython.embedsignature(True)
def hipblasCgemvStridedBatched(object handle, object transA, int m, int n, object alpha, object AP, int lda, long strideA, object x, int incx, long stridex, object beta, object y, int incy, long stridey, int batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        transA (`~.hipblasOperation_t`):
            (undocumented)

        m (`~.int`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        alpha (`~.hipblasComplex`/`~.object`):
            (undocumented)

        AP (`~.hipblasComplex`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        strideA (`~.int`):
            (undocumented)

        x (`~.hipblasComplex`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        stridex (`~.int`):
            (undocumented)

        beta (`~.hipblasComplex`/`~.object`):
            (undocumented)

        y (`~.hipblasComplex`/`~.object`):
            (undocumented)

        incy (`~.int`):
            (undocumented)

        stridey (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    if not isinstance(transA,_hipblasOperation_t__Base):
        raise TypeError("argument 'transA' must be of type '_hipblasOperation_t__Base'")
    _hipblasCgemvStridedBatched__retval = hipblasStatus_t(chipblas.hipblasCgemvStridedBatched(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,transA.value,m,n,
        hipblasComplex.fromPyobj(alpha).getElementPtr(),
        hipblasComplex.fromPyobj(AP).getElementPtr(),lda,strideA,
        hipblasComplex.fromPyobj(x).getElementPtr(),incx,stridex,
        hipblasComplex.fromPyobj(beta).getElementPtr(),
        hipblasComplex.fromPyobj(y).getElementPtr(),incy,stridey,batchCount))
    return (_hipblasCgemvStridedBatched__retval,)


@cython.embedsignature(True)
def hipblasZgemvStridedBatched(object handle, object transA, int m, int n, object alpha, object AP, int lda, long strideA, object x, int incx, long stridex, object beta, object y, int incy, long stridey, int batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        transA (`~.hipblasOperation_t`):
            (undocumented)

        m (`~.int`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        alpha (`~.hipblasDoubleComplex`/`~.object`):
            (undocumented)

        AP (`~.hipblasDoubleComplex`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        strideA (`~.int`):
            (undocumented)

        x (`~.hipblasDoubleComplex`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        stridex (`~.int`):
            (undocumented)

        beta (`~.hipblasDoubleComplex`/`~.object`):
            (undocumented)

        y (`~.hipblasDoubleComplex`/`~.object`):
            (undocumented)

        incy (`~.int`):
            (undocumented)

        stridey (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    if not isinstance(transA,_hipblasOperation_t__Base):
        raise TypeError("argument 'transA' must be of type '_hipblasOperation_t__Base'")
    _hipblasZgemvStridedBatched__retval = hipblasStatus_t(chipblas.hipblasZgemvStridedBatched(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,transA.value,m,n,
        hipblasDoubleComplex.fromPyobj(alpha).getElementPtr(),
        hipblasDoubleComplex.fromPyobj(AP).getElementPtr(),lda,strideA,
        hipblasDoubleComplex.fromPyobj(x).getElementPtr(),incx,stridex,
        hipblasDoubleComplex.fromPyobj(beta).getElementPtr(),
        hipblasDoubleComplex.fromPyobj(y).getElementPtr(),incy,stridey,batchCount))
    return (_hipblasZgemvStridedBatched__retval,)


@cython.embedsignature(True)
def hipblasCgemvStridedBatched_v2(object handle, object transA, int m, int n, object alpha, object AP, int lda, long strideA, object x, int incx, long stridex, object beta, object y, int incy, long stridey, int batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        transA (`~.hipblasOperation_t`):
            (undocumented)

        m (`~.int`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        alpha (`~.float2`/`~.object`):
            (undocumented)

        AP (`~.float2`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        strideA (`~.int`):
            (undocumented)

        x (`~.float2`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        stridex (`~.int`):
            (undocumented)

        beta (`~.float2`/`~.object`):
            (undocumented)

        y (`~.float2`/`~.object`):
            (undocumented)

        incy (`~.int`):
            (undocumented)

        stridey (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    if not isinstance(transA,_hipblasOperation_t__Base):
        raise TypeError("argument 'transA' must be of type '_hipblasOperation_t__Base'")
    _hipblasCgemvStridedBatched_v2__retval = hipblasStatus_t(chipblas.hipblasCgemvStridedBatched_v2(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,transA.value,m,n,
        float2.fromPyobj(alpha).getElementPtr(),
        float2.fromPyobj(AP).getElementPtr(),lda,strideA,
        float2.fromPyobj(x).getElementPtr(),incx,stridex,
        float2.fromPyobj(beta).getElementPtr(),
        float2.fromPyobj(y).getElementPtr(),incy,stridey,batchCount))
    return (_hipblasCgemvStridedBatched_v2__retval,)


@cython.embedsignature(True)
def hipblasZgemvStridedBatched_v2(object handle, object transA, int m, int n, object alpha, object AP, int lda, long strideA, object x, int incx, long stridex, object beta, object y, int incy, long stridey, int batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        transA (`~.hipblasOperation_t`):
            (undocumented)

        m (`~.int`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        alpha (`~.double2`/`~.object`):
            (undocumented)

        AP (`~.double2`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        strideA (`~.int`):
            (undocumented)

        x (`~.double2`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        stridex (`~.int`):
            (undocumented)

        beta (`~.double2`/`~.object`):
            (undocumented)

        y (`~.double2`/`~.object`):
            (undocumented)

        incy (`~.int`):
            (undocumented)

        stridey (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    if not isinstance(transA,_hipblasOperation_t__Base):
        raise TypeError("argument 'transA' must be of type '_hipblasOperation_t__Base'")
    _hipblasZgemvStridedBatched_v2__retval = hipblasStatus_t(chipblas.hipblasZgemvStridedBatched_v2(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,transA.value,m,n,
        double2.fromPyobj(alpha).getElementPtr(),
        double2.fromPyobj(AP).getElementPtr(),lda,strideA,
        double2.fromPyobj(x).getElementPtr(),incx,stridex,
        double2.fromPyobj(beta).getElementPtr(),
        double2.fromPyobj(y).getElementPtr(),incy,stridey,batchCount))
    return (_hipblasZgemvStridedBatched_v2__retval,)


@cython.embedsignature(True)
def hipblasSgemvStridedBatched_64(object handle, object transA, long m, long n, object alpha, object AP, long lda, long strideA, object x, long incx, long stridex, object beta, object y, long incy, long stridey, long batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        transA (`~.hipblasOperation_t`):
            (undocumented)

        m (`~.int`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        alpha (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        AP (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        strideA (`~.int`):
            (undocumented)

        x (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        stridex (`~.int`):
            (undocumented)

        beta (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        y (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        incy (`~.int`):
            (undocumented)

        stridey (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    if not isinstance(transA,_hipblasOperation_t__Base):
        raise TypeError("argument 'transA' must be of type '_hipblasOperation_t__Base'")
    _hipblasSgemvStridedBatched_64__retval = hipblasStatus_t(chipblas.hipblasSgemvStridedBatched_64(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,transA.value,m,n,
        <const float *>hip._util.types.Pointer.fromPyobj(alpha)._ptr,
        <const float *>hip._util.types.Pointer.fromPyobj(AP)._ptr,lda,strideA,
        <const float *>hip._util.types.Pointer.fromPyobj(x)._ptr,incx,stridex,
        <const float *>hip._util.types.Pointer.fromPyobj(beta)._ptr,
        <float *>hip._util.types.Pointer.fromPyobj(y)._ptr,incy,stridey,batchCount))
    return (_hipblasSgemvStridedBatched_64__retval,)


@cython.embedsignature(True)
def hipblasDgemvStridedBatched_64(object handle, object transA, long m, long n, object alpha, object AP, long lda, long strideA, object x, long incx, long stridex, object beta, object y, long incy, long stridey, long batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        transA (`~.hipblasOperation_t`):
            (undocumented)

        m (`~.int`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        alpha (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        AP (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        strideA (`~.int`):
            (undocumented)

        x (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        stridex (`~.int`):
            (undocumented)

        beta (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        y (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        incy (`~.int`):
            (undocumented)

        stridey (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    if not isinstance(transA,_hipblasOperation_t__Base):
        raise TypeError("argument 'transA' must be of type '_hipblasOperation_t__Base'")
    _hipblasDgemvStridedBatched_64__retval = hipblasStatus_t(chipblas.hipblasDgemvStridedBatched_64(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,transA.value,m,n,
        <const double *>hip._util.types.Pointer.fromPyobj(alpha)._ptr,
        <const double *>hip._util.types.Pointer.fromPyobj(AP)._ptr,lda,strideA,
        <const double *>hip._util.types.Pointer.fromPyobj(x)._ptr,incx,stridex,
        <const double *>hip._util.types.Pointer.fromPyobj(beta)._ptr,
        <double *>hip._util.types.Pointer.fromPyobj(y)._ptr,incy,stridey,batchCount))
    return (_hipblasDgemvStridedBatched_64__retval,)


@cython.embedsignature(True)
def hipblasCgemvStridedBatched_64(object handle, object transA, long m, long n, object alpha, object AP, long lda, long strideA, object x, long incx, long stridex, object beta, object y, long incy, long stridey, long batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        transA (`~.hipblasOperation_t`):
            (undocumented)

        m (`~.int`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        alpha (`~.hipblasComplex`/`~.object`):
            (undocumented)

        AP (`~.hipblasComplex`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        strideA (`~.int`):
            (undocumented)

        x (`~.hipblasComplex`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        stridex (`~.int`):
            (undocumented)

        beta (`~.hipblasComplex`/`~.object`):
            (undocumented)

        y (`~.hipblasComplex`/`~.object`):
            (undocumented)

        incy (`~.int`):
            (undocumented)

        stridey (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    if not isinstance(transA,_hipblasOperation_t__Base):
        raise TypeError("argument 'transA' must be of type '_hipblasOperation_t__Base'")
    _hipblasCgemvStridedBatched_64__retval = hipblasStatus_t(chipblas.hipblasCgemvStridedBatched_64(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,transA.value,m,n,
        hipblasComplex.fromPyobj(alpha).getElementPtr(),
        hipblasComplex.fromPyobj(AP).getElementPtr(),lda,strideA,
        hipblasComplex.fromPyobj(x).getElementPtr(),incx,stridex,
        hipblasComplex.fromPyobj(beta).getElementPtr(),
        hipblasComplex.fromPyobj(y).getElementPtr(),incy,stridey,batchCount))
    return (_hipblasCgemvStridedBatched_64__retval,)


@cython.embedsignature(True)
def hipblasZgemvStridedBatched_64(object handle, object transA, long m, long n, object alpha, object AP, long lda, long strideA, object x, long incx, long stridex, object beta, object y, long incy, long stridey, long batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        transA (`~.hipblasOperation_t`):
            (undocumented)

        m (`~.int`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        alpha (`~.hipblasDoubleComplex`/`~.object`):
            (undocumented)

        AP (`~.hipblasDoubleComplex`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        strideA (`~.int`):
            (undocumented)

        x (`~.hipblasDoubleComplex`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        stridex (`~.int`):
            (undocumented)

        beta (`~.hipblasDoubleComplex`/`~.object`):
            (undocumented)

        y (`~.hipblasDoubleComplex`/`~.object`):
            (undocumented)

        incy (`~.int`):
            (undocumented)

        stridey (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    if not isinstance(transA,_hipblasOperation_t__Base):
        raise TypeError("argument 'transA' must be of type '_hipblasOperation_t__Base'")
    _hipblasZgemvStridedBatched_64__retval = hipblasStatus_t(chipblas.hipblasZgemvStridedBatched_64(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,transA.value,m,n,
        hipblasDoubleComplex.fromPyobj(alpha).getElementPtr(),
        hipblasDoubleComplex.fromPyobj(AP).getElementPtr(),lda,strideA,
        hipblasDoubleComplex.fromPyobj(x).getElementPtr(),incx,stridex,
        hipblasDoubleComplex.fromPyobj(beta).getElementPtr(),
        hipblasDoubleComplex.fromPyobj(y).getElementPtr(),incy,stridey,batchCount))
    return (_hipblasZgemvStridedBatched_64__retval,)


@cython.embedsignature(True)
def hipblasCgemvStridedBatched_v2_64(object handle, object transA, long m, long n, object alpha, object AP, long lda, long strideA, object x, long incx, long stridex, object beta, object y, long incy, long stridey, long batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        transA (`~.hipblasOperation_t`):
            (undocumented)

        m (`~.int`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        alpha (`~.float2`/`~.object`):
            (undocumented)

        AP (`~.float2`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        strideA (`~.int`):
            (undocumented)

        x (`~.float2`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        stridex (`~.int`):
            (undocumented)

        beta (`~.float2`/`~.object`):
            (undocumented)

        y (`~.float2`/`~.object`):
            (undocumented)

        incy (`~.int`):
            (undocumented)

        stridey (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    if not isinstance(transA,_hipblasOperation_t__Base):
        raise TypeError("argument 'transA' must be of type '_hipblasOperation_t__Base'")
    _hipblasCgemvStridedBatched_v2_64__retval = hipblasStatus_t(chipblas.hipblasCgemvStridedBatched_v2_64(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,transA.value,m,n,
        float2.fromPyobj(alpha).getElementPtr(),
        float2.fromPyobj(AP).getElementPtr(),lda,strideA,
        float2.fromPyobj(x).getElementPtr(),incx,stridex,
        float2.fromPyobj(beta).getElementPtr(),
        float2.fromPyobj(y).getElementPtr(),incy,stridey,batchCount))
    return (_hipblasCgemvStridedBatched_v2_64__retval,)


@cython.embedsignature(True)
def hipblasZgemvStridedBatched_v2_64(object handle, object transA, long m, long n, object alpha, object AP, long lda, long strideA, object x, long incx, long stridex, object beta, object y, long incy, long stridey, long batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        transA (`~.hipblasOperation_t`):
            (undocumented)

        m (`~.int`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        alpha (`~.double2`/`~.object`):
            (undocumented)

        AP (`~.double2`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        strideA (`~.int`):
            (undocumented)

        x (`~.double2`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        stridex (`~.int`):
            (undocumented)

        beta (`~.double2`/`~.object`):
            (undocumented)

        y (`~.double2`/`~.object`):
            (undocumented)

        incy (`~.int`):
            (undocumented)

        stridey (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    if not isinstance(transA,_hipblasOperation_t__Base):
        raise TypeError("argument 'transA' must be of type '_hipblasOperation_t__Base'")
    _hipblasZgemvStridedBatched_v2_64__retval = hipblasStatus_t(chipblas.hipblasZgemvStridedBatched_v2_64(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,transA.value,m,n,
        double2.fromPyobj(alpha).getElementPtr(),
        double2.fromPyobj(AP).getElementPtr(),lda,strideA,
        double2.fromPyobj(x).getElementPtr(),incx,stridex,
        double2.fromPyobj(beta).getElementPtr(),
        double2.fromPyobj(y).getElementPtr(),incy,stridey,batchCount))
    return (_hipblasZgemvStridedBatched_v2_64__retval,)


@cython.embedsignature(True)
def hipblasSger(object handle, int m, int n, object alpha, object x, int incx, object y, int incy, object AP, int lda):
    r"""BLAS Level 2 API

    @{

    ger,geru,gerc performs the matrix-vector operations

    A := A + alpha*x*y**T , OR
        A := A + alpha*x*y**H for gerc

    where alpha is a scalar, x and y are vectors, and A is an
    m by n matrix.

    - Supported precisions in rocBLAS : s,d,c,z
    - Supported precisions in cuBLAS  : s,d,c,z

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`) -- *IN*:
            [hipblasHandle_t]
            handle to the hipblas library context queue.

        m (`~.int`) -- *IN*:
            [int]
            the number of rows of the matrix A.

        n (`~.int`) -- *IN*:
            [int]
            the number of columns of the matrix A.

        alpha (`~.hip._util.types.Pointer`/`~.object`) -- *IN*:
            device pointer or host pointer to scalar alpha.

        x (`~.hip._util.types.Pointer`/`~.object`) -- *IN*:
            device pointer storing vector x.

        incx (`~.int`) -- *IN*:
            [int]
            specifies the increment for the elements of x.

        y (`~.hip._util.types.Pointer`/`~.object`) -- *IN*:
            device pointer storing vector y.

        incy (`~.int`) -- *IN*:
            [int]
            specifies the increment for the elements of y.

        AP (`~.hip._util.types.Pointer`/`~.object`) -- *INOUT*:
            device pointer storing matrix A.

        lda (`~.int`) -- *IN*:
            [int]
            specifies the leading dimension of A.
    """
    _hipblasSger__retval = hipblasStatus_t(chipblas.hipblasSger(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,m,n,
        <const float *>hip._util.types.Pointer.fromPyobj(alpha)._ptr,
        <const float *>hip._util.types.Pointer.fromPyobj(x)._ptr,incx,
        <const float *>hip._util.types.Pointer.fromPyobj(y)._ptr,incy,
        <float *>hip._util.types.Pointer.fromPyobj(AP)._ptr,lda))
    return (_hipblasSger__retval,)


@cython.embedsignature(True)
def hipblasDger(object handle, int m, int n, object alpha, object x, int incx, object y, int incy, object AP, int lda):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        m (`~.int`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        alpha (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        x (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        y (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        incy (`~.int`):
            (undocumented)

        AP (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)
    """
    _hipblasDger__retval = hipblasStatus_t(chipblas.hipblasDger(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,m,n,
        <const double *>hip._util.types.Pointer.fromPyobj(alpha)._ptr,
        <const double *>hip._util.types.Pointer.fromPyobj(x)._ptr,incx,
        <const double *>hip._util.types.Pointer.fromPyobj(y)._ptr,incy,
        <double *>hip._util.types.Pointer.fromPyobj(AP)._ptr,lda))
    return (_hipblasDger__retval,)


@cython.embedsignature(True)
def hipblasCgeru(object handle, int m, int n, object alpha, object x, int incx, object y, int incy, object AP, int lda):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        m (`~.int`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        alpha (`~.hipblasComplex`/`~.object`):
            (undocumented)

        x (`~.hipblasComplex`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        y (`~.hipblasComplex`/`~.object`):
            (undocumented)

        incy (`~.int`):
            (undocumented)

        AP (`~.hipblasComplex`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)
    """
    _hipblasCgeru__retval = hipblasStatus_t(chipblas.hipblasCgeru(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,m,n,
        hipblasComplex.fromPyobj(alpha).getElementPtr(),
        hipblasComplex.fromPyobj(x).getElementPtr(),incx,
        hipblasComplex.fromPyobj(y).getElementPtr(),incy,
        hipblasComplex.fromPyobj(AP).getElementPtr(),lda))
    return (_hipblasCgeru__retval,)


@cython.embedsignature(True)
def hipblasCgerc(object handle, int m, int n, object alpha, object x, int incx, object y, int incy, object AP, int lda):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        m (`~.int`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        alpha (`~.hipblasComplex`/`~.object`):
            (undocumented)

        x (`~.hipblasComplex`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        y (`~.hipblasComplex`/`~.object`):
            (undocumented)

        incy (`~.int`):
            (undocumented)

        AP (`~.hipblasComplex`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)
    """
    _hipblasCgerc__retval = hipblasStatus_t(chipblas.hipblasCgerc(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,m,n,
        hipblasComplex.fromPyobj(alpha).getElementPtr(),
        hipblasComplex.fromPyobj(x).getElementPtr(),incx,
        hipblasComplex.fromPyobj(y).getElementPtr(),incy,
        hipblasComplex.fromPyobj(AP).getElementPtr(),lda))
    return (_hipblasCgerc__retval,)


@cython.embedsignature(True)
def hipblasZgeru(object handle, int m, int n, object alpha, object x, int incx, object y, int incy, object AP, int lda):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        m (`~.int`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        alpha (`~.hipblasDoubleComplex`/`~.object`):
            (undocumented)

        x (`~.hipblasDoubleComplex`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        y (`~.hipblasDoubleComplex`/`~.object`):
            (undocumented)

        incy (`~.int`):
            (undocumented)

        AP (`~.hipblasDoubleComplex`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)
    """
    _hipblasZgeru__retval = hipblasStatus_t(chipblas.hipblasZgeru(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,m,n,
        hipblasDoubleComplex.fromPyobj(alpha).getElementPtr(),
        hipblasDoubleComplex.fromPyobj(x).getElementPtr(),incx,
        hipblasDoubleComplex.fromPyobj(y).getElementPtr(),incy,
        hipblasDoubleComplex.fromPyobj(AP).getElementPtr(),lda))
    return (_hipblasZgeru__retval,)


@cython.embedsignature(True)
def hipblasZgerc(object handle, int m, int n, object alpha, object x, int incx, object y, int incy, object AP, int lda):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        m (`~.int`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        alpha (`~.hipblasDoubleComplex`/`~.object`):
            (undocumented)

        x (`~.hipblasDoubleComplex`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        y (`~.hipblasDoubleComplex`/`~.object`):
            (undocumented)

        incy (`~.int`):
            (undocumented)

        AP (`~.hipblasDoubleComplex`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)
    """
    _hipblasZgerc__retval = hipblasStatus_t(chipblas.hipblasZgerc(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,m,n,
        hipblasDoubleComplex.fromPyobj(alpha).getElementPtr(),
        hipblasDoubleComplex.fromPyobj(x).getElementPtr(),incx,
        hipblasDoubleComplex.fromPyobj(y).getElementPtr(),incy,
        hipblasDoubleComplex.fromPyobj(AP).getElementPtr(),lda))
    return (_hipblasZgerc__retval,)


@cython.embedsignature(True)
def hipblasCgeru_v2(object handle, int m, int n, object alpha, object x, int incx, object y, int incy, object AP, int lda):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        m (`~.int`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        alpha (`~.float2`/`~.object`):
            (undocumented)

        x (`~.float2`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        y (`~.float2`/`~.object`):
            (undocumented)

        incy (`~.int`):
            (undocumented)

        AP (`~.float2`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)
    """
    _hipblasCgeru_v2__retval = hipblasStatus_t(chipblas.hipblasCgeru_v2(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,m,n,
        float2.fromPyobj(alpha).getElementPtr(),
        float2.fromPyobj(x).getElementPtr(),incx,
        float2.fromPyobj(y).getElementPtr(),incy,
        float2.fromPyobj(AP).getElementPtr(),lda))
    return (_hipblasCgeru_v2__retval,)


@cython.embedsignature(True)
def hipblasCgerc_v2(object handle, int m, int n, object alpha, object x, int incx, object y, int incy, object AP, int lda):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        m (`~.int`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        alpha (`~.float2`/`~.object`):
            (undocumented)

        x (`~.float2`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        y (`~.float2`/`~.object`):
            (undocumented)

        incy (`~.int`):
            (undocumented)

        AP (`~.float2`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)
    """
    _hipblasCgerc_v2__retval = hipblasStatus_t(chipblas.hipblasCgerc_v2(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,m,n,
        float2.fromPyobj(alpha).getElementPtr(),
        float2.fromPyobj(x).getElementPtr(),incx,
        float2.fromPyobj(y).getElementPtr(),incy,
        float2.fromPyobj(AP).getElementPtr(),lda))
    return (_hipblasCgerc_v2__retval,)


@cython.embedsignature(True)
def hipblasZgeru_v2(object handle, int m, int n, object alpha, object x, int incx, object y, int incy, object AP, int lda):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        m (`~.int`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        alpha (`~.double2`/`~.object`):
            (undocumented)

        x (`~.double2`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        y (`~.double2`/`~.object`):
            (undocumented)

        incy (`~.int`):
            (undocumented)

        AP (`~.double2`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)
    """
    _hipblasZgeru_v2__retval = hipblasStatus_t(chipblas.hipblasZgeru_v2(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,m,n,
        double2.fromPyobj(alpha).getElementPtr(),
        double2.fromPyobj(x).getElementPtr(),incx,
        double2.fromPyobj(y).getElementPtr(),incy,
        double2.fromPyobj(AP).getElementPtr(),lda))
    return (_hipblasZgeru_v2__retval,)


@cython.embedsignature(True)
def hipblasZgerc_v2(object handle, int m, int n, object alpha, object x, int incx, object y, int incy, object AP, int lda):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        m (`~.int`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        alpha (`~.double2`/`~.object`):
            (undocumented)

        x (`~.double2`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        y (`~.double2`/`~.object`):
            (undocumented)

        incy (`~.int`):
            (undocumented)

        AP (`~.double2`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)
    """
    _hipblasZgerc_v2__retval = hipblasStatus_t(chipblas.hipblasZgerc_v2(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,m,n,
        double2.fromPyobj(alpha).getElementPtr(),
        double2.fromPyobj(x).getElementPtr(),incx,
        double2.fromPyobj(y).getElementPtr(),incy,
        double2.fromPyobj(AP).getElementPtr(),lda))
    return (_hipblasZgerc_v2__retval,)


@cython.embedsignature(True)
def hipblasSger_64(object handle, long m, long n, object alpha, object x, long incx, object y, long incy, object AP, long lda):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        m (`~.int`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        alpha (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        x (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        y (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        incy (`~.int`):
            (undocumented)

        AP (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)
    """
    _hipblasSger_64__retval = hipblasStatus_t(chipblas.hipblasSger_64(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,m,n,
        <const float *>hip._util.types.Pointer.fromPyobj(alpha)._ptr,
        <const float *>hip._util.types.Pointer.fromPyobj(x)._ptr,incx,
        <const float *>hip._util.types.Pointer.fromPyobj(y)._ptr,incy,
        <float *>hip._util.types.Pointer.fromPyobj(AP)._ptr,lda))
    return (_hipblasSger_64__retval,)


@cython.embedsignature(True)
def hipblasDger_64(object handle, long m, long n, object alpha, object x, long incx, object y, long incy, object AP, long lda):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        m (`~.int`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        alpha (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        x (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        y (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        incy (`~.int`):
            (undocumented)

        AP (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)
    """
    _hipblasDger_64__retval = hipblasStatus_t(chipblas.hipblasDger_64(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,m,n,
        <const double *>hip._util.types.Pointer.fromPyobj(alpha)._ptr,
        <const double *>hip._util.types.Pointer.fromPyobj(x)._ptr,incx,
        <const double *>hip._util.types.Pointer.fromPyobj(y)._ptr,incy,
        <double *>hip._util.types.Pointer.fromPyobj(AP)._ptr,lda))
    return (_hipblasDger_64__retval,)


@cython.embedsignature(True)
def hipblasCgeru_64(object handle, long m, long n, object alpha, object x, long incx, object y, long incy, object AP, long lda):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        m (`~.int`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        alpha (`~.hipblasComplex`/`~.object`):
            (undocumented)

        x (`~.hipblasComplex`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        y (`~.hipblasComplex`/`~.object`):
            (undocumented)

        incy (`~.int`):
            (undocumented)

        AP (`~.hipblasComplex`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)
    """
    _hipblasCgeru_64__retval = hipblasStatus_t(chipblas.hipblasCgeru_64(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,m,n,
        hipblasComplex.fromPyobj(alpha).getElementPtr(),
        hipblasComplex.fromPyobj(x).getElementPtr(),incx,
        hipblasComplex.fromPyobj(y).getElementPtr(),incy,
        hipblasComplex.fromPyobj(AP).getElementPtr(),lda))
    return (_hipblasCgeru_64__retval,)


@cython.embedsignature(True)
def hipblasCgerc_64(object handle, long m, long n, object alpha, object x, long incx, object y, long incy, object AP, long lda):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        m (`~.int`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        alpha (`~.hipblasComplex`/`~.object`):
            (undocumented)

        x (`~.hipblasComplex`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        y (`~.hipblasComplex`/`~.object`):
            (undocumented)

        incy (`~.int`):
            (undocumented)

        AP (`~.hipblasComplex`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)
    """
    _hipblasCgerc_64__retval = hipblasStatus_t(chipblas.hipblasCgerc_64(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,m,n,
        hipblasComplex.fromPyobj(alpha).getElementPtr(),
        hipblasComplex.fromPyobj(x).getElementPtr(),incx,
        hipblasComplex.fromPyobj(y).getElementPtr(),incy,
        hipblasComplex.fromPyobj(AP).getElementPtr(),lda))
    return (_hipblasCgerc_64__retval,)


@cython.embedsignature(True)
def hipblasZgeru_64(object handle, long m, long n, object alpha, object x, long incx, object y, long incy, object AP, long lda):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        m (`~.int`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        alpha (`~.hipblasDoubleComplex`/`~.object`):
            (undocumented)

        x (`~.hipblasDoubleComplex`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        y (`~.hipblasDoubleComplex`/`~.object`):
            (undocumented)

        incy (`~.int`):
            (undocumented)

        AP (`~.hipblasDoubleComplex`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)
    """
    _hipblasZgeru_64__retval = hipblasStatus_t(chipblas.hipblasZgeru_64(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,m,n,
        hipblasDoubleComplex.fromPyobj(alpha).getElementPtr(),
        hipblasDoubleComplex.fromPyobj(x).getElementPtr(),incx,
        hipblasDoubleComplex.fromPyobj(y).getElementPtr(),incy,
        hipblasDoubleComplex.fromPyobj(AP).getElementPtr(),lda))
    return (_hipblasZgeru_64__retval,)


@cython.embedsignature(True)
def hipblasZgerc_64(object handle, long m, long n, object alpha, object x, long incx, object y, long incy, object AP, long lda):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        m (`~.int`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        alpha (`~.hipblasDoubleComplex`/`~.object`):
            (undocumented)

        x (`~.hipblasDoubleComplex`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        y (`~.hipblasDoubleComplex`/`~.object`):
            (undocumented)

        incy (`~.int`):
            (undocumented)

        AP (`~.hipblasDoubleComplex`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)
    """
    _hipblasZgerc_64__retval = hipblasStatus_t(chipblas.hipblasZgerc_64(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,m,n,
        hipblasDoubleComplex.fromPyobj(alpha).getElementPtr(),
        hipblasDoubleComplex.fromPyobj(x).getElementPtr(),incx,
        hipblasDoubleComplex.fromPyobj(y).getElementPtr(),incy,
        hipblasDoubleComplex.fromPyobj(AP).getElementPtr(),lda))
    return (_hipblasZgerc_64__retval,)


@cython.embedsignature(True)
def hipblasCgeru_v2_64(object handle, long m, long n, object alpha, object x, long incx, object y, long incy, object AP, long lda):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        m (`~.int`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        alpha (`~.float2`/`~.object`):
            (undocumented)

        x (`~.float2`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        y (`~.float2`/`~.object`):
            (undocumented)

        incy (`~.int`):
            (undocumented)

        AP (`~.float2`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)
    """
    _hipblasCgeru_v2_64__retval = hipblasStatus_t(chipblas.hipblasCgeru_v2_64(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,m,n,
        float2.fromPyobj(alpha).getElementPtr(),
        float2.fromPyobj(x).getElementPtr(),incx,
        float2.fromPyobj(y).getElementPtr(),incy,
        float2.fromPyobj(AP).getElementPtr(),lda))
    return (_hipblasCgeru_v2_64__retval,)


@cython.embedsignature(True)
def hipblasCgerc_v2_64(object handle, long m, long n, object alpha, object x, long incx, object y, long incy, object AP, long lda):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        m (`~.int`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        alpha (`~.float2`/`~.object`):
            (undocumented)

        x (`~.float2`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        y (`~.float2`/`~.object`):
            (undocumented)

        incy (`~.int`):
            (undocumented)

        AP (`~.float2`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)
    """
    _hipblasCgerc_v2_64__retval = hipblasStatus_t(chipblas.hipblasCgerc_v2_64(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,m,n,
        float2.fromPyobj(alpha).getElementPtr(),
        float2.fromPyobj(x).getElementPtr(),incx,
        float2.fromPyobj(y).getElementPtr(),incy,
        float2.fromPyobj(AP).getElementPtr(),lda))
    return (_hipblasCgerc_v2_64__retval,)


@cython.embedsignature(True)
def hipblasZgeru_v2_64(object handle, long m, long n, object alpha, object x, long incx, object y, long incy, object AP, long lda):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        m (`~.int`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        alpha (`~.double2`/`~.object`):
            (undocumented)

        x (`~.double2`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        y (`~.double2`/`~.object`):
            (undocumented)

        incy (`~.int`):
            (undocumented)

        AP (`~.double2`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)
    """
    _hipblasZgeru_v2_64__retval = hipblasStatus_t(chipblas.hipblasZgeru_v2_64(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,m,n,
        double2.fromPyobj(alpha).getElementPtr(),
        double2.fromPyobj(x).getElementPtr(),incx,
        double2.fromPyobj(y).getElementPtr(),incy,
        double2.fromPyobj(AP).getElementPtr(),lda))
    return (_hipblasZgeru_v2_64__retval,)


@cython.embedsignature(True)
def hipblasZgerc_v2_64(object handle, long m, long n, object alpha, object x, long incx, object y, long incy, object AP, long lda):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        m (`~.int`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        alpha (`~.double2`/`~.object`):
            (undocumented)

        x (`~.double2`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        y (`~.double2`/`~.object`):
            (undocumented)

        incy (`~.int`):
            (undocumented)

        AP (`~.double2`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)
    """
    _hipblasZgerc_v2_64__retval = hipblasStatus_t(chipblas.hipblasZgerc_v2_64(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,m,n,
        double2.fromPyobj(alpha).getElementPtr(),
        double2.fromPyobj(x).getElementPtr(),incx,
        double2.fromPyobj(y).getElementPtr(),incy,
        double2.fromPyobj(AP).getElementPtr(),lda))
    return (_hipblasZgerc_v2_64__retval,)


@cython.embedsignature(True)
def hipblasSgerBatched(object handle, int m, int n, object alpha, object x, int incx, object y, int incy, object AP, int lda, int batchCount):
    r"""BLAS Level 2 API

    @{

    gerBatched,geruBatched,gercBatched performs a batch of the matrix-vector operations

    A := A + alpha*x*y**T , OR
        A := A + alpha*x*y**H for gerc

    where (A_i, x_i, y_i) is the i-th instance of the batch.
    alpha is a scalar, x_i and y_i are vectors and A_i is an
    m by n matrix, for i = 1, ..., batchCount.

    - Supported precisions in rocBLAS : s,d,c,z
    - Supported precisions in cuBLAS  : No support

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`) -- *IN*:
            [hipblasHandle_t]
            handle to the hipblas library context queue.

        m (`~.int`) -- *IN*:
            [int]
            the number of rows of each matrix A_i.

        n (`~.int`) -- *IN*:
            [int]
            the number of columns of eaceh matrix A_i.

        alpha (`~.hip._util.types.Pointer`/`~.object`) -- *IN*:
            device pointer or host pointer to scalar alpha.

        x (`~.hip._util.types.ListOfPointer`/`~.object`) -- *IN*:
            device array of device pointers storing each vector x_i.

        incx (`~.int`) -- *IN*:
            [int]
            specifies the increment for the elements of each vector x_i.

        y (`~.hip._util.types.ListOfPointer`/`~.object`) -- *IN*:
            device array of device pointers storing each vector y_i.

        incy (`~.int`) -- *IN*:
            [int]
            specifies the increment for the elements of each vector y_i.

        AP (`~.hip._util.types.Pointer`/`~.object`) -- *INOUT*:
            device array of device pointers storing each matrix A_i.

        lda (`~.int`) -- *IN*:
            [int]
            specifies the leading dimension of each A_i.

        batchCount (`~.int`) -- *IN*:
            [int]
            number of instances in the batch
    """
    _hipblasSgerBatched__retval = hipblasStatus_t(chipblas.hipblasSgerBatched(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,m,n,
        <const float *>hip._util.types.Pointer.fromPyobj(alpha)._ptr,
        <const float *const*>hip._util.types.ListOfPointer.fromPyobj(x)._ptr,incx,
        <const float *const*>hip._util.types.ListOfPointer.fromPyobj(y)._ptr,incy,
        <float *const*>hip._util.types.Pointer.fromPyobj(AP)._ptr,lda,batchCount))
    return (_hipblasSgerBatched__retval,)


@cython.embedsignature(True)
def hipblasDgerBatched(object handle, int m, int n, object alpha, object x, int incx, object y, int incy, object AP, int lda, int batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        m (`~.int`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        alpha (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        x (`~.hip._util.types.ListOfPointer`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        y (`~.hip._util.types.ListOfPointer`/`~.object`):
            (undocumented)

        incy (`~.int`):
            (undocumented)

        AP (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    _hipblasDgerBatched__retval = hipblasStatus_t(chipblas.hipblasDgerBatched(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,m,n,
        <const double *>hip._util.types.Pointer.fromPyobj(alpha)._ptr,
        <const double *const*>hip._util.types.ListOfPointer.fromPyobj(x)._ptr,incx,
        <const double *const*>hip._util.types.ListOfPointer.fromPyobj(y)._ptr,incy,
        <double *const*>hip._util.types.Pointer.fromPyobj(AP)._ptr,lda,batchCount))
    return (_hipblasDgerBatched__retval,)


@cython.embedsignature(True)
def hipblasCgeruBatched(object handle, int m, int n, object alpha, object x, int incx, object y, int incy, object AP, int lda, int batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        m (`~.int`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        alpha (`~.hipblasComplex`/`~.object`):
            (undocumented)

        x (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        y (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        incy (`~.int`):
            (undocumented)

        AP (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    _hipblasCgeruBatched__retval = hipblasStatus_t(chipblas.hipblasCgeruBatched(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,m,n,
        hipblasComplex.fromPyobj(alpha).getElementPtr(),
        <chipblas.hipblasComplex *const*>hip._util.types.Pointer.fromPyobj(x)._ptr,incx,
        <chipblas.hipblasComplex *const*>hip._util.types.Pointer.fromPyobj(y)._ptr,incy,
        <chipblas.hipblasComplex *const*>hip._util.types.Pointer.fromPyobj(AP)._ptr,lda,batchCount))
    return (_hipblasCgeruBatched__retval,)


@cython.embedsignature(True)
def hipblasCgercBatched(object handle, int m, int n, object alpha, object x, int incx, object y, int incy, object AP, int lda, int batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        m (`~.int`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        alpha (`~.hipblasComplex`/`~.object`):
            (undocumented)

        x (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        y (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        incy (`~.int`):
            (undocumented)

        AP (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    _hipblasCgercBatched__retval = hipblasStatus_t(chipblas.hipblasCgercBatched(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,m,n,
        hipblasComplex.fromPyobj(alpha).getElementPtr(),
        <chipblas.hipblasComplex *const*>hip._util.types.Pointer.fromPyobj(x)._ptr,incx,
        <chipblas.hipblasComplex *const*>hip._util.types.Pointer.fromPyobj(y)._ptr,incy,
        <chipblas.hipblasComplex *const*>hip._util.types.Pointer.fromPyobj(AP)._ptr,lda,batchCount))
    return (_hipblasCgercBatched__retval,)


@cython.embedsignature(True)
def hipblasZgeruBatched(object handle, int m, int n, object alpha, object x, int incx, object y, int incy, object AP, int lda, int batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        m (`~.int`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        alpha (`~.hipblasDoubleComplex`/`~.object`):
            (undocumented)

        x (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        y (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        incy (`~.int`):
            (undocumented)

        AP (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    _hipblasZgeruBatched__retval = hipblasStatus_t(chipblas.hipblasZgeruBatched(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,m,n,
        hipblasDoubleComplex.fromPyobj(alpha).getElementPtr(),
        <chipblas.hipblasDoubleComplex *const*>hip._util.types.Pointer.fromPyobj(x)._ptr,incx,
        <chipblas.hipblasDoubleComplex *const*>hip._util.types.Pointer.fromPyobj(y)._ptr,incy,
        <chipblas.hipblasDoubleComplex *const*>hip._util.types.Pointer.fromPyobj(AP)._ptr,lda,batchCount))
    return (_hipblasZgeruBatched__retval,)


@cython.embedsignature(True)
def hipblasZgercBatched(object handle, int m, int n, object alpha, object x, int incx, object y, int incy, object AP, int lda, int batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        m (`~.int`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        alpha (`~.hipblasDoubleComplex`/`~.object`):
            (undocumented)

        x (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        y (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        incy (`~.int`):
            (undocumented)

        AP (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    _hipblasZgercBatched__retval = hipblasStatus_t(chipblas.hipblasZgercBatched(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,m,n,
        hipblasDoubleComplex.fromPyobj(alpha).getElementPtr(),
        <chipblas.hipblasDoubleComplex *const*>hip._util.types.Pointer.fromPyobj(x)._ptr,incx,
        <chipblas.hipblasDoubleComplex *const*>hip._util.types.Pointer.fromPyobj(y)._ptr,incy,
        <chipblas.hipblasDoubleComplex *const*>hip._util.types.Pointer.fromPyobj(AP)._ptr,lda,batchCount))
    return (_hipblasZgercBatched__retval,)


@cython.embedsignature(True)
def hipblasCgeruBatched_v2(object handle, int m, int n, object alpha, object x, int incx, object y, int incy, object AP, int lda, int batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        m (`~.int`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        alpha (`~.float2`/`~.object`):
            (undocumented)

        x (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        y (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        incy (`~.int`):
            (undocumented)

        AP (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    _hipblasCgeruBatched_v2__retval = hipblasStatus_t(chipblas.hipblasCgeruBatched_v2(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,m,n,
        float2.fromPyobj(alpha).getElementPtr(),
        <chipblas.float2 *const*>hip._util.types.Pointer.fromPyobj(x)._ptr,incx,
        <chipblas.float2 *const*>hip._util.types.Pointer.fromPyobj(y)._ptr,incy,
        <chipblas.float2 *const*>hip._util.types.Pointer.fromPyobj(AP)._ptr,lda,batchCount))
    return (_hipblasCgeruBatched_v2__retval,)


@cython.embedsignature(True)
def hipblasCgercBatched_v2(object handle, int m, int n, object alpha, object x, int incx, object y, int incy, object AP, int lda, int batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        m (`~.int`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        alpha (`~.float2`/`~.object`):
            (undocumented)

        x (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        y (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        incy (`~.int`):
            (undocumented)

        AP (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    _hipblasCgercBatched_v2__retval = hipblasStatus_t(chipblas.hipblasCgercBatched_v2(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,m,n,
        float2.fromPyobj(alpha).getElementPtr(),
        <chipblas.float2 *const*>hip._util.types.Pointer.fromPyobj(x)._ptr,incx,
        <chipblas.float2 *const*>hip._util.types.Pointer.fromPyobj(y)._ptr,incy,
        <chipblas.float2 *const*>hip._util.types.Pointer.fromPyobj(AP)._ptr,lda,batchCount))
    return (_hipblasCgercBatched_v2__retval,)


@cython.embedsignature(True)
def hipblasZgeruBatched_v2(object handle, int m, int n, object alpha, object x, int incx, object y, int incy, object AP, int lda, int batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        m (`~.int`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        alpha (`~.double2`/`~.object`):
            (undocumented)

        x (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        y (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        incy (`~.int`):
            (undocumented)

        AP (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    _hipblasZgeruBatched_v2__retval = hipblasStatus_t(chipblas.hipblasZgeruBatched_v2(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,m,n,
        double2.fromPyobj(alpha).getElementPtr(),
        <chipblas.double2 *const*>hip._util.types.Pointer.fromPyobj(x)._ptr,incx,
        <chipblas.double2 *const*>hip._util.types.Pointer.fromPyobj(y)._ptr,incy,
        <chipblas.double2 *const*>hip._util.types.Pointer.fromPyobj(AP)._ptr,lda,batchCount))
    return (_hipblasZgeruBatched_v2__retval,)


@cython.embedsignature(True)
def hipblasZgercBatched_v2(object handle, int m, int n, object alpha, object x, int incx, object y, int incy, object AP, int lda, int batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        m (`~.int`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        alpha (`~.double2`/`~.object`):
            (undocumented)

        x (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        y (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        incy (`~.int`):
            (undocumented)

        AP (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    _hipblasZgercBatched_v2__retval = hipblasStatus_t(chipblas.hipblasZgercBatched_v2(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,m,n,
        double2.fromPyobj(alpha).getElementPtr(),
        <chipblas.double2 *const*>hip._util.types.Pointer.fromPyobj(x)._ptr,incx,
        <chipblas.double2 *const*>hip._util.types.Pointer.fromPyobj(y)._ptr,incy,
        <chipblas.double2 *const*>hip._util.types.Pointer.fromPyobj(AP)._ptr,lda,batchCount))
    return (_hipblasZgercBatched_v2__retval,)


@cython.embedsignature(True)
def hipblasSgerBatched_64(object handle, long m, long n, object alpha, object x, long incx, object y, long incy, object AP, long lda, long batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        m (`~.int`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        alpha (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        x (`~.hip._util.types.ListOfPointer`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        y (`~.hip._util.types.ListOfPointer`/`~.object`):
            (undocumented)

        incy (`~.int`):
            (undocumented)

        AP (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    _hipblasSgerBatched_64__retval = hipblasStatus_t(chipblas.hipblasSgerBatched_64(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,m,n,
        <const float *>hip._util.types.Pointer.fromPyobj(alpha)._ptr,
        <const float *const*>hip._util.types.ListOfPointer.fromPyobj(x)._ptr,incx,
        <const float *const*>hip._util.types.ListOfPointer.fromPyobj(y)._ptr,incy,
        <float *const*>hip._util.types.Pointer.fromPyobj(AP)._ptr,lda,batchCount))
    return (_hipblasSgerBatched_64__retval,)


@cython.embedsignature(True)
def hipblasDgerBatched_64(object handle, long m, long n, object alpha, object x, long incx, object y, long incy, object AP, long lda, long batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        m (`~.int`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        alpha (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        x (`~.hip._util.types.ListOfPointer`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        y (`~.hip._util.types.ListOfPointer`/`~.object`):
            (undocumented)

        incy (`~.int`):
            (undocumented)

        AP (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    _hipblasDgerBatched_64__retval = hipblasStatus_t(chipblas.hipblasDgerBatched_64(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,m,n,
        <const double *>hip._util.types.Pointer.fromPyobj(alpha)._ptr,
        <const double *const*>hip._util.types.ListOfPointer.fromPyobj(x)._ptr,incx,
        <const double *const*>hip._util.types.ListOfPointer.fromPyobj(y)._ptr,incy,
        <double *const*>hip._util.types.Pointer.fromPyobj(AP)._ptr,lda,batchCount))
    return (_hipblasDgerBatched_64__retval,)


@cython.embedsignature(True)
def hipblasCgeruBatched_64(object handle, long m, long n, object alpha, object x, long incx, object y, long incy, object AP, long lda, long batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        m (`~.int`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        alpha (`~.hipblasComplex`/`~.object`):
            (undocumented)

        x (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        y (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        incy (`~.int`):
            (undocumented)

        AP (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    _hipblasCgeruBatched_64__retval = hipblasStatus_t(chipblas.hipblasCgeruBatched_64(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,m,n,
        hipblasComplex.fromPyobj(alpha).getElementPtr(),
        <chipblas.hipblasComplex *const*>hip._util.types.Pointer.fromPyobj(x)._ptr,incx,
        <chipblas.hipblasComplex *const*>hip._util.types.Pointer.fromPyobj(y)._ptr,incy,
        <chipblas.hipblasComplex *const*>hip._util.types.Pointer.fromPyobj(AP)._ptr,lda,batchCount))
    return (_hipblasCgeruBatched_64__retval,)


@cython.embedsignature(True)
def hipblasCgercBatched_64(object handle, long m, long n, object alpha, object x, long incx, object y, long incy, object AP, long lda, long batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        m (`~.int`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        alpha (`~.hipblasComplex`/`~.object`):
            (undocumented)

        x (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        y (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        incy (`~.int`):
            (undocumented)

        AP (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    _hipblasCgercBatched_64__retval = hipblasStatus_t(chipblas.hipblasCgercBatched_64(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,m,n,
        hipblasComplex.fromPyobj(alpha).getElementPtr(),
        <chipblas.hipblasComplex *const*>hip._util.types.Pointer.fromPyobj(x)._ptr,incx,
        <chipblas.hipblasComplex *const*>hip._util.types.Pointer.fromPyobj(y)._ptr,incy,
        <chipblas.hipblasComplex *const*>hip._util.types.Pointer.fromPyobj(AP)._ptr,lda,batchCount))
    return (_hipblasCgercBatched_64__retval,)


@cython.embedsignature(True)
def hipblasZgeruBatched_64(object handle, long m, long n, object alpha, object x, long incx, object y, long incy, object AP, long lda, long batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        m (`~.int`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        alpha (`~.hipblasDoubleComplex`/`~.object`):
            (undocumented)

        x (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        y (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        incy (`~.int`):
            (undocumented)

        AP (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    _hipblasZgeruBatched_64__retval = hipblasStatus_t(chipblas.hipblasZgeruBatched_64(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,m,n,
        hipblasDoubleComplex.fromPyobj(alpha).getElementPtr(),
        <chipblas.hipblasDoubleComplex *const*>hip._util.types.Pointer.fromPyobj(x)._ptr,incx,
        <chipblas.hipblasDoubleComplex *const*>hip._util.types.Pointer.fromPyobj(y)._ptr,incy,
        <chipblas.hipblasDoubleComplex *const*>hip._util.types.Pointer.fromPyobj(AP)._ptr,lda,batchCount))
    return (_hipblasZgeruBatched_64__retval,)


@cython.embedsignature(True)
def hipblasZgercBatched_64(object handle, long m, long n, object alpha, object x, long incx, object y, long incy, object AP, long lda, long batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        m (`~.int`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        alpha (`~.hipblasDoubleComplex`/`~.object`):
            (undocumented)

        x (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        y (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        incy (`~.int`):
            (undocumented)

        AP (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    _hipblasZgercBatched_64__retval = hipblasStatus_t(chipblas.hipblasZgercBatched_64(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,m,n,
        hipblasDoubleComplex.fromPyobj(alpha).getElementPtr(),
        <chipblas.hipblasDoubleComplex *const*>hip._util.types.Pointer.fromPyobj(x)._ptr,incx,
        <chipblas.hipblasDoubleComplex *const*>hip._util.types.Pointer.fromPyobj(y)._ptr,incy,
        <chipblas.hipblasDoubleComplex *const*>hip._util.types.Pointer.fromPyobj(AP)._ptr,lda,batchCount))
    return (_hipblasZgercBatched_64__retval,)


@cython.embedsignature(True)
def hipblasCgeruBatched_v2_64(object handle, long m, long n, object alpha, object x, long incx, object y, long incy, object AP, long lda, long batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        m (`~.int`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        alpha (`~.float2`/`~.object`):
            (undocumented)

        x (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        y (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        incy (`~.int`):
            (undocumented)

        AP (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    _hipblasCgeruBatched_v2_64__retval = hipblasStatus_t(chipblas.hipblasCgeruBatched_v2_64(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,m,n,
        float2.fromPyobj(alpha).getElementPtr(),
        <chipblas.float2 *const*>hip._util.types.Pointer.fromPyobj(x)._ptr,incx,
        <chipblas.float2 *const*>hip._util.types.Pointer.fromPyobj(y)._ptr,incy,
        <chipblas.float2 *const*>hip._util.types.Pointer.fromPyobj(AP)._ptr,lda,batchCount))
    return (_hipblasCgeruBatched_v2_64__retval,)


@cython.embedsignature(True)
def hipblasCgercBatched_v2_64(object handle, long m, long n, object alpha, object x, long incx, object y, long incy, object AP, long lda, long batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        m (`~.int`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        alpha (`~.float2`/`~.object`):
            (undocumented)

        x (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        y (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        incy (`~.int`):
            (undocumented)

        AP (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    _hipblasCgercBatched_v2_64__retval = hipblasStatus_t(chipblas.hipblasCgercBatched_v2_64(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,m,n,
        float2.fromPyobj(alpha).getElementPtr(),
        <chipblas.float2 *const*>hip._util.types.Pointer.fromPyobj(x)._ptr,incx,
        <chipblas.float2 *const*>hip._util.types.Pointer.fromPyobj(y)._ptr,incy,
        <chipblas.float2 *const*>hip._util.types.Pointer.fromPyobj(AP)._ptr,lda,batchCount))
    return (_hipblasCgercBatched_v2_64__retval,)


@cython.embedsignature(True)
def hipblasZgeruBatched_v2_64(object handle, long m, long n, object alpha, object x, long incx, object y, long incy, object AP, long lda, long batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        m (`~.int`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        alpha (`~.double2`/`~.object`):
            (undocumented)

        x (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        y (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        incy (`~.int`):
            (undocumented)

        AP (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    _hipblasZgeruBatched_v2_64__retval = hipblasStatus_t(chipblas.hipblasZgeruBatched_v2_64(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,m,n,
        double2.fromPyobj(alpha).getElementPtr(),
        <chipblas.double2 *const*>hip._util.types.Pointer.fromPyobj(x)._ptr,incx,
        <chipblas.double2 *const*>hip._util.types.Pointer.fromPyobj(y)._ptr,incy,
        <chipblas.double2 *const*>hip._util.types.Pointer.fromPyobj(AP)._ptr,lda,batchCount))
    return (_hipblasZgeruBatched_v2_64__retval,)


@cython.embedsignature(True)
def hipblasZgercBatched_v2_64(object handle, long m, long n, object alpha, object x, long incx, object y, long incy, object AP, long lda, long batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        m (`~.int`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        alpha (`~.double2`/`~.object`):
            (undocumented)

        x (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        y (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        incy (`~.int`):
            (undocumented)

        AP (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    _hipblasZgercBatched_v2_64__retval = hipblasStatus_t(chipblas.hipblasZgercBatched_v2_64(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,m,n,
        double2.fromPyobj(alpha).getElementPtr(),
        <chipblas.double2 *const*>hip._util.types.Pointer.fromPyobj(x)._ptr,incx,
        <chipblas.double2 *const*>hip._util.types.Pointer.fromPyobj(y)._ptr,incy,
        <chipblas.double2 *const*>hip._util.types.Pointer.fromPyobj(AP)._ptr,lda,batchCount))
    return (_hipblasZgercBatched_v2_64__retval,)


@cython.embedsignature(True)
def hipblasSgerStridedBatched(object handle, int m, int n, object alpha, object x, int incx, long stridex, object y, int incy, long stridey, object AP, int lda, long strideA, int batchCount):
    r"""BLAS Level 2 API

    @{

    gerStridedBatched,geruStridedBatched,gercStridedBatched performs the matrix-vector operations

    A_i := A_i + alpha*x_i*y_i**T, OR
        A_i := A_i + alpha*x_i*y_i**H  for gerc

    where (A_i, x_i, y_i) is the i-th instance of the batch.
    alpha is a scalar, x_i and y_i are vectors and A_i is an
    m by n matrix, for i = 1, ..., batchCount.

    - Supported precisions in rocBLAS : s,d,c,z
    - Supported precisions in cuBLAS  : No support

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`) -- *IN*:
            [hipblasHandle_t]
            handle to the hipblas library context queue.

        m (`~.int`) -- *IN*:
            [int]
            the number of rows of each matrix A_i.

        n (`~.int`) -- *IN*:
            [int]
            the number of columns of each matrix A_i.

        alpha (`~.hip._util.types.Pointer`/`~.object`) -- *IN*:
            device pointer or host pointer to scalar alpha.

        x (`~.hip._util.types.Pointer`/`~.object`) -- *IN*:
            device pointer to the first vector (x_1) in the batch.

        incx (`~.int`) -- *IN*:
            [int]
            specifies the increments for the elements of each vector x_i.

        stridex (`~.int`) -- *IN*:
            [hipblasStride]
            stride from the start of one vector (x_i) and the next one (x_i+1).
            There are no restrictions placed on stridex, however the user should
            take care to ensure that stridex is of appropriate size, for a typical
            case this means stridex >= m * incx.

        y (`~.hip._util.types.Pointer`/`~.object`) -- *INOUT*:
            device pointer to the first vector (y_1) in the batch.

        incy (`~.int`) -- *IN*:
            [int]
            specifies the increment for the elements of each vector y_i.

        stridey (`~.int`) -- *IN*:
            [hipblasStride]
            stride from the start of one vector (y_i) and the next one (y_i+1).
            There are no restrictions placed on stridey, however the user should
            take care to ensure that stridey is of appropriate size, for a typical
            case this means stridey >= n * incy.

        AP (`~.hip._util.types.Pointer`/`~.object`) -- *INOUT*:
            device pointer to the first matrix (A_1) in the batch.

        lda (`~.int`) -- *IN*:
            [int]
            specifies the leading dimension of each A_i.

        strideA (`~.int`) -- *IN*:
            [hipblasStride]
            stride from the start of one matrix (A_i) and the next one (A_i+1)

        batchCount (`~.int`) -- *IN*:
            [int]
            number of instances in the batch
    """
    _hipblasSgerStridedBatched__retval = hipblasStatus_t(chipblas.hipblasSgerStridedBatched(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,m,n,
        <const float *>hip._util.types.Pointer.fromPyobj(alpha)._ptr,
        <const float *>hip._util.types.Pointer.fromPyobj(x)._ptr,incx,stridex,
        <const float *>hip._util.types.Pointer.fromPyobj(y)._ptr,incy,stridey,
        <float *>hip._util.types.Pointer.fromPyobj(AP)._ptr,lda,strideA,batchCount))
    return (_hipblasSgerStridedBatched__retval,)


@cython.embedsignature(True)
def hipblasDgerStridedBatched(object handle, int m, int n, object alpha, object x, int incx, long stridex, object y, int incy, long stridey, object AP, int lda, long strideA, int batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        m (`~.int`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        alpha (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        x (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        stridex (`~.int`):
            (undocumented)

        y (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        incy (`~.int`):
            (undocumented)

        stridey (`~.int`):
            (undocumented)

        AP (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        strideA (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    _hipblasDgerStridedBatched__retval = hipblasStatus_t(chipblas.hipblasDgerStridedBatched(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,m,n,
        <const double *>hip._util.types.Pointer.fromPyobj(alpha)._ptr,
        <const double *>hip._util.types.Pointer.fromPyobj(x)._ptr,incx,stridex,
        <const double *>hip._util.types.Pointer.fromPyobj(y)._ptr,incy,stridey,
        <double *>hip._util.types.Pointer.fromPyobj(AP)._ptr,lda,strideA,batchCount))
    return (_hipblasDgerStridedBatched__retval,)


@cython.embedsignature(True)
def hipblasCgeruStridedBatched(object handle, int m, int n, object alpha, object x, int incx, long stridex, object y, int incy, long stridey, object AP, int lda, long strideA, int batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        m (`~.int`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        alpha (`~.hipblasComplex`/`~.object`):
            (undocumented)

        x (`~.hipblasComplex`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        stridex (`~.int`):
            (undocumented)

        y (`~.hipblasComplex`/`~.object`):
            (undocumented)

        incy (`~.int`):
            (undocumented)

        stridey (`~.int`):
            (undocumented)

        AP (`~.hipblasComplex`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        strideA (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    _hipblasCgeruStridedBatched__retval = hipblasStatus_t(chipblas.hipblasCgeruStridedBatched(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,m,n,
        hipblasComplex.fromPyobj(alpha).getElementPtr(),
        hipblasComplex.fromPyobj(x).getElementPtr(),incx,stridex,
        hipblasComplex.fromPyobj(y).getElementPtr(),incy,stridey,
        hipblasComplex.fromPyobj(AP).getElementPtr(),lda,strideA,batchCount))
    return (_hipblasCgeruStridedBatched__retval,)


@cython.embedsignature(True)
def hipblasCgercStridedBatched(object handle, int m, int n, object alpha, object x, int incx, long stridex, object y, int incy, long stridey, object AP, int lda, long strideA, int batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        m (`~.int`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        alpha (`~.hipblasComplex`/`~.object`):
            (undocumented)

        x (`~.hipblasComplex`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        stridex (`~.int`):
            (undocumented)

        y (`~.hipblasComplex`/`~.object`):
            (undocumented)

        incy (`~.int`):
            (undocumented)

        stridey (`~.int`):
            (undocumented)

        AP (`~.hipblasComplex`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        strideA (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    _hipblasCgercStridedBatched__retval = hipblasStatus_t(chipblas.hipblasCgercStridedBatched(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,m,n,
        hipblasComplex.fromPyobj(alpha).getElementPtr(),
        hipblasComplex.fromPyobj(x).getElementPtr(),incx,stridex,
        hipblasComplex.fromPyobj(y).getElementPtr(),incy,stridey,
        hipblasComplex.fromPyobj(AP).getElementPtr(),lda,strideA,batchCount))
    return (_hipblasCgercStridedBatched__retval,)


@cython.embedsignature(True)
def hipblasZgeruStridedBatched(object handle, int m, int n, object alpha, object x, int incx, long stridex, object y, int incy, long stridey, object AP, int lda, long strideA, int batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        m (`~.int`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        alpha (`~.hipblasDoubleComplex`/`~.object`):
            (undocumented)

        x (`~.hipblasDoubleComplex`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        stridex (`~.int`):
            (undocumented)

        y (`~.hipblasDoubleComplex`/`~.object`):
            (undocumented)

        incy (`~.int`):
            (undocumented)

        stridey (`~.int`):
            (undocumented)

        AP (`~.hipblasDoubleComplex`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        strideA (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    _hipblasZgeruStridedBatched__retval = hipblasStatus_t(chipblas.hipblasZgeruStridedBatched(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,m,n,
        hipblasDoubleComplex.fromPyobj(alpha).getElementPtr(),
        hipblasDoubleComplex.fromPyobj(x).getElementPtr(),incx,stridex,
        hipblasDoubleComplex.fromPyobj(y).getElementPtr(),incy,stridey,
        hipblasDoubleComplex.fromPyobj(AP).getElementPtr(),lda,strideA,batchCount))
    return (_hipblasZgeruStridedBatched__retval,)


@cython.embedsignature(True)
def hipblasZgercStridedBatched(object handle, int m, int n, object alpha, object x, int incx, long stridex, object y, int incy, long stridey, object AP, int lda, long strideA, int batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        m (`~.int`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        alpha (`~.hipblasDoubleComplex`/`~.object`):
            (undocumented)

        x (`~.hipblasDoubleComplex`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        stridex (`~.int`):
            (undocumented)

        y (`~.hipblasDoubleComplex`/`~.object`):
            (undocumented)

        incy (`~.int`):
            (undocumented)

        stridey (`~.int`):
            (undocumented)

        AP (`~.hipblasDoubleComplex`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        strideA (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    _hipblasZgercStridedBatched__retval = hipblasStatus_t(chipblas.hipblasZgercStridedBatched(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,m,n,
        hipblasDoubleComplex.fromPyobj(alpha).getElementPtr(),
        hipblasDoubleComplex.fromPyobj(x).getElementPtr(),incx,stridex,
        hipblasDoubleComplex.fromPyobj(y).getElementPtr(),incy,stridey,
        hipblasDoubleComplex.fromPyobj(AP).getElementPtr(),lda,strideA,batchCount))
    return (_hipblasZgercStridedBatched__retval,)


@cython.embedsignature(True)
def hipblasCgeruStridedBatched_v2(object handle, int m, int n, object alpha, object x, int incx, long stridex, object y, int incy, long stridey, object AP, int lda, long strideA, int batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        m (`~.int`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        alpha (`~.float2`/`~.object`):
            (undocumented)

        x (`~.float2`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        stridex (`~.int`):
            (undocumented)

        y (`~.float2`/`~.object`):
            (undocumented)

        incy (`~.int`):
            (undocumented)

        stridey (`~.int`):
            (undocumented)

        AP (`~.float2`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        strideA (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    _hipblasCgeruStridedBatched_v2__retval = hipblasStatus_t(chipblas.hipblasCgeruStridedBatched_v2(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,m,n,
        float2.fromPyobj(alpha).getElementPtr(),
        float2.fromPyobj(x).getElementPtr(),incx,stridex,
        float2.fromPyobj(y).getElementPtr(),incy,stridey,
        float2.fromPyobj(AP).getElementPtr(),lda,strideA,batchCount))
    return (_hipblasCgeruStridedBatched_v2__retval,)


@cython.embedsignature(True)
def hipblasCgercStridedBatched_v2(object handle, int m, int n, object alpha, object x, int incx, long stridex, object y, int incy, long stridey, object AP, int lda, long strideA, int batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        m (`~.int`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        alpha (`~.float2`/`~.object`):
            (undocumented)

        x (`~.float2`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        stridex (`~.int`):
            (undocumented)

        y (`~.float2`/`~.object`):
            (undocumented)

        incy (`~.int`):
            (undocumented)

        stridey (`~.int`):
            (undocumented)

        AP (`~.float2`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        strideA (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    _hipblasCgercStridedBatched_v2__retval = hipblasStatus_t(chipblas.hipblasCgercStridedBatched_v2(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,m,n,
        float2.fromPyobj(alpha).getElementPtr(),
        float2.fromPyobj(x).getElementPtr(),incx,stridex,
        float2.fromPyobj(y).getElementPtr(),incy,stridey,
        float2.fromPyobj(AP).getElementPtr(),lda,strideA,batchCount))
    return (_hipblasCgercStridedBatched_v2__retval,)


@cython.embedsignature(True)
def hipblasZgeruStridedBatched_v2(object handle, int m, int n, object alpha, object x, int incx, long stridex, object y, int incy, long stridey, object AP, int lda, long strideA, int batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        m (`~.int`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        alpha (`~.double2`/`~.object`):
            (undocumented)

        x (`~.double2`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        stridex (`~.int`):
            (undocumented)

        y (`~.double2`/`~.object`):
            (undocumented)

        incy (`~.int`):
            (undocumented)

        stridey (`~.int`):
            (undocumented)

        AP (`~.double2`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        strideA (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    _hipblasZgeruStridedBatched_v2__retval = hipblasStatus_t(chipblas.hipblasZgeruStridedBatched_v2(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,m,n,
        double2.fromPyobj(alpha).getElementPtr(),
        double2.fromPyobj(x).getElementPtr(),incx,stridex,
        double2.fromPyobj(y).getElementPtr(),incy,stridey,
        double2.fromPyobj(AP).getElementPtr(),lda,strideA,batchCount))
    return (_hipblasZgeruStridedBatched_v2__retval,)


@cython.embedsignature(True)
def hipblasZgercStridedBatched_v2(object handle, int m, int n, object alpha, object x, int incx, long stridex, object y, int incy, long stridey, object AP, int lda, long strideA, int batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        m (`~.int`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        alpha (`~.double2`/`~.object`):
            (undocumented)

        x (`~.double2`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        stridex (`~.int`):
            (undocumented)

        y (`~.double2`/`~.object`):
            (undocumented)

        incy (`~.int`):
            (undocumented)

        stridey (`~.int`):
            (undocumented)

        AP (`~.double2`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        strideA (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    _hipblasZgercStridedBatched_v2__retval = hipblasStatus_t(chipblas.hipblasZgercStridedBatched_v2(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,m,n,
        double2.fromPyobj(alpha).getElementPtr(),
        double2.fromPyobj(x).getElementPtr(),incx,stridex,
        double2.fromPyobj(y).getElementPtr(),incy,stridey,
        double2.fromPyobj(AP).getElementPtr(),lda,strideA,batchCount))
    return (_hipblasZgercStridedBatched_v2__retval,)


@cython.embedsignature(True)
def hipblasSgerStridedBatched_64(object handle, long m, long n, object alpha, object x, long incx, long stridex, object y, long incy, long stridey, object AP, long lda, long strideA, long batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        m (`~.int`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        alpha (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        x (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        stridex (`~.int`):
            (undocumented)

        y (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        incy (`~.int`):
            (undocumented)

        stridey (`~.int`):
            (undocumented)

        AP (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        strideA (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    _hipblasSgerStridedBatched_64__retval = hipblasStatus_t(chipblas.hipblasSgerStridedBatched_64(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,m,n,
        <const float *>hip._util.types.Pointer.fromPyobj(alpha)._ptr,
        <const float *>hip._util.types.Pointer.fromPyobj(x)._ptr,incx,stridex,
        <const float *>hip._util.types.Pointer.fromPyobj(y)._ptr,incy,stridey,
        <float *>hip._util.types.Pointer.fromPyobj(AP)._ptr,lda,strideA,batchCount))
    return (_hipblasSgerStridedBatched_64__retval,)


@cython.embedsignature(True)
def hipblasDgerStridedBatched_64(object handle, long m, long n, object alpha, object x, long incx, long stridex, object y, long incy, long stridey, object AP, long lda, long strideA, long batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        m (`~.int`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        alpha (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        x (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        stridex (`~.int`):
            (undocumented)

        y (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        incy (`~.int`):
            (undocumented)

        stridey (`~.int`):
            (undocumented)

        AP (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        strideA (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    _hipblasDgerStridedBatched_64__retval = hipblasStatus_t(chipblas.hipblasDgerStridedBatched_64(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,m,n,
        <const double *>hip._util.types.Pointer.fromPyobj(alpha)._ptr,
        <const double *>hip._util.types.Pointer.fromPyobj(x)._ptr,incx,stridex,
        <const double *>hip._util.types.Pointer.fromPyobj(y)._ptr,incy,stridey,
        <double *>hip._util.types.Pointer.fromPyobj(AP)._ptr,lda,strideA,batchCount))
    return (_hipblasDgerStridedBatched_64__retval,)


@cython.embedsignature(True)
def hipblasCgeruStridedBatched_64(object handle, long m, long n, object alpha, object x, long incx, long stridex, object y, long incy, long stridey, object AP, long lda, long strideA, long batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        m (`~.int`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        alpha (`~.hipblasComplex`/`~.object`):
            (undocumented)

        x (`~.hipblasComplex`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        stridex (`~.int`):
            (undocumented)

        y (`~.hipblasComplex`/`~.object`):
            (undocumented)

        incy (`~.int`):
            (undocumented)

        stridey (`~.int`):
            (undocumented)

        AP (`~.hipblasComplex`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        strideA (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    _hipblasCgeruStridedBatched_64__retval = hipblasStatus_t(chipblas.hipblasCgeruStridedBatched_64(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,m,n,
        hipblasComplex.fromPyobj(alpha).getElementPtr(),
        hipblasComplex.fromPyobj(x).getElementPtr(),incx,stridex,
        hipblasComplex.fromPyobj(y).getElementPtr(),incy,stridey,
        hipblasComplex.fromPyobj(AP).getElementPtr(),lda,strideA,batchCount))
    return (_hipblasCgeruStridedBatched_64__retval,)


@cython.embedsignature(True)
def hipblasCgercStridedBatched_64(object handle, long m, long n, object alpha, object x, long incx, long stridex, object y, long incy, long stridey, object AP, long lda, long strideA, long batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        m (`~.int`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        alpha (`~.hipblasComplex`/`~.object`):
            (undocumented)

        x (`~.hipblasComplex`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        stridex (`~.int`):
            (undocumented)

        y (`~.hipblasComplex`/`~.object`):
            (undocumented)

        incy (`~.int`):
            (undocumented)

        stridey (`~.int`):
            (undocumented)

        AP (`~.hipblasComplex`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        strideA (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    _hipblasCgercStridedBatched_64__retval = hipblasStatus_t(chipblas.hipblasCgercStridedBatched_64(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,m,n,
        hipblasComplex.fromPyobj(alpha).getElementPtr(),
        hipblasComplex.fromPyobj(x).getElementPtr(),incx,stridex,
        hipblasComplex.fromPyobj(y).getElementPtr(),incy,stridey,
        hipblasComplex.fromPyobj(AP).getElementPtr(),lda,strideA,batchCount))
    return (_hipblasCgercStridedBatched_64__retval,)


@cython.embedsignature(True)
def hipblasZgeruStridedBatched_64(object handle, long m, long n, object alpha, object x, long incx, long stridex, object y, long incy, long stridey, object AP, long lda, long strideA, long batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        m (`~.int`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        alpha (`~.hipblasDoubleComplex`/`~.object`):
            (undocumented)

        x (`~.hipblasDoubleComplex`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        stridex (`~.int`):
            (undocumented)

        y (`~.hipblasDoubleComplex`/`~.object`):
            (undocumented)

        incy (`~.int`):
            (undocumented)

        stridey (`~.int`):
            (undocumented)

        AP (`~.hipblasDoubleComplex`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        strideA (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    _hipblasZgeruStridedBatched_64__retval = hipblasStatus_t(chipblas.hipblasZgeruStridedBatched_64(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,m,n,
        hipblasDoubleComplex.fromPyobj(alpha).getElementPtr(),
        hipblasDoubleComplex.fromPyobj(x).getElementPtr(),incx,stridex,
        hipblasDoubleComplex.fromPyobj(y).getElementPtr(),incy,stridey,
        hipblasDoubleComplex.fromPyobj(AP).getElementPtr(),lda,strideA,batchCount))
    return (_hipblasZgeruStridedBatched_64__retval,)


@cython.embedsignature(True)
def hipblasZgercStridedBatched_64(object handle, long m, long n, object alpha, object x, long incx, long stridex, object y, long incy, long stridey, object AP, long lda, long strideA, long batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        m (`~.int`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        alpha (`~.hipblasDoubleComplex`/`~.object`):
            (undocumented)

        x (`~.hipblasDoubleComplex`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        stridex (`~.int`):
            (undocumented)

        y (`~.hipblasDoubleComplex`/`~.object`):
            (undocumented)

        incy (`~.int`):
            (undocumented)

        stridey (`~.int`):
            (undocumented)

        AP (`~.hipblasDoubleComplex`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        strideA (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    _hipblasZgercStridedBatched_64__retval = hipblasStatus_t(chipblas.hipblasZgercStridedBatched_64(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,m,n,
        hipblasDoubleComplex.fromPyobj(alpha).getElementPtr(),
        hipblasDoubleComplex.fromPyobj(x).getElementPtr(),incx,stridex,
        hipblasDoubleComplex.fromPyobj(y).getElementPtr(),incy,stridey,
        hipblasDoubleComplex.fromPyobj(AP).getElementPtr(),lda,strideA,batchCount))
    return (_hipblasZgercStridedBatched_64__retval,)


@cython.embedsignature(True)
def hipblasCgeruStridedBatched_v2_64(object handle, long m, long n, object alpha, object x, long incx, long stridex, object y, long incy, long stridey, object AP, long lda, long strideA, long batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        m (`~.int`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        alpha (`~.float2`/`~.object`):
            (undocumented)

        x (`~.float2`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        stridex (`~.int`):
            (undocumented)

        y (`~.float2`/`~.object`):
            (undocumented)

        incy (`~.int`):
            (undocumented)

        stridey (`~.int`):
            (undocumented)

        AP (`~.float2`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        strideA (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    _hipblasCgeruStridedBatched_v2_64__retval = hipblasStatus_t(chipblas.hipblasCgeruStridedBatched_v2_64(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,m,n,
        float2.fromPyobj(alpha).getElementPtr(),
        float2.fromPyobj(x).getElementPtr(),incx,stridex,
        float2.fromPyobj(y).getElementPtr(),incy,stridey,
        float2.fromPyobj(AP).getElementPtr(),lda,strideA,batchCount))
    return (_hipblasCgeruStridedBatched_v2_64__retval,)


@cython.embedsignature(True)
def hipblasCgercStridedBatched_v2_64(object handle, long m, long n, object alpha, object x, long incx, long stridex, object y, long incy, long stridey, object AP, long lda, long strideA, long batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        m (`~.int`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        alpha (`~.float2`/`~.object`):
            (undocumented)

        x (`~.float2`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        stridex (`~.int`):
            (undocumented)

        y (`~.float2`/`~.object`):
            (undocumented)

        incy (`~.int`):
            (undocumented)

        stridey (`~.int`):
            (undocumented)

        AP (`~.float2`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        strideA (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    _hipblasCgercStridedBatched_v2_64__retval = hipblasStatus_t(chipblas.hipblasCgercStridedBatched_v2_64(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,m,n,
        float2.fromPyobj(alpha).getElementPtr(),
        float2.fromPyobj(x).getElementPtr(),incx,stridex,
        float2.fromPyobj(y).getElementPtr(),incy,stridey,
        float2.fromPyobj(AP).getElementPtr(),lda,strideA,batchCount))
    return (_hipblasCgercStridedBatched_v2_64__retval,)


@cython.embedsignature(True)
def hipblasZgeruStridedBatched_v2_64(object handle, long m, long n, object alpha, object x, long incx, long stridex, object y, long incy, long stridey, object AP, long lda, long strideA, long batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        m (`~.int`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        alpha (`~.double2`/`~.object`):
            (undocumented)

        x (`~.double2`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        stridex (`~.int`):
            (undocumented)

        y (`~.double2`/`~.object`):
            (undocumented)

        incy (`~.int`):
            (undocumented)

        stridey (`~.int`):
            (undocumented)

        AP (`~.double2`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        strideA (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    _hipblasZgeruStridedBatched_v2_64__retval = hipblasStatus_t(chipblas.hipblasZgeruStridedBatched_v2_64(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,m,n,
        double2.fromPyobj(alpha).getElementPtr(),
        double2.fromPyobj(x).getElementPtr(),incx,stridex,
        double2.fromPyobj(y).getElementPtr(),incy,stridey,
        double2.fromPyobj(AP).getElementPtr(),lda,strideA,batchCount))
    return (_hipblasZgeruStridedBatched_v2_64__retval,)


@cython.embedsignature(True)
def hipblasZgercStridedBatched_v2_64(object handle, long m, long n, object alpha, object x, long incx, long stridex, object y, long incy, long stridey, object AP, long lda, long strideA, long batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        m (`~.int`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        alpha (`~.double2`/`~.object`):
            (undocumented)

        x (`~.double2`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        stridex (`~.int`):
            (undocumented)

        y (`~.double2`/`~.object`):
            (undocumented)

        incy (`~.int`):
            (undocumented)

        stridey (`~.int`):
            (undocumented)

        AP (`~.double2`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        strideA (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    _hipblasZgercStridedBatched_v2_64__retval = hipblasStatus_t(chipblas.hipblasZgercStridedBatched_v2_64(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,m,n,
        double2.fromPyobj(alpha).getElementPtr(),
        double2.fromPyobj(x).getElementPtr(),incx,stridex,
        double2.fromPyobj(y).getElementPtr(),incy,stridey,
        double2.fromPyobj(AP).getElementPtr(),lda,strideA,batchCount))
    return (_hipblasZgercStridedBatched_v2_64__retval,)


@cython.embedsignature(True)
def hipblasChbmv(object handle, object uplo, int n, int k, object alpha, object AP, int lda, object x, int incx, object beta, object y, int incy):
    r"""BLAS Level 2 API

    @{

    hbmv performs the matrix-vector operations

    y := alpha*A*x + beta*y

    where alpha and beta are scalars, x and y are n element vectors and A is an
    n by n Hermitian band matrix, with k super-diagonals.

    - Supported precisions in rocBLAS : c,z
    - Supported precisions in cuBLAS  : c,z

    if uplo == HIPBLAS_FILL_MODE_LOWER:
      The leading (k + 1) by n part of A must contain the lower
      triangular band part of the Hermitian matrix, with the leading
      diagonal in row (1), the first sub-diagonal on the LHS of
      row 2, etc.
      The bottom right k by k triangle of A will not be referenced.
          Ex (lower, lda = 2, n = 4, k = 1):
          A                               Represented matrix
          (1,0) (2,0) (3,0) (4,0)         (1, 0) (5,-9) (0, 0) (0, 0)
          (5,9) (6,8) (7,7) (0,0)         (5, 9) (2, 0) (6,-8) (0, 0)
                                          (0, 0) (6, 8) (3, 0) (7,-7)
                                          (0, 0) (0, 0) (7, 7) (4, 0)

    As a Hermitian matrix, the imaginary part of the main diagonal
    of A will not be referenced and is assumed to be == 0.

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`) -- *IN*:
            [hipblasHandle_t]
            handle to the hipblas library context queue.

        uplo (`~.hipblasFillMode_t`) -- *IN*:
            [hipblasFillMode_t]
            HIPBLAS_FILL_MODE_UPPER: The upper triangular part of A is being supplied.
            HIPBLAS_FILL_MODE_LOWER: The lower triangular part of A is being supplied.

        n (`~.int`) -- *IN*:
            [int]
            the order of the matrix A.

        k (`~.int`) -- *IN*:
            [int]
            the number of super-diagonals of the matrix A. Must be >= 0.

        alpha (`~.hipblasComplex`/`~.object`) -- *IN*:
            device pointer or host pointer to scalar alpha.

        AP (`~.hipblasComplex`/`~.object`) -- *IN*:
            device pointer storing matrix A. Of dimension (lda, n).
            if uplo == HIPBLAS_FILL_MODE_UPPER:
              The leading (k + 1) by n part of A must contain the upper
              triangular band part of the Hermitian matrix, with the leading
              diagonal in row (k + 1), the first super-diagonal on the RHS
              of row k, etc.
              The top left k by x triangle of A will not be referenced.
                  Ex (upper, lda = n = 4, k = 1):
                  A                             Represented matrix
                  (0,0) (5,9) (6,8) (7,7)       (1, 0) (5, 9) (0, 0) (0, 0)
                  (1,0) (2,0) (3,0) (4,0)       (5,-9) (2, 0) (6, 8) (0, 0)
                  (0,0) (0,0) (0,0) (0,0)       (0, 0) (6,-8) (3, 0) (7, 7)
                  (0,0) (0,0) (0,0) (0,0)       (0, 0) (0, 0) (7,-7) (4, 0)

        lda (`~.int`) -- *IN*:
            [int]
            specifies the leading dimension of A. must be >= k + 1

        x (`~.hipblasComplex`/`~.object`) -- *IN*:
            device pointer storing vector x.

        incx (`~.int`) -- *IN*:
            [int]
            specifies the increment for the elements of x.

        beta (`~.hipblasComplex`/`~.object`) -- *IN*:
            device pointer or host pointer to scalar beta.

        y (`~.hipblasComplex`/`~.object`) -- *INOUT*:
            device pointer storing vector y.

        incy (`~.int`) -- *IN*:
            [int]
            specifies the increment for the elements of y.
    """
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")
    _hipblasChbmv__retval = hipblasStatus_t(chipblas.hipblasChbmv(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,uplo.value,n,k,
        hipblasComplex.fromPyobj(alpha).getElementPtr(),
        hipblasComplex.fromPyobj(AP).getElementPtr(),lda,
        hipblasComplex.fromPyobj(x).getElementPtr(),incx,
        hipblasComplex.fromPyobj(beta).getElementPtr(),
        hipblasComplex.fromPyobj(y).getElementPtr(),incy))
    return (_hipblasChbmv__retval,)


@cython.embedsignature(True)
def hipblasZhbmv(object handle, object uplo, int n, int k, object alpha, object AP, int lda, object x, int incx, object beta, object y, int incy):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        uplo (`~.hipblasFillMode_t`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        k (`~.int`):
            (undocumented)

        alpha (`~.hipblasDoubleComplex`/`~.object`):
            (undocumented)

        AP (`~.hipblasDoubleComplex`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        x (`~.hipblasDoubleComplex`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        beta (`~.hipblasDoubleComplex`/`~.object`):
            (undocumented)

        y (`~.hipblasDoubleComplex`/`~.object`):
            (undocumented)

        incy (`~.int`):
            (undocumented)
    """
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")
    _hipblasZhbmv__retval = hipblasStatus_t(chipblas.hipblasZhbmv(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,uplo.value,n,k,
        hipblasDoubleComplex.fromPyobj(alpha).getElementPtr(),
        hipblasDoubleComplex.fromPyobj(AP).getElementPtr(),lda,
        hipblasDoubleComplex.fromPyobj(x).getElementPtr(),incx,
        hipblasDoubleComplex.fromPyobj(beta).getElementPtr(),
        hipblasDoubleComplex.fromPyobj(y).getElementPtr(),incy))
    return (_hipblasZhbmv__retval,)


@cython.embedsignature(True)
def hipblasChbmv_v2(object handle, object uplo, int n, int k, object alpha, object AP, int lda, object x, int incx, object beta, object y, int incy):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        uplo (`~.hipblasFillMode_t`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        k (`~.int`):
            (undocumented)

        alpha (`~.float2`/`~.object`):
            (undocumented)

        AP (`~.float2`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        x (`~.float2`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        beta (`~.float2`/`~.object`):
            (undocumented)

        y (`~.float2`/`~.object`):
            (undocumented)

        incy (`~.int`):
            (undocumented)
    """
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")
    _hipblasChbmv_v2__retval = hipblasStatus_t(chipblas.hipblasChbmv_v2(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,uplo.value,n,k,
        float2.fromPyobj(alpha).getElementPtr(),
        float2.fromPyobj(AP).getElementPtr(),lda,
        float2.fromPyobj(x).getElementPtr(),incx,
        float2.fromPyobj(beta).getElementPtr(),
        float2.fromPyobj(y).getElementPtr(),incy))
    return (_hipblasChbmv_v2__retval,)


@cython.embedsignature(True)
def hipblasZhbmv_v2(object handle, object uplo, int n, int k, object alpha, object AP, int lda, object x, int incx, object beta, object y, int incy):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        uplo (`~.hipblasFillMode_t`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        k (`~.int`):
            (undocumented)

        alpha (`~.double2`/`~.object`):
            (undocumented)

        AP (`~.double2`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        x (`~.double2`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        beta (`~.double2`/`~.object`):
            (undocumented)

        y (`~.double2`/`~.object`):
            (undocumented)

        incy (`~.int`):
            (undocumented)
    """
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")
    _hipblasZhbmv_v2__retval = hipblasStatus_t(chipblas.hipblasZhbmv_v2(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,uplo.value,n,k,
        double2.fromPyobj(alpha).getElementPtr(),
        double2.fromPyobj(AP).getElementPtr(),lda,
        double2.fromPyobj(x).getElementPtr(),incx,
        double2.fromPyobj(beta).getElementPtr(),
        double2.fromPyobj(y).getElementPtr(),incy))
    return (_hipblasZhbmv_v2__retval,)


@cython.embedsignature(True)
def hipblasChbmv_64(object handle, object uplo, long n, long k, object alpha, object AP, long lda, object x, long incx, object beta, object y, long incy):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        uplo (`~.hipblasFillMode_t`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        k (`~.int`):
            (undocumented)

        alpha (`~.hipblasComplex`/`~.object`):
            (undocumented)

        AP (`~.hipblasComplex`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        x (`~.hipblasComplex`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        beta (`~.hipblasComplex`/`~.object`):
            (undocumented)

        y (`~.hipblasComplex`/`~.object`):
            (undocumented)

        incy (`~.int`):
            (undocumented)
    """
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")
    _hipblasChbmv_64__retval = hipblasStatus_t(chipblas.hipblasChbmv_64(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,uplo.value,n,k,
        hipblasComplex.fromPyobj(alpha).getElementPtr(),
        hipblasComplex.fromPyobj(AP).getElementPtr(),lda,
        hipblasComplex.fromPyobj(x).getElementPtr(),incx,
        hipblasComplex.fromPyobj(beta).getElementPtr(),
        hipblasComplex.fromPyobj(y).getElementPtr(),incy))
    return (_hipblasChbmv_64__retval,)


@cython.embedsignature(True)
def hipblasZhbmv_64(object handle, object uplo, long n, long k, object alpha, object AP, long lda, object x, long incx, object beta, object y, long incy):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        uplo (`~.hipblasFillMode_t`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        k (`~.int`):
            (undocumented)

        alpha (`~.hipblasDoubleComplex`/`~.object`):
            (undocumented)

        AP (`~.hipblasDoubleComplex`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        x (`~.hipblasDoubleComplex`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        beta (`~.hipblasDoubleComplex`/`~.object`):
            (undocumented)

        y (`~.hipblasDoubleComplex`/`~.object`):
            (undocumented)

        incy (`~.int`):
            (undocumented)
    """
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")
    _hipblasZhbmv_64__retval = hipblasStatus_t(chipblas.hipblasZhbmv_64(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,uplo.value,n,k,
        hipblasDoubleComplex.fromPyobj(alpha).getElementPtr(),
        hipblasDoubleComplex.fromPyobj(AP).getElementPtr(),lda,
        hipblasDoubleComplex.fromPyobj(x).getElementPtr(),incx,
        hipblasDoubleComplex.fromPyobj(beta).getElementPtr(),
        hipblasDoubleComplex.fromPyobj(y).getElementPtr(),incy))
    return (_hipblasZhbmv_64__retval,)


@cython.embedsignature(True)
def hipblasChbmv_v2_64(object handle, object uplo, long n, long k, object alpha, object AP, long lda, object x, long incx, object beta, object y, long incy):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        uplo (`~.hipblasFillMode_t`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        k (`~.int`):
            (undocumented)

        alpha (`~.float2`/`~.object`):
            (undocumented)

        AP (`~.float2`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        x (`~.float2`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        beta (`~.float2`/`~.object`):
            (undocumented)

        y (`~.float2`/`~.object`):
            (undocumented)

        incy (`~.int`):
            (undocumented)
    """
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")
    _hipblasChbmv_v2_64__retval = hipblasStatus_t(chipblas.hipblasChbmv_v2_64(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,uplo.value,n,k,
        float2.fromPyobj(alpha).getElementPtr(),
        float2.fromPyobj(AP).getElementPtr(),lda,
        float2.fromPyobj(x).getElementPtr(),incx,
        float2.fromPyobj(beta).getElementPtr(),
        float2.fromPyobj(y).getElementPtr(),incy))
    return (_hipblasChbmv_v2_64__retval,)


@cython.embedsignature(True)
def hipblasZhbmv_v2_64(object handle, object uplo, long n, long k, object alpha, object AP, long lda, object x, long incx, object beta, object y, long incy):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        uplo (`~.hipblasFillMode_t`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        k (`~.int`):
            (undocumented)

        alpha (`~.double2`/`~.object`):
            (undocumented)

        AP (`~.double2`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        x (`~.double2`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        beta (`~.double2`/`~.object`):
            (undocumented)

        y (`~.double2`/`~.object`):
            (undocumented)

        incy (`~.int`):
            (undocumented)
    """
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")
    _hipblasZhbmv_v2_64__retval = hipblasStatus_t(chipblas.hipblasZhbmv_v2_64(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,uplo.value,n,k,
        double2.fromPyobj(alpha).getElementPtr(),
        double2.fromPyobj(AP).getElementPtr(),lda,
        double2.fromPyobj(x).getElementPtr(),incx,
        double2.fromPyobj(beta).getElementPtr(),
        double2.fromPyobj(y).getElementPtr(),incy))
    return (_hipblasZhbmv_v2_64__retval,)


@cython.embedsignature(True)
def hipblasChbmvBatched(object handle, object uplo, int n, int k, object alpha, object AP, int lda, object x, int incx, object beta, object y, int incy, int batchCount):
    r"""BLAS Level 2 API

    @{

    hbmvBatched performs one of the matrix-vector operations

    y_i := alpha*A_i*x_i + beta*y_i

    where alpha and beta are scalars, x_i and y_i are n element vectors and A_i is an
    n by n Hermitian band matrix with k super-diagonals, for each batch in i = [1, batchCount].

    - Supported precisions in rocBLAS : c,z
    - Supported precisions in cuBLAS  : No support

    if uplo == HIPBLAS_FILL_MODE_LOWER:
      The leading (k + 1) by n part of each A_i must contain the lower
      triangular band part of the Hermitian matrix, with the leading
      diagonal in row (1), the first sub-diagonal on the LHS of
      row 2, etc.
      The bottom right k by k triangle of each A_i will not be referenced.
          Ex (lower, lda = 2, n = 4, k = 1):
          A                               Represented matrix
          (1,0) (2,0) (3,0) (4,0)         (1, 0) (5,-9) (0, 0) (0, 0)
          (5,9) (6,8) (7,7) (0,0)         (5, 9) (2, 0) (6,-8) (0, 0)
                                          (0, 0) (6, 8) (3, 0) (7,-7)
                                          (0, 0) (0, 0) (7, 7) (4, 0)

    As a Hermitian matrix, the imaginary part of the main diagonal
    of each A_i will not be referenced and is assumed to be == 0.

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`) -- *IN*:
            [hipblasHandle_t]
            handle to the hipblas library context queue.

        uplo (`~.hipblasFillMode_t`) -- *IN*:
            [hipblasFillMode_t]
            HIPBLAS_FILL_MODE_UPPER: The upper triangular part of each A_i is being supplied.
            HIPBLAS_FILL_MODE_LOWER: The lower triangular part of each A_i is being supplied.

        n (`~.int`) -- *IN*:
            [int]
            the order of each matrix A_i.

        k (`~.int`) -- *IN*:
            [int]
            the number of super-diagonals of each matrix A_i. Must be >= 0.

        alpha (`~.hipblasComplex`/`~.object`) -- *IN*:
            device pointer or host pointer to scalar alpha.

        AP (`~.hip._util.types.Pointer`/`~.object`) -- *IN*:
            device array of device pointers storing each matrix_i A of dimension (lda, n).
            if uplo == HIPBLAS_FILL_MODE_UPPER:
              The leading (k + 1) by n part of each A_i must contain the upper
              triangular band part of the Hermitian matrix, with the leading
              diagonal in row (k + 1), the first super-diagonal on the RHS
              of row k, etc.
              The top left k by x triangle of each A_i will not be referenced.
                  Ex (upper, lda = n = 4, k = 1):
                  A                             Represented matrix
                  (0,0) (5,9) (6,8) (7,7)       (1, 0) (5, 9) (0, 0) (0, 0)
                  (1,0) (2,0) (3,0) (4,0)       (5,-9) (2, 0) (6, 8) (0, 0)
                  (0,0) (0,0) (0,0) (0,0)       (0, 0) (6,-8) (3, 0) (7, 7)
                  (0,0) (0,0) (0,0) (0,0)       (0, 0) (0, 0) (7,-7) (4, 0)

        lda (`~.int`) -- *IN*:
            [int]
            specifies the leading dimension of each A_i. must be >= max(1, n)

        x (`~.hip._util.types.Pointer`/`~.object`) -- *IN*:
            device array of device pointers storing each vector x_i.

        incx (`~.int`) -- *IN*:
            [int]
            specifies the increment for the elements of each x_i.

        beta (`~.hipblasComplex`/`~.object`) -- *IN*:
            device pointer or host pointer to scalar beta.

        y (`~.hip._util.types.Pointer`/`~.object`) -- *INOUT*:
            device array of device pointers storing each vector y_i.

        incy (`~.int`) -- *IN*:
            [int]
            specifies the increment for the elements of y.

        batchCount (`~.int`) -- *IN*:
            [int]
            number of instances in the batch.
    """
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")
    _hipblasChbmvBatched__retval = hipblasStatus_t(chipblas.hipblasChbmvBatched(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,uplo.value,n,k,
        hipblasComplex.fromPyobj(alpha).getElementPtr(),
        <chipblas.hipblasComplex *const*>hip._util.types.Pointer.fromPyobj(AP)._ptr,lda,
        <chipblas.hipblasComplex *const*>hip._util.types.Pointer.fromPyobj(x)._ptr,incx,
        hipblasComplex.fromPyobj(beta).getElementPtr(),
        <chipblas.hipblasComplex *const*>hip._util.types.Pointer.fromPyobj(y)._ptr,incy,batchCount))
    return (_hipblasChbmvBatched__retval,)


@cython.embedsignature(True)
def hipblasZhbmvBatched(object handle, object uplo, int n, int k, object alpha, object AP, int lda, object x, int incx, object beta, object y, int incy, int batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        uplo (`~.hipblasFillMode_t`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        k (`~.int`):
            (undocumented)

        alpha (`~.hipblasDoubleComplex`/`~.object`):
            (undocumented)

        AP (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        x (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        beta (`~.hipblasDoubleComplex`/`~.object`):
            (undocumented)

        y (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        incy (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")
    _hipblasZhbmvBatched__retval = hipblasStatus_t(chipblas.hipblasZhbmvBatched(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,uplo.value,n,k,
        hipblasDoubleComplex.fromPyobj(alpha).getElementPtr(),
        <chipblas.hipblasDoubleComplex *const*>hip._util.types.Pointer.fromPyobj(AP)._ptr,lda,
        <chipblas.hipblasDoubleComplex *const*>hip._util.types.Pointer.fromPyobj(x)._ptr,incx,
        hipblasDoubleComplex.fromPyobj(beta).getElementPtr(),
        <chipblas.hipblasDoubleComplex *const*>hip._util.types.Pointer.fromPyobj(y)._ptr,incy,batchCount))
    return (_hipblasZhbmvBatched__retval,)


@cython.embedsignature(True)
def hipblasChbmvBatched_v2(object handle, object uplo, int n, int k, object alpha, object AP, int lda, object x, int incx, object beta, object y, int incy, int batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        uplo (`~.hipblasFillMode_t`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        k (`~.int`):
            (undocumented)

        alpha (`~.float2`/`~.object`):
            (undocumented)

        AP (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        x (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        beta (`~.float2`/`~.object`):
            (undocumented)

        y (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        incy (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")
    _hipblasChbmvBatched_v2__retval = hipblasStatus_t(chipblas.hipblasChbmvBatched_v2(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,uplo.value,n,k,
        float2.fromPyobj(alpha).getElementPtr(),
        <chipblas.float2 *const*>hip._util.types.Pointer.fromPyobj(AP)._ptr,lda,
        <chipblas.float2 *const*>hip._util.types.Pointer.fromPyobj(x)._ptr,incx,
        float2.fromPyobj(beta).getElementPtr(),
        <chipblas.float2 *const*>hip._util.types.Pointer.fromPyobj(y)._ptr,incy,batchCount))
    return (_hipblasChbmvBatched_v2__retval,)


@cython.embedsignature(True)
def hipblasZhbmvBatched_v2(object handle, object uplo, int n, int k, object alpha, object AP, int lda, object x, int incx, object beta, object y, int incy, int batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        uplo (`~.hipblasFillMode_t`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        k (`~.int`):
            (undocumented)

        alpha (`~.double2`/`~.object`):
            (undocumented)

        AP (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        x (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        beta (`~.double2`/`~.object`):
            (undocumented)

        y (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        incy (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")
    _hipblasZhbmvBatched_v2__retval = hipblasStatus_t(chipblas.hipblasZhbmvBatched_v2(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,uplo.value,n,k,
        double2.fromPyobj(alpha).getElementPtr(),
        <chipblas.double2 *const*>hip._util.types.Pointer.fromPyobj(AP)._ptr,lda,
        <chipblas.double2 *const*>hip._util.types.Pointer.fromPyobj(x)._ptr,incx,
        double2.fromPyobj(beta).getElementPtr(),
        <chipblas.double2 *const*>hip._util.types.Pointer.fromPyobj(y)._ptr,incy,batchCount))
    return (_hipblasZhbmvBatched_v2__retval,)


@cython.embedsignature(True)
def hipblasChbmvBatched_64(object handle, object uplo, long n, long k, object alpha, object AP, long lda, object x, long incx, object beta, object y, long incy, long batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        uplo (`~.hipblasFillMode_t`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        k (`~.int`):
            (undocumented)

        alpha (`~.hipblasComplex`/`~.object`):
            (undocumented)

        AP (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        x (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        beta (`~.hipblasComplex`/`~.object`):
            (undocumented)

        y (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        incy (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")
    _hipblasChbmvBatched_64__retval = hipblasStatus_t(chipblas.hipblasChbmvBatched_64(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,uplo.value,n,k,
        hipblasComplex.fromPyobj(alpha).getElementPtr(),
        <chipblas.hipblasComplex *const*>hip._util.types.Pointer.fromPyobj(AP)._ptr,lda,
        <chipblas.hipblasComplex *const*>hip._util.types.Pointer.fromPyobj(x)._ptr,incx,
        hipblasComplex.fromPyobj(beta).getElementPtr(),
        <chipblas.hipblasComplex *const*>hip._util.types.Pointer.fromPyobj(y)._ptr,incy,batchCount))
    return (_hipblasChbmvBatched_64__retval,)


@cython.embedsignature(True)
def hipblasZhbmvBatched_64(object handle, object uplo, long n, long k, object alpha, object AP, long lda, object x, long incx, object beta, object y, long incy, long batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        uplo (`~.hipblasFillMode_t`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        k (`~.int`):
            (undocumented)

        alpha (`~.hipblasDoubleComplex`/`~.object`):
            (undocumented)

        AP (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        x (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        beta (`~.hipblasDoubleComplex`/`~.object`):
            (undocumented)

        y (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        incy (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")
    _hipblasZhbmvBatched_64__retval = hipblasStatus_t(chipblas.hipblasZhbmvBatched_64(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,uplo.value,n,k,
        hipblasDoubleComplex.fromPyobj(alpha).getElementPtr(),
        <chipblas.hipblasDoubleComplex *const*>hip._util.types.Pointer.fromPyobj(AP)._ptr,lda,
        <chipblas.hipblasDoubleComplex *const*>hip._util.types.Pointer.fromPyobj(x)._ptr,incx,
        hipblasDoubleComplex.fromPyobj(beta).getElementPtr(),
        <chipblas.hipblasDoubleComplex *const*>hip._util.types.Pointer.fromPyobj(y)._ptr,incy,batchCount))
    return (_hipblasZhbmvBatched_64__retval,)


@cython.embedsignature(True)
def hipblasChbmvBatched_v2_64(object handle, object uplo, long n, long k, object alpha, object AP, long lda, object x, long incx, object beta, object y, long incy, long batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        uplo (`~.hipblasFillMode_t`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        k (`~.int`):
            (undocumented)

        alpha (`~.float2`/`~.object`):
            (undocumented)

        AP (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        x (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        beta (`~.float2`/`~.object`):
            (undocumented)

        y (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        incy (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")
    _hipblasChbmvBatched_v2_64__retval = hipblasStatus_t(chipblas.hipblasChbmvBatched_v2_64(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,uplo.value,n,k,
        float2.fromPyobj(alpha).getElementPtr(),
        <chipblas.float2 *const*>hip._util.types.Pointer.fromPyobj(AP)._ptr,lda,
        <chipblas.float2 *const*>hip._util.types.Pointer.fromPyobj(x)._ptr,incx,
        float2.fromPyobj(beta).getElementPtr(),
        <chipblas.float2 *const*>hip._util.types.Pointer.fromPyobj(y)._ptr,incy,batchCount))
    return (_hipblasChbmvBatched_v2_64__retval,)


@cython.embedsignature(True)
def hipblasZhbmvBatched_v2_64(object handle, object uplo, long n, long k, object alpha, object AP, long lda, object x, long incx, object beta, object y, long incy, long batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        uplo (`~.hipblasFillMode_t`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        k (`~.int`):
            (undocumented)

        alpha (`~.double2`/`~.object`):
            (undocumented)

        AP (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        x (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        beta (`~.double2`/`~.object`):
            (undocumented)

        y (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        incy (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")
    _hipblasZhbmvBatched_v2_64__retval = hipblasStatus_t(chipblas.hipblasZhbmvBatched_v2_64(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,uplo.value,n,k,
        double2.fromPyobj(alpha).getElementPtr(),
        <chipblas.double2 *const*>hip._util.types.Pointer.fromPyobj(AP)._ptr,lda,
        <chipblas.double2 *const*>hip._util.types.Pointer.fromPyobj(x)._ptr,incx,
        double2.fromPyobj(beta).getElementPtr(),
        <chipblas.double2 *const*>hip._util.types.Pointer.fromPyobj(y)._ptr,incy,batchCount))
    return (_hipblasZhbmvBatched_v2_64__retval,)


@cython.embedsignature(True)
def hipblasChbmvStridedBatched(object handle, object uplo, int n, int k, object alpha, object AP, int lda, long strideA, object x, int incx, long stridex, object beta, object y, int incy, long stridey, int batchCount):
    r"""BLAS Level 2 API

    @{

    hbmvStridedBatched performs one of the matrix-vector operations

    y_i := alpha*A_i*x_i + beta*y_i

    where alpha and beta are scalars, x_i and y_i are n element vectors and A_i is an
    n by n Hermitian band matrix with k super-diagonals, for each batch in i = [1, batchCount].

    - Supported precisions in rocBLAS : c,z
    - Supported precisions in cuBLAS  : No support

    if uplo == HIPBLAS_FILL_MODE_LOWER:
      The leading (k + 1) by n part of each A_i must contain the lower
      triangular band part of the Hermitian matrix, with the leading
      diagonal in row (1), the first sub-diagonal on the LHS of
      row 2, etc.
      The bottom right k by k triangle of each A_i will not be referenced.
          Ex (lower, lda = 2, n = 4, k = 1):
          A                               Represented matrix
          (1,0) (2,0) (3,0) (4,0)         (1, 0) (5,-9) (0, 0) (0, 0)
          (5,9) (6,8) (7,7) (0,0)         (5, 9) (2, 0) (6,-8) (0, 0)
                                          (0, 0) (6, 8) (3, 0) (7,-7)
                                          (0, 0) (0, 0) (7, 7) (4, 0)

    As a Hermitian matrix, the imaginary part of the main diagonal
    of each A_i will not be referenced and is assumed to be == 0.

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`) -- *IN*:
            [hipblasHandle_t]
            handle to the hipblas library context queue.

        uplo (`~.hipblasFillMode_t`) -- *IN*:
            [hipblasFillMode_t]
            HIPBLAS_FILL_MODE_UPPER: The upper triangular part of each A_i is being supplied.
            HIPBLAS_FILL_MODE_LOWER: The lower triangular part of each A_i is being supplied.

        n (`~.int`) -- *IN*:
            [int]
            the order of each matrix A_i.

        k (`~.int`) -- *IN*:
            [int]
            the number of super-diagonals of each matrix A_i. Must be >= 0.

        alpha (`~.hipblasComplex`/`~.object`) -- *IN*:
            device pointer or host pointer to scalar alpha.

        AP (`~.hipblasComplex`/`~.object`) -- *IN*:
            device array pointing to the first matrix A_1. Each A_i is of dimension (lda, n).
            if uplo == HIPBLAS_FILL_MODE_UPPER:
              The leading (k + 1) by n part of each A_i must contain the upper
              triangular band part of the Hermitian matrix, with the leading
              diagonal in row (k + 1), the first super-diagonal on the RHS
              of row k, etc.
              The top left k by x triangle of each A_i will not be referenced.
                  Ex (upper, lda = n = 4, k = 1):
                  A                             Represented matrix
                  (0,0) (5,9) (6,8) (7,7)       (1, 0) (5, 9) (0, 0) (0, 0)
                  (1,0) (2,0) (3,0) (4,0)       (5,-9) (2, 0) (6, 8) (0, 0)
                  (0,0) (0,0) (0,0) (0,0)       (0, 0) (6,-8) (3, 0) (7, 7)
                  (0,0) (0,0) (0,0) (0,0)       (0, 0) (0, 0) (7,-7) (4, 0)

        lda (`~.int`) -- *IN*:
            [int]
            specifies the leading dimension of each A_i. must be >= max(1, n)

        strideA (`~.int`) -- *IN*:
            [hipblasStride]
            stride from the start of one matrix (A_i) and the next one (A_i+1)

        x (`~.hipblasComplex`/`~.object`) -- *IN*:
            device array pointing to the first vector y_1.

        incx (`~.int`) -- *IN*:
            [int]
            specifies the increment for the elements of each x_i.

        stridex (`~.int`) -- *IN*:
            [hipblasStride]
            stride from the start of one vector (x_i) and the next one (x_i+1)

        beta (`~.hipblasComplex`/`~.object`) -- *IN*:
            device pointer or host pointer to scalar beta.

        y (`~.hipblasComplex`/`~.object`) -- *INOUT*:
            device array pointing to the first vector y_1.

        incy (`~.int`) -- *IN*:
            [int]
            specifies the increment for the elements of y.

        stridey (`~.int`) -- *IN*:
            [hipblasStride]
            stride from the start of one vector (y_i) and the next one (y_i+1)

        batchCount (`~.int`) -- *IN*:
            [int]
            number of instances in the batch.
    """
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")
    _hipblasChbmvStridedBatched__retval = hipblasStatus_t(chipblas.hipblasChbmvStridedBatched(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,uplo.value,n,k,
        hipblasComplex.fromPyobj(alpha).getElementPtr(),
        hipblasComplex.fromPyobj(AP).getElementPtr(),lda,strideA,
        hipblasComplex.fromPyobj(x).getElementPtr(),incx,stridex,
        hipblasComplex.fromPyobj(beta).getElementPtr(),
        hipblasComplex.fromPyobj(y).getElementPtr(),incy,stridey,batchCount))
    return (_hipblasChbmvStridedBatched__retval,)


@cython.embedsignature(True)
def hipblasZhbmvStridedBatched(object handle, object uplo, int n, int k, object alpha, object AP, int lda, long strideA, object x, int incx, long stridex, object beta, object y, int incy, long stridey, int batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        uplo (`~.hipblasFillMode_t`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        k (`~.int`):
            (undocumented)

        alpha (`~.hipblasDoubleComplex`/`~.object`):
            (undocumented)

        AP (`~.hipblasDoubleComplex`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        strideA (`~.int`):
            (undocumented)

        x (`~.hipblasDoubleComplex`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        stridex (`~.int`):
            (undocumented)

        beta (`~.hipblasDoubleComplex`/`~.object`):
            (undocumented)

        y (`~.hipblasDoubleComplex`/`~.object`):
            (undocumented)

        incy (`~.int`):
            (undocumented)

        stridey (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")
    _hipblasZhbmvStridedBatched__retval = hipblasStatus_t(chipblas.hipblasZhbmvStridedBatched(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,uplo.value,n,k,
        hipblasDoubleComplex.fromPyobj(alpha).getElementPtr(),
        hipblasDoubleComplex.fromPyobj(AP).getElementPtr(),lda,strideA,
        hipblasDoubleComplex.fromPyobj(x).getElementPtr(),incx,stridex,
        hipblasDoubleComplex.fromPyobj(beta).getElementPtr(),
        hipblasDoubleComplex.fromPyobj(y).getElementPtr(),incy,stridey,batchCount))
    return (_hipblasZhbmvStridedBatched__retval,)


@cython.embedsignature(True)
def hipblasChbmvStridedBatched_v2(object handle, object uplo, int n, int k, object alpha, object AP, int lda, long strideA, object x, int incx, long stridex, object beta, object y, int incy, long stridey, int batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        uplo (`~.hipblasFillMode_t`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        k (`~.int`):
            (undocumented)

        alpha (`~.float2`/`~.object`):
            (undocumented)

        AP (`~.float2`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        strideA (`~.int`):
            (undocumented)

        x (`~.float2`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        stridex (`~.int`):
            (undocumented)

        beta (`~.float2`/`~.object`):
            (undocumented)

        y (`~.float2`/`~.object`):
            (undocumented)

        incy (`~.int`):
            (undocumented)

        stridey (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")
    _hipblasChbmvStridedBatched_v2__retval = hipblasStatus_t(chipblas.hipblasChbmvStridedBatched_v2(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,uplo.value,n,k,
        float2.fromPyobj(alpha).getElementPtr(),
        float2.fromPyobj(AP).getElementPtr(),lda,strideA,
        float2.fromPyobj(x).getElementPtr(),incx,stridex,
        float2.fromPyobj(beta).getElementPtr(),
        float2.fromPyobj(y).getElementPtr(),incy,stridey,batchCount))
    return (_hipblasChbmvStridedBatched_v2__retval,)


@cython.embedsignature(True)
def hipblasZhbmvStridedBatched_v2(object handle, object uplo, int n, int k, object alpha, object AP, int lda, long strideA, object x, int incx, long stridex, object beta, object y, int incy, long stridey, int batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        uplo (`~.hipblasFillMode_t`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        k (`~.int`):
            (undocumented)

        alpha (`~.double2`/`~.object`):
            (undocumented)

        AP (`~.double2`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        strideA (`~.int`):
            (undocumented)

        x (`~.double2`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        stridex (`~.int`):
            (undocumented)

        beta (`~.double2`/`~.object`):
            (undocumented)

        y (`~.double2`/`~.object`):
            (undocumented)

        incy (`~.int`):
            (undocumented)

        stridey (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")
    _hipblasZhbmvStridedBatched_v2__retval = hipblasStatus_t(chipblas.hipblasZhbmvStridedBatched_v2(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,uplo.value,n,k,
        double2.fromPyobj(alpha).getElementPtr(),
        double2.fromPyobj(AP).getElementPtr(),lda,strideA,
        double2.fromPyobj(x).getElementPtr(),incx,stridex,
        double2.fromPyobj(beta).getElementPtr(),
        double2.fromPyobj(y).getElementPtr(),incy,stridey,batchCount))
    return (_hipblasZhbmvStridedBatched_v2__retval,)


@cython.embedsignature(True)
def hipblasChbmvStridedBatched_64(object handle, object uplo, long n, long k, object alpha, object AP, long lda, long strideA, object x, long incx, long stridex, object beta, object y, long incy, long stridey, long batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        uplo (`~.hipblasFillMode_t`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        k (`~.int`):
            (undocumented)

        alpha (`~.hipblasComplex`/`~.object`):
            (undocumented)

        AP (`~.hipblasComplex`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        strideA (`~.int`):
            (undocumented)

        x (`~.hipblasComplex`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        stridex (`~.int`):
            (undocumented)

        beta (`~.hipblasComplex`/`~.object`):
            (undocumented)

        y (`~.hipblasComplex`/`~.object`):
            (undocumented)

        incy (`~.int`):
            (undocumented)

        stridey (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")
    _hipblasChbmvStridedBatched_64__retval = hipblasStatus_t(chipblas.hipblasChbmvStridedBatched_64(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,uplo.value,n,k,
        hipblasComplex.fromPyobj(alpha).getElementPtr(),
        hipblasComplex.fromPyobj(AP).getElementPtr(),lda,strideA,
        hipblasComplex.fromPyobj(x).getElementPtr(),incx,stridex,
        hipblasComplex.fromPyobj(beta).getElementPtr(),
        hipblasComplex.fromPyobj(y).getElementPtr(),incy,stridey,batchCount))
    return (_hipblasChbmvStridedBatched_64__retval,)


@cython.embedsignature(True)
def hipblasZhbmvStridedBatched_64(object handle, object uplo, long n, long k, object alpha, object AP, long lda, long strideA, object x, long incx, long stridex, object beta, object y, long incy, long stridey, long batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        uplo (`~.hipblasFillMode_t`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        k (`~.int`):
            (undocumented)

        alpha (`~.hipblasDoubleComplex`/`~.object`):
            (undocumented)

        AP (`~.hipblasDoubleComplex`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        strideA (`~.int`):
            (undocumented)

        x (`~.hipblasDoubleComplex`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        stridex (`~.int`):
            (undocumented)

        beta (`~.hipblasDoubleComplex`/`~.object`):
            (undocumented)

        y (`~.hipblasDoubleComplex`/`~.object`):
            (undocumented)

        incy (`~.int`):
            (undocumented)

        stridey (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")
    _hipblasZhbmvStridedBatched_64__retval = hipblasStatus_t(chipblas.hipblasZhbmvStridedBatched_64(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,uplo.value,n,k,
        hipblasDoubleComplex.fromPyobj(alpha).getElementPtr(),
        hipblasDoubleComplex.fromPyobj(AP).getElementPtr(),lda,strideA,
        hipblasDoubleComplex.fromPyobj(x).getElementPtr(),incx,stridex,
        hipblasDoubleComplex.fromPyobj(beta).getElementPtr(),
        hipblasDoubleComplex.fromPyobj(y).getElementPtr(),incy,stridey,batchCount))
    return (_hipblasZhbmvStridedBatched_64__retval,)


@cython.embedsignature(True)
def hipblasChbmvStridedBatched_v2_64(object handle, object uplo, long n, long k, object alpha, object AP, long lda, long strideA, object x, long incx, long stridex, object beta, object y, long incy, long stridey, long batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        uplo (`~.hipblasFillMode_t`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        k (`~.int`):
            (undocumented)

        alpha (`~.float2`/`~.object`):
            (undocumented)

        AP (`~.float2`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        strideA (`~.int`):
            (undocumented)

        x (`~.float2`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        stridex (`~.int`):
            (undocumented)

        beta (`~.float2`/`~.object`):
            (undocumented)

        y (`~.float2`/`~.object`):
            (undocumented)

        incy (`~.int`):
            (undocumented)

        stridey (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")
    _hipblasChbmvStridedBatched_v2_64__retval = hipblasStatus_t(chipblas.hipblasChbmvStridedBatched_v2_64(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,uplo.value,n,k,
        float2.fromPyobj(alpha).getElementPtr(),
        float2.fromPyobj(AP).getElementPtr(),lda,strideA,
        float2.fromPyobj(x).getElementPtr(),incx,stridex,
        float2.fromPyobj(beta).getElementPtr(),
        float2.fromPyobj(y).getElementPtr(),incy,stridey,batchCount))
    return (_hipblasChbmvStridedBatched_v2_64__retval,)


@cython.embedsignature(True)
def hipblasZhbmvStridedBatched_v2_64(object handle, object uplo, long n, long k, object alpha, object AP, long lda, long strideA, object x, long incx, long stridex, object beta, object y, long incy, long stridey, long batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        uplo (`~.hipblasFillMode_t`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        k (`~.int`):
            (undocumented)

        alpha (`~.double2`/`~.object`):
            (undocumented)

        AP (`~.double2`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        strideA (`~.int`):
            (undocumented)

        x (`~.double2`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        stridex (`~.int`):
            (undocumented)

        beta (`~.double2`/`~.object`):
            (undocumented)

        y (`~.double2`/`~.object`):
            (undocumented)

        incy (`~.int`):
            (undocumented)

        stridey (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")
    _hipblasZhbmvStridedBatched_v2_64__retval = hipblasStatus_t(chipblas.hipblasZhbmvStridedBatched_v2_64(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,uplo.value,n,k,
        double2.fromPyobj(alpha).getElementPtr(),
        double2.fromPyobj(AP).getElementPtr(),lda,strideA,
        double2.fromPyobj(x).getElementPtr(),incx,stridex,
        double2.fromPyobj(beta).getElementPtr(),
        double2.fromPyobj(y).getElementPtr(),incy,stridey,batchCount))
    return (_hipblasZhbmvStridedBatched_v2_64__retval,)


@cython.embedsignature(True)
def hipblasChemv(object handle, object uplo, int n, object alpha, object AP, int lda, object x, int incx, object beta, object y, int incy):
    r"""BLAS Level 2 API

    @{

    hemv performs one of the matrix-vector operations

    y := alpha*A*x + beta*y

    where alpha and beta are scalars, x and y are n element vectors and A is an
    n by n Hermitian matrix.

    - Supported precisions in rocBLAS : c,z
    - Supported precisions in cuBLAS  : c,z

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`) -- *IN*:
            [hipblasHandle_t]
            handle to the hipblas library context queue.

        uplo (`~.hipblasFillMode_t`) -- *IN*:
            [hipblasFillMode_t]
            HIPBLAS_FILL_MODE_UPPER: the upper triangular part of the Hermitian matrix A is supplied.
            HIPBLAS_FILL_MODE_LOWER: the lower triangular part of the Hermitian matrix A is supplied.

        n (`~.int`) -- *IN*:
            [int]
            the order of the matrix A.

        alpha (`~.hipblasComplex`/`~.object`) -- *IN*:
            device pointer or host pointer to scalar alpha.

        AP (`~.hipblasComplex`/`~.object`) -- *IN*:
            device pointer storing matrix A. Of dimension (lda, n).
            if uplo == HIPBLAS_FILL_MODE_UPPER:
              The upper triangular part of A must contain
              the upper triangular part of a Hermitian matrix. The lower
              triangular part of A will not be referenced.
            if uplo == HIPBLAS_FILL_MODE_LOWER:
              The lower triangular part of A must contain
              the lower triangular part of a Hermitian matrix. The upper
              triangular part of A will not be referenced.
            As a Hermitian matrix, the imaginary part of the main diagonal
            of A will not be referenced and is assumed to be == 0.

        lda (`~.int`) -- *IN*:
            [int]
            specifies the leading dimension of A. must be >= max(1, n)

        x (`~.hipblasComplex`/`~.object`) -- *IN*:
            device pointer storing vector x.

        incx (`~.int`) -- *IN*:
            [int]
            specifies the increment for the elements of x.

        beta (`~.hipblasComplex`/`~.object`) -- *IN*:
            device pointer or host pointer to scalar beta.

        y (`~.hipblasComplex`/`~.object`) -- *INOUT*:
            device pointer storing vector y.

        incy (`~.int`) -- *IN*:
            [int]
            specifies the increment for the elements of y.
    """
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")
    _hipblasChemv__retval = hipblasStatus_t(chipblas.hipblasChemv(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,uplo.value,n,
        hipblasComplex.fromPyobj(alpha).getElementPtr(),
        hipblasComplex.fromPyobj(AP).getElementPtr(),lda,
        hipblasComplex.fromPyobj(x).getElementPtr(),incx,
        hipblasComplex.fromPyobj(beta).getElementPtr(),
        hipblasComplex.fromPyobj(y).getElementPtr(),incy))
    return (_hipblasChemv__retval,)


@cython.embedsignature(True)
def hipblasZhemv(object handle, object uplo, int n, object alpha, object AP, int lda, object x, int incx, object beta, object y, int incy):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        uplo (`~.hipblasFillMode_t`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        alpha (`~.hipblasDoubleComplex`/`~.object`):
            (undocumented)

        AP (`~.hipblasDoubleComplex`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        x (`~.hipblasDoubleComplex`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        beta (`~.hipblasDoubleComplex`/`~.object`):
            (undocumented)

        y (`~.hipblasDoubleComplex`/`~.object`):
            (undocumented)

        incy (`~.int`):
            (undocumented)
    """
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")
    _hipblasZhemv__retval = hipblasStatus_t(chipblas.hipblasZhemv(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,uplo.value,n,
        hipblasDoubleComplex.fromPyobj(alpha).getElementPtr(),
        hipblasDoubleComplex.fromPyobj(AP).getElementPtr(),lda,
        hipblasDoubleComplex.fromPyobj(x).getElementPtr(),incx,
        hipblasDoubleComplex.fromPyobj(beta).getElementPtr(),
        hipblasDoubleComplex.fromPyobj(y).getElementPtr(),incy))
    return (_hipblasZhemv__retval,)


@cython.embedsignature(True)
def hipblasChemv_v2(object handle, object uplo, int n, object alpha, object AP, int lda, object x, int incx, object beta, object y, int incy):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        uplo (`~.hipblasFillMode_t`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        alpha (`~.float2`/`~.object`):
            (undocumented)

        AP (`~.float2`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        x (`~.float2`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        beta (`~.float2`/`~.object`):
            (undocumented)

        y (`~.float2`/`~.object`):
            (undocumented)

        incy (`~.int`):
            (undocumented)
    """
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")
    _hipblasChemv_v2__retval = hipblasStatus_t(chipblas.hipblasChemv_v2(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,uplo.value,n,
        float2.fromPyobj(alpha).getElementPtr(),
        float2.fromPyobj(AP).getElementPtr(),lda,
        float2.fromPyobj(x).getElementPtr(),incx,
        float2.fromPyobj(beta).getElementPtr(),
        float2.fromPyobj(y).getElementPtr(),incy))
    return (_hipblasChemv_v2__retval,)


@cython.embedsignature(True)
def hipblasZhemv_v2(object handle, object uplo, int n, object alpha, object AP, int lda, object x, int incx, object beta, object y, int incy):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        uplo (`~.hipblasFillMode_t`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        alpha (`~.double2`/`~.object`):
            (undocumented)

        AP (`~.double2`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        x (`~.double2`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        beta (`~.double2`/`~.object`):
            (undocumented)

        y (`~.double2`/`~.object`):
            (undocumented)

        incy (`~.int`):
            (undocumented)
    """
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")
    _hipblasZhemv_v2__retval = hipblasStatus_t(chipblas.hipblasZhemv_v2(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,uplo.value,n,
        double2.fromPyobj(alpha).getElementPtr(),
        double2.fromPyobj(AP).getElementPtr(),lda,
        double2.fromPyobj(x).getElementPtr(),incx,
        double2.fromPyobj(beta).getElementPtr(),
        double2.fromPyobj(y).getElementPtr(),incy))
    return (_hipblasZhemv_v2__retval,)


@cython.embedsignature(True)
def hipblasChemv_64(object handle, object uplo, long n, object alpha, object AP, long lda, object x, long incx, object beta, object y, long incy):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        uplo (`~.hipblasFillMode_t`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        alpha (`~.hipblasComplex`/`~.object`):
            (undocumented)

        AP (`~.hipblasComplex`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        x (`~.hipblasComplex`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        beta (`~.hipblasComplex`/`~.object`):
            (undocumented)

        y (`~.hipblasComplex`/`~.object`):
            (undocumented)

        incy (`~.int`):
            (undocumented)
    """
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")
    _hipblasChemv_64__retval = hipblasStatus_t(chipblas.hipblasChemv_64(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,uplo.value,n,
        hipblasComplex.fromPyobj(alpha).getElementPtr(),
        hipblasComplex.fromPyobj(AP).getElementPtr(),lda,
        hipblasComplex.fromPyobj(x).getElementPtr(),incx,
        hipblasComplex.fromPyobj(beta).getElementPtr(),
        hipblasComplex.fromPyobj(y).getElementPtr(),incy))
    return (_hipblasChemv_64__retval,)


@cython.embedsignature(True)
def hipblasZhemv_64(object handle, object uplo, long n, object alpha, object AP, long lda, object x, long incx, object beta, object y, long incy):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        uplo (`~.hipblasFillMode_t`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        alpha (`~.hipblasDoubleComplex`/`~.object`):
            (undocumented)

        AP (`~.hipblasDoubleComplex`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        x (`~.hipblasDoubleComplex`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        beta (`~.hipblasDoubleComplex`/`~.object`):
            (undocumented)

        y (`~.hipblasDoubleComplex`/`~.object`):
            (undocumented)

        incy (`~.int`):
            (undocumented)
    """
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")
    _hipblasZhemv_64__retval = hipblasStatus_t(chipblas.hipblasZhemv_64(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,uplo.value,n,
        hipblasDoubleComplex.fromPyobj(alpha).getElementPtr(),
        hipblasDoubleComplex.fromPyobj(AP).getElementPtr(),lda,
        hipblasDoubleComplex.fromPyobj(x).getElementPtr(),incx,
        hipblasDoubleComplex.fromPyobj(beta).getElementPtr(),
        hipblasDoubleComplex.fromPyobj(y).getElementPtr(),incy))
    return (_hipblasZhemv_64__retval,)


@cython.embedsignature(True)
def hipblasChemv_v2_64(object handle, object uplo, long n, object alpha, object AP, long lda, object x, long incx, object beta, object y, long incy):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        uplo (`~.hipblasFillMode_t`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        alpha (`~.float2`/`~.object`):
            (undocumented)

        AP (`~.float2`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        x (`~.float2`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        beta (`~.float2`/`~.object`):
            (undocumented)

        y (`~.float2`/`~.object`):
            (undocumented)

        incy (`~.int`):
            (undocumented)
    """
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")
    _hipblasChemv_v2_64__retval = hipblasStatus_t(chipblas.hipblasChemv_v2_64(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,uplo.value,n,
        float2.fromPyobj(alpha).getElementPtr(),
        float2.fromPyobj(AP).getElementPtr(),lda,
        float2.fromPyobj(x).getElementPtr(),incx,
        float2.fromPyobj(beta).getElementPtr(),
        float2.fromPyobj(y).getElementPtr(),incy))
    return (_hipblasChemv_v2_64__retval,)


@cython.embedsignature(True)
def hipblasZhemv_v2_64(object handle, object uplo, long n, object alpha, object AP, long lda, object x, long incx, object beta, object y, long incy):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        uplo (`~.hipblasFillMode_t`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        alpha (`~.double2`/`~.object`):
            (undocumented)

        AP (`~.double2`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        x (`~.double2`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        beta (`~.double2`/`~.object`):
            (undocumented)

        y (`~.double2`/`~.object`):
            (undocumented)

        incy (`~.int`):
            (undocumented)
    """
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")
    _hipblasZhemv_v2_64__retval = hipblasStatus_t(chipblas.hipblasZhemv_v2_64(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,uplo.value,n,
        double2.fromPyobj(alpha).getElementPtr(),
        double2.fromPyobj(AP).getElementPtr(),lda,
        double2.fromPyobj(x).getElementPtr(),incx,
        double2.fromPyobj(beta).getElementPtr(),
        double2.fromPyobj(y).getElementPtr(),incy))
    return (_hipblasZhemv_v2_64__retval,)


@cython.embedsignature(True)
def hipblasChemvBatched(object handle, object uplo, int n, object alpha, object AP, int lda, object x, int incx, object beta, object y, int incy, int batchCount):
    r"""BLAS Level 2 API

    @{

    hemvBatched performs one of the matrix-vector operations

    y_i := alpha*A_i*x_i + beta*y_i

    where alpha and beta are scalars, x_i and y_i are n element vectors and A_i is an
    n by n Hermitian matrix, for each batch in i = [1, batchCount].

    - Supported precisions in rocBLAS : c,z
    - Supported precisions in cuBLAS  : No support

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`) -- *IN*:
            [hipblasHandle_t]
            handle to the hipblas library context queue.

        uplo (`~.hipblasFillMode_t`) -- *IN*:
            [hipblasFillMode_t]
            HIPBLAS_FILL_MODE_UPPER: the upper triangular part of the Hermitian matrix A is supplied.
            HIPBLAS_FILL_MODE_LOWER: the lower triangular part of the Hermitian matrix A is supplied.

        n (`~.int`) -- *IN*:
            [int]
            the order of each matrix A_i.

        alpha (`~.hipblasComplex`/`~.object`) -- *IN*:
            device pointer or host pointer to scalar alpha.

        AP (`~.hip._util.types.Pointer`/`~.object`) -- *IN*:
            device array of device pointers storing each matrix A_i of dimension (lda, n).
            if uplo == HIPBLAS_FILL_MODE_UPPER:
              The upper triangular part of each A_i must contain
              the upper triangular part of a Hermitian matrix. The lower
              triangular part of each A_i will not be referenced.
            if uplo == HIPBLAS_FILL_MODE_LOWER:
              The lower triangular part of each A_i must contain
              the lower triangular part of a Hermitian matrix. The upper
              triangular part of each A_i will not be referenced.
            As a Hermitian matrix, the imaginary part of the main diagonal
            of each A_i will not be referenced and is assumed to be == 0.

        lda (`~.int`) -- *IN*:
            [int]
            specifies the leading dimension of each A_i. must be >= max(1, n)

        x (`~.hip._util.types.Pointer`/`~.object`) -- *IN*:
            device array of device pointers storing each vector x_i.

        incx (`~.int`) -- *IN*:
            [int]
            specifies the increment for the elements of each x_i.

        beta (`~.hipblasComplex`/`~.object`) -- *IN*:
            device pointer or host pointer to scalar beta.

        y (`~.hip._util.types.Pointer`/`~.object`) -- *INOUT*:
            device array of device pointers storing each vector y_i.

        incy (`~.int`) -- *IN*:
            [int]
            specifies the increment for the elements of y.

        batchCount (`~.int`) -- *IN*:
            [int]
            number of instances in the batch.
    """
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")
    _hipblasChemvBatched__retval = hipblasStatus_t(chipblas.hipblasChemvBatched(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,uplo.value,n,
        hipblasComplex.fromPyobj(alpha).getElementPtr(),
        <chipblas.hipblasComplex *const*>hip._util.types.Pointer.fromPyobj(AP)._ptr,lda,
        <chipblas.hipblasComplex *const*>hip._util.types.Pointer.fromPyobj(x)._ptr,incx,
        hipblasComplex.fromPyobj(beta).getElementPtr(),
        <chipblas.hipblasComplex *const*>hip._util.types.Pointer.fromPyobj(y)._ptr,incy,batchCount))
    return (_hipblasChemvBatched__retval,)


@cython.embedsignature(True)
def hipblasZhemvBatched(object handle, object uplo, int n, object alpha, object AP, int lda, object x, int incx, object beta, object y, int incy, int batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        uplo (`~.hipblasFillMode_t`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        alpha (`~.hipblasDoubleComplex`/`~.object`):
            (undocumented)

        AP (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        x (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        beta (`~.hipblasDoubleComplex`/`~.object`):
            (undocumented)

        y (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        incy (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")
    _hipblasZhemvBatched__retval = hipblasStatus_t(chipblas.hipblasZhemvBatched(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,uplo.value,n,
        hipblasDoubleComplex.fromPyobj(alpha).getElementPtr(),
        <chipblas.hipblasDoubleComplex *const*>hip._util.types.Pointer.fromPyobj(AP)._ptr,lda,
        <chipblas.hipblasDoubleComplex *const*>hip._util.types.Pointer.fromPyobj(x)._ptr,incx,
        hipblasDoubleComplex.fromPyobj(beta).getElementPtr(),
        <chipblas.hipblasDoubleComplex *const*>hip._util.types.Pointer.fromPyobj(y)._ptr,incy,batchCount))
    return (_hipblasZhemvBatched__retval,)


@cython.embedsignature(True)
def hipblasChemvBatched_v2(object handle, object uplo, int n, object alpha, object AP, int lda, object x, int incx, object beta, object y, int incy, int batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        uplo (`~.hipblasFillMode_t`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        alpha (`~.float2`/`~.object`):
            (undocumented)

        AP (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        x (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        beta (`~.float2`/`~.object`):
            (undocumented)

        y (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        incy (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")
    _hipblasChemvBatched_v2__retval = hipblasStatus_t(chipblas.hipblasChemvBatched_v2(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,uplo.value,n,
        float2.fromPyobj(alpha).getElementPtr(),
        <chipblas.float2 *const*>hip._util.types.Pointer.fromPyobj(AP)._ptr,lda,
        <chipblas.float2 *const*>hip._util.types.Pointer.fromPyobj(x)._ptr,incx,
        float2.fromPyobj(beta).getElementPtr(),
        <chipblas.float2 *const*>hip._util.types.Pointer.fromPyobj(y)._ptr,incy,batchCount))
    return (_hipblasChemvBatched_v2__retval,)


@cython.embedsignature(True)
def hipblasZhemvBatched_v2(object handle, object uplo, int n, object alpha, object AP, int lda, object x, int incx, object beta, object y, int incy, int batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        uplo (`~.hipblasFillMode_t`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        alpha (`~.double2`/`~.object`):
            (undocumented)

        AP (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        x (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        beta (`~.double2`/`~.object`):
            (undocumented)

        y (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        incy (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")
    _hipblasZhemvBatched_v2__retval = hipblasStatus_t(chipblas.hipblasZhemvBatched_v2(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,uplo.value,n,
        double2.fromPyobj(alpha).getElementPtr(),
        <chipblas.double2 *const*>hip._util.types.Pointer.fromPyobj(AP)._ptr,lda,
        <chipblas.double2 *const*>hip._util.types.Pointer.fromPyobj(x)._ptr,incx,
        double2.fromPyobj(beta).getElementPtr(),
        <chipblas.double2 *const*>hip._util.types.Pointer.fromPyobj(y)._ptr,incy,batchCount))
    return (_hipblasZhemvBatched_v2__retval,)


@cython.embedsignature(True)
def hipblasChemvBatched_64(object handle, object uplo, long n, object alpha, object AP, long lda, object x, long incx, object beta, object y, long incy, long batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        uplo (`~.hipblasFillMode_t`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        alpha (`~.hipblasComplex`/`~.object`):
            (undocumented)

        AP (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        x (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        beta (`~.hipblasComplex`/`~.object`):
            (undocumented)

        y (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        incy (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")
    _hipblasChemvBatched_64__retval = hipblasStatus_t(chipblas.hipblasChemvBatched_64(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,uplo.value,n,
        hipblasComplex.fromPyobj(alpha).getElementPtr(),
        <chipblas.hipblasComplex *const*>hip._util.types.Pointer.fromPyobj(AP)._ptr,lda,
        <chipblas.hipblasComplex *const*>hip._util.types.Pointer.fromPyobj(x)._ptr,incx,
        hipblasComplex.fromPyobj(beta).getElementPtr(),
        <chipblas.hipblasComplex *const*>hip._util.types.Pointer.fromPyobj(y)._ptr,incy,batchCount))
    return (_hipblasChemvBatched_64__retval,)


@cython.embedsignature(True)
def hipblasZhemvBatched_64(object handle, object uplo, long n, object alpha, object AP, long lda, object x, long incx, object beta, object y, long incy, long batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        uplo (`~.hipblasFillMode_t`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        alpha (`~.hipblasDoubleComplex`/`~.object`):
            (undocumented)

        AP (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        x (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        beta (`~.hipblasDoubleComplex`/`~.object`):
            (undocumented)

        y (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        incy (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")
    _hipblasZhemvBatched_64__retval = hipblasStatus_t(chipblas.hipblasZhemvBatched_64(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,uplo.value,n,
        hipblasDoubleComplex.fromPyobj(alpha).getElementPtr(),
        <chipblas.hipblasDoubleComplex *const*>hip._util.types.Pointer.fromPyobj(AP)._ptr,lda,
        <chipblas.hipblasDoubleComplex *const*>hip._util.types.Pointer.fromPyobj(x)._ptr,incx,
        hipblasDoubleComplex.fromPyobj(beta).getElementPtr(),
        <chipblas.hipblasDoubleComplex *const*>hip._util.types.Pointer.fromPyobj(y)._ptr,incy,batchCount))
    return (_hipblasZhemvBatched_64__retval,)


@cython.embedsignature(True)
def hipblasChemvBatched_v2_64(object handle, object uplo, long n, object alpha, object AP, long lda, object x, long incx, object beta, object y, long incy, long batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        uplo (`~.hipblasFillMode_t`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        alpha (`~.float2`/`~.object`):
            (undocumented)

        AP (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        x (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        beta (`~.float2`/`~.object`):
            (undocumented)

        y (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        incy (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")
    _hipblasChemvBatched_v2_64__retval = hipblasStatus_t(chipblas.hipblasChemvBatched_v2_64(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,uplo.value,n,
        float2.fromPyobj(alpha).getElementPtr(),
        <chipblas.float2 *const*>hip._util.types.Pointer.fromPyobj(AP)._ptr,lda,
        <chipblas.float2 *const*>hip._util.types.Pointer.fromPyobj(x)._ptr,incx,
        float2.fromPyobj(beta).getElementPtr(),
        <chipblas.float2 *const*>hip._util.types.Pointer.fromPyobj(y)._ptr,incy,batchCount))
    return (_hipblasChemvBatched_v2_64__retval,)


@cython.embedsignature(True)
def hipblasZhemvBatched_v2_64(object handle, object uplo, long n, object alpha, object AP, long lda, object x, long incx, object beta, object y, long incy, long batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        uplo (`~.hipblasFillMode_t`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        alpha (`~.double2`/`~.object`):
            (undocumented)

        AP (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        x (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        beta (`~.double2`/`~.object`):
            (undocumented)

        y (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        incy (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")
    _hipblasZhemvBatched_v2_64__retval = hipblasStatus_t(chipblas.hipblasZhemvBatched_v2_64(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,uplo.value,n,
        double2.fromPyobj(alpha).getElementPtr(),
        <chipblas.double2 *const*>hip._util.types.Pointer.fromPyobj(AP)._ptr,lda,
        <chipblas.double2 *const*>hip._util.types.Pointer.fromPyobj(x)._ptr,incx,
        double2.fromPyobj(beta).getElementPtr(),
        <chipblas.double2 *const*>hip._util.types.Pointer.fromPyobj(y)._ptr,incy,batchCount))
    return (_hipblasZhemvBatched_v2_64__retval,)


@cython.embedsignature(True)
def hipblasChemvStridedBatched(object handle, object uplo, int n, object alpha, object AP, int lda, long strideA, object x, int incx, long stridex, object beta, object y, int incy, long stridey, int batchCount):
    r"""BLAS Level 2 API

    @{

    hemvStridedBatched performs one of the matrix-vector operations

    y_i := alpha*A_i*x_i + beta*y_i

    where alpha and beta are scalars, x_i and y_i are n element vectors and A_i is an
    n by n Hermitian matrix, for each batch in i = [1, batchCount].

    - Supported precisions in rocBLAS : c,z
    - Supported precisions in cuBLAS  : No support

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`) -- *IN*:
            [hipblasHandle_t]
            handle to the hipblas library context queue.

        uplo (`~.hipblasFillMode_t`) -- *IN*:
            [hipblasFillMode_t]
            HIPBLAS_FILL_MODE_UPPER: the upper triangular part of the Hermitian matrix A is supplied.
            HIPBLAS_FILL_MODE_LOWER: the lower triangular part of the Hermitian matrix A is supplied.

        n (`~.int`) -- *IN*:
            [int]
            the order of each matrix A_i.

        alpha (`~.hipblasComplex`/`~.object`) -- *IN*:
            device pointer or host pointer to scalar alpha.

        AP (`~.hipblasComplex`/`~.object`) -- *IN*:
            device array of device pointers storing each matrix A_i of dimension (lda, n).
            if uplo == HIPBLAS_FILL_MODE_UPPER:
              The upper triangular part of each A_i must contain
              the upper triangular part of a Hermitian matrix. The lower
              triangular part of each A_i will not be referenced.
            if uplo == HIPBLAS_FILL_MODE_LOWER:
              The lower triangular part of each A_i must contain
              the lower triangular part of a Hermitian matrix. The upper
              triangular part of each A_i will not be referenced.
            As a Hermitian matrix, the imaginary part of the main diagonal
            of each A_i will not be referenced and is assumed to be == 0.

        lda (`~.int`) -- *IN*:
            [int]
            specifies the leading dimension of each A_i. must be >= max(1, n)

        strideA (`~.int`) -- *IN*:
            [hipblasStride]
            stride from the start of one (A_i) to the next (A_i+1)

        x (`~.hipblasComplex`/`~.object`) -- *IN*:
            device array of device pointers storing each vector x_i.

        incx (`~.int`) -- *IN*:
            [int]
            specifies the increment for the elements of each x_i.

        stridex (`~.int`) -- *IN*:
            [hipblasStride]
            stride from the start of one vector (x_i) and the next one (x_i+1).

        beta (`~.hipblasComplex`/`~.object`) -- *IN*:
            device pointer or host pointer to scalar beta.

        y (`~.hipblasComplex`/`~.object`) -- *INOUT*:
            device array of device pointers storing each vector y_i.

        incy (`~.int`) -- *IN*:
            [int]
            specifies the increment for the elements of y.

        stridey (`~.int`) -- *IN*:
            [hipblasStride]
            stride from the start of one vector (y_i) and the next one (y_i+1).

        batchCount (`~.int`) -- *IN*:
            [int]
            number of instances in the batch.
    """
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")
    _hipblasChemvStridedBatched__retval = hipblasStatus_t(chipblas.hipblasChemvStridedBatched(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,uplo.value,n,
        hipblasComplex.fromPyobj(alpha).getElementPtr(),
        hipblasComplex.fromPyobj(AP).getElementPtr(),lda,strideA,
        hipblasComplex.fromPyobj(x).getElementPtr(),incx,stridex,
        hipblasComplex.fromPyobj(beta).getElementPtr(),
        hipblasComplex.fromPyobj(y).getElementPtr(),incy,stridey,batchCount))
    return (_hipblasChemvStridedBatched__retval,)


@cython.embedsignature(True)
def hipblasZhemvStridedBatched(object handle, object uplo, int n, object alpha, object AP, int lda, long strideA, object x, int incx, long stridex, object beta, object y, int incy, long stridey, int batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        uplo (`~.hipblasFillMode_t`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        alpha (`~.hipblasDoubleComplex`/`~.object`):
            (undocumented)

        AP (`~.hipblasDoubleComplex`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        strideA (`~.int`):
            (undocumented)

        x (`~.hipblasDoubleComplex`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        stridex (`~.int`):
            (undocumented)

        beta (`~.hipblasDoubleComplex`/`~.object`):
            (undocumented)

        y (`~.hipblasDoubleComplex`/`~.object`):
            (undocumented)

        incy (`~.int`):
            (undocumented)

        stridey (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")
    _hipblasZhemvStridedBatched__retval = hipblasStatus_t(chipblas.hipblasZhemvStridedBatched(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,uplo.value,n,
        hipblasDoubleComplex.fromPyobj(alpha).getElementPtr(),
        hipblasDoubleComplex.fromPyobj(AP).getElementPtr(),lda,strideA,
        hipblasDoubleComplex.fromPyobj(x).getElementPtr(),incx,stridex,
        hipblasDoubleComplex.fromPyobj(beta).getElementPtr(),
        hipblasDoubleComplex.fromPyobj(y).getElementPtr(),incy,stridey,batchCount))
    return (_hipblasZhemvStridedBatched__retval,)


@cython.embedsignature(True)
def hipblasChemvStridedBatched_v2(object handle, object uplo, int n, object alpha, object AP, int lda, long strideA, object x, int incx, long stridex, object beta, object y, int incy, long stridey, int batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        uplo (`~.hipblasFillMode_t`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        alpha (`~.float2`/`~.object`):
            (undocumented)

        AP (`~.float2`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        strideA (`~.int`):
            (undocumented)

        x (`~.float2`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        stridex (`~.int`):
            (undocumented)

        beta (`~.float2`/`~.object`):
            (undocumented)

        y (`~.float2`/`~.object`):
            (undocumented)

        incy (`~.int`):
            (undocumented)

        stridey (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")
    _hipblasChemvStridedBatched_v2__retval = hipblasStatus_t(chipblas.hipblasChemvStridedBatched_v2(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,uplo.value,n,
        float2.fromPyobj(alpha).getElementPtr(),
        float2.fromPyobj(AP).getElementPtr(),lda,strideA,
        float2.fromPyobj(x).getElementPtr(),incx,stridex,
        float2.fromPyobj(beta).getElementPtr(),
        float2.fromPyobj(y).getElementPtr(),incy,stridey,batchCount))
    return (_hipblasChemvStridedBatched_v2__retval,)


@cython.embedsignature(True)
def hipblasZhemvStridedBatched_v2(object handle, object uplo, int n, object alpha, object AP, int lda, long strideA, object x, int incx, long stridex, object beta, object y, int incy, long stridey, int batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        uplo (`~.hipblasFillMode_t`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        alpha (`~.double2`/`~.object`):
            (undocumented)

        AP (`~.double2`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        strideA (`~.int`):
            (undocumented)

        x (`~.double2`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        stridex (`~.int`):
            (undocumented)

        beta (`~.double2`/`~.object`):
            (undocumented)

        y (`~.double2`/`~.object`):
            (undocumented)

        incy (`~.int`):
            (undocumented)

        stridey (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")
    _hipblasZhemvStridedBatched_v2__retval = hipblasStatus_t(chipblas.hipblasZhemvStridedBatched_v2(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,uplo.value,n,
        double2.fromPyobj(alpha).getElementPtr(),
        double2.fromPyobj(AP).getElementPtr(),lda,strideA,
        double2.fromPyobj(x).getElementPtr(),incx,stridex,
        double2.fromPyobj(beta).getElementPtr(),
        double2.fromPyobj(y).getElementPtr(),incy,stridey,batchCount))
    return (_hipblasZhemvStridedBatched_v2__retval,)


@cython.embedsignature(True)
def hipblasChemvStridedBatched_64(object handle, object uplo, long n, object alpha, object AP, long lda, long strideA, object x, long incx, long stridex, object beta, object y, long incy, long stridey, long batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        uplo (`~.hipblasFillMode_t`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        alpha (`~.hipblasComplex`/`~.object`):
            (undocumented)

        AP (`~.hipblasComplex`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        strideA (`~.int`):
            (undocumented)

        x (`~.hipblasComplex`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        stridex (`~.int`):
            (undocumented)

        beta (`~.hipblasComplex`/`~.object`):
            (undocumented)

        y (`~.hipblasComplex`/`~.object`):
            (undocumented)

        incy (`~.int`):
            (undocumented)

        stridey (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")
    _hipblasChemvStridedBatched_64__retval = hipblasStatus_t(chipblas.hipblasChemvStridedBatched_64(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,uplo.value,n,
        hipblasComplex.fromPyobj(alpha).getElementPtr(),
        hipblasComplex.fromPyobj(AP).getElementPtr(),lda,strideA,
        hipblasComplex.fromPyobj(x).getElementPtr(),incx,stridex,
        hipblasComplex.fromPyobj(beta).getElementPtr(),
        hipblasComplex.fromPyobj(y).getElementPtr(),incy,stridey,batchCount))
    return (_hipblasChemvStridedBatched_64__retval,)


@cython.embedsignature(True)
def hipblasZhemvStridedBatched_64(object handle, object uplo, long n, object alpha, object AP, long lda, long strideA, object x, long incx, long stridex, object beta, object y, long incy, long stridey, long batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        uplo (`~.hipblasFillMode_t`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        alpha (`~.hipblasDoubleComplex`/`~.object`):
            (undocumented)

        AP (`~.hipblasDoubleComplex`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        strideA (`~.int`):
            (undocumented)

        x (`~.hipblasDoubleComplex`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        stridex (`~.int`):
            (undocumented)

        beta (`~.hipblasDoubleComplex`/`~.object`):
            (undocumented)

        y (`~.hipblasDoubleComplex`/`~.object`):
            (undocumented)

        incy (`~.int`):
            (undocumented)

        stridey (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")
    _hipblasZhemvStridedBatched_64__retval = hipblasStatus_t(chipblas.hipblasZhemvStridedBatched_64(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,uplo.value,n,
        hipblasDoubleComplex.fromPyobj(alpha).getElementPtr(),
        hipblasDoubleComplex.fromPyobj(AP).getElementPtr(),lda,strideA,
        hipblasDoubleComplex.fromPyobj(x).getElementPtr(),incx,stridex,
        hipblasDoubleComplex.fromPyobj(beta).getElementPtr(),
        hipblasDoubleComplex.fromPyobj(y).getElementPtr(),incy,stridey,batchCount))
    return (_hipblasZhemvStridedBatched_64__retval,)


@cython.embedsignature(True)
def hipblasChemvStridedBatched_v2_64(object handle, object uplo, long n, object alpha, object AP, long lda, long strideA, object x, long incx, long stridex, object beta, object y, long incy, long stridey, long batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        uplo (`~.hipblasFillMode_t`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        alpha (`~.float2`/`~.object`):
            (undocumented)

        AP (`~.float2`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        strideA (`~.int`):
            (undocumented)

        x (`~.float2`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        stridex (`~.int`):
            (undocumented)

        beta (`~.float2`/`~.object`):
            (undocumented)

        y (`~.float2`/`~.object`):
            (undocumented)

        incy (`~.int`):
            (undocumented)

        stridey (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")
    _hipblasChemvStridedBatched_v2_64__retval = hipblasStatus_t(chipblas.hipblasChemvStridedBatched_v2_64(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,uplo.value,n,
        float2.fromPyobj(alpha).getElementPtr(),
        float2.fromPyobj(AP).getElementPtr(),lda,strideA,
        float2.fromPyobj(x).getElementPtr(),incx,stridex,
        float2.fromPyobj(beta).getElementPtr(),
        float2.fromPyobj(y).getElementPtr(),incy,stridey,batchCount))
    return (_hipblasChemvStridedBatched_v2_64__retval,)


@cython.embedsignature(True)
def hipblasZhemvStridedBatched_v2_64(object handle, object uplo, long n, object alpha, object AP, long lda, long strideA, object x, long incx, long stridex, object beta, object y, long incy, long stridey, long batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        uplo (`~.hipblasFillMode_t`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        alpha (`~.double2`/`~.object`):
            (undocumented)

        AP (`~.double2`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        strideA (`~.int`):
            (undocumented)

        x (`~.double2`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        stridex (`~.int`):
            (undocumented)

        beta (`~.double2`/`~.object`):
            (undocumented)

        y (`~.double2`/`~.object`):
            (undocumented)

        incy (`~.int`):
            (undocumented)

        stridey (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")
    _hipblasZhemvStridedBatched_v2_64__retval = hipblasStatus_t(chipblas.hipblasZhemvStridedBatched_v2_64(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,uplo.value,n,
        double2.fromPyobj(alpha).getElementPtr(),
        double2.fromPyobj(AP).getElementPtr(),lda,strideA,
        double2.fromPyobj(x).getElementPtr(),incx,stridex,
        double2.fromPyobj(beta).getElementPtr(),
        double2.fromPyobj(y).getElementPtr(),incy,stridey,batchCount))
    return (_hipblasZhemvStridedBatched_v2_64__retval,)


@cython.embedsignature(True)
def hipblasCher(object handle, object uplo, int n, object alpha, object x, int incx, object AP, int lda):
    r"""BLAS Level 2 API

    @{

    her performs the matrix-vector operations

    A := A + alpha*x*x**H

    where alpha is a real scalar, x is a vector, and A is an
    n by n Hermitian matrix.

    - Supported precisions in rocBLAS : c,z
    - Supported precisions in cuBLAS  : c,z

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`) -- *IN*:
            [hipblasHandle_t]
            handle to the hipblas library context queue.

        uplo (`~.hipblasFillMode_t`) -- *IN*:
            [hipblasFillMode_t]
            specifies whether the upper 'HIPBLAS_FILL_MODE_UPPER' or lower 'HIPBLAS_FILL_MODE_LOWER'
            HIPBLAS_FILL_MODE_UPPER: The upper triangular part of A is supplied in A.
            HIPBLAS_FILL_MODE_LOWER: The lower triangular part of A is supplied in A.

        n (`~.int`) -- *IN*:
            [int]
            the number of rows and columns of matrix A, must be at least 0.

        alpha (`~.hip._util.types.Pointer`/`~.object`) -- *IN*:
            device pointer or host pointer to scalar alpha.

        x (`~.hipblasComplex`/`~.object`) -- *IN*:
            device pointer storing vector x.

        incx (`~.int`) -- *IN*:
            [int]
            specifies the increment for the elements of x.

        AP (`~.hipblasComplex`/`~.object`) -- *INOUT*:
            device pointer storing the specified triangular portion of
              the Hermitian matrix A. Of size (lda * n).
              if uplo == HIPBLAS_FILL_MODE_UPPER:
                The upper triangular portion of the Hermitian matrix A is supplied. The lower
                triangluar portion will not be touched.
            if uplo == HIPBLAS_FILL_MODE_LOWER:
                The lower triangular portion of the Hermitian matrix A is supplied. The upper
                triangular portion will not be touched.
            Note that the imaginary part of the diagonal elements are not accessed and are assumed
            to be 0.

        lda (`~.int`) -- *IN*:
            [int]
            specifies the leading dimension of A. Must be at least max(1, n).
    """
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")
    _hipblasCher__retval = hipblasStatus_t(chipblas.hipblasCher(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,uplo.value,n,
        <const float *>hip._util.types.Pointer.fromPyobj(alpha)._ptr,
        hipblasComplex.fromPyobj(x).getElementPtr(),incx,
        hipblasComplex.fromPyobj(AP).getElementPtr(),lda))
    return (_hipblasCher__retval,)


@cython.embedsignature(True)
def hipblasZher(object handle, object uplo, int n, object alpha, object x, int incx, object AP, int lda):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        uplo (`~.hipblasFillMode_t`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        alpha (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        x (`~.hipblasDoubleComplex`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        AP (`~.hipblasDoubleComplex`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)
    """
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")
    _hipblasZher__retval = hipblasStatus_t(chipblas.hipblasZher(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,uplo.value,n,
        <const double *>hip._util.types.Pointer.fromPyobj(alpha)._ptr,
        hipblasDoubleComplex.fromPyobj(x).getElementPtr(),incx,
        hipblasDoubleComplex.fromPyobj(AP).getElementPtr(),lda))
    return (_hipblasZher__retval,)


@cython.embedsignature(True)
def hipblasCher_v2(object handle, object uplo, int n, object alpha, object x, int incx, object AP, int lda):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        uplo (`~.hipblasFillMode_t`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        alpha (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        x (`~.float2`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        AP (`~.float2`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)
    """
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")
    _hipblasCher_v2__retval = hipblasStatus_t(chipblas.hipblasCher_v2(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,uplo.value,n,
        <const float *>hip._util.types.Pointer.fromPyobj(alpha)._ptr,
        float2.fromPyobj(x).getElementPtr(),incx,
        float2.fromPyobj(AP).getElementPtr(),lda))
    return (_hipblasCher_v2__retval,)


@cython.embedsignature(True)
def hipblasZher_v2(object handle, object uplo, int n, object alpha, object x, int incx, object AP, int lda):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        uplo (`~.hipblasFillMode_t`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        alpha (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        x (`~.double2`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        AP (`~.double2`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)
    """
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")
    _hipblasZher_v2__retval = hipblasStatus_t(chipblas.hipblasZher_v2(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,uplo.value,n,
        <const double *>hip._util.types.Pointer.fromPyobj(alpha)._ptr,
        double2.fromPyobj(x).getElementPtr(),incx,
        double2.fromPyobj(AP).getElementPtr(),lda))
    return (_hipblasZher_v2__retval,)


@cython.embedsignature(True)
def hipblasCher_64(object handle, object uplo, long n, object alpha, object x, long incx, object AP, long lda):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        uplo (`~.hipblasFillMode_t`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        alpha (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        x (`~.hipblasComplex`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        AP (`~.hipblasComplex`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)
    """
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")
    _hipblasCher_64__retval = hipblasStatus_t(chipblas.hipblasCher_64(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,uplo.value,n,
        <const float *>hip._util.types.Pointer.fromPyobj(alpha)._ptr,
        hipblasComplex.fromPyobj(x).getElementPtr(),incx,
        hipblasComplex.fromPyobj(AP).getElementPtr(),lda))
    return (_hipblasCher_64__retval,)


@cython.embedsignature(True)
def hipblasZher_64(object handle, object uplo, long n, object alpha, object x, long incx, object AP, long lda):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        uplo (`~.hipblasFillMode_t`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        alpha (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        x (`~.hipblasDoubleComplex`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        AP (`~.hipblasDoubleComplex`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)
    """
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")
    _hipblasZher_64__retval = hipblasStatus_t(chipblas.hipblasZher_64(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,uplo.value,n,
        <const double *>hip._util.types.Pointer.fromPyobj(alpha)._ptr,
        hipblasDoubleComplex.fromPyobj(x).getElementPtr(),incx,
        hipblasDoubleComplex.fromPyobj(AP).getElementPtr(),lda))
    return (_hipblasZher_64__retval,)


@cython.embedsignature(True)
def hipblasCher_v2_64(object handle, object uplo, long n, object alpha, object x, long incx, object AP, long lda):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        uplo (`~.hipblasFillMode_t`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        alpha (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        x (`~.float2`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        AP (`~.float2`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)
    """
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")
    _hipblasCher_v2_64__retval = hipblasStatus_t(chipblas.hipblasCher_v2_64(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,uplo.value,n,
        <const float *>hip._util.types.Pointer.fromPyobj(alpha)._ptr,
        float2.fromPyobj(x).getElementPtr(),incx,
        float2.fromPyobj(AP).getElementPtr(),lda))
    return (_hipblasCher_v2_64__retval,)


@cython.embedsignature(True)
def hipblasZher_v2_64(object handle, object uplo, long n, object alpha, object x, long incx, object AP, long lda):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        uplo (`~.hipblasFillMode_t`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        alpha (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        x (`~.double2`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        AP (`~.double2`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)
    """
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")
    _hipblasZher_v2_64__retval = hipblasStatus_t(chipblas.hipblasZher_v2_64(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,uplo.value,n,
        <const double *>hip._util.types.Pointer.fromPyobj(alpha)._ptr,
        double2.fromPyobj(x).getElementPtr(),incx,
        double2.fromPyobj(AP).getElementPtr(),lda))
    return (_hipblasZher_v2_64__retval,)


@cython.embedsignature(True)
def hipblasCherBatched(object handle, object uplo, int n, object alpha, object x, int incx, object AP, int lda, int batchCount):
    r"""BLAS Level 2 API

    @{

    herBatched performs the matrix-vector operations

    A_i := A_i + alpha*x_i*x_i**H

    where alpha is a real scalar, x_i is a vector, and A_i is an
    n by n symmetric matrix, for i = 1, ..., batchCount.

    - Supported precisions in rocBLAS : c,z
    - Supported precisions in cuBLAS  : No support

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`) -- *IN*:
            [hipblasHandle_t]
            handle to the hipblas library context queue.

        uplo (`~.hipblasFillMode_t`) -- *IN*:
            [hipblasFillMode_t]
            specifies whether the upper 'HIPBLAS_FILL_MODE_UPPER' or lower 'HIPBLAS_FILL_MODE_LOWER'
            HIPBLAS_FILL_MODE_UPPER: The upper triangular part of each A_i is supplied in A.
            HIPBLAS_FILL_MODE_LOWER: The lower triangular part of each A_i is supplied in A.

        n (`~.int`) -- *IN*:
            [int]
            the number of rows and columns of each matrix A_i, must be at least 0.

        alpha (`~.hip._util.types.Pointer`/`~.object`) -- *IN*:
            device pointer or host pointer to scalar alpha.

        x (`~.hip._util.types.Pointer`/`~.object`) -- *IN*:
            device array of device pointers storing each vector x_i.

        incx (`~.int`) -- *IN*:
            [int]
            specifies the increment for the elements of each x_i.

        AP (`~.hip._util.types.Pointer`/`~.object`) -- *INOUT*:
            device array of device pointers storing the specified triangular portion of
              each Hermitian matrix A_i of at least size ((n * (n + 1)) / 2). Array is of at least size batchCount.
              if uplo == HIPBLAS_FILL_MODE_UPPER:
                The upper triangular portion of each Hermitian matrix A_i is supplied. The lower triangular portion
                of each A_i will not be touched.
            if uplo == HIPBLAS_FILL_MODE_LOWER:
                The lower triangular portion of each Hermitian matrix A_i is supplied. The upper triangular portion
                of each A_i will not be touched.
            Note that the imaginary part of the diagonal elements are not accessed and are assumed
            to be 0.

        lda (`~.int`) -- *IN*:
            [int]
            specifies the leading dimension of each A_i. Must be at least max(1, n).

        batchCount (`~.int`) -- *IN*:
            [int]
            number of instances in the batch.
    """
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")
    _hipblasCherBatched__retval = hipblasStatus_t(chipblas.hipblasCherBatched(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,uplo.value,n,
        <const float *>hip._util.types.Pointer.fromPyobj(alpha)._ptr,
        <chipblas.hipblasComplex *const*>hip._util.types.Pointer.fromPyobj(x)._ptr,incx,
        <chipblas.hipblasComplex *const*>hip._util.types.Pointer.fromPyobj(AP)._ptr,lda,batchCount))
    return (_hipblasCherBatched__retval,)


@cython.embedsignature(True)
def hipblasZherBatched(object handle, object uplo, int n, object alpha, object x, int incx, object AP, int lda, int batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        uplo (`~.hipblasFillMode_t`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        alpha (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        x (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        AP (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")
    _hipblasZherBatched__retval = hipblasStatus_t(chipblas.hipblasZherBatched(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,uplo.value,n,
        <const double *>hip._util.types.Pointer.fromPyobj(alpha)._ptr,
        <chipblas.hipblasDoubleComplex *const*>hip._util.types.Pointer.fromPyobj(x)._ptr,incx,
        <chipblas.hipblasDoubleComplex *const*>hip._util.types.Pointer.fromPyobj(AP)._ptr,lda,batchCount))
    return (_hipblasZherBatched__retval,)


@cython.embedsignature(True)
def hipblasCherBatched_v2(object handle, object uplo, int n, object alpha, object x, int incx, object AP, int lda, int batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        uplo (`~.hipblasFillMode_t`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        alpha (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        x (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        AP (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")
    _hipblasCherBatched_v2__retval = hipblasStatus_t(chipblas.hipblasCherBatched_v2(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,uplo.value,n,
        <const float *>hip._util.types.Pointer.fromPyobj(alpha)._ptr,
        <chipblas.float2 *const*>hip._util.types.Pointer.fromPyobj(x)._ptr,incx,
        <chipblas.float2 *const*>hip._util.types.Pointer.fromPyobj(AP)._ptr,lda,batchCount))
    return (_hipblasCherBatched_v2__retval,)


@cython.embedsignature(True)
def hipblasZherBatched_v2(object handle, object uplo, int n, object alpha, object x, int incx, object AP, int lda, int batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        uplo (`~.hipblasFillMode_t`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        alpha (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        x (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        AP (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")
    _hipblasZherBatched_v2__retval = hipblasStatus_t(chipblas.hipblasZherBatched_v2(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,uplo.value,n,
        <const double *>hip._util.types.Pointer.fromPyobj(alpha)._ptr,
        <chipblas.double2 *const*>hip._util.types.Pointer.fromPyobj(x)._ptr,incx,
        <chipblas.double2 *const*>hip._util.types.Pointer.fromPyobj(AP)._ptr,lda,batchCount))
    return (_hipblasZherBatched_v2__retval,)


@cython.embedsignature(True)
def hipblasCherBatched_64(object handle, object uplo, long n, object alpha, object x, long incx, object AP, long lda, long batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        uplo (`~.hipblasFillMode_t`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        alpha (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        x (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        AP (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")
    _hipblasCherBatched_64__retval = hipblasStatus_t(chipblas.hipblasCherBatched_64(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,uplo.value,n,
        <const float *>hip._util.types.Pointer.fromPyobj(alpha)._ptr,
        <chipblas.hipblasComplex *const*>hip._util.types.Pointer.fromPyobj(x)._ptr,incx,
        <chipblas.hipblasComplex *const*>hip._util.types.Pointer.fromPyobj(AP)._ptr,lda,batchCount))
    return (_hipblasCherBatched_64__retval,)


@cython.embedsignature(True)
def hipblasZherBatched_64(object handle, object uplo, long n, object alpha, object x, long incx, object AP, long lda, long batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        uplo (`~.hipblasFillMode_t`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        alpha (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        x (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        AP (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")
    _hipblasZherBatched_64__retval = hipblasStatus_t(chipblas.hipblasZherBatched_64(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,uplo.value,n,
        <const double *>hip._util.types.Pointer.fromPyobj(alpha)._ptr,
        <chipblas.hipblasDoubleComplex *const*>hip._util.types.Pointer.fromPyobj(x)._ptr,incx,
        <chipblas.hipblasDoubleComplex *const*>hip._util.types.Pointer.fromPyobj(AP)._ptr,lda,batchCount))
    return (_hipblasZherBatched_64__retval,)


@cython.embedsignature(True)
def hipblasCherBatched_v2_64(object handle, object uplo, long n, object alpha, object x, long incx, object AP, long lda, long batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        uplo (`~.hipblasFillMode_t`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        alpha (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        x (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        AP (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")
    _hipblasCherBatched_v2_64__retval = hipblasStatus_t(chipblas.hipblasCherBatched_v2_64(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,uplo.value,n,
        <const float *>hip._util.types.Pointer.fromPyobj(alpha)._ptr,
        <chipblas.float2 *const*>hip._util.types.Pointer.fromPyobj(x)._ptr,incx,
        <chipblas.float2 *const*>hip._util.types.Pointer.fromPyobj(AP)._ptr,lda,batchCount))
    return (_hipblasCherBatched_v2_64__retval,)


@cython.embedsignature(True)
def hipblasZherBatched_v2_64(object handle, object uplo, long n, object alpha, object x, long incx, object AP, long lda, long batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        uplo (`~.hipblasFillMode_t`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        alpha (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        x (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        AP (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")
    _hipblasZherBatched_v2_64__retval = hipblasStatus_t(chipblas.hipblasZherBatched_v2_64(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,uplo.value,n,
        <const double *>hip._util.types.Pointer.fromPyobj(alpha)._ptr,
        <chipblas.double2 *const*>hip._util.types.Pointer.fromPyobj(x)._ptr,incx,
        <chipblas.double2 *const*>hip._util.types.Pointer.fromPyobj(AP)._ptr,lda,batchCount))
    return (_hipblasZherBatched_v2_64__retval,)


@cython.embedsignature(True)
def hipblasCherStridedBatched(object handle, object uplo, int n, object alpha, object x, int incx, long stridex, object AP, int lda, long strideA, int batchCount):
    r"""BLAS Level 2 API

    @{

    herStridedBatched performs the matrix-vector operations

    A_i := A_i + alpha*x_i*x_i**H

    where alpha is a real scalar, x_i is a vector, and A_i is an
    n by n Hermitian matrix, for i = 1, ..., batchCount.

    - Supported precisions in rocBLAS : c,z
    - Supported precisions in cuBLAS  : No support

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`) -- *IN*:
            [hipblasHandle_t]
            handle to the hipblas library context queue.

        uplo (`~.hipblasFillMode_t`) -- *IN*:
            [hipblasFillMode_t]
            specifies whether the upper 'HIPBLAS_FILL_MODE_UPPER' or lower 'HIPBLAS_FILL_MODE_LOWER'
            HIPBLAS_FILL_MODE_UPPER: The upper triangular part of each A_i is supplied in A.
            HIPBLAS_FILL_MODE_LOWER: The lower triangular part of each A_i is supplied in A.

        n (`~.int`) -- *IN*:
            [int]
            the number of rows and columns of each matrix A_i, must be at least 0.

        alpha (`~.hip._util.types.Pointer`/`~.object`) -- *IN*:
            device pointer or host pointer to scalar alpha.

        x (`~.hipblasComplex`/`~.object`) -- *IN*:
            device pointer pointing to the first vector (x_1).

        incx (`~.int`) -- *IN*:
            [int]
            specifies the increment for the elements of each x_i.

        stridex (`~.int`) -- *IN*:
            [hipblasStride]
            stride from the start of one vector (x_i) and the next one (x_i+1).

        AP (`~.hipblasComplex`/`~.object`) -- *INOUT*:
            device array of device pointers storing the specified triangular portion of
              each Hermitian matrix A_i. Points to the first matrix (A_1).
              if uplo == HIPBLAS_FILL_MODE_UPPER:
                The upper triangular portion of each Hermitian matrix A_i is supplied. The lower triangular
                portion of each A_i will not be touched.
            if uplo == HIPBLAS_FILL_MODE_LOWER:
                The lower triangular portion of each Hermitian matrix A_i is supplied. The upper triangular
                portion of each A_i will not be touched.
            Note that the imaginary part of the diagonal elements are not accessed and are assumed
            to be 0.

        lda (`~.int`) -- *IN*:
            [int]
            specifies the leading dimension of each A_i.

        strideA (`~.int`) -- *IN*:
            [hipblasStride]
            stride from the start of one (A_i) and the next (A_i+1)

        batchCount (`~.int`) -- *IN*:
            [int]
            number of instances in the batch.
    """
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")
    _hipblasCherStridedBatched__retval = hipblasStatus_t(chipblas.hipblasCherStridedBatched(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,uplo.value,n,
        <const float *>hip._util.types.Pointer.fromPyobj(alpha)._ptr,
        hipblasComplex.fromPyobj(x).getElementPtr(),incx,stridex,
        hipblasComplex.fromPyobj(AP).getElementPtr(),lda,strideA,batchCount))
    return (_hipblasCherStridedBatched__retval,)


@cython.embedsignature(True)
def hipblasZherStridedBatched(object handle, object uplo, int n, object alpha, object x, int incx, long stridex, object AP, int lda, long strideA, int batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        uplo (`~.hipblasFillMode_t`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        alpha (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        x (`~.hipblasDoubleComplex`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        stridex (`~.int`):
            (undocumented)

        AP (`~.hipblasDoubleComplex`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        strideA (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")
    _hipblasZherStridedBatched__retval = hipblasStatus_t(chipblas.hipblasZherStridedBatched(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,uplo.value,n,
        <const double *>hip._util.types.Pointer.fromPyobj(alpha)._ptr,
        hipblasDoubleComplex.fromPyobj(x).getElementPtr(),incx,stridex,
        hipblasDoubleComplex.fromPyobj(AP).getElementPtr(),lda,strideA,batchCount))
    return (_hipblasZherStridedBatched__retval,)


@cython.embedsignature(True)
def hipblasCherStridedBatched_v2(object handle, object uplo, int n, object alpha, object x, int incx, long stridex, object AP, int lda, long strideA, int batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        uplo (`~.hipblasFillMode_t`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        alpha (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        x (`~.float2`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        stridex (`~.int`):
            (undocumented)

        AP (`~.float2`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        strideA (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")
    _hipblasCherStridedBatched_v2__retval = hipblasStatus_t(chipblas.hipblasCherStridedBatched_v2(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,uplo.value,n,
        <const float *>hip._util.types.Pointer.fromPyobj(alpha)._ptr,
        float2.fromPyobj(x).getElementPtr(),incx,stridex,
        float2.fromPyobj(AP).getElementPtr(),lda,strideA,batchCount))
    return (_hipblasCherStridedBatched_v2__retval,)


@cython.embedsignature(True)
def hipblasZherStridedBatched_v2(object handle, object uplo, int n, object alpha, object x, int incx, long stridex, object AP, int lda, long strideA, int batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        uplo (`~.hipblasFillMode_t`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        alpha (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        x (`~.double2`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        stridex (`~.int`):
            (undocumented)

        AP (`~.double2`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        strideA (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")
    _hipblasZherStridedBatched_v2__retval = hipblasStatus_t(chipblas.hipblasZherStridedBatched_v2(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,uplo.value,n,
        <const double *>hip._util.types.Pointer.fromPyobj(alpha)._ptr,
        double2.fromPyobj(x).getElementPtr(),incx,stridex,
        double2.fromPyobj(AP).getElementPtr(),lda,strideA,batchCount))
    return (_hipblasZherStridedBatched_v2__retval,)


@cython.embedsignature(True)
def hipblasCherStridedBatched_64(object handle, object uplo, long n, object alpha, object x, long incx, long stridex, object AP, long lda, long strideA, long batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        uplo (`~.hipblasFillMode_t`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        alpha (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        x (`~.hipblasComplex`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        stridex (`~.int`):
            (undocumented)

        AP (`~.hipblasComplex`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        strideA (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")
    _hipblasCherStridedBatched_64__retval = hipblasStatus_t(chipblas.hipblasCherStridedBatched_64(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,uplo.value,n,
        <const float *>hip._util.types.Pointer.fromPyobj(alpha)._ptr,
        hipblasComplex.fromPyobj(x).getElementPtr(),incx,stridex,
        hipblasComplex.fromPyobj(AP).getElementPtr(),lda,strideA,batchCount))
    return (_hipblasCherStridedBatched_64__retval,)


@cython.embedsignature(True)
def hipblasZherStridedBatched_64(object handle, object uplo, long n, object alpha, object x, long incx, long stridex, object AP, long lda, long strideA, long batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        uplo (`~.hipblasFillMode_t`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        alpha (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        x (`~.hipblasDoubleComplex`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        stridex (`~.int`):
            (undocumented)

        AP (`~.hipblasDoubleComplex`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        strideA (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")
    _hipblasZherStridedBatched_64__retval = hipblasStatus_t(chipblas.hipblasZherStridedBatched_64(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,uplo.value,n,
        <const double *>hip._util.types.Pointer.fromPyobj(alpha)._ptr,
        hipblasDoubleComplex.fromPyobj(x).getElementPtr(),incx,stridex,
        hipblasDoubleComplex.fromPyobj(AP).getElementPtr(),lda,strideA,batchCount))
    return (_hipblasZherStridedBatched_64__retval,)


@cython.embedsignature(True)
def hipblasCherStridedBatched_v2_64(object handle, object uplo, long n, object alpha, object x, long incx, long stridex, object AP, long lda, long strideA, long batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        uplo (`~.hipblasFillMode_t`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        alpha (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        x (`~.float2`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        stridex (`~.int`):
            (undocumented)

        AP (`~.float2`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        strideA (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")
    _hipblasCherStridedBatched_v2_64__retval = hipblasStatus_t(chipblas.hipblasCherStridedBatched_v2_64(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,uplo.value,n,
        <const float *>hip._util.types.Pointer.fromPyobj(alpha)._ptr,
        float2.fromPyobj(x).getElementPtr(),incx,stridex,
        float2.fromPyobj(AP).getElementPtr(),lda,strideA,batchCount))
    return (_hipblasCherStridedBatched_v2_64__retval,)


@cython.embedsignature(True)
def hipblasZherStridedBatched_v2_64(object handle, object uplo, long n, object alpha, object x, long incx, long stridex, object AP, long lda, long strideA, long batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        uplo (`~.hipblasFillMode_t`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        alpha (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        x (`~.double2`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        stridex (`~.int`):
            (undocumented)

        AP (`~.double2`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        strideA (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")
    _hipblasZherStridedBatched_v2_64__retval = hipblasStatus_t(chipblas.hipblasZherStridedBatched_v2_64(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,uplo.value,n,
        <const double *>hip._util.types.Pointer.fromPyobj(alpha)._ptr,
        double2.fromPyobj(x).getElementPtr(),incx,stridex,
        double2.fromPyobj(AP).getElementPtr(),lda,strideA,batchCount))
    return (_hipblasZherStridedBatched_v2_64__retval,)


@cython.embedsignature(True)
def hipblasCher2(object handle, object uplo, int n, object alpha, object x, int incx, object y, int incy, object AP, int lda):
    r"""BLAS Level 2 API

    @{

    her2 performs the matrix-vector operations

    A := A + alpha*x*y**H + conj(alpha)*y*x**H

    where alpha is a complex scalar, x and y are vectors, and A is an
    n by n Hermitian matrix.

    - Supported precisions in rocBLAS : c,z
    - Supported precisions in cuBLAS  : c,z

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`) -- *IN*:
            [hipblasHandle_t]
            handle to the hipblas library context queue.

        uplo (`~.hipblasFillMode_t`) -- *IN*:
            [hipblasFillMode_t]
            specifies whether the upper 'HIPBLAS_FILL_MODE_UPPER' or lower 'HIPBLAS_FILL_MODE_LOWER'
            HIPBLAS_FILL_MODE_UPPER: The upper triangular part of A is supplied.
            HIPBLAS_FILL_MODE_LOWER: The lower triangular part of A is supplied.

        n (`~.int`) -- *IN*:
            [int]
            the number of rows and columns of matrix A, must be at least 0.

        alpha (`~.hipblasComplex`/`~.object`) -- *IN*:
            device pointer or host pointer to scalar alpha.

        x (`~.hipblasComplex`/`~.object`) -- *IN*:
            device pointer storing vector x.

        incx (`~.int`) -- *IN*:
            [int]
            specifies the increment for the elements of x.

        y (`~.hipblasComplex`/`~.object`) -- *IN*:
            device pointer storing vector y.

        incy (`~.int`) -- *IN*:
            [int]
            specifies the increment for the elements of y.

        AP (`~.hipblasComplex`/`~.object`) -- *INOUT*:
            device pointer storing the specified triangular portion of
              the Hermitian matrix A. Of size (lda, n).
              if uplo == HIPBLAS_FILL_MODE_UPPER:
                The upper triangular portion of the Hermitian matrix A is supplied. The lower triangular
                portion of A will not be touched.
            if uplo == HIPBLAS_FILL_MODE_LOWER:
                The lower triangular portion of the Hermitian matrix A is supplied. The upper triangular
                portion of A will not be touched.
            Note that the imaginary part of the diagonal elements are not accessed and are assumed
            to be 0.

        lda (`~.int`) -- *IN*:
            [int]
            specifies the leading dimension of A. Must be at least max(lda, 1).
    """
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")
    _hipblasCher2__retval = hipblasStatus_t(chipblas.hipblasCher2(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,uplo.value,n,
        hipblasComplex.fromPyobj(alpha).getElementPtr(),
        hipblasComplex.fromPyobj(x).getElementPtr(),incx,
        hipblasComplex.fromPyobj(y).getElementPtr(),incy,
        hipblasComplex.fromPyobj(AP).getElementPtr(),lda))
    return (_hipblasCher2__retval,)


@cython.embedsignature(True)
def hipblasZher2(object handle, object uplo, int n, object alpha, object x, int incx, object y, int incy, object AP, int lda):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        uplo (`~.hipblasFillMode_t`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        alpha (`~.hipblasDoubleComplex`/`~.object`):
            (undocumented)

        x (`~.hipblasDoubleComplex`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        y (`~.hipblasDoubleComplex`/`~.object`):
            (undocumented)

        incy (`~.int`):
            (undocumented)

        AP (`~.hipblasDoubleComplex`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)
    """
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")
    _hipblasZher2__retval = hipblasStatus_t(chipblas.hipblasZher2(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,uplo.value,n,
        hipblasDoubleComplex.fromPyobj(alpha).getElementPtr(),
        hipblasDoubleComplex.fromPyobj(x).getElementPtr(),incx,
        hipblasDoubleComplex.fromPyobj(y).getElementPtr(),incy,
        hipblasDoubleComplex.fromPyobj(AP).getElementPtr(),lda))
    return (_hipblasZher2__retval,)


@cython.embedsignature(True)
def hipblasCher2_v2(object handle, object uplo, int n, object alpha, object x, int incx, object y, int incy, object AP, int lda):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        uplo (`~.hipblasFillMode_t`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        alpha (`~.float2`/`~.object`):
            (undocumented)

        x (`~.float2`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        y (`~.float2`/`~.object`):
            (undocumented)

        incy (`~.int`):
            (undocumented)

        AP (`~.float2`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)
    """
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")
    _hipblasCher2_v2__retval = hipblasStatus_t(chipblas.hipblasCher2_v2(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,uplo.value,n,
        float2.fromPyobj(alpha).getElementPtr(),
        float2.fromPyobj(x).getElementPtr(),incx,
        float2.fromPyobj(y).getElementPtr(),incy,
        float2.fromPyobj(AP).getElementPtr(),lda))
    return (_hipblasCher2_v2__retval,)


@cython.embedsignature(True)
def hipblasZher2_v2(object handle, object uplo, int n, object alpha, object x, int incx, object y, int incy, object AP, int lda):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        uplo (`~.hipblasFillMode_t`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        alpha (`~.double2`/`~.object`):
            (undocumented)

        x (`~.double2`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        y (`~.double2`/`~.object`):
            (undocumented)

        incy (`~.int`):
            (undocumented)

        AP (`~.double2`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)
    """
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")
    _hipblasZher2_v2__retval = hipblasStatus_t(chipblas.hipblasZher2_v2(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,uplo.value,n,
        double2.fromPyobj(alpha).getElementPtr(),
        double2.fromPyobj(x).getElementPtr(),incx,
        double2.fromPyobj(y).getElementPtr(),incy,
        double2.fromPyobj(AP).getElementPtr(),lda))
    return (_hipblasZher2_v2__retval,)


@cython.embedsignature(True)
def hipblasCher2_64(object handle, object uplo, long n, object alpha, object x, long incx, object y, long incy, object AP, long lda):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        uplo (`~.hipblasFillMode_t`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        alpha (`~.hipblasComplex`/`~.object`):
            (undocumented)

        x (`~.hipblasComplex`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        y (`~.hipblasComplex`/`~.object`):
            (undocumented)

        incy (`~.int`):
            (undocumented)

        AP (`~.hipblasComplex`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)
    """
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")
    _hipblasCher2_64__retval = hipblasStatus_t(chipblas.hipblasCher2_64(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,uplo.value,n,
        hipblasComplex.fromPyobj(alpha).getElementPtr(),
        hipblasComplex.fromPyobj(x).getElementPtr(),incx,
        hipblasComplex.fromPyobj(y).getElementPtr(),incy,
        hipblasComplex.fromPyobj(AP).getElementPtr(),lda))
    return (_hipblasCher2_64__retval,)


@cython.embedsignature(True)
def hipblasZher2_64(object handle, object uplo, long n, object alpha, object x, long incx, object y, long incy, object AP, long lda):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        uplo (`~.hipblasFillMode_t`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        alpha (`~.hipblasDoubleComplex`/`~.object`):
            (undocumented)

        x (`~.hipblasDoubleComplex`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        y (`~.hipblasDoubleComplex`/`~.object`):
            (undocumented)

        incy (`~.int`):
            (undocumented)

        AP (`~.hipblasDoubleComplex`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)
    """
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")
    _hipblasZher2_64__retval = hipblasStatus_t(chipblas.hipblasZher2_64(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,uplo.value,n,
        hipblasDoubleComplex.fromPyobj(alpha).getElementPtr(),
        hipblasDoubleComplex.fromPyobj(x).getElementPtr(),incx,
        hipblasDoubleComplex.fromPyobj(y).getElementPtr(),incy,
        hipblasDoubleComplex.fromPyobj(AP).getElementPtr(),lda))
    return (_hipblasZher2_64__retval,)


@cython.embedsignature(True)
def hipblasCher2_v2_64(object handle, object uplo, long n, object alpha, object x, long incx, object y, long incy, object AP, long lda):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        uplo (`~.hipblasFillMode_t`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        alpha (`~.float2`/`~.object`):
            (undocumented)

        x (`~.float2`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        y (`~.float2`/`~.object`):
            (undocumented)

        incy (`~.int`):
            (undocumented)

        AP (`~.float2`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)
    """
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")
    _hipblasCher2_v2_64__retval = hipblasStatus_t(chipblas.hipblasCher2_v2_64(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,uplo.value,n,
        float2.fromPyobj(alpha).getElementPtr(),
        float2.fromPyobj(x).getElementPtr(),incx,
        float2.fromPyobj(y).getElementPtr(),incy,
        float2.fromPyobj(AP).getElementPtr(),lda))
    return (_hipblasCher2_v2_64__retval,)


@cython.embedsignature(True)
def hipblasZher2_v2_64(object handle, object uplo, long n, object alpha, object x, long incx, object y, long incy, object AP, long lda):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        uplo (`~.hipblasFillMode_t`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        alpha (`~.double2`/`~.object`):
            (undocumented)

        x (`~.double2`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        y (`~.double2`/`~.object`):
            (undocumented)

        incy (`~.int`):
            (undocumented)

        AP (`~.double2`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)
    """
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")
    _hipblasZher2_v2_64__retval = hipblasStatus_t(chipblas.hipblasZher2_v2_64(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,uplo.value,n,
        double2.fromPyobj(alpha).getElementPtr(),
        double2.fromPyobj(x).getElementPtr(),incx,
        double2.fromPyobj(y).getElementPtr(),incy,
        double2.fromPyobj(AP).getElementPtr(),lda))
    return (_hipblasZher2_v2_64__retval,)


@cython.embedsignature(True)
def hipblasCher2Batched(object handle, object uplo, int n, object alpha, object x, int incx, object y, int incy, object AP, int lda, int batchCount):
    r"""BLAS Level 2 API

    @{

    her2Batched performs the matrix-vector operations

    A_i := A_i + alpha*x_i*y_i**H + conj(alpha)*y_i*x_i**H

    where alpha is a complex scalar, x_i and y_i are vectors, and A_i is an
    n by n Hermitian matrix for each batch in i = [1, batchCount].

    - Supported precisions in rocBLAS : c,z
    - Supported precisions in cuBLAS  : No support

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`) -- *IN*:
            [hipblasHandle_t]
            handle to the hipblas library context queue.

        uplo (`~.hipblasFillMode_t`) -- *IN*:
            [hipblasFillMode_t]
            specifies whether the upper 'HIPBLAS_FILL_MODE_UPPER' or lower 'HIPBLAS_FILL_MODE_LOWER'
            HIPBLAS_FILL_MODE_UPPER: The upper triangular part of each A_i is supplied.
            HIPBLAS_FILL_MODE_LOWER: The lower triangular part of each A_i is supplied.

        n (`~.int`) -- *IN*:
            [int]
            the number of rows and columns of each matrix A_i, must be at least 0.

        alpha (`~.hipblasComplex`/`~.object`) -- *IN*:
            device pointer or host pointer to scalar alpha.

        x (`~.hip._util.types.Pointer`/`~.object`) -- *IN*:
            device array of device pointers storing each vector x_i.

        incx (`~.int`) -- *IN*:
            [int]
            specifies the increment for the elements of x.

        y (`~.hip._util.types.Pointer`/`~.object`) -- *IN*:
            device array of device pointers storing each vector y_i.

        incy (`~.int`) -- *IN*:
            [int]
            specifies the increment for the elements of each y_i.

        AP (`~.hip._util.types.Pointer`/`~.object`) -- *INOUT*:
            device array of device pointers storing the specified triangular portion of
              each Hermitian matrix A_i of size (lda, n).
              if uplo == HIPBLAS_FILL_MODE_UPPER:
                The upper triangular portion of each Hermitian matrix A_i is supplied. The lower triangular
                portion of each A_i will not be touched.
            if uplo == HIPBLAS_FILL_MODE_LOWER:
                The lower triangular portion of each Hermitian matrix A_i is supplied. The upper triangular
                portion of each A_i will not be touched.
            Note that the imaginary part of the diagonal elements are not accessed and are assumed
            to be 0.

        lda (`~.int`) -- *IN*:
            [int]
            specifies the leading dimension of each A_i. Must be at least max(lda, 1).

        batchCount (`~.int`) -- *IN*:
            [int]
            number of instances in the batch.
    """
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")
    _hipblasCher2Batched__retval = hipblasStatus_t(chipblas.hipblasCher2Batched(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,uplo.value,n,
        hipblasComplex.fromPyobj(alpha).getElementPtr(),
        <chipblas.hipblasComplex *const*>hip._util.types.Pointer.fromPyobj(x)._ptr,incx,
        <chipblas.hipblasComplex *const*>hip._util.types.Pointer.fromPyobj(y)._ptr,incy,
        <chipblas.hipblasComplex *const*>hip._util.types.Pointer.fromPyobj(AP)._ptr,lda,batchCount))
    return (_hipblasCher2Batched__retval,)


@cython.embedsignature(True)
def hipblasZher2Batched(object handle, object uplo, int n, object alpha, object x, int incx, object y, int incy, object AP, int lda, int batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        uplo (`~.hipblasFillMode_t`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        alpha (`~.hipblasDoubleComplex`/`~.object`):
            (undocumented)

        x (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        y (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        incy (`~.int`):
            (undocumented)

        AP (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")
    _hipblasZher2Batched__retval = hipblasStatus_t(chipblas.hipblasZher2Batched(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,uplo.value,n,
        hipblasDoubleComplex.fromPyobj(alpha).getElementPtr(),
        <chipblas.hipblasDoubleComplex *const*>hip._util.types.Pointer.fromPyobj(x)._ptr,incx,
        <chipblas.hipblasDoubleComplex *const*>hip._util.types.Pointer.fromPyobj(y)._ptr,incy,
        <chipblas.hipblasDoubleComplex *const*>hip._util.types.Pointer.fromPyobj(AP)._ptr,lda,batchCount))
    return (_hipblasZher2Batched__retval,)


@cython.embedsignature(True)
def hipblasCher2Batched_v2(object handle, object uplo, int n, object alpha, object x, int incx, object y, int incy, object AP, int lda, int batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        uplo (`~.hipblasFillMode_t`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        alpha (`~.float2`/`~.object`):
            (undocumented)

        x (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        y (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        incy (`~.int`):
            (undocumented)

        AP (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")
    _hipblasCher2Batched_v2__retval = hipblasStatus_t(chipblas.hipblasCher2Batched_v2(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,uplo.value,n,
        float2.fromPyobj(alpha).getElementPtr(),
        <chipblas.float2 *const*>hip._util.types.Pointer.fromPyobj(x)._ptr,incx,
        <chipblas.float2 *const*>hip._util.types.Pointer.fromPyobj(y)._ptr,incy,
        <chipblas.float2 *const*>hip._util.types.Pointer.fromPyobj(AP)._ptr,lda,batchCount))
    return (_hipblasCher2Batched_v2__retval,)


@cython.embedsignature(True)
def hipblasZher2Batched_v2(object handle, object uplo, int n, object alpha, object x, int incx, object y, int incy, object AP, int lda, int batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        uplo (`~.hipblasFillMode_t`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        alpha (`~.double2`/`~.object`):
            (undocumented)

        x (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        y (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        incy (`~.int`):
            (undocumented)

        AP (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")
    _hipblasZher2Batched_v2__retval = hipblasStatus_t(chipblas.hipblasZher2Batched_v2(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,uplo.value,n,
        double2.fromPyobj(alpha).getElementPtr(),
        <chipblas.double2 *const*>hip._util.types.Pointer.fromPyobj(x)._ptr,incx,
        <chipblas.double2 *const*>hip._util.types.Pointer.fromPyobj(y)._ptr,incy,
        <chipblas.double2 *const*>hip._util.types.Pointer.fromPyobj(AP)._ptr,lda,batchCount))
    return (_hipblasZher2Batched_v2__retval,)


@cython.embedsignature(True)
def hipblasCher2Batched_64(object handle, object uplo, long n, object alpha, object x, long incx, object y, long incy, object AP, long lda, long batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        uplo (`~.hipblasFillMode_t`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        alpha (`~.hipblasComplex`/`~.object`):
            (undocumented)

        x (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        y (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        incy (`~.int`):
            (undocumented)

        AP (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")
    _hipblasCher2Batched_64__retval = hipblasStatus_t(chipblas.hipblasCher2Batched_64(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,uplo.value,n,
        hipblasComplex.fromPyobj(alpha).getElementPtr(),
        <chipblas.hipblasComplex *const*>hip._util.types.Pointer.fromPyobj(x)._ptr,incx,
        <chipblas.hipblasComplex *const*>hip._util.types.Pointer.fromPyobj(y)._ptr,incy,
        <chipblas.hipblasComplex *const*>hip._util.types.Pointer.fromPyobj(AP)._ptr,lda,batchCount))
    return (_hipblasCher2Batched_64__retval,)


@cython.embedsignature(True)
def hipblasZher2Batched_64(object handle, object uplo, long n, object alpha, object x, long incx, object y, long incy, object AP, long lda, long batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        uplo (`~.hipblasFillMode_t`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        alpha (`~.hipblasDoubleComplex`/`~.object`):
            (undocumented)

        x (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        y (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        incy (`~.int`):
            (undocumented)

        AP (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")
    _hipblasZher2Batched_64__retval = hipblasStatus_t(chipblas.hipblasZher2Batched_64(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,uplo.value,n,
        hipblasDoubleComplex.fromPyobj(alpha).getElementPtr(),
        <chipblas.hipblasDoubleComplex *const*>hip._util.types.Pointer.fromPyobj(x)._ptr,incx,
        <chipblas.hipblasDoubleComplex *const*>hip._util.types.Pointer.fromPyobj(y)._ptr,incy,
        <chipblas.hipblasDoubleComplex *const*>hip._util.types.Pointer.fromPyobj(AP)._ptr,lda,batchCount))
    return (_hipblasZher2Batched_64__retval,)


@cython.embedsignature(True)
def hipblasCher2Batched_v2_64(object handle, object uplo, long n, object alpha, object x, long incx, object y, long incy, object AP, long lda, long batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        uplo (`~.hipblasFillMode_t`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        alpha (`~.float2`/`~.object`):
            (undocumented)

        x (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        y (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        incy (`~.int`):
            (undocumented)

        AP (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")
    _hipblasCher2Batched_v2_64__retval = hipblasStatus_t(chipblas.hipblasCher2Batched_v2_64(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,uplo.value,n,
        float2.fromPyobj(alpha).getElementPtr(),
        <chipblas.float2 *const*>hip._util.types.Pointer.fromPyobj(x)._ptr,incx,
        <chipblas.float2 *const*>hip._util.types.Pointer.fromPyobj(y)._ptr,incy,
        <chipblas.float2 *const*>hip._util.types.Pointer.fromPyobj(AP)._ptr,lda,batchCount))
    return (_hipblasCher2Batched_v2_64__retval,)


@cython.embedsignature(True)
def hipblasZher2Batched_v2_64(object handle, object uplo, long n, object alpha, object x, long incx, object y, long incy, object AP, long lda, long batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        uplo (`~.hipblasFillMode_t`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        alpha (`~.double2`/`~.object`):
            (undocumented)

        x (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        y (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        incy (`~.int`):
            (undocumented)

        AP (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")
    _hipblasZher2Batched_v2_64__retval = hipblasStatus_t(chipblas.hipblasZher2Batched_v2_64(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,uplo.value,n,
        double2.fromPyobj(alpha).getElementPtr(),
        <chipblas.double2 *const*>hip._util.types.Pointer.fromPyobj(x)._ptr,incx,
        <chipblas.double2 *const*>hip._util.types.Pointer.fromPyobj(y)._ptr,incy,
        <chipblas.double2 *const*>hip._util.types.Pointer.fromPyobj(AP)._ptr,lda,batchCount))
    return (_hipblasZher2Batched_v2_64__retval,)


@cython.embedsignature(True)
def hipblasCher2StridedBatched(object handle, object uplo, int n, object alpha, object x, int incx, long stridex, object y, int incy, long stridey, object AP, int lda, long strideA, int batchCount):
    r"""BLAS Level 2 API

    @{

    her2StridedBatched performs the matrix-vector operations

    A_i := A_i + alpha*x_i*y_i**H + conj(alpha)*y_i*x_i**H

    where alpha is a complex scalar, x_i and y_i are vectors, and A_i is an
    n by n Hermitian matrix for each batch in i = [1, batchCount].

    - Supported precisions in rocBLAS : c,z
    - Supported precisions in cuBLAS  : No support

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`) -- *IN*:
            [hipblasHandle_t]
            handle to the hipblas library context queue.

        uplo (`~.hipblasFillMode_t`) -- *IN*:
            [hipblasFillMode_t]
            specifies whether the upper 'HIPBLAS_FILL_MODE_UPPER' or lower 'HIPBLAS_FILL_MODE_LOWER'
            HIPBLAS_FILL_MODE_UPPER: The upper triangular part of each A_i is supplied.
            HIPBLAS_FILL_MODE_LOWER: The lower triangular part of each A_i is supplied.

        n (`~.int`) -- *IN*:
            [int]
            the number of rows and columns of each matrix A_i, must be at least 0.

        alpha (`~.hipblasComplex`/`~.object`) -- *IN*:
            device pointer or host pointer to scalar alpha.

        x (`~.hipblasComplex`/`~.object`) -- *IN*:
            device pointer pointing to the first vector x_1.

        incx (`~.int`) -- *IN*:
            [int]
            specifies the increment for the elements of each x_i.

        stridex (`~.int`) -- *IN*:
            [hipblasStride]
            specifies the stride between the beginning of one vector (x_i) and the next (x_i+1).

        y (`~.hipblasComplex`/`~.object`) -- *IN*:
            device pointer pointing to the first vector y_i.

        incy (`~.int`) -- *IN*:
            [int]
            specifies the increment for the elements of each y_i.

        stridey (`~.int`) -- *IN*:
            [hipblasStride]
            specifies the stride between the beginning of one vector (y_i) and the next (y_i+1).

        AP (`~.hipblasComplex`/`~.object`) -- *INOUT*:
            device pointer pointing to the first matrix (A_1). Stores the specified triangular portion of
              each Hermitian matrix A_i.
              if uplo == HIPBLAS_FILL_MODE_UPPER:
                The upper triangular portion of each Hermitian matrix A_i is supplied. The lower triangular
                portion of each A_i will not be touched.
            if uplo == HIPBLAS_FILL_MODE_LOWER:
                The lower triangular portion of each Hermitian matrix A_i is supplied. The upper triangular
                portion of each A_i will not be touched.
            Note that the imaginary part of the diagonal elements are not accessed and are assumed
            to be 0.

        lda (`~.int`) -- *IN*:
            [int]
            specifies the leading dimension of each A_i. Must be at least max(lda, 1).

        strideA (`~.int`) -- *IN*:
            [hipblasStride]
            specifies the stride between the beginning of one matrix (A_i) and the next (A_i+1).

        batchCount (`~.int`) -- *IN*:
            [int]
            number of instances in the batch.
    """
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")
    _hipblasCher2StridedBatched__retval = hipblasStatus_t(chipblas.hipblasCher2StridedBatched(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,uplo.value,n,
        hipblasComplex.fromPyobj(alpha).getElementPtr(),
        hipblasComplex.fromPyobj(x).getElementPtr(),incx,stridex,
        hipblasComplex.fromPyobj(y).getElementPtr(),incy,stridey,
        hipblasComplex.fromPyobj(AP).getElementPtr(),lda,strideA,batchCount))
    return (_hipblasCher2StridedBatched__retval,)


@cython.embedsignature(True)
def hipblasZher2StridedBatched(object handle, object uplo, int n, object alpha, object x, int incx, long stridex, object y, int incy, long stridey, object AP, int lda, long strideA, int batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        uplo (`~.hipblasFillMode_t`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        alpha (`~.hipblasDoubleComplex`/`~.object`):
            (undocumented)

        x (`~.hipblasDoubleComplex`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        stridex (`~.int`):
            (undocumented)

        y (`~.hipblasDoubleComplex`/`~.object`):
            (undocumented)

        incy (`~.int`):
            (undocumented)

        stridey (`~.int`):
            (undocumented)

        AP (`~.hipblasDoubleComplex`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        strideA (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")
    _hipblasZher2StridedBatched__retval = hipblasStatus_t(chipblas.hipblasZher2StridedBatched(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,uplo.value,n,
        hipblasDoubleComplex.fromPyobj(alpha).getElementPtr(),
        hipblasDoubleComplex.fromPyobj(x).getElementPtr(),incx,stridex,
        hipblasDoubleComplex.fromPyobj(y).getElementPtr(),incy,stridey,
        hipblasDoubleComplex.fromPyobj(AP).getElementPtr(),lda,strideA,batchCount))
    return (_hipblasZher2StridedBatched__retval,)


@cython.embedsignature(True)
def hipblasCher2StridedBatched_v2(object handle, object uplo, int n, object alpha, object x, int incx, long stridex, object y, int incy, long stridey, object AP, int lda, long strideA, int batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        uplo (`~.hipblasFillMode_t`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        alpha (`~.float2`/`~.object`):
            (undocumented)

        x (`~.float2`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        stridex (`~.int`):
            (undocumented)

        y (`~.float2`/`~.object`):
            (undocumented)

        incy (`~.int`):
            (undocumented)

        stridey (`~.int`):
            (undocumented)

        AP (`~.float2`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        strideA (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")
    _hipblasCher2StridedBatched_v2__retval = hipblasStatus_t(chipblas.hipblasCher2StridedBatched_v2(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,uplo.value,n,
        float2.fromPyobj(alpha).getElementPtr(),
        float2.fromPyobj(x).getElementPtr(),incx,stridex,
        float2.fromPyobj(y).getElementPtr(),incy,stridey,
        float2.fromPyobj(AP).getElementPtr(),lda,strideA,batchCount))
    return (_hipblasCher2StridedBatched_v2__retval,)


@cython.embedsignature(True)
def hipblasZher2StridedBatched_v2(object handle, object uplo, int n, object alpha, object x, int incx, long stridex, object y, int incy, long stridey, object AP, int lda, long strideA, int batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        uplo (`~.hipblasFillMode_t`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        alpha (`~.double2`/`~.object`):
            (undocumented)

        x (`~.double2`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        stridex (`~.int`):
            (undocumented)

        y (`~.double2`/`~.object`):
            (undocumented)

        incy (`~.int`):
            (undocumented)

        stridey (`~.int`):
            (undocumented)

        AP (`~.double2`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        strideA (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")
    _hipblasZher2StridedBatched_v2__retval = hipblasStatus_t(chipblas.hipblasZher2StridedBatched_v2(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,uplo.value,n,
        double2.fromPyobj(alpha).getElementPtr(),
        double2.fromPyobj(x).getElementPtr(),incx,stridex,
        double2.fromPyobj(y).getElementPtr(),incy,stridey,
        double2.fromPyobj(AP).getElementPtr(),lda,strideA,batchCount))
    return (_hipblasZher2StridedBatched_v2__retval,)


@cython.embedsignature(True)
def hipblasCher2StridedBatched_64(object handle, object uplo, long n, object alpha, object x, long incx, long stridex, object y, long incy, long stridey, object AP, long lda, long strideA, long batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        uplo (`~.hipblasFillMode_t`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        alpha (`~.hipblasComplex`/`~.object`):
            (undocumented)

        x (`~.hipblasComplex`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        stridex (`~.int`):
            (undocumented)

        y (`~.hipblasComplex`/`~.object`):
            (undocumented)

        incy (`~.int`):
            (undocumented)

        stridey (`~.int`):
            (undocumented)

        AP (`~.hipblasComplex`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        strideA (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")
    _hipblasCher2StridedBatched_64__retval = hipblasStatus_t(chipblas.hipblasCher2StridedBatched_64(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,uplo.value,n,
        hipblasComplex.fromPyobj(alpha).getElementPtr(),
        hipblasComplex.fromPyobj(x).getElementPtr(),incx,stridex,
        hipblasComplex.fromPyobj(y).getElementPtr(),incy,stridey,
        hipblasComplex.fromPyobj(AP).getElementPtr(),lda,strideA,batchCount))
    return (_hipblasCher2StridedBatched_64__retval,)


@cython.embedsignature(True)
def hipblasZher2StridedBatched_64(object handle, object uplo, long n, object alpha, object x, long incx, long stridex, object y, long incy, long stridey, object AP, long lda, long strideA, long batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        uplo (`~.hipblasFillMode_t`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        alpha (`~.hipblasDoubleComplex`/`~.object`):
            (undocumented)

        x (`~.hipblasDoubleComplex`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        stridex (`~.int`):
            (undocumented)

        y (`~.hipblasDoubleComplex`/`~.object`):
            (undocumented)

        incy (`~.int`):
            (undocumented)

        stridey (`~.int`):
            (undocumented)

        AP (`~.hipblasDoubleComplex`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        strideA (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")
    _hipblasZher2StridedBatched_64__retval = hipblasStatus_t(chipblas.hipblasZher2StridedBatched_64(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,uplo.value,n,
        hipblasDoubleComplex.fromPyobj(alpha).getElementPtr(),
        hipblasDoubleComplex.fromPyobj(x).getElementPtr(),incx,stridex,
        hipblasDoubleComplex.fromPyobj(y).getElementPtr(),incy,stridey,
        hipblasDoubleComplex.fromPyobj(AP).getElementPtr(),lda,strideA,batchCount))
    return (_hipblasZher2StridedBatched_64__retval,)


@cython.embedsignature(True)
def hipblasCher2StridedBatched_v2_64(object handle, object uplo, long n, object alpha, object x, long incx, long stridex, object y, long incy, long stridey, object AP, long lda, long strideA, long batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        uplo (`~.hipblasFillMode_t`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        alpha (`~.float2`/`~.object`):
            (undocumented)

        x (`~.float2`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        stridex (`~.int`):
            (undocumented)

        y (`~.float2`/`~.object`):
            (undocumented)

        incy (`~.int`):
            (undocumented)

        stridey (`~.int`):
            (undocumented)

        AP (`~.float2`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        strideA (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")
    _hipblasCher2StridedBatched_v2_64__retval = hipblasStatus_t(chipblas.hipblasCher2StridedBatched_v2_64(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,uplo.value,n,
        float2.fromPyobj(alpha).getElementPtr(),
        float2.fromPyobj(x).getElementPtr(),incx,stridex,
        float2.fromPyobj(y).getElementPtr(),incy,stridey,
        float2.fromPyobj(AP).getElementPtr(),lda,strideA,batchCount))
    return (_hipblasCher2StridedBatched_v2_64__retval,)


@cython.embedsignature(True)
def hipblasZher2StridedBatched_v2_64(object handle, object uplo, long n, object alpha, object x, long incx, long stridex, object y, long incy, long stridey, object AP, long lda, long strideA, long batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        uplo (`~.hipblasFillMode_t`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        alpha (`~.double2`/`~.object`):
            (undocumented)

        x (`~.double2`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        stridex (`~.int`):
            (undocumented)

        y (`~.double2`/`~.object`):
            (undocumented)

        incy (`~.int`):
            (undocumented)

        stridey (`~.int`):
            (undocumented)

        AP (`~.double2`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        strideA (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")
    _hipblasZher2StridedBatched_v2_64__retval = hipblasStatus_t(chipblas.hipblasZher2StridedBatched_v2_64(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,uplo.value,n,
        double2.fromPyobj(alpha).getElementPtr(),
        double2.fromPyobj(x).getElementPtr(),incx,stridex,
        double2.fromPyobj(y).getElementPtr(),incy,stridey,
        double2.fromPyobj(AP).getElementPtr(),lda,strideA,batchCount))
    return (_hipblasZher2StridedBatched_v2_64__retval,)


@cython.embedsignature(True)
def hipblasChpmv(object handle, object uplo, int n, object alpha, object AP, object x, int incx, object beta, object y, int incy):
    r"""BLAS Level 2 API

    @{

    hpmv performs the matrix-vector operation

    y := alpha*A*x + beta*y

    where alpha and beta are scalars, x and y are n element vectors and A is an
    n by n Hermitian matrix, supplied in packed form (see description below).

    - Supported precisions in rocBLAS : c,z
    - Supported precisions in cuBLAS  : c,z

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`) -- *IN*:
            [hipblasHandle_t]
            handle to the hipblas library context queue.

        uplo (`~.hipblasFillMode_t`) -- *IN*:
            [hipblasFillMode_t]
            HIPBLAS_FILL_MODE_UPPER: the upper triangular part of the Hermitian matrix A is supplied in AP.
            HIPBLAS_FILL_MODE_LOWER: the lower triangular part of the Hermitian matrix A is supplied in AP.

        n (`~.int`) -- *IN*:
            [int]
            the order of the matrix A, must be >= 0.

        alpha (`~.hipblasComplex`/`~.object`) -- *IN*:
            device pointer or host pointer to scalar alpha.

        AP (`~.hipblasComplex`/`~.object`) -- *IN*:
            device pointer storing the packed version of the specified triangular portion of
              the Hermitian matrix A. Of at least size ((n * (n + 1)) / 2).
              if uplo == HIPBLAS_FILL_MODE_UPPER:
                The upper triangular portion of the Hermitian matrix A is supplied.
                The matrix is compacted so that AP contains the triangular portion column-by-column
                so that:
                AP(0) = A(0,0)
                AP(1) = A(0,1)
                AP(2) = A(1,1), etc.
                    Ex: (HIPBLAS_FILL_MODE_UPPER; n = 3)
                        (1, 0) (2, 1) (3, 2)
                        (2,-1) (4, 0) (5,-1)    -----> [(1,0), (2,1), (4,0), (3,2), (5,-1), (6,0)]
                        (3,-2) (5, 1) (6, 0)
            if uplo == HIPBLAS_FILL_MODE_LOWER:
                The lower triangular portion of the Hermitian matrix A is supplied.
                The matrix is compacted so that AP contains the triangular portion column-by-column
                so that:
                AP(0) = A(0,0)
                AP(1) = A(1,0)
                AP(2) = A(2,1), etc.
                    Ex: (HIPBLAS_FILL_MODE_LOWER; n = 3)
                        (1, 0) (2, 1) (3, 2)
                        (2,-1) (4, 0) (5,-1)    -----> [(1,0), (2,-1), (3,-2), (4,0), (5,1), (6,0)]
                        (3,-2) (5, 1) (6, 0)
            Note that the imaginary part of the diagonal elements are not accessed and are assumed
            to be 0.

        x (`~.hipblasComplex`/`~.object`) -- *IN*:
            device pointer storing vector x.

        incx (`~.int`) -- *IN*:
            [int]
            specifies the increment for the elements of x.

        beta (`~.hipblasComplex`/`~.object`) -- *IN*:
            device pointer or host pointer to scalar beta.

        y (`~.hipblasComplex`/`~.object`) -- *INOUT*:
            device pointer storing vector y.

        incy (`~.int`) -- *IN*:
            [int]
            specifies the increment for the elements of y.
    """
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")
    _hipblasChpmv__retval = hipblasStatus_t(chipblas.hipblasChpmv(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,uplo.value,n,
        hipblasComplex.fromPyobj(alpha).getElementPtr(),
        hipblasComplex.fromPyobj(AP).getElementPtr(),
        hipblasComplex.fromPyobj(x).getElementPtr(),incx,
        hipblasComplex.fromPyobj(beta).getElementPtr(),
        hipblasComplex.fromPyobj(y).getElementPtr(),incy))
    return (_hipblasChpmv__retval,)


@cython.embedsignature(True)
def hipblasZhpmv(object handle, object uplo, int n, object alpha, object AP, object x, int incx, object beta, object y, int incy):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        uplo (`~.hipblasFillMode_t`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        alpha (`~.hipblasDoubleComplex`/`~.object`):
            (undocumented)

        AP (`~.hipblasDoubleComplex`/`~.object`):
            (undocumented)

        x (`~.hipblasDoubleComplex`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        beta (`~.hipblasDoubleComplex`/`~.object`):
            (undocumented)

        y (`~.hipblasDoubleComplex`/`~.object`):
            (undocumented)

        incy (`~.int`):
            (undocumented)
    """
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")
    _hipblasZhpmv__retval = hipblasStatus_t(chipblas.hipblasZhpmv(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,uplo.value,n,
        hipblasDoubleComplex.fromPyobj(alpha).getElementPtr(),
        hipblasDoubleComplex.fromPyobj(AP).getElementPtr(),
        hipblasDoubleComplex.fromPyobj(x).getElementPtr(),incx,
        hipblasDoubleComplex.fromPyobj(beta).getElementPtr(),
        hipblasDoubleComplex.fromPyobj(y).getElementPtr(),incy))
    return (_hipblasZhpmv__retval,)


@cython.embedsignature(True)
def hipblasChpmv_v2(object handle, object uplo, int n, object alpha, object AP, object x, int incx, object beta, object y, int incy):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        uplo (`~.hipblasFillMode_t`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        alpha (`~.float2`/`~.object`):
            (undocumented)

        AP (`~.float2`/`~.object`):
            (undocumented)

        x (`~.float2`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        beta (`~.float2`/`~.object`):
            (undocumented)

        y (`~.float2`/`~.object`):
            (undocumented)

        incy (`~.int`):
            (undocumented)
    """
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")
    _hipblasChpmv_v2__retval = hipblasStatus_t(chipblas.hipblasChpmv_v2(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,uplo.value,n,
        float2.fromPyobj(alpha).getElementPtr(),
        float2.fromPyobj(AP).getElementPtr(),
        float2.fromPyobj(x).getElementPtr(),incx,
        float2.fromPyobj(beta).getElementPtr(),
        float2.fromPyobj(y).getElementPtr(),incy))
    return (_hipblasChpmv_v2__retval,)


@cython.embedsignature(True)
def hipblasZhpmv_v2(object handle, object uplo, int n, object alpha, object AP, object x, int incx, object beta, object y, int incy):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        uplo (`~.hipblasFillMode_t`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        alpha (`~.double2`/`~.object`):
            (undocumented)

        AP (`~.double2`/`~.object`):
            (undocumented)

        x (`~.double2`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        beta (`~.double2`/`~.object`):
            (undocumented)

        y (`~.double2`/`~.object`):
            (undocumented)

        incy (`~.int`):
            (undocumented)
    """
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")
    _hipblasZhpmv_v2__retval = hipblasStatus_t(chipblas.hipblasZhpmv_v2(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,uplo.value,n,
        double2.fromPyobj(alpha).getElementPtr(),
        double2.fromPyobj(AP).getElementPtr(),
        double2.fromPyobj(x).getElementPtr(),incx,
        double2.fromPyobj(beta).getElementPtr(),
        double2.fromPyobj(y).getElementPtr(),incy))
    return (_hipblasZhpmv_v2__retval,)


@cython.embedsignature(True)
def hipblasChpmv_64(object handle, object uplo, long n, object alpha, object AP, object x, long incx, object beta, object y, long incy):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        uplo (`~.hipblasFillMode_t`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        alpha (`~.hipblasComplex`/`~.object`):
            (undocumented)

        AP (`~.hipblasComplex`/`~.object`):
            (undocumented)

        x (`~.hipblasComplex`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        beta (`~.hipblasComplex`/`~.object`):
            (undocumented)

        y (`~.hipblasComplex`/`~.object`):
            (undocumented)

        incy (`~.int`):
            (undocumented)
    """
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")
    _hipblasChpmv_64__retval = hipblasStatus_t(chipblas.hipblasChpmv_64(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,uplo.value,n,
        hipblasComplex.fromPyobj(alpha).getElementPtr(),
        hipblasComplex.fromPyobj(AP).getElementPtr(),
        hipblasComplex.fromPyobj(x).getElementPtr(),incx,
        hipblasComplex.fromPyobj(beta).getElementPtr(),
        hipblasComplex.fromPyobj(y).getElementPtr(),incy))
    return (_hipblasChpmv_64__retval,)


@cython.embedsignature(True)
def hipblasZhpmv_64(object handle, object uplo, long n, object alpha, object AP, object x, long incx, object beta, object y, long incy):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        uplo (`~.hipblasFillMode_t`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        alpha (`~.hipblasDoubleComplex`/`~.object`):
            (undocumented)

        AP (`~.hipblasDoubleComplex`/`~.object`):
            (undocumented)

        x (`~.hipblasDoubleComplex`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        beta (`~.hipblasDoubleComplex`/`~.object`):
            (undocumented)

        y (`~.hipblasDoubleComplex`/`~.object`):
            (undocumented)

        incy (`~.int`):
            (undocumented)
    """
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")
    _hipblasZhpmv_64__retval = hipblasStatus_t(chipblas.hipblasZhpmv_64(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,uplo.value,n,
        hipblasDoubleComplex.fromPyobj(alpha).getElementPtr(),
        hipblasDoubleComplex.fromPyobj(AP).getElementPtr(),
        hipblasDoubleComplex.fromPyobj(x).getElementPtr(),incx,
        hipblasDoubleComplex.fromPyobj(beta).getElementPtr(),
        hipblasDoubleComplex.fromPyobj(y).getElementPtr(),incy))
    return (_hipblasZhpmv_64__retval,)


@cython.embedsignature(True)
def hipblasChpmv_v2_64(object handle, object uplo, long n, object alpha, object AP, object x, long incx, object beta, object y, long incy):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        uplo (`~.hipblasFillMode_t`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        alpha (`~.float2`/`~.object`):
            (undocumented)

        AP (`~.float2`/`~.object`):
            (undocumented)

        x (`~.float2`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        beta (`~.float2`/`~.object`):
            (undocumented)

        y (`~.float2`/`~.object`):
            (undocumented)

        incy (`~.int`):
            (undocumented)
    """
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")
    _hipblasChpmv_v2_64__retval = hipblasStatus_t(chipblas.hipblasChpmv_v2_64(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,uplo.value,n,
        float2.fromPyobj(alpha).getElementPtr(),
        float2.fromPyobj(AP).getElementPtr(),
        float2.fromPyobj(x).getElementPtr(),incx,
        float2.fromPyobj(beta).getElementPtr(),
        float2.fromPyobj(y).getElementPtr(),incy))
    return (_hipblasChpmv_v2_64__retval,)


@cython.embedsignature(True)
def hipblasZhpmv_v2_64(object handle, object uplo, long n, object alpha, object AP, object x, long incx, object beta, object y, long incy):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        uplo (`~.hipblasFillMode_t`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        alpha (`~.double2`/`~.object`):
            (undocumented)

        AP (`~.double2`/`~.object`):
            (undocumented)

        x (`~.double2`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        beta (`~.double2`/`~.object`):
            (undocumented)

        y (`~.double2`/`~.object`):
            (undocumented)

        incy (`~.int`):
            (undocumented)
    """
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")
    _hipblasZhpmv_v2_64__retval = hipblasStatus_t(chipblas.hipblasZhpmv_v2_64(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,uplo.value,n,
        double2.fromPyobj(alpha).getElementPtr(),
        double2.fromPyobj(AP).getElementPtr(),
        double2.fromPyobj(x).getElementPtr(),incx,
        double2.fromPyobj(beta).getElementPtr(),
        double2.fromPyobj(y).getElementPtr(),incy))
    return (_hipblasZhpmv_v2_64__retval,)


@cython.embedsignature(True)
def hipblasChpmvBatched(object handle, object uplo, int n, object alpha, object AP, object x, int incx, object beta, object y, int incy, int batchCount):
    r"""BLAS Level 2 API

    @{

    hpmvBatched performs the matrix-vector operation

    y_i := alpha*A_i*x_i + beta*y_i

    where alpha and beta are scalars, x_i and y_i are n element vectors and A_i is an
    n by n Hermitian matrix, supplied in packed form (see description below),
    for each batch in i = [1, batchCount].

    - Supported precisions in rocBLAS : c,z
    - Supported precisions in cuBLAS  : No support

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`) -- *IN*:
            [hipblasHandle_t]
            handle to the hipblas library context queue.

        uplo (`~.hipblasFillMode_t`) -- *IN*:
            [hipblasFillMode_t]
            HIPBLAS_FILL_MODE_UPPER: the upper triangular part of each Hermitian matrix A_i is supplied in AP.
            HIPBLAS_FILL_MODE_LOWER: the lower triangular part of each Hermitian matrix A_i is supplied in AP.

        n (`~.int`) -- *IN*:
            [int]
            the order of each matrix A_i.

        alpha (`~.hipblasComplex`/`~.object`) -- *IN*:
            device pointer or host pointer to scalar alpha.

        AP (`~.hip._util.types.Pointer`/`~.object`) -- *IN*:
            device pointer of device pointers storing the packed version of the specified triangular
                portion of each Hermitian matrix A_i. Each A_i is of at least size ((n * (n + 1)) / 2).
                if uplo == HIPBLAS_FILL_MODE_UPPER:
                The upper triangular portion of each Hermitian matrix A_i is supplied.
                The matrix is compacted so that each AP_i contains the triangular portion column-by-column
                so that:
                AP(0) = A(0,0)
                AP(1) = A(0,1)
                AP(2) = A(1,1), etc.
                    Ex: (HIPBLAS_FILL_MODE_UPPER; n = 3)
                        (1, 0) (2, 1) (3, 2)
                        (2,-1) (4, 0) (5,-1)    -----> [(1,0), (2,1), (4,0), (3,2), (5,-1), (6,0)]
                        (3,-2) (5, 1) (6, 0)
            if uplo == HIPBLAS_FILL_MODE_LOWER:
                The lower triangular portion of each Hermitian matrix A_i is supplied.
                The matrix is compacted so that each AP_i contains the triangular portion column-by-column
                so that:
                AP(0) = A(0,0)
                AP(1) = A(1,0)
                AP(2) = A(2,1), etc.
                    Ex: (HIPBLAS_FILL_MODE_LOWER; n = 3)
                        (1, 0) (2, 1) (3, 2)
                        (2,-1) (4, 0) (5,-1)    -----> [(1,0), (2,-1), (3,-2), (4,0), (5,1), (6,0)]
                        (3,-2) (5, 1) (6, 0)
            Note that the imaginary part of the diagonal elements are not accessed and are assumed
            to be 0.

        x (`~.hip._util.types.Pointer`/`~.object`) -- *IN*:
            device array of device pointers storing each vector x_i.

        incx (`~.int`) -- *IN*:
            [int]
            specifies the increment for the elements of each x_i.

        beta (`~.hipblasComplex`/`~.object`) -- *IN*:
            device pointer or host pointer to scalar beta.

        y (`~.hip._util.types.Pointer`/`~.object`) -- *INOUT*:
            device array of device pointers storing each vector y_i.

        incy (`~.int`) -- *IN*:
            [int]
            specifies the increment for the elements of y.

        batchCount (`~.int`) -- *IN*:
            [int]
            number of instances in the batch.
    """
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")
    _hipblasChpmvBatched__retval = hipblasStatus_t(chipblas.hipblasChpmvBatched(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,uplo.value,n,
        hipblasComplex.fromPyobj(alpha).getElementPtr(),
        <chipblas.hipblasComplex *const*>hip._util.types.Pointer.fromPyobj(AP)._ptr,
        <chipblas.hipblasComplex *const*>hip._util.types.Pointer.fromPyobj(x)._ptr,incx,
        hipblasComplex.fromPyobj(beta).getElementPtr(),
        <chipblas.hipblasComplex *const*>hip._util.types.Pointer.fromPyobj(y)._ptr,incy,batchCount))
    return (_hipblasChpmvBatched__retval,)


@cython.embedsignature(True)
def hipblasZhpmvBatched(object handle, object uplo, int n, object alpha, object AP, object x, int incx, object beta, object y, int incy, int batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        uplo (`~.hipblasFillMode_t`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        alpha (`~.hipblasDoubleComplex`/`~.object`):
            (undocumented)

        AP (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        x (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        beta (`~.hipblasDoubleComplex`/`~.object`):
            (undocumented)

        y (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        incy (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")
    _hipblasZhpmvBatched__retval = hipblasStatus_t(chipblas.hipblasZhpmvBatched(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,uplo.value,n,
        hipblasDoubleComplex.fromPyobj(alpha).getElementPtr(),
        <chipblas.hipblasDoubleComplex *const*>hip._util.types.Pointer.fromPyobj(AP)._ptr,
        <chipblas.hipblasDoubleComplex *const*>hip._util.types.Pointer.fromPyobj(x)._ptr,incx,
        hipblasDoubleComplex.fromPyobj(beta).getElementPtr(),
        <chipblas.hipblasDoubleComplex *const*>hip._util.types.Pointer.fromPyobj(y)._ptr,incy,batchCount))
    return (_hipblasZhpmvBatched__retval,)


@cython.embedsignature(True)
def hipblasChpmvBatched_v2(object handle, object uplo, int n, object alpha, object AP, object x, int incx, object beta, object y, int incy, int batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        uplo (`~.hipblasFillMode_t`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        alpha (`~.float2`/`~.object`):
            (undocumented)

        AP (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        x (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        beta (`~.float2`/`~.object`):
            (undocumented)

        y (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        incy (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")
    _hipblasChpmvBatched_v2__retval = hipblasStatus_t(chipblas.hipblasChpmvBatched_v2(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,uplo.value,n,
        float2.fromPyobj(alpha).getElementPtr(),
        <chipblas.float2 *const*>hip._util.types.Pointer.fromPyobj(AP)._ptr,
        <chipblas.float2 *const*>hip._util.types.Pointer.fromPyobj(x)._ptr,incx,
        float2.fromPyobj(beta).getElementPtr(),
        <chipblas.float2 *const*>hip._util.types.Pointer.fromPyobj(y)._ptr,incy,batchCount))
    return (_hipblasChpmvBatched_v2__retval,)


@cython.embedsignature(True)
def hipblasZhpmvBatched_v2(object handle, object uplo, int n, object alpha, object AP, object x, int incx, object beta, object y, int incy, int batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        uplo (`~.hipblasFillMode_t`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        alpha (`~.double2`/`~.object`):
            (undocumented)

        AP (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        x (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        beta (`~.double2`/`~.object`):
            (undocumented)

        y (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        incy (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")
    _hipblasZhpmvBatched_v2__retval = hipblasStatus_t(chipblas.hipblasZhpmvBatched_v2(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,uplo.value,n,
        double2.fromPyobj(alpha).getElementPtr(),
        <chipblas.double2 *const*>hip._util.types.Pointer.fromPyobj(AP)._ptr,
        <chipblas.double2 *const*>hip._util.types.Pointer.fromPyobj(x)._ptr,incx,
        double2.fromPyobj(beta).getElementPtr(),
        <chipblas.double2 *const*>hip._util.types.Pointer.fromPyobj(y)._ptr,incy,batchCount))
    return (_hipblasZhpmvBatched_v2__retval,)


@cython.embedsignature(True)
def hipblasChpmvBatched_64(object handle, object uplo, long n, object alpha, object AP, object x, long incx, object beta, object y, long incy, long batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        uplo (`~.hipblasFillMode_t`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        alpha (`~.hipblasComplex`/`~.object`):
            (undocumented)

        AP (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        x (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        beta (`~.hipblasComplex`/`~.object`):
            (undocumented)

        y (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        incy (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")
    _hipblasChpmvBatched_64__retval = hipblasStatus_t(chipblas.hipblasChpmvBatched_64(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,uplo.value,n,
        hipblasComplex.fromPyobj(alpha).getElementPtr(),
        <chipblas.hipblasComplex *const*>hip._util.types.Pointer.fromPyobj(AP)._ptr,
        <chipblas.hipblasComplex *const*>hip._util.types.Pointer.fromPyobj(x)._ptr,incx,
        hipblasComplex.fromPyobj(beta).getElementPtr(),
        <chipblas.hipblasComplex *const*>hip._util.types.Pointer.fromPyobj(y)._ptr,incy,batchCount))
    return (_hipblasChpmvBatched_64__retval,)


@cython.embedsignature(True)
def hipblasZhpmvBatched_64(object handle, object uplo, long n, object alpha, object AP, object x, long incx, object beta, object y, long incy, long batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        uplo (`~.hipblasFillMode_t`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        alpha (`~.hipblasDoubleComplex`/`~.object`):
            (undocumented)

        AP (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        x (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        beta (`~.hipblasDoubleComplex`/`~.object`):
            (undocumented)

        y (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        incy (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")
    _hipblasZhpmvBatched_64__retval = hipblasStatus_t(chipblas.hipblasZhpmvBatched_64(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,uplo.value,n,
        hipblasDoubleComplex.fromPyobj(alpha).getElementPtr(),
        <chipblas.hipblasDoubleComplex *const*>hip._util.types.Pointer.fromPyobj(AP)._ptr,
        <chipblas.hipblasDoubleComplex *const*>hip._util.types.Pointer.fromPyobj(x)._ptr,incx,
        hipblasDoubleComplex.fromPyobj(beta).getElementPtr(),
        <chipblas.hipblasDoubleComplex *const*>hip._util.types.Pointer.fromPyobj(y)._ptr,incy,batchCount))
    return (_hipblasZhpmvBatched_64__retval,)


@cython.embedsignature(True)
def hipblasChpmvBatched_v2_64(object handle, object uplo, long n, object alpha, object AP, object x, long incx, object beta, object y, long incy, long batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        uplo (`~.hipblasFillMode_t`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        alpha (`~.float2`/`~.object`):
            (undocumented)

        AP (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        x (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        beta (`~.float2`/`~.object`):
            (undocumented)

        y (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        incy (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")
    _hipblasChpmvBatched_v2_64__retval = hipblasStatus_t(chipblas.hipblasChpmvBatched_v2_64(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,uplo.value,n,
        float2.fromPyobj(alpha).getElementPtr(),
        <chipblas.float2 *const*>hip._util.types.Pointer.fromPyobj(AP)._ptr,
        <chipblas.float2 *const*>hip._util.types.Pointer.fromPyobj(x)._ptr,incx,
        float2.fromPyobj(beta).getElementPtr(),
        <chipblas.float2 *const*>hip._util.types.Pointer.fromPyobj(y)._ptr,incy,batchCount))
    return (_hipblasChpmvBatched_v2_64__retval,)


@cython.embedsignature(True)
def hipblasZhpmvBatched_v2_64(object handle, object uplo, long n, object alpha, object AP, object x, long incx, object beta, object y, long incy, long batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        uplo (`~.hipblasFillMode_t`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        alpha (`~.double2`/`~.object`):
            (undocumented)

        AP (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        x (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        beta (`~.double2`/`~.object`):
            (undocumented)

        y (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        incy (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")
    _hipblasZhpmvBatched_v2_64__retval = hipblasStatus_t(chipblas.hipblasZhpmvBatched_v2_64(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,uplo.value,n,
        double2.fromPyobj(alpha).getElementPtr(),
        <chipblas.double2 *const*>hip._util.types.Pointer.fromPyobj(AP)._ptr,
        <chipblas.double2 *const*>hip._util.types.Pointer.fromPyobj(x)._ptr,incx,
        double2.fromPyobj(beta).getElementPtr(),
        <chipblas.double2 *const*>hip._util.types.Pointer.fromPyobj(y)._ptr,incy,batchCount))
    return (_hipblasZhpmvBatched_v2_64__retval,)


@cython.embedsignature(True)
def hipblasChpmvStridedBatched(object handle, object uplo, int n, object alpha, object AP, long strideA, object x, int incx, long stridex, object beta, object y, int incy, long stridey, int batchCount):
    r"""BLAS Level 2 API

    @{

    hpmvStridedBatched performs the matrix-vector operation

    y_i := alpha*A_i*x_i + beta*y_i

    where alpha and beta are scalars, x_i and y_i are n element vectors and A_i is an
    n by n Hermitian matrix, supplied in packed form (see description below),
    for each batch in i = [1, batchCount].

    - Supported precisions in rocBLAS : c,z
    - Supported precisions in cuBLAS  : No support

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`) -- *IN*:
            [hipblasHandle_t]
            handle to the hipblas library context queue.

        uplo (`~.hipblasFillMode_t`) -- *IN*:
            [hipblasFillMode_t]
            HIPBLAS_FILL_MODE_UPPER: the upper triangular part of each Hermitian matrix A_i is supplied in AP.
            HIPBLAS_FILL_MODE_LOWER: the lower triangular part of each Hermitian matrix A_i is supplied in AP.

        n (`~.int`) -- *IN*:
            [int]
            the order of each matrix A_i.

        alpha (`~.hipblasComplex`/`~.object`) -- *IN*:
            device pointer or host pointer to scalar alpha.

        AP (`~.hipblasComplex`/`~.object`) -- *IN*:
            device pointer pointing to the beginning of the first matrix (AP_1). Stores the packed
                  version of the specified triangular portion of each Hermitian matrix AP_i of size ((n * (n + 1)) / 2).
                  if uplo == HIPBLAS_FILL_MODE_UPPER:
                    The upper triangular portion of each Hermitian matrix A_i is supplied.
                    The matrix is compacted so that each AP_i contains the triangular portion column-by-column
                    so that:
                    AP(0) = A(0,0)
                    AP(1) = A(0,1)
                    AP(2) = A(1,1), etc.
                        Ex: (HIPBLAS_FILL_MODE_UPPER; n = 3)
                            (1, 0) (2, 1) (3, 2)
                            (2,-1) (4, 0) (5,-1)    -----> [(1,0), (2,1), (4,0), (3,2), (5,-1), (6,0)]
                            (3,-2) (5, 1) (6, 0)
                if uplo == HIPBLAS_FILL_MODE_LOWER:
                    The lower triangular portion of each Hermitian matrix A_i is supplied.
                    The matrix is compacted so that each AP_i contains the triangular portion column-by-column
                    so that:
                    AP(0) = A(0,0)
                    AP(1) = A(1,0)
                    AP(2) = A(2,1), etc.
                        Ex: (HIPBLAS_FILL_MODE_LOWER; n = 3)
                            (1, 0) (2, 1) (3, 2)
                            (2,-1) (4, 0) (5,-1)    -----> [(1,0), (2,-1), (3,-2), (4,0), (5,1), (6,0)]
                            (3,-2) (5, 1) (6, 0)
            Note that the imaginary part of the diagonal elements are not accessed and are assumed
            to be 0.

        strideA (`~.int`) -- *IN*:
            [hipblasStride]
            stride from the start of one matrix (AP_i) and the next one (AP_i+1).

        x (`~.hipblasComplex`/`~.object`) -- *IN*:
            device array pointing to the beginning of the first vector (x_1).

        incx (`~.int`) -- *IN*:
            [int]
            specifies the increment for the elements of each x_i.

        stridex (`~.int`) -- *IN*:
            [hipblasStride]
            stride from the start of one vector (x_i) and the next one (x_i+1).

        beta (`~.hipblasComplex`/`~.object`) -- *IN*:
            device pointer or host pointer to scalar beta.

        y (`~.hipblasComplex`/`~.object`) -- *INOUT*:
            device array pointing to the beginning of the first vector (y_1).

        incy (`~.int`) -- *IN*:
            [int]
            specifies the increment for the elements of y.

        stridey (`~.int`) -- *IN*:
            [hipblasStride]
            stride from the start of one vector (y_i) and the next one (y_i+1).

        batchCount (`~.int`) -- *IN*:
            [int]
            number of instances in the batch.
    """
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")
    _hipblasChpmvStridedBatched__retval = hipblasStatus_t(chipblas.hipblasChpmvStridedBatched(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,uplo.value,n,
        hipblasComplex.fromPyobj(alpha).getElementPtr(),
        hipblasComplex.fromPyobj(AP).getElementPtr(),strideA,
        hipblasComplex.fromPyobj(x).getElementPtr(),incx,stridex,
        hipblasComplex.fromPyobj(beta).getElementPtr(),
        hipblasComplex.fromPyobj(y).getElementPtr(),incy,stridey,batchCount))
    return (_hipblasChpmvStridedBatched__retval,)


@cython.embedsignature(True)
def hipblasZhpmvStridedBatched(object handle, object uplo, int n, object alpha, object AP, long strideA, object x, int incx, long stridex, object beta, object y, int incy, long stridey, int batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        uplo (`~.hipblasFillMode_t`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        alpha (`~.hipblasDoubleComplex`/`~.object`):
            (undocumented)

        AP (`~.hipblasDoubleComplex`/`~.object`):
            (undocumented)

        strideA (`~.int`):
            (undocumented)

        x (`~.hipblasDoubleComplex`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        stridex (`~.int`):
            (undocumented)

        beta (`~.hipblasDoubleComplex`/`~.object`):
            (undocumented)

        y (`~.hipblasDoubleComplex`/`~.object`):
            (undocumented)

        incy (`~.int`):
            (undocumented)

        stridey (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")
    _hipblasZhpmvStridedBatched__retval = hipblasStatus_t(chipblas.hipblasZhpmvStridedBatched(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,uplo.value,n,
        hipblasDoubleComplex.fromPyobj(alpha).getElementPtr(),
        hipblasDoubleComplex.fromPyobj(AP).getElementPtr(),strideA,
        hipblasDoubleComplex.fromPyobj(x).getElementPtr(),incx,stridex,
        hipblasDoubleComplex.fromPyobj(beta).getElementPtr(),
        hipblasDoubleComplex.fromPyobj(y).getElementPtr(),incy,stridey,batchCount))
    return (_hipblasZhpmvStridedBatched__retval,)


@cython.embedsignature(True)
def hipblasChpmvStridedBatched_v2(object handle, object uplo, int n, object alpha, object AP, long strideA, object x, int incx, long stridex, object beta, object y, int incy, long stridey, int batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        uplo (`~.hipblasFillMode_t`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        alpha (`~.float2`/`~.object`):
            (undocumented)

        AP (`~.float2`/`~.object`):
            (undocumented)

        strideA (`~.int`):
            (undocumented)

        x (`~.float2`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        stridex (`~.int`):
            (undocumented)

        beta (`~.float2`/`~.object`):
            (undocumented)

        y (`~.float2`/`~.object`):
            (undocumented)

        incy (`~.int`):
            (undocumented)

        stridey (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")
    _hipblasChpmvStridedBatched_v2__retval = hipblasStatus_t(chipblas.hipblasChpmvStridedBatched_v2(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,uplo.value,n,
        float2.fromPyobj(alpha).getElementPtr(),
        float2.fromPyobj(AP).getElementPtr(),strideA,
        float2.fromPyobj(x).getElementPtr(),incx,stridex,
        float2.fromPyobj(beta).getElementPtr(),
        float2.fromPyobj(y).getElementPtr(),incy,stridey,batchCount))
    return (_hipblasChpmvStridedBatched_v2__retval,)


@cython.embedsignature(True)
def hipblasZhpmvStridedBatched_v2(object handle, object uplo, int n, object alpha, object AP, long strideA, object x, int incx, long stridex, object beta, object y, int incy, long stridey, int batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        uplo (`~.hipblasFillMode_t`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        alpha (`~.double2`/`~.object`):
            (undocumented)

        AP (`~.double2`/`~.object`):
            (undocumented)

        strideA (`~.int`):
            (undocumented)

        x (`~.double2`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        stridex (`~.int`):
            (undocumented)

        beta (`~.double2`/`~.object`):
            (undocumented)

        y (`~.double2`/`~.object`):
            (undocumented)

        incy (`~.int`):
            (undocumented)

        stridey (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")
    _hipblasZhpmvStridedBatched_v2__retval = hipblasStatus_t(chipblas.hipblasZhpmvStridedBatched_v2(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,uplo.value,n,
        double2.fromPyobj(alpha).getElementPtr(),
        double2.fromPyobj(AP).getElementPtr(),strideA,
        double2.fromPyobj(x).getElementPtr(),incx,stridex,
        double2.fromPyobj(beta).getElementPtr(),
        double2.fromPyobj(y).getElementPtr(),incy,stridey,batchCount))
    return (_hipblasZhpmvStridedBatched_v2__retval,)


@cython.embedsignature(True)
def hipblasChpmvStridedBatched_64(object handle, object uplo, long n, object alpha, object AP, long strideA, object x, long incx, long stridex, object beta, object y, long incy, long stridey, long batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        uplo (`~.hipblasFillMode_t`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        alpha (`~.hipblasComplex`/`~.object`):
            (undocumented)

        AP (`~.hipblasComplex`/`~.object`):
            (undocumented)

        strideA (`~.int`):
            (undocumented)

        x (`~.hipblasComplex`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        stridex (`~.int`):
            (undocumented)

        beta (`~.hipblasComplex`/`~.object`):
            (undocumented)

        y (`~.hipblasComplex`/`~.object`):
            (undocumented)

        incy (`~.int`):
            (undocumented)

        stridey (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")
    _hipblasChpmvStridedBatched_64__retval = hipblasStatus_t(chipblas.hipblasChpmvStridedBatched_64(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,uplo.value,n,
        hipblasComplex.fromPyobj(alpha).getElementPtr(),
        hipblasComplex.fromPyobj(AP).getElementPtr(),strideA,
        hipblasComplex.fromPyobj(x).getElementPtr(),incx,stridex,
        hipblasComplex.fromPyobj(beta).getElementPtr(),
        hipblasComplex.fromPyobj(y).getElementPtr(),incy,stridey,batchCount))
    return (_hipblasChpmvStridedBatched_64__retval,)


@cython.embedsignature(True)
def hipblasZhpmvStridedBatched_64(object handle, object uplo, long n, object alpha, object AP, long strideA, object x, long incx, long stridex, object beta, object y, long incy, long stridey, long batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        uplo (`~.hipblasFillMode_t`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        alpha (`~.hipblasDoubleComplex`/`~.object`):
            (undocumented)

        AP (`~.hipblasDoubleComplex`/`~.object`):
            (undocumented)

        strideA (`~.int`):
            (undocumented)

        x (`~.hipblasDoubleComplex`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        stridex (`~.int`):
            (undocumented)

        beta (`~.hipblasDoubleComplex`/`~.object`):
            (undocumented)

        y (`~.hipblasDoubleComplex`/`~.object`):
            (undocumented)

        incy (`~.int`):
            (undocumented)

        stridey (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")
    _hipblasZhpmvStridedBatched_64__retval = hipblasStatus_t(chipblas.hipblasZhpmvStridedBatched_64(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,uplo.value,n,
        hipblasDoubleComplex.fromPyobj(alpha).getElementPtr(),
        hipblasDoubleComplex.fromPyobj(AP).getElementPtr(),strideA,
        hipblasDoubleComplex.fromPyobj(x).getElementPtr(),incx,stridex,
        hipblasDoubleComplex.fromPyobj(beta).getElementPtr(),
        hipblasDoubleComplex.fromPyobj(y).getElementPtr(),incy,stridey,batchCount))
    return (_hipblasZhpmvStridedBatched_64__retval,)


@cython.embedsignature(True)
def hipblasChpmvStridedBatched_v2_64(object handle, object uplo, long n, object alpha, object AP, long strideA, object x, long incx, long stridex, object beta, object y, long incy, long stridey, long batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        uplo (`~.hipblasFillMode_t`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        alpha (`~.float2`/`~.object`):
            (undocumented)

        AP (`~.float2`/`~.object`):
            (undocumented)

        strideA (`~.int`):
            (undocumented)

        x (`~.float2`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        stridex (`~.int`):
            (undocumented)

        beta (`~.float2`/`~.object`):
            (undocumented)

        y (`~.float2`/`~.object`):
            (undocumented)

        incy (`~.int`):
            (undocumented)

        stridey (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")
    _hipblasChpmvStridedBatched_v2_64__retval = hipblasStatus_t(chipblas.hipblasChpmvStridedBatched_v2_64(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,uplo.value,n,
        float2.fromPyobj(alpha).getElementPtr(),
        float2.fromPyobj(AP).getElementPtr(),strideA,
        float2.fromPyobj(x).getElementPtr(),incx,stridex,
        float2.fromPyobj(beta).getElementPtr(),
        float2.fromPyobj(y).getElementPtr(),incy,stridey,batchCount))
    return (_hipblasChpmvStridedBatched_v2_64__retval,)


@cython.embedsignature(True)
def hipblasZhpmvStridedBatched_v2_64(object handle, object uplo, long n, object alpha, object AP, long strideA, object x, long incx, long stridex, object beta, object y, long incy, long stridey, long batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        uplo (`~.hipblasFillMode_t`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        alpha (`~.double2`/`~.object`):
            (undocumented)

        AP (`~.double2`/`~.object`):
            (undocumented)

        strideA (`~.int`):
            (undocumented)

        x (`~.double2`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        stridex (`~.int`):
            (undocumented)

        beta (`~.double2`/`~.object`):
            (undocumented)

        y (`~.double2`/`~.object`):
            (undocumented)

        incy (`~.int`):
            (undocumented)

        stridey (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")
    _hipblasZhpmvStridedBatched_v2_64__retval = hipblasStatus_t(chipblas.hipblasZhpmvStridedBatched_v2_64(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,uplo.value,n,
        double2.fromPyobj(alpha).getElementPtr(),
        double2.fromPyobj(AP).getElementPtr(),strideA,
        double2.fromPyobj(x).getElementPtr(),incx,stridex,
        double2.fromPyobj(beta).getElementPtr(),
        double2.fromPyobj(y).getElementPtr(),incy,stridey,batchCount))
    return (_hipblasZhpmvStridedBatched_v2_64__retval,)


@cython.embedsignature(True)
def hipblasChpr(object handle, object uplo, int n, object alpha, object x, int incx, object AP):
    r"""BLAS Level 2 API

    @{

    hpr performs the matrix-vector operations

    A := A + alpha*x*x**H

    where alpha is a real scalar, x is a vector, and A is an
    n by n Hermitian matrix, supplied in packed form.

    - Supported precisions in rocBLAS : c,z
    - Supported precisions in cuBLAS  : c,z

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`) -- *IN*:
            [hipblasHandle_t]
            handle to the hipblas library context queue.

        uplo (`~.hipblasFillMode_t`) -- *IN*:
            [hipblasFillMode_t]
            specifies whether the upper 'HIPBLAS_FILL_MODE_UPPER' or lower 'HIPBLAS_FILL_MODE_LOWER'
            HIPBLAS_FILL_MODE_UPPER: The upper triangular part of A is supplied in AP.
            HIPBLAS_FILL_MODE_LOWER: The lower triangular part of A is supplied in AP.

        n (`~.int`) -- *IN*:
            [int]
            the number of rows and columns of matrix A, must be at least 0.

        alpha (`~.hip._util.types.Pointer`/`~.object`) -- *IN*:
            device pointer or host pointer to scalar alpha.

        x (`~.hipblasComplex`/`~.object`) -- *IN*:
            device pointer storing vector x.

        incx (`~.int`) -- *IN*:
            [int]
            specifies the increment for the elements of x.

        AP (`~.hipblasComplex`/`~.object`) -- *INOUT*:
            device pointer storing the packed version of the specified triangular portion of
              the Hermitian matrix A. Of at least size ((n * (n + 1)) / 2).
              if uplo == HIPBLAS_FILL_MODE_UPPER:
                The upper triangular portion of the Hermitian matrix A is supplied.
                The matrix is compacted so that AP contains the triangular portion column-by-column
                so that:
                AP(0) = A(0,0)
                AP(1) = A(0,1)
                AP(2) = A(1,1), etc.
                    Ex: (HIPBLAS_FILL_MODE_UPPER; n = 3)
                        (1, 0) (2, 1) (4,9)
                        (2,-1) (3, 0) (5,3)  -----> [(1,0), (2,1), (3,0), (4,9), (5,3), (6,0)]
                        (4,-9) (5,-3) (6,0)
            if uplo == HIPBLAS_FILL_MODE_LOWER:
                The lower triangular portion of the Hermitian matrix A is supplied.
                The matrix is compacted so that AP contains the triangular portion column-by-column
                so that:
                AP(0) = A(0,0)
                AP(1) = A(1,0)
                AP(2) = A(2,1), etc.
                    Ex: (HIPBLAS_FILL_MODE_LOWER; n = 3)
                        (1, 0) (2, 1) (4,9)
                        (2,-1) (3, 0) (5,3)  -----> [(1,0), (2,-1), (4,-9), (3,0), (5,-3), (6,0)]
                        (4,-9) (5,-3) (6,0)
            Note that the imaginary part of the diagonal elements are not accessed and are assumed
            to be 0.
    """
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")
    _hipblasChpr__retval = hipblasStatus_t(chipblas.hipblasChpr(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,uplo.value,n,
        <const float *>hip._util.types.Pointer.fromPyobj(alpha)._ptr,
        hipblasComplex.fromPyobj(x).getElementPtr(),incx,
        hipblasComplex.fromPyobj(AP).getElementPtr()))
    return (_hipblasChpr__retval,)


@cython.embedsignature(True)
def hipblasZhpr(object handle, object uplo, int n, object alpha, object x, int incx, object AP):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        uplo (`~.hipblasFillMode_t`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        alpha (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        x (`~.hipblasDoubleComplex`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        AP (`~.hipblasDoubleComplex`/`~.object`):
            (undocumented)
    """
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")
    _hipblasZhpr__retval = hipblasStatus_t(chipblas.hipblasZhpr(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,uplo.value,n,
        <const double *>hip._util.types.Pointer.fromPyobj(alpha)._ptr,
        hipblasDoubleComplex.fromPyobj(x).getElementPtr(),incx,
        hipblasDoubleComplex.fromPyobj(AP).getElementPtr()))
    return (_hipblasZhpr__retval,)


@cython.embedsignature(True)
def hipblasChpr_v2(object handle, object uplo, int n, object alpha, object x, int incx, object AP):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        uplo (`~.hipblasFillMode_t`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        alpha (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        x (`~.float2`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        AP (`~.float2`/`~.object`):
            (undocumented)
    """
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")
    _hipblasChpr_v2__retval = hipblasStatus_t(chipblas.hipblasChpr_v2(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,uplo.value,n,
        <const float *>hip._util.types.Pointer.fromPyobj(alpha)._ptr,
        float2.fromPyobj(x).getElementPtr(),incx,
        float2.fromPyobj(AP).getElementPtr()))
    return (_hipblasChpr_v2__retval,)


@cython.embedsignature(True)
def hipblasZhpr_v2(object handle, object uplo, int n, object alpha, object x, int incx, object AP):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        uplo (`~.hipblasFillMode_t`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        alpha (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        x (`~.double2`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        AP (`~.double2`/`~.object`):
            (undocumented)
    """
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")
    _hipblasZhpr_v2__retval = hipblasStatus_t(chipblas.hipblasZhpr_v2(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,uplo.value,n,
        <const double *>hip._util.types.Pointer.fromPyobj(alpha)._ptr,
        double2.fromPyobj(x).getElementPtr(),incx,
        double2.fromPyobj(AP).getElementPtr()))
    return (_hipblasZhpr_v2__retval,)


@cython.embedsignature(True)
def hipblasChpr_64(object handle, object uplo, long n, object alpha, object x, long incx, object AP):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        uplo (`~.hipblasFillMode_t`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        alpha (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        x (`~.hipblasComplex`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        AP (`~.hipblasComplex`/`~.object`):
            (undocumented)
    """
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")
    _hipblasChpr_64__retval = hipblasStatus_t(chipblas.hipblasChpr_64(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,uplo.value,n,
        <const float *>hip._util.types.Pointer.fromPyobj(alpha)._ptr,
        hipblasComplex.fromPyobj(x).getElementPtr(),incx,
        hipblasComplex.fromPyobj(AP).getElementPtr()))
    return (_hipblasChpr_64__retval,)


@cython.embedsignature(True)
def hipblasZhpr_64(object handle, object uplo, long n, object alpha, object x, long incx, object AP):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        uplo (`~.hipblasFillMode_t`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        alpha (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        x (`~.hipblasDoubleComplex`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        AP (`~.hipblasDoubleComplex`/`~.object`):
            (undocumented)
    """
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")
    _hipblasZhpr_64__retval = hipblasStatus_t(chipblas.hipblasZhpr_64(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,uplo.value,n,
        <const double *>hip._util.types.Pointer.fromPyobj(alpha)._ptr,
        hipblasDoubleComplex.fromPyobj(x).getElementPtr(),incx,
        hipblasDoubleComplex.fromPyobj(AP).getElementPtr()))
    return (_hipblasZhpr_64__retval,)


@cython.embedsignature(True)
def hipblasChpr_v2_64(object handle, object uplo, long n, object alpha, object x, long incx, object AP):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        uplo (`~.hipblasFillMode_t`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        alpha (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        x (`~.float2`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        AP (`~.float2`/`~.object`):
            (undocumented)
    """
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")
    _hipblasChpr_v2_64__retval = hipblasStatus_t(chipblas.hipblasChpr_v2_64(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,uplo.value,n,
        <const float *>hip._util.types.Pointer.fromPyobj(alpha)._ptr,
        float2.fromPyobj(x).getElementPtr(),incx,
        float2.fromPyobj(AP).getElementPtr()))
    return (_hipblasChpr_v2_64__retval,)


@cython.embedsignature(True)
def hipblasZhpr_v2_64(object handle, object uplo, long n, object alpha, object x, long incx, object AP):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        uplo (`~.hipblasFillMode_t`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        alpha (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        x (`~.double2`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        AP (`~.double2`/`~.object`):
            (undocumented)
    """
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")
    _hipblasZhpr_v2_64__retval = hipblasStatus_t(chipblas.hipblasZhpr_v2_64(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,uplo.value,n,
        <const double *>hip._util.types.Pointer.fromPyobj(alpha)._ptr,
        double2.fromPyobj(x).getElementPtr(),incx,
        double2.fromPyobj(AP).getElementPtr()))
    return (_hipblasZhpr_v2_64__retval,)


@cython.embedsignature(True)
def hipblasChprBatched(object handle, object uplo, int n, object alpha, object x, int incx, object AP, int batchCount):
    r"""BLAS Level 2 API

    @{

    hprBatched performs the matrix-vector operations

    A_i := A_i + alpha*x_i*x_i**H

    where alpha is a real scalar, x_i is a vector, and A_i is an
    n by n symmetric matrix, supplied in packed form, for i = 1, ..., batchCount.

    - Supported precisions in rocBLAS : c,z
    - Supported precisions in cuBLAS  : No support

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`) -- *IN*:
            [hipblasHandle_t]
            handle to the hipblas library context queue.

        uplo (`~.hipblasFillMode_t`) -- *IN*:
            [hipblasFillMode_t]
            specifies whether the upper 'HIPBLAS_FILL_MODE_UPPER' or lower 'HIPBLAS_FILL_MODE_LOWER'
            HIPBLAS_FILL_MODE_UPPER: The upper triangular part of each A_i is supplied in AP.
            HIPBLAS_FILL_MODE_LOWER: The lower triangular part of each A_i is supplied in AP.

        n (`~.int`) -- *IN*:
            [int]
            the number of rows and columns of each matrix A_i, must be at least 0.

        alpha (`~.hip._util.types.Pointer`/`~.object`) -- *IN*:
            device pointer or host pointer to scalar alpha.

        x (`~.hip._util.types.Pointer`/`~.object`) -- *IN*:
            device array of device pointers storing each vector x_i.

        incx (`~.int`) -- *IN*:
            [int]
            specifies the increment for the elements of each x_i.

        AP (`~.hip._util.types.Pointer`/`~.object`) -- *INOUT*:
            device array of device pointers storing the packed version of the specified triangular portion of
              each Hermitian matrix A_i of at least size ((n * (n + 1)) / 2). Array is of at least size batchCount.
              if uplo == HIPBLAS_FILL_MODE_UPPER:
                The upper triangular portion of each Hermitian matrix A_i is supplied.
                The matrix is compacted so that AP contains the triangular portion column-by-column
                so that:
                AP(0) = A(0,0)
                AP(1) = A(0,1)
                AP(2) = A(1,1), etc.
                    Ex: (HIPBLAS_FILL_MODE_UPPER; n = 3)
                        (1, 0) (2, 1) (4,9)
                        (2,-1) (3, 0) (5,3)  -----> [(1,0), (2,1), (3,0), (4,9), (5,3), (6,0)]
                        (4,-9) (5,-3) (6,0)
            if uplo == HIPBLAS_FILL_MODE_LOWER:
                The lower triangular portion of each Hermitian matrix A_i is supplied.
                The matrix is compacted so that AP contains the triangular portion column-by-column
                so that:
                AP(0) = A(0,0)
                AP(1) = A(1,0)
                AP(2) = A(2,1), etc.
                    Ex: (HIPBLAS_FILL_MODE_LOWER; n = 3)
                        (1, 0) (2, 1) (4,9)
                        (2,-1) (3, 0) (5,3)  -----> [(1,0), (2,-1), (4,-9), (3,0), (5,-3), (6,0)]
                        (4,-9) (5,-3) (6,0)
            Note that the imaginary part of the diagonal elements are not accessed and are assumed
            to be 0.

        batchCount (`~.int`) -- *IN*:
            [int]
            number of instances in the batch.
    """
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")
    _hipblasChprBatched__retval = hipblasStatus_t(chipblas.hipblasChprBatched(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,uplo.value,n,
        <const float *>hip._util.types.Pointer.fromPyobj(alpha)._ptr,
        <chipblas.hipblasComplex *const*>hip._util.types.Pointer.fromPyobj(x)._ptr,incx,
        <chipblas.hipblasComplex *const*>hip._util.types.Pointer.fromPyobj(AP)._ptr,batchCount))
    return (_hipblasChprBatched__retval,)


@cython.embedsignature(True)
def hipblasZhprBatched(object handle, object uplo, int n, object alpha, object x, int incx, object AP, int batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        uplo (`~.hipblasFillMode_t`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        alpha (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        x (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        AP (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")
    _hipblasZhprBatched__retval = hipblasStatus_t(chipblas.hipblasZhprBatched(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,uplo.value,n,
        <const double *>hip._util.types.Pointer.fromPyobj(alpha)._ptr,
        <chipblas.hipblasDoubleComplex *const*>hip._util.types.Pointer.fromPyobj(x)._ptr,incx,
        <chipblas.hipblasDoubleComplex *const*>hip._util.types.Pointer.fromPyobj(AP)._ptr,batchCount))
    return (_hipblasZhprBatched__retval,)


@cython.embedsignature(True)
def hipblasChprBatched_v2(object handle, object uplo, int n, object alpha, object x, int incx, object AP, int batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        uplo (`~.hipblasFillMode_t`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        alpha (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        x (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        AP (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")
    _hipblasChprBatched_v2__retval = hipblasStatus_t(chipblas.hipblasChprBatched_v2(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,uplo.value,n,
        <const float *>hip._util.types.Pointer.fromPyobj(alpha)._ptr,
        <chipblas.float2 *const*>hip._util.types.Pointer.fromPyobj(x)._ptr,incx,
        <chipblas.float2 *const*>hip._util.types.Pointer.fromPyobj(AP)._ptr,batchCount))
    return (_hipblasChprBatched_v2__retval,)


@cython.embedsignature(True)
def hipblasZhprBatched_v2(object handle, object uplo, int n, object alpha, object x, int incx, object AP, int batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        uplo (`~.hipblasFillMode_t`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        alpha (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        x (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        AP (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")
    _hipblasZhprBatched_v2__retval = hipblasStatus_t(chipblas.hipblasZhprBatched_v2(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,uplo.value,n,
        <const double *>hip._util.types.Pointer.fromPyobj(alpha)._ptr,
        <chipblas.double2 *const*>hip._util.types.Pointer.fromPyobj(x)._ptr,incx,
        <chipblas.double2 *const*>hip._util.types.Pointer.fromPyobj(AP)._ptr,batchCount))
    return (_hipblasZhprBatched_v2__retval,)


@cython.embedsignature(True)
def hipblasChprBatched_64(object handle, object uplo, long n, object alpha, object x, long incx, object AP, long batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        uplo (`~.hipblasFillMode_t`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        alpha (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        x (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        AP (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")
    _hipblasChprBatched_64__retval = hipblasStatus_t(chipblas.hipblasChprBatched_64(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,uplo.value,n,
        <const float *>hip._util.types.Pointer.fromPyobj(alpha)._ptr,
        <chipblas.hipblasComplex *const*>hip._util.types.Pointer.fromPyobj(x)._ptr,incx,
        <chipblas.hipblasComplex *const*>hip._util.types.Pointer.fromPyobj(AP)._ptr,batchCount))
    return (_hipblasChprBatched_64__retval,)


@cython.embedsignature(True)
def hipblasZhprBatched_64(object handle, object uplo, long n, object alpha, object x, long incx, object AP, long batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        uplo (`~.hipblasFillMode_t`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        alpha (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        x (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        AP (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")
    _hipblasZhprBatched_64__retval = hipblasStatus_t(chipblas.hipblasZhprBatched_64(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,uplo.value,n,
        <const double *>hip._util.types.Pointer.fromPyobj(alpha)._ptr,
        <chipblas.hipblasDoubleComplex *const*>hip._util.types.Pointer.fromPyobj(x)._ptr,incx,
        <chipblas.hipblasDoubleComplex *const*>hip._util.types.Pointer.fromPyobj(AP)._ptr,batchCount))
    return (_hipblasZhprBatched_64__retval,)


@cython.embedsignature(True)
def hipblasChprBatched_v2_64(object handle, object uplo, long n, object alpha, object x, long incx, object AP, long batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        uplo (`~.hipblasFillMode_t`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        alpha (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        x (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        AP (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")
    _hipblasChprBatched_v2_64__retval = hipblasStatus_t(chipblas.hipblasChprBatched_v2_64(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,uplo.value,n,
        <const float *>hip._util.types.Pointer.fromPyobj(alpha)._ptr,
        <chipblas.float2 *const*>hip._util.types.Pointer.fromPyobj(x)._ptr,incx,
        <chipblas.float2 *const*>hip._util.types.Pointer.fromPyobj(AP)._ptr,batchCount))
    return (_hipblasChprBatched_v2_64__retval,)


@cython.embedsignature(True)
def hipblasZhprBatched_v2_64(object handle, object uplo, long n, object alpha, object x, long incx, object AP, long batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        uplo (`~.hipblasFillMode_t`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        alpha (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        x (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        AP (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")
    _hipblasZhprBatched_v2_64__retval = hipblasStatus_t(chipblas.hipblasZhprBatched_v2_64(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,uplo.value,n,
        <const double *>hip._util.types.Pointer.fromPyobj(alpha)._ptr,
        <chipblas.double2 *const*>hip._util.types.Pointer.fromPyobj(x)._ptr,incx,
        <chipblas.double2 *const*>hip._util.types.Pointer.fromPyobj(AP)._ptr,batchCount))
    return (_hipblasZhprBatched_v2_64__retval,)


@cython.embedsignature(True)
def hipblasChprStridedBatched(object handle, object uplo, int n, object alpha, object x, int incx, long stridex, object AP, long strideA, int batchCount):
    r"""BLAS Level 2 API

    @{

    hprStridedBatched performs the matrix-vector operations

    A_i := A_i + alpha*x_i*x_i**H

    where alpha is a real scalar, x_i is a vector, and A_i is an
    n by n symmetric matrix, supplied in packed form, for i = 1, ..., batchCount.

    - Supported precisions in rocBLAS : c,z
    - Supported precisions in cuBLAS  : No support

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`) -- *IN*:
            [hipblasHandle_t]
            handle to the hipblas library context queue.

        uplo (`~.hipblasFillMode_t`) -- *IN*:
            [hipblasFillMode_t]
            specifies whether the upper 'HIPBLAS_FILL_MODE_UPPER' or lower 'HIPBLAS_FILL_MODE_LOWER'
            HIPBLAS_FILL_MODE_UPPER: The upper triangular part of each A_i is supplied in AP.
            HIPBLAS_FILL_MODE_LOWER: The lower triangular part of each A_i is supplied in AP.

        n (`~.int`) -- *IN*:
            [int]
            the number of rows and columns of each matrix A_i, must be at least 0.

        alpha (`~.hip._util.types.Pointer`/`~.object`) -- *IN*:
            device pointer or host pointer to scalar alpha.

        x (`~.hipblasComplex`/`~.object`) -- *IN*:
            device pointer pointing to the first vector (x_1).

        incx (`~.int`) -- *IN*:
            [int]
            specifies the increment for the elements of each x_i.

        stridex (`~.int`) -- *IN*:
            [hipblasStride]
            stride from the start of one vector (x_i) and the next one (x_i+1).

        AP (`~.hipblasComplex`/`~.object`) -- *INOUT*:
            device array of device pointers storing the packed version of the specified triangular portion of
              each Hermitian matrix A_i. Points to the first matrix (A_1).
              if uplo == HIPBLAS_FILL_MODE_UPPER:
                The upper triangular portion of each Hermitian matrix A_i is supplied.
                The matrix is compacted so that AP contains the triangular portion column-by-column
                so that:
                AP(0) = A(0,0)
                AP(1) = A(0,1)
                AP(2) = A(1,1), etc.
                    Ex: (HIPBLAS_FILL_MODE_UPPER; n = 3)
                        (1, 0) (2, 1) (4,9)
                        (2,-1) (3, 0) (5,3)  -----> [(1,0), (2,1), (3,0), (4,9), (5,3), (6,0)]
                        (4,-9) (5,-3) (6,0)
            if uplo == HIPBLAS_FILL_MODE_LOWER:
                The lower triangular portion of each Hermitian matrix A_i is supplied.
                The matrix is compacted so that AP contains the triangular portion column-by-column
                so that:
                AP(0) = A(0,0)
                AP(1) = A(1,0)
                AP(2) = A(2,1), etc.
                    Ex: (HIPBLAS_FILL_MODE_LOWER; n = 3)
                        (1, 0) (2, 1) (4,9)
                        (2,-1) (3, 0) (5,3)  -----> [(1,0), (2,-1), (4,-9), (3,0), (5,-3), (6,0)]
                        (4,-9) (5,-3) (6,0)
            Note that the imaginary part of the diagonal elements are not accessed and are assumed
            to be 0.

        strideA (`~.int`) -- *IN*:
            [hipblasStride]
            stride from the start of one (A_i) and the next (A_i+1)

        batchCount (`~.int`) -- *IN*:
            [int]
            number of instances in the batch.
    """
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")
    _hipblasChprStridedBatched__retval = hipblasStatus_t(chipblas.hipblasChprStridedBatched(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,uplo.value,n,
        <const float *>hip._util.types.Pointer.fromPyobj(alpha)._ptr,
        hipblasComplex.fromPyobj(x).getElementPtr(),incx,stridex,
        hipblasComplex.fromPyobj(AP).getElementPtr(),strideA,batchCount))
    return (_hipblasChprStridedBatched__retval,)


@cython.embedsignature(True)
def hipblasZhprStridedBatched(object handle, object uplo, int n, object alpha, object x, int incx, long stridex, object AP, long strideA, int batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        uplo (`~.hipblasFillMode_t`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        alpha (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        x (`~.hipblasDoubleComplex`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        stridex (`~.int`):
            (undocumented)

        AP (`~.hipblasDoubleComplex`/`~.object`):
            (undocumented)

        strideA (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")
    _hipblasZhprStridedBatched__retval = hipblasStatus_t(chipblas.hipblasZhprStridedBatched(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,uplo.value,n,
        <const double *>hip._util.types.Pointer.fromPyobj(alpha)._ptr,
        hipblasDoubleComplex.fromPyobj(x).getElementPtr(),incx,stridex,
        hipblasDoubleComplex.fromPyobj(AP).getElementPtr(),strideA,batchCount))
    return (_hipblasZhprStridedBatched__retval,)


@cython.embedsignature(True)
def hipblasChprStridedBatched_v2(object handle, object uplo, int n, object alpha, object x, int incx, long stridex, object AP, long strideA, int batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        uplo (`~.hipblasFillMode_t`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        alpha (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        x (`~.float2`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        stridex (`~.int`):
            (undocumented)

        AP (`~.float2`/`~.object`):
            (undocumented)

        strideA (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")
    _hipblasChprStridedBatched_v2__retval = hipblasStatus_t(chipblas.hipblasChprStridedBatched_v2(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,uplo.value,n,
        <const float *>hip._util.types.Pointer.fromPyobj(alpha)._ptr,
        float2.fromPyobj(x).getElementPtr(),incx,stridex,
        float2.fromPyobj(AP).getElementPtr(),strideA,batchCount))
    return (_hipblasChprStridedBatched_v2__retval,)


@cython.embedsignature(True)
def hipblasZhprStridedBatched_v2(object handle, object uplo, int n, object alpha, object x, int incx, long stridex, object AP, long strideA, int batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        uplo (`~.hipblasFillMode_t`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        alpha (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        x (`~.double2`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        stridex (`~.int`):
            (undocumented)

        AP (`~.double2`/`~.object`):
            (undocumented)

        strideA (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")
    _hipblasZhprStridedBatched_v2__retval = hipblasStatus_t(chipblas.hipblasZhprStridedBatched_v2(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,uplo.value,n,
        <const double *>hip._util.types.Pointer.fromPyobj(alpha)._ptr,
        double2.fromPyobj(x).getElementPtr(),incx,stridex,
        double2.fromPyobj(AP).getElementPtr(),strideA,batchCount))
    return (_hipblasZhprStridedBatched_v2__retval,)


@cython.embedsignature(True)
def hipblasChprStridedBatched_64(object handle, object uplo, long n, object alpha, object x, long incx, long stridex, object AP, long strideA, long batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        uplo (`~.hipblasFillMode_t`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        alpha (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        x (`~.hipblasComplex`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        stridex (`~.int`):
            (undocumented)

        AP (`~.hipblasComplex`/`~.object`):
            (undocumented)

        strideA (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")
    _hipblasChprStridedBatched_64__retval = hipblasStatus_t(chipblas.hipblasChprStridedBatched_64(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,uplo.value,n,
        <const float *>hip._util.types.Pointer.fromPyobj(alpha)._ptr,
        hipblasComplex.fromPyobj(x).getElementPtr(),incx,stridex,
        hipblasComplex.fromPyobj(AP).getElementPtr(),strideA,batchCount))
    return (_hipblasChprStridedBatched_64__retval,)


@cython.embedsignature(True)
def hipblasZhprStridedBatched_64(object handle, object uplo, long n, object alpha, object x, long incx, long stridex, object AP, long strideA, long batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        uplo (`~.hipblasFillMode_t`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        alpha (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        x (`~.hipblasDoubleComplex`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        stridex (`~.int`):
            (undocumented)

        AP (`~.hipblasDoubleComplex`/`~.object`):
            (undocumented)

        strideA (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")
    _hipblasZhprStridedBatched_64__retval = hipblasStatus_t(chipblas.hipblasZhprStridedBatched_64(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,uplo.value,n,
        <const double *>hip._util.types.Pointer.fromPyobj(alpha)._ptr,
        hipblasDoubleComplex.fromPyobj(x).getElementPtr(),incx,stridex,
        hipblasDoubleComplex.fromPyobj(AP).getElementPtr(),strideA,batchCount))
    return (_hipblasZhprStridedBatched_64__retval,)


@cython.embedsignature(True)
def hipblasChprStridedBatched_v2_64(object handle, object uplo, long n, object alpha, object x, long incx, long stridex, object AP, long strideA, long batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        uplo (`~.hipblasFillMode_t`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        alpha (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        x (`~.float2`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        stridex (`~.int`):
            (undocumented)

        AP (`~.float2`/`~.object`):
            (undocumented)

        strideA (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")
    _hipblasChprStridedBatched_v2_64__retval = hipblasStatus_t(chipblas.hipblasChprStridedBatched_v2_64(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,uplo.value,n,
        <const float *>hip._util.types.Pointer.fromPyobj(alpha)._ptr,
        float2.fromPyobj(x).getElementPtr(),incx,stridex,
        float2.fromPyobj(AP).getElementPtr(),strideA,batchCount))
    return (_hipblasChprStridedBatched_v2_64__retval,)


@cython.embedsignature(True)
def hipblasZhprStridedBatched_v2_64(object handle, object uplo, long n, object alpha, object x, long incx, long stridex, object AP, long strideA, long batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        uplo (`~.hipblasFillMode_t`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        alpha (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        x (`~.double2`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        stridex (`~.int`):
            (undocumented)

        AP (`~.double2`/`~.object`):
            (undocumented)

        strideA (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")
    _hipblasZhprStridedBatched_v2_64__retval = hipblasStatus_t(chipblas.hipblasZhprStridedBatched_v2_64(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,uplo.value,n,
        <const double *>hip._util.types.Pointer.fromPyobj(alpha)._ptr,
        double2.fromPyobj(x).getElementPtr(),incx,stridex,
        double2.fromPyobj(AP).getElementPtr(),strideA,batchCount))
    return (_hipblasZhprStridedBatched_v2_64__retval,)


@cython.embedsignature(True)
def hipblasChpr2(object handle, object uplo, int n, object alpha, object x, int incx, object y, int incy, object AP):
    r"""BLAS Level 2 API

    @{

    hpr2 performs the matrix-vector operations

    A := A + alpha*x*y**H + conj(alpha)*y*x**H

    where alpha is a complex scalar, x and y are vectors, and A is an
    n by n Hermitian matrix, supplied in packed form.

    - Supported precisions in rocBLAS : c,z
    - Supported precisions in cuBLAS  : c,z

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`) -- *IN*:
            [hipblasHandle_t]
            handle to the hipblas library context queue.

        uplo (`~.hipblasFillMode_t`) -- *IN*:
            [hipblasFillMode_t]
            specifies whether the upper 'HIPBLAS_FILL_MODE_UPPER' or lower 'HIPBLAS_FILL_MODE_LOWER'
            HIPBLAS_FILL_MODE_UPPER: The upper triangular part of A is supplied in AP.
            HIPBLAS_FILL_MODE_LOWER: The lower triangular part of A is supplied in AP.

        n (`~.int`) -- *IN*:
            [int]
            the number of rows and columns of matrix A, must be at least 0.

        alpha (`~.hipblasComplex`/`~.object`) -- *IN*:
            device pointer or host pointer to scalar alpha.

        x (`~.hipblasComplex`/`~.object`) -- *IN*:
            device pointer storing vector x.

        incx (`~.int`) -- *IN*:
            [int]
            specifies the increment for the elements of x.

        y (`~.hipblasComplex`/`~.object`) -- *IN*:
            device pointer storing vector y.

        incy (`~.int`) -- *IN*:
            [int]
            specifies the increment for the elements of y.

        AP (`~.hipblasComplex`/`~.object`) -- *INOUT*:
            device pointer storing the packed version of the specified triangular portion of
              the Hermitian matrix A. Of at least size ((n * (n + 1)) / 2).
              if uplo == HIPBLAS_FILL_MODE_UPPER:
                The upper triangular portion of the Hermitian matrix A is supplied.
                The matrix is compacted so that AP contains the triangular portion column-by-column
                so that:
                AP(0) = A(0,0)
                AP(1) = A(0,1)
                AP(2) = A(1,1), etc.
                    Ex: (HIPBLAS_FILL_MODE_UPPER; n = 3)
                        (1, 0) (2, 1) (4,9)
                        (2,-1) (3, 0) (5,3)  -----> [(1,0), (2,1), (3,0), (4,9), (5,3), (6,0)]
                        (4,-9) (5,-3) (6,0)
            if uplo == HIPBLAS_FILL_MODE_LOWER:
                The lower triangular portion of the Hermitian matrix A is supplied.
                The matrix is compacted so that AP contains the triangular portion column-by-column
                so that:
                AP(0) = A(0,0)
                AP(1) = A(1,0)
                AP(2) = A(2,1), etc.
                    Ex: (HIPBLAS_FILL_MODE_LOWER; n = 3)
                        (1, 0) (2, 1) (4,9)
                        (2,-1) (3, 0) (5,3)  -----> [(1,0), (2,-1), (4,-9), (3,0), (5,-3), (6,0)]
                        (4,-9) (5,-3) (6,0)
            Note that the imaginary part of the diagonal elements are not accessed and are assumed
            to be 0.
    """
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")
    _hipblasChpr2__retval = hipblasStatus_t(chipblas.hipblasChpr2(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,uplo.value,n,
        hipblasComplex.fromPyobj(alpha).getElementPtr(),
        hipblasComplex.fromPyobj(x).getElementPtr(),incx,
        hipblasComplex.fromPyobj(y).getElementPtr(),incy,
        hipblasComplex.fromPyobj(AP).getElementPtr()))
    return (_hipblasChpr2__retval,)


@cython.embedsignature(True)
def hipblasZhpr2(object handle, object uplo, int n, object alpha, object x, int incx, object y, int incy, object AP):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        uplo (`~.hipblasFillMode_t`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        alpha (`~.hipblasDoubleComplex`/`~.object`):
            (undocumented)

        x (`~.hipblasDoubleComplex`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        y (`~.hipblasDoubleComplex`/`~.object`):
            (undocumented)

        incy (`~.int`):
            (undocumented)

        AP (`~.hipblasDoubleComplex`/`~.object`):
            (undocumented)
    """
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")
    _hipblasZhpr2__retval = hipblasStatus_t(chipblas.hipblasZhpr2(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,uplo.value,n,
        hipblasDoubleComplex.fromPyobj(alpha).getElementPtr(),
        hipblasDoubleComplex.fromPyobj(x).getElementPtr(),incx,
        hipblasDoubleComplex.fromPyobj(y).getElementPtr(),incy,
        hipblasDoubleComplex.fromPyobj(AP).getElementPtr()))
    return (_hipblasZhpr2__retval,)


@cython.embedsignature(True)
def hipblasChpr2_v2(object handle, object uplo, int n, object alpha, object x, int incx, object y, int incy, object AP):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        uplo (`~.hipblasFillMode_t`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        alpha (`~.float2`/`~.object`):
            (undocumented)

        x (`~.float2`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        y (`~.float2`/`~.object`):
            (undocumented)

        incy (`~.int`):
            (undocumented)

        AP (`~.float2`/`~.object`):
            (undocumented)
    """
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")
    _hipblasChpr2_v2__retval = hipblasStatus_t(chipblas.hipblasChpr2_v2(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,uplo.value,n,
        float2.fromPyobj(alpha).getElementPtr(),
        float2.fromPyobj(x).getElementPtr(),incx,
        float2.fromPyobj(y).getElementPtr(),incy,
        float2.fromPyobj(AP).getElementPtr()))
    return (_hipblasChpr2_v2__retval,)


@cython.embedsignature(True)
def hipblasZhpr2_v2(object handle, object uplo, int n, object alpha, object x, int incx, object y, int incy, object AP):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        uplo (`~.hipblasFillMode_t`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        alpha (`~.double2`/`~.object`):
            (undocumented)

        x (`~.double2`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        y (`~.double2`/`~.object`):
            (undocumented)

        incy (`~.int`):
            (undocumented)

        AP (`~.double2`/`~.object`):
            (undocumented)
    """
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")
    _hipblasZhpr2_v2__retval = hipblasStatus_t(chipblas.hipblasZhpr2_v2(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,uplo.value,n,
        double2.fromPyobj(alpha).getElementPtr(),
        double2.fromPyobj(x).getElementPtr(),incx,
        double2.fromPyobj(y).getElementPtr(),incy,
        double2.fromPyobj(AP).getElementPtr()))
    return (_hipblasZhpr2_v2__retval,)


@cython.embedsignature(True)
def hipblasChpr2_64(object handle, object uplo, long n, object alpha, object x, long incx, object y, long incy, object AP):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        uplo (`~.hipblasFillMode_t`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        alpha (`~.hipblasComplex`/`~.object`):
            (undocumented)

        x (`~.hipblasComplex`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        y (`~.hipblasComplex`/`~.object`):
            (undocumented)

        incy (`~.int`):
            (undocumented)

        AP (`~.hipblasComplex`/`~.object`):
            (undocumented)
    """
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")
    _hipblasChpr2_64__retval = hipblasStatus_t(chipblas.hipblasChpr2_64(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,uplo.value,n,
        hipblasComplex.fromPyobj(alpha).getElementPtr(),
        hipblasComplex.fromPyobj(x).getElementPtr(),incx,
        hipblasComplex.fromPyobj(y).getElementPtr(),incy,
        hipblasComplex.fromPyobj(AP).getElementPtr()))
    return (_hipblasChpr2_64__retval,)


@cython.embedsignature(True)
def hipblasZhpr2_64(object handle, object uplo, long n, object alpha, object x, long incx, object y, long incy, object AP):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        uplo (`~.hipblasFillMode_t`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        alpha (`~.hipblasDoubleComplex`/`~.object`):
            (undocumented)

        x (`~.hipblasDoubleComplex`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        y (`~.hipblasDoubleComplex`/`~.object`):
            (undocumented)

        incy (`~.int`):
            (undocumented)

        AP (`~.hipblasDoubleComplex`/`~.object`):
            (undocumented)
    """
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")
    _hipblasZhpr2_64__retval = hipblasStatus_t(chipblas.hipblasZhpr2_64(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,uplo.value,n,
        hipblasDoubleComplex.fromPyobj(alpha).getElementPtr(),
        hipblasDoubleComplex.fromPyobj(x).getElementPtr(),incx,
        hipblasDoubleComplex.fromPyobj(y).getElementPtr(),incy,
        hipblasDoubleComplex.fromPyobj(AP).getElementPtr()))
    return (_hipblasZhpr2_64__retval,)


@cython.embedsignature(True)
def hipblasChpr2_v2_64(object handle, object uplo, long n, object alpha, object x, long incx, object y, long incy, object AP):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        uplo (`~.hipblasFillMode_t`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        alpha (`~.float2`/`~.object`):
            (undocumented)

        x (`~.float2`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        y (`~.float2`/`~.object`):
            (undocumented)

        incy (`~.int`):
            (undocumented)

        AP (`~.float2`/`~.object`):
            (undocumented)
    """
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")
    _hipblasChpr2_v2_64__retval = hipblasStatus_t(chipblas.hipblasChpr2_v2_64(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,uplo.value,n,
        float2.fromPyobj(alpha).getElementPtr(),
        float2.fromPyobj(x).getElementPtr(),incx,
        float2.fromPyobj(y).getElementPtr(),incy,
        float2.fromPyobj(AP).getElementPtr()))
    return (_hipblasChpr2_v2_64__retval,)


@cython.embedsignature(True)
def hipblasZhpr2_v2_64(object handle, object uplo, long n, object alpha, object x, long incx, object y, long incy, object AP):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        uplo (`~.hipblasFillMode_t`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        alpha (`~.double2`/`~.object`):
            (undocumented)

        x (`~.double2`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        y (`~.double2`/`~.object`):
            (undocumented)

        incy (`~.int`):
            (undocumented)

        AP (`~.double2`/`~.object`):
            (undocumented)
    """
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")
    _hipblasZhpr2_v2_64__retval = hipblasStatus_t(chipblas.hipblasZhpr2_v2_64(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,uplo.value,n,
        double2.fromPyobj(alpha).getElementPtr(),
        double2.fromPyobj(x).getElementPtr(),incx,
        double2.fromPyobj(y).getElementPtr(),incy,
        double2.fromPyobj(AP).getElementPtr()))
    return (_hipblasZhpr2_v2_64__retval,)


@cython.embedsignature(True)
def hipblasChpr2Batched(object handle, object uplo, int n, object alpha, object x, int incx, object y, int incy, object AP, int batchCount):
    r"""BLAS Level 2 API

    @{

    hpr2Batched performs the matrix-vector operations

    A_i := A_i + alpha*x_i*y_i**H + conj(alpha)*y_i*x_i**H

    where alpha is a complex scalar, x_i and y_i are vectors, and A_i is an
    n by n symmetric matrix, supplied in packed form, for i = 1, ..., batchCount.

    - Supported precisions in rocBLAS : c,z
    - Supported precisions in cuBLAS  : No support

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`) -- *IN*:
            [hipblasHandle_t]
            handle to the hipblas library context queue.

        uplo (`~.hipblasFillMode_t`) -- *IN*:
            [hipblasFillMode_t]
            specifies whether the upper 'HIPBLAS_FILL_MODE_UPPER' or lower 'HIPBLAS_FILL_MODE_LOWER'
            HIPBLAS_FILL_MODE_UPPER: The upper triangular part of each A_i is supplied in AP.
            HIPBLAS_FILL_MODE_LOWER: The lower triangular part of each A_i is supplied in AP.

        n (`~.int`) -- *IN*:
            [int]
            the number of rows and columns of each matrix A_i, must be at least 0.

        alpha (`~.hipblasComplex`/`~.object`) -- *IN*:
            device pointer or host pointer to scalar alpha.

        x (`~.hip._util.types.Pointer`/`~.object`) -- *IN*:
            device array of device pointers storing each vector x_i.

        incx (`~.int`) -- *IN*:
            [int]
            specifies the increment for the elements of each x_i.

        y (`~.hip._util.types.Pointer`/`~.object`) -- *IN*:
            device array of device pointers storing each vector y_i.

        incy (`~.int`) -- *IN*:
            [int]
            specifies the increment for the elements of each y_i.

        AP (`~.hip._util.types.Pointer`/`~.object`) -- *INOUT*:
            device array of device pointers storing the packed version of the specified triangular portion of
              each Hermitian matrix A_i of at least size ((n * (n + 1)) / 2). Array is of at least size batchCount.
              if uplo == HIPBLAS_FILL_MODE_UPPER:
                The upper triangular portion of each Hermitian matrix A_i is supplied.
                The matrix is compacted so that AP contains the triangular portion column-by-column
                so that:
                AP(0) = A(0,0)
                AP(1) = A(0,1)
                AP(2) = A(1,1), etc.
                    Ex: (HIPBLAS_FILL_MODE_UPPER; n = 3)
                        (1, 0) (2, 1) (4,9)
                        (2,-1) (3, 0) (5,3)  -----> [(1,0), (2,1), (3,0), (4,9), (5,3), (6,0)]
                        (4,-9) (5,-3) (6,0)
            if uplo == HIPBLAS_FILL_MODE_LOWER:
                The lower triangular portion of each Hermitian matrix A_i is supplied.
                The matrix is compacted so that AP contains the triangular portion column-by-column
                so that:
                AP(0) = A(0,0)
                AP(1) = A(1,0)
                AP(2) = A(2,1), etc.
                    Ex: (HIPBLAS_FILL_MODE_LOWER; n = 3)
                        (1, 0) (2, 1) (4,9)
                        (2,-1) (3, 0) (5,3)  -----> [(1,0), (2,-1), (4,-9), (3,0), (5,-3), (6,0)]
                        (4,-9) (5,-3) (6,0)
            Note that the imaginary part of the diagonal elements are not accessed and are assumed
            to be 0.

        batchCount (`~.int`) -- *IN*:
            [int]
            number of instances in the batch.
    """
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")
    _hipblasChpr2Batched__retval = hipblasStatus_t(chipblas.hipblasChpr2Batched(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,uplo.value,n,
        hipblasComplex.fromPyobj(alpha).getElementPtr(),
        <chipblas.hipblasComplex *const*>hip._util.types.Pointer.fromPyobj(x)._ptr,incx,
        <chipblas.hipblasComplex *const*>hip._util.types.Pointer.fromPyobj(y)._ptr,incy,
        <chipblas.hipblasComplex *const*>hip._util.types.Pointer.fromPyobj(AP)._ptr,batchCount))
    return (_hipblasChpr2Batched__retval,)


@cython.embedsignature(True)
def hipblasZhpr2Batched(object handle, object uplo, int n, object alpha, object x, int incx, object y, int incy, object AP, int batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        uplo (`~.hipblasFillMode_t`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        alpha (`~.hipblasDoubleComplex`/`~.object`):
            (undocumented)

        x (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        y (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        incy (`~.int`):
            (undocumented)

        AP (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")
    _hipblasZhpr2Batched__retval = hipblasStatus_t(chipblas.hipblasZhpr2Batched(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,uplo.value,n,
        hipblasDoubleComplex.fromPyobj(alpha).getElementPtr(),
        <chipblas.hipblasDoubleComplex *const*>hip._util.types.Pointer.fromPyobj(x)._ptr,incx,
        <chipblas.hipblasDoubleComplex *const*>hip._util.types.Pointer.fromPyobj(y)._ptr,incy,
        <chipblas.hipblasDoubleComplex *const*>hip._util.types.Pointer.fromPyobj(AP)._ptr,batchCount))
    return (_hipblasZhpr2Batched__retval,)


@cython.embedsignature(True)
def hipblasChpr2Batched_v2(object handle, object uplo, int n, object alpha, object x, int incx, object y, int incy, object AP, int batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        uplo (`~.hipblasFillMode_t`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        alpha (`~.float2`/`~.object`):
            (undocumented)

        x (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        y (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        incy (`~.int`):
            (undocumented)

        AP (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")
    _hipblasChpr2Batched_v2__retval = hipblasStatus_t(chipblas.hipblasChpr2Batched_v2(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,uplo.value,n,
        float2.fromPyobj(alpha).getElementPtr(),
        <chipblas.float2 *const*>hip._util.types.Pointer.fromPyobj(x)._ptr,incx,
        <chipblas.float2 *const*>hip._util.types.Pointer.fromPyobj(y)._ptr,incy,
        <chipblas.float2 *const*>hip._util.types.Pointer.fromPyobj(AP)._ptr,batchCount))
    return (_hipblasChpr2Batched_v2__retval,)


@cython.embedsignature(True)
def hipblasZhpr2Batched_v2(object handle, object uplo, int n, object alpha, object x, int incx, object y, int incy, object AP, int batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        uplo (`~.hipblasFillMode_t`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        alpha (`~.double2`/`~.object`):
            (undocumented)

        x (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        y (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        incy (`~.int`):
            (undocumented)

        AP (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")
    _hipblasZhpr2Batched_v2__retval = hipblasStatus_t(chipblas.hipblasZhpr2Batched_v2(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,uplo.value,n,
        double2.fromPyobj(alpha).getElementPtr(),
        <chipblas.double2 *const*>hip._util.types.Pointer.fromPyobj(x)._ptr,incx,
        <chipblas.double2 *const*>hip._util.types.Pointer.fromPyobj(y)._ptr,incy,
        <chipblas.double2 *const*>hip._util.types.Pointer.fromPyobj(AP)._ptr,batchCount))
    return (_hipblasZhpr2Batched_v2__retval,)


@cython.embedsignature(True)
def hipblasChpr2Batched_64(object handle, object uplo, long n, object alpha, object x, long incx, object y, long incy, object AP, long batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        uplo (`~.hipblasFillMode_t`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        alpha (`~.hipblasComplex`/`~.object`):
            (undocumented)

        x (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        y (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        incy (`~.int`):
            (undocumented)

        AP (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")
    _hipblasChpr2Batched_64__retval = hipblasStatus_t(chipblas.hipblasChpr2Batched_64(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,uplo.value,n,
        hipblasComplex.fromPyobj(alpha).getElementPtr(),
        <chipblas.hipblasComplex *const*>hip._util.types.Pointer.fromPyobj(x)._ptr,incx,
        <chipblas.hipblasComplex *const*>hip._util.types.Pointer.fromPyobj(y)._ptr,incy,
        <chipblas.hipblasComplex *const*>hip._util.types.Pointer.fromPyobj(AP)._ptr,batchCount))
    return (_hipblasChpr2Batched_64__retval,)


@cython.embedsignature(True)
def hipblasZhpr2Batched_64(object handle, object uplo, long n, object alpha, object x, long incx, object y, long incy, object AP, long batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        uplo (`~.hipblasFillMode_t`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        alpha (`~.hipblasDoubleComplex`/`~.object`):
            (undocumented)

        x (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        y (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        incy (`~.int`):
            (undocumented)

        AP (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")
    _hipblasZhpr2Batched_64__retval = hipblasStatus_t(chipblas.hipblasZhpr2Batched_64(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,uplo.value,n,
        hipblasDoubleComplex.fromPyobj(alpha).getElementPtr(),
        <chipblas.hipblasDoubleComplex *const*>hip._util.types.Pointer.fromPyobj(x)._ptr,incx,
        <chipblas.hipblasDoubleComplex *const*>hip._util.types.Pointer.fromPyobj(y)._ptr,incy,
        <chipblas.hipblasDoubleComplex *const*>hip._util.types.Pointer.fromPyobj(AP)._ptr,batchCount))
    return (_hipblasZhpr2Batched_64__retval,)


@cython.embedsignature(True)
def hipblasChpr2Batched_v2_64(object handle, object uplo, long n, object alpha, object x, long incx, object y, long incy, object AP, long batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        uplo (`~.hipblasFillMode_t`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        alpha (`~.float2`/`~.object`):
            (undocumented)

        x (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        y (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        incy (`~.int`):
            (undocumented)

        AP (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")
    _hipblasChpr2Batched_v2_64__retval = hipblasStatus_t(chipblas.hipblasChpr2Batched_v2_64(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,uplo.value,n,
        float2.fromPyobj(alpha).getElementPtr(),
        <chipblas.float2 *const*>hip._util.types.Pointer.fromPyobj(x)._ptr,incx,
        <chipblas.float2 *const*>hip._util.types.Pointer.fromPyobj(y)._ptr,incy,
        <chipblas.float2 *const*>hip._util.types.Pointer.fromPyobj(AP)._ptr,batchCount))
    return (_hipblasChpr2Batched_v2_64__retval,)


@cython.embedsignature(True)
def hipblasZhpr2Batched_v2_64(object handle, object uplo, long n, object alpha, object x, long incx, object y, long incy, object AP, long batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        uplo (`~.hipblasFillMode_t`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        alpha (`~.double2`/`~.object`):
            (undocumented)

        x (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        y (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        incy (`~.int`):
            (undocumented)

        AP (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")
    _hipblasZhpr2Batched_v2_64__retval = hipblasStatus_t(chipblas.hipblasZhpr2Batched_v2_64(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,uplo.value,n,
        double2.fromPyobj(alpha).getElementPtr(),
        <chipblas.double2 *const*>hip._util.types.Pointer.fromPyobj(x)._ptr,incx,
        <chipblas.double2 *const*>hip._util.types.Pointer.fromPyobj(y)._ptr,incy,
        <chipblas.double2 *const*>hip._util.types.Pointer.fromPyobj(AP)._ptr,batchCount))
    return (_hipblasZhpr2Batched_v2_64__retval,)


@cython.embedsignature(True)
def hipblasChpr2StridedBatched(object handle, object uplo, int n, object alpha, object x, int incx, long stridex, object y, int incy, long stridey, object AP, long strideA, int batchCount):
    r"""BLAS Level 2 API

    @{

    hpr2StridedBatched performs the matrix-vector operations

    A_i := A_i + alpha*x_i*y_i**H + conj(alpha)*y_i*x_i**H

    where alpha is a complex scalar, x_i and y_i are vectors, and A_i is an
    n by n symmetric matrix, supplied in packed form, for i = 1, ..., batchCount.

    - Supported precisions in rocBLAS : c,z
    - Supported precisions in cuBLAS  : No support

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`) -- *IN*:
            [hipblasHandle_t]
            handle to the hipblas library context queue.

        uplo (`~.hipblasFillMode_t`) -- *IN*:
            [hipblasFillMode_t]
            specifies whether the upper 'HIPBLAS_FILL_MODE_UPPER' or lower 'HIPBLAS_FILL_MODE_LOWER'
            HIPBLAS_FILL_MODE_UPPER: The upper triangular part of each A_i is supplied in AP.
            HIPBLAS_FILL_MODE_LOWER: The lower triangular part of each A_i is supplied in AP.

        n (`~.int`) -- *IN*:
            [int]
            the number of rows and columns of each matrix A_i, must be at least 0.

        alpha (`~.hipblasComplex`/`~.object`) -- *IN*:
            device pointer or host pointer to scalar alpha.

        x (`~.hipblasComplex`/`~.object`) -- *IN*:
            device pointer pointing to the first vector (x_1).

        incx (`~.int`) -- *IN*:
            [int]
            specifies the increment for the elements of each x_i.

        stridex (`~.int`) -- *IN*:
            [hipblasStride]
            stride from the start of one vector (x_i) and the next one (x_i+1).

        y (`~.hipblasComplex`/`~.object`) -- *IN*:
            device pointer pointing to the first vector (y_1).

        incy (`~.int`) -- *IN*:
            [int]
            specifies the increment for the elements of each y_i.

        stridey (`~.int`) -- *IN*:
            [hipblasStride]
            stride from the start of one vector (y_i) and the next one (y_i+1).

        AP (`~.hipblasComplex`/`~.object`) -- *INOUT*:
            device array of device pointers storing the packed version of the specified triangular portion of
              each Hermitian matrix A_i. Points to the first matrix (A_1).
              if uplo == HIPBLAS_FILL_MODE_UPPER:
                The upper triangular portion of each Hermitian matrix A_i is supplied.
                The matrix is compacted so that AP contains the triangular portion column-by-column
                so that:
                AP(0) = A(0,0)
                AP(1) = A(0,1)
                AP(2) = A(1,1), etc.
                    Ex: (HIPBLAS_FILL_MODE_UPPER; n = 3)
                        (1, 0) (2, 1) (4,9)
                        (2,-1) (3, 0) (5,3)  -----> [(1,0), (2,1), (3,0), (4,9), (5,3), (6,0)]
                        (4,-9) (5,-3) (6,0)
            if uplo == HIPBLAS_FILL_MODE_LOWER:
                The lower triangular portion of each Hermitian matrix A_i is supplied.
                The matrix is compacted so that AP contains the triangular portion column-by-column
                so that:
                AP(0) = A(0,0)
                AP(1) = A(1,0)
                AP(2) = A(2,1), etc.
                    Ex: (HIPBLAS_FILL_MODE_LOWER; n = 3)
                        (1, 0) (2, 1) (4,9)
                        (2,-1) (3, 0) (5,3)  -----> [(1,0), (2,-1), (4,-9), (3,0), (5,-3), (6,0)]
                        (4,-9) (5,-3) (6,0)
            Note that the imaginary part of the diagonal elements are not accessed and are assumed
            to be 0.

        strideA (`~.int`) -- *IN*:
            [hipblasStride]
            stride from the start of one (A_i) and the next (A_i+1)

        batchCount (`~.int`) -- *IN*:
            [int]
            number of instances in the batch.
    """
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")
    _hipblasChpr2StridedBatched__retval = hipblasStatus_t(chipblas.hipblasChpr2StridedBatched(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,uplo.value,n,
        hipblasComplex.fromPyobj(alpha).getElementPtr(),
        hipblasComplex.fromPyobj(x).getElementPtr(),incx,stridex,
        hipblasComplex.fromPyobj(y).getElementPtr(),incy,stridey,
        hipblasComplex.fromPyobj(AP).getElementPtr(),strideA,batchCount))
    return (_hipblasChpr2StridedBatched__retval,)


@cython.embedsignature(True)
def hipblasZhpr2StridedBatched(object handle, object uplo, int n, object alpha, object x, int incx, long stridex, object y, int incy, long stridey, object AP, long strideA, int batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        uplo (`~.hipblasFillMode_t`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        alpha (`~.hipblasDoubleComplex`/`~.object`):
            (undocumented)

        x (`~.hipblasDoubleComplex`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        stridex (`~.int`):
            (undocumented)

        y (`~.hipblasDoubleComplex`/`~.object`):
            (undocumented)

        incy (`~.int`):
            (undocumented)

        stridey (`~.int`):
            (undocumented)

        AP (`~.hipblasDoubleComplex`/`~.object`):
            (undocumented)

        strideA (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")
    _hipblasZhpr2StridedBatched__retval = hipblasStatus_t(chipblas.hipblasZhpr2StridedBatched(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,uplo.value,n,
        hipblasDoubleComplex.fromPyobj(alpha).getElementPtr(),
        hipblasDoubleComplex.fromPyobj(x).getElementPtr(),incx,stridex,
        hipblasDoubleComplex.fromPyobj(y).getElementPtr(),incy,stridey,
        hipblasDoubleComplex.fromPyobj(AP).getElementPtr(),strideA,batchCount))
    return (_hipblasZhpr2StridedBatched__retval,)


@cython.embedsignature(True)
def hipblasChpr2StridedBatched_v2(object handle, object uplo, int n, object alpha, object x, int incx, long stridex, object y, int incy, long stridey, object AP, long strideA, int batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        uplo (`~.hipblasFillMode_t`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        alpha (`~.float2`/`~.object`):
            (undocumented)

        x (`~.float2`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        stridex (`~.int`):
            (undocumented)

        y (`~.float2`/`~.object`):
            (undocumented)

        incy (`~.int`):
            (undocumented)

        stridey (`~.int`):
            (undocumented)

        AP (`~.float2`/`~.object`):
            (undocumented)

        strideA (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")
    _hipblasChpr2StridedBatched_v2__retval = hipblasStatus_t(chipblas.hipblasChpr2StridedBatched_v2(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,uplo.value,n,
        float2.fromPyobj(alpha).getElementPtr(),
        float2.fromPyobj(x).getElementPtr(),incx,stridex,
        float2.fromPyobj(y).getElementPtr(),incy,stridey,
        float2.fromPyobj(AP).getElementPtr(),strideA,batchCount))
    return (_hipblasChpr2StridedBatched_v2__retval,)


@cython.embedsignature(True)
def hipblasZhpr2StridedBatched_v2(object handle, object uplo, int n, object alpha, object x, int incx, long stridex, object y, int incy, long stridey, object AP, long strideA, int batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        uplo (`~.hipblasFillMode_t`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        alpha (`~.double2`/`~.object`):
            (undocumented)

        x (`~.double2`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        stridex (`~.int`):
            (undocumented)

        y (`~.double2`/`~.object`):
            (undocumented)

        incy (`~.int`):
            (undocumented)

        stridey (`~.int`):
            (undocumented)

        AP (`~.double2`/`~.object`):
            (undocumented)

        strideA (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")
    _hipblasZhpr2StridedBatched_v2__retval = hipblasStatus_t(chipblas.hipblasZhpr2StridedBatched_v2(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,uplo.value,n,
        double2.fromPyobj(alpha).getElementPtr(),
        double2.fromPyobj(x).getElementPtr(),incx,stridex,
        double2.fromPyobj(y).getElementPtr(),incy,stridey,
        double2.fromPyobj(AP).getElementPtr(),strideA,batchCount))
    return (_hipblasZhpr2StridedBatched_v2__retval,)


@cython.embedsignature(True)
def hipblasChpr2StridedBatched_64(object handle, object uplo, long n, object alpha, object x, long incx, long stridex, object y, long incy, long stridey, object AP, long strideA, long batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        uplo (`~.hipblasFillMode_t`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        alpha (`~.hipblasComplex`/`~.object`):
            (undocumented)

        x (`~.hipblasComplex`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        stridex (`~.int`):
            (undocumented)

        y (`~.hipblasComplex`/`~.object`):
            (undocumented)

        incy (`~.int`):
            (undocumented)

        stridey (`~.int`):
            (undocumented)

        AP (`~.hipblasComplex`/`~.object`):
            (undocumented)

        strideA (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")
    _hipblasChpr2StridedBatched_64__retval = hipblasStatus_t(chipblas.hipblasChpr2StridedBatched_64(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,uplo.value,n,
        hipblasComplex.fromPyobj(alpha).getElementPtr(),
        hipblasComplex.fromPyobj(x).getElementPtr(),incx,stridex,
        hipblasComplex.fromPyobj(y).getElementPtr(),incy,stridey,
        hipblasComplex.fromPyobj(AP).getElementPtr(),strideA,batchCount))
    return (_hipblasChpr2StridedBatched_64__retval,)


@cython.embedsignature(True)
def hipblasZhpr2StridedBatched_64(object handle, object uplo, long n, object alpha, object x, long incx, long stridex, object y, long incy, long stridey, object AP, long strideA, long batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        uplo (`~.hipblasFillMode_t`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        alpha (`~.hipblasDoubleComplex`/`~.object`):
            (undocumented)

        x (`~.hipblasDoubleComplex`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        stridex (`~.int`):
            (undocumented)

        y (`~.hipblasDoubleComplex`/`~.object`):
            (undocumented)

        incy (`~.int`):
            (undocumented)

        stridey (`~.int`):
            (undocumented)

        AP (`~.hipblasDoubleComplex`/`~.object`):
            (undocumented)

        strideA (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")
    _hipblasZhpr2StridedBatched_64__retval = hipblasStatus_t(chipblas.hipblasZhpr2StridedBatched_64(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,uplo.value,n,
        hipblasDoubleComplex.fromPyobj(alpha).getElementPtr(),
        hipblasDoubleComplex.fromPyobj(x).getElementPtr(),incx,stridex,
        hipblasDoubleComplex.fromPyobj(y).getElementPtr(),incy,stridey,
        hipblasDoubleComplex.fromPyobj(AP).getElementPtr(),strideA,batchCount))
    return (_hipblasZhpr2StridedBatched_64__retval,)


@cython.embedsignature(True)
def hipblasChpr2StridedBatched_v2_64(object handle, object uplo, long n, object alpha, object x, long incx, long stridex, object y, long incy, long stridey, object AP, long strideA, long batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        uplo (`~.hipblasFillMode_t`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        alpha (`~.float2`/`~.object`):
            (undocumented)

        x (`~.float2`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        stridex (`~.int`):
            (undocumented)

        y (`~.float2`/`~.object`):
            (undocumented)

        incy (`~.int`):
            (undocumented)

        stridey (`~.int`):
            (undocumented)

        AP (`~.float2`/`~.object`):
            (undocumented)

        strideA (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")
    _hipblasChpr2StridedBatched_v2_64__retval = hipblasStatus_t(chipblas.hipblasChpr2StridedBatched_v2_64(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,uplo.value,n,
        float2.fromPyobj(alpha).getElementPtr(),
        float2.fromPyobj(x).getElementPtr(),incx,stridex,
        float2.fromPyobj(y).getElementPtr(),incy,stridey,
        float2.fromPyobj(AP).getElementPtr(),strideA,batchCount))
    return (_hipblasChpr2StridedBatched_v2_64__retval,)


@cython.embedsignature(True)
def hipblasZhpr2StridedBatched_v2_64(object handle, object uplo, long n, object alpha, object x, long incx, long stridex, object y, long incy, long stridey, object AP, long strideA, long batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        uplo (`~.hipblasFillMode_t`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        alpha (`~.double2`/`~.object`):
            (undocumented)

        x (`~.double2`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        stridex (`~.int`):
            (undocumented)

        y (`~.double2`/`~.object`):
            (undocumented)

        incy (`~.int`):
            (undocumented)

        stridey (`~.int`):
            (undocumented)

        AP (`~.double2`/`~.object`):
            (undocumented)

        strideA (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")
    _hipblasZhpr2StridedBatched_v2_64__retval = hipblasStatus_t(chipblas.hipblasZhpr2StridedBatched_v2_64(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,uplo.value,n,
        double2.fromPyobj(alpha).getElementPtr(),
        double2.fromPyobj(x).getElementPtr(),incx,stridex,
        double2.fromPyobj(y).getElementPtr(),incy,stridey,
        double2.fromPyobj(AP).getElementPtr(),strideA,batchCount))
    return (_hipblasZhpr2StridedBatched_v2_64__retval,)


@cython.embedsignature(True)
def hipblasSsbmv(object handle, object uplo, int n, int k, object alpha, object AP, int lda, object x, int incx, object beta, object y, int incy):
    r"""BLAS Level 2 API

    @{

    sbmv performs the matrix-vector operation:

    y := alpha*A*x + beta*y,

    where alpha and beta are scalars, x and y are n element vectors and
    A should contain an upper or lower triangular n by n symmetric banded matrix.

    - Supported precisions in rocBLAS : s,d
    - Supported precisions in cuBLAS  : s,d

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`) -- *IN*:
            [hipblasHandle_t]
            handle to the hipblas library context queue.

        uplo (`~.hipblasFillMode_t`) -- *IN*:
            [hipblasFillMode_t]
            specifies whether the upper 'HIPBLAS_FILL_MODE_UPPER' or lower 'HIPBLAS_FILL_MODE_LOWER'
            if HIPBLAS_FILL_MODE_UPPER, the lower part of A is not referenced
            if HIPBLAS_FILL_MODE_LOWER, the upper part of A is not referenced

        n (`~.int`) -- *IN*:
            [int]

        k (`~.int`) -- *IN*:
            [int]
            specifies the number of sub- and super-diagonals

        alpha (`~.hip._util.types.Pointer`/`~.object`) -- *IN*:
            specifies the scalar alpha

        AP (`~.hip._util.types.Pointer`/`~.object`) -- *IN*:
            pointer storing matrix A on the GPU

        lda (`~.int`) -- *IN*:
            [int]
            specifies the leading dimension of matrix A

        x (`~.hip._util.types.Pointer`/`~.object`) -- *IN*:
            pointer storing vector x on the GPU

        incx (`~.int`) -- *IN*:
            [int]
            specifies the increment for the elements of x

        beta (`~.hip._util.types.Pointer`/`~.object`) -- *IN*:
            specifies the scalar beta

        y (`~.hip._util.types.Pointer`/`~.object`) -- *OUT*:
            pointer storing vector y on the GPU

        incy (`~.int`) -- *IN*:
            [int]
            specifies the increment for the elements of y
    """
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")
    _hipblasSsbmv__retval = hipblasStatus_t(chipblas.hipblasSsbmv(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,uplo.value,n,k,
        <const float *>hip._util.types.Pointer.fromPyobj(alpha)._ptr,
        <const float *>hip._util.types.Pointer.fromPyobj(AP)._ptr,lda,
        <const float *>hip._util.types.Pointer.fromPyobj(x)._ptr,incx,
        <const float *>hip._util.types.Pointer.fromPyobj(beta)._ptr,
        <float *>hip._util.types.Pointer.fromPyobj(y)._ptr,incy))
    return (_hipblasSsbmv__retval,)


@cython.embedsignature(True)
def hipblasDsbmv(object handle, object uplo, int n, int k, object alpha, object AP, int lda, object x, int incx, object beta, object y, int incy):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        uplo (`~.hipblasFillMode_t`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        k (`~.int`):
            (undocumented)

        alpha (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        AP (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        x (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        beta (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        y (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        incy (`~.int`):
            (undocumented)
    """
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")
    _hipblasDsbmv__retval = hipblasStatus_t(chipblas.hipblasDsbmv(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,uplo.value,n,k,
        <const double *>hip._util.types.Pointer.fromPyobj(alpha)._ptr,
        <const double *>hip._util.types.Pointer.fromPyobj(AP)._ptr,lda,
        <const double *>hip._util.types.Pointer.fromPyobj(x)._ptr,incx,
        <const double *>hip._util.types.Pointer.fromPyobj(beta)._ptr,
        <double *>hip._util.types.Pointer.fromPyobj(y)._ptr,incy))
    return (_hipblasDsbmv__retval,)


@cython.embedsignature(True)
def hipblasSsbmv_64(object handle, object uplo, long n, long k, object alpha, object AP, long lda, object x, long incx, object beta, object y, long incy):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        uplo (`~.hipblasFillMode_t`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        k (`~.int`):
            (undocumented)

        alpha (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        AP (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        x (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        beta (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        y (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        incy (`~.int`):
            (undocumented)
    """
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")
    _hipblasSsbmv_64__retval = hipblasStatus_t(chipblas.hipblasSsbmv_64(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,uplo.value,n,k,
        <const float *>hip._util.types.Pointer.fromPyobj(alpha)._ptr,
        <const float *>hip._util.types.Pointer.fromPyobj(AP)._ptr,lda,
        <const float *>hip._util.types.Pointer.fromPyobj(x)._ptr,incx,
        <const float *>hip._util.types.Pointer.fromPyobj(beta)._ptr,
        <float *>hip._util.types.Pointer.fromPyobj(y)._ptr,incy))
    return (_hipblasSsbmv_64__retval,)


@cython.embedsignature(True)
def hipblasDsbmv_64(object handle, object uplo, long n, long k, object alpha, object AP, long lda, object x, long incx, object beta, object y, long incy):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        uplo (`~.hipblasFillMode_t`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        k (`~.int`):
            (undocumented)

        alpha (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        AP (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        x (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        beta (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        y (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        incy (`~.int`):
            (undocumented)
    """
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")
    _hipblasDsbmv_64__retval = hipblasStatus_t(chipblas.hipblasDsbmv_64(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,uplo.value,n,k,
        <const double *>hip._util.types.Pointer.fromPyobj(alpha)._ptr,
        <const double *>hip._util.types.Pointer.fromPyobj(AP)._ptr,lda,
        <const double *>hip._util.types.Pointer.fromPyobj(x)._ptr,incx,
        <const double *>hip._util.types.Pointer.fromPyobj(beta)._ptr,
        <double *>hip._util.types.Pointer.fromPyobj(y)._ptr,incy))
    return (_hipblasDsbmv_64__retval,)


@cython.embedsignature(True)
def hipblasSsbmvBatched(object handle, object uplo, int n, int k, object alpha, object AP, int lda, object x, int incx, object beta, object y, int incy, int batchCount):
    r"""BLAS Level 2 API

    @{

    sbmvBatched performs the matrix-vector operation:

    y_i := alpha*A_i*x_i + beta*y_i,

    where (A_i, x_i, y_i) is the i-th instance of the batch.
    alpha and beta are scalars, x_i and y_i are vectors and A_i is an
    n by n symmetric banded matrix, for i = 1, ..., batchCount.
    A should contain an upper or lower triangular n by n symmetric banded matrix.

    - Supported precisions in rocBLAS : s,d
    - Supported precisions in cuBLAS  : No support

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`) -- *IN*:
            [hipblasHandle_t]
            handle to the hipblas library context queue

        uplo (`~.hipblasFillMode_t`) -- *IN*:
            [hipblasFillMode_t]
            specifies whether the upper 'HIPBLAS_FILL_MODE_UPPER' or lower 'HIPBLAS_FILL_MODE_LOWER'
            if HIPBLAS_FILL_MODE_UPPER, the lower part of A is not referenced
            if HIPBLAS_FILL_MODE_LOWER, the upper part of A is not referenced

        n (`~.int`) -- *IN*:
            [int]
            number of rows and columns of each matrix A_i

        k (`~.int`) -- *IN*:
            [int]
            specifies the number of sub- and super-diagonals

        alpha (`~.hip._util.types.Pointer`/`~.object`) -- *IN*:
            device pointer or host pointer to scalar alpha

        AP (`~.hip._util.types.Pointer`/`~.object`) -- *IN*:
            device array of device pointers storing each matrix A_i

        lda (`~.int`) -- *IN*:
            [int]
            specifies the leading dimension of each matrix A_i

        x (`~.hip._util.types.ListOfPointer`/`~.object`) -- *IN*:
            device array of device pointers storing each vector x_i

        incx (`~.int`) -- *IN*:
            [int]
            specifies the increment for the elements of each vector x_i

        beta (`~.hip._util.types.Pointer`/`~.object`) -- *IN*:
            device pointer or host pointer to scalar beta

        y (`~.hip._util.types.ListOfPointer`/`~.object`) -- *OUT*:
            device array of device pointers storing each vector y_i

        incy (`~.int`) -- *IN*:
            [int]
            specifies the increment for the elements of each vector y_i

        batchCount (`~.int`) -- *IN*:
            [int]
            number of instances in the batch
    """
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")
    _hipblasSsbmvBatched__retval = hipblasStatus_t(chipblas.hipblasSsbmvBatched(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,uplo.value,n,k,
        <const float *>hip._util.types.Pointer.fromPyobj(alpha)._ptr,
        <const float *const*>hip._util.types.Pointer.fromPyobj(AP)._ptr,lda,
        <const float *const*>hip._util.types.ListOfPointer.fromPyobj(x)._ptr,incx,
        <const float *>hip._util.types.Pointer.fromPyobj(beta)._ptr,
        <float *const*>hip._util.types.ListOfPointer.fromPyobj(y)._ptr,incy,batchCount))
    return (_hipblasSsbmvBatched__retval,)


@cython.embedsignature(True)
def hipblasDsbmvBatched(object handle, object uplo, int n, int k, object alpha, object AP, int lda, object x, int incx, object beta, object y, int incy, int batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        uplo (`~.hipblasFillMode_t`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        k (`~.int`):
            (undocumented)

        alpha (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        AP (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        x (`~.hip._util.types.ListOfPointer`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        beta (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        y (`~.hip._util.types.ListOfPointer`/`~.object`):
            (undocumented)

        incy (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")
    _hipblasDsbmvBatched__retval = hipblasStatus_t(chipblas.hipblasDsbmvBatched(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,uplo.value,n,k,
        <const double *>hip._util.types.Pointer.fromPyobj(alpha)._ptr,
        <const double *const*>hip._util.types.Pointer.fromPyobj(AP)._ptr,lda,
        <const double *const*>hip._util.types.ListOfPointer.fromPyobj(x)._ptr,incx,
        <const double *>hip._util.types.Pointer.fromPyobj(beta)._ptr,
        <double *const*>hip._util.types.ListOfPointer.fromPyobj(y)._ptr,incy,batchCount))
    return (_hipblasDsbmvBatched__retval,)


@cython.embedsignature(True)
def hipblasSsbmvBatched_64(object handle, object uplo, long n, long k, object alpha, object AP, long lda, object x, long incx, object beta, object y, long incy, long batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        uplo (`~.hipblasFillMode_t`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        k (`~.int`):
            (undocumented)

        alpha (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        AP (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        x (`~.hip._util.types.ListOfPointer`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        beta (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        y (`~.hip._util.types.ListOfPointer`/`~.object`):
            (undocumented)

        incy (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")
    _hipblasSsbmvBatched_64__retval = hipblasStatus_t(chipblas.hipblasSsbmvBatched_64(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,uplo.value,n,k,
        <const float *>hip._util.types.Pointer.fromPyobj(alpha)._ptr,
        <const float *const*>hip._util.types.Pointer.fromPyobj(AP)._ptr,lda,
        <const float *const*>hip._util.types.ListOfPointer.fromPyobj(x)._ptr,incx,
        <const float *>hip._util.types.Pointer.fromPyobj(beta)._ptr,
        <float *const*>hip._util.types.ListOfPointer.fromPyobj(y)._ptr,incy,batchCount))
    return (_hipblasSsbmvBatched_64__retval,)


@cython.embedsignature(True)
def hipblasDsbmvBatched_64(object handle, object uplo, long n, long k, object alpha, object AP, long lda, object x, long incx, object beta, object y, long incy, long batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        uplo (`~.hipblasFillMode_t`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        k (`~.int`):
            (undocumented)

        alpha (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        AP (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        x (`~.hip._util.types.ListOfPointer`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        beta (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        y (`~.hip._util.types.ListOfPointer`/`~.object`):
            (undocumented)

        incy (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")
    _hipblasDsbmvBatched_64__retval = hipblasStatus_t(chipblas.hipblasDsbmvBatched_64(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,uplo.value,n,k,
        <const double *>hip._util.types.Pointer.fromPyobj(alpha)._ptr,
        <const double *const*>hip._util.types.Pointer.fromPyobj(AP)._ptr,lda,
        <const double *const*>hip._util.types.ListOfPointer.fromPyobj(x)._ptr,incx,
        <const double *>hip._util.types.Pointer.fromPyobj(beta)._ptr,
        <double *const*>hip._util.types.ListOfPointer.fromPyobj(y)._ptr,incy,batchCount))
    return (_hipblasDsbmvBatched_64__retval,)


@cython.embedsignature(True)
def hipblasSsbmvStridedBatched(object handle, object uplo, int n, int k, object alpha, object AP, int lda, long strideA, object x, int incx, long stridex, object beta, object y, int incy, long stridey, int batchCount):
    r"""BLAS Level 2 API

    @{

    sbmvStridedBatched performs the matrix-vector operation:

    y_i := alpha*A_i*x_i + beta*y_i,

    where (A_i, x_i, y_i) is the i-th instance of the batch.
    alpha and beta are scalars, x_i and y_i are vectors and A_i is an
    n by n symmetric banded matrix, for i = 1, ..., batchCount.
    A should contain an upper or lower triangular n by n symmetric banded matrix.

    - Supported precisions in rocBLAS : s,d
    - Supported precisions in cuBLAS  : No support

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`) -- *IN*:
            [hipblasHandle_t]
            handle to the hipblas library context queue

        uplo (`~.hipblasFillMode_t`) -- *IN*:
            [hipblasFillMode_t]
            specifies whether the upper 'HIPBLAS_FILL_MODE_UPPER' or lower 'HIPBLAS_FILL_MODE_LOWER'
            if HIPBLAS_FILL_MODE_UPPER, the lower part of A is not referenced
            if HIPBLAS_FILL_MODE_LOWER, the upper part of A is not referenced

        n (`~.int`) -- *IN*:
            [int]
            number of rows and columns of each matrix A_i

        k (`~.int`) -- *IN*:
            [int]
            specifies the number of sub- and super-diagonals

        alpha (`~.hip._util.types.Pointer`/`~.object`) -- *IN*:
            device pointer or host pointer to scalar alpha

        AP (`~.hip._util.types.Pointer`/`~.object`) -- *IN*:
            Device pointer to the first matrix A_1 on the GPU

        lda (`~.int`) -- *IN*:
            [int]
            specifies the leading dimension of each matrix A_i

        strideA (`~.int`) -- *IN*:
            [hipblasStride]
            stride from the start of one matrix (A_i) and the next one (A_i+1)

        x (`~.hip._util.types.Pointer`/`~.object`) -- *IN*:
            Device pointer to the first vector x_1 on the GPU

        incx (`~.int`) -- *IN*:
            [int]
            specifies the increment for the elements of each vector x_i

        stridex (`~.int`) -- *IN*:
            [hipblasStride]
            stride from the start of one vector (x_i) and the next one (x_i+1).
            There are no restrictions placed on stridex, however the user should
            take care to ensure that stridex is of appropriate size.
            This typically means stridex >= n * incx. stridex should be non zero.

        beta (`~.hip._util.types.Pointer`/`~.object`) -- *IN*:
            device pointer or host pointer to scalar beta

        y (`~.hip._util.types.Pointer`/`~.object`) -- *OUT*:
            Device pointer to the first vector y_1 on the GPU

        incy (`~.int`) -- *IN*:
            [int]
            specifies the increment for the elements of each vector y_i

        stridey (`~.int`) -- *IN*:
            [hipblasStride]
            stride from the start of one vector (y_i) and the next one (y_i+1).
            There are no restrictions placed on stridey, however the user should
            take care to ensure that stridey is of appropriate size.
            This typically means stridey >= n * incy. stridey should be non zero.

        batchCount (`~.int`) -- *IN*:
            [int]
            number of instances in the batch
    """
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")
    _hipblasSsbmvStridedBatched__retval = hipblasStatus_t(chipblas.hipblasSsbmvStridedBatched(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,uplo.value,n,k,
        <const float *>hip._util.types.Pointer.fromPyobj(alpha)._ptr,
        <const float *>hip._util.types.Pointer.fromPyobj(AP)._ptr,lda,strideA,
        <const float *>hip._util.types.Pointer.fromPyobj(x)._ptr,incx,stridex,
        <const float *>hip._util.types.Pointer.fromPyobj(beta)._ptr,
        <float *>hip._util.types.Pointer.fromPyobj(y)._ptr,incy,stridey,batchCount))
    return (_hipblasSsbmvStridedBatched__retval,)


@cython.embedsignature(True)
def hipblasDsbmvStridedBatched(object handle, object uplo, int n, int k, object alpha, object AP, int lda, long strideA, object x, int incx, long stridex, object beta, object y, int incy, long stridey, int batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        uplo (`~.hipblasFillMode_t`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        k (`~.int`):
            (undocumented)

        alpha (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        AP (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        strideA (`~.int`):
            (undocumented)

        x (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        stridex (`~.int`):
            (undocumented)

        beta (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        y (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        incy (`~.int`):
            (undocumented)

        stridey (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")
    _hipblasDsbmvStridedBatched__retval = hipblasStatus_t(chipblas.hipblasDsbmvStridedBatched(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,uplo.value,n,k,
        <const double *>hip._util.types.Pointer.fromPyobj(alpha)._ptr,
        <const double *>hip._util.types.Pointer.fromPyobj(AP)._ptr,lda,strideA,
        <const double *>hip._util.types.Pointer.fromPyobj(x)._ptr,incx,stridex,
        <const double *>hip._util.types.Pointer.fromPyobj(beta)._ptr,
        <double *>hip._util.types.Pointer.fromPyobj(y)._ptr,incy,stridey,batchCount))
    return (_hipblasDsbmvStridedBatched__retval,)


@cython.embedsignature(True)
def hipblasSsbmvStridedBatched_64(object handle, object uplo, long n, long k, object alpha, object AP, long lda, long strideA, object x, long incx, long stridex, object beta, object y, long incy, long stridey, long batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        uplo (`~.hipblasFillMode_t`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        k (`~.int`):
            (undocumented)

        alpha (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        AP (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        strideA (`~.int`):
            (undocumented)

        x (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        stridex (`~.int`):
            (undocumented)

        beta (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        y (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        incy (`~.int`):
            (undocumented)

        stridey (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")
    _hipblasSsbmvStridedBatched_64__retval = hipblasStatus_t(chipblas.hipblasSsbmvStridedBatched_64(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,uplo.value,n,k,
        <const float *>hip._util.types.Pointer.fromPyobj(alpha)._ptr,
        <const float *>hip._util.types.Pointer.fromPyobj(AP)._ptr,lda,strideA,
        <const float *>hip._util.types.Pointer.fromPyobj(x)._ptr,incx,stridex,
        <const float *>hip._util.types.Pointer.fromPyobj(beta)._ptr,
        <float *>hip._util.types.Pointer.fromPyobj(y)._ptr,incy,stridey,batchCount))
    return (_hipblasSsbmvStridedBatched_64__retval,)


@cython.embedsignature(True)
def hipblasDsbmvStridedBatched_64(object handle, object uplo, long n, long k, object alpha, object AP, long lda, long strideA, object x, long incx, long stridex, object beta, object y, long incy, long stridey, long batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        uplo (`~.hipblasFillMode_t`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        k (`~.int`):
            (undocumented)

        alpha (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        AP (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        strideA (`~.int`):
            (undocumented)

        x (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        stridex (`~.int`):
            (undocumented)

        beta (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        y (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        incy (`~.int`):
            (undocumented)

        stridey (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")
    _hipblasDsbmvStridedBatched_64__retval = hipblasStatus_t(chipblas.hipblasDsbmvStridedBatched_64(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,uplo.value,n,k,
        <const double *>hip._util.types.Pointer.fromPyobj(alpha)._ptr,
        <const double *>hip._util.types.Pointer.fromPyobj(AP)._ptr,lda,strideA,
        <const double *>hip._util.types.Pointer.fromPyobj(x)._ptr,incx,stridex,
        <const double *>hip._util.types.Pointer.fromPyobj(beta)._ptr,
        <double *>hip._util.types.Pointer.fromPyobj(y)._ptr,incy,stridey,batchCount))
    return (_hipblasDsbmvStridedBatched_64__retval,)


@cython.embedsignature(True)
def hipblasSspmv(object handle, object uplo, int n, object alpha, object AP, object x, int incx, object beta, object y, int incy):
    r"""BLAS Level 2 API

    @{

    spmv performs the matrix-vector operation:

    y := alpha*A*x + beta*y,

    where alpha and beta are scalars, x and y are n element vectors and
    A should contain an upper or lower triangular n by n packed symmetric matrix.

    - Supported precisions in rocBLAS : s,d
    - Supported precisions in cuBLAS  : s,d

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`) -- *IN*:
            [hipblasHandle_t]
            handle to the hipblas library context queue.

        uplo (`~.hipblasFillMode_t`) -- *IN*:
            [hipblasFillMode_t]
            specifies whether the upper 'HIPBLAS_FILL_MODE_UPPER' or lower 'HIPBLAS_FILL_MODE_LOWER'
            if HIPBLAS_FILL_MODE_UPPER, the lower part of A is not referenced
            if HIPBLAS_FILL_MODE_LOWER, the upper part of A is not referenced

        n (`~.int`) -- *IN*:
            [int]

        alpha (`~.hip._util.types.Pointer`/`~.object`) -- *IN*:
            specifies the scalar alpha

        AP (`~.hip._util.types.Pointer`/`~.object`) -- *IN*:
            pointer storing matrix A on the GPU

        x (`~.hip._util.types.Pointer`/`~.object`) -- *IN*:
            pointer storing vector x on the GPU

        incx (`~.int`) -- *IN*:
            [int]
            specifies the increment for the elements of x

        beta (`~.hip._util.types.Pointer`/`~.object`) -- *IN*:
            specifies the scalar beta

        y (`~.hip._util.types.Pointer`/`~.object`) -- *OUT*:
            pointer storing vector y on the GPU

        incy (`~.int`) -- *IN*:
            [int]
            specifies the increment for the elements of y
    """
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")
    _hipblasSspmv__retval = hipblasStatus_t(chipblas.hipblasSspmv(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,uplo.value,n,
        <const float *>hip._util.types.Pointer.fromPyobj(alpha)._ptr,
        <const float *>hip._util.types.Pointer.fromPyobj(AP)._ptr,
        <const float *>hip._util.types.Pointer.fromPyobj(x)._ptr,incx,
        <const float *>hip._util.types.Pointer.fromPyobj(beta)._ptr,
        <float *>hip._util.types.Pointer.fromPyobj(y)._ptr,incy))
    return (_hipblasSspmv__retval,)


@cython.embedsignature(True)
def hipblasDspmv(object handle, object uplo, int n, object alpha, object AP, object x, int incx, object beta, object y, int incy):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        uplo (`~.hipblasFillMode_t`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        alpha (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        AP (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        x (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        beta (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        y (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        incy (`~.int`):
            (undocumented)
    """
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")
    _hipblasDspmv__retval = hipblasStatus_t(chipblas.hipblasDspmv(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,uplo.value,n,
        <const double *>hip._util.types.Pointer.fromPyobj(alpha)._ptr,
        <const double *>hip._util.types.Pointer.fromPyobj(AP)._ptr,
        <const double *>hip._util.types.Pointer.fromPyobj(x)._ptr,incx,
        <const double *>hip._util.types.Pointer.fromPyobj(beta)._ptr,
        <double *>hip._util.types.Pointer.fromPyobj(y)._ptr,incy))
    return (_hipblasDspmv__retval,)


@cython.embedsignature(True)
def hipblasSspmv_64(object handle, object uplo, long n, object alpha, object AP, object x, long incx, object beta, object y, long incy):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        uplo (`~.hipblasFillMode_t`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        alpha (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        AP (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        x (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        beta (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        y (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        incy (`~.int`):
            (undocumented)
    """
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")
    _hipblasSspmv_64__retval = hipblasStatus_t(chipblas.hipblasSspmv_64(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,uplo.value,n,
        <const float *>hip._util.types.Pointer.fromPyobj(alpha)._ptr,
        <const float *>hip._util.types.Pointer.fromPyobj(AP)._ptr,
        <const float *>hip._util.types.Pointer.fromPyobj(x)._ptr,incx,
        <const float *>hip._util.types.Pointer.fromPyobj(beta)._ptr,
        <float *>hip._util.types.Pointer.fromPyobj(y)._ptr,incy))
    return (_hipblasSspmv_64__retval,)


@cython.embedsignature(True)
def hipblasDspmv_64(object handle, object uplo, long n, object alpha, object AP, object x, long incx, object beta, object y, long incy):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        uplo (`~.hipblasFillMode_t`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        alpha (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        AP (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        x (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        beta (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        y (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        incy (`~.int`):
            (undocumented)
    """
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")
    _hipblasDspmv_64__retval = hipblasStatus_t(chipblas.hipblasDspmv_64(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,uplo.value,n,
        <const double *>hip._util.types.Pointer.fromPyobj(alpha)._ptr,
        <const double *>hip._util.types.Pointer.fromPyobj(AP)._ptr,
        <const double *>hip._util.types.Pointer.fromPyobj(x)._ptr,incx,
        <const double *>hip._util.types.Pointer.fromPyobj(beta)._ptr,
        <double *>hip._util.types.Pointer.fromPyobj(y)._ptr,incy))
    return (_hipblasDspmv_64__retval,)


@cython.embedsignature(True)
def hipblasSspmvBatched(object handle, object uplo, int n, object alpha, object AP, object x, int incx, object beta, object y, int incy, int batchCount):
    r"""BLAS Level 2 API

    @{

    spmvBatched performs the matrix-vector operation:

    y_i := alpha*AP_i*x_i + beta*y_i,

    where (A_i, x_i, y_i) is the i-th instance of the batch.
    alpha and beta are scalars, x_i and y_i are vectors and A_i is an
    n by n symmetric matrix, for i = 1, ..., batchCount.
    A should contain an upper or lower triangular n by n packed symmetric matrix.

    - Supported precisions in rocBLAS : s,d
    - Supported precisions in cuBLAS  : No support

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`) -- *IN*:
            [hipblasHandle_t]
            handle to the hipblas library context queue

        uplo (`~.hipblasFillMode_t`) -- *IN*:
            [hipblasFillMode_t]
            specifies whether the upper 'HIPBLAS_FILL_MODE_UPPER' or lower 'HIPBLAS_FILL_MODE_LOWER'
            if HIPBLAS_FILL_MODE_UPPER, the lower part of A is not referenced
            if HIPBLAS_FILL_MODE_LOWER, the upper part of A is not referenced

        n (`~.int`) -- *IN*:
            [int]
            number of rows and columns of each matrix A_i

        alpha (`~.hip._util.types.Pointer`/`~.object`) -- *IN*:
            device pointer or host pointer to scalar alpha

        AP (`~.hip._util.types.Pointer`/`~.object`) -- *IN*:
            device array of device pointers storing each matrix A_i

        x (`~.hip._util.types.ListOfPointer`/`~.object`) -- *IN*:
            device array of device pointers storing each vector x_i

        incx (`~.int`) -- *IN*:
            [int]
            specifies the increment for the elements of each vector x_i

        beta (`~.hip._util.types.Pointer`/`~.object`) -- *IN*:
            device pointer or host pointer to scalar beta

        y (`~.hip._util.types.ListOfPointer`/`~.object`) -- *OUT*:
            device array of device pointers storing each vector y_i

        incy (`~.int`) -- *IN*:
            [int]
            specifies the increment for the elements of each vector y_i

        batchCount (`~.int`) -- *IN*:
            [int]
            number of instances in the batch
    """
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")
    _hipblasSspmvBatched__retval = hipblasStatus_t(chipblas.hipblasSspmvBatched(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,uplo.value,n,
        <const float *>hip._util.types.Pointer.fromPyobj(alpha)._ptr,
        <const float *const*>hip._util.types.Pointer.fromPyobj(AP)._ptr,
        <const float *const*>hip._util.types.ListOfPointer.fromPyobj(x)._ptr,incx,
        <const float *>hip._util.types.Pointer.fromPyobj(beta)._ptr,
        <float *const*>hip._util.types.ListOfPointer.fromPyobj(y)._ptr,incy,batchCount))
    return (_hipblasSspmvBatched__retval,)


@cython.embedsignature(True)
def hipblasDspmvBatched(object handle, object uplo, int n, object alpha, object AP, object x, int incx, object beta, object y, int incy, int batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        uplo (`~.hipblasFillMode_t`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        alpha (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        AP (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        x (`~.hip._util.types.ListOfPointer`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        beta (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        y (`~.hip._util.types.ListOfPointer`/`~.object`):
            (undocumented)

        incy (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")
    _hipblasDspmvBatched__retval = hipblasStatus_t(chipblas.hipblasDspmvBatched(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,uplo.value,n,
        <const double *>hip._util.types.Pointer.fromPyobj(alpha)._ptr,
        <const double *const*>hip._util.types.Pointer.fromPyobj(AP)._ptr,
        <const double *const*>hip._util.types.ListOfPointer.fromPyobj(x)._ptr,incx,
        <const double *>hip._util.types.Pointer.fromPyobj(beta)._ptr,
        <double *const*>hip._util.types.ListOfPointer.fromPyobj(y)._ptr,incy,batchCount))
    return (_hipblasDspmvBatched__retval,)


@cython.embedsignature(True)
def hipblasSspmvBatched_64(object handle, object uplo, long n, object alpha, object AP, object x, long incx, object beta, object y, long incy, long batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        uplo (`~.hipblasFillMode_t`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        alpha (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        AP (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        x (`~.hip._util.types.ListOfPointer`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        beta (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        y (`~.hip._util.types.ListOfPointer`/`~.object`):
            (undocumented)

        incy (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")
    _hipblasSspmvBatched_64__retval = hipblasStatus_t(chipblas.hipblasSspmvBatched_64(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,uplo.value,n,
        <const float *>hip._util.types.Pointer.fromPyobj(alpha)._ptr,
        <const float *const*>hip._util.types.Pointer.fromPyobj(AP)._ptr,
        <const float *const*>hip._util.types.ListOfPointer.fromPyobj(x)._ptr,incx,
        <const float *>hip._util.types.Pointer.fromPyobj(beta)._ptr,
        <float *const*>hip._util.types.ListOfPointer.fromPyobj(y)._ptr,incy,batchCount))
    return (_hipblasSspmvBatched_64__retval,)


@cython.embedsignature(True)
def hipblasDspmvBatched_64(object handle, object uplo, long n, object alpha, object AP, object x, long incx, object beta, object y, long incy, long batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        uplo (`~.hipblasFillMode_t`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        alpha (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        AP (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        x (`~.hip._util.types.ListOfPointer`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        beta (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        y (`~.hip._util.types.ListOfPointer`/`~.object`):
            (undocumented)

        incy (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")
    _hipblasDspmvBatched_64__retval = hipblasStatus_t(chipblas.hipblasDspmvBatched_64(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,uplo.value,n,
        <const double *>hip._util.types.Pointer.fromPyobj(alpha)._ptr,
        <const double *const*>hip._util.types.Pointer.fromPyobj(AP)._ptr,
        <const double *const*>hip._util.types.ListOfPointer.fromPyobj(x)._ptr,incx,
        <const double *>hip._util.types.Pointer.fromPyobj(beta)._ptr,
        <double *const*>hip._util.types.ListOfPointer.fromPyobj(y)._ptr,incy,batchCount))
    return (_hipblasDspmvBatched_64__retval,)


@cython.embedsignature(True)
def hipblasSspmvStridedBatched(object handle, object uplo, int n, object alpha, object AP, long strideA, object x, int incx, long stridex, object beta, object y, int incy, long stridey, int batchCount):
    r"""BLAS Level 2 API

    @{

    spmvStridedBatched performs the matrix-vector operation:

    y_i := alpha*A_i*x_i + beta*y_i,

    where (A_i, x_i, y_i) is the i-th instance of the batch.
    alpha and beta are scalars, x_i and y_i are vectors and A_i is an
    n by n symmetric matrix, for i = 1, ..., batchCount.
    A should contain an upper or lower triangular n by n packed symmetric matrix.

    - Supported precisions in rocBLAS : s,d
    - Supported precisions in cuBLAS  : No support

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`) -- *IN*:
            [hipblasHandle_t]
            handle to the hipblas library context queue

        uplo (`~.hipblasFillMode_t`) -- *IN*:
            [hipblasFillMode_t]
            specifies whether the upper 'HIPBLAS_FILL_MODE_UPPER' or lower 'HIPBLAS_FILL_MODE_LOWER'
            if HIPBLAS_FILL_MODE_UPPER, the lower part of A is not referenced
            if HIPBLAS_FILL_MODE_LOWER, the upper part of A is not referenced

        n (`~.int`) -- *IN*:
            [int]
            number of rows and columns of each matrix A_i

        alpha (`~.hip._util.types.Pointer`/`~.object`) -- *IN*:
            device pointer or host pointer to scalar alpha

        AP (`~.hip._util.types.Pointer`/`~.object`) -- *IN*:
            Device pointer to the first matrix A_1 on the GPU

        strideA (`~.int`) -- *IN*:
            [hipblasStride]
            stride from the start of one matrix (A_i) and the next one (A_i+1)

        x (`~.hip._util.types.Pointer`/`~.object`) -- *IN*:
            Device pointer to the first vector x_1 on the GPU

        incx (`~.int`) -- *IN*:
            [int]
            specifies the increment for the elements of each vector x_i

        stridex (`~.int`) -- *IN*:
            [hipblasStride]
            stride from the start of one vector (x_i) and the next one (x_i+1).
            There are no restrictions placed on stridex, however the user should
            take care to ensure that stridex is of appropriate size.
            This typically means stridex >= n * incx. stridex should be non zero.

        beta (`~.hip._util.types.Pointer`/`~.object`) -- *IN*:
            device pointer or host pointer to scalar beta

        y (`~.hip._util.types.Pointer`/`~.object`) -- *OUT*:
            Device pointer to the first vector y_1 on the GPU

        incy (`~.int`) -- *IN*:
            [int]
            specifies the increment for the elements of each vector y_i

        stridey (`~.int`) -- *IN*:
            [hipblasStride]
            stride from the start of one vector (y_i) and the next one (y_i+1).
            There are no restrictions placed on stridey, however the user should
            take care to ensure that stridey is of appropriate size.
            This typically means stridey >= n * incy. stridey should be non zero.

        batchCount (`~.int`) -- *IN*:
            [int]
            number of instances in the batch
    """
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")
    _hipblasSspmvStridedBatched__retval = hipblasStatus_t(chipblas.hipblasSspmvStridedBatched(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,uplo.value,n,
        <const float *>hip._util.types.Pointer.fromPyobj(alpha)._ptr,
        <const float *>hip._util.types.Pointer.fromPyobj(AP)._ptr,strideA,
        <const float *>hip._util.types.Pointer.fromPyobj(x)._ptr,incx,stridex,
        <const float *>hip._util.types.Pointer.fromPyobj(beta)._ptr,
        <float *>hip._util.types.Pointer.fromPyobj(y)._ptr,incy,stridey,batchCount))
    return (_hipblasSspmvStridedBatched__retval,)


@cython.embedsignature(True)
def hipblasDspmvStridedBatched(object handle, object uplo, int n, object alpha, object AP, long strideA, object x, int incx, long stridex, object beta, object y, int incy, long stridey, int batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        uplo (`~.hipblasFillMode_t`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        alpha (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        AP (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        strideA (`~.int`):
            (undocumented)

        x (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        stridex (`~.int`):
            (undocumented)

        beta (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        y (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        incy (`~.int`):
            (undocumented)

        stridey (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")
    _hipblasDspmvStridedBatched__retval = hipblasStatus_t(chipblas.hipblasDspmvStridedBatched(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,uplo.value,n,
        <const double *>hip._util.types.Pointer.fromPyobj(alpha)._ptr,
        <const double *>hip._util.types.Pointer.fromPyobj(AP)._ptr,strideA,
        <const double *>hip._util.types.Pointer.fromPyobj(x)._ptr,incx,stridex,
        <const double *>hip._util.types.Pointer.fromPyobj(beta)._ptr,
        <double *>hip._util.types.Pointer.fromPyobj(y)._ptr,incy,stridey,batchCount))
    return (_hipblasDspmvStridedBatched__retval,)


@cython.embedsignature(True)
def hipblasSspmvStridedBatched_64(object handle, object uplo, long n, object alpha, object AP, long strideA, object x, long incx, long stridex, object beta, object y, long incy, long stridey, long batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        uplo (`~.hipblasFillMode_t`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        alpha (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        AP (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        strideA (`~.int`):
            (undocumented)

        x (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        stridex (`~.int`):
            (undocumented)

        beta (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        y (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        incy (`~.int`):
            (undocumented)

        stridey (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")
    _hipblasSspmvStridedBatched_64__retval = hipblasStatus_t(chipblas.hipblasSspmvStridedBatched_64(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,uplo.value,n,
        <const float *>hip._util.types.Pointer.fromPyobj(alpha)._ptr,
        <const float *>hip._util.types.Pointer.fromPyobj(AP)._ptr,strideA,
        <const float *>hip._util.types.Pointer.fromPyobj(x)._ptr,incx,stridex,
        <const float *>hip._util.types.Pointer.fromPyobj(beta)._ptr,
        <float *>hip._util.types.Pointer.fromPyobj(y)._ptr,incy,stridey,batchCount))
    return (_hipblasSspmvStridedBatched_64__retval,)


@cython.embedsignature(True)
def hipblasDspmvStridedBatched_64(object handle, object uplo, long n, object alpha, object AP, long strideA, object x, long incx, long stridex, object beta, object y, long incy, long stridey, long batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        uplo (`~.hipblasFillMode_t`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        alpha (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        AP (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        strideA (`~.int`):
            (undocumented)

        x (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        stridex (`~.int`):
            (undocumented)

        beta (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        y (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        incy (`~.int`):
            (undocumented)

        stridey (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")
    _hipblasDspmvStridedBatched_64__retval = hipblasStatus_t(chipblas.hipblasDspmvStridedBatched_64(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,uplo.value,n,
        <const double *>hip._util.types.Pointer.fromPyobj(alpha)._ptr,
        <const double *>hip._util.types.Pointer.fromPyobj(AP)._ptr,strideA,
        <const double *>hip._util.types.Pointer.fromPyobj(x)._ptr,incx,stridex,
        <const double *>hip._util.types.Pointer.fromPyobj(beta)._ptr,
        <double *>hip._util.types.Pointer.fromPyobj(y)._ptr,incy,stridey,batchCount))
    return (_hipblasDspmvStridedBatched_64__retval,)


@cython.embedsignature(True)
def hipblasSspr(object handle, object uplo, int n, object alpha, object x, int incx, object AP):
    r"""BLAS Level 2 API

    @{

    spr performs the matrix-vector operations

    A := A + alpha*x*x**T

    where alpha is a scalar, x is a vector, and A is an
    n by n symmetric matrix, supplied in packed form.

    - Supported precisions in rocBLAS : s,d,c,z
    - Supported precisions in cuBLAS  : s,d,c,z

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`) -- *IN*:
            [hipblasHandle_t]
            handle to the hipblas library context queue.

        uplo (`~.hipblasFillMode_t`) -- *IN*:
            [hipblasFillMode_t]
            specifies whether the upper 'HIPBLAS_FILL_MODE_UPPER' or lower 'HIPBLAS_FILL_MODE_LOWER'
            HIPBLAS_FILL_MODE_UPPER: The upper triangular part of A is supplied in AP.
            HIPBLAS_FILL_MODE_LOWER: The lower triangular part of A is supplied in AP.

        n (`~.int`) -- *IN*:
            [int]
            the number of rows and columns of matrix A, must be at least 0.

        alpha (`~.hip._util.types.Pointer`/`~.object`) -- *IN*:
            device pointer or host pointer to scalar alpha.

        x (`~.hip._util.types.Pointer`/`~.object`) -- *IN*:
            device pointer storing vector x.

        incx (`~.int`) -- *IN*:
            [int]
            specifies the increment for the elements of x.

        AP (`~.hip._util.types.Pointer`/`~.object`) -- *INOUT*:
            device pointer storing the packed version of the specified triangular portion of
              the symmetric matrix A. Of at least size ((n * (n + 1)) / 2).
              if uplo == HIPBLAS_FILL_MODE_UPPER:
                The upper triangular portion of the symmetric matrix A is supplied.
                The matrix is compacted so that AP contains the triangular portion column-by-column
                so that:
                AP(0) = A(0,0)
                AP(1) = A(0,1)
                AP(2) = A(1,1), etc.
                    Ex: (HIPBLAS_FILL_MODE_UPPER; n = 4)
                        1 2 4 7
                        2 3 5 8   -----> [1, 2, 3, 4, 5, 6, 7, 8, 9, 0]
                        4 5 6 9
                        7 8 9 0
            if uplo == HIPBLAS_FILL_MODE_LOWER:
                The lower triangular portion of the symmetric matrix A is supplied.
                The matrix is compacted so that AP contains the triangular portion column-by-column
                so that:
                AP(0) = A(0,0)
                AP(1) = A(1,0)
                AP(2) = A(2,1), etc.
                    Ex: (HIPBLAS_FILL_MODE_LOWER; n = 4)
                        1 2 3 4
                        2 5 6 7    -----> [1, 2, 3, 4, 5, 6, 7, 8, 9, 0]
                        3 6 8 9
                        4 7 9 0
    """
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")
    _hipblasSspr__retval = hipblasStatus_t(chipblas.hipblasSspr(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,uplo.value,n,
        <const float *>hip._util.types.Pointer.fromPyobj(alpha)._ptr,
        <const float *>hip._util.types.Pointer.fromPyobj(x)._ptr,incx,
        <float *>hip._util.types.Pointer.fromPyobj(AP)._ptr))
    return (_hipblasSspr__retval,)


@cython.embedsignature(True)
def hipblasDspr(object handle, object uplo, int n, object alpha, object x, int incx, object AP):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        uplo (`~.hipblasFillMode_t`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        alpha (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        x (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        AP (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)
    """
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")
    _hipblasDspr__retval = hipblasStatus_t(chipblas.hipblasDspr(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,uplo.value,n,
        <const double *>hip._util.types.Pointer.fromPyobj(alpha)._ptr,
        <const double *>hip._util.types.Pointer.fromPyobj(x)._ptr,incx,
        <double *>hip._util.types.Pointer.fromPyobj(AP)._ptr))
    return (_hipblasDspr__retval,)


@cython.embedsignature(True)
def hipblasCspr(object handle, object uplo, int n, object alpha, object x, int incx, object AP):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        uplo (`~.hipblasFillMode_t`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        alpha (`~.hipblasComplex`/`~.object`):
            (undocumented)

        x (`~.hipblasComplex`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        AP (`~.hipblasComplex`/`~.object`):
            (undocumented)
    """
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")
    _hipblasCspr__retval = hipblasStatus_t(chipblas.hipblasCspr(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,uplo.value,n,
        hipblasComplex.fromPyobj(alpha).getElementPtr(),
        hipblasComplex.fromPyobj(x).getElementPtr(),incx,
        hipblasComplex.fromPyobj(AP).getElementPtr()))
    return (_hipblasCspr__retval,)


@cython.embedsignature(True)
def hipblasZspr(object handle, object uplo, int n, object alpha, object x, int incx, object AP):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        uplo (`~.hipblasFillMode_t`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        alpha (`~.hipblasDoubleComplex`/`~.object`):
            (undocumented)

        x (`~.hipblasDoubleComplex`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        AP (`~.hipblasDoubleComplex`/`~.object`):
            (undocumented)
    """
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")
    _hipblasZspr__retval = hipblasStatus_t(chipblas.hipblasZspr(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,uplo.value,n,
        hipblasDoubleComplex.fromPyobj(alpha).getElementPtr(),
        hipblasDoubleComplex.fromPyobj(x).getElementPtr(),incx,
        hipblasDoubleComplex.fromPyobj(AP).getElementPtr()))
    return (_hipblasZspr__retval,)


@cython.embedsignature(True)
def hipblasCspr_v2(object handle, object uplo, int n, object alpha, object x, int incx, object AP):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        uplo (`~.hipblasFillMode_t`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        alpha (`~.float2`/`~.object`):
            (undocumented)

        x (`~.float2`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        AP (`~.float2`/`~.object`):
            (undocumented)
    """
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")
    _hipblasCspr_v2__retval = hipblasStatus_t(chipblas.hipblasCspr_v2(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,uplo.value,n,
        float2.fromPyobj(alpha).getElementPtr(),
        float2.fromPyobj(x).getElementPtr(),incx,
        float2.fromPyobj(AP).getElementPtr()))
    return (_hipblasCspr_v2__retval,)


@cython.embedsignature(True)
def hipblasZspr_v2(object handle, object uplo, int n, object alpha, object x, int incx, object AP):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        uplo (`~.hipblasFillMode_t`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        alpha (`~.double2`/`~.object`):
            (undocumented)

        x (`~.double2`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        AP (`~.double2`/`~.object`):
            (undocumented)
    """
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")
    _hipblasZspr_v2__retval = hipblasStatus_t(chipblas.hipblasZspr_v2(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,uplo.value,n,
        double2.fromPyobj(alpha).getElementPtr(),
        double2.fromPyobj(x).getElementPtr(),incx,
        double2.fromPyobj(AP).getElementPtr()))
    return (_hipblasZspr_v2__retval,)


@cython.embedsignature(True)
def hipblasSspr_64(object handle, object uplo, long n, object alpha, object x, long incx, object AP):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        uplo (`~.hipblasFillMode_t`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        alpha (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        x (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        AP (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)
    """
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")
    _hipblasSspr_64__retval = hipblasStatus_t(chipblas.hipblasSspr_64(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,uplo.value,n,
        <const float *>hip._util.types.Pointer.fromPyobj(alpha)._ptr,
        <const float *>hip._util.types.Pointer.fromPyobj(x)._ptr,incx,
        <float *>hip._util.types.Pointer.fromPyobj(AP)._ptr))
    return (_hipblasSspr_64__retval,)


@cython.embedsignature(True)
def hipblasDspr_64(object handle, object uplo, long n, object alpha, object x, long incx, object AP):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        uplo (`~.hipblasFillMode_t`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        alpha (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        x (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        AP (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)
    """
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")
    _hipblasDspr_64__retval = hipblasStatus_t(chipblas.hipblasDspr_64(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,uplo.value,n,
        <const double *>hip._util.types.Pointer.fromPyobj(alpha)._ptr,
        <const double *>hip._util.types.Pointer.fromPyobj(x)._ptr,incx,
        <double *>hip._util.types.Pointer.fromPyobj(AP)._ptr))
    return (_hipblasDspr_64__retval,)


@cython.embedsignature(True)
def hipblasCspr_64(object handle, object uplo, long n, object alpha, object x, long incx, object AP):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        uplo (`~.hipblasFillMode_t`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        alpha (`~.hipblasComplex`/`~.object`):
            (undocumented)

        x (`~.hipblasComplex`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        AP (`~.hipblasComplex`/`~.object`):
            (undocumented)
    """
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")
    _hipblasCspr_64__retval = hipblasStatus_t(chipblas.hipblasCspr_64(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,uplo.value,n,
        hipblasComplex.fromPyobj(alpha).getElementPtr(),
        hipblasComplex.fromPyobj(x).getElementPtr(),incx,
        hipblasComplex.fromPyobj(AP).getElementPtr()))
    return (_hipblasCspr_64__retval,)


@cython.embedsignature(True)
def hipblasZspr_64(object handle, object uplo, long n, object alpha, object x, long incx, object AP):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        uplo (`~.hipblasFillMode_t`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        alpha (`~.hipblasDoubleComplex`/`~.object`):
            (undocumented)

        x (`~.hipblasDoubleComplex`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        AP (`~.hipblasDoubleComplex`/`~.object`):
            (undocumented)
    """
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")
    _hipblasZspr_64__retval = hipblasStatus_t(chipblas.hipblasZspr_64(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,uplo.value,n,
        hipblasDoubleComplex.fromPyobj(alpha).getElementPtr(),
        hipblasDoubleComplex.fromPyobj(x).getElementPtr(),incx,
        hipblasDoubleComplex.fromPyobj(AP).getElementPtr()))
    return (_hipblasZspr_64__retval,)


@cython.embedsignature(True)
def hipblasCspr_v2_64(object handle, object uplo, long n, object alpha, object x, long incx, object AP):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        uplo (`~.hipblasFillMode_t`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        alpha (`~.float2`/`~.object`):
            (undocumented)

        x (`~.float2`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        AP (`~.float2`/`~.object`):
            (undocumented)
    """
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")
    _hipblasCspr_v2_64__retval = hipblasStatus_t(chipblas.hipblasCspr_v2_64(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,uplo.value,n,
        float2.fromPyobj(alpha).getElementPtr(),
        float2.fromPyobj(x).getElementPtr(),incx,
        float2.fromPyobj(AP).getElementPtr()))
    return (_hipblasCspr_v2_64__retval,)


@cython.embedsignature(True)
def hipblasZspr_v2_64(object handle, object uplo, long n, object alpha, object x, long incx, object AP):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        uplo (`~.hipblasFillMode_t`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        alpha (`~.double2`/`~.object`):
            (undocumented)

        x (`~.double2`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        AP (`~.double2`/`~.object`):
            (undocumented)
    """
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")
    _hipblasZspr_v2_64__retval = hipblasStatus_t(chipblas.hipblasZspr_v2_64(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,uplo.value,n,
        double2.fromPyobj(alpha).getElementPtr(),
        double2.fromPyobj(x).getElementPtr(),incx,
        double2.fromPyobj(AP).getElementPtr()))
    return (_hipblasZspr_v2_64__retval,)


@cython.embedsignature(True)
def hipblasSsprBatched(object handle, object uplo, int n, object alpha, object x, int incx, object AP, int batchCount):
    r"""BLAS Level 2 API

    @{

    sprBatched performs the matrix-vector operations

    A_i := A_i + alpha*x_i*x_i**T

    where alpha is a scalar, x_i is a vector, and A_i is an
    n by n symmetric matrix, supplied in packed form, for i = 1, ..., batchCount.

    - Supported precisions in rocBLAS : s,d,c,z
    - Supported precisions in cuBLAS  : No support

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`) -- *IN*:
            [hipblasHandle_t]
            handle to the hipblas library context queue.

        uplo (`~.hipblasFillMode_t`) -- *IN*:
            [hipblasFillMode_t]
            specifies whether the upper 'HIPBLAS_FILL_MODE_UPPER' or lower 'HIPBLAS_FILL_MODE_LOWER'
            HIPBLAS_FILL_MODE_UPPER: The upper triangular part of each A_i is supplied in AP.
            HIPBLAS_FILL_MODE_LOWER: The lower triangular part of each A_i is supplied in AP.

        n (`~.int`) -- *IN*:
            [int]
            the number of rows and columns of each matrix A_i, must be at least 0.

        alpha (`~.hip._util.types.Pointer`/`~.object`) -- *IN*:
            device pointer or host pointer to scalar alpha.

        x (`~.hip._util.types.ListOfPointer`/`~.object`) -- *IN*:
            device array of device pointers storing each vector x_i.

        incx (`~.int`) -- *IN*:
            [int]
            specifies the increment for the elements of each x_i.

        AP (`~.hip._util.types.Pointer`/`~.object`) -- *INOUT*:
            device array of device pointers storing the packed version of the specified triangular portion of
              each symmetric matrix A_i of at least size ((n * (n + 1)) / 2). Array is of at least size batchCount.
              if uplo == HIPBLAS_FILL_MODE_UPPER:
                The upper triangular portion of each symmetric matrix A_i is supplied.
                The matrix is compacted so that AP contains the triangular portion column-by-column
                so that:
                AP(0) = A(0,0)
                AP(1) = A(0,1)
                AP(2) = A(1,1), etc.
                    Ex: (HIPBLAS_FILL_MODE_UPPER; n = 4)
                        1 2 4 7
                        2 3 5 8   -----> [1, 2, 3, 4, 5, 6, 7, 8, 9, 0]
                        4 5 6 9
                        7 8 9 0
            if uplo == HIPBLAS_FILL_MODE_LOWER:
                The lower triangular portion of each symmetric matrix A_i is supplied.
                The matrix is compacted so that AP contains the triangular portion column-by-column
                so that:
                AP(0) = A(0,0)
                AP(1) = A(1,0)
                AP(2) = A(2,1), etc.
                    Ex: (HIPBLAS_FILL_MODE_LOWER; n = 4)
                        1 2 3 4
                        2 5 6 7    -----> [1, 2, 3, 4, 5, 6, 7, 8, 9, 0]
                        3 6 8 9
                        4 7 9 0

        batchCount (`~.int`) -- *IN*:
            [int]
            number of instances in the batch.
    """
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")
    _hipblasSsprBatched__retval = hipblasStatus_t(chipblas.hipblasSsprBatched(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,uplo.value,n,
        <const float *>hip._util.types.Pointer.fromPyobj(alpha)._ptr,
        <const float *const*>hip._util.types.ListOfPointer.fromPyobj(x)._ptr,incx,
        <float *const*>hip._util.types.Pointer.fromPyobj(AP)._ptr,batchCount))
    return (_hipblasSsprBatched__retval,)


@cython.embedsignature(True)
def hipblasDsprBatched(object handle, object uplo, int n, object alpha, object x, int incx, object AP, int batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        uplo (`~.hipblasFillMode_t`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        alpha (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        x (`~.hip._util.types.ListOfPointer`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        AP (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")
    _hipblasDsprBatched__retval = hipblasStatus_t(chipblas.hipblasDsprBatched(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,uplo.value,n,
        <const double *>hip._util.types.Pointer.fromPyobj(alpha)._ptr,
        <const double *const*>hip._util.types.ListOfPointer.fromPyobj(x)._ptr,incx,
        <double *const*>hip._util.types.Pointer.fromPyobj(AP)._ptr,batchCount))
    return (_hipblasDsprBatched__retval,)


@cython.embedsignature(True)
def hipblasCsprBatched(object handle, object uplo, int n, object alpha, object x, int incx, object AP, int batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        uplo (`~.hipblasFillMode_t`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        alpha (`~.hipblasComplex`/`~.object`):
            (undocumented)

        x (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        AP (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")
    _hipblasCsprBatched__retval = hipblasStatus_t(chipblas.hipblasCsprBatched(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,uplo.value,n,
        hipblasComplex.fromPyobj(alpha).getElementPtr(),
        <chipblas.hipblasComplex *const*>hip._util.types.Pointer.fromPyobj(x)._ptr,incx,
        <chipblas.hipblasComplex *const*>hip._util.types.Pointer.fromPyobj(AP)._ptr,batchCount))
    return (_hipblasCsprBatched__retval,)


@cython.embedsignature(True)
def hipblasZsprBatched(object handle, object uplo, int n, object alpha, object x, int incx, object AP, int batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        uplo (`~.hipblasFillMode_t`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        alpha (`~.hipblasDoubleComplex`/`~.object`):
            (undocumented)

        x (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        AP (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")
    _hipblasZsprBatched__retval = hipblasStatus_t(chipblas.hipblasZsprBatched(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,uplo.value,n,
        hipblasDoubleComplex.fromPyobj(alpha).getElementPtr(),
        <chipblas.hipblasDoubleComplex *const*>hip._util.types.Pointer.fromPyobj(x)._ptr,incx,
        <chipblas.hipblasDoubleComplex *const*>hip._util.types.Pointer.fromPyobj(AP)._ptr,batchCount))
    return (_hipblasZsprBatched__retval,)


@cython.embedsignature(True)
def hipblasCsprBatched_v2(object handle, object uplo, int n, object alpha, object x, int incx, object AP, int batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        uplo (`~.hipblasFillMode_t`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        alpha (`~.float2`/`~.object`):
            (undocumented)

        x (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        AP (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")
    _hipblasCsprBatched_v2__retval = hipblasStatus_t(chipblas.hipblasCsprBatched_v2(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,uplo.value,n,
        float2.fromPyobj(alpha).getElementPtr(),
        <chipblas.float2 *const*>hip._util.types.Pointer.fromPyobj(x)._ptr,incx,
        <chipblas.float2 *const*>hip._util.types.Pointer.fromPyobj(AP)._ptr,batchCount))
    return (_hipblasCsprBatched_v2__retval,)


@cython.embedsignature(True)
def hipblasZsprBatched_v2(object handle, object uplo, int n, object alpha, object x, int incx, object AP, int batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        uplo (`~.hipblasFillMode_t`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        alpha (`~.double2`/`~.object`):
            (undocumented)

        x (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        AP (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")
    _hipblasZsprBatched_v2__retval = hipblasStatus_t(chipblas.hipblasZsprBatched_v2(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,uplo.value,n,
        double2.fromPyobj(alpha).getElementPtr(),
        <chipblas.double2 *const*>hip._util.types.Pointer.fromPyobj(x)._ptr,incx,
        <chipblas.double2 *const*>hip._util.types.Pointer.fromPyobj(AP)._ptr,batchCount))
    return (_hipblasZsprBatched_v2__retval,)


@cython.embedsignature(True)
def hipblasSsprBatched_64(object handle, object uplo, long n, object alpha, object x, long incx, object AP, long batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        uplo (`~.hipblasFillMode_t`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        alpha (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        x (`~.hip._util.types.ListOfPointer`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        AP (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")
    _hipblasSsprBatched_64__retval = hipblasStatus_t(chipblas.hipblasSsprBatched_64(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,uplo.value,n,
        <const float *>hip._util.types.Pointer.fromPyobj(alpha)._ptr,
        <const float *const*>hip._util.types.ListOfPointer.fromPyobj(x)._ptr,incx,
        <float *const*>hip._util.types.Pointer.fromPyobj(AP)._ptr,batchCount))
    return (_hipblasSsprBatched_64__retval,)


@cython.embedsignature(True)
def hipblasDsprBatched_64(object handle, object uplo, long n, object alpha, object x, long incx, object AP, long batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        uplo (`~.hipblasFillMode_t`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        alpha (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        x (`~.hip._util.types.ListOfPointer`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        AP (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")
    _hipblasDsprBatched_64__retval = hipblasStatus_t(chipblas.hipblasDsprBatched_64(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,uplo.value,n,
        <const double *>hip._util.types.Pointer.fromPyobj(alpha)._ptr,
        <const double *const*>hip._util.types.ListOfPointer.fromPyobj(x)._ptr,incx,
        <double *const*>hip._util.types.Pointer.fromPyobj(AP)._ptr,batchCount))
    return (_hipblasDsprBatched_64__retval,)


@cython.embedsignature(True)
def hipblasCsprBatched_64(object handle, object uplo, long n, object alpha, object x, long incx, object AP, long batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        uplo (`~.hipblasFillMode_t`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        alpha (`~.hipblasComplex`/`~.object`):
            (undocumented)

        x (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        AP (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")
    _hipblasCsprBatched_64__retval = hipblasStatus_t(chipblas.hipblasCsprBatched_64(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,uplo.value,n,
        hipblasComplex.fromPyobj(alpha).getElementPtr(),
        <chipblas.hipblasComplex *const*>hip._util.types.Pointer.fromPyobj(x)._ptr,incx,
        <chipblas.hipblasComplex *const*>hip._util.types.Pointer.fromPyobj(AP)._ptr,batchCount))
    return (_hipblasCsprBatched_64__retval,)


@cython.embedsignature(True)
def hipblasZsprBatched_64(object handle, object uplo, long n, object alpha, object x, long incx, object AP, long batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        uplo (`~.hipblasFillMode_t`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        alpha (`~.hipblasDoubleComplex`/`~.object`):
            (undocumented)

        x (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        AP (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")
    _hipblasZsprBatched_64__retval = hipblasStatus_t(chipblas.hipblasZsprBatched_64(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,uplo.value,n,
        hipblasDoubleComplex.fromPyobj(alpha).getElementPtr(),
        <chipblas.hipblasDoubleComplex *const*>hip._util.types.Pointer.fromPyobj(x)._ptr,incx,
        <chipblas.hipblasDoubleComplex *const*>hip._util.types.Pointer.fromPyobj(AP)._ptr,batchCount))
    return (_hipblasZsprBatched_64__retval,)


@cython.embedsignature(True)
def hipblasCsprBatched_v2_64(object handle, object uplo, long n, object alpha, object x, long incx, object AP, long batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        uplo (`~.hipblasFillMode_t`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        alpha (`~.float2`/`~.object`):
            (undocumented)

        x (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        AP (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")
    _hipblasCsprBatched_v2_64__retval = hipblasStatus_t(chipblas.hipblasCsprBatched_v2_64(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,uplo.value,n,
        float2.fromPyobj(alpha).getElementPtr(),
        <chipblas.float2 *const*>hip._util.types.Pointer.fromPyobj(x)._ptr,incx,
        <chipblas.float2 *const*>hip._util.types.Pointer.fromPyobj(AP)._ptr,batchCount))
    return (_hipblasCsprBatched_v2_64__retval,)


@cython.embedsignature(True)
def hipblasZsprBatched_v2_64(object handle, object uplo, long n, object alpha, object x, long incx, object AP, long batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        uplo (`~.hipblasFillMode_t`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        alpha (`~.double2`/`~.object`):
            (undocumented)

        x (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        AP (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")
    _hipblasZsprBatched_v2_64__retval = hipblasStatus_t(chipblas.hipblasZsprBatched_v2_64(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,uplo.value,n,
        double2.fromPyobj(alpha).getElementPtr(),
        <chipblas.double2 *const*>hip._util.types.Pointer.fromPyobj(x)._ptr,incx,
        <chipblas.double2 *const*>hip._util.types.Pointer.fromPyobj(AP)._ptr,batchCount))
    return (_hipblasZsprBatched_v2_64__retval,)


@cython.embedsignature(True)
def hipblasSsprStridedBatched(object handle, object uplo, int n, object alpha, object x, int incx, long stridex, object AP, long strideA, int batchCount):
    r"""BLAS Level 2 API

    @{

    sprStridedBatched performs the matrix-vector operations

    A_i := A_i + alpha*x_i*x_i**T

    where alpha is a scalar, x_i is a vector, and A_i is an
    n by n symmetric matrix, supplied in packed form, for i = 1, ..., batchCount.

    - Supported precisions in rocBLAS : s,d,c,z
    - Supported precisions in cuBLAS  : No support

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`) -- *IN*:
            [hipblasHandle_t]
            handle to the hipblas library context queue.

        uplo (`~.hipblasFillMode_t`) -- *IN*:
            [hipblasFillMode_t]
            specifies whether the upper 'HIPBLAS_FILL_MODE_UPPER' or lower 'HIPBLAS_FILL_MODE_LOWER'
            HIPBLAS_FILL_MODE_UPPER: The upper triangular part of each A_i is supplied in AP.
            HIPBLAS_FILL_MODE_LOWER: The lower triangular part of each A_i is supplied in AP.

        n (`~.int`) -- *IN*:
            [int]
            the number of rows and columns of each matrix A_i, must be at least 0.

        alpha (`~.hip._util.types.Pointer`/`~.object`) -- *IN*:
            device pointer or host pointer to scalar alpha.

        x (`~.hip._util.types.Pointer`/`~.object`) -- *IN*:
            device pointer pointing to the first vector (x_1).

        incx (`~.int`) -- *IN*:
            [int]
            specifies the increment for the elements of each x_i.

        stridex (`~.int`) -- *IN*:
            [hipblasStride]
            stride from the start of one vector (x_i) and the next one (x_i+1).

        AP (`~.hip._util.types.Pointer`/`~.object`) -- *INOUT*:
            device pointer storing the packed version of the specified triangular portion of
              each symmetric matrix A_i. Points to the first A_1.
              if uplo == HIPBLAS_FILL_MODE_UPPER:
                The upper triangular portion of each symmetric matrix A_i is supplied.
                The matrix is compacted so that AP contains the triangular portion column-by-column
                so that:
                AP(0) = A(0,0)
                AP(1) = A(0,1)
                AP(2) = A(1,1), etc.
                    Ex: (HIPBLAS_FILL_MODE_UPPER; n = 4)
                        1 2 4 7
                        2 3 5 8   -----> [1, 2, 3, 4, 5, 6, 7, 8, 9, 0]
                        4 5 6 9
                        7 8 9 0
            if uplo == HIPBLAS_FILL_MODE_LOWER:
                The lower triangular portion of each symmetric matrix A_i is supplied.
                The matrix is compacted so that AP contains the triangular portion column-by-column
                so that:
                AP(0) = A(0,0)
                AP(1) = A(1,0)
                AP(2) = A(2,1), etc.
                    Ex: (HIPBLAS_FILL_MODE_LOWER; n = 4)
                        1 2 3 4
                        2 5 6 7    -----> [1, 2, 3, 4, 5, 6, 7, 8, 9, 0]
                        3 6 8 9
                        4 7 9 0

        strideA (`~.int`) -- *IN*:
            [hipblasStride]
            stride from the start of one (A_i) and the next (A_i+1)

        batchCount (`~.int`) -- *IN*:
            [int]
            number of instances in the batch.
    """
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")
    _hipblasSsprStridedBatched__retval = hipblasStatus_t(chipblas.hipblasSsprStridedBatched(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,uplo.value,n,
        <const float *>hip._util.types.Pointer.fromPyobj(alpha)._ptr,
        <const float *>hip._util.types.Pointer.fromPyobj(x)._ptr,incx,stridex,
        <float *>hip._util.types.Pointer.fromPyobj(AP)._ptr,strideA,batchCount))
    return (_hipblasSsprStridedBatched__retval,)


@cython.embedsignature(True)
def hipblasDsprStridedBatched(object handle, object uplo, int n, object alpha, object x, int incx, long stridex, object AP, long strideA, int batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        uplo (`~.hipblasFillMode_t`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        alpha (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        x (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        stridex (`~.int`):
            (undocumented)

        AP (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        strideA (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")
    _hipblasDsprStridedBatched__retval = hipblasStatus_t(chipblas.hipblasDsprStridedBatched(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,uplo.value,n,
        <const double *>hip._util.types.Pointer.fromPyobj(alpha)._ptr,
        <const double *>hip._util.types.Pointer.fromPyobj(x)._ptr,incx,stridex,
        <double *>hip._util.types.Pointer.fromPyobj(AP)._ptr,strideA,batchCount))
    return (_hipblasDsprStridedBatched__retval,)


@cython.embedsignature(True)
def hipblasCsprStridedBatched(object handle, object uplo, int n, object alpha, object x, int incx, long stridex, object AP, long strideA, int batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        uplo (`~.hipblasFillMode_t`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        alpha (`~.hipblasComplex`/`~.object`):
            (undocumented)

        x (`~.hipblasComplex`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        stridex (`~.int`):
            (undocumented)

        AP (`~.hipblasComplex`/`~.object`):
            (undocumented)

        strideA (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")
    _hipblasCsprStridedBatched__retval = hipblasStatus_t(chipblas.hipblasCsprStridedBatched(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,uplo.value,n,
        hipblasComplex.fromPyobj(alpha).getElementPtr(),
        hipblasComplex.fromPyobj(x).getElementPtr(),incx,stridex,
        hipblasComplex.fromPyobj(AP).getElementPtr(),strideA,batchCount))
    return (_hipblasCsprStridedBatched__retval,)


@cython.embedsignature(True)
def hipblasZsprStridedBatched(object handle, object uplo, int n, object alpha, object x, int incx, long stridex, object AP, long strideA, int batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        uplo (`~.hipblasFillMode_t`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        alpha (`~.hipblasDoubleComplex`/`~.object`):
            (undocumented)

        x (`~.hipblasDoubleComplex`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        stridex (`~.int`):
            (undocumented)

        AP (`~.hipblasDoubleComplex`/`~.object`):
            (undocumented)

        strideA (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")
    _hipblasZsprStridedBatched__retval = hipblasStatus_t(chipblas.hipblasZsprStridedBatched(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,uplo.value,n,
        hipblasDoubleComplex.fromPyobj(alpha).getElementPtr(),
        hipblasDoubleComplex.fromPyobj(x).getElementPtr(),incx,stridex,
        hipblasDoubleComplex.fromPyobj(AP).getElementPtr(),strideA,batchCount))
    return (_hipblasZsprStridedBatched__retval,)


@cython.embedsignature(True)
def hipblasCsprStridedBatched_v2(object handle, object uplo, int n, object alpha, object x, int incx, long stridex, object AP, long strideA, int batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        uplo (`~.hipblasFillMode_t`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        alpha (`~.float2`/`~.object`):
            (undocumented)

        x (`~.float2`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        stridex (`~.int`):
            (undocumented)

        AP (`~.float2`/`~.object`):
            (undocumented)

        strideA (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")
    _hipblasCsprStridedBatched_v2__retval = hipblasStatus_t(chipblas.hipblasCsprStridedBatched_v2(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,uplo.value,n,
        float2.fromPyobj(alpha).getElementPtr(),
        float2.fromPyobj(x).getElementPtr(),incx,stridex,
        float2.fromPyobj(AP).getElementPtr(),strideA,batchCount))
    return (_hipblasCsprStridedBatched_v2__retval,)


@cython.embedsignature(True)
def hipblasZsprStridedBatched_v2(object handle, object uplo, int n, object alpha, object x, int incx, long stridex, object AP, long strideA, int batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        uplo (`~.hipblasFillMode_t`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        alpha (`~.double2`/`~.object`):
            (undocumented)

        x (`~.double2`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        stridex (`~.int`):
            (undocumented)

        AP (`~.double2`/`~.object`):
            (undocumented)

        strideA (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")
    _hipblasZsprStridedBatched_v2__retval = hipblasStatus_t(chipblas.hipblasZsprStridedBatched_v2(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,uplo.value,n,
        double2.fromPyobj(alpha).getElementPtr(),
        double2.fromPyobj(x).getElementPtr(),incx,stridex,
        double2.fromPyobj(AP).getElementPtr(),strideA,batchCount))
    return (_hipblasZsprStridedBatched_v2__retval,)


@cython.embedsignature(True)
def hipblasSsprStridedBatched_64(object handle, object uplo, long n, object alpha, object x, long incx, long stridex, object AP, long strideA, long batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        uplo (`~.hipblasFillMode_t`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        alpha (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        x (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        stridex (`~.int`):
            (undocumented)

        AP (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        strideA (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")
    _hipblasSsprStridedBatched_64__retval = hipblasStatus_t(chipblas.hipblasSsprStridedBatched_64(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,uplo.value,n,
        <const float *>hip._util.types.Pointer.fromPyobj(alpha)._ptr,
        <const float *>hip._util.types.Pointer.fromPyobj(x)._ptr,incx,stridex,
        <float *>hip._util.types.Pointer.fromPyobj(AP)._ptr,strideA,batchCount))
    return (_hipblasSsprStridedBatched_64__retval,)


@cython.embedsignature(True)
def hipblasDsprStridedBatched_64(object handle, object uplo, long n, object alpha, object x, long incx, long stridex, object AP, long strideA, long batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        uplo (`~.hipblasFillMode_t`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        alpha (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        x (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        stridex (`~.int`):
            (undocumented)

        AP (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        strideA (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")
    _hipblasDsprStridedBatched_64__retval = hipblasStatus_t(chipblas.hipblasDsprStridedBatched_64(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,uplo.value,n,
        <const double *>hip._util.types.Pointer.fromPyobj(alpha)._ptr,
        <const double *>hip._util.types.Pointer.fromPyobj(x)._ptr,incx,stridex,
        <double *>hip._util.types.Pointer.fromPyobj(AP)._ptr,strideA,batchCount))
    return (_hipblasDsprStridedBatched_64__retval,)


@cython.embedsignature(True)
def hipblasCsprStridedBatched_64(object handle, object uplo, long n, object alpha, object x, long incx, long stridex, object AP, long strideA, long batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        uplo (`~.hipblasFillMode_t`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        alpha (`~.hipblasComplex`/`~.object`):
            (undocumented)

        x (`~.hipblasComplex`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        stridex (`~.int`):
            (undocumented)

        AP (`~.hipblasComplex`/`~.object`):
            (undocumented)

        strideA (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")
    _hipblasCsprStridedBatched_64__retval = hipblasStatus_t(chipblas.hipblasCsprStridedBatched_64(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,uplo.value,n,
        hipblasComplex.fromPyobj(alpha).getElementPtr(),
        hipblasComplex.fromPyobj(x).getElementPtr(),incx,stridex,
        hipblasComplex.fromPyobj(AP).getElementPtr(),strideA,batchCount))
    return (_hipblasCsprStridedBatched_64__retval,)


@cython.embedsignature(True)
def hipblasZsprStridedBatched_64(object handle, object uplo, long n, object alpha, object x, long incx, long stridex, object AP, long strideA, long batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        uplo (`~.hipblasFillMode_t`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        alpha (`~.hipblasDoubleComplex`/`~.object`):
            (undocumented)

        x (`~.hipblasDoubleComplex`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        stridex (`~.int`):
            (undocumented)

        AP (`~.hipblasDoubleComplex`/`~.object`):
            (undocumented)

        strideA (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")
    _hipblasZsprStridedBatched_64__retval = hipblasStatus_t(chipblas.hipblasZsprStridedBatched_64(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,uplo.value,n,
        hipblasDoubleComplex.fromPyobj(alpha).getElementPtr(),
        hipblasDoubleComplex.fromPyobj(x).getElementPtr(),incx,stridex,
        hipblasDoubleComplex.fromPyobj(AP).getElementPtr(),strideA,batchCount))
    return (_hipblasZsprStridedBatched_64__retval,)


@cython.embedsignature(True)
def hipblasCsprStridedBatched_v2_64(object handle, object uplo, long n, object alpha, object x, long incx, long stridex, object AP, long strideA, long batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        uplo (`~.hipblasFillMode_t`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        alpha (`~.float2`/`~.object`):
            (undocumented)

        x (`~.float2`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        stridex (`~.int`):
            (undocumented)

        AP (`~.float2`/`~.object`):
            (undocumented)

        strideA (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")
    _hipblasCsprStridedBatched_v2_64__retval = hipblasStatus_t(chipblas.hipblasCsprStridedBatched_v2_64(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,uplo.value,n,
        float2.fromPyobj(alpha).getElementPtr(),
        float2.fromPyobj(x).getElementPtr(),incx,stridex,
        float2.fromPyobj(AP).getElementPtr(),strideA,batchCount))
    return (_hipblasCsprStridedBatched_v2_64__retval,)


@cython.embedsignature(True)
def hipblasZsprStridedBatched_v2_64(object handle, object uplo, long n, object alpha, object x, long incx, long stridex, object AP, long strideA, long batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        uplo (`~.hipblasFillMode_t`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        alpha (`~.double2`/`~.object`):
            (undocumented)

        x (`~.double2`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        stridex (`~.int`):
            (undocumented)

        AP (`~.double2`/`~.object`):
            (undocumented)

        strideA (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")
    _hipblasZsprStridedBatched_v2_64__retval = hipblasStatus_t(chipblas.hipblasZsprStridedBatched_v2_64(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,uplo.value,n,
        double2.fromPyobj(alpha).getElementPtr(),
        double2.fromPyobj(x).getElementPtr(),incx,stridex,
        double2.fromPyobj(AP).getElementPtr(),strideA,batchCount))
    return (_hipblasZsprStridedBatched_v2_64__retval,)


@cython.embedsignature(True)
def hipblasSspr2(object handle, object uplo, int n, object alpha, object x, int incx, object y, int incy, object AP):
    r"""BLAS Level 2 API

    @{

    spr2 performs the matrix-vector operation

    A := A + alpha*x*y**T + alpha*y*x**T

    where alpha is a scalar, x and y are vectors, and A is an
    n by n symmetric matrix, supplied in packed form.

    - Supported precisions in rocBLAS : s,d
    - Supported precisions in cuBLAS  : s,d

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`) -- *IN*:
            [hipblasHandle_t]
            handle to the hipblas library context queue.

        uplo (`~.hipblasFillMode_t`) -- *IN*:
            [hipblasFillMode_t]
            specifies whether the upper 'HIPBLAS_FILL_MODE_UPPER' or lower 'HIPBLAS_FILL_MODE_LOWER'
            HIPBLAS_FILL_MODE_UPPER: The upper triangular part of A is supplied in AP.
            HIPBLAS_FILL_MODE_LOWER: The lower triangular part of A is supplied in AP.

        n (`~.int`) -- *IN*:
            [int]
            the number of rows and columns of matrix A, must be at least 0.

        alpha (`~.hip._util.types.Pointer`/`~.object`) -- *IN*:
            device pointer or host pointer to scalar alpha.

        x (`~.hip._util.types.Pointer`/`~.object`) -- *IN*:
            device pointer storing vector x.

        incx (`~.int`) -- *IN*:
            [int]
            specifies the increment for the elements of x.

        y (`~.hip._util.types.Pointer`/`~.object`) -- *IN*:
            device pointer storing vector y.

        incy (`~.int`) -- *IN*:
            [int]
            specifies the increment for the elements of y.

        AP (`~.hip._util.types.Pointer`/`~.object`) -- *INOUT*:
            device pointer storing the packed version of the specified triangular portion of
              the symmetric matrix A. Of at least size ((n * (n + 1)) / 2).
              if uplo == HIPBLAS_FILL_MODE_UPPER:
                The upper triangular portion of the symmetric matrix A is supplied.
                The matrix is compacted so that AP contains the triangular portion column-by-column
                so that:
                AP(0) = A(0,0)
                AP(1) = A(0,1)
                AP(2) = A(1,1), etc.
                    Ex: (HIPBLAS_FILL_MODE_UPPER; n = 4)
                        1 2 4 7
                        2 3 5 8   -----> [1, 2, 3, 4, 5, 6, 7, 8, 9, 0]
                        4 5 6 9
                        7 8 9 0
            if uplo == HIPBLAS_FILL_MODE_LOWER:
                The lower triangular portion of the symmetric matrix A is supplied.
                The matrix is compacted so that AP contains the triangular portion column-by-column
                so that:
                AP(0) = A(0,0)
                AP(1) = A(1,0)
                AP(n) = A(2,1), etc.
                    Ex: (HIPBLAS_FILL_MODE_LOWER; n = 4)
                        1 2 3 4
                        2 5 6 7    -----> [1, 2, 3, 4, 5, 6, 7, 8, 9, 0]
                        3 6 8 9
                        4 7 9 0
    """
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")
    _hipblasSspr2__retval = hipblasStatus_t(chipblas.hipblasSspr2(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,uplo.value,n,
        <const float *>hip._util.types.Pointer.fromPyobj(alpha)._ptr,
        <const float *>hip._util.types.Pointer.fromPyobj(x)._ptr,incx,
        <const float *>hip._util.types.Pointer.fromPyobj(y)._ptr,incy,
        <float *>hip._util.types.Pointer.fromPyobj(AP)._ptr))
    return (_hipblasSspr2__retval,)


@cython.embedsignature(True)
def hipblasDspr2(object handle, object uplo, int n, object alpha, object x, int incx, object y, int incy, object AP):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        uplo (`~.hipblasFillMode_t`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        alpha (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        x (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        y (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        incy (`~.int`):
            (undocumented)

        AP (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)
    """
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")
    _hipblasDspr2__retval = hipblasStatus_t(chipblas.hipblasDspr2(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,uplo.value,n,
        <const double *>hip._util.types.Pointer.fromPyobj(alpha)._ptr,
        <const double *>hip._util.types.Pointer.fromPyobj(x)._ptr,incx,
        <const double *>hip._util.types.Pointer.fromPyobj(y)._ptr,incy,
        <double *>hip._util.types.Pointer.fromPyobj(AP)._ptr))
    return (_hipblasDspr2__retval,)


@cython.embedsignature(True)
def hipblasSspr2_64(object handle, object uplo, long n, object alpha, object x, long incx, object y, long incy, object AP):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        uplo (`~.hipblasFillMode_t`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        alpha (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        x (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        y (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        incy (`~.int`):
            (undocumented)

        AP (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)
    """
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")
    _hipblasSspr2_64__retval = hipblasStatus_t(chipblas.hipblasSspr2_64(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,uplo.value,n,
        <const float *>hip._util.types.Pointer.fromPyobj(alpha)._ptr,
        <const float *>hip._util.types.Pointer.fromPyobj(x)._ptr,incx,
        <const float *>hip._util.types.Pointer.fromPyobj(y)._ptr,incy,
        <float *>hip._util.types.Pointer.fromPyobj(AP)._ptr))
    return (_hipblasSspr2_64__retval,)


@cython.embedsignature(True)
def hipblasDspr2_64(object handle, object uplo, long n, object alpha, object x, long incx, object y, long incy, object AP):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        uplo (`~.hipblasFillMode_t`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        alpha (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        x (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        y (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        incy (`~.int`):
            (undocumented)

        AP (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)
    """
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")
    _hipblasDspr2_64__retval = hipblasStatus_t(chipblas.hipblasDspr2_64(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,uplo.value,n,
        <const double *>hip._util.types.Pointer.fromPyobj(alpha)._ptr,
        <const double *>hip._util.types.Pointer.fromPyobj(x)._ptr,incx,
        <const double *>hip._util.types.Pointer.fromPyobj(y)._ptr,incy,
        <double *>hip._util.types.Pointer.fromPyobj(AP)._ptr))
    return (_hipblasDspr2_64__retval,)


@cython.embedsignature(True)
def hipblasSspr2Batched(object handle, object uplo, int n, object alpha, object x, int incx, object y, int incy, object AP, int batchCount):
    r"""BLAS Level 2 API

    @{

    spr2Batched performs the matrix-vector operation

    A_i := A_i + alpha*x_i*y_i**T + alpha*y_i*x_i**T

    where alpha is a scalar, x_i and y_i are vectors, and A_i is an
    n by n symmetric matrix, supplied in packed form, for i = 1, ..., batchCount.

    - Supported precisions in rocBLAS : s,d
    - Supported precisions in cuBLAS  : No support

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`) -- *IN*:
            [hipblasHandle_t]
            handle to the hipblas library context queue.

        uplo (`~.hipblasFillMode_t`) -- *IN*:
            [hipblasFillMode_t]
            specifies whether the upper 'HIPBLAS_FILL_MODE_UPPER' or lower 'HIPBLAS_FILL_MODE_LOWER'
            HIPBLAS_FILL_MODE_UPPER: The upper triangular part of each A_i is supplied in AP.
            HIPBLAS_FILL_MODE_LOWER: The lower triangular part of each A_i is supplied in AP.

        n (`~.int`) -- *IN*:
            [int]
            the number of rows and columns of each matrix A_i, must be at least 0.

        alpha (`~.hip._util.types.Pointer`/`~.object`) -- *IN*:
            device pointer or host pointer to scalar alpha.

        x (`~.hip._util.types.ListOfPointer`/`~.object`) -- *IN*:
            device array of device pointers storing each vector x_i.

        incx (`~.int`) -- *IN*:
            [int]
            specifies the increment for the elements of each x_i.

        y (`~.hip._util.types.ListOfPointer`/`~.object`) -- *IN*:
            device array of device pointers storing each vector y_i.

        incy (`~.int`) -- *IN*:
            [int]
            specifies the increment for the elements of each y_i.

        AP (`~.hip._util.types.Pointer`/`~.object`) -- *INOUT*:
            device array of device pointers storing the packed version of the specified triangular portion of
              each symmetric matrix A_i of at least size ((n * (n + 1)) / 2). Array is of at least size batchCount.
              if uplo == HIPBLAS_FILL_MODE_UPPER:
                The upper triangular portion of each symmetric matrix A_i is supplied.
                The matrix is compacted so that AP contains the triangular portion column-by-column
                so that:
                AP(0) = A(0,0)
                AP(1) = A(0,1)
                AP(2) = A(1,1), etc.
                    Ex: (HIPBLAS_FILL_MODE_UPPER; n = 4)
                        1 2 4 7
                        2 3 5 8   -----> [1, 2, 3, 4, 5, 6, 7, 8, 9, 0]
                        4 5 6 9
                        7 8 9 0
            if uplo == HIPBLAS_FILL_MODE_LOWER:
                The lower triangular portion of each symmetric matrix A_i is supplied.
                The matrix is compacted so that AP contains the triangular portion column-by-column
                so that:
                AP(0) = A(0,0)
                AP(1) = A(1,0)
                AP(n) = A(2,1), etc.
                    Ex: (HIPBLAS_FILL_MODE_LOWER; n = 4)
                        1 2 3 4
                        2 5 6 7    -----> [1, 2, 3, 4, 5, 6, 7, 8, 9, 0]
                        3 6 8 9
                        4 7 9 0

        batchCount (`~.int`) -- *IN*:
            [int]
            number of instances in the batch.
    """
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")
    _hipblasSspr2Batched__retval = hipblasStatus_t(chipblas.hipblasSspr2Batched(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,uplo.value,n,
        <const float *>hip._util.types.Pointer.fromPyobj(alpha)._ptr,
        <const float *const*>hip._util.types.ListOfPointer.fromPyobj(x)._ptr,incx,
        <const float *const*>hip._util.types.ListOfPointer.fromPyobj(y)._ptr,incy,
        <float *const*>hip._util.types.Pointer.fromPyobj(AP)._ptr,batchCount))
    return (_hipblasSspr2Batched__retval,)


@cython.embedsignature(True)
def hipblasDspr2Batched(object handle, object uplo, int n, object alpha, object x, int incx, object y, int incy, object AP, int batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        uplo (`~.hipblasFillMode_t`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        alpha (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        x (`~.hip._util.types.ListOfPointer`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        y (`~.hip._util.types.ListOfPointer`/`~.object`):
            (undocumented)

        incy (`~.int`):
            (undocumented)

        AP (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")
    _hipblasDspr2Batched__retval = hipblasStatus_t(chipblas.hipblasDspr2Batched(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,uplo.value,n,
        <const double *>hip._util.types.Pointer.fromPyobj(alpha)._ptr,
        <const double *const*>hip._util.types.ListOfPointer.fromPyobj(x)._ptr,incx,
        <const double *const*>hip._util.types.ListOfPointer.fromPyobj(y)._ptr,incy,
        <double *const*>hip._util.types.Pointer.fromPyobj(AP)._ptr,batchCount))
    return (_hipblasDspr2Batched__retval,)


@cython.embedsignature(True)
def hipblasSspr2Batched_64(object handle, object uplo, long n, object alpha, object x, long incx, object y, long incy, object AP, long batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        uplo (`~.hipblasFillMode_t`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        alpha (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        x (`~.hip._util.types.ListOfPointer`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        y (`~.hip._util.types.ListOfPointer`/`~.object`):
            (undocumented)

        incy (`~.int`):
            (undocumented)

        AP (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")
    _hipblasSspr2Batched_64__retval = hipblasStatus_t(chipblas.hipblasSspr2Batched_64(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,uplo.value,n,
        <const float *>hip._util.types.Pointer.fromPyobj(alpha)._ptr,
        <const float *const*>hip._util.types.ListOfPointer.fromPyobj(x)._ptr,incx,
        <const float *const*>hip._util.types.ListOfPointer.fromPyobj(y)._ptr,incy,
        <float *const*>hip._util.types.Pointer.fromPyobj(AP)._ptr,batchCount))
    return (_hipblasSspr2Batched_64__retval,)


@cython.embedsignature(True)
def hipblasDspr2Batched_64(object handle, object uplo, long n, object alpha, object x, long incx, object y, long incy, object AP, long batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        uplo (`~.hipblasFillMode_t`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        alpha (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        x (`~.hip._util.types.ListOfPointer`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        y (`~.hip._util.types.ListOfPointer`/`~.object`):
            (undocumented)

        incy (`~.int`):
            (undocumented)

        AP (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")
    _hipblasDspr2Batched_64__retval = hipblasStatus_t(chipblas.hipblasDspr2Batched_64(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,uplo.value,n,
        <const double *>hip._util.types.Pointer.fromPyobj(alpha)._ptr,
        <const double *const*>hip._util.types.ListOfPointer.fromPyobj(x)._ptr,incx,
        <const double *const*>hip._util.types.ListOfPointer.fromPyobj(y)._ptr,incy,
        <double *const*>hip._util.types.Pointer.fromPyobj(AP)._ptr,batchCount))
    return (_hipblasDspr2Batched_64__retval,)


@cython.embedsignature(True)
def hipblasSspr2StridedBatched(object handle, object uplo, int n, object alpha, object x, int incx, long stridex, object y, int incy, long stridey, object AP, long strideA, int batchCount):
    r"""BLAS Level 2 API

    @{

    spr2StridedBatched performs the matrix-vector operation

    A_i := A_i + alpha*x_i*y_i**T + alpha*y_i*x_i**T

    where alpha is a scalar, x_i amd y_i are vectors, and A_i is an
    n by n symmetric matrix, supplied in packed form, for i = 1, ..., batchCount.

    - Supported precisions in rocBLAS : s,d
    - Supported precisions in cuBLAS  : No support

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`) -- *IN*:
            [hipblasHandle_t]
            handle to the hipblas library context queue.

        uplo (`~.hipblasFillMode_t`) -- *IN*:
            [hipblasFillMode_t]
            specifies whether the upper 'HIPBLAS_FILL_MODE_UPPER' or lower 'HIPBLAS_FILL_MODE_LOWER'
            HIPBLAS_FILL_MODE_UPPER: The upper triangular part of each A_i is supplied in AP.
            HIPBLAS_FILL_MODE_LOWER: The lower triangular part of each A_i is supplied in AP.

        n (`~.int`) -- *IN*:
            [int]
            the number of rows and columns of each matrix A_i, must be at least 0.

        alpha (`~.hip._util.types.Pointer`/`~.object`) -- *IN*:
            device pointer or host pointer to scalar alpha.

        x (`~.hip._util.types.Pointer`/`~.object`) -- *IN*:
            device pointer pointing to the first vector (x_1).

        incx (`~.int`) -- *IN*:
            [int]
            specifies the increment for the elements of each x_i.

        stridex (`~.int`) -- *IN*:
            [hipblasStride]
            stride from the start of one vector (x_i) and the next one (x_i+1).

        y (`~.hip._util.types.Pointer`/`~.object`) -- *IN*:
            device pointer pointing to the first vector (y_1).

        incy (`~.int`) -- *IN*:
            [int]
            specifies the increment for the elements of each y_i.

        stridey (`~.int`) -- *IN*:
            [hipblasStride]
            stride from the start of one vector (y_i) and the next one (y_i+1).

        AP (`~.hip._util.types.Pointer`/`~.object`) -- *INOUT*:
            device pointer storing the packed version of the specified triangular portion of
              each symmetric matrix A_i. Points to the first A_1.
              if uplo == HIPBLAS_FILL_MODE_UPPER:
                The upper triangular portion of each symmetric matrix A_i is supplied.
                The matrix is compacted so that AP contains the triangular portion column-by-column
                so that:
                AP(0) = A(0,0)
                AP(1) = A(0,1)
                AP(2) = A(1,1), etc.
                    Ex: (HIPBLAS_FILL_MODE_UPPER; n = 4)
                        1 2 4 7
                        2 3 5 8   -----> [1, 2, 3, 4, 5, 6, 7, 8, 9, 0]
                        4 5 6 9
                        7 8 9 0
            if uplo == HIPBLAS_FILL_MODE_LOWER:
                The lower triangular portion of each symmetric matrix A_i is supplied.
                The matrix is compacted so that AP contains the triangular portion column-by-column
                so that:
                AP(0) = A(0,0)
                AP(1) = A(1,0)
                AP(n) = A(2,1), etc.
                    Ex: (HIPBLAS_FILL_MODE_LOWER; n = 4)
                        1 2 3 4
                        2 5 6 7    -----> [1, 2, 3, 4, 5, 6, 7, 8, 9, 0]
                        3 6 8 9
                        4 7 9 0

        strideA (`~.int`) -- *IN*:
            [hipblasStride]
            stride from the start of one (A_i) and the next (A_i+1)

        batchCount (`~.int`) -- *IN*:
            [int]
            number of instances in the batch.
    """
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")
    _hipblasSspr2StridedBatched__retval = hipblasStatus_t(chipblas.hipblasSspr2StridedBatched(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,uplo.value,n,
        <const float *>hip._util.types.Pointer.fromPyobj(alpha)._ptr,
        <const float *>hip._util.types.Pointer.fromPyobj(x)._ptr,incx,stridex,
        <const float *>hip._util.types.Pointer.fromPyobj(y)._ptr,incy,stridey,
        <float *>hip._util.types.Pointer.fromPyobj(AP)._ptr,strideA,batchCount))
    return (_hipblasSspr2StridedBatched__retval,)


@cython.embedsignature(True)
def hipblasDspr2StridedBatched(object handle, object uplo, int n, object alpha, object x, int incx, long stridex, object y, int incy, long stridey, object AP, long strideA, int batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        uplo (`~.hipblasFillMode_t`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        alpha (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        x (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        stridex (`~.int`):
            (undocumented)

        y (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        incy (`~.int`):
            (undocumented)

        stridey (`~.int`):
            (undocumented)

        AP (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        strideA (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")
    _hipblasDspr2StridedBatched__retval = hipblasStatus_t(chipblas.hipblasDspr2StridedBatched(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,uplo.value,n,
        <const double *>hip._util.types.Pointer.fromPyobj(alpha)._ptr,
        <const double *>hip._util.types.Pointer.fromPyobj(x)._ptr,incx,stridex,
        <const double *>hip._util.types.Pointer.fromPyobj(y)._ptr,incy,stridey,
        <double *>hip._util.types.Pointer.fromPyobj(AP)._ptr,strideA,batchCount))
    return (_hipblasDspr2StridedBatched__retval,)


@cython.embedsignature(True)
def hipblasSspr2StridedBatched_64(object handle, object uplo, long n, object alpha, object x, long incx, long stridex, object y, long incy, long stridey, object AP, long strideA, long batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        uplo (`~.hipblasFillMode_t`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        alpha (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        x (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        stridex (`~.int`):
            (undocumented)

        y (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        incy (`~.int`):
            (undocumented)

        stridey (`~.int`):
            (undocumented)

        AP (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        strideA (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")
    _hipblasSspr2StridedBatched_64__retval = hipblasStatus_t(chipblas.hipblasSspr2StridedBatched_64(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,uplo.value,n,
        <const float *>hip._util.types.Pointer.fromPyobj(alpha)._ptr,
        <const float *>hip._util.types.Pointer.fromPyobj(x)._ptr,incx,stridex,
        <const float *>hip._util.types.Pointer.fromPyobj(y)._ptr,incy,stridey,
        <float *>hip._util.types.Pointer.fromPyobj(AP)._ptr,strideA,batchCount))
    return (_hipblasSspr2StridedBatched_64__retval,)


@cython.embedsignature(True)
def hipblasDspr2StridedBatched_64(object handle, object uplo, long n, object alpha, object x, long incx, long stridex, object y, long incy, long stridey, object AP, long strideA, long batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        uplo (`~.hipblasFillMode_t`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        alpha (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        x (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        stridex (`~.int`):
            (undocumented)

        y (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        incy (`~.int`):
            (undocumented)

        stridey (`~.int`):
            (undocumented)

        AP (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        strideA (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")
    _hipblasDspr2StridedBatched_64__retval = hipblasStatus_t(chipblas.hipblasDspr2StridedBatched_64(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,uplo.value,n,
        <const double *>hip._util.types.Pointer.fromPyobj(alpha)._ptr,
        <const double *>hip._util.types.Pointer.fromPyobj(x)._ptr,incx,stridex,
        <const double *>hip._util.types.Pointer.fromPyobj(y)._ptr,incy,stridey,
        <double *>hip._util.types.Pointer.fromPyobj(AP)._ptr,strideA,batchCount))
    return (_hipblasDspr2StridedBatched_64__retval,)


@cython.embedsignature(True)
def hipblasSsymv(object handle, object uplo, int n, object alpha, object AP, int lda, object x, int incx, object beta, object y, int incy):
    r"""BLAS Level 2 API

    @{

    symv performs the matrix-vector operation:

    y := alpha*A*x + beta*y,

    where alpha and beta are scalars, x and y are n element vectors and
    A should contain an upper or lower triangular n by n symmetric matrix.

    - Supported precisions in rocBLAS : s,d,c,z
    - Supported precisions in cuBLAS  : s,d,c,z

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`) -- *IN*:
            [hipblasHandle_t]
            handle to the hipblas library context queue.

        uplo (`~.hipblasFillMode_t`) -- *IN*:
            [hipblasFillMode_t]
            specifies whether the upper 'HIPBLAS_FILL_MODE_UPPER' or lower 'HIPBLAS_FILL_MODE_LOWER'
            if HIPBLAS_FILL_MODE_UPPER, the lower part of A is not referenced
            if HIPBLAS_FILL_MODE_LOWER, the upper part of A is not referenced

        n (`~.int`) -- *IN*:
            [int]

        alpha (`~.hip._util.types.Pointer`/`~.object`) -- *IN*:
            specifies the scalar alpha

        AP (`~.hip._util.types.Pointer`/`~.object`) -- *IN*:
            pointer storing matrix A on the GPU

        lda (`~.int`) -- *IN*:
            [int]
            specifies the leading dimension of A

        x (`~.hip._util.types.Pointer`/`~.object`) -- *IN*:
            pointer storing vector x on the GPU

        incx (`~.int`) -- *IN*:
            [int]
            specifies the increment for the elements of x

        beta (`~.hip._util.types.Pointer`/`~.object`) -- *IN*:
            specifies the scalar beta

        y (`~.hip._util.types.Pointer`/`~.object`) -- *OUT*:
            pointer storing vector y on the GPU

        incy (`~.int`) -- *IN*:
            [int]
            specifies the increment for the elements of y
    """
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")
    _hipblasSsymv__retval = hipblasStatus_t(chipblas.hipblasSsymv(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,uplo.value,n,
        <const float *>hip._util.types.Pointer.fromPyobj(alpha)._ptr,
        <const float *>hip._util.types.Pointer.fromPyobj(AP)._ptr,lda,
        <const float *>hip._util.types.Pointer.fromPyobj(x)._ptr,incx,
        <const float *>hip._util.types.Pointer.fromPyobj(beta)._ptr,
        <float *>hip._util.types.Pointer.fromPyobj(y)._ptr,incy))
    return (_hipblasSsymv__retval,)


@cython.embedsignature(True)
def hipblasDsymv(object handle, object uplo, int n, object alpha, object AP, int lda, object x, int incx, object beta, object y, int incy):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        uplo (`~.hipblasFillMode_t`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        alpha (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        AP (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        x (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        beta (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        y (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        incy (`~.int`):
            (undocumented)
    """
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")
    _hipblasDsymv__retval = hipblasStatus_t(chipblas.hipblasDsymv(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,uplo.value,n,
        <const double *>hip._util.types.Pointer.fromPyobj(alpha)._ptr,
        <const double *>hip._util.types.Pointer.fromPyobj(AP)._ptr,lda,
        <const double *>hip._util.types.Pointer.fromPyobj(x)._ptr,incx,
        <const double *>hip._util.types.Pointer.fromPyobj(beta)._ptr,
        <double *>hip._util.types.Pointer.fromPyobj(y)._ptr,incy))
    return (_hipblasDsymv__retval,)


@cython.embedsignature(True)
def hipblasCsymv(object handle, object uplo, int n, object alpha, object AP, int lda, object x, int incx, object beta, object y, int incy):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        uplo (`~.hipblasFillMode_t`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        alpha (`~.hipblasComplex`/`~.object`):
            (undocumented)

        AP (`~.hipblasComplex`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        x (`~.hipblasComplex`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        beta (`~.hipblasComplex`/`~.object`):
            (undocumented)

        y (`~.hipblasComplex`/`~.object`):
            (undocumented)

        incy (`~.int`):
            (undocumented)
    """
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")
    _hipblasCsymv__retval = hipblasStatus_t(chipblas.hipblasCsymv(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,uplo.value,n,
        hipblasComplex.fromPyobj(alpha).getElementPtr(),
        hipblasComplex.fromPyobj(AP).getElementPtr(),lda,
        hipblasComplex.fromPyobj(x).getElementPtr(),incx,
        hipblasComplex.fromPyobj(beta).getElementPtr(),
        hipblasComplex.fromPyobj(y).getElementPtr(),incy))
    return (_hipblasCsymv__retval,)


@cython.embedsignature(True)
def hipblasZsymv(object handle, object uplo, int n, object alpha, object AP, int lda, object x, int incx, object beta, object y, int incy):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        uplo (`~.hipblasFillMode_t`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        alpha (`~.hipblasDoubleComplex`/`~.object`):
            (undocumented)

        AP (`~.hipblasDoubleComplex`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        x (`~.hipblasDoubleComplex`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        beta (`~.hipblasDoubleComplex`/`~.object`):
            (undocumented)

        y (`~.hipblasDoubleComplex`/`~.object`):
            (undocumented)

        incy (`~.int`):
            (undocumented)
    """
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")
    _hipblasZsymv__retval = hipblasStatus_t(chipblas.hipblasZsymv(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,uplo.value,n,
        hipblasDoubleComplex.fromPyobj(alpha).getElementPtr(),
        hipblasDoubleComplex.fromPyobj(AP).getElementPtr(),lda,
        hipblasDoubleComplex.fromPyobj(x).getElementPtr(),incx,
        hipblasDoubleComplex.fromPyobj(beta).getElementPtr(),
        hipblasDoubleComplex.fromPyobj(y).getElementPtr(),incy))
    return (_hipblasZsymv__retval,)


@cython.embedsignature(True)
def hipblasCsymv_v2(object handle, object uplo, int n, object alpha, object AP, int lda, object x, int incx, object beta, object y, int incy):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        uplo (`~.hipblasFillMode_t`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        alpha (`~.float2`/`~.object`):
            (undocumented)

        AP (`~.float2`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        x (`~.float2`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        beta (`~.float2`/`~.object`):
            (undocumented)

        y (`~.float2`/`~.object`):
            (undocumented)

        incy (`~.int`):
            (undocumented)
    """
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")
    _hipblasCsymv_v2__retval = hipblasStatus_t(chipblas.hipblasCsymv_v2(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,uplo.value,n,
        float2.fromPyobj(alpha).getElementPtr(),
        float2.fromPyobj(AP).getElementPtr(),lda,
        float2.fromPyobj(x).getElementPtr(),incx,
        float2.fromPyobj(beta).getElementPtr(),
        float2.fromPyobj(y).getElementPtr(),incy))
    return (_hipblasCsymv_v2__retval,)


@cython.embedsignature(True)
def hipblasZsymv_v2(object handle, object uplo, int n, object alpha, object AP, int lda, object x, int incx, object beta, object y, int incy):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        uplo (`~.hipblasFillMode_t`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        alpha (`~.double2`/`~.object`):
            (undocumented)

        AP (`~.double2`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        x (`~.double2`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        beta (`~.double2`/`~.object`):
            (undocumented)

        y (`~.double2`/`~.object`):
            (undocumented)

        incy (`~.int`):
            (undocumented)
    """
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")
    _hipblasZsymv_v2__retval = hipblasStatus_t(chipblas.hipblasZsymv_v2(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,uplo.value,n,
        double2.fromPyobj(alpha).getElementPtr(),
        double2.fromPyobj(AP).getElementPtr(),lda,
        double2.fromPyobj(x).getElementPtr(),incx,
        double2.fromPyobj(beta).getElementPtr(),
        double2.fromPyobj(y).getElementPtr(),incy))
    return (_hipblasZsymv_v2__retval,)


@cython.embedsignature(True)
def hipblasSsymv_64(object handle, object uplo, long n, object alpha, object AP, long lda, object x, long incx, object beta, object y, long incy):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        uplo (`~.hipblasFillMode_t`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        alpha (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        AP (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        x (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        beta (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        y (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        incy (`~.int`):
            (undocumented)
    """
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")
    _hipblasSsymv_64__retval = hipblasStatus_t(chipblas.hipblasSsymv_64(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,uplo.value,n,
        <const float *>hip._util.types.Pointer.fromPyobj(alpha)._ptr,
        <const float *>hip._util.types.Pointer.fromPyobj(AP)._ptr,lda,
        <const float *>hip._util.types.Pointer.fromPyobj(x)._ptr,incx,
        <const float *>hip._util.types.Pointer.fromPyobj(beta)._ptr,
        <float *>hip._util.types.Pointer.fromPyobj(y)._ptr,incy))
    return (_hipblasSsymv_64__retval,)


@cython.embedsignature(True)
def hipblasDsymv_64(object handle, object uplo, long n, object alpha, object AP, long lda, object x, long incx, object beta, object y, long incy):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        uplo (`~.hipblasFillMode_t`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        alpha (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        AP (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        x (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        beta (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        y (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        incy (`~.int`):
            (undocumented)
    """
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")
    _hipblasDsymv_64__retval = hipblasStatus_t(chipblas.hipblasDsymv_64(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,uplo.value,n,
        <const double *>hip._util.types.Pointer.fromPyobj(alpha)._ptr,
        <const double *>hip._util.types.Pointer.fromPyobj(AP)._ptr,lda,
        <const double *>hip._util.types.Pointer.fromPyobj(x)._ptr,incx,
        <const double *>hip._util.types.Pointer.fromPyobj(beta)._ptr,
        <double *>hip._util.types.Pointer.fromPyobj(y)._ptr,incy))
    return (_hipblasDsymv_64__retval,)


@cython.embedsignature(True)
def hipblasCsymv_64(object handle, object uplo, long n, object alpha, object AP, long lda, object x, long incx, object beta, object y, long incy):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        uplo (`~.hipblasFillMode_t`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        alpha (`~.hipblasComplex`/`~.object`):
            (undocumented)

        AP (`~.hipblasComplex`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        x (`~.hipblasComplex`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        beta (`~.hipblasComplex`/`~.object`):
            (undocumented)

        y (`~.hipblasComplex`/`~.object`):
            (undocumented)

        incy (`~.int`):
            (undocumented)
    """
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")
    _hipblasCsymv_64__retval = hipblasStatus_t(chipblas.hipblasCsymv_64(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,uplo.value,n,
        hipblasComplex.fromPyobj(alpha).getElementPtr(),
        hipblasComplex.fromPyobj(AP).getElementPtr(),lda,
        hipblasComplex.fromPyobj(x).getElementPtr(),incx,
        hipblasComplex.fromPyobj(beta).getElementPtr(),
        hipblasComplex.fromPyobj(y).getElementPtr(),incy))
    return (_hipblasCsymv_64__retval,)


@cython.embedsignature(True)
def hipblasZsymv_64(object handle, object uplo, long n, object alpha, object AP, long lda, object x, long incx, object beta, object y, long incy):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        uplo (`~.hipblasFillMode_t`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        alpha (`~.hipblasDoubleComplex`/`~.object`):
            (undocumented)

        AP (`~.hipblasDoubleComplex`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        x (`~.hipblasDoubleComplex`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        beta (`~.hipblasDoubleComplex`/`~.object`):
            (undocumented)

        y (`~.hipblasDoubleComplex`/`~.object`):
            (undocumented)

        incy (`~.int`):
            (undocumented)
    """
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")
    _hipblasZsymv_64__retval = hipblasStatus_t(chipblas.hipblasZsymv_64(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,uplo.value,n,
        hipblasDoubleComplex.fromPyobj(alpha).getElementPtr(),
        hipblasDoubleComplex.fromPyobj(AP).getElementPtr(),lda,
        hipblasDoubleComplex.fromPyobj(x).getElementPtr(),incx,
        hipblasDoubleComplex.fromPyobj(beta).getElementPtr(),
        hipblasDoubleComplex.fromPyobj(y).getElementPtr(),incy))
    return (_hipblasZsymv_64__retval,)


@cython.embedsignature(True)
def hipblasCsymv_v2_64(object handle, object uplo, long n, object alpha, object AP, long lda, object x, long incx, object beta, object y, long incy):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        uplo (`~.hipblasFillMode_t`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        alpha (`~.float2`/`~.object`):
            (undocumented)

        AP (`~.float2`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        x (`~.float2`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        beta (`~.float2`/`~.object`):
            (undocumented)

        y (`~.float2`/`~.object`):
            (undocumented)

        incy (`~.int`):
            (undocumented)
    """
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")
    _hipblasCsymv_v2_64__retval = hipblasStatus_t(chipblas.hipblasCsymv_v2_64(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,uplo.value,n,
        float2.fromPyobj(alpha).getElementPtr(),
        float2.fromPyobj(AP).getElementPtr(),lda,
        float2.fromPyobj(x).getElementPtr(),incx,
        float2.fromPyobj(beta).getElementPtr(),
        float2.fromPyobj(y).getElementPtr(),incy))
    return (_hipblasCsymv_v2_64__retval,)


@cython.embedsignature(True)
def hipblasZsymv_v2_64(object handle, object uplo, long n, object alpha, object AP, long lda, object x, long incx, object beta, object y, long incy):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        uplo (`~.hipblasFillMode_t`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        alpha (`~.double2`/`~.object`):
            (undocumented)

        AP (`~.double2`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        x (`~.double2`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        beta (`~.double2`/`~.object`):
            (undocumented)

        y (`~.double2`/`~.object`):
            (undocumented)

        incy (`~.int`):
            (undocumented)
    """
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")
    _hipblasZsymv_v2_64__retval = hipblasStatus_t(chipblas.hipblasZsymv_v2_64(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,uplo.value,n,
        double2.fromPyobj(alpha).getElementPtr(),
        double2.fromPyobj(AP).getElementPtr(),lda,
        double2.fromPyobj(x).getElementPtr(),incx,
        double2.fromPyobj(beta).getElementPtr(),
        double2.fromPyobj(y).getElementPtr(),incy))
    return (_hipblasZsymv_v2_64__retval,)


@cython.embedsignature(True)
def hipblasSsymvBatched(object handle, object uplo, int n, object alpha, object AP, int lda, object x, int incx, object beta, object y, int incy, int batchCount):
    r"""BLAS Level 2 API

    @{

    symvBatched performs the matrix-vector operation:

    y_i := alpha*A_i*x_i + beta*y_i,

    where (A_i, x_i, y_i) is the i-th instance of the batch.
    alpha and beta are scalars, x_i and y_i are vectors and A_i is an
    n by n symmetric matrix, for i = 1, ..., batchCount.
    A a should contain an upper or lower triangular symmetric matrix
    and the opposing triangular part of A is not referenced

    - Supported precisions in rocBLAS : s,d,c,z
    - Supported precisions in cuBLAS  : No support

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`) -- *IN*:
            [hipblasHandle_t]
            handle to the hipblas library context queue

        uplo (`~.hipblasFillMode_t`) -- *IN*:
            [hipblasFillMode_t]
            specifies whether the upper 'HIPBLAS_FILL_MODE_UPPER' or lower 'HIPBLAS_FILL_MODE_LOWER'
            if HIPBLAS_FILL_MODE_UPPER, the lower part of A is not referenced
            if HIPBLAS_FILL_MODE_LOWER, the upper part of A is not referenced

        n (`~.int`) -- *IN*:
            [int]
            number of rows and columns of each matrix A_i

        alpha (`~.hip._util.types.Pointer`/`~.object`) -- *IN*:
            device pointer or host pointer to scalar alpha

        AP (`~.hip._util.types.Pointer`/`~.object`) -- *IN*:
            device array of device pointers storing each matrix A_i

        lda (`~.int`) -- *IN*:
            [int]
            specifies the leading dimension of each matrix A_i

        x (`~.hip._util.types.ListOfPointer`/`~.object`) -- *IN*:
            device array of device pointers storing each vector x_i

        incx (`~.int`) -- *IN*:
            [int]
            specifies the increment for the elements of each vector x_i

        beta (`~.hip._util.types.Pointer`/`~.object`) -- *IN*:
            device pointer or host pointer to scalar beta

        y (`~.hip._util.types.ListOfPointer`/`~.object`) -- *OUT*:
            device array of device pointers storing each vector y_i

        incy (`~.int`) -- *IN*:
            [int]
            specifies the increment for the elements of each vector y_i

        batchCount (`~.int`) -- *IN*:
            [int]
            number of instances in the batch
    """
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")
    _hipblasSsymvBatched__retval = hipblasStatus_t(chipblas.hipblasSsymvBatched(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,uplo.value,n,
        <const float *>hip._util.types.Pointer.fromPyobj(alpha)._ptr,
        <const float *const*>hip._util.types.Pointer.fromPyobj(AP)._ptr,lda,
        <const float *const*>hip._util.types.ListOfPointer.fromPyobj(x)._ptr,incx,
        <const float *>hip._util.types.Pointer.fromPyobj(beta)._ptr,
        <float *const*>hip._util.types.ListOfPointer.fromPyobj(y)._ptr,incy,batchCount))
    return (_hipblasSsymvBatched__retval,)


@cython.embedsignature(True)
def hipblasDsymvBatched(object handle, object uplo, int n, object alpha, object AP, int lda, object x, int incx, object beta, object y, int incy, int batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        uplo (`~.hipblasFillMode_t`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        alpha (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        AP (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        x (`~.hip._util.types.ListOfPointer`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        beta (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        y (`~.hip._util.types.ListOfPointer`/`~.object`):
            (undocumented)

        incy (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")
    _hipblasDsymvBatched__retval = hipblasStatus_t(chipblas.hipblasDsymvBatched(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,uplo.value,n,
        <const double *>hip._util.types.Pointer.fromPyobj(alpha)._ptr,
        <const double *const*>hip._util.types.Pointer.fromPyobj(AP)._ptr,lda,
        <const double *const*>hip._util.types.ListOfPointer.fromPyobj(x)._ptr,incx,
        <const double *>hip._util.types.Pointer.fromPyobj(beta)._ptr,
        <double *const*>hip._util.types.ListOfPointer.fromPyobj(y)._ptr,incy,batchCount))
    return (_hipblasDsymvBatched__retval,)


@cython.embedsignature(True)
def hipblasCsymvBatched(object handle, object uplo, int n, object alpha, object AP, int lda, object x, int incx, object beta, object y, int incy, int batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        uplo (`~.hipblasFillMode_t`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        alpha (`~.hipblasComplex`/`~.object`):
            (undocumented)

        AP (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        x (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        beta (`~.hipblasComplex`/`~.object`):
            (undocumented)

        y (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        incy (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")
    _hipblasCsymvBatched__retval = hipblasStatus_t(chipblas.hipblasCsymvBatched(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,uplo.value,n,
        hipblasComplex.fromPyobj(alpha).getElementPtr(),
        <chipblas.hipblasComplex *const*>hip._util.types.Pointer.fromPyobj(AP)._ptr,lda,
        <chipblas.hipblasComplex *const*>hip._util.types.Pointer.fromPyobj(x)._ptr,incx,
        hipblasComplex.fromPyobj(beta).getElementPtr(),
        <chipblas.hipblasComplex *const*>hip._util.types.Pointer.fromPyobj(y)._ptr,incy,batchCount))
    return (_hipblasCsymvBatched__retval,)


@cython.embedsignature(True)
def hipblasZsymvBatched(object handle, object uplo, int n, object alpha, object AP, int lda, object x, int incx, object beta, object y, int incy, int batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        uplo (`~.hipblasFillMode_t`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        alpha (`~.hipblasDoubleComplex`/`~.object`):
            (undocumented)

        AP (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        x (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        beta (`~.hipblasDoubleComplex`/`~.object`):
            (undocumented)

        y (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        incy (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")
    _hipblasZsymvBatched__retval = hipblasStatus_t(chipblas.hipblasZsymvBatched(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,uplo.value,n,
        hipblasDoubleComplex.fromPyobj(alpha).getElementPtr(),
        <chipblas.hipblasDoubleComplex *const*>hip._util.types.Pointer.fromPyobj(AP)._ptr,lda,
        <chipblas.hipblasDoubleComplex *const*>hip._util.types.Pointer.fromPyobj(x)._ptr,incx,
        hipblasDoubleComplex.fromPyobj(beta).getElementPtr(),
        <chipblas.hipblasDoubleComplex *const*>hip._util.types.Pointer.fromPyobj(y)._ptr,incy,batchCount))
    return (_hipblasZsymvBatched__retval,)


@cython.embedsignature(True)
def hipblasCsymvBatched_v2(object handle, object uplo, int n, object alpha, object AP, int lda, object x, int incx, object beta, object y, int incy, int batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        uplo (`~.hipblasFillMode_t`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        alpha (`~.float2`/`~.object`):
            (undocumented)

        AP (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        x (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        beta (`~.float2`/`~.object`):
            (undocumented)

        y (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        incy (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")
    _hipblasCsymvBatched_v2__retval = hipblasStatus_t(chipblas.hipblasCsymvBatched_v2(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,uplo.value,n,
        float2.fromPyobj(alpha).getElementPtr(),
        <chipblas.float2 *const*>hip._util.types.Pointer.fromPyobj(AP)._ptr,lda,
        <chipblas.float2 *const*>hip._util.types.Pointer.fromPyobj(x)._ptr,incx,
        float2.fromPyobj(beta).getElementPtr(),
        <chipblas.float2 *const*>hip._util.types.Pointer.fromPyobj(y)._ptr,incy,batchCount))
    return (_hipblasCsymvBatched_v2__retval,)


@cython.embedsignature(True)
def hipblasZsymvBatched_v2(object handle, object uplo, int n, object alpha, object AP, int lda, object x, int incx, object beta, object y, int incy, int batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        uplo (`~.hipblasFillMode_t`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        alpha (`~.double2`/`~.object`):
            (undocumented)

        AP (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        x (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        beta (`~.double2`/`~.object`):
            (undocumented)

        y (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        incy (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")
    _hipblasZsymvBatched_v2__retval = hipblasStatus_t(chipblas.hipblasZsymvBatched_v2(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,uplo.value,n,
        double2.fromPyobj(alpha).getElementPtr(),
        <chipblas.double2 *const*>hip._util.types.Pointer.fromPyobj(AP)._ptr,lda,
        <chipblas.double2 *const*>hip._util.types.Pointer.fromPyobj(x)._ptr,incx,
        double2.fromPyobj(beta).getElementPtr(),
        <chipblas.double2 *const*>hip._util.types.Pointer.fromPyobj(y)._ptr,incy,batchCount))
    return (_hipblasZsymvBatched_v2__retval,)


@cython.embedsignature(True)
def hipblasSsymvBatched_64(object handle, object uplo, long n, object alpha, object AP, long lda, object x, long incx, object beta, object y, long incy, long batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        uplo (`~.hipblasFillMode_t`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        alpha (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        AP (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        x (`~.hip._util.types.ListOfPointer`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        beta (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        y (`~.hip._util.types.ListOfPointer`/`~.object`):
            (undocumented)

        incy (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")
    _hipblasSsymvBatched_64__retval = hipblasStatus_t(chipblas.hipblasSsymvBatched_64(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,uplo.value,n,
        <const float *>hip._util.types.Pointer.fromPyobj(alpha)._ptr,
        <const float *const*>hip._util.types.Pointer.fromPyobj(AP)._ptr,lda,
        <const float *const*>hip._util.types.ListOfPointer.fromPyobj(x)._ptr,incx,
        <const float *>hip._util.types.Pointer.fromPyobj(beta)._ptr,
        <float *const*>hip._util.types.ListOfPointer.fromPyobj(y)._ptr,incy,batchCount))
    return (_hipblasSsymvBatched_64__retval,)


@cython.embedsignature(True)
def hipblasDsymvBatched_64(object handle, object uplo, long n, object alpha, object AP, long lda, object x, long incx, object beta, object y, long incy, long batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        uplo (`~.hipblasFillMode_t`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        alpha (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        AP (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        x (`~.hip._util.types.ListOfPointer`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        beta (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        y (`~.hip._util.types.ListOfPointer`/`~.object`):
            (undocumented)

        incy (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")
    _hipblasDsymvBatched_64__retval = hipblasStatus_t(chipblas.hipblasDsymvBatched_64(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,uplo.value,n,
        <const double *>hip._util.types.Pointer.fromPyobj(alpha)._ptr,
        <const double *const*>hip._util.types.Pointer.fromPyobj(AP)._ptr,lda,
        <const double *const*>hip._util.types.ListOfPointer.fromPyobj(x)._ptr,incx,
        <const double *>hip._util.types.Pointer.fromPyobj(beta)._ptr,
        <double *const*>hip._util.types.ListOfPointer.fromPyobj(y)._ptr,incy,batchCount))
    return (_hipblasDsymvBatched_64__retval,)


@cython.embedsignature(True)
def hipblasCsymvBatched_64(object handle, object uplo, long n, object alpha, object AP, long lda, object x, long incx, object beta, object y, long incy, long batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        uplo (`~.hipblasFillMode_t`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        alpha (`~.hipblasComplex`/`~.object`):
            (undocumented)

        AP (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        x (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        beta (`~.hipblasComplex`/`~.object`):
            (undocumented)

        y (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        incy (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")
    _hipblasCsymvBatched_64__retval = hipblasStatus_t(chipblas.hipblasCsymvBatched_64(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,uplo.value,n,
        hipblasComplex.fromPyobj(alpha).getElementPtr(),
        <chipblas.hipblasComplex *const*>hip._util.types.Pointer.fromPyobj(AP)._ptr,lda,
        <chipblas.hipblasComplex *const*>hip._util.types.Pointer.fromPyobj(x)._ptr,incx,
        hipblasComplex.fromPyobj(beta).getElementPtr(),
        <chipblas.hipblasComplex *const*>hip._util.types.Pointer.fromPyobj(y)._ptr,incy,batchCount))
    return (_hipblasCsymvBatched_64__retval,)


@cython.embedsignature(True)
def hipblasZsymvBatched_64(object handle, object uplo, long n, object alpha, object AP, long lda, object x, long incx, object beta, object y, long incy, long batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        uplo (`~.hipblasFillMode_t`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        alpha (`~.hipblasDoubleComplex`/`~.object`):
            (undocumented)

        AP (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        x (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        beta (`~.hipblasDoubleComplex`/`~.object`):
            (undocumented)

        y (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        incy (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")
    _hipblasZsymvBatched_64__retval = hipblasStatus_t(chipblas.hipblasZsymvBatched_64(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,uplo.value,n,
        hipblasDoubleComplex.fromPyobj(alpha).getElementPtr(),
        <chipblas.hipblasDoubleComplex *const*>hip._util.types.Pointer.fromPyobj(AP)._ptr,lda,
        <chipblas.hipblasDoubleComplex *const*>hip._util.types.Pointer.fromPyobj(x)._ptr,incx,
        hipblasDoubleComplex.fromPyobj(beta).getElementPtr(),
        <chipblas.hipblasDoubleComplex *const*>hip._util.types.Pointer.fromPyobj(y)._ptr,incy,batchCount))
    return (_hipblasZsymvBatched_64__retval,)


@cython.embedsignature(True)
def hipblasCsymvBatched_v2_64(object handle, object uplo, long n, object alpha, object AP, long lda, object x, long incx, object beta, object y, long incy, long batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        uplo (`~.hipblasFillMode_t`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        alpha (`~.float2`/`~.object`):
            (undocumented)

        AP (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        x (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        beta (`~.float2`/`~.object`):
            (undocumented)

        y (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        incy (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")
    _hipblasCsymvBatched_v2_64__retval = hipblasStatus_t(chipblas.hipblasCsymvBatched_v2_64(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,uplo.value,n,
        float2.fromPyobj(alpha).getElementPtr(),
        <chipblas.float2 *const*>hip._util.types.Pointer.fromPyobj(AP)._ptr,lda,
        <chipblas.float2 *const*>hip._util.types.Pointer.fromPyobj(x)._ptr,incx,
        float2.fromPyobj(beta).getElementPtr(),
        <chipblas.float2 *const*>hip._util.types.Pointer.fromPyobj(y)._ptr,incy,batchCount))
    return (_hipblasCsymvBatched_v2_64__retval,)


@cython.embedsignature(True)
def hipblasZsymvBatched_v2_64(object handle, object uplo, long n, object alpha, object AP, long lda, object x, long incx, object beta, object y, long incy, long batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        uplo (`~.hipblasFillMode_t`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        alpha (`~.double2`/`~.object`):
            (undocumented)

        AP (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        x (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        beta (`~.double2`/`~.object`):
            (undocumented)

        y (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        incy (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")
    _hipblasZsymvBatched_v2_64__retval = hipblasStatus_t(chipblas.hipblasZsymvBatched_v2_64(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,uplo.value,n,
        double2.fromPyobj(alpha).getElementPtr(),
        <chipblas.double2 *const*>hip._util.types.Pointer.fromPyobj(AP)._ptr,lda,
        <chipblas.double2 *const*>hip._util.types.Pointer.fromPyobj(x)._ptr,incx,
        double2.fromPyobj(beta).getElementPtr(),
        <chipblas.double2 *const*>hip._util.types.Pointer.fromPyobj(y)._ptr,incy,batchCount))
    return (_hipblasZsymvBatched_v2_64__retval,)


@cython.embedsignature(True)
def hipblasSsymvStridedBatched(object handle, object uplo, int n, object alpha, object AP, int lda, long strideA, object x, int incx, long stridex, object beta, object y, int incy, long stridey, int batchCount):
    r"""BLAS Level 2 API

    @{

    symvStridedBatched performs the matrix-vector operation:

    y_i := alpha*A_i*x_i + beta*y_i,

    where (A_i, x_i, y_i) is the i-th instance of the batch.
    alpha and beta are scalars, x_i and y_i are vectors and A_i is an
    n by n symmetric matrix, for i = 1, ..., batchCount.
    A a should contain an upper or lower triangular symmetric matrix
    and the opposing triangular part of A is not referenced

    - Supported precisions in rocBLAS : s,d,c,z
    - Supported precisions in cuBLAS  : No support

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`) -- *IN*:
            [hipblasHandle_t]
            handle to the hipblas library context queue

        uplo (`~.hipblasFillMode_t`) -- *IN*:
            [hipblasFillMode_t]
            specifies whether the upper 'HIPBLAS_FILL_MODE_UPPER' or lower 'HIPBLAS_FILL_MODE_LOWER'
            if HIPBLAS_FILL_MODE_UPPER, the lower part of A is not referenced
            if HIPBLAS_FILL_MODE_LOWER, the upper part of A is not referenced

        n (`~.int`) -- *IN*:
            [int]
            number of rows and columns of each matrix A_i

        alpha (`~.hip._util.types.Pointer`/`~.object`) -- *IN*:
            device pointer or host pointer to scalar alpha

        AP (`~.hip._util.types.Pointer`/`~.object`) -- *IN*:
            Device pointer to the first matrix A_1 on the GPU

        lda (`~.int`) -- *IN*:
            [int]
            specifies the leading dimension of each matrix A_i

        strideA (`~.int`) -- *IN*:
            [hipblasStride]
            stride from the start of one matrix (A_i) and the next one (A_i+1)

        x (`~.hip._util.types.Pointer`/`~.object`) -- *IN*:
            Device pointer to the first vector x_1 on the GPU

        incx (`~.int`) -- *IN*:
            [int]
            specifies the increment for the elements of each vector x_i

        stridex (`~.int`) -- *IN*:
            [hipblasStride]
            stride from the start of one vector (x_i) and the next one (x_i+1).
            There are no restrictions placed on stridex, however the user should
            take care to ensure that stridex is of appropriate size.
            This typically means stridex >= n * incx. stridex should be non zero.

        beta (`~.hip._util.types.Pointer`/`~.object`) -- *IN*:
            device pointer or host pointer to scalar beta

        y (`~.hip._util.types.Pointer`/`~.object`) -- *OUT*:
            Device pointer to the first vector y_1 on the GPU

        incy (`~.int`) -- *IN*:
            [int]
            specifies the increment for the elements of each vector y_i

        stridey (`~.int`) -- *IN*:
            [hipblasStride]
            stride from the start of one vector (y_i) and the next one (y_i+1).
            There are no restrictions placed on stridey, however the user should
            take care to ensure that stridey is of appropriate size.
            This typically means stridey >= n * incy. stridey should be non zero.

        batchCount (`~.int`) -- *IN*:
            [int]
            number of instances in the batch
    """
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")
    _hipblasSsymvStridedBatched__retval = hipblasStatus_t(chipblas.hipblasSsymvStridedBatched(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,uplo.value,n,
        <const float *>hip._util.types.Pointer.fromPyobj(alpha)._ptr,
        <const float *>hip._util.types.Pointer.fromPyobj(AP)._ptr,lda,strideA,
        <const float *>hip._util.types.Pointer.fromPyobj(x)._ptr,incx,stridex,
        <const float *>hip._util.types.Pointer.fromPyobj(beta)._ptr,
        <float *>hip._util.types.Pointer.fromPyobj(y)._ptr,incy,stridey,batchCount))
    return (_hipblasSsymvStridedBatched__retval,)


@cython.embedsignature(True)
def hipblasDsymvStridedBatched(object handle, object uplo, int n, object alpha, object AP, int lda, long strideA, object x, int incx, long stridex, object beta, object y, int incy, long stridey, int batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        uplo (`~.hipblasFillMode_t`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        alpha (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        AP (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        strideA (`~.int`):
            (undocumented)

        x (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        stridex (`~.int`):
            (undocumented)

        beta (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        y (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        incy (`~.int`):
            (undocumented)

        stridey (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")
    _hipblasDsymvStridedBatched__retval = hipblasStatus_t(chipblas.hipblasDsymvStridedBatched(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,uplo.value,n,
        <const double *>hip._util.types.Pointer.fromPyobj(alpha)._ptr,
        <const double *>hip._util.types.Pointer.fromPyobj(AP)._ptr,lda,strideA,
        <const double *>hip._util.types.Pointer.fromPyobj(x)._ptr,incx,stridex,
        <const double *>hip._util.types.Pointer.fromPyobj(beta)._ptr,
        <double *>hip._util.types.Pointer.fromPyobj(y)._ptr,incy,stridey,batchCount))
    return (_hipblasDsymvStridedBatched__retval,)


@cython.embedsignature(True)
def hipblasCsymvStridedBatched(object handle, object uplo, int n, object alpha, object AP, int lda, long strideA, object x, int incx, long stridex, object beta, object y, int incy, long stridey, int batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        uplo (`~.hipblasFillMode_t`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        alpha (`~.hipblasComplex`/`~.object`):
            (undocumented)

        AP (`~.hipblasComplex`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        strideA (`~.int`):
            (undocumented)

        x (`~.hipblasComplex`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        stridex (`~.int`):
            (undocumented)

        beta (`~.hipblasComplex`/`~.object`):
            (undocumented)

        y (`~.hipblasComplex`/`~.object`):
            (undocumented)

        incy (`~.int`):
            (undocumented)

        stridey (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")
    _hipblasCsymvStridedBatched__retval = hipblasStatus_t(chipblas.hipblasCsymvStridedBatched(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,uplo.value,n,
        hipblasComplex.fromPyobj(alpha).getElementPtr(),
        hipblasComplex.fromPyobj(AP).getElementPtr(),lda,strideA,
        hipblasComplex.fromPyobj(x).getElementPtr(),incx,stridex,
        hipblasComplex.fromPyobj(beta).getElementPtr(),
        hipblasComplex.fromPyobj(y).getElementPtr(),incy,stridey,batchCount))
    return (_hipblasCsymvStridedBatched__retval,)


@cython.embedsignature(True)
def hipblasZsymvStridedBatched(object handle, object uplo, int n, object alpha, object AP, int lda, long strideA, object x, int incx, long stridex, object beta, object y, int incy, long stridey, int batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        uplo (`~.hipblasFillMode_t`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        alpha (`~.hipblasDoubleComplex`/`~.object`):
            (undocumented)

        AP (`~.hipblasDoubleComplex`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        strideA (`~.int`):
            (undocumented)

        x (`~.hipblasDoubleComplex`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        stridex (`~.int`):
            (undocumented)

        beta (`~.hipblasDoubleComplex`/`~.object`):
            (undocumented)

        y (`~.hipblasDoubleComplex`/`~.object`):
            (undocumented)

        incy (`~.int`):
            (undocumented)

        stridey (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")
    _hipblasZsymvStridedBatched__retval = hipblasStatus_t(chipblas.hipblasZsymvStridedBatched(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,uplo.value,n,
        hipblasDoubleComplex.fromPyobj(alpha).getElementPtr(),
        hipblasDoubleComplex.fromPyobj(AP).getElementPtr(),lda,strideA,
        hipblasDoubleComplex.fromPyobj(x).getElementPtr(),incx,stridex,
        hipblasDoubleComplex.fromPyobj(beta).getElementPtr(),
        hipblasDoubleComplex.fromPyobj(y).getElementPtr(),incy,stridey,batchCount))
    return (_hipblasZsymvStridedBatched__retval,)


@cython.embedsignature(True)
def hipblasCsymvStridedBatched_v2(object handle, object uplo, int n, object alpha, object AP, int lda, long strideA, object x, int incx, long stridex, object beta, object y, int incy, long stridey, int batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        uplo (`~.hipblasFillMode_t`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        alpha (`~.float2`/`~.object`):
            (undocumented)

        AP (`~.float2`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        strideA (`~.int`):
            (undocumented)

        x (`~.float2`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        stridex (`~.int`):
            (undocumented)

        beta (`~.float2`/`~.object`):
            (undocumented)

        y (`~.float2`/`~.object`):
            (undocumented)

        incy (`~.int`):
            (undocumented)

        stridey (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")
    _hipblasCsymvStridedBatched_v2__retval = hipblasStatus_t(chipblas.hipblasCsymvStridedBatched_v2(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,uplo.value,n,
        float2.fromPyobj(alpha).getElementPtr(),
        float2.fromPyobj(AP).getElementPtr(),lda,strideA,
        float2.fromPyobj(x).getElementPtr(),incx,stridex,
        float2.fromPyobj(beta).getElementPtr(),
        float2.fromPyobj(y).getElementPtr(),incy,stridey,batchCount))
    return (_hipblasCsymvStridedBatched_v2__retval,)


@cython.embedsignature(True)
def hipblasZsymvStridedBatched_v2(object handle, object uplo, int n, object alpha, object AP, int lda, long strideA, object x, int incx, long stridex, object beta, object y, int incy, long stridey, int batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        uplo (`~.hipblasFillMode_t`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        alpha (`~.double2`/`~.object`):
            (undocumented)

        AP (`~.double2`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        strideA (`~.int`):
            (undocumented)

        x (`~.double2`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        stridex (`~.int`):
            (undocumented)

        beta (`~.double2`/`~.object`):
            (undocumented)

        y (`~.double2`/`~.object`):
            (undocumented)

        incy (`~.int`):
            (undocumented)

        stridey (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")
    _hipblasZsymvStridedBatched_v2__retval = hipblasStatus_t(chipblas.hipblasZsymvStridedBatched_v2(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,uplo.value,n,
        double2.fromPyobj(alpha).getElementPtr(),
        double2.fromPyobj(AP).getElementPtr(),lda,strideA,
        double2.fromPyobj(x).getElementPtr(),incx,stridex,
        double2.fromPyobj(beta).getElementPtr(),
        double2.fromPyobj(y).getElementPtr(),incy,stridey,batchCount))
    return (_hipblasZsymvStridedBatched_v2__retval,)


@cython.embedsignature(True)
def hipblasSsymvStridedBatched_64(object handle, object uplo, long n, object alpha, object AP, long lda, long strideA, object x, long incx, long stridex, object beta, object y, long incy, long stridey, long batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        uplo (`~.hipblasFillMode_t`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        alpha (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        AP (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        strideA (`~.int`):
            (undocumented)

        x (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        stridex (`~.int`):
            (undocumented)

        beta (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        y (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        incy (`~.int`):
            (undocumented)

        stridey (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")
    _hipblasSsymvStridedBatched_64__retval = hipblasStatus_t(chipblas.hipblasSsymvStridedBatched_64(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,uplo.value,n,
        <const float *>hip._util.types.Pointer.fromPyobj(alpha)._ptr,
        <const float *>hip._util.types.Pointer.fromPyobj(AP)._ptr,lda,strideA,
        <const float *>hip._util.types.Pointer.fromPyobj(x)._ptr,incx,stridex,
        <const float *>hip._util.types.Pointer.fromPyobj(beta)._ptr,
        <float *>hip._util.types.Pointer.fromPyobj(y)._ptr,incy,stridey,batchCount))
    return (_hipblasSsymvStridedBatched_64__retval,)


@cython.embedsignature(True)
def hipblasDsymvStridedBatched_64(object handle, object uplo, long n, object alpha, object AP, long lda, long strideA, object x, long incx, long stridex, object beta, object y, long incy, long stridey, long batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        uplo (`~.hipblasFillMode_t`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        alpha (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        AP (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        strideA (`~.int`):
            (undocumented)

        x (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        stridex (`~.int`):
            (undocumented)

        beta (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        y (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        incy (`~.int`):
            (undocumented)

        stridey (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")
    _hipblasDsymvStridedBatched_64__retval = hipblasStatus_t(chipblas.hipblasDsymvStridedBatched_64(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,uplo.value,n,
        <const double *>hip._util.types.Pointer.fromPyobj(alpha)._ptr,
        <const double *>hip._util.types.Pointer.fromPyobj(AP)._ptr,lda,strideA,
        <const double *>hip._util.types.Pointer.fromPyobj(x)._ptr,incx,stridex,
        <const double *>hip._util.types.Pointer.fromPyobj(beta)._ptr,
        <double *>hip._util.types.Pointer.fromPyobj(y)._ptr,incy,stridey,batchCount))
    return (_hipblasDsymvStridedBatched_64__retval,)


@cython.embedsignature(True)
def hipblasCsymvStridedBatched_64(object handle, object uplo, long n, object alpha, object AP, long lda, long strideA, object x, long incx, long stridex, object beta, object y, long incy, long stridey, long batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        uplo (`~.hipblasFillMode_t`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        alpha (`~.hipblasComplex`/`~.object`):
            (undocumented)

        AP (`~.hipblasComplex`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        strideA (`~.int`):
            (undocumented)

        x (`~.hipblasComplex`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        stridex (`~.int`):
            (undocumented)

        beta (`~.hipblasComplex`/`~.object`):
            (undocumented)

        y (`~.hipblasComplex`/`~.object`):
            (undocumented)

        incy (`~.int`):
            (undocumented)

        stridey (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")
    _hipblasCsymvStridedBatched_64__retval = hipblasStatus_t(chipblas.hipblasCsymvStridedBatched_64(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,uplo.value,n,
        hipblasComplex.fromPyobj(alpha).getElementPtr(),
        hipblasComplex.fromPyobj(AP).getElementPtr(),lda,strideA,
        hipblasComplex.fromPyobj(x).getElementPtr(),incx,stridex,
        hipblasComplex.fromPyobj(beta).getElementPtr(),
        hipblasComplex.fromPyobj(y).getElementPtr(),incy,stridey,batchCount))
    return (_hipblasCsymvStridedBatched_64__retval,)


@cython.embedsignature(True)
def hipblasZsymvStridedBatched_64(object handle, object uplo, long n, object alpha, object AP, long lda, long strideA, object x, long incx, long stridex, object beta, object y, long incy, long stridey, long batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        uplo (`~.hipblasFillMode_t`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        alpha (`~.hipblasDoubleComplex`/`~.object`):
            (undocumented)

        AP (`~.hipblasDoubleComplex`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        strideA (`~.int`):
            (undocumented)

        x (`~.hipblasDoubleComplex`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        stridex (`~.int`):
            (undocumented)

        beta (`~.hipblasDoubleComplex`/`~.object`):
            (undocumented)

        y (`~.hipblasDoubleComplex`/`~.object`):
            (undocumented)

        incy (`~.int`):
            (undocumented)

        stridey (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")
    _hipblasZsymvStridedBatched_64__retval = hipblasStatus_t(chipblas.hipblasZsymvStridedBatched_64(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,uplo.value,n,
        hipblasDoubleComplex.fromPyobj(alpha).getElementPtr(),
        hipblasDoubleComplex.fromPyobj(AP).getElementPtr(),lda,strideA,
        hipblasDoubleComplex.fromPyobj(x).getElementPtr(),incx,stridex,
        hipblasDoubleComplex.fromPyobj(beta).getElementPtr(),
        hipblasDoubleComplex.fromPyobj(y).getElementPtr(),incy,stridey,batchCount))
    return (_hipblasZsymvStridedBatched_64__retval,)


@cython.embedsignature(True)
def hipblasCsymvStridedBatched_v2_64(object handle, object uplo, long n, object alpha, object AP, long lda, long strideA, object x, long incx, long stridex, object beta, object y, long incy, long stridey, long batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        uplo (`~.hipblasFillMode_t`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        alpha (`~.float2`/`~.object`):
            (undocumented)

        AP (`~.float2`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        strideA (`~.int`):
            (undocumented)

        x (`~.float2`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        stridex (`~.int`):
            (undocumented)

        beta (`~.float2`/`~.object`):
            (undocumented)

        y (`~.float2`/`~.object`):
            (undocumented)

        incy (`~.int`):
            (undocumented)

        stridey (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")
    _hipblasCsymvStridedBatched_v2_64__retval = hipblasStatus_t(chipblas.hipblasCsymvStridedBatched_v2_64(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,uplo.value,n,
        float2.fromPyobj(alpha).getElementPtr(),
        float2.fromPyobj(AP).getElementPtr(),lda,strideA,
        float2.fromPyobj(x).getElementPtr(),incx,stridex,
        float2.fromPyobj(beta).getElementPtr(),
        float2.fromPyobj(y).getElementPtr(),incy,stridey,batchCount))
    return (_hipblasCsymvStridedBatched_v2_64__retval,)


@cython.embedsignature(True)
def hipblasZsymvStridedBatched_v2_64(object handle, object uplo, long n, object alpha, object AP, long lda, long strideA, object x, long incx, long stridex, object beta, object y, long incy, long stridey, long batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        uplo (`~.hipblasFillMode_t`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        alpha (`~.double2`/`~.object`):
            (undocumented)

        AP (`~.double2`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        strideA (`~.int`):
            (undocumented)

        x (`~.double2`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        stridex (`~.int`):
            (undocumented)

        beta (`~.double2`/`~.object`):
            (undocumented)

        y (`~.double2`/`~.object`):
            (undocumented)

        incy (`~.int`):
            (undocumented)

        stridey (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")
    _hipblasZsymvStridedBatched_v2_64__retval = hipblasStatus_t(chipblas.hipblasZsymvStridedBatched_v2_64(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,uplo.value,n,
        double2.fromPyobj(alpha).getElementPtr(),
        double2.fromPyobj(AP).getElementPtr(),lda,strideA,
        double2.fromPyobj(x).getElementPtr(),incx,stridex,
        double2.fromPyobj(beta).getElementPtr(),
        double2.fromPyobj(y).getElementPtr(),incy,stridey,batchCount))
    return (_hipblasZsymvStridedBatched_v2_64__retval,)


@cython.embedsignature(True)
def hipblasSsyr(object handle, object uplo, int n, object alpha, object x, int incx, object AP, int lda):
    r"""BLAS Level 2 API

    @{

    syr performs the matrix-vector operations

    A := A + alpha*x*x**T

    where alpha is a scalar, x is a vector, and A is an
    n by n symmetric matrix.

    - Supported precisions in rocBLAS : s,d,c,z
    - Supported precisions in cuBLAS  : s,d,c,z

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`) -- *IN*:
            [hipblasHandle_t]
            handle to the hipblas library context queue.

        uplo (`~.hipblasFillMode_t`) -- *IN*:
            [hipblasFillMode_t]
            specifies whether the upper 'HIPBLAS_FILL_MODE_UPPER' or lower 'HIPBLAS_FILL_MODE_LOWER'
            if HIPBLAS_FILL_MODE_UPPER, the lower part of A is not referenced
            if HIPBLAS_FILL_MODE_LOWER, the upper part of A is not referenced

        n (`~.int`) -- *IN*:
            [int]
            the number of rows and columns of matrix A.

        alpha (`~.hip._util.types.Pointer`/`~.object`) -- *IN*:
            device pointer or host pointer to scalar alpha.

        x (`~.hip._util.types.Pointer`/`~.object`) -- *IN*:
            device pointer storing vector x.

        incx (`~.int`) -- *IN*:
            [int]
            specifies the increment for the elements of x.

        AP (`~.hip._util.types.Pointer`/`~.object`) -- *INOUT*:
            device pointer storing matrix A.

        lda (`~.int`) -- *IN*:
            [int]
            specifies the leading dimension of A.
    """
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")
    _hipblasSsyr__retval = hipblasStatus_t(chipblas.hipblasSsyr(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,uplo.value,n,
        <const float *>hip._util.types.Pointer.fromPyobj(alpha)._ptr,
        <const float *>hip._util.types.Pointer.fromPyobj(x)._ptr,incx,
        <float *>hip._util.types.Pointer.fromPyobj(AP)._ptr,lda))
    return (_hipblasSsyr__retval,)


@cython.embedsignature(True)
def hipblasDsyr(object handle, object uplo, int n, object alpha, object x, int incx, object AP, int lda):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        uplo (`~.hipblasFillMode_t`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        alpha (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        x (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        AP (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)
    """
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")
    _hipblasDsyr__retval = hipblasStatus_t(chipblas.hipblasDsyr(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,uplo.value,n,
        <const double *>hip._util.types.Pointer.fromPyobj(alpha)._ptr,
        <const double *>hip._util.types.Pointer.fromPyobj(x)._ptr,incx,
        <double *>hip._util.types.Pointer.fromPyobj(AP)._ptr,lda))
    return (_hipblasDsyr__retval,)


@cython.embedsignature(True)
def hipblasCsyr(object handle, object uplo, int n, object alpha, object x, int incx, object AP, int lda):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        uplo (`~.hipblasFillMode_t`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        alpha (`~.hipblasComplex`/`~.object`):
            (undocumented)

        x (`~.hipblasComplex`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        AP (`~.hipblasComplex`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)
    """
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")
    _hipblasCsyr__retval = hipblasStatus_t(chipblas.hipblasCsyr(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,uplo.value,n,
        hipblasComplex.fromPyobj(alpha).getElementPtr(),
        hipblasComplex.fromPyobj(x).getElementPtr(),incx,
        hipblasComplex.fromPyobj(AP).getElementPtr(),lda))
    return (_hipblasCsyr__retval,)


@cython.embedsignature(True)
def hipblasZsyr(object handle, object uplo, int n, object alpha, object x, int incx, object AP, int lda):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        uplo (`~.hipblasFillMode_t`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        alpha (`~.hipblasDoubleComplex`/`~.object`):
            (undocumented)

        x (`~.hipblasDoubleComplex`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        AP (`~.hipblasDoubleComplex`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)
    """
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")
    _hipblasZsyr__retval = hipblasStatus_t(chipblas.hipblasZsyr(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,uplo.value,n,
        hipblasDoubleComplex.fromPyobj(alpha).getElementPtr(),
        hipblasDoubleComplex.fromPyobj(x).getElementPtr(),incx,
        hipblasDoubleComplex.fromPyobj(AP).getElementPtr(),lda))
    return (_hipblasZsyr__retval,)


@cython.embedsignature(True)
def hipblasCsyr_v2(object handle, object uplo, int n, object alpha, object x, int incx, object AP, int lda):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        uplo (`~.hipblasFillMode_t`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        alpha (`~.float2`/`~.object`):
            (undocumented)

        x (`~.float2`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        AP (`~.float2`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)
    """
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")
    _hipblasCsyr_v2__retval = hipblasStatus_t(chipblas.hipblasCsyr_v2(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,uplo.value,n,
        float2.fromPyobj(alpha).getElementPtr(),
        float2.fromPyobj(x).getElementPtr(),incx,
        float2.fromPyobj(AP).getElementPtr(),lda))
    return (_hipblasCsyr_v2__retval,)


@cython.embedsignature(True)
def hipblasZsyr_v2(object handle, object uplo, int n, object alpha, object x, int incx, object AP, int lda):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        uplo (`~.hipblasFillMode_t`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        alpha (`~.double2`/`~.object`):
            (undocumented)

        x (`~.double2`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        AP (`~.double2`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)
    """
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")
    _hipblasZsyr_v2__retval = hipblasStatus_t(chipblas.hipblasZsyr_v2(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,uplo.value,n,
        double2.fromPyobj(alpha).getElementPtr(),
        double2.fromPyobj(x).getElementPtr(),incx,
        double2.fromPyobj(AP).getElementPtr(),lda))
    return (_hipblasZsyr_v2__retval,)


@cython.embedsignature(True)
def hipblasSsyr_64(object handle, object uplo, long n, object alpha, object x, long incx, object AP, long lda):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        uplo (`~.hipblasFillMode_t`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        alpha (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        x (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        AP (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)
    """
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")
    _hipblasSsyr_64__retval = hipblasStatus_t(chipblas.hipblasSsyr_64(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,uplo.value,n,
        <const float *>hip._util.types.Pointer.fromPyobj(alpha)._ptr,
        <const float *>hip._util.types.Pointer.fromPyobj(x)._ptr,incx,
        <float *>hip._util.types.Pointer.fromPyobj(AP)._ptr,lda))
    return (_hipblasSsyr_64__retval,)


@cython.embedsignature(True)
def hipblasDsyr_64(object handle, object uplo, long n, object alpha, object x, long incx, object AP, long lda):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        uplo (`~.hipblasFillMode_t`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        alpha (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        x (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        AP (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)
    """
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")
    _hipblasDsyr_64__retval = hipblasStatus_t(chipblas.hipblasDsyr_64(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,uplo.value,n,
        <const double *>hip._util.types.Pointer.fromPyobj(alpha)._ptr,
        <const double *>hip._util.types.Pointer.fromPyobj(x)._ptr,incx,
        <double *>hip._util.types.Pointer.fromPyobj(AP)._ptr,lda))
    return (_hipblasDsyr_64__retval,)


@cython.embedsignature(True)
def hipblasCsyr_64(object handle, object uplo, long n, object alpha, object x, long incx, object AP, long lda):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        uplo (`~.hipblasFillMode_t`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        alpha (`~.hipblasComplex`/`~.object`):
            (undocumented)

        x (`~.hipblasComplex`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        AP (`~.hipblasComplex`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)
    """
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")
    _hipblasCsyr_64__retval = hipblasStatus_t(chipblas.hipblasCsyr_64(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,uplo.value,n,
        hipblasComplex.fromPyobj(alpha).getElementPtr(),
        hipblasComplex.fromPyobj(x).getElementPtr(),incx,
        hipblasComplex.fromPyobj(AP).getElementPtr(),lda))
    return (_hipblasCsyr_64__retval,)


@cython.embedsignature(True)
def hipblasZsyr_64(object handle, object uplo, long n, object alpha, object x, long incx, object AP, long lda):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        uplo (`~.hipblasFillMode_t`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        alpha (`~.hipblasDoubleComplex`/`~.object`):
            (undocumented)

        x (`~.hipblasDoubleComplex`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        AP (`~.hipblasDoubleComplex`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)
    """
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")
    _hipblasZsyr_64__retval = hipblasStatus_t(chipblas.hipblasZsyr_64(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,uplo.value,n,
        hipblasDoubleComplex.fromPyobj(alpha).getElementPtr(),
        hipblasDoubleComplex.fromPyobj(x).getElementPtr(),incx,
        hipblasDoubleComplex.fromPyobj(AP).getElementPtr(),lda))
    return (_hipblasZsyr_64__retval,)


@cython.embedsignature(True)
def hipblasCsyr_v2_64(object handle, object uplo, long n, object alpha, object x, long incx, object AP, long lda):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        uplo (`~.hipblasFillMode_t`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        alpha (`~.float2`/`~.object`):
            (undocumented)

        x (`~.float2`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        AP (`~.float2`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)
    """
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")
    _hipblasCsyr_v2_64__retval = hipblasStatus_t(chipblas.hipblasCsyr_v2_64(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,uplo.value,n,
        float2.fromPyobj(alpha).getElementPtr(),
        float2.fromPyobj(x).getElementPtr(),incx,
        float2.fromPyobj(AP).getElementPtr(),lda))
    return (_hipblasCsyr_v2_64__retval,)


@cython.embedsignature(True)
def hipblasZsyr_v2_64(object handle, object uplo, long n, object alpha, object x, long incx, object AP, long lda):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        uplo (`~.hipblasFillMode_t`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        alpha (`~.double2`/`~.object`):
            (undocumented)

        x (`~.double2`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        AP (`~.double2`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)
    """
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")
    _hipblasZsyr_v2_64__retval = hipblasStatus_t(chipblas.hipblasZsyr_v2_64(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,uplo.value,n,
        double2.fromPyobj(alpha).getElementPtr(),
        double2.fromPyobj(x).getElementPtr(),incx,
        double2.fromPyobj(AP).getElementPtr(),lda))
    return (_hipblasZsyr_v2_64__retval,)


@cython.embedsignature(True)
def hipblasSsyrBatched(object handle, object uplo, int n, object alpha, object x, int incx, object AP, int lda, int batchCount):
    r"""BLAS Level 2 API

    @{

    syrBatched performs a batch of matrix-vector operations

    A[i] := A[i] + alpha*x[i]*x[i]**T

    where alpha is a scalar, x is an array of vectors, and A is an array of
    n by n symmetric matrices, for i = 1 , ... , batchCount.

    - Supported precisions in rocBLAS : s,d,c,z
    - Supported precisions in cuBLAS  : No support

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`) -- *IN*:
            [hipblasHandle_t]
            handle to the hipblas library context queue.

        uplo (`~.hipblasFillMode_t`) -- *IN*:
            [hipblasFillMode_t]
            specifies whether the upper 'HIPBLAS_FILL_MODE_UPPER' or lower 'HIPBLAS_FILL_MODE_LOWER'
            if HIPBLAS_FILL_MODE_UPPER, the lower part of A is not referenced
            if HIPBLAS_FILL_MODE_LOWER, the upper part of A is not referenced

        n (`~.int`) -- *IN*:
            [int]
            the number of rows and columns of matrix A.

        alpha (`~.hip._util.types.Pointer`/`~.object`) -- *IN*:
            device pointer or host pointer to scalar alpha.

        x (`~.hip._util.types.ListOfPointer`/`~.object`) -- *IN*:
            device array of device pointers storing each vector x_i.

        incx (`~.int`) -- *IN*:
            [int]
            specifies the increment for the elements of each x_i.

        AP (`~.hip._util.types.Pointer`/`~.object`) -- *INOUT*:
            device array of device pointers storing each matrix A_i.

        lda (`~.int`) -- *IN*:
            [int]
            specifies the leading dimension of each A_i.

        batchCount (`~.int`) -- *IN*:
            [int]
            number of instances in the batch
    """
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")
    _hipblasSsyrBatched__retval = hipblasStatus_t(chipblas.hipblasSsyrBatched(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,uplo.value,n,
        <const float *>hip._util.types.Pointer.fromPyobj(alpha)._ptr,
        <const float *const*>hip._util.types.ListOfPointer.fromPyobj(x)._ptr,incx,
        <float *const*>hip._util.types.Pointer.fromPyobj(AP)._ptr,lda,batchCount))
    return (_hipblasSsyrBatched__retval,)


@cython.embedsignature(True)
def hipblasDsyrBatched(object handle, object uplo, int n, object alpha, object x, int incx, object AP, int lda, int batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        uplo (`~.hipblasFillMode_t`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        alpha (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        x (`~.hip._util.types.ListOfPointer`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        AP (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")
    _hipblasDsyrBatched__retval = hipblasStatus_t(chipblas.hipblasDsyrBatched(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,uplo.value,n,
        <const double *>hip._util.types.Pointer.fromPyobj(alpha)._ptr,
        <const double *const*>hip._util.types.ListOfPointer.fromPyobj(x)._ptr,incx,
        <double *const*>hip._util.types.Pointer.fromPyobj(AP)._ptr,lda,batchCount))
    return (_hipblasDsyrBatched__retval,)


@cython.embedsignature(True)
def hipblasCsyrBatched(object handle, object uplo, int n, object alpha, object x, int incx, object AP, int lda, int batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        uplo (`~.hipblasFillMode_t`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        alpha (`~.hipblasComplex`/`~.object`):
            (undocumented)

        x (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        AP (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")
    _hipblasCsyrBatched__retval = hipblasStatus_t(chipblas.hipblasCsyrBatched(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,uplo.value,n,
        hipblasComplex.fromPyobj(alpha).getElementPtr(),
        <chipblas.hipblasComplex *const*>hip._util.types.Pointer.fromPyobj(x)._ptr,incx,
        <chipblas.hipblasComplex *const*>hip._util.types.Pointer.fromPyobj(AP)._ptr,lda,batchCount))
    return (_hipblasCsyrBatched__retval,)


@cython.embedsignature(True)
def hipblasZsyrBatched(object handle, object uplo, int n, object alpha, object x, int incx, object AP, int lda, int batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        uplo (`~.hipblasFillMode_t`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        alpha (`~.hipblasDoubleComplex`/`~.object`):
            (undocumented)

        x (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        AP (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")
    _hipblasZsyrBatched__retval = hipblasStatus_t(chipblas.hipblasZsyrBatched(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,uplo.value,n,
        hipblasDoubleComplex.fromPyobj(alpha).getElementPtr(),
        <chipblas.hipblasDoubleComplex *const*>hip._util.types.Pointer.fromPyobj(x)._ptr,incx,
        <chipblas.hipblasDoubleComplex *const*>hip._util.types.Pointer.fromPyobj(AP)._ptr,lda,batchCount))
    return (_hipblasZsyrBatched__retval,)


@cython.embedsignature(True)
def hipblasCsyrBatched_v2(object handle, object uplo, int n, object alpha, object x, int incx, object AP, int lda, int batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        uplo (`~.hipblasFillMode_t`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        alpha (`~.float2`/`~.object`):
            (undocumented)

        x (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        AP (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")
    _hipblasCsyrBatched_v2__retval = hipblasStatus_t(chipblas.hipblasCsyrBatched_v2(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,uplo.value,n,
        float2.fromPyobj(alpha).getElementPtr(),
        <chipblas.float2 *const*>hip._util.types.Pointer.fromPyobj(x)._ptr,incx,
        <chipblas.float2 *const*>hip._util.types.Pointer.fromPyobj(AP)._ptr,lda,batchCount))
    return (_hipblasCsyrBatched_v2__retval,)


@cython.embedsignature(True)
def hipblasZsyrBatched_v2(object handle, object uplo, int n, object alpha, object x, int incx, object AP, int lda, int batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        uplo (`~.hipblasFillMode_t`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        alpha (`~.double2`/`~.object`):
            (undocumented)

        x (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        AP (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")
    _hipblasZsyrBatched_v2__retval = hipblasStatus_t(chipblas.hipblasZsyrBatched_v2(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,uplo.value,n,
        double2.fromPyobj(alpha).getElementPtr(),
        <chipblas.double2 *const*>hip._util.types.Pointer.fromPyobj(x)._ptr,incx,
        <chipblas.double2 *const*>hip._util.types.Pointer.fromPyobj(AP)._ptr,lda,batchCount))
    return (_hipblasZsyrBatched_v2__retval,)


@cython.embedsignature(True)
def hipblasSsyrBatched_64(object handle, object uplo, long n, object alpha, object x, long incx, object AP, long lda, long batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        uplo (`~.hipblasFillMode_t`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        alpha (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        x (`~.hip._util.types.ListOfPointer`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        AP (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")
    _hipblasSsyrBatched_64__retval = hipblasStatus_t(chipblas.hipblasSsyrBatched_64(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,uplo.value,n,
        <const float *>hip._util.types.Pointer.fromPyobj(alpha)._ptr,
        <const float *const*>hip._util.types.ListOfPointer.fromPyobj(x)._ptr,incx,
        <float *const*>hip._util.types.Pointer.fromPyobj(AP)._ptr,lda,batchCount))
    return (_hipblasSsyrBatched_64__retval,)


@cython.embedsignature(True)
def hipblasDsyrBatched_64(object handle, object uplo, long n, object alpha, object x, long incx, object AP, long lda, long batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        uplo (`~.hipblasFillMode_t`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        alpha (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        x (`~.hip._util.types.ListOfPointer`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        AP (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")
    _hipblasDsyrBatched_64__retval = hipblasStatus_t(chipblas.hipblasDsyrBatched_64(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,uplo.value,n,
        <const double *>hip._util.types.Pointer.fromPyobj(alpha)._ptr,
        <const double *const*>hip._util.types.ListOfPointer.fromPyobj(x)._ptr,incx,
        <double *const*>hip._util.types.Pointer.fromPyobj(AP)._ptr,lda,batchCount))
    return (_hipblasDsyrBatched_64__retval,)


@cython.embedsignature(True)
def hipblasCsyrBatched_64(object handle, object uplo, long n, object alpha, object x, long incx, object AP, long lda, long batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        uplo (`~.hipblasFillMode_t`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        alpha (`~.hipblasComplex`/`~.object`):
            (undocumented)

        x (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        AP (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")
    _hipblasCsyrBatched_64__retval = hipblasStatus_t(chipblas.hipblasCsyrBatched_64(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,uplo.value,n,
        hipblasComplex.fromPyobj(alpha).getElementPtr(),
        <chipblas.hipblasComplex *const*>hip._util.types.Pointer.fromPyobj(x)._ptr,incx,
        <chipblas.hipblasComplex *const*>hip._util.types.Pointer.fromPyobj(AP)._ptr,lda,batchCount))
    return (_hipblasCsyrBatched_64__retval,)


@cython.embedsignature(True)
def hipblasZsyrBatched_64(object handle, object uplo, long n, object alpha, object x, long incx, object AP, long lda, long batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        uplo (`~.hipblasFillMode_t`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        alpha (`~.hipblasDoubleComplex`/`~.object`):
            (undocumented)

        x (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        AP (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")
    _hipblasZsyrBatched_64__retval = hipblasStatus_t(chipblas.hipblasZsyrBatched_64(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,uplo.value,n,
        hipblasDoubleComplex.fromPyobj(alpha).getElementPtr(),
        <chipblas.hipblasDoubleComplex *const*>hip._util.types.Pointer.fromPyobj(x)._ptr,incx,
        <chipblas.hipblasDoubleComplex *const*>hip._util.types.Pointer.fromPyobj(AP)._ptr,lda,batchCount))
    return (_hipblasZsyrBatched_64__retval,)


@cython.embedsignature(True)
def hipblasCsyrBatched_v2_64(object handle, object uplo, long n, object alpha, object x, long incx, object AP, long lda, long batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        uplo (`~.hipblasFillMode_t`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        alpha (`~.float2`/`~.object`):
            (undocumented)

        x (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        AP (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")
    _hipblasCsyrBatched_v2_64__retval = hipblasStatus_t(chipblas.hipblasCsyrBatched_v2_64(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,uplo.value,n,
        float2.fromPyobj(alpha).getElementPtr(),
        <chipblas.float2 *const*>hip._util.types.Pointer.fromPyobj(x)._ptr,incx,
        <chipblas.float2 *const*>hip._util.types.Pointer.fromPyobj(AP)._ptr,lda,batchCount))
    return (_hipblasCsyrBatched_v2_64__retval,)


@cython.embedsignature(True)
def hipblasZsyrBatched_v2_64(object handle, object uplo, long n, object alpha, object x, long incx, object AP, long lda, long batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        uplo (`~.hipblasFillMode_t`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        alpha (`~.double2`/`~.object`):
            (undocumented)

        x (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        AP (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")
    _hipblasZsyrBatched_v2_64__retval = hipblasStatus_t(chipblas.hipblasZsyrBatched_v2_64(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,uplo.value,n,
        double2.fromPyobj(alpha).getElementPtr(),
        <chipblas.double2 *const*>hip._util.types.Pointer.fromPyobj(x)._ptr,incx,
        <chipblas.double2 *const*>hip._util.types.Pointer.fromPyobj(AP)._ptr,lda,batchCount))
    return (_hipblasZsyrBatched_v2_64__retval,)


@cython.embedsignature(True)
def hipblasSsyrStridedBatched(object handle, object uplo, int n, object alpha, object x, int incx, long stridex, object AP, int lda, long strideA, int batchCount):
    r"""BLAS Level 2 API

    @{

    syrStridedBatched performs the matrix-vector operations

    A[i] := A[i] + alpha*x[i]*x[i]**T

    where alpha is a scalar, vectors, and A is an array of
    n by n symmetric matrices, for i = 1 , ... , batchCount.

    - Supported precisions in rocBLAS : s,d,c,z
    - Supported precisions in cuBLAS  : No support

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`) -- *IN*:
            [hipblasHandle_t]
            handle to the hipblas library context queue.

        uplo (`~.hipblasFillMode_t`) -- *IN*:
            [hipblasFillMode_t]
            specifies whether the upper 'HIPBLAS_FILL_MODE_UPPER' or lower 'HIPBLAS_FILL_MODE_LOWER'
            if HIPBLAS_FILL_MODE_UPPER, the lower part of A is not referenced
            if HIPBLAS_FILL_MODE_LOWER, the upper part of A is not referenced

        n (`~.int`) -- *IN*:
            [int]
            the number of rows and columns of each matrix A.

        alpha (`~.hip._util.types.Pointer`/`~.object`) -- *IN*:
            device pointer or host pointer to scalar alpha.

        x (`~.hip._util.types.Pointer`/`~.object`) -- *IN*:
            device pointer to the first vector x_1.

        incx (`~.int`) -- *IN*:
            [int]
            specifies the increment for the elements of each x_i.

        stridex (`~.int`) -- *IN*:
            [hipblasStride]
            specifies the pointer increment between vectors (x_i) and (x_i+1).

        AP (`~.hip._util.types.Pointer`/`~.object`) -- *INOUT*:
            device pointer to the first matrix A_1.

        lda (`~.int`) -- *IN*:
            [int]
            specifies the leading dimension of each A_i.

        strideA (`~.int`) -- *IN*:
            [hipblasStride]
            stride from the start of one matrix (A_i) and the next one (A_i+1)

        batchCount (`~.int`) -- *IN*:
            [int]
            number of instances in the batch
    """
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")
    _hipblasSsyrStridedBatched__retval = hipblasStatus_t(chipblas.hipblasSsyrStridedBatched(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,uplo.value,n,
        <const float *>hip._util.types.Pointer.fromPyobj(alpha)._ptr,
        <const float *>hip._util.types.Pointer.fromPyobj(x)._ptr,incx,stridex,
        <float *>hip._util.types.Pointer.fromPyobj(AP)._ptr,lda,strideA,batchCount))
    return (_hipblasSsyrStridedBatched__retval,)


@cython.embedsignature(True)
def hipblasDsyrStridedBatched(object handle, object uplo, int n, object alpha, object x, int incx, long stridex, object AP, int lda, long strideA, int batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        uplo (`~.hipblasFillMode_t`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        alpha (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        x (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        stridex (`~.int`):
            (undocumented)

        AP (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        strideA (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")
    _hipblasDsyrStridedBatched__retval = hipblasStatus_t(chipblas.hipblasDsyrStridedBatched(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,uplo.value,n,
        <const double *>hip._util.types.Pointer.fromPyobj(alpha)._ptr,
        <const double *>hip._util.types.Pointer.fromPyobj(x)._ptr,incx,stridex,
        <double *>hip._util.types.Pointer.fromPyobj(AP)._ptr,lda,strideA,batchCount))
    return (_hipblasDsyrStridedBatched__retval,)


@cython.embedsignature(True)
def hipblasCsyrStridedBatched(object handle, object uplo, int n, object alpha, object x, int incx, long stridex, object AP, int lda, long strideA, int batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        uplo (`~.hipblasFillMode_t`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        alpha (`~.hipblasComplex`/`~.object`):
            (undocumented)

        x (`~.hipblasComplex`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        stridex (`~.int`):
            (undocumented)

        AP (`~.hipblasComplex`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        strideA (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")
    _hipblasCsyrStridedBatched__retval = hipblasStatus_t(chipblas.hipblasCsyrStridedBatched(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,uplo.value,n,
        hipblasComplex.fromPyobj(alpha).getElementPtr(),
        hipblasComplex.fromPyobj(x).getElementPtr(),incx,stridex,
        hipblasComplex.fromPyobj(AP).getElementPtr(),lda,strideA,batchCount))
    return (_hipblasCsyrStridedBatched__retval,)


@cython.embedsignature(True)
def hipblasZsyrStridedBatched(object handle, object uplo, int n, object alpha, object x, int incx, long stridex, object AP, int lda, long strideA, int batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        uplo (`~.hipblasFillMode_t`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        alpha (`~.hipblasDoubleComplex`/`~.object`):
            (undocumented)

        x (`~.hipblasDoubleComplex`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        stridex (`~.int`):
            (undocumented)

        AP (`~.hipblasDoubleComplex`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        strideA (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")
    _hipblasZsyrStridedBatched__retval = hipblasStatus_t(chipblas.hipblasZsyrStridedBatched(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,uplo.value,n,
        hipblasDoubleComplex.fromPyobj(alpha).getElementPtr(),
        hipblasDoubleComplex.fromPyobj(x).getElementPtr(),incx,stridex,
        hipblasDoubleComplex.fromPyobj(AP).getElementPtr(),lda,strideA,batchCount))
    return (_hipblasZsyrStridedBatched__retval,)


@cython.embedsignature(True)
def hipblasCsyrStridedBatched_v2(object handle, object uplo, int n, object alpha, object x, int incx, long stridex, object AP, int lda, long strideA, int batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        uplo (`~.hipblasFillMode_t`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        alpha (`~.float2`/`~.object`):
            (undocumented)

        x (`~.float2`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        stridex (`~.int`):
            (undocumented)

        AP (`~.float2`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        strideA (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")
    _hipblasCsyrStridedBatched_v2__retval = hipblasStatus_t(chipblas.hipblasCsyrStridedBatched_v2(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,uplo.value,n,
        float2.fromPyobj(alpha).getElementPtr(),
        float2.fromPyobj(x).getElementPtr(),incx,stridex,
        float2.fromPyobj(AP).getElementPtr(),lda,strideA,batchCount))
    return (_hipblasCsyrStridedBatched_v2__retval,)


@cython.embedsignature(True)
def hipblasZsyrStridedBatched_v2(object handle, object uplo, int n, object alpha, object x, int incx, long stridex, object AP, int lda, long strideA, int batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        uplo (`~.hipblasFillMode_t`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        alpha (`~.double2`/`~.object`):
            (undocumented)

        x (`~.double2`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        stridex (`~.int`):
            (undocumented)

        AP (`~.double2`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        strideA (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")
    _hipblasZsyrStridedBatched_v2__retval = hipblasStatus_t(chipblas.hipblasZsyrStridedBatched_v2(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,uplo.value,n,
        double2.fromPyobj(alpha).getElementPtr(),
        double2.fromPyobj(x).getElementPtr(),incx,stridex,
        double2.fromPyobj(AP).getElementPtr(),lda,strideA,batchCount))
    return (_hipblasZsyrStridedBatched_v2__retval,)


@cython.embedsignature(True)
def hipblasSsyrStridedBatched_64(object handle, object uplo, long n, object alpha, object x, long incx, long stridex, object AP, long lda, long strideA, long batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        uplo (`~.hipblasFillMode_t`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        alpha (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        x (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        stridex (`~.int`):
            (undocumented)

        AP (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        strideA (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")
    _hipblasSsyrStridedBatched_64__retval = hipblasStatus_t(chipblas.hipblasSsyrStridedBatched_64(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,uplo.value,n,
        <const float *>hip._util.types.Pointer.fromPyobj(alpha)._ptr,
        <const float *>hip._util.types.Pointer.fromPyobj(x)._ptr,incx,stridex,
        <float *>hip._util.types.Pointer.fromPyobj(AP)._ptr,lda,strideA,batchCount))
    return (_hipblasSsyrStridedBatched_64__retval,)


@cython.embedsignature(True)
def hipblasDsyrStridedBatched_64(object handle, object uplo, long n, object alpha, object x, long incx, long stridex, object AP, long lda, long strideA, long batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        uplo (`~.hipblasFillMode_t`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        alpha (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        x (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        stridex (`~.int`):
            (undocumented)

        AP (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        strideA (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")
    _hipblasDsyrStridedBatched_64__retval = hipblasStatus_t(chipblas.hipblasDsyrStridedBatched_64(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,uplo.value,n,
        <const double *>hip._util.types.Pointer.fromPyobj(alpha)._ptr,
        <const double *>hip._util.types.Pointer.fromPyobj(x)._ptr,incx,stridex,
        <double *>hip._util.types.Pointer.fromPyobj(AP)._ptr,lda,strideA,batchCount))
    return (_hipblasDsyrStridedBatched_64__retval,)


@cython.embedsignature(True)
def hipblasCsyrStridedBatched_64(object handle, object uplo, long n, object alpha, object x, long incx, long stridex, object AP, long lda, long strideA, long batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        uplo (`~.hipblasFillMode_t`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        alpha (`~.hipblasComplex`/`~.object`):
            (undocumented)

        x (`~.hipblasComplex`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        stridex (`~.int`):
            (undocumented)

        AP (`~.hipblasComplex`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        strideA (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")
    _hipblasCsyrStridedBatched_64__retval = hipblasStatus_t(chipblas.hipblasCsyrStridedBatched_64(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,uplo.value,n,
        hipblasComplex.fromPyobj(alpha).getElementPtr(),
        hipblasComplex.fromPyobj(x).getElementPtr(),incx,stridex,
        hipblasComplex.fromPyobj(AP).getElementPtr(),lda,strideA,batchCount))
    return (_hipblasCsyrStridedBatched_64__retval,)


@cython.embedsignature(True)
def hipblasZsyrStridedBatched_64(object handle, object uplo, long n, object alpha, object x, long incx, long stridex, object AP, long lda, long strideA, long batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        uplo (`~.hipblasFillMode_t`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        alpha (`~.hipblasDoubleComplex`/`~.object`):
            (undocumented)

        x (`~.hipblasDoubleComplex`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        stridex (`~.int`):
            (undocumented)

        AP (`~.hipblasDoubleComplex`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        strideA (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")
    _hipblasZsyrStridedBatched_64__retval = hipblasStatus_t(chipblas.hipblasZsyrStridedBatched_64(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,uplo.value,n,
        hipblasDoubleComplex.fromPyobj(alpha).getElementPtr(),
        hipblasDoubleComplex.fromPyobj(x).getElementPtr(),incx,stridex,
        hipblasDoubleComplex.fromPyobj(AP).getElementPtr(),lda,strideA,batchCount))
    return (_hipblasZsyrStridedBatched_64__retval,)


@cython.embedsignature(True)
def hipblasCsyrStridedBatched_v2_64(object handle, object uplo, long n, object alpha, object x, long incx, long stridex, object AP, long lda, long strideA, long batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        uplo (`~.hipblasFillMode_t`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        alpha (`~.float2`/`~.object`):
            (undocumented)

        x (`~.float2`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        stridex (`~.int`):
            (undocumented)

        AP (`~.float2`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        strideA (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")
    _hipblasCsyrStridedBatched_v2_64__retval = hipblasStatus_t(chipblas.hipblasCsyrStridedBatched_v2_64(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,uplo.value,n,
        float2.fromPyobj(alpha).getElementPtr(),
        float2.fromPyobj(x).getElementPtr(),incx,stridex,
        float2.fromPyobj(AP).getElementPtr(),lda,strideA,batchCount))
    return (_hipblasCsyrStridedBatched_v2_64__retval,)


@cython.embedsignature(True)
def hipblasZsyrStridedBatched_v2_64(object handle, object uplo, long n, object alpha, object x, long incx, long stridex, object AP, long lda, long strideA, long batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        uplo (`~.hipblasFillMode_t`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        alpha (`~.double2`/`~.object`):
            (undocumented)

        x (`~.double2`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        stridex (`~.int`):
            (undocumented)

        AP (`~.double2`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        strideA (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")
    _hipblasZsyrStridedBatched_v2_64__retval = hipblasStatus_t(chipblas.hipblasZsyrStridedBatched_v2_64(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,uplo.value,n,
        double2.fromPyobj(alpha).getElementPtr(),
        double2.fromPyobj(x).getElementPtr(),incx,stridex,
        double2.fromPyobj(AP).getElementPtr(),lda,strideA,batchCount))
    return (_hipblasZsyrStridedBatched_v2_64__retval,)


@cython.embedsignature(True)
def hipblasSsyr2(object handle, object uplo, int n, object alpha, object x, int incx, object y, int incy, object AP, int lda):
    r"""BLAS Level 2 API

    @{

    syr2 performs the matrix-vector operations

    A := A + alpha*x*y**T + alpha*y*x**T

    where alpha is a scalar, x and y are vectors, and A is an
    n by n symmetric matrix.

    - Supported precisions in rocBLAS : s,d,c,z
    - Supported precisions in cuBLAS  : No support

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`) -- *IN*:
            [hipblasHandle_t]
            handle to the hipblas library context queue.

        uplo (`~.hipblasFillMode_t`) -- *IN*:
            [hipblasFillMode_t]
            specifies whether the upper 'HIPBLAS_FILL_MODE_UPPER' or lower 'HIPBLAS_FILL_MODE_LOWER'
            if HIPBLAS_FILL_MODE_UPPER, the lower part of A is not referenced
            if HIPBLAS_FILL_MODE_LOWER, the upper part of A is not referenced

        n (`~.int`) -- *IN*:
            [int]
            the number of rows and columns of matrix A.

        alpha (`~.hip._util.types.Pointer`/`~.object`) -- *IN*:
            device pointer or host pointer to scalar alpha.

        x (`~.hip._util.types.Pointer`/`~.object`) -- *IN*:
            device pointer storing vector x.

        incx (`~.int`) -- *IN*:
            [int]
            specifies the increment for the elements of x.

        y (`~.hip._util.types.Pointer`/`~.object`) -- *IN*:
            device pointer storing vector y.

        incy (`~.int`) -- *IN*:
            [int]
            specifies the increment for the elements of y.

        AP (`~.hip._util.types.Pointer`/`~.object`) -- *INOUT*:
            device pointer storing matrix A.

        lda (`~.int`) -- *IN*:
            [int]
            specifies the leading dimension of A.
    """
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")
    _hipblasSsyr2__retval = hipblasStatus_t(chipblas.hipblasSsyr2(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,uplo.value,n,
        <const float *>hip._util.types.Pointer.fromPyobj(alpha)._ptr,
        <const float *>hip._util.types.Pointer.fromPyobj(x)._ptr,incx,
        <const float *>hip._util.types.Pointer.fromPyobj(y)._ptr,incy,
        <float *>hip._util.types.Pointer.fromPyobj(AP)._ptr,lda))
    return (_hipblasSsyr2__retval,)


@cython.embedsignature(True)
def hipblasDsyr2(object handle, object uplo, int n, object alpha, object x, int incx, object y, int incy, object AP, int lda):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        uplo (`~.hipblasFillMode_t`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        alpha (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        x (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        y (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        incy (`~.int`):
            (undocumented)

        AP (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)
    """
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")
    _hipblasDsyr2__retval = hipblasStatus_t(chipblas.hipblasDsyr2(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,uplo.value,n,
        <const double *>hip._util.types.Pointer.fromPyobj(alpha)._ptr,
        <const double *>hip._util.types.Pointer.fromPyobj(x)._ptr,incx,
        <const double *>hip._util.types.Pointer.fromPyobj(y)._ptr,incy,
        <double *>hip._util.types.Pointer.fromPyobj(AP)._ptr,lda))
    return (_hipblasDsyr2__retval,)


@cython.embedsignature(True)
def hipblasCsyr2(object handle, object uplo, int n, object alpha, object x, int incx, object y, int incy, object AP, int lda):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        uplo (`~.hipblasFillMode_t`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        alpha (`~.hipblasComplex`/`~.object`):
            (undocumented)

        x (`~.hipblasComplex`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        y (`~.hipblasComplex`/`~.object`):
            (undocumented)

        incy (`~.int`):
            (undocumented)

        AP (`~.hipblasComplex`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)
    """
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")
    _hipblasCsyr2__retval = hipblasStatus_t(chipblas.hipblasCsyr2(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,uplo.value,n,
        hipblasComplex.fromPyobj(alpha).getElementPtr(),
        hipblasComplex.fromPyobj(x).getElementPtr(),incx,
        hipblasComplex.fromPyobj(y).getElementPtr(),incy,
        hipblasComplex.fromPyobj(AP).getElementPtr(),lda))
    return (_hipblasCsyr2__retval,)


@cython.embedsignature(True)
def hipblasZsyr2(object handle, object uplo, int n, object alpha, object x, int incx, object y, int incy, object AP, int lda):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        uplo (`~.hipblasFillMode_t`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        alpha (`~.hipblasDoubleComplex`/`~.object`):
            (undocumented)

        x (`~.hipblasDoubleComplex`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        y (`~.hipblasDoubleComplex`/`~.object`):
            (undocumented)

        incy (`~.int`):
            (undocumented)

        AP (`~.hipblasDoubleComplex`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)
    """
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")
    _hipblasZsyr2__retval = hipblasStatus_t(chipblas.hipblasZsyr2(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,uplo.value,n,
        hipblasDoubleComplex.fromPyobj(alpha).getElementPtr(),
        hipblasDoubleComplex.fromPyobj(x).getElementPtr(),incx,
        hipblasDoubleComplex.fromPyobj(y).getElementPtr(),incy,
        hipblasDoubleComplex.fromPyobj(AP).getElementPtr(),lda))
    return (_hipblasZsyr2__retval,)


@cython.embedsignature(True)
def hipblasCsyr2_v2(object handle, object uplo, int n, object alpha, object x, int incx, object y, int incy, object AP, int lda):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        uplo (`~.hipblasFillMode_t`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        alpha (`~.float2`/`~.object`):
            (undocumented)

        x (`~.float2`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        y (`~.float2`/`~.object`):
            (undocumented)

        incy (`~.int`):
            (undocumented)

        AP (`~.float2`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)
    """
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")
    _hipblasCsyr2_v2__retval = hipblasStatus_t(chipblas.hipblasCsyr2_v2(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,uplo.value,n,
        float2.fromPyobj(alpha).getElementPtr(),
        float2.fromPyobj(x).getElementPtr(),incx,
        float2.fromPyobj(y).getElementPtr(),incy,
        float2.fromPyobj(AP).getElementPtr(),lda))
    return (_hipblasCsyr2_v2__retval,)


@cython.embedsignature(True)
def hipblasZsyr2_v2(object handle, object uplo, int n, object alpha, object x, int incx, object y, int incy, object AP, int lda):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        uplo (`~.hipblasFillMode_t`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        alpha (`~.double2`/`~.object`):
            (undocumented)

        x (`~.double2`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        y (`~.double2`/`~.object`):
            (undocumented)

        incy (`~.int`):
            (undocumented)

        AP (`~.double2`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)
    """
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")
    _hipblasZsyr2_v2__retval = hipblasStatus_t(chipblas.hipblasZsyr2_v2(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,uplo.value,n,
        double2.fromPyobj(alpha).getElementPtr(),
        double2.fromPyobj(x).getElementPtr(),incx,
        double2.fromPyobj(y).getElementPtr(),incy,
        double2.fromPyobj(AP).getElementPtr(),lda))
    return (_hipblasZsyr2_v2__retval,)


@cython.embedsignature(True)
def hipblasSsyr2_64(object handle, object uplo, long n, object alpha, object x, long incx, object y, long incy, object AP, long lda):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        uplo (`~.hipblasFillMode_t`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        alpha (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        x (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        y (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        incy (`~.int`):
            (undocumented)

        AP (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)
    """
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")
    _hipblasSsyr2_64__retval = hipblasStatus_t(chipblas.hipblasSsyr2_64(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,uplo.value,n,
        <const float *>hip._util.types.Pointer.fromPyobj(alpha)._ptr,
        <const float *>hip._util.types.Pointer.fromPyobj(x)._ptr,incx,
        <const float *>hip._util.types.Pointer.fromPyobj(y)._ptr,incy,
        <float *>hip._util.types.Pointer.fromPyobj(AP)._ptr,lda))
    return (_hipblasSsyr2_64__retval,)


@cython.embedsignature(True)
def hipblasDsyr2_64(object handle, object uplo, long n, object alpha, object x, long incx, object y, long incy, object AP, long lda):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        uplo (`~.hipblasFillMode_t`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        alpha (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        x (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        y (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        incy (`~.int`):
            (undocumented)

        AP (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)
    """
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")
    _hipblasDsyr2_64__retval = hipblasStatus_t(chipblas.hipblasDsyr2_64(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,uplo.value,n,
        <const double *>hip._util.types.Pointer.fromPyobj(alpha)._ptr,
        <const double *>hip._util.types.Pointer.fromPyobj(x)._ptr,incx,
        <const double *>hip._util.types.Pointer.fromPyobj(y)._ptr,incy,
        <double *>hip._util.types.Pointer.fromPyobj(AP)._ptr,lda))
    return (_hipblasDsyr2_64__retval,)


@cython.embedsignature(True)
def hipblasCsyr2_64(object handle, object uplo, long n, object alpha, object x, long incx, object y, long incy, object AP, long lda):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        uplo (`~.hipblasFillMode_t`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        alpha (`~.hipblasComplex`/`~.object`):
            (undocumented)

        x (`~.hipblasComplex`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        y (`~.hipblasComplex`/`~.object`):
            (undocumented)

        incy (`~.int`):
            (undocumented)

        AP (`~.hipblasComplex`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)
    """
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")
    _hipblasCsyr2_64__retval = hipblasStatus_t(chipblas.hipblasCsyr2_64(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,uplo.value,n,
        hipblasComplex.fromPyobj(alpha).getElementPtr(),
        hipblasComplex.fromPyobj(x).getElementPtr(),incx,
        hipblasComplex.fromPyobj(y).getElementPtr(),incy,
        hipblasComplex.fromPyobj(AP).getElementPtr(),lda))
    return (_hipblasCsyr2_64__retval,)


@cython.embedsignature(True)
def hipblasZsyr2_64(object handle, object uplo, long n, object alpha, object x, long incx, object y, long incy, object AP, long lda):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        uplo (`~.hipblasFillMode_t`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        alpha (`~.hipblasDoubleComplex`/`~.object`):
            (undocumented)

        x (`~.hipblasDoubleComplex`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        y (`~.hipblasDoubleComplex`/`~.object`):
            (undocumented)

        incy (`~.int`):
            (undocumented)

        AP (`~.hipblasDoubleComplex`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)
    """
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")
    _hipblasZsyr2_64__retval = hipblasStatus_t(chipblas.hipblasZsyr2_64(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,uplo.value,n,
        hipblasDoubleComplex.fromPyobj(alpha).getElementPtr(),
        hipblasDoubleComplex.fromPyobj(x).getElementPtr(),incx,
        hipblasDoubleComplex.fromPyobj(y).getElementPtr(),incy,
        hipblasDoubleComplex.fromPyobj(AP).getElementPtr(),lda))
    return (_hipblasZsyr2_64__retval,)


@cython.embedsignature(True)
def hipblasCsyr2_v2_64(object handle, object uplo, long n, object alpha, object x, long incx, object y, long incy, object AP, long lda):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        uplo (`~.hipblasFillMode_t`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        alpha (`~.float2`/`~.object`):
            (undocumented)

        x (`~.float2`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        y (`~.float2`/`~.object`):
            (undocumented)

        incy (`~.int`):
            (undocumented)

        AP (`~.float2`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)
    """
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")
    _hipblasCsyr2_v2_64__retval = hipblasStatus_t(chipblas.hipblasCsyr2_v2_64(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,uplo.value,n,
        float2.fromPyobj(alpha).getElementPtr(),
        float2.fromPyobj(x).getElementPtr(),incx,
        float2.fromPyobj(y).getElementPtr(),incy,
        float2.fromPyobj(AP).getElementPtr(),lda))
    return (_hipblasCsyr2_v2_64__retval,)


@cython.embedsignature(True)
def hipblasZsyr2_v2_64(object handle, object uplo, long n, object alpha, object x, long incx, object y, long incy, object AP, long lda):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        uplo (`~.hipblasFillMode_t`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        alpha (`~.double2`/`~.object`):
            (undocumented)

        x (`~.double2`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        y (`~.double2`/`~.object`):
            (undocumented)

        incy (`~.int`):
            (undocumented)

        AP (`~.double2`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)
    """
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")
    _hipblasZsyr2_v2_64__retval = hipblasStatus_t(chipblas.hipblasZsyr2_v2_64(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,uplo.value,n,
        double2.fromPyobj(alpha).getElementPtr(),
        double2.fromPyobj(x).getElementPtr(),incx,
        double2.fromPyobj(y).getElementPtr(),incy,
        double2.fromPyobj(AP).getElementPtr(),lda))
    return (_hipblasZsyr2_v2_64__retval,)


@cython.embedsignature(True)
def hipblasSsyr2Batched(object handle, object uplo, int n, object alpha, object x, int incx, object y, int incy, object AP, int lda, int batchCount):
    r"""BLAS Level 2 API

    @{

    syr2Batched performs a batch of matrix-vector operations

    A[i] := A[i] + alpha*x[i]*y[i]**T + alpha*y[i]*x[i]**T

    where alpha is a scalar, x[i] and y[i] are vectors, and A[i] is a
    n by n symmetric matrix, for i = 1 , ... , batchCount.

    - Supported precisions in rocBLAS : s,d,c,z
    - Supported precisions in cuBLAS  : No support

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`) -- *IN*:
            [hipblasHandle_t]
            handle to the hipblas library context queue.

        uplo (`~.hipblasFillMode_t`) -- *IN*:
            [hipblasFillMode_t]
            specifies whether the upper 'HIPBLAS_FILL_MODE_UPPER' or lower 'HIPBLAS_FILL_MODE_LOWER'
            if HIPBLAS_FILL_MODE_UPPER, the lower part of A is not referenced
            if HIPBLAS_FILL_MODE_LOWER, the upper part of A is not referenced

        n (`~.int`) -- *IN*:
            [int]
            the number of rows and columns of matrix A.

        alpha (`~.hip._util.types.Pointer`/`~.object`) -- *IN*:
            device pointer or host pointer to scalar alpha.

        x (`~.hip._util.types.ListOfPointer`/`~.object`) -- *IN*:
            device array of device pointers storing each vector x_i.

        incx (`~.int`) -- *IN*:
            [int]
            specifies the increment for the elements of each x_i.

        y (`~.hip._util.types.ListOfPointer`/`~.object`) -- *IN*:
            device array of device pointers storing each vector y_i.

        incy (`~.int`) -- *IN*:
            [int]
            specifies the increment for the elements of each y_i.

        AP (`~.hip._util.types.Pointer`/`~.object`) -- *INOUT*:
            device array of device pointers storing each matrix A_i.

        lda (`~.int`) -- *IN*:
            [int]
            specifies the leading dimension of each A_i.

        batchCount (`~.int`) -- *IN*:
            [int]
            number of instances in the batch
    """
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")
    _hipblasSsyr2Batched__retval = hipblasStatus_t(chipblas.hipblasSsyr2Batched(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,uplo.value,n,
        <const float *>hip._util.types.Pointer.fromPyobj(alpha)._ptr,
        <const float *const*>hip._util.types.ListOfPointer.fromPyobj(x)._ptr,incx,
        <const float *const*>hip._util.types.ListOfPointer.fromPyobj(y)._ptr,incy,
        <float *const*>hip._util.types.Pointer.fromPyobj(AP)._ptr,lda,batchCount))
    return (_hipblasSsyr2Batched__retval,)


@cython.embedsignature(True)
def hipblasDsyr2Batched(object handle, object uplo, int n, object alpha, object x, int incx, object y, int incy, object AP, int lda, int batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        uplo (`~.hipblasFillMode_t`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        alpha (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        x (`~.hip._util.types.ListOfPointer`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        y (`~.hip._util.types.ListOfPointer`/`~.object`):
            (undocumented)

        incy (`~.int`):
            (undocumented)

        AP (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")
    _hipblasDsyr2Batched__retval = hipblasStatus_t(chipblas.hipblasDsyr2Batched(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,uplo.value,n,
        <const double *>hip._util.types.Pointer.fromPyobj(alpha)._ptr,
        <const double *const*>hip._util.types.ListOfPointer.fromPyobj(x)._ptr,incx,
        <const double *const*>hip._util.types.ListOfPointer.fromPyobj(y)._ptr,incy,
        <double *const*>hip._util.types.Pointer.fromPyobj(AP)._ptr,lda,batchCount))
    return (_hipblasDsyr2Batched__retval,)


@cython.embedsignature(True)
def hipblasCsyr2Batched(object handle, object uplo, int n, object alpha, object x, int incx, object y, int incy, object AP, int lda, int batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        uplo (`~.hipblasFillMode_t`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        alpha (`~.hipblasComplex`/`~.object`):
            (undocumented)

        x (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        y (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        incy (`~.int`):
            (undocumented)

        AP (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")
    _hipblasCsyr2Batched__retval = hipblasStatus_t(chipblas.hipblasCsyr2Batched(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,uplo.value,n,
        hipblasComplex.fromPyobj(alpha).getElementPtr(),
        <chipblas.hipblasComplex *const*>hip._util.types.Pointer.fromPyobj(x)._ptr,incx,
        <chipblas.hipblasComplex *const*>hip._util.types.Pointer.fromPyobj(y)._ptr,incy,
        <chipblas.hipblasComplex *const*>hip._util.types.Pointer.fromPyobj(AP)._ptr,lda,batchCount))
    return (_hipblasCsyr2Batched__retval,)


@cython.embedsignature(True)
def hipblasZsyr2Batched(object handle, object uplo, int n, object alpha, object x, int incx, object y, int incy, object AP, int lda, int batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        uplo (`~.hipblasFillMode_t`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        alpha (`~.hipblasDoubleComplex`/`~.object`):
            (undocumented)

        x (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        y (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        incy (`~.int`):
            (undocumented)

        AP (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")
    _hipblasZsyr2Batched__retval = hipblasStatus_t(chipblas.hipblasZsyr2Batched(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,uplo.value,n,
        hipblasDoubleComplex.fromPyobj(alpha).getElementPtr(),
        <chipblas.hipblasDoubleComplex *const*>hip._util.types.Pointer.fromPyobj(x)._ptr,incx,
        <chipblas.hipblasDoubleComplex *const*>hip._util.types.Pointer.fromPyobj(y)._ptr,incy,
        <chipblas.hipblasDoubleComplex *const*>hip._util.types.Pointer.fromPyobj(AP)._ptr,lda,batchCount))
    return (_hipblasZsyr2Batched__retval,)


@cython.embedsignature(True)
def hipblasCsyr2Batched_v2(object handle, object uplo, int n, object alpha, object x, int incx, object y, int incy, object AP, int lda, int batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        uplo (`~.hipblasFillMode_t`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        alpha (`~.float2`/`~.object`):
            (undocumented)

        x (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        y (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        incy (`~.int`):
            (undocumented)

        AP (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")
    _hipblasCsyr2Batched_v2__retval = hipblasStatus_t(chipblas.hipblasCsyr2Batched_v2(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,uplo.value,n,
        float2.fromPyobj(alpha).getElementPtr(),
        <chipblas.float2 *const*>hip._util.types.Pointer.fromPyobj(x)._ptr,incx,
        <chipblas.float2 *const*>hip._util.types.Pointer.fromPyobj(y)._ptr,incy,
        <chipblas.float2 *const*>hip._util.types.Pointer.fromPyobj(AP)._ptr,lda,batchCount))
    return (_hipblasCsyr2Batched_v2__retval,)


@cython.embedsignature(True)
def hipblasZsyr2Batched_v2(object handle, object uplo, int n, object alpha, object x, int incx, object y, int incy, object AP, int lda, int batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        uplo (`~.hipblasFillMode_t`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        alpha (`~.double2`/`~.object`):
            (undocumented)

        x (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        y (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        incy (`~.int`):
            (undocumented)

        AP (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")
    _hipblasZsyr2Batched_v2__retval = hipblasStatus_t(chipblas.hipblasZsyr2Batched_v2(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,uplo.value,n,
        double2.fromPyobj(alpha).getElementPtr(),
        <chipblas.double2 *const*>hip._util.types.Pointer.fromPyobj(x)._ptr,incx,
        <chipblas.double2 *const*>hip._util.types.Pointer.fromPyobj(y)._ptr,incy,
        <chipblas.double2 *const*>hip._util.types.Pointer.fromPyobj(AP)._ptr,lda,batchCount))
    return (_hipblasZsyr2Batched_v2__retval,)


@cython.embedsignature(True)
def hipblasSsyr2Batched_64(object handle, object uplo, long n, object alpha, object x, long incx, object y, long incy, object AP, long lda, long batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        uplo (`~.hipblasFillMode_t`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        alpha (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        x (`~.hip._util.types.ListOfPointer`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        y (`~.hip._util.types.ListOfPointer`/`~.object`):
            (undocumented)

        incy (`~.int`):
            (undocumented)

        AP (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")
    _hipblasSsyr2Batched_64__retval = hipblasStatus_t(chipblas.hipblasSsyr2Batched_64(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,uplo.value,n,
        <const float *>hip._util.types.Pointer.fromPyobj(alpha)._ptr,
        <const float *const*>hip._util.types.ListOfPointer.fromPyobj(x)._ptr,incx,
        <const float *const*>hip._util.types.ListOfPointer.fromPyobj(y)._ptr,incy,
        <float *const*>hip._util.types.Pointer.fromPyobj(AP)._ptr,lda,batchCount))
    return (_hipblasSsyr2Batched_64__retval,)


@cython.embedsignature(True)
def hipblasDsyr2Batched_64(object handle, object uplo, long n, object alpha, object x, long incx, object y, long incy, object AP, long lda, long batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        uplo (`~.hipblasFillMode_t`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        alpha (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        x (`~.hip._util.types.ListOfPointer`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        y (`~.hip._util.types.ListOfPointer`/`~.object`):
            (undocumented)

        incy (`~.int`):
            (undocumented)

        AP (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")
    _hipblasDsyr2Batched_64__retval = hipblasStatus_t(chipblas.hipblasDsyr2Batched_64(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,uplo.value,n,
        <const double *>hip._util.types.Pointer.fromPyobj(alpha)._ptr,
        <const double *const*>hip._util.types.ListOfPointer.fromPyobj(x)._ptr,incx,
        <const double *const*>hip._util.types.ListOfPointer.fromPyobj(y)._ptr,incy,
        <double *const*>hip._util.types.Pointer.fromPyobj(AP)._ptr,lda,batchCount))
    return (_hipblasDsyr2Batched_64__retval,)


@cython.embedsignature(True)
def hipblasCsyr2Batched_64(object handle, object uplo, long n, object alpha, object x, long incx, object y, long incy, object AP, long lda, long batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        uplo (`~.hipblasFillMode_t`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        alpha (`~.hipblasComplex`/`~.object`):
            (undocumented)

        x (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        y (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        incy (`~.int`):
            (undocumented)

        AP (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")
    _hipblasCsyr2Batched_64__retval = hipblasStatus_t(chipblas.hipblasCsyr2Batched_64(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,uplo.value,n,
        hipblasComplex.fromPyobj(alpha).getElementPtr(),
        <chipblas.hipblasComplex *const*>hip._util.types.Pointer.fromPyobj(x)._ptr,incx,
        <chipblas.hipblasComplex *const*>hip._util.types.Pointer.fromPyobj(y)._ptr,incy,
        <chipblas.hipblasComplex *const*>hip._util.types.Pointer.fromPyobj(AP)._ptr,lda,batchCount))
    return (_hipblasCsyr2Batched_64__retval,)


@cython.embedsignature(True)
def hipblasZsyr2Batched_64(object handle, object uplo, long n, object alpha, object x, long incx, object y, long incy, object AP, long lda, long batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        uplo (`~.hipblasFillMode_t`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        alpha (`~.hipblasDoubleComplex`/`~.object`):
            (undocumented)

        x (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        y (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        incy (`~.int`):
            (undocumented)

        AP (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")
    _hipblasZsyr2Batched_64__retval = hipblasStatus_t(chipblas.hipblasZsyr2Batched_64(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,uplo.value,n,
        hipblasDoubleComplex.fromPyobj(alpha).getElementPtr(),
        <chipblas.hipblasDoubleComplex *const*>hip._util.types.Pointer.fromPyobj(x)._ptr,incx,
        <chipblas.hipblasDoubleComplex *const*>hip._util.types.Pointer.fromPyobj(y)._ptr,incy,
        <chipblas.hipblasDoubleComplex *const*>hip._util.types.Pointer.fromPyobj(AP)._ptr,lda,batchCount))
    return (_hipblasZsyr2Batched_64__retval,)


@cython.embedsignature(True)
def hipblasCsyr2Batched_v2_64(object handle, object uplo, long n, object alpha, object x, long incx, object y, long incy, object AP, long lda, long batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        uplo (`~.hipblasFillMode_t`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        alpha (`~.float2`/`~.object`):
            (undocumented)

        x (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        y (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        incy (`~.int`):
            (undocumented)

        AP (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")
    _hipblasCsyr2Batched_v2_64__retval = hipblasStatus_t(chipblas.hipblasCsyr2Batched_v2_64(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,uplo.value,n,
        float2.fromPyobj(alpha).getElementPtr(),
        <chipblas.float2 *const*>hip._util.types.Pointer.fromPyobj(x)._ptr,incx,
        <chipblas.float2 *const*>hip._util.types.Pointer.fromPyobj(y)._ptr,incy,
        <chipblas.float2 *const*>hip._util.types.Pointer.fromPyobj(AP)._ptr,lda,batchCount))
    return (_hipblasCsyr2Batched_v2_64__retval,)


@cython.embedsignature(True)
def hipblasZsyr2Batched_v2_64(object handle, object uplo, long n, object alpha, object x, long incx, object y, long incy, object AP, long lda, long batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        uplo (`~.hipblasFillMode_t`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        alpha (`~.double2`/`~.object`):
            (undocumented)

        x (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        y (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        incy (`~.int`):
            (undocumented)

        AP (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")
    _hipblasZsyr2Batched_v2_64__retval = hipblasStatus_t(chipblas.hipblasZsyr2Batched_v2_64(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,uplo.value,n,
        double2.fromPyobj(alpha).getElementPtr(),
        <chipblas.double2 *const*>hip._util.types.Pointer.fromPyobj(x)._ptr,incx,
        <chipblas.double2 *const*>hip._util.types.Pointer.fromPyobj(y)._ptr,incy,
        <chipblas.double2 *const*>hip._util.types.Pointer.fromPyobj(AP)._ptr,lda,batchCount))
    return (_hipblasZsyr2Batched_v2_64__retval,)


@cython.embedsignature(True)
def hipblasSsyr2StridedBatched(object handle, object uplo, int n, object alpha, object x, int incx, long stridex, object y, int incy, long stridey, object AP, int lda, long strideA, int batchCount):
    r"""BLAS Level 2 API

    @{

    syr2StridedBatched the matrix-vector operations

    A[i] := A[i] + alpha*x[i]*y[i]**T + alpha*y[i]*x[i]**T

    where alpha is a scalar, x[i] and y[i] are vectors, and A[i] is a
    n by n symmetric matrices, for i = 1 , ... , batchCount.

    - Supported precisions in rocBLAS : s,d,c,z
    - Supported precisions in cuBLAS  : No support

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`) -- *IN*:
            [hipblasHandle_t]
            handle to the hipblas library context queue.

        uplo (`~.hipblasFillMode_t`) -- *IN*:
            [hipblasFillMode_t]
            specifies whether the upper 'HIPBLAS_FILL_MODE_UPPER' or lower 'HIPBLAS_FILL_MODE_LOWER'
            if HIPBLAS_FILL_MODE_UPPER, the lower part of A is not referenced
            if HIPBLAS_FILL_MODE_LOWER, the upper part of A is not referenced

        n (`~.int`) -- *IN*:
            [int]
            the number of rows and columns of each matrix A.

        alpha (`~.hip._util.types.Pointer`/`~.object`) -- *IN*:
            device pointer or host pointer to scalar alpha.

        x (`~.hip._util.types.Pointer`/`~.object`) -- *IN*:
            device pointer to the first vector x_1.

        incx (`~.int`) -- *IN*:
            [int]
            specifies the increment for the elements of each x_i.

        stridex (`~.int`) -- *IN*:
            [hipblasStride]
            specifies the pointer increment between vectors (x_i) and (x_i+1).

        y (`~.hip._util.types.Pointer`/`~.object`) -- *IN*:
            device pointer to the first vector y_1.

        incy (`~.int`) -- *IN*:
            [int]
            specifies the increment for the elements of each y_i.

        stridey (`~.int`) -- *IN*:
            [hipblasStride]
            specifies the pointer increment between vectors (y_i) and (y_i+1).

        AP (`~.hip._util.types.Pointer`/`~.object`) -- *INOUT*:
            device pointer to the first matrix A_1.

        lda (`~.int`) -- *IN*:
            [int]
            specifies the leading dimension of each A_i.

        strideA (`~.int`) -- *IN*:
            [hipblasStride]
            stride from the start of one matrix (A_i) and the next one (A_i+1)

        batchCount (`~.int`) -- *IN*:
            [int]
            number of instances in the batch
    """
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")
    _hipblasSsyr2StridedBatched__retval = hipblasStatus_t(chipblas.hipblasSsyr2StridedBatched(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,uplo.value,n,
        <const float *>hip._util.types.Pointer.fromPyobj(alpha)._ptr,
        <const float *>hip._util.types.Pointer.fromPyobj(x)._ptr,incx,stridex,
        <const float *>hip._util.types.Pointer.fromPyobj(y)._ptr,incy,stridey,
        <float *>hip._util.types.Pointer.fromPyobj(AP)._ptr,lda,strideA,batchCount))
    return (_hipblasSsyr2StridedBatched__retval,)


@cython.embedsignature(True)
def hipblasDsyr2StridedBatched(object handle, object uplo, int n, object alpha, object x, int incx, long stridex, object y, int incy, long stridey, object AP, int lda, long strideA, int batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        uplo (`~.hipblasFillMode_t`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        alpha (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        x (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        stridex (`~.int`):
            (undocumented)

        y (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        incy (`~.int`):
            (undocumented)

        stridey (`~.int`):
            (undocumented)

        AP (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        strideA (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")
    _hipblasDsyr2StridedBatched__retval = hipblasStatus_t(chipblas.hipblasDsyr2StridedBatched(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,uplo.value,n,
        <const double *>hip._util.types.Pointer.fromPyobj(alpha)._ptr,
        <const double *>hip._util.types.Pointer.fromPyobj(x)._ptr,incx,stridex,
        <const double *>hip._util.types.Pointer.fromPyobj(y)._ptr,incy,stridey,
        <double *>hip._util.types.Pointer.fromPyobj(AP)._ptr,lda,strideA,batchCount))
    return (_hipblasDsyr2StridedBatched__retval,)


@cython.embedsignature(True)
def hipblasCsyr2StridedBatched(object handle, object uplo, int n, object alpha, object x, int incx, long stridex, object y, int incy, long stridey, object AP, int lda, long strideA, int batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        uplo (`~.hipblasFillMode_t`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        alpha (`~.hipblasComplex`/`~.object`):
            (undocumented)

        x (`~.hipblasComplex`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        stridex (`~.int`):
            (undocumented)

        y (`~.hipblasComplex`/`~.object`):
            (undocumented)

        incy (`~.int`):
            (undocumented)

        stridey (`~.int`):
            (undocumented)

        AP (`~.hipblasComplex`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        strideA (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")
    _hipblasCsyr2StridedBatched__retval = hipblasStatus_t(chipblas.hipblasCsyr2StridedBatched(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,uplo.value,n,
        hipblasComplex.fromPyobj(alpha).getElementPtr(),
        hipblasComplex.fromPyobj(x).getElementPtr(),incx,stridex,
        hipblasComplex.fromPyobj(y).getElementPtr(),incy,stridey,
        hipblasComplex.fromPyobj(AP).getElementPtr(),lda,strideA,batchCount))
    return (_hipblasCsyr2StridedBatched__retval,)


@cython.embedsignature(True)
def hipblasZsyr2StridedBatched(object handle, object uplo, int n, object alpha, object x, int incx, long stridex, object y, int incy, long stridey, object AP, int lda, long strideA, int batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        uplo (`~.hipblasFillMode_t`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        alpha (`~.hipblasDoubleComplex`/`~.object`):
            (undocumented)

        x (`~.hipblasDoubleComplex`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        stridex (`~.int`):
            (undocumented)

        y (`~.hipblasDoubleComplex`/`~.object`):
            (undocumented)

        incy (`~.int`):
            (undocumented)

        stridey (`~.int`):
            (undocumented)

        AP (`~.hipblasDoubleComplex`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        strideA (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")
    _hipblasZsyr2StridedBatched__retval = hipblasStatus_t(chipblas.hipblasZsyr2StridedBatched(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,uplo.value,n,
        hipblasDoubleComplex.fromPyobj(alpha).getElementPtr(),
        hipblasDoubleComplex.fromPyobj(x).getElementPtr(),incx,stridex,
        hipblasDoubleComplex.fromPyobj(y).getElementPtr(),incy,stridey,
        hipblasDoubleComplex.fromPyobj(AP).getElementPtr(),lda,strideA,batchCount))
    return (_hipblasZsyr2StridedBatched__retval,)


@cython.embedsignature(True)
def hipblasCsyr2StridedBatched_v2(object handle, object uplo, int n, object alpha, object x, int incx, long stridex, object y, int incy, long stridey, object AP, int lda, long strideA, int batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        uplo (`~.hipblasFillMode_t`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        alpha (`~.float2`/`~.object`):
            (undocumented)

        x (`~.float2`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        stridex (`~.int`):
            (undocumented)

        y (`~.float2`/`~.object`):
            (undocumented)

        incy (`~.int`):
            (undocumented)

        stridey (`~.int`):
            (undocumented)

        AP (`~.float2`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        strideA (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")
    _hipblasCsyr2StridedBatched_v2__retval = hipblasStatus_t(chipblas.hipblasCsyr2StridedBatched_v2(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,uplo.value,n,
        float2.fromPyobj(alpha).getElementPtr(),
        float2.fromPyobj(x).getElementPtr(),incx,stridex,
        float2.fromPyobj(y).getElementPtr(),incy,stridey,
        float2.fromPyobj(AP).getElementPtr(),lda,strideA,batchCount))
    return (_hipblasCsyr2StridedBatched_v2__retval,)


@cython.embedsignature(True)
def hipblasZsyr2StridedBatched_v2(object handle, object uplo, int n, object alpha, object x, int incx, long stridex, object y, int incy, long stridey, object AP, int lda, long strideA, int batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        uplo (`~.hipblasFillMode_t`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        alpha (`~.double2`/`~.object`):
            (undocumented)

        x (`~.double2`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        stridex (`~.int`):
            (undocumented)

        y (`~.double2`/`~.object`):
            (undocumented)

        incy (`~.int`):
            (undocumented)

        stridey (`~.int`):
            (undocumented)

        AP (`~.double2`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        strideA (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")
    _hipblasZsyr2StridedBatched_v2__retval = hipblasStatus_t(chipblas.hipblasZsyr2StridedBatched_v2(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,uplo.value,n,
        double2.fromPyobj(alpha).getElementPtr(),
        double2.fromPyobj(x).getElementPtr(),incx,stridex,
        double2.fromPyobj(y).getElementPtr(),incy,stridey,
        double2.fromPyobj(AP).getElementPtr(),lda,strideA,batchCount))
    return (_hipblasZsyr2StridedBatched_v2__retval,)


@cython.embedsignature(True)
def hipblasSsyr2StridedBatched_64(object handle, object uplo, long n, object alpha, object x, long incx, long stridex, object y, long incy, long stridey, object AP, long lda, long strideA, long batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        uplo (`~.hipblasFillMode_t`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        alpha (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        x (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        stridex (`~.int`):
            (undocumented)

        y (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        incy (`~.int`):
            (undocumented)

        stridey (`~.int`):
            (undocumented)

        AP (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        strideA (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")
    _hipblasSsyr2StridedBatched_64__retval = hipblasStatus_t(chipblas.hipblasSsyr2StridedBatched_64(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,uplo.value,n,
        <const float *>hip._util.types.Pointer.fromPyobj(alpha)._ptr,
        <const float *>hip._util.types.Pointer.fromPyobj(x)._ptr,incx,stridex,
        <const float *>hip._util.types.Pointer.fromPyobj(y)._ptr,incy,stridey,
        <float *>hip._util.types.Pointer.fromPyobj(AP)._ptr,lda,strideA,batchCount))
    return (_hipblasSsyr2StridedBatched_64__retval,)


@cython.embedsignature(True)
def hipblasDsyr2StridedBatched_64(object handle, object uplo, long n, object alpha, object x, long incx, long stridex, object y, long incy, long stridey, object AP, long lda, long strideA, long batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        uplo (`~.hipblasFillMode_t`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        alpha (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        x (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        stridex (`~.int`):
            (undocumented)

        y (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        incy (`~.int`):
            (undocumented)

        stridey (`~.int`):
            (undocumented)

        AP (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        strideA (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")
    _hipblasDsyr2StridedBatched_64__retval = hipblasStatus_t(chipblas.hipblasDsyr2StridedBatched_64(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,uplo.value,n,
        <const double *>hip._util.types.Pointer.fromPyobj(alpha)._ptr,
        <const double *>hip._util.types.Pointer.fromPyobj(x)._ptr,incx,stridex,
        <const double *>hip._util.types.Pointer.fromPyobj(y)._ptr,incy,stridey,
        <double *>hip._util.types.Pointer.fromPyobj(AP)._ptr,lda,strideA,batchCount))
    return (_hipblasDsyr2StridedBatched_64__retval,)


@cython.embedsignature(True)
def hipblasCsyr2StridedBatched_64(object handle, object uplo, long n, object alpha, object x, long incx, long stridex, object y, long incy, long stridey, object AP, long lda, long strideA, long batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        uplo (`~.hipblasFillMode_t`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        alpha (`~.hipblasComplex`/`~.object`):
            (undocumented)

        x (`~.hipblasComplex`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        stridex (`~.int`):
            (undocumented)

        y (`~.hipblasComplex`/`~.object`):
            (undocumented)

        incy (`~.int`):
            (undocumented)

        stridey (`~.int`):
            (undocumented)

        AP (`~.hipblasComplex`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        strideA (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")
    _hipblasCsyr2StridedBatched_64__retval = hipblasStatus_t(chipblas.hipblasCsyr2StridedBatched_64(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,uplo.value,n,
        hipblasComplex.fromPyobj(alpha).getElementPtr(),
        hipblasComplex.fromPyobj(x).getElementPtr(),incx,stridex,
        hipblasComplex.fromPyobj(y).getElementPtr(),incy,stridey,
        hipblasComplex.fromPyobj(AP).getElementPtr(),lda,strideA,batchCount))
    return (_hipblasCsyr2StridedBatched_64__retval,)


@cython.embedsignature(True)
def hipblasZsyr2StridedBatched_64(object handle, object uplo, long n, object alpha, object x, long incx, long stridex, object y, long incy, long stridey, object AP, long lda, long strideA, long batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        uplo (`~.hipblasFillMode_t`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        alpha (`~.hipblasDoubleComplex`/`~.object`):
            (undocumented)

        x (`~.hipblasDoubleComplex`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        stridex (`~.int`):
            (undocumented)

        y (`~.hipblasDoubleComplex`/`~.object`):
            (undocumented)

        incy (`~.int`):
            (undocumented)

        stridey (`~.int`):
            (undocumented)

        AP (`~.hipblasDoubleComplex`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        strideA (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")
    _hipblasZsyr2StridedBatched_64__retval = hipblasStatus_t(chipblas.hipblasZsyr2StridedBatched_64(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,uplo.value,n,
        hipblasDoubleComplex.fromPyobj(alpha).getElementPtr(),
        hipblasDoubleComplex.fromPyobj(x).getElementPtr(),incx,stridex,
        hipblasDoubleComplex.fromPyobj(y).getElementPtr(),incy,stridey,
        hipblasDoubleComplex.fromPyobj(AP).getElementPtr(),lda,strideA,batchCount))
    return (_hipblasZsyr2StridedBatched_64__retval,)


@cython.embedsignature(True)
def hipblasCsyr2StridedBatched_v2_64(object handle, object uplo, long n, object alpha, object x, long incx, long stridex, object y, long incy, long stridey, object AP, long lda, long strideA, long batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        uplo (`~.hipblasFillMode_t`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        alpha (`~.float2`/`~.object`):
            (undocumented)

        x (`~.float2`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        stridex (`~.int`):
            (undocumented)

        y (`~.float2`/`~.object`):
            (undocumented)

        incy (`~.int`):
            (undocumented)

        stridey (`~.int`):
            (undocumented)

        AP (`~.float2`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        strideA (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")
    _hipblasCsyr2StridedBatched_v2_64__retval = hipblasStatus_t(chipblas.hipblasCsyr2StridedBatched_v2_64(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,uplo.value,n,
        float2.fromPyobj(alpha).getElementPtr(),
        float2.fromPyobj(x).getElementPtr(),incx,stridex,
        float2.fromPyobj(y).getElementPtr(),incy,stridey,
        float2.fromPyobj(AP).getElementPtr(),lda,strideA,batchCount))
    return (_hipblasCsyr2StridedBatched_v2_64__retval,)


@cython.embedsignature(True)
def hipblasZsyr2StridedBatched_v2_64(object handle, object uplo, long n, object alpha, object x, long incx, long stridex, object y, long incy, long stridey, object AP, long lda, long strideA, long batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        uplo (`~.hipblasFillMode_t`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        alpha (`~.double2`/`~.object`):
            (undocumented)

        x (`~.double2`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        stridex (`~.int`):
            (undocumented)

        y (`~.double2`/`~.object`):
            (undocumented)

        incy (`~.int`):
            (undocumented)

        stridey (`~.int`):
            (undocumented)

        AP (`~.double2`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        strideA (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")
    _hipblasZsyr2StridedBatched_v2_64__retval = hipblasStatus_t(chipblas.hipblasZsyr2StridedBatched_v2_64(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,uplo.value,n,
        double2.fromPyobj(alpha).getElementPtr(),
        double2.fromPyobj(x).getElementPtr(),incx,stridex,
        double2.fromPyobj(y).getElementPtr(),incy,stridey,
        double2.fromPyobj(AP).getElementPtr(),lda,strideA,batchCount))
    return (_hipblasZsyr2StridedBatched_v2_64__retval,)


@cython.embedsignature(True)
def hipblasStbmv(object handle, object uplo, object transA, object diag, int n, int k, object AP, int lda, object x, int incx):
    r"""BLAS Level 2 API

    @{

    tbmv performs one of the matrix-vector operations

    x := A*x      or
        x := A**T*x   or
        x := A**H*x,

    x is a vectors and A is a banded n by n matrix (see description below).

    - Supported precisions in rocBLAS : s,d,c,z
    - Supported precisions in cuBLAS  : s,d,c,z

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`) -- *IN*:
            [hipblasHandle_t]
            handle to the hipblas library context queue.

        uplo (`~.hipblasFillMode_t`) -- *IN*:
            [hipblasFillMode_t]
            HIPBLAS_FILL_MODE_UPPER: A is an upper banded triangular matrix.
            HIPBLAS_FILL_MODE_LOWER: A is a  lower banded triangular matrix.

        transA (`~.hipblasOperation_t`) -- *IN*:
            [hipblasOperation_t]
            indicates whether matrix A is tranposed (conjugated) or not.

        diag (`~.hipblasDiagType_t`) -- *IN*:
            [hipblasDiagType_t]
            HIPBLAS_DIAG_UNIT: The main diagonal of A is assumed to consist of only
                                   1's and is not referenced.
            HIPBLAS_DIAG_NON_UNIT: No assumptions are made of A's main diagonal.

        n (`~.int`) -- *IN*:
            [int]
            the number of rows and columns of the matrix represented by A.

        k (`~.int`) -- *IN*:
            [int]
            if uplo == HIPBLAS_FILL_MODE_UPPER, k specifies the number of super-diagonals
            of the matrix A.
            if uplo == HIPBLAS_FILL_MODE_LOWER, k specifies the number of sub-diagonals
            of the matrix A.
            k must satisfy k > 0 && k < lda.

        AP (`~.hip._util.types.Pointer`/`~.object`) -- *IN*:
            device pointer storing banded triangular matrix A.
            if uplo == HIPBLAS_FILL_MODE_UPPER:
              The matrix represented is an upper banded triangular matrix
              with the main diagonal and k super-diagonals, everything
              else can be assumed to be 0.
              The matrix is compacted so that the main diagonal resides on the k'th
              row, the first super diagonal resides on the RHS of the k-1'th row, etc,
              with the k'th diagonal on the RHS of the 0'th row.
                 Ex: (HIPBLAS_FILL_MODE_UPPER; n = 5; k = 2)
                    1 6 9 0 0              0 0 9 8 7
                    0 2 7 8 0              0 6 7 8 9
                    0 0 3 8 7     ---->    1 2 3 4 5
                    0 0 0 4 9              0 0 0 0 0
                    0 0 0 0 5              0 0 0 0 0
            if uplo == HIPBLAS_FILL_MODE_LOWER:
              The matrix represnted is a lower banded triangular matrix
              with the main diagonal and k sub-diagonals, everything else can be
              assumed to be 0.
              The matrix is compacted so that the main diagonal resides on the 0'th row,
              working up to the k'th diagonal residing on the LHS of the k'th row.
                 Ex: (HIPBLAS_FILL_MODE_LOWER; n = 5; k = 2)
                    1 0 0 0 0              1 2 3 4 5
                    6 2 0 0 0              6 7 8 9 0
                    9 7 3 0 0     ---->    9 8 7 0 0
                    0 8 8 4 0              0 0 0 0 0
                    0 0 7 9 5              0 0 0 0 0

        lda (`~.int`) -- *IN*:
            [int]
            specifies the leading dimension of A. lda must satisfy lda > k.

        x (`~.hip._util.types.Pointer`/`~.object`) -- *INOUT*:
            device pointer storing vector x.

        incx (`~.int`) -- *IN*:
            [int]
            specifies the increment for the elements of x.
    """
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")                    
    if not isinstance(transA,_hipblasOperation_t__Base):
        raise TypeError("argument 'transA' must be of type '_hipblasOperation_t__Base'")                    
    if not isinstance(diag,_hipblasDiagType_t__Base):
        raise TypeError("argument 'diag' must be of type '_hipblasDiagType_t__Base'")
    _hipblasStbmv__retval = hipblasStatus_t(chipblas.hipblasStbmv(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,uplo.value,transA.value,diag.value,n,k,
        <const float *>hip._util.types.Pointer.fromPyobj(AP)._ptr,lda,
        <float *>hip._util.types.Pointer.fromPyobj(x)._ptr,incx))
    return (_hipblasStbmv__retval,)


@cython.embedsignature(True)
def hipblasDtbmv(object handle, object uplo, object transA, object diag, int n, int k, object AP, int lda, object x, int incx):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        uplo (`~.hipblasFillMode_t`):
            (undocumented)

        transA (`~.hipblasOperation_t`):
            (undocumented)

        diag (`~.hipblasDiagType_t`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        k (`~.int`):
            (undocumented)

        AP (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        x (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)
    """
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")                    
    if not isinstance(transA,_hipblasOperation_t__Base):
        raise TypeError("argument 'transA' must be of type '_hipblasOperation_t__Base'")                    
    if not isinstance(diag,_hipblasDiagType_t__Base):
        raise TypeError("argument 'diag' must be of type '_hipblasDiagType_t__Base'")
    _hipblasDtbmv__retval = hipblasStatus_t(chipblas.hipblasDtbmv(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,uplo.value,transA.value,diag.value,n,k,
        <const double *>hip._util.types.Pointer.fromPyobj(AP)._ptr,lda,
        <double *>hip._util.types.Pointer.fromPyobj(x)._ptr,incx))
    return (_hipblasDtbmv__retval,)


@cython.embedsignature(True)
def hipblasCtbmv(object handle, object uplo, object transA, object diag, int n, int k, object AP, int lda, object x, int incx):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        uplo (`~.hipblasFillMode_t`):
            (undocumented)

        transA (`~.hipblasOperation_t`):
            (undocumented)

        diag (`~.hipblasDiagType_t`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        k (`~.int`):
            (undocumented)

        AP (`~.hipblasComplex`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        x (`~.hipblasComplex`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)
    """
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")                    
    if not isinstance(transA,_hipblasOperation_t__Base):
        raise TypeError("argument 'transA' must be of type '_hipblasOperation_t__Base'")                    
    if not isinstance(diag,_hipblasDiagType_t__Base):
        raise TypeError("argument 'diag' must be of type '_hipblasDiagType_t__Base'")
    _hipblasCtbmv__retval = hipblasStatus_t(chipblas.hipblasCtbmv(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,uplo.value,transA.value,diag.value,n,k,
        hipblasComplex.fromPyobj(AP).getElementPtr(),lda,
        hipblasComplex.fromPyobj(x).getElementPtr(),incx))
    return (_hipblasCtbmv__retval,)


@cython.embedsignature(True)
def hipblasZtbmv(object handle, object uplo, object transA, object diag, int n, int k, object AP, int lda, object x, int incx):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        uplo (`~.hipblasFillMode_t`):
            (undocumented)

        transA (`~.hipblasOperation_t`):
            (undocumented)

        diag (`~.hipblasDiagType_t`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        k (`~.int`):
            (undocumented)

        AP (`~.hipblasDoubleComplex`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        x (`~.hipblasDoubleComplex`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)
    """
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")                    
    if not isinstance(transA,_hipblasOperation_t__Base):
        raise TypeError("argument 'transA' must be of type '_hipblasOperation_t__Base'")                    
    if not isinstance(diag,_hipblasDiagType_t__Base):
        raise TypeError("argument 'diag' must be of type '_hipblasDiagType_t__Base'")
    _hipblasZtbmv__retval = hipblasStatus_t(chipblas.hipblasZtbmv(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,uplo.value,transA.value,diag.value,n,k,
        hipblasDoubleComplex.fromPyobj(AP).getElementPtr(),lda,
        hipblasDoubleComplex.fromPyobj(x).getElementPtr(),incx))
    return (_hipblasZtbmv__retval,)


@cython.embedsignature(True)
def hipblasCtbmv_v2(object handle, object uplo, object transA, object diag, int n, int k, object AP, int lda, object x, int incx):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        uplo (`~.hipblasFillMode_t`):
            (undocumented)

        transA (`~.hipblasOperation_t`):
            (undocumented)

        diag (`~.hipblasDiagType_t`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        k (`~.int`):
            (undocumented)

        AP (`~.float2`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        x (`~.float2`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)
    """
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")                    
    if not isinstance(transA,_hipblasOperation_t__Base):
        raise TypeError("argument 'transA' must be of type '_hipblasOperation_t__Base'")                    
    if not isinstance(diag,_hipblasDiagType_t__Base):
        raise TypeError("argument 'diag' must be of type '_hipblasDiagType_t__Base'")
    _hipblasCtbmv_v2__retval = hipblasStatus_t(chipblas.hipblasCtbmv_v2(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,uplo.value,transA.value,diag.value,n,k,
        float2.fromPyobj(AP).getElementPtr(),lda,
        float2.fromPyobj(x).getElementPtr(),incx))
    return (_hipblasCtbmv_v2__retval,)


@cython.embedsignature(True)
def hipblasZtbmv_v2(object handle, object uplo, object transA, object diag, int n, int k, object AP, int lda, object x, int incx):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        uplo (`~.hipblasFillMode_t`):
            (undocumented)

        transA (`~.hipblasOperation_t`):
            (undocumented)

        diag (`~.hipblasDiagType_t`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        k (`~.int`):
            (undocumented)

        AP (`~.double2`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        x (`~.double2`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)
    """
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")                    
    if not isinstance(transA,_hipblasOperation_t__Base):
        raise TypeError("argument 'transA' must be of type '_hipblasOperation_t__Base'")                    
    if not isinstance(diag,_hipblasDiagType_t__Base):
        raise TypeError("argument 'diag' must be of type '_hipblasDiagType_t__Base'")
    _hipblasZtbmv_v2__retval = hipblasStatus_t(chipblas.hipblasZtbmv_v2(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,uplo.value,transA.value,diag.value,n,k,
        double2.fromPyobj(AP).getElementPtr(),lda,
        double2.fromPyobj(x).getElementPtr(),incx))
    return (_hipblasZtbmv_v2__retval,)


@cython.embedsignature(True)
def hipblasStbmv_64(object handle, object uplo, object transA, object diag, long n, long k, object AP, long lda, object x, long incx):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        uplo (`~.hipblasFillMode_t`):
            (undocumented)

        transA (`~.hipblasOperation_t`):
            (undocumented)

        diag (`~.hipblasDiagType_t`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        k (`~.int`):
            (undocumented)

        AP (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        x (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)
    """
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")                    
    if not isinstance(transA,_hipblasOperation_t__Base):
        raise TypeError("argument 'transA' must be of type '_hipblasOperation_t__Base'")                    
    if not isinstance(diag,_hipblasDiagType_t__Base):
        raise TypeError("argument 'diag' must be of type '_hipblasDiagType_t__Base'")
    _hipblasStbmv_64__retval = hipblasStatus_t(chipblas.hipblasStbmv_64(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,uplo.value,transA.value,diag.value,n,k,
        <const float *>hip._util.types.Pointer.fromPyobj(AP)._ptr,lda,
        <float *>hip._util.types.Pointer.fromPyobj(x)._ptr,incx))
    return (_hipblasStbmv_64__retval,)


@cython.embedsignature(True)
def hipblasDtbmv_64(object handle, object uplo, object transA, object diag, long n, long k, object AP, long lda, object x, long incx):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        uplo (`~.hipblasFillMode_t`):
            (undocumented)

        transA (`~.hipblasOperation_t`):
            (undocumented)

        diag (`~.hipblasDiagType_t`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        k (`~.int`):
            (undocumented)

        AP (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        x (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)
    """
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")                    
    if not isinstance(transA,_hipblasOperation_t__Base):
        raise TypeError("argument 'transA' must be of type '_hipblasOperation_t__Base'")                    
    if not isinstance(diag,_hipblasDiagType_t__Base):
        raise TypeError("argument 'diag' must be of type '_hipblasDiagType_t__Base'")
    _hipblasDtbmv_64__retval = hipblasStatus_t(chipblas.hipblasDtbmv_64(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,uplo.value,transA.value,diag.value,n,k,
        <const double *>hip._util.types.Pointer.fromPyobj(AP)._ptr,lda,
        <double *>hip._util.types.Pointer.fromPyobj(x)._ptr,incx))
    return (_hipblasDtbmv_64__retval,)


@cython.embedsignature(True)
def hipblasCtbmv_64(object handle, object uplo, object transA, object diag, long n, long k, object AP, long lda, object x, long incx):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        uplo (`~.hipblasFillMode_t`):
            (undocumented)

        transA (`~.hipblasOperation_t`):
            (undocumented)

        diag (`~.hipblasDiagType_t`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        k (`~.int`):
            (undocumented)

        AP (`~.hipblasComplex`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        x (`~.hipblasComplex`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)
    """
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")                    
    if not isinstance(transA,_hipblasOperation_t__Base):
        raise TypeError("argument 'transA' must be of type '_hipblasOperation_t__Base'")                    
    if not isinstance(diag,_hipblasDiagType_t__Base):
        raise TypeError("argument 'diag' must be of type '_hipblasDiagType_t__Base'")
    _hipblasCtbmv_64__retval = hipblasStatus_t(chipblas.hipblasCtbmv_64(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,uplo.value,transA.value,diag.value,n,k,
        hipblasComplex.fromPyobj(AP).getElementPtr(),lda,
        hipblasComplex.fromPyobj(x).getElementPtr(),incx))
    return (_hipblasCtbmv_64__retval,)


@cython.embedsignature(True)
def hipblasZtbmv_64(object handle, object uplo, object transA, object diag, long n, long k, object AP, long lda, object x, long incx):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        uplo (`~.hipblasFillMode_t`):
            (undocumented)

        transA (`~.hipblasOperation_t`):
            (undocumented)

        diag (`~.hipblasDiagType_t`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        k (`~.int`):
            (undocumented)

        AP (`~.hipblasDoubleComplex`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        x (`~.hipblasDoubleComplex`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)
    """
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")                    
    if not isinstance(transA,_hipblasOperation_t__Base):
        raise TypeError("argument 'transA' must be of type '_hipblasOperation_t__Base'")                    
    if not isinstance(diag,_hipblasDiagType_t__Base):
        raise TypeError("argument 'diag' must be of type '_hipblasDiagType_t__Base'")
    _hipblasZtbmv_64__retval = hipblasStatus_t(chipblas.hipblasZtbmv_64(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,uplo.value,transA.value,diag.value,n,k,
        hipblasDoubleComplex.fromPyobj(AP).getElementPtr(),lda,
        hipblasDoubleComplex.fromPyobj(x).getElementPtr(),incx))
    return (_hipblasZtbmv_64__retval,)


@cython.embedsignature(True)
def hipblasCtbmv_v2_64(object handle, object uplo, object transA, object diag, long n, long k, object AP, long lda, object x, long incx):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        uplo (`~.hipblasFillMode_t`):
            (undocumented)

        transA (`~.hipblasOperation_t`):
            (undocumented)

        diag (`~.hipblasDiagType_t`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        k (`~.int`):
            (undocumented)

        AP (`~.float2`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        x (`~.float2`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)
    """
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")                    
    if not isinstance(transA,_hipblasOperation_t__Base):
        raise TypeError("argument 'transA' must be of type '_hipblasOperation_t__Base'")                    
    if not isinstance(diag,_hipblasDiagType_t__Base):
        raise TypeError("argument 'diag' must be of type '_hipblasDiagType_t__Base'")
    _hipblasCtbmv_v2_64__retval = hipblasStatus_t(chipblas.hipblasCtbmv_v2_64(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,uplo.value,transA.value,diag.value,n,k,
        float2.fromPyobj(AP).getElementPtr(),lda,
        float2.fromPyobj(x).getElementPtr(),incx))
    return (_hipblasCtbmv_v2_64__retval,)


@cython.embedsignature(True)
def hipblasZtbmv_v2_64(object handle, object uplo, object transA, object diag, long n, long k, object AP, long lda, object x, long incx):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        uplo (`~.hipblasFillMode_t`):
            (undocumented)

        transA (`~.hipblasOperation_t`):
            (undocumented)

        diag (`~.hipblasDiagType_t`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        k (`~.int`):
            (undocumented)

        AP (`~.double2`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        x (`~.double2`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)
    """
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")                    
    if not isinstance(transA,_hipblasOperation_t__Base):
        raise TypeError("argument 'transA' must be of type '_hipblasOperation_t__Base'")                    
    if not isinstance(diag,_hipblasDiagType_t__Base):
        raise TypeError("argument 'diag' must be of type '_hipblasDiagType_t__Base'")
    _hipblasZtbmv_v2_64__retval = hipblasStatus_t(chipblas.hipblasZtbmv_v2_64(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,uplo.value,transA.value,diag.value,n,k,
        double2.fromPyobj(AP).getElementPtr(),lda,
        double2.fromPyobj(x).getElementPtr(),incx))
    return (_hipblasZtbmv_v2_64__retval,)


@cython.embedsignature(True)
def hipblasStbmvBatched(object handle, object uplo, object transA, object diag, int n, int k, object AP, int lda, object x, int incx, int batchCount):
    r"""BLAS Level 2 API

    @{

    tbmvBatched performs one of the matrix-vector operations

    x_i := A_i*x_i      or
        x_i := A_i**T*x_i   or
        x_i := A_i**H*x_i,

    where (A_i, x_i) is the i-th instance of the batch.
    x_i is a vector and A_i is an n by n matrix, for i = 1, ..., batchCount.

    - Supported precisions in rocBLAS : s,d,c,z
    - Supported precisions in cuBLAS  : No support

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`) -- *IN*:
            [hipblasHandle_t]
            handle to the hipblas library context queue.

        uplo (`~.hipblasFillMode_t`) -- *IN*:
            [hipblasFillMode_t]
            HIPBLAS_FILL_MODE_UPPER: each A_i is an upper banded triangular matrix.
            HIPBLAS_FILL_MODE_LOWER: each A_i is a  lower banded triangular matrix.

        transA (`~.hipblasOperation_t`) -- *IN*:
            [hipblasOperation_t]
            indicates whether each matrix A_i is tranposed (conjugated) or not.

        diag (`~.hipblasDiagType_t`) -- *IN*:
            [hipblasDiagType_t]
            HIPBLAS_DIAG_UNIT: The main diagonal of each A_i is assumed to consist of only
                                   1's and is not referenced.
            HIPBLAS_DIAG_NON_UNIT: No assumptions are made of each A_i's main diagonal.

        n (`~.int`) -- *IN*:
            [int]
            the number of rows and columns of the matrix represented by each A_i.

        k (`~.int`) -- *IN*:
            [int]
            if uplo == HIPBLAS_FILL_MODE_UPPER, k specifies the number of super-diagonals
            of each matrix A_i.
            if uplo == HIPBLAS_FILL_MODE_LOWER, k specifies the number of sub-diagonals
            of each matrix A_i.
            k must satisfy k > 0 && k < lda.

        AP (`~.hip._util.types.Pointer`/`~.object`) -- *IN*:
            device array of device pointers storing each banded triangular matrix A_i.
            if uplo == HIPBLAS_FILL_MODE_UPPER:
              The matrix represented is an upper banded triangular matrix
              with the main diagonal and k super-diagonals, everything
              else can be assumed to be 0.
              The matrix is compacted so that the main diagonal resides on the k'th
              row, the first super diagonal resides on the RHS of the k-1'th row, etc,
              with the k'th diagonal on the RHS of the 0'th row.
                 Ex: (HIPBLAS_FILL_MODE_UPPER; n = 5; k = 2)
                    1 6 9 0 0              0 0 9 8 7
                    0 2 7 8 0              0 6 7 8 9
                    0 0 3 8 7     ---->    1 2 3 4 5
                    0 0 0 4 9              0 0 0 0 0
                    0 0 0 0 5              0 0 0 0 0
            if uplo == HIPBLAS_FILL_MODE_LOWER:
              The matrix represnted is a lower banded triangular matrix
              with the main diagonal and k sub-diagonals, everything else can be
              assumed to be 0.
              The matrix is compacted so that the main diagonal resides on the 0'th row,
              working up to the k'th diagonal residing on the LHS of the k'th row.
                 Ex: (HIPBLAS_FILL_MODE_LOWER; n = 5; k = 2)
                    1 0 0 0 0              1 2 3 4 5
                    6 2 0 0 0              6 7 8 9 0
                    9 7 3 0 0     ---->    9 8 7 0 0
                    0 8 8 4 0              0 0 0 0 0
                    0 0 7 9 5              0 0 0 0 0

        lda (`~.int`) -- *IN*:
            [int]
            specifies the leading dimension of each A_i. lda must satisfy lda > k.

        x (`~.hip._util.types.ListOfPointer`/`~.object`) -- *INOUT*:
            device array of device pointer storing each vector x_i.

        incx (`~.int`) -- *IN*:
            [int]
            specifies the increment for the elements of each x_i.

        batchCount (`~.int`) -- *IN*:
            [int]
            number of instances in the batch.
    """
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")                    
    if not isinstance(transA,_hipblasOperation_t__Base):
        raise TypeError("argument 'transA' must be of type '_hipblasOperation_t__Base'")                    
    if not isinstance(diag,_hipblasDiagType_t__Base):
        raise TypeError("argument 'diag' must be of type '_hipblasDiagType_t__Base'")
    _hipblasStbmvBatched__retval = hipblasStatus_t(chipblas.hipblasStbmvBatched(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,uplo.value,transA.value,diag.value,n,k,
        <const float *const*>hip._util.types.Pointer.fromPyobj(AP)._ptr,lda,
        <float *const*>hip._util.types.ListOfPointer.fromPyobj(x)._ptr,incx,batchCount))
    return (_hipblasStbmvBatched__retval,)


@cython.embedsignature(True)
def hipblasDtbmvBatched(object handle, object uplo, object transA, object diag, int n, int k, object AP, int lda, object x, int incx, int batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        uplo (`~.hipblasFillMode_t`):
            (undocumented)

        transA (`~.hipblasOperation_t`):
            (undocumented)

        diag (`~.hipblasDiagType_t`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        k (`~.int`):
            (undocumented)

        AP (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        x (`~.hip._util.types.ListOfPointer`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")                    
    if not isinstance(transA,_hipblasOperation_t__Base):
        raise TypeError("argument 'transA' must be of type '_hipblasOperation_t__Base'")                    
    if not isinstance(diag,_hipblasDiagType_t__Base):
        raise TypeError("argument 'diag' must be of type '_hipblasDiagType_t__Base'")
    _hipblasDtbmvBatched__retval = hipblasStatus_t(chipblas.hipblasDtbmvBatched(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,uplo.value,transA.value,diag.value,n,k,
        <const double *const*>hip._util.types.Pointer.fromPyobj(AP)._ptr,lda,
        <double *const*>hip._util.types.ListOfPointer.fromPyobj(x)._ptr,incx,batchCount))
    return (_hipblasDtbmvBatched__retval,)


@cython.embedsignature(True)
def hipblasCtbmvBatched(object handle, object uplo, object transA, object diag, int n, int k, object AP, int lda, object x, int incx, int batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        uplo (`~.hipblasFillMode_t`):
            (undocumented)

        transA (`~.hipblasOperation_t`):
            (undocumented)

        diag (`~.hipblasDiagType_t`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        k (`~.int`):
            (undocumented)

        AP (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        x (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")                    
    if not isinstance(transA,_hipblasOperation_t__Base):
        raise TypeError("argument 'transA' must be of type '_hipblasOperation_t__Base'")                    
    if not isinstance(diag,_hipblasDiagType_t__Base):
        raise TypeError("argument 'diag' must be of type '_hipblasDiagType_t__Base'")
    _hipblasCtbmvBatched__retval = hipblasStatus_t(chipblas.hipblasCtbmvBatched(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,uplo.value,transA.value,diag.value,n,k,
        <chipblas.hipblasComplex *const*>hip._util.types.Pointer.fromPyobj(AP)._ptr,lda,
        <chipblas.hipblasComplex *const*>hip._util.types.Pointer.fromPyobj(x)._ptr,incx,batchCount))
    return (_hipblasCtbmvBatched__retval,)


@cython.embedsignature(True)
def hipblasZtbmvBatched(object handle, object uplo, object transA, object diag, int n, int k, object AP, int lda, object x, int incx, int batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        uplo (`~.hipblasFillMode_t`):
            (undocumented)

        transA (`~.hipblasOperation_t`):
            (undocumented)

        diag (`~.hipblasDiagType_t`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        k (`~.int`):
            (undocumented)

        AP (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        x (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")                    
    if not isinstance(transA,_hipblasOperation_t__Base):
        raise TypeError("argument 'transA' must be of type '_hipblasOperation_t__Base'")                    
    if not isinstance(diag,_hipblasDiagType_t__Base):
        raise TypeError("argument 'diag' must be of type '_hipblasDiagType_t__Base'")
    _hipblasZtbmvBatched__retval = hipblasStatus_t(chipblas.hipblasZtbmvBatched(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,uplo.value,transA.value,diag.value,n,k,
        <chipblas.hipblasDoubleComplex *const*>hip._util.types.Pointer.fromPyobj(AP)._ptr,lda,
        <chipblas.hipblasDoubleComplex *const*>hip._util.types.Pointer.fromPyobj(x)._ptr,incx,batchCount))
    return (_hipblasZtbmvBatched__retval,)


@cython.embedsignature(True)
def hipblasCtbmvBatched_v2(object handle, object uplo, object transA, object diag, int n, int k, object AP, int lda, object x, int incx, int batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        uplo (`~.hipblasFillMode_t`):
            (undocumented)

        transA (`~.hipblasOperation_t`):
            (undocumented)

        diag (`~.hipblasDiagType_t`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        k (`~.int`):
            (undocumented)

        AP (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        x (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")                    
    if not isinstance(transA,_hipblasOperation_t__Base):
        raise TypeError("argument 'transA' must be of type '_hipblasOperation_t__Base'")                    
    if not isinstance(diag,_hipblasDiagType_t__Base):
        raise TypeError("argument 'diag' must be of type '_hipblasDiagType_t__Base'")
    _hipblasCtbmvBatched_v2__retval = hipblasStatus_t(chipblas.hipblasCtbmvBatched_v2(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,uplo.value,transA.value,diag.value,n,k,
        <chipblas.float2 *const*>hip._util.types.Pointer.fromPyobj(AP)._ptr,lda,
        <chipblas.float2 *const*>hip._util.types.Pointer.fromPyobj(x)._ptr,incx,batchCount))
    return (_hipblasCtbmvBatched_v2__retval,)


@cython.embedsignature(True)
def hipblasZtbmvBatched_v2(object handle, object uplo, object transA, object diag, int n, int k, object AP, int lda, object x, int incx, int batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        uplo (`~.hipblasFillMode_t`):
            (undocumented)

        transA (`~.hipblasOperation_t`):
            (undocumented)

        diag (`~.hipblasDiagType_t`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        k (`~.int`):
            (undocumented)

        AP (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        x (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")                    
    if not isinstance(transA,_hipblasOperation_t__Base):
        raise TypeError("argument 'transA' must be of type '_hipblasOperation_t__Base'")                    
    if not isinstance(diag,_hipblasDiagType_t__Base):
        raise TypeError("argument 'diag' must be of type '_hipblasDiagType_t__Base'")
    _hipblasZtbmvBatched_v2__retval = hipblasStatus_t(chipblas.hipblasZtbmvBatched_v2(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,uplo.value,transA.value,diag.value,n,k,
        <chipblas.double2 *const*>hip._util.types.Pointer.fromPyobj(AP)._ptr,lda,
        <chipblas.double2 *const*>hip._util.types.Pointer.fromPyobj(x)._ptr,incx,batchCount))
    return (_hipblasZtbmvBatched_v2__retval,)


@cython.embedsignature(True)
def hipblasStbmvBatched_64(object handle, object uplo, object transA, object diag, long n, long k, object AP, long lda, object x, long incx, long batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        uplo (`~.hipblasFillMode_t`):
            (undocumented)

        transA (`~.hipblasOperation_t`):
            (undocumented)

        diag (`~.hipblasDiagType_t`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        k (`~.int`):
            (undocumented)

        AP (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        x (`~.hip._util.types.ListOfPointer`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")                    
    if not isinstance(transA,_hipblasOperation_t__Base):
        raise TypeError("argument 'transA' must be of type '_hipblasOperation_t__Base'")                    
    if not isinstance(diag,_hipblasDiagType_t__Base):
        raise TypeError("argument 'diag' must be of type '_hipblasDiagType_t__Base'")
    _hipblasStbmvBatched_64__retval = hipblasStatus_t(chipblas.hipblasStbmvBatched_64(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,uplo.value,transA.value,diag.value,n,k,
        <const float *const*>hip._util.types.Pointer.fromPyobj(AP)._ptr,lda,
        <float *const*>hip._util.types.ListOfPointer.fromPyobj(x)._ptr,incx,batchCount))
    return (_hipblasStbmvBatched_64__retval,)


@cython.embedsignature(True)
def hipblasDtbmvBatched_64(object handle, object uplo, object transA, object diag, long n, long k, object AP, long lda, object x, long incx, long batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        uplo (`~.hipblasFillMode_t`):
            (undocumented)

        transA (`~.hipblasOperation_t`):
            (undocumented)

        diag (`~.hipblasDiagType_t`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        k (`~.int`):
            (undocumented)

        AP (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        x (`~.hip._util.types.ListOfPointer`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")                    
    if not isinstance(transA,_hipblasOperation_t__Base):
        raise TypeError("argument 'transA' must be of type '_hipblasOperation_t__Base'")                    
    if not isinstance(diag,_hipblasDiagType_t__Base):
        raise TypeError("argument 'diag' must be of type '_hipblasDiagType_t__Base'")
    _hipblasDtbmvBatched_64__retval = hipblasStatus_t(chipblas.hipblasDtbmvBatched_64(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,uplo.value,transA.value,diag.value,n,k,
        <const double *const*>hip._util.types.Pointer.fromPyobj(AP)._ptr,lda,
        <double *const*>hip._util.types.ListOfPointer.fromPyobj(x)._ptr,incx,batchCount))
    return (_hipblasDtbmvBatched_64__retval,)


@cython.embedsignature(True)
def hipblasCtbmvBatched_64(object handle, object uplo, object transA, object diag, long n, long k, object AP, long lda, object x, long incx, long batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        uplo (`~.hipblasFillMode_t`):
            (undocumented)

        transA (`~.hipblasOperation_t`):
            (undocumented)

        diag (`~.hipblasDiagType_t`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        k (`~.int`):
            (undocumented)

        AP (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        x (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")                    
    if not isinstance(transA,_hipblasOperation_t__Base):
        raise TypeError("argument 'transA' must be of type '_hipblasOperation_t__Base'")                    
    if not isinstance(diag,_hipblasDiagType_t__Base):
        raise TypeError("argument 'diag' must be of type '_hipblasDiagType_t__Base'")
    _hipblasCtbmvBatched_64__retval = hipblasStatus_t(chipblas.hipblasCtbmvBatched_64(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,uplo.value,transA.value,diag.value,n,k,
        <chipblas.hipblasComplex *const*>hip._util.types.Pointer.fromPyobj(AP)._ptr,lda,
        <chipblas.hipblasComplex *const*>hip._util.types.Pointer.fromPyobj(x)._ptr,incx,batchCount))
    return (_hipblasCtbmvBatched_64__retval,)


@cython.embedsignature(True)
def hipblasZtbmvBatched_64(object handle, object uplo, object transA, object diag, long n, long k, object AP, long lda, object x, long incx, long batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        uplo (`~.hipblasFillMode_t`):
            (undocumented)

        transA (`~.hipblasOperation_t`):
            (undocumented)

        diag (`~.hipblasDiagType_t`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        k (`~.int`):
            (undocumented)

        AP (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        x (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")                    
    if not isinstance(transA,_hipblasOperation_t__Base):
        raise TypeError("argument 'transA' must be of type '_hipblasOperation_t__Base'")                    
    if not isinstance(diag,_hipblasDiagType_t__Base):
        raise TypeError("argument 'diag' must be of type '_hipblasDiagType_t__Base'")
    _hipblasZtbmvBatched_64__retval = hipblasStatus_t(chipblas.hipblasZtbmvBatched_64(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,uplo.value,transA.value,diag.value,n,k,
        <chipblas.hipblasDoubleComplex *const*>hip._util.types.Pointer.fromPyobj(AP)._ptr,lda,
        <chipblas.hipblasDoubleComplex *const*>hip._util.types.Pointer.fromPyobj(x)._ptr,incx,batchCount))
    return (_hipblasZtbmvBatched_64__retval,)


@cython.embedsignature(True)
def hipblasCtbmvBatched_v2_64(object handle, object uplo, object transA, object diag, long n, long k, object AP, long lda, object x, long incx, long batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        uplo (`~.hipblasFillMode_t`):
            (undocumented)

        transA (`~.hipblasOperation_t`):
            (undocumented)

        diag (`~.hipblasDiagType_t`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        k (`~.int`):
            (undocumented)

        AP (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        x (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")                    
    if not isinstance(transA,_hipblasOperation_t__Base):
        raise TypeError("argument 'transA' must be of type '_hipblasOperation_t__Base'")                    
    if not isinstance(diag,_hipblasDiagType_t__Base):
        raise TypeError("argument 'diag' must be of type '_hipblasDiagType_t__Base'")
    _hipblasCtbmvBatched_v2_64__retval = hipblasStatus_t(chipblas.hipblasCtbmvBatched_v2_64(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,uplo.value,transA.value,diag.value,n,k,
        <chipblas.float2 *const*>hip._util.types.Pointer.fromPyobj(AP)._ptr,lda,
        <chipblas.float2 *const*>hip._util.types.Pointer.fromPyobj(x)._ptr,incx,batchCount))
    return (_hipblasCtbmvBatched_v2_64__retval,)


@cython.embedsignature(True)
def hipblasZtbmvBatched_v2_64(object handle, object uplo, object transA, object diag, long n, long k, object AP, long lda, object x, long incx, long batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        uplo (`~.hipblasFillMode_t`):
            (undocumented)

        transA (`~.hipblasOperation_t`):
            (undocumented)

        diag (`~.hipblasDiagType_t`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        k (`~.int`):
            (undocumented)

        AP (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        x (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")                    
    if not isinstance(transA,_hipblasOperation_t__Base):
        raise TypeError("argument 'transA' must be of type '_hipblasOperation_t__Base'")                    
    if not isinstance(diag,_hipblasDiagType_t__Base):
        raise TypeError("argument 'diag' must be of type '_hipblasDiagType_t__Base'")
    _hipblasZtbmvBatched_v2_64__retval = hipblasStatus_t(chipblas.hipblasZtbmvBatched_v2_64(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,uplo.value,transA.value,diag.value,n,k,
        <chipblas.double2 *const*>hip._util.types.Pointer.fromPyobj(AP)._ptr,lda,
        <chipblas.double2 *const*>hip._util.types.Pointer.fromPyobj(x)._ptr,incx,batchCount))
    return (_hipblasZtbmvBatched_v2_64__retval,)


@cython.embedsignature(True)
def hipblasStbmvStridedBatched(object handle, object uplo, object transA, object diag, int n, int k, object AP, int lda, long strideA, object x, int incx, long stridex, int batchCount):
    r"""BLAS Level 2 API

    @{

    tbmvStridedBatched performs one of the matrix-vector operations

    x_i := A_i*x_i      or
        x_i := A_i**T*x_i   or
        x_i := A_i**H*x_i,

    where (A_i, x_i) is the i-th instance of the batch.
    x_i is a vector and A_i is an n by n matrix, for i = 1, ..., batchCount.

    - Supported precisions in rocBLAS : s,d,c,z
    - Supported precisions in cuBLAS  : No support

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`) -- *IN*:
            [hipblasHandle_t]
            handle to the hipblas library context queue.

        uplo (`~.hipblasFillMode_t`) -- *IN*:
            [hipblasFillMode_t]
            HIPBLAS_FILL_MODE_UPPER: each A_i is an upper banded triangular matrix.
            HIPBLAS_FILL_MODE_LOWER: each A_i is a  lower banded triangular matrix.

        transA (`~.hipblasOperation_t`) -- *IN*:
            [hipblasOperation_t]
            indicates whether each matrix A_i is tranposed (conjugated) or not.

        diag (`~.hipblasDiagType_t`) -- *IN*:
            [hipblasDiagType_t]
            HIPBLAS_DIAG_UNIT: The main diagonal of each A_i is assumed to consist of only
                                   1's and is not referenced.
            HIPBLAS_DIAG_NON_UNIT: No assumptions are made of each A_i's main diagonal.

        n (`~.int`) -- *IN*:
            [int]
            the number of rows and columns of the matrix represented by each A_i.

        k (`~.int`) -- *IN*:
            [int]
            if uplo == HIPBLAS_FILL_MODE_UPPER, k specifies the number of super-diagonals
            of each matrix A_i.
            if uplo == HIPBLAS_FILL_MODE_LOWER, k specifies the number of sub-diagonals
            of each matrix A_i.
            k must satisfy k > 0 && k < lda.

        AP (`~.hip._util.types.Pointer`/`~.object`) -- *IN*:
            device array to the first matrix A_i of the batch. Stores each banded triangular matrix A_i.
            if uplo == HIPBLAS_FILL_MODE_UPPER:
              The matrix represented is an upper banded triangular matrix
              with the main diagonal and k super-diagonals, everything
              else can be assumed to be 0.
              The matrix is compacted so that the main diagonal resides on the k'th
              row, the first super diagonal resides on the RHS of the k-1'th row, etc,
              with the k'th diagonal on the RHS of the 0'th row.
                 Ex: (HIPBLAS_FILL_MODE_UPPER; n = 5; k = 2)
                    1 6 9 0 0              0 0 9 8 7
                    0 2 7 8 0              0 6 7 8 9
                    0 0 3 8 7     ---->    1 2 3 4 5
                    0 0 0 4 9              0 0 0 0 0
                    0 0 0 0 5              0 0 0 0 0
            if uplo == HIPBLAS_FILL_MODE_LOWER:
              The matrix represnted is a lower banded triangular matrix
              with the main diagonal and k sub-diagonals, everything else can be
              assumed to be 0.
              The matrix is compacted so that the main diagonal resides on the 0'th row,
              working up to the k'th diagonal residing on the LHS of the k'th row.
                 Ex: (HIPBLAS_FILL_MODE_LOWER; n = 5; k = 2)
                    1 0 0 0 0              1 2 3 4 5
                    6 2 0 0 0              6 7 8 9 0
                    9 7 3 0 0     ---->    9 8 7 0 0
                    0 8 8 4 0              0 0 0 0 0
                    0 0 7 9 5              0 0 0 0 0

        lda (`~.int`) -- *IN*:
            [int]
            specifies the leading dimension of each A_i. lda must satisfy lda > k.

        strideA (`~.int`) -- *IN*:
            [hipblasStride]
            stride from the start of one A_i matrix to the next A_(i + 1).

        x (`~.hip._util.types.Pointer`/`~.object`) -- *INOUT*:
            device array to the first vector x_i of the batch.

        incx (`~.int`) -- *IN*:
            [int]
            specifies the increment for the elements of each x_i.

        stridex (`~.int`) -- *IN*:
            [hipblasStride]
            stride from the start of one x_i matrix to the next x_(i + 1).

        batchCount (`~.int`) -- *IN*:
            [int]
            number of instances in the batch.
    """
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")                    
    if not isinstance(transA,_hipblasOperation_t__Base):
        raise TypeError("argument 'transA' must be of type '_hipblasOperation_t__Base'")                    
    if not isinstance(diag,_hipblasDiagType_t__Base):
        raise TypeError("argument 'diag' must be of type '_hipblasDiagType_t__Base'")
    _hipblasStbmvStridedBatched__retval = hipblasStatus_t(chipblas.hipblasStbmvStridedBatched(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,uplo.value,transA.value,diag.value,n,k,
        <const float *>hip._util.types.Pointer.fromPyobj(AP)._ptr,lda,strideA,
        <float *>hip._util.types.Pointer.fromPyobj(x)._ptr,incx,stridex,batchCount))
    return (_hipblasStbmvStridedBatched__retval,)


@cython.embedsignature(True)
def hipblasDtbmvStridedBatched(object handle, object uplo, object transA, object diag, int n, int k, object AP, int lda, long strideA, object x, int incx, long stridex, int batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        uplo (`~.hipblasFillMode_t`):
            (undocumented)

        transA (`~.hipblasOperation_t`):
            (undocumented)

        diag (`~.hipblasDiagType_t`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        k (`~.int`):
            (undocumented)

        AP (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        strideA (`~.int`):
            (undocumented)

        x (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        stridex (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")                    
    if not isinstance(transA,_hipblasOperation_t__Base):
        raise TypeError("argument 'transA' must be of type '_hipblasOperation_t__Base'")                    
    if not isinstance(diag,_hipblasDiagType_t__Base):
        raise TypeError("argument 'diag' must be of type '_hipblasDiagType_t__Base'")
    _hipblasDtbmvStridedBatched__retval = hipblasStatus_t(chipblas.hipblasDtbmvStridedBatched(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,uplo.value,transA.value,diag.value,n,k,
        <const double *>hip._util.types.Pointer.fromPyobj(AP)._ptr,lda,strideA,
        <double *>hip._util.types.Pointer.fromPyobj(x)._ptr,incx,stridex,batchCount))
    return (_hipblasDtbmvStridedBatched__retval,)


@cython.embedsignature(True)
def hipblasCtbmvStridedBatched(object handle, object uplo, object transA, object diag, int n, int k, object AP, int lda, long strideA, object x, int incx, long stridex, int batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        uplo (`~.hipblasFillMode_t`):
            (undocumented)

        transA (`~.hipblasOperation_t`):
            (undocumented)

        diag (`~.hipblasDiagType_t`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        k (`~.int`):
            (undocumented)

        AP (`~.hipblasComplex`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        strideA (`~.int`):
            (undocumented)

        x (`~.hipblasComplex`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        stridex (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")                    
    if not isinstance(transA,_hipblasOperation_t__Base):
        raise TypeError("argument 'transA' must be of type '_hipblasOperation_t__Base'")                    
    if not isinstance(diag,_hipblasDiagType_t__Base):
        raise TypeError("argument 'diag' must be of type '_hipblasDiagType_t__Base'")
    _hipblasCtbmvStridedBatched__retval = hipblasStatus_t(chipblas.hipblasCtbmvStridedBatched(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,uplo.value,transA.value,diag.value,n,k,
        hipblasComplex.fromPyobj(AP).getElementPtr(),lda,strideA,
        hipblasComplex.fromPyobj(x).getElementPtr(),incx,stridex,batchCount))
    return (_hipblasCtbmvStridedBatched__retval,)


@cython.embedsignature(True)
def hipblasZtbmvStridedBatched(object handle, object uplo, object transA, object diag, int n, int k, object AP, int lda, long strideA, object x, int incx, long stridex, int batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        uplo (`~.hipblasFillMode_t`):
            (undocumented)

        transA (`~.hipblasOperation_t`):
            (undocumented)

        diag (`~.hipblasDiagType_t`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        k (`~.int`):
            (undocumented)

        AP (`~.hipblasDoubleComplex`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        strideA (`~.int`):
            (undocumented)

        x (`~.hipblasDoubleComplex`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        stridex (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")                    
    if not isinstance(transA,_hipblasOperation_t__Base):
        raise TypeError("argument 'transA' must be of type '_hipblasOperation_t__Base'")                    
    if not isinstance(diag,_hipblasDiagType_t__Base):
        raise TypeError("argument 'diag' must be of type '_hipblasDiagType_t__Base'")
    _hipblasZtbmvStridedBatched__retval = hipblasStatus_t(chipblas.hipblasZtbmvStridedBatched(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,uplo.value,transA.value,diag.value,n,k,
        hipblasDoubleComplex.fromPyobj(AP).getElementPtr(),lda,strideA,
        hipblasDoubleComplex.fromPyobj(x).getElementPtr(),incx,stridex,batchCount))
    return (_hipblasZtbmvStridedBatched__retval,)


@cython.embedsignature(True)
def hipblasCtbmvStridedBatched_v2(object handle, object uplo, object transA, object diag, int n, int k, object AP, int lda, long strideA, object x, int incx, long stridex, int batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        uplo (`~.hipblasFillMode_t`):
            (undocumented)

        transA (`~.hipblasOperation_t`):
            (undocumented)

        diag (`~.hipblasDiagType_t`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        k (`~.int`):
            (undocumented)

        AP (`~.float2`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        strideA (`~.int`):
            (undocumented)

        x (`~.float2`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        stridex (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")                    
    if not isinstance(transA,_hipblasOperation_t__Base):
        raise TypeError("argument 'transA' must be of type '_hipblasOperation_t__Base'")                    
    if not isinstance(diag,_hipblasDiagType_t__Base):
        raise TypeError("argument 'diag' must be of type '_hipblasDiagType_t__Base'")
    _hipblasCtbmvStridedBatched_v2__retval = hipblasStatus_t(chipblas.hipblasCtbmvStridedBatched_v2(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,uplo.value,transA.value,diag.value,n,k,
        float2.fromPyobj(AP).getElementPtr(),lda,strideA,
        float2.fromPyobj(x).getElementPtr(),incx,stridex,batchCount))
    return (_hipblasCtbmvStridedBatched_v2__retval,)


@cython.embedsignature(True)
def hipblasZtbmvStridedBatched_v2(object handle, object uplo, object transA, object diag, int n, int k, object AP, int lda, long strideA, object x, int incx, long stridex, int batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        uplo (`~.hipblasFillMode_t`):
            (undocumented)

        transA (`~.hipblasOperation_t`):
            (undocumented)

        diag (`~.hipblasDiagType_t`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        k (`~.int`):
            (undocumented)

        AP (`~.double2`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        strideA (`~.int`):
            (undocumented)

        x (`~.double2`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        stridex (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")                    
    if not isinstance(transA,_hipblasOperation_t__Base):
        raise TypeError("argument 'transA' must be of type '_hipblasOperation_t__Base'")                    
    if not isinstance(diag,_hipblasDiagType_t__Base):
        raise TypeError("argument 'diag' must be of type '_hipblasDiagType_t__Base'")
    _hipblasZtbmvStridedBatched_v2__retval = hipblasStatus_t(chipblas.hipblasZtbmvStridedBatched_v2(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,uplo.value,transA.value,diag.value,n,k,
        double2.fromPyobj(AP).getElementPtr(),lda,strideA,
        double2.fromPyobj(x).getElementPtr(),incx,stridex,batchCount))
    return (_hipblasZtbmvStridedBatched_v2__retval,)


@cython.embedsignature(True)
def hipblasStbmvStridedBatched_64(object handle, object uplo, object transA, object diag, long n, long k, object AP, long lda, long strideA, object x, long incx, long stridex, long batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        uplo (`~.hipblasFillMode_t`):
            (undocumented)

        transA (`~.hipblasOperation_t`):
            (undocumented)

        diag (`~.hipblasDiagType_t`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        k (`~.int`):
            (undocumented)

        AP (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        strideA (`~.int`):
            (undocumented)

        x (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        stridex (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")                    
    if not isinstance(transA,_hipblasOperation_t__Base):
        raise TypeError("argument 'transA' must be of type '_hipblasOperation_t__Base'")                    
    if not isinstance(diag,_hipblasDiagType_t__Base):
        raise TypeError("argument 'diag' must be of type '_hipblasDiagType_t__Base'")
    _hipblasStbmvStridedBatched_64__retval = hipblasStatus_t(chipblas.hipblasStbmvStridedBatched_64(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,uplo.value,transA.value,diag.value,n,k,
        <const float *>hip._util.types.Pointer.fromPyobj(AP)._ptr,lda,strideA,
        <float *>hip._util.types.Pointer.fromPyobj(x)._ptr,incx,stridex,batchCount))
    return (_hipblasStbmvStridedBatched_64__retval,)


@cython.embedsignature(True)
def hipblasDtbmvStridedBatched_64(object handle, object uplo, object transA, object diag, long n, long k, object AP, long lda, long strideA, object x, long incx, long stridex, long batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        uplo (`~.hipblasFillMode_t`):
            (undocumented)

        transA (`~.hipblasOperation_t`):
            (undocumented)

        diag (`~.hipblasDiagType_t`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        k (`~.int`):
            (undocumented)

        AP (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        strideA (`~.int`):
            (undocumented)

        x (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        stridex (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")                    
    if not isinstance(transA,_hipblasOperation_t__Base):
        raise TypeError("argument 'transA' must be of type '_hipblasOperation_t__Base'")                    
    if not isinstance(diag,_hipblasDiagType_t__Base):
        raise TypeError("argument 'diag' must be of type '_hipblasDiagType_t__Base'")
    _hipblasDtbmvStridedBatched_64__retval = hipblasStatus_t(chipblas.hipblasDtbmvStridedBatched_64(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,uplo.value,transA.value,diag.value,n,k,
        <const double *>hip._util.types.Pointer.fromPyobj(AP)._ptr,lda,strideA,
        <double *>hip._util.types.Pointer.fromPyobj(x)._ptr,incx,stridex,batchCount))
    return (_hipblasDtbmvStridedBatched_64__retval,)


@cython.embedsignature(True)
def hipblasCtbmvStridedBatched_64(object handle, object uplo, object transA, object diag, long n, long k, object AP, long lda, long strideA, object x, long incx, long stridex, long batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        uplo (`~.hipblasFillMode_t`):
            (undocumented)

        transA (`~.hipblasOperation_t`):
            (undocumented)

        diag (`~.hipblasDiagType_t`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        k (`~.int`):
            (undocumented)

        AP (`~.hipblasComplex`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        strideA (`~.int`):
            (undocumented)

        x (`~.hipblasComplex`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        stridex (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")                    
    if not isinstance(transA,_hipblasOperation_t__Base):
        raise TypeError("argument 'transA' must be of type '_hipblasOperation_t__Base'")                    
    if not isinstance(diag,_hipblasDiagType_t__Base):
        raise TypeError("argument 'diag' must be of type '_hipblasDiagType_t__Base'")
    _hipblasCtbmvStridedBatched_64__retval = hipblasStatus_t(chipblas.hipblasCtbmvStridedBatched_64(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,uplo.value,transA.value,diag.value,n,k,
        hipblasComplex.fromPyobj(AP).getElementPtr(),lda,strideA,
        hipblasComplex.fromPyobj(x).getElementPtr(),incx,stridex,batchCount))
    return (_hipblasCtbmvStridedBatched_64__retval,)


@cython.embedsignature(True)
def hipblasZtbmvStridedBatched_64(object handle, object uplo, object transA, object diag, long n, long k, object AP, long lda, long strideA, object x, long incx, long stridex, long batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        uplo (`~.hipblasFillMode_t`):
            (undocumented)

        transA (`~.hipblasOperation_t`):
            (undocumented)

        diag (`~.hipblasDiagType_t`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        k (`~.int`):
            (undocumented)

        AP (`~.hipblasDoubleComplex`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        strideA (`~.int`):
            (undocumented)

        x (`~.hipblasDoubleComplex`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        stridex (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")                    
    if not isinstance(transA,_hipblasOperation_t__Base):
        raise TypeError("argument 'transA' must be of type '_hipblasOperation_t__Base'")                    
    if not isinstance(diag,_hipblasDiagType_t__Base):
        raise TypeError("argument 'diag' must be of type '_hipblasDiagType_t__Base'")
    _hipblasZtbmvStridedBatched_64__retval = hipblasStatus_t(chipblas.hipblasZtbmvStridedBatched_64(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,uplo.value,transA.value,diag.value,n,k,
        hipblasDoubleComplex.fromPyobj(AP).getElementPtr(),lda,strideA,
        hipblasDoubleComplex.fromPyobj(x).getElementPtr(),incx,stridex,batchCount))
    return (_hipblasZtbmvStridedBatched_64__retval,)


@cython.embedsignature(True)
def hipblasCtbmvStridedBatched_v2_64(object handle, object uplo, object transA, object diag, long n, long k, object AP, long lda, long strideA, object x, long incx, long stridex, long batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        uplo (`~.hipblasFillMode_t`):
            (undocumented)

        transA (`~.hipblasOperation_t`):
            (undocumented)

        diag (`~.hipblasDiagType_t`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        k (`~.int`):
            (undocumented)

        AP (`~.float2`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        strideA (`~.int`):
            (undocumented)

        x (`~.float2`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        stridex (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")                    
    if not isinstance(transA,_hipblasOperation_t__Base):
        raise TypeError("argument 'transA' must be of type '_hipblasOperation_t__Base'")                    
    if not isinstance(diag,_hipblasDiagType_t__Base):
        raise TypeError("argument 'diag' must be of type '_hipblasDiagType_t__Base'")
    _hipblasCtbmvStridedBatched_v2_64__retval = hipblasStatus_t(chipblas.hipblasCtbmvStridedBatched_v2_64(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,uplo.value,transA.value,diag.value,n,k,
        float2.fromPyobj(AP).getElementPtr(),lda,strideA,
        float2.fromPyobj(x).getElementPtr(),incx,stridex,batchCount))
    return (_hipblasCtbmvStridedBatched_v2_64__retval,)


@cython.embedsignature(True)
def hipblasZtbmvStridedBatched_v2_64(object handle, object uplo, object transA, object diag, long n, long k, object AP, long lda, long strideA, object x, long incx, long stridex, long batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        uplo (`~.hipblasFillMode_t`):
            (undocumented)

        transA (`~.hipblasOperation_t`):
            (undocumented)

        diag (`~.hipblasDiagType_t`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        k (`~.int`):
            (undocumented)

        AP (`~.double2`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        strideA (`~.int`):
            (undocumented)

        x (`~.double2`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        stridex (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")                    
    if not isinstance(transA,_hipblasOperation_t__Base):
        raise TypeError("argument 'transA' must be of type '_hipblasOperation_t__Base'")                    
    if not isinstance(diag,_hipblasDiagType_t__Base):
        raise TypeError("argument 'diag' must be of type '_hipblasDiagType_t__Base'")
    _hipblasZtbmvStridedBatched_v2_64__retval = hipblasStatus_t(chipblas.hipblasZtbmvStridedBatched_v2_64(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,uplo.value,transA.value,diag.value,n,k,
        double2.fromPyobj(AP).getElementPtr(),lda,strideA,
        double2.fromPyobj(x).getElementPtr(),incx,stridex,batchCount))
    return (_hipblasZtbmvStridedBatched_v2_64__retval,)


@cython.embedsignature(True)
def hipblasStbsv(object handle, object uplo, object transA, object diag, int n, int k, object AP, int lda, object x, int incx):
    r"""BLAS Level 2 API

    @{

    tbsv solves

    A*x = b or A**T*x = b or A**H*x = b,

    where x and b are vectors and A is a banded triangular matrix.

    - Supported precisions in rocBLAS : s,d,c,z
    - Supported precisions in cuBLAS  : s,d,c,z

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`) -- *IN*:
            [hipblasHandle_t]
            handle to the hipblas library context queue.

        uplo (`~.hipblasFillMode_t`) -- *IN*:
            [hipblasFillMode_t]
            HIPBLAS_FILL_MODE_UPPER:  A is an upper triangular matrix.
            HIPBLAS_FILL_MODE_LOWER:  A is a  lower triangular matrix.

        transA (`~.hipblasOperation_t`) -- *IN*:
            [hipblasOperation_t]
            HIPBLAS_OP_N: Solves A*x = b
            HIPBLAS_OP_T: Solves A**T*x = b
            HIPBLAS_OP_C: Solves A**H*x = b

        diag (`~.hipblasDiagType_t`) -- *IN*:
            [hipblasDiagType_t]
            HIPBLAS_DIAG_UNIT:     A is assumed to be unit triangular (i.e. the diagonal elements
                                       of A are not used in computations).
            HIPBLAS_DIAG_NON_UNIT: A is not assumed to be unit triangular.

        n (`~.int`) -- *IN*:
            [int]
            n specifies the number of rows of b. n >= 0.

        k (`~.int`) -- *IN*:
            [int]
            if(uplo == HIPBLAS_FILL_MODE_UPPER)
              k specifies the number of super-diagonals of A.
            if(uplo == HIPBLAS_FILL_MODE_LOWER)
              k specifies the number of sub-diagonals of A.
            k >= 0.

        AP (`~.hip._util.types.Pointer`/`~.object`) -- *IN*:
            device pointer storing the matrix A in banded format.

        lda (`~.int`) -- *IN*:
            [int]
            specifies the leading dimension of A.
            lda >= (k + 1).

        x (`~.hip._util.types.Pointer`/`~.object`) -- *INOUT*:
            device pointer storing input vector b. Overwritten by the output vector x.

        incx (`~.int`) -- *IN*:
            [int]
            specifies the increment for the elements of x.
    """
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")                    
    if not isinstance(transA,_hipblasOperation_t__Base):
        raise TypeError("argument 'transA' must be of type '_hipblasOperation_t__Base'")                    
    if not isinstance(diag,_hipblasDiagType_t__Base):
        raise TypeError("argument 'diag' must be of type '_hipblasDiagType_t__Base'")
    _hipblasStbsv__retval = hipblasStatus_t(chipblas.hipblasStbsv(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,uplo.value,transA.value,diag.value,n,k,
        <const float *>hip._util.types.Pointer.fromPyobj(AP)._ptr,lda,
        <float *>hip._util.types.Pointer.fromPyobj(x)._ptr,incx))
    return (_hipblasStbsv__retval,)


@cython.embedsignature(True)
def hipblasDtbsv(object handle, object uplo, object transA, object diag, int n, int k, object AP, int lda, object x, int incx):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        uplo (`~.hipblasFillMode_t`):
            (undocumented)

        transA (`~.hipblasOperation_t`):
            (undocumented)

        diag (`~.hipblasDiagType_t`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        k (`~.int`):
            (undocumented)

        AP (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        x (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)
    """
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")                    
    if not isinstance(transA,_hipblasOperation_t__Base):
        raise TypeError("argument 'transA' must be of type '_hipblasOperation_t__Base'")                    
    if not isinstance(diag,_hipblasDiagType_t__Base):
        raise TypeError("argument 'diag' must be of type '_hipblasDiagType_t__Base'")
    _hipblasDtbsv__retval = hipblasStatus_t(chipblas.hipblasDtbsv(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,uplo.value,transA.value,diag.value,n,k,
        <const double *>hip._util.types.Pointer.fromPyobj(AP)._ptr,lda,
        <double *>hip._util.types.Pointer.fromPyobj(x)._ptr,incx))
    return (_hipblasDtbsv__retval,)


@cython.embedsignature(True)
def hipblasCtbsv(object handle, object uplo, object transA, object diag, int n, int k, object AP, int lda, object x, int incx):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        uplo (`~.hipblasFillMode_t`):
            (undocumented)

        transA (`~.hipblasOperation_t`):
            (undocumented)

        diag (`~.hipblasDiagType_t`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        k (`~.int`):
            (undocumented)

        AP (`~.hipblasComplex`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        x (`~.hipblasComplex`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)
    """
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")                    
    if not isinstance(transA,_hipblasOperation_t__Base):
        raise TypeError("argument 'transA' must be of type '_hipblasOperation_t__Base'")                    
    if not isinstance(diag,_hipblasDiagType_t__Base):
        raise TypeError("argument 'diag' must be of type '_hipblasDiagType_t__Base'")
    _hipblasCtbsv__retval = hipblasStatus_t(chipblas.hipblasCtbsv(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,uplo.value,transA.value,diag.value,n,k,
        hipblasComplex.fromPyobj(AP).getElementPtr(),lda,
        hipblasComplex.fromPyobj(x).getElementPtr(),incx))
    return (_hipblasCtbsv__retval,)


@cython.embedsignature(True)
def hipblasZtbsv(object handle, object uplo, object transA, object diag, int n, int k, object AP, int lda, object x, int incx):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        uplo (`~.hipblasFillMode_t`):
            (undocumented)

        transA (`~.hipblasOperation_t`):
            (undocumented)

        diag (`~.hipblasDiagType_t`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        k (`~.int`):
            (undocumented)

        AP (`~.hipblasDoubleComplex`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        x (`~.hipblasDoubleComplex`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)
    """
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")                    
    if not isinstance(transA,_hipblasOperation_t__Base):
        raise TypeError("argument 'transA' must be of type '_hipblasOperation_t__Base'")                    
    if not isinstance(diag,_hipblasDiagType_t__Base):
        raise TypeError("argument 'diag' must be of type '_hipblasDiagType_t__Base'")
    _hipblasZtbsv__retval = hipblasStatus_t(chipblas.hipblasZtbsv(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,uplo.value,transA.value,diag.value,n,k,
        hipblasDoubleComplex.fromPyobj(AP).getElementPtr(),lda,
        hipblasDoubleComplex.fromPyobj(x).getElementPtr(),incx))
    return (_hipblasZtbsv__retval,)


@cython.embedsignature(True)
def hipblasCtbsv_v2(object handle, object uplo, object transA, object diag, int n, int k, object AP, int lda, object x, int incx):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        uplo (`~.hipblasFillMode_t`):
            (undocumented)

        transA (`~.hipblasOperation_t`):
            (undocumented)

        diag (`~.hipblasDiagType_t`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        k (`~.int`):
            (undocumented)

        AP (`~.float2`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        x (`~.float2`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)
    """
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")                    
    if not isinstance(transA,_hipblasOperation_t__Base):
        raise TypeError("argument 'transA' must be of type '_hipblasOperation_t__Base'")                    
    if not isinstance(diag,_hipblasDiagType_t__Base):
        raise TypeError("argument 'diag' must be of type '_hipblasDiagType_t__Base'")
    _hipblasCtbsv_v2__retval = hipblasStatus_t(chipblas.hipblasCtbsv_v2(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,uplo.value,transA.value,diag.value,n,k,
        float2.fromPyobj(AP).getElementPtr(),lda,
        float2.fromPyobj(x).getElementPtr(),incx))
    return (_hipblasCtbsv_v2__retval,)


@cython.embedsignature(True)
def hipblasZtbsv_v2(object handle, object uplo, object transA, object diag, int n, int k, object AP, int lda, object x, int incx):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        uplo (`~.hipblasFillMode_t`):
            (undocumented)

        transA (`~.hipblasOperation_t`):
            (undocumented)

        diag (`~.hipblasDiagType_t`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        k (`~.int`):
            (undocumented)

        AP (`~.double2`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        x (`~.double2`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)
    """
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")                    
    if not isinstance(transA,_hipblasOperation_t__Base):
        raise TypeError("argument 'transA' must be of type '_hipblasOperation_t__Base'")                    
    if not isinstance(diag,_hipblasDiagType_t__Base):
        raise TypeError("argument 'diag' must be of type '_hipblasDiagType_t__Base'")
    _hipblasZtbsv_v2__retval = hipblasStatus_t(chipblas.hipblasZtbsv_v2(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,uplo.value,transA.value,diag.value,n,k,
        double2.fromPyobj(AP).getElementPtr(),lda,
        double2.fromPyobj(x).getElementPtr(),incx))
    return (_hipblasZtbsv_v2__retval,)


@cython.embedsignature(True)
def hipblasStbsv_64(object handle, object uplo, object transA, object diag, long n, long k, object AP, long lda, object x, long incx):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        uplo (`~.hipblasFillMode_t`):
            (undocumented)

        transA (`~.hipblasOperation_t`):
            (undocumented)

        diag (`~.hipblasDiagType_t`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        k (`~.int`):
            (undocumented)

        AP (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        x (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)
    """
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")                    
    if not isinstance(transA,_hipblasOperation_t__Base):
        raise TypeError("argument 'transA' must be of type '_hipblasOperation_t__Base'")                    
    if not isinstance(diag,_hipblasDiagType_t__Base):
        raise TypeError("argument 'diag' must be of type '_hipblasDiagType_t__Base'")
    _hipblasStbsv_64__retval = hipblasStatus_t(chipblas.hipblasStbsv_64(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,uplo.value,transA.value,diag.value,n,k,
        <const float *>hip._util.types.Pointer.fromPyobj(AP)._ptr,lda,
        <float *>hip._util.types.Pointer.fromPyobj(x)._ptr,incx))
    return (_hipblasStbsv_64__retval,)


@cython.embedsignature(True)
def hipblasDtbsv_64(object handle, object uplo, object transA, object diag, long n, long k, object AP, long lda, object x, long incx):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        uplo (`~.hipblasFillMode_t`):
            (undocumented)

        transA (`~.hipblasOperation_t`):
            (undocumented)

        diag (`~.hipblasDiagType_t`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        k (`~.int`):
            (undocumented)

        AP (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        x (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)
    """
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")                    
    if not isinstance(transA,_hipblasOperation_t__Base):
        raise TypeError("argument 'transA' must be of type '_hipblasOperation_t__Base'")                    
    if not isinstance(diag,_hipblasDiagType_t__Base):
        raise TypeError("argument 'diag' must be of type '_hipblasDiagType_t__Base'")
    _hipblasDtbsv_64__retval = hipblasStatus_t(chipblas.hipblasDtbsv_64(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,uplo.value,transA.value,diag.value,n,k,
        <const double *>hip._util.types.Pointer.fromPyobj(AP)._ptr,lda,
        <double *>hip._util.types.Pointer.fromPyobj(x)._ptr,incx))
    return (_hipblasDtbsv_64__retval,)


@cython.embedsignature(True)
def hipblasCtbsv_64(object handle, object uplo, object transA, object diag, long n, long k, object AP, long lda, object x, long incx):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        uplo (`~.hipblasFillMode_t`):
            (undocumented)

        transA (`~.hipblasOperation_t`):
            (undocumented)

        diag (`~.hipblasDiagType_t`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        k (`~.int`):
            (undocumented)

        AP (`~.hipblasComplex`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        x (`~.hipblasComplex`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)
    """
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")                    
    if not isinstance(transA,_hipblasOperation_t__Base):
        raise TypeError("argument 'transA' must be of type '_hipblasOperation_t__Base'")                    
    if not isinstance(diag,_hipblasDiagType_t__Base):
        raise TypeError("argument 'diag' must be of type '_hipblasDiagType_t__Base'")
    _hipblasCtbsv_64__retval = hipblasStatus_t(chipblas.hipblasCtbsv_64(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,uplo.value,transA.value,diag.value,n,k,
        hipblasComplex.fromPyobj(AP).getElementPtr(),lda,
        hipblasComplex.fromPyobj(x).getElementPtr(),incx))
    return (_hipblasCtbsv_64__retval,)


@cython.embedsignature(True)
def hipblasZtbsv_64(object handle, object uplo, object transA, object diag, long n, long k, object AP, long lda, object x, long incx):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        uplo (`~.hipblasFillMode_t`):
            (undocumented)

        transA (`~.hipblasOperation_t`):
            (undocumented)

        diag (`~.hipblasDiagType_t`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        k (`~.int`):
            (undocumented)

        AP (`~.hipblasDoubleComplex`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        x (`~.hipblasDoubleComplex`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)
    """
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")                    
    if not isinstance(transA,_hipblasOperation_t__Base):
        raise TypeError("argument 'transA' must be of type '_hipblasOperation_t__Base'")                    
    if not isinstance(diag,_hipblasDiagType_t__Base):
        raise TypeError("argument 'diag' must be of type '_hipblasDiagType_t__Base'")
    _hipblasZtbsv_64__retval = hipblasStatus_t(chipblas.hipblasZtbsv_64(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,uplo.value,transA.value,diag.value,n,k,
        hipblasDoubleComplex.fromPyobj(AP).getElementPtr(),lda,
        hipblasDoubleComplex.fromPyobj(x).getElementPtr(),incx))
    return (_hipblasZtbsv_64__retval,)


@cython.embedsignature(True)
def hipblasCtbsv_v2_64(object handle, object uplo, object transA, object diag, long n, long k, object AP, long lda, object x, long incx):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        uplo (`~.hipblasFillMode_t`):
            (undocumented)

        transA (`~.hipblasOperation_t`):
            (undocumented)

        diag (`~.hipblasDiagType_t`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        k (`~.int`):
            (undocumented)

        AP (`~.float2`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        x (`~.float2`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)
    """
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")                    
    if not isinstance(transA,_hipblasOperation_t__Base):
        raise TypeError("argument 'transA' must be of type '_hipblasOperation_t__Base'")                    
    if not isinstance(diag,_hipblasDiagType_t__Base):
        raise TypeError("argument 'diag' must be of type '_hipblasDiagType_t__Base'")
    _hipblasCtbsv_v2_64__retval = hipblasStatus_t(chipblas.hipblasCtbsv_v2_64(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,uplo.value,transA.value,diag.value,n,k,
        float2.fromPyobj(AP).getElementPtr(),lda,
        float2.fromPyobj(x).getElementPtr(),incx))
    return (_hipblasCtbsv_v2_64__retval,)


@cython.embedsignature(True)
def hipblasZtbsv_v2_64(object handle, object uplo, object transA, object diag, long n, long k, object AP, long lda, object x, long incx):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        uplo (`~.hipblasFillMode_t`):
            (undocumented)

        transA (`~.hipblasOperation_t`):
            (undocumented)

        diag (`~.hipblasDiagType_t`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        k (`~.int`):
            (undocumented)

        AP (`~.double2`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        x (`~.double2`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)
    """
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")                    
    if not isinstance(transA,_hipblasOperation_t__Base):
        raise TypeError("argument 'transA' must be of type '_hipblasOperation_t__Base'")                    
    if not isinstance(diag,_hipblasDiagType_t__Base):
        raise TypeError("argument 'diag' must be of type '_hipblasDiagType_t__Base'")
    _hipblasZtbsv_v2_64__retval = hipblasStatus_t(chipblas.hipblasZtbsv_v2_64(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,uplo.value,transA.value,diag.value,n,k,
        double2.fromPyobj(AP).getElementPtr(),lda,
        double2.fromPyobj(x).getElementPtr(),incx))
    return (_hipblasZtbsv_v2_64__retval,)


@cython.embedsignature(True)
def hipblasStbsvBatched(object handle, object uplo, object transA, object diag, int n, int k, object AP, int lda, object x, int incx, int batchCount):
    r"""BLAS Level 2 API

    @{

    tbsvBatched solves

    A_i*x_i = b_i or A_i**T*x_i = b_i or A_i**H*x_i = b_i,

    where x_i and b_i are vectors and A_i is a banded triangular matrix,
    for i = [1, batchCount].

    The input vectors b_i are overwritten by the output vectors x_i.

    - Supported precisions in rocBLAS : s,d,c,z
    - Supported precisions in cuBLAS  : No support

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`) -- *IN*:
            [hipblasHandle_t]
            handle to the hipblas library context queue.

        uplo (`~.hipblasFillMode_t`) -- *IN*:
            [hipblasFillMode_t]
            HIPBLAS_FILL_MODE_UPPER:  A_i is an upper triangular matrix.
            HIPBLAS_FILL_MODE_LOWER:  A_i is a  lower triangular matrix.

        transA (`~.hipblasOperation_t`) -- *IN*:
            [hipblasOperation_t]
            HIPBLAS_OP_N: Solves A_i*x_i = b_i
            HIPBLAS_OP_T: Solves A_i**T*x_i = b_i
            HIPBLAS_OP_C: Solves A_i**H*x_i = b_i

        diag (`~.hipblasDiagType_t`) -- *IN*:
            [hipblasDiagType_t]
            HIPBLAS_DIAG_UNIT:     each A_i is assumed to be unit triangular (i.e. the diagonal elements
                                       of each A_i are not used in computations).
            HIPBLAS_DIAG_NON_UNIT: each A_i is not assumed to be unit triangular.

        n (`~.int`) -- *IN*:
            [int]
            n specifies the number of rows of each b_i. n >= 0.

        k (`~.int`) -- *IN*:
            [int]
            if(uplo == HIPBLAS_FILL_MODE_UPPER)
              k specifies the number of super-diagonals of each A_i.
            if(uplo == HIPBLAS_FILL_MODE_LOWER)
              k specifies the number of sub-diagonals of each A_i.
            k >= 0.

        AP (`~.hip._util.types.Pointer`/`~.object`) -- *IN*:
            device vector of device pointers storing each matrix A_i in banded format.

        lda (`~.int`) -- *IN*:
            [int]
            specifies the leading dimension of each A_i.
            lda >= (k + 1).

        x (`~.hip._util.types.ListOfPointer`/`~.object`) -- *INOUT*:
            device vector of device pointers storing each input vector b_i. Overwritten by each output
            vector x_i.

        incx (`~.int`) -- *IN*:
            [int]
            specifies the increment for the elements of each x_i.

        batchCount (`~.int`) -- *IN*:
            [int]
            number of instances in the batch.
    """
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")                    
    if not isinstance(transA,_hipblasOperation_t__Base):
        raise TypeError("argument 'transA' must be of type '_hipblasOperation_t__Base'")                    
    if not isinstance(diag,_hipblasDiagType_t__Base):
        raise TypeError("argument 'diag' must be of type '_hipblasDiagType_t__Base'")
    _hipblasStbsvBatched__retval = hipblasStatus_t(chipblas.hipblasStbsvBatched(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,uplo.value,transA.value,diag.value,n,k,
        <const float *const*>hip._util.types.Pointer.fromPyobj(AP)._ptr,lda,
        <float *const*>hip._util.types.ListOfPointer.fromPyobj(x)._ptr,incx,batchCount))
    return (_hipblasStbsvBatched__retval,)


@cython.embedsignature(True)
def hipblasDtbsvBatched(object handle, object uplo, object transA, object diag, int n, int k, object AP, int lda, object x, int incx, int batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        uplo (`~.hipblasFillMode_t`):
            (undocumented)

        transA (`~.hipblasOperation_t`):
            (undocumented)

        diag (`~.hipblasDiagType_t`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        k (`~.int`):
            (undocumented)

        AP (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        x (`~.hip._util.types.ListOfPointer`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")                    
    if not isinstance(transA,_hipblasOperation_t__Base):
        raise TypeError("argument 'transA' must be of type '_hipblasOperation_t__Base'")                    
    if not isinstance(diag,_hipblasDiagType_t__Base):
        raise TypeError("argument 'diag' must be of type '_hipblasDiagType_t__Base'")
    _hipblasDtbsvBatched__retval = hipblasStatus_t(chipblas.hipblasDtbsvBatched(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,uplo.value,transA.value,diag.value,n,k,
        <const double *const*>hip._util.types.Pointer.fromPyobj(AP)._ptr,lda,
        <double *const*>hip._util.types.ListOfPointer.fromPyobj(x)._ptr,incx,batchCount))
    return (_hipblasDtbsvBatched__retval,)


@cython.embedsignature(True)
def hipblasCtbsvBatched(object handle, object uplo, object transA, object diag, int n, int k, object AP, int lda, object x, int incx, int batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        uplo (`~.hipblasFillMode_t`):
            (undocumented)

        transA (`~.hipblasOperation_t`):
            (undocumented)

        diag (`~.hipblasDiagType_t`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        k (`~.int`):
            (undocumented)

        AP (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        x (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")                    
    if not isinstance(transA,_hipblasOperation_t__Base):
        raise TypeError("argument 'transA' must be of type '_hipblasOperation_t__Base'")                    
    if not isinstance(diag,_hipblasDiagType_t__Base):
        raise TypeError("argument 'diag' must be of type '_hipblasDiagType_t__Base'")
    _hipblasCtbsvBatched__retval = hipblasStatus_t(chipblas.hipblasCtbsvBatched(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,uplo.value,transA.value,diag.value,n,k,
        <chipblas.hipblasComplex *const*>hip._util.types.Pointer.fromPyobj(AP)._ptr,lda,
        <chipblas.hipblasComplex *const*>hip._util.types.Pointer.fromPyobj(x)._ptr,incx,batchCount))
    return (_hipblasCtbsvBatched__retval,)


@cython.embedsignature(True)
def hipblasZtbsvBatched(object handle, object uplo, object transA, object diag, int n, int k, object AP, int lda, object x, int incx, int batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        uplo (`~.hipblasFillMode_t`):
            (undocumented)

        transA (`~.hipblasOperation_t`):
            (undocumented)

        diag (`~.hipblasDiagType_t`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        k (`~.int`):
            (undocumented)

        AP (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        x (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")                    
    if not isinstance(transA,_hipblasOperation_t__Base):
        raise TypeError("argument 'transA' must be of type '_hipblasOperation_t__Base'")                    
    if not isinstance(diag,_hipblasDiagType_t__Base):
        raise TypeError("argument 'diag' must be of type '_hipblasDiagType_t__Base'")
    _hipblasZtbsvBatched__retval = hipblasStatus_t(chipblas.hipblasZtbsvBatched(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,uplo.value,transA.value,diag.value,n,k,
        <chipblas.hipblasDoubleComplex *const*>hip._util.types.Pointer.fromPyobj(AP)._ptr,lda,
        <chipblas.hipblasDoubleComplex *const*>hip._util.types.Pointer.fromPyobj(x)._ptr,incx,batchCount))
    return (_hipblasZtbsvBatched__retval,)


@cython.embedsignature(True)
def hipblasCtbsvBatched_v2(object handle, object uplo, object transA, object diag, int n, int k, object AP, int lda, object x, int incx, int batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        uplo (`~.hipblasFillMode_t`):
            (undocumented)

        transA (`~.hipblasOperation_t`):
            (undocumented)

        diag (`~.hipblasDiagType_t`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        k (`~.int`):
            (undocumented)

        AP (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        x (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")                    
    if not isinstance(transA,_hipblasOperation_t__Base):
        raise TypeError("argument 'transA' must be of type '_hipblasOperation_t__Base'")                    
    if not isinstance(diag,_hipblasDiagType_t__Base):
        raise TypeError("argument 'diag' must be of type '_hipblasDiagType_t__Base'")
    _hipblasCtbsvBatched_v2__retval = hipblasStatus_t(chipblas.hipblasCtbsvBatched_v2(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,uplo.value,transA.value,diag.value,n,k,
        <chipblas.float2 *const*>hip._util.types.Pointer.fromPyobj(AP)._ptr,lda,
        <chipblas.float2 *const*>hip._util.types.Pointer.fromPyobj(x)._ptr,incx,batchCount))
    return (_hipblasCtbsvBatched_v2__retval,)


@cython.embedsignature(True)
def hipblasZtbsvBatched_v2(object handle, object uplo, object transA, object diag, int n, int k, object AP, int lda, object x, int incx, int batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        uplo (`~.hipblasFillMode_t`):
            (undocumented)

        transA (`~.hipblasOperation_t`):
            (undocumented)

        diag (`~.hipblasDiagType_t`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        k (`~.int`):
            (undocumented)

        AP (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        x (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")                    
    if not isinstance(transA,_hipblasOperation_t__Base):
        raise TypeError("argument 'transA' must be of type '_hipblasOperation_t__Base'")                    
    if not isinstance(diag,_hipblasDiagType_t__Base):
        raise TypeError("argument 'diag' must be of type '_hipblasDiagType_t__Base'")
    _hipblasZtbsvBatched_v2__retval = hipblasStatus_t(chipblas.hipblasZtbsvBatched_v2(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,uplo.value,transA.value,diag.value,n,k,
        <chipblas.double2 *const*>hip._util.types.Pointer.fromPyobj(AP)._ptr,lda,
        <chipblas.double2 *const*>hip._util.types.Pointer.fromPyobj(x)._ptr,incx,batchCount))
    return (_hipblasZtbsvBatched_v2__retval,)


@cython.embedsignature(True)
def hipblasStbsvBatched_64(object handle, object uplo, object transA, object diag, long n, long k, object AP, long lda, object x, long incx, long batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        uplo (`~.hipblasFillMode_t`):
            (undocumented)

        transA (`~.hipblasOperation_t`):
            (undocumented)

        diag (`~.hipblasDiagType_t`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        k (`~.int`):
            (undocumented)

        AP (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        x (`~.hip._util.types.ListOfPointer`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")                    
    if not isinstance(transA,_hipblasOperation_t__Base):
        raise TypeError("argument 'transA' must be of type '_hipblasOperation_t__Base'")                    
    if not isinstance(diag,_hipblasDiagType_t__Base):
        raise TypeError("argument 'diag' must be of type '_hipblasDiagType_t__Base'")
    _hipblasStbsvBatched_64__retval = hipblasStatus_t(chipblas.hipblasStbsvBatched_64(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,uplo.value,transA.value,diag.value,n,k,
        <const float *const*>hip._util.types.Pointer.fromPyobj(AP)._ptr,lda,
        <float *const*>hip._util.types.ListOfPointer.fromPyobj(x)._ptr,incx,batchCount))
    return (_hipblasStbsvBatched_64__retval,)


@cython.embedsignature(True)
def hipblasDtbsvBatched_64(object handle, object uplo, object transA, object diag, long n, long k, object AP, long lda, object x, long incx, long batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        uplo (`~.hipblasFillMode_t`):
            (undocumented)

        transA (`~.hipblasOperation_t`):
            (undocumented)

        diag (`~.hipblasDiagType_t`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        k (`~.int`):
            (undocumented)

        AP (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        x (`~.hip._util.types.ListOfPointer`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")                    
    if not isinstance(transA,_hipblasOperation_t__Base):
        raise TypeError("argument 'transA' must be of type '_hipblasOperation_t__Base'")                    
    if not isinstance(diag,_hipblasDiagType_t__Base):
        raise TypeError("argument 'diag' must be of type '_hipblasDiagType_t__Base'")
    _hipblasDtbsvBatched_64__retval = hipblasStatus_t(chipblas.hipblasDtbsvBatched_64(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,uplo.value,transA.value,diag.value,n,k,
        <const double *const*>hip._util.types.Pointer.fromPyobj(AP)._ptr,lda,
        <double *const*>hip._util.types.ListOfPointer.fromPyobj(x)._ptr,incx,batchCount))
    return (_hipblasDtbsvBatched_64__retval,)


@cython.embedsignature(True)
def hipblasCtbsvBatched_64(object handle, object uplo, object transA, object diag, long n, long k, object AP, long lda, object x, long incx, long batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        uplo (`~.hipblasFillMode_t`):
            (undocumented)

        transA (`~.hipblasOperation_t`):
            (undocumented)

        diag (`~.hipblasDiagType_t`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        k (`~.int`):
            (undocumented)

        AP (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        x (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")                    
    if not isinstance(transA,_hipblasOperation_t__Base):
        raise TypeError("argument 'transA' must be of type '_hipblasOperation_t__Base'")                    
    if not isinstance(diag,_hipblasDiagType_t__Base):
        raise TypeError("argument 'diag' must be of type '_hipblasDiagType_t__Base'")
    _hipblasCtbsvBatched_64__retval = hipblasStatus_t(chipblas.hipblasCtbsvBatched_64(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,uplo.value,transA.value,diag.value,n,k,
        <chipblas.hipblasComplex *const*>hip._util.types.Pointer.fromPyobj(AP)._ptr,lda,
        <chipblas.hipblasComplex *const*>hip._util.types.Pointer.fromPyobj(x)._ptr,incx,batchCount))
    return (_hipblasCtbsvBatched_64__retval,)


@cython.embedsignature(True)
def hipblasZtbsvBatched_64(object handle, object uplo, object transA, object diag, long n, long k, object AP, long lda, object x, long incx, long batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        uplo (`~.hipblasFillMode_t`):
            (undocumented)

        transA (`~.hipblasOperation_t`):
            (undocumented)

        diag (`~.hipblasDiagType_t`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        k (`~.int`):
            (undocumented)

        AP (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        x (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")                    
    if not isinstance(transA,_hipblasOperation_t__Base):
        raise TypeError("argument 'transA' must be of type '_hipblasOperation_t__Base'")                    
    if not isinstance(diag,_hipblasDiagType_t__Base):
        raise TypeError("argument 'diag' must be of type '_hipblasDiagType_t__Base'")
    _hipblasZtbsvBatched_64__retval = hipblasStatus_t(chipblas.hipblasZtbsvBatched_64(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,uplo.value,transA.value,diag.value,n,k,
        <chipblas.hipblasDoubleComplex *const*>hip._util.types.Pointer.fromPyobj(AP)._ptr,lda,
        <chipblas.hipblasDoubleComplex *const*>hip._util.types.Pointer.fromPyobj(x)._ptr,incx,batchCount))
    return (_hipblasZtbsvBatched_64__retval,)


@cython.embedsignature(True)
def hipblasCtbsvBatched_v2_64(object handle, object uplo, object transA, object diag, long n, long k, object AP, long lda, object x, long incx, long batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        uplo (`~.hipblasFillMode_t`):
            (undocumented)

        transA (`~.hipblasOperation_t`):
            (undocumented)

        diag (`~.hipblasDiagType_t`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        k (`~.int`):
            (undocumented)

        AP (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        x (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")                    
    if not isinstance(transA,_hipblasOperation_t__Base):
        raise TypeError("argument 'transA' must be of type '_hipblasOperation_t__Base'")                    
    if not isinstance(diag,_hipblasDiagType_t__Base):
        raise TypeError("argument 'diag' must be of type '_hipblasDiagType_t__Base'")
    _hipblasCtbsvBatched_v2_64__retval = hipblasStatus_t(chipblas.hipblasCtbsvBatched_v2_64(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,uplo.value,transA.value,diag.value,n,k,
        <chipblas.float2 *const*>hip._util.types.Pointer.fromPyobj(AP)._ptr,lda,
        <chipblas.float2 *const*>hip._util.types.Pointer.fromPyobj(x)._ptr,incx,batchCount))
    return (_hipblasCtbsvBatched_v2_64__retval,)


@cython.embedsignature(True)
def hipblasZtbsvBatched_v2_64(object handle, object uplo, object transA, object diag, long n, long k, object AP, long lda, object x, long incx, long batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        uplo (`~.hipblasFillMode_t`):
            (undocumented)

        transA (`~.hipblasOperation_t`):
            (undocumented)

        diag (`~.hipblasDiagType_t`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        k (`~.int`):
            (undocumented)

        AP (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        x (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")                    
    if not isinstance(transA,_hipblasOperation_t__Base):
        raise TypeError("argument 'transA' must be of type '_hipblasOperation_t__Base'")                    
    if not isinstance(diag,_hipblasDiagType_t__Base):
        raise TypeError("argument 'diag' must be of type '_hipblasDiagType_t__Base'")
    _hipblasZtbsvBatched_v2_64__retval = hipblasStatus_t(chipblas.hipblasZtbsvBatched_v2_64(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,uplo.value,transA.value,diag.value,n,k,
        <chipblas.double2 *const*>hip._util.types.Pointer.fromPyobj(AP)._ptr,lda,
        <chipblas.double2 *const*>hip._util.types.Pointer.fromPyobj(x)._ptr,incx,batchCount))
    return (_hipblasZtbsvBatched_v2_64__retval,)


@cython.embedsignature(True)
def hipblasStbsvStridedBatched(object handle, object uplo, object transA, object diag, int n, int k, object AP, int lda, long strideA, object x, int incx, long stridex, int batchCount):
    r"""BLAS Level 2 API

    @{

    tbsvStridedBatched solves

    A_i*x_i = b_i or A_i**T*x_i = b_i or A_i**H*x_i = b_i,

    where x_i and b_i are vectors and A_i is a banded triangular matrix,
    for i = [1, batchCount].

    The input vectors b_i are overwritten by the output vectors x_i.

    - Supported precisions in rocBLAS : s,d,c,z
    - Supported precisions in cuBLAS  : No support

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`) -- *IN*:
            [hipblasHandle_t]
            handle to the hipblas library context queue.

        uplo (`~.hipblasFillMode_t`) -- *IN*:
            [hipblasFillMode_t]
            HIPBLAS_FILL_MODE_UPPER:  A_i is an upper triangular matrix.
            HIPBLAS_FILL_MODE_LOWER:  A_i is a  lower triangular matrix.

        transA (`~.hipblasOperation_t`) -- *IN*:
            [hipblasOperation_t]
            HIPBLAS_OP_N: Solves A_i*x_i = b_i
            HIPBLAS_OP_T: Solves A_i**T*x_i = b_i
            HIPBLAS_OP_C: Solves A_i**H*x_i = b_i

        diag (`~.hipblasDiagType_t`) -- *IN*:
            [hipblasDiagType_t]
            HIPBLAS_DIAG_UNIT:     each A_i is assumed to be unit triangular (i.e. the diagonal elements
                                       of each A_i are not used in computations).
            HIPBLAS_DIAG_NON_UNIT: each A_i is not assumed to be unit triangular.

        n (`~.int`) -- *IN*:
            [int]
            n specifies the number of rows of each b_i. n >= 0.

        k (`~.int`) -- *IN*:
            [int]
            if(uplo == HIPBLAS_FILL_MODE_UPPER)
              k specifies the number of super-diagonals of each A_i.
            if(uplo == HIPBLAS_FILL_MODE_LOWER)
              k specifies the number of sub-diagonals of each A_i.
            k >= 0.

        AP (`~.hip._util.types.Pointer`/`~.object`) -- *IN*:
            device pointer pointing to the first banded matrix A_1.

        lda (`~.int`) -- *IN*:
            [int]
            specifies the leading dimension of each A_i.
            lda >= (k + 1).

        strideA (`~.int`) -- *IN*:
            [hipblasStride]
            specifies the distance between the start of one matrix (A_i) and the next (A_i+1).

        x (`~.hip._util.types.Pointer`/`~.object`) -- *INOUT*:
            device pointer pointing to the first input vector b_1. Overwritten by output vectors x.

        incx (`~.int`) -- *IN*:
            [int]
            specifies the increment for the elements of each x_i.

        stridex (`~.int`) -- *IN*:
            [hipblasStride]
            specifies the distance between the start of one vector (x_i) and the next (x_i+1).

        batchCount (`~.int`) -- *IN*:
            [int]
            number of instances in the batch.
    """
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")                    
    if not isinstance(transA,_hipblasOperation_t__Base):
        raise TypeError("argument 'transA' must be of type '_hipblasOperation_t__Base'")                    
    if not isinstance(diag,_hipblasDiagType_t__Base):
        raise TypeError("argument 'diag' must be of type '_hipblasDiagType_t__Base'")
    _hipblasStbsvStridedBatched__retval = hipblasStatus_t(chipblas.hipblasStbsvStridedBatched(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,uplo.value,transA.value,diag.value,n,k,
        <const float *>hip._util.types.Pointer.fromPyobj(AP)._ptr,lda,strideA,
        <float *>hip._util.types.Pointer.fromPyobj(x)._ptr,incx,stridex,batchCount))
    return (_hipblasStbsvStridedBatched__retval,)


@cython.embedsignature(True)
def hipblasDtbsvStridedBatched(object handle, object uplo, object transA, object diag, int n, int k, object AP, int lda, long strideA, object x, int incx, long stridex, int batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        uplo (`~.hipblasFillMode_t`):
            (undocumented)

        transA (`~.hipblasOperation_t`):
            (undocumented)

        diag (`~.hipblasDiagType_t`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        k (`~.int`):
            (undocumented)

        AP (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        strideA (`~.int`):
            (undocumented)

        x (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        stridex (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")                    
    if not isinstance(transA,_hipblasOperation_t__Base):
        raise TypeError("argument 'transA' must be of type '_hipblasOperation_t__Base'")                    
    if not isinstance(diag,_hipblasDiagType_t__Base):
        raise TypeError("argument 'diag' must be of type '_hipblasDiagType_t__Base'")
    _hipblasDtbsvStridedBatched__retval = hipblasStatus_t(chipblas.hipblasDtbsvStridedBatched(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,uplo.value,transA.value,diag.value,n,k,
        <const double *>hip._util.types.Pointer.fromPyobj(AP)._ptr,lda,strideA,
        <double *>hip._util.types.Pointer.fromPyobj(x)._ptr,incx,stridex,batchCount))
    return (_hipblasDtbsvStridedBatched__retval,)


@cython.embedsignature(True)
def hipblasCtbsvStridedBatched(object handle, object uplo, object transA, object diag, int n, int k, object AP, int lda, long strideA, object x, int incx, long stridex, int batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        uplo (`~.hipblasFillMode_t`):
            (undocumented)

        transA (`~.hipblasOperation_t`):
            (undocumented)

        diag (`~.hipblasDiagType_t`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        k (`~.int`):
            (undocumented)

        AP (`~.hipblasComplex`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        strideA (`~.int`):
            (undocumented)

        x (`~.hipblasComplex`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        stridex (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")                    
    if not isinstance(transA,_hipblasOperation_t__Base):
        raise TypeError("argument 'transA' must be of type '_hipblasOperation_t__Base'")                    
    if not isinstance(diag,_hipblasDiagType_t__Base):
        raise TypeError("argument 'diag' must be of type '_hipblasDiagType_t__Base'")
    _hipblasCtbsvStridedBatched__retval = hipblasStatus_t(chipblas.hipblasCtbsvStridedBatched(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,uplo.value,transA.value,diag.value,n,k,
        hipblasComplex.fromPyobj(AP).getElementPtr(),lda,strideA,
        hipblasComplex.fromPyobj(x).getElementPtr(),incx,stridex,batchCount))
    return (_hipblasCtbsvStridedBatched__retval,)


@cython.embedsignature(True)
def hipblasZtbsvStridedBatched(object handle, object uplo, object transA, object diag, int n, int k, object AP, int lda, long strideA, object x, int incx, long stridex, int batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        uplo (`~.hipblasFillMode_t`):
            (undocumented)

        transA (`~.hipblasOperation_t`):
            (undocumented)

        diag (`~.hipblasDiagType_t`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        k (`~.int`):
            (undocumented)

        AP (`~.hipblasDoubleComplex`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        strideA (`~.int`):
            (undocumented)

        x (`~.hipblasDoubleComplex`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        stridex (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")                    
    if not isinstance(transA,_hipblasOperation_t__Base):
        raise TypeError("argument 'transA' must be of type '_hipblasOperation_t__Base'")                    
    if not isinstance(diag,_hipblasDiagType_t__Base):
        raise TypeError("argument 'diag' must be of type '_hipblasDiagType_t__Base'")
    _hipblasZtbsvStridedBatched__retval = hipblasStatus_t(chipblas.hipblasZtbsvStridedBatched(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,uplo.value,transA.value,diag.value,n,k,
        hipblasDoubleComplex.fromPyobj(AP).getElementPtr(),lda,strideA,
        hipblasDoubleComplex.fromPyobj(x).getElementPtr(),incx,stridex,batchCount))
    return (_hipblasZtbsvStridedBatched__retval,)


@cython.embedsignature(True)
def hipblasCtbsvStridedBatched_v2(object handle, object uplo, object transA, object diag, int n, int k, object AP, int lda, long strideA, object x, int incx, long stridex, int batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        uplo (`~.hipblasFillMode_t`):
            (undocumented)

        transA (`~.hipblasOperation_t`):
            (undocumented)

        diag (`~.hipblasDiagType_t`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        k (`~.int`):
            (undocumented)

        AP (`~.float2`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        strideA (`~.int`):
            (undocumented)

        x (`~.float2`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        stridex (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")                    
    if not isinstance(transA,_hipblasOperation_t__Base):
        raise TypeError("argument 'transA' must be of type '_hipblasOperation_t__Base'")                    
    if not isinstance(diag,_hipblasDiagType_t__Base):
        raise TypeError("argument 'diag' must be of type '_hipblasDiagType_t__Base'")
    _hipblasCtbsvStridedBatched_v2__retval = hipblasStatus_t(chipblas.hipblasCtbsvStridedBatched_v2(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,uplo.value,transA.value,diag.value,n,k,
        float2.fromPyobj(AP).getElementPtr(),lda,strideA,
        float2.fromPyobj(x).getElementPtr(),incx,stridex,batchCount))
    return (_hipblasCtbsvStridedBatched_v2__retval,)


@cython.embedsignature(True)
def hipblasZtbsvStridedBatched_v2(object handle, object uplo, object transA, object diag, int n, int k, object AP, int lda, long strideA, object x, int incx, long stridex, int batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        uplo (`~.hipblasFillMode_t`):
            (undocumented)

        transA (`~.hipblasOperation_t`):
            (undocumented)

        diag (`~.hipblasDiagType_t`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        k (`~.int`):
            (undocumented)

        AP (`~.double2`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        strideA (`~.int`):
            (undocumented)

        x (`~.double2`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        stridex (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")                    
    if not isinstance(transA,_hipblasOperation_t__Base):
        raise TypeError("argument 'transA' must be of type '_hipblasOperation_t__Base'")                    
    if not isinstance(diag,_hipblasDiagType_t__Base):
        raise TypeError("argument 'diag' must be of type '_hipblasDiagType_t__Base'")
    _hipblasZtbsvStridedBatched_v2__retval = hipblasStatus_t(chipblas.hipblasZtbsvStridedBatched_v2(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,uplo.value,transA.value,diag.value,n,k,
        double2.fromPyobj(AP).getElementPtr(),lda,strideA,
        double2.fromPyobj(x).getElementPtr(),incx,stridex,batchCount))
    return (_hipblasZtbsvStridedBatched_v2__retval,)


@cython.embedsignature(True)
def hipblasStbsvStridedBatched_64(object handle, object uplo, object transA, object diag, long n, long k, object AP, long lda, long strideA, object x, long incx, long stridex, long batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        uplo (`~.hipblasFillMode_t`):
            (undocumented)

        transA (`~.hipblasOperation_t`):
            (undocumented)

        diag (`~.hipblasDiagType_t`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        k (`~.int`):
            (undocumented)

        AP (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        strideA (`~.int`):
            (undocumented)

        x (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        stridex (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")                    
    if not isinstance(transA,_hipblasOperation_t__Base):
        raise TypeError("argument 'transA' must be of type '_hipblasOperation_t__Base'")                    
    if not isinstance(diag,_hipblasDiagType_t__Base):
        raise TypeError("argument 'diag' must be of type '_hipblasDiagType_t__Base'")
    _hipblasStbsvStridedBatched_64__retval = hipblasStatus_t(chipblas.hipblasStbsvStridedBatched_64(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,uplo.value,transA.value,diag.value,n,k,
        <const float *>hip._util.types.Pointer.fromPyobj(AP)._ptr,lda,strideA,
        <float *>hip._util.types.Pointer.fromPyobj(x)._ptr,incx,stridex,batchCount))
    return (_hipblasStbsvStridedBatched_64__retval,)


@cython.embedsignature(True)
def hipblasDtbsvStridedBatched_64(object handle, object uplo, object transA, object diag, long n, long k, object AP, long lda, long strideA, object x, long incx, long stridex, long batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        uplo (`~.hipblasFillMode_t`):
            (undocumented)

        transA (`~.hipblasOperation_t`):
            (undocumented)

        diag (`~.hipblasDiagType_t`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        k (`~.int`):
            (undocumented)

        AP (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        strideA (`~.int`):
            (undocumented)

        x (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        stridex (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")                    
    if not isinstance(transA,_hipblasOperation_t__Base):
        raise TypeError("argument 'transA' must be of type '_hipblasOperation_t__Base'")                    
    if not isinstance(diag,_hipblasDiagType_t__Base):
        raise TypeError("argument 'diag' must be of type '_hipblasDiagType_t__Base'")
    _hipblasDtbsvStridedBatched_64__retval = hipblasStatus_t(chipblas.hipblasDtbsvStridedBatched_64(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,uplo.value,transA.value,diag.value,n,k,
        <const double *>hip._util.types.Pointer.fromPyobj(AP)._ptr,lda,strideA,
        <double *>hip._util.types.Pointer.fromPyobj(x)._ptr,incx,stridex,batchCount))
    return (_hipblasDtbsvStridedBatched_64__retval,)


@cython.embedsignature(True)
def hipblasCtbsvStridedBatched_64(object handle, object uplo, object transA, object diag, long n, long k, object AP, long lda, long strideA, object x, long incx, long stridex, long batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        uplo (`~.hipblasFillMode_t`):
            (undocumented)

        transA (`~.hipblasOperation_t`):
            (undocumented)

        diag (`~.hipblasDiagType_t`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        k (`~.int`):
            (undocumented)

        AP (`~.hipblasComplex`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        strideA (`~.int`):
            (undocumented)

        x (`~.hipblasComplex`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        stridex (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")                    
    if not isinstance(transA,_hipblasOperation_t__Base):
        raise TypeError("argument 'transA' must be of type '_hipblasOperation_t__Base'")                    
    if not isinstance(diag,_hipblasDiagType_t__Base):
        raise TypeError("argument 'diag' must be of type '_hipblasDiagType_t__Base'")
    _hipblasCtbsvStridedBatched_64__retval = hipblasStatus_t(chipblas.hipblasCtbsvStridedBatched_64(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,uplo.value,transA.value,diag.value,n,k,
        hipblasComplex.fromPyobj(AP).getElementPtr(),lda,strideA,
        hipblasComplex.fromPyobj(x).getElementPtr(),incx,stridex,batchCount))
    return (_hipblasCtbsvStridedBatched_64__retval,)


@cython.embedsignature(True)
def hipblasZtbsvStridedBatched_64(object handle, object uplo, object transA, object diag, long n, long k, object AP, long lda, long strideA, object x, long incx, long stridex, long batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        uplo (`~.hipblasFillMode_t`):
            (undocumented)

        transA (`~.hipblasOperation_t`):
            (undocumented)

        diag (`~.hipblasDiagType_t`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        k (`~.int`):
            (undocumented)

        AP (`~.hipblasDoubleComplex`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        strideA (`~.int`):
            (undocumented)

        x (`~.hipblasDoubleComplex`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        stridex (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")                    
    if not isinstance(transA,_hipblasOperation_t__Base):
        raise TypeError("argument 'transA' must be of type '_hipblasOperation_t__Base'")                    
    if not isinstance(diag,_hipblasDiagType_t__Base):
        raise TypeError("argument 'diag' must be of type '_hipblasDiagType_t__Base'")
    _hipblasZtbsvStridedBatched_64__retval = hipblasStatus_t(chipblas.hipblasZtbsvStridedBatched_64(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,uplo.value,transA.value,diag.value,n,k,
        hipblasDoubleComplex.fromPyobj(AP).getElementPtr(),lda,strideA,
        hipblasDoubleComplex.fromPyobj(x).getElementPtr(),incx,stridex,batchCount))
    return (_hipblasZtbsvStridedBatched_64__retval,)


@cython.embedsignature(True)
def hipblasCtbsvStridedBatched_v2_64(object handle, object uplo, object transA, object diag, long n, long k, object AP, long lda, long strideA, object x, long incx, long stridex, long batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        uplo (`~.hipblasFillMode_t`):
            (undocumented)

        transA (`~.hipblasOperation_t`):
            (undocumented)

        diag (`~.hipblasDiagType_t`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        k (`~.int`):
            (undocumented)

        AP (`~.float2`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        strideA (`~.int`):
            (undocumented)

        x (`~.float2`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        stridex (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")                    
    if not isinstance(transA,_hipblasOperation_t__Base):
        raise TypeError("argument 'transA' must be of type '_hipblasOperation_t__Base'")                    
    if not isinstance(diag,_hipblasDiagType_t__Base):
        raise TypeError("argument 'diag' must be of type '_hipblasDiagType_t__Base'")
    _hipblasCtbsvStridedBatched_v2_64__retval = hipblasStatus_t(chipblas.hipblasCtbsvStridedBatched_v2_64(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,uplo.value,transA.value,diag.value,n,k,
        float2.fromPyobj(AP).getElementPtr(),lda,strideA,
        float2.fromPyobj(x).getElementPtr(),incx,stridex,batchCount))
    return (_hipblasCtbsvStridedBatched_v2_64__retval,)


@cython.embedsignature(True)
def hipblasZtbsvStridedBatched_v2_64(object handle, object uplo, object transA, object diag, long n, long k, object AP, long lda, long strideA, object x, long incx, long stridex, long batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        uplo (`~.hipblasFillMode_t`):
            (undocumented)

        transA (`~.hipblasOperation_t`):
            (undocumented)

        diag (`~.hipblasDiagType_t`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        k (`~.int`):
            (undocumented)

        AP (`~.double2`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        strideA (`~.int`):
            (undocumented)

        x (`~.double2`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        stridex (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")                    
    if not isinstance(transA,_hipblasOperation_t__Base):
        raise TypeError("argument 'transA' must be of type '_hipblasOperation_t__Base'")                    
    if not isinstance(diag,_hipblasDiagType_t__Base):
        raise TypeError("argument 'diag' must be of type '_hipblasDiagType_t__Base'")
    _hipblasZtbsvStridedBatched_v2_64__retval = hipblasStatus_t(chipblas.hipblasZtbsvStridedBatched_v2_64(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,uplo.value,transA.value,diag.value,n,k,
        double2.fromPyobj(AP).getElementPtr(),lda,strideA,
        double2.fromPyobj(x).getElementPtr(),incx,stridex,batchCount))
    return (_hipblasZtbsvStridedBatched_v2_64__retval,)


@cython.embedsignature(True)
def hipblasStpmv(object handle, object uplo, object transA, object diag, int n, object AP, object x, int incx):
    r"""BLAS Level 2 API

    @{

    tpmv performs one of the matrix-vector operations

    x = A*x or x = A**T*x,

    where x is an n element vector and A is an n by n unit, or non-unit, upper or lower triangular matrix, supplied in the pack form.

    The vector x is overwritten.

    - Supported precisions in rocBLAS : s,d,c,z
    - Supported precisions in cuBLAS  : s,d,c,z

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`) -- *IN*:
            [hipblasHandle_t]
            handle to the hipblas library context queue.

        uplo (`~.hipblasFillMode_t`) -- *IN*:
            [hipblasFillMode_t]
            HIPBLAS_FILL_MODE_UPPER:  A is an upper triangular matrix.
            HIPBLAS_FILL_MODE_LOWER:  A is a  lower triangular matrix.

        transA (`~.hipblasOperation_t`) -- *IN*:
            [hipblasOperation_t]

        diag (`~.hipblasDiagType_t`) -- *IN*:
            [hipblasDiagType_t]
            HIPBLAS_DIAG_UNIT:     A is assumed to be unit triangular.
            HIPBLAS_DIAG_NON_UNIT:  A is not assumed to be unit triangular.

        n (`~.int`) -- *IN*:
            [int]
            n specifies the number of rows of A. n >= 0.

        AP (`~.hip._util.types.Pointer`/`~.object`) -- *IN*:
            device pointer storing matrix A,
              of dimension at least ( n * ( n + 1 ) / 2 ).
            Before entry with uplo = HIPBLAS_FILL_MODE_UPPER, the array A
            must contain the upper triangular matrix packed sequentially,
            column by column, so that A[0] contains a_{0,0}, A[1] and A[2] contain
            a_{0,1} and a_{1, 1} respectively, and so on.
            Before entry with uplo = HIPBLAS_FILL_MODE_LOWER, the array A
            must contain the lower triangular matrix packed sequentially,
            column by column, so that A[0] contains a_{0,0}, A[1] and A[2] contain
            a_{1,0} and a_{2,0} respectively, and so on.
            Note that when DIAG = HIPBLAS_DIAG_UNIT, the diagonal elements of A are
            not referenced, but are assumed to be unity.

        x (`~.hip._util.types.Pointer`/`~.object`) -- *IN*:
            device pointer storing vector x.

        incx (`~.int`) -- *IN*:
            [int]
            specifies the increment for the elements of x. incx must not be zero.
    """
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")                    
    if not isinstance(transA,_hipblasOperation_t__Base):
        raise TypeError("argument 'transA' must be of type '_hipblasOperation_t__Base'")                    
    if not isinstance(diag,_hipblasDiagType_t__Base):
        raise TypeError("argument 'diag' must be of type '_hipblasDiagType_t__Base'")
    _hipblasStpmv__retval = hipblasStatus_t(chipblas.hipblasStpmv(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,uplo.value,transA.value,diag.value,n,
        <const float *>hip._util.types.Pointer.fromPyobj(AP)._ptr,
        <float *>hip._util.types.Pointer.fromPyobj(x)._ptr,incx))
    return (_hipblasStpmv__retval,)


@cython.embedsignature(True)
def hipblasDtpmv(object handle, object uplo, object transA, object diag, int n, object AP, object x, int incx):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        uplo (`~.hipblasFillMode_t`):
            (undocumented)

        transA (`~.hipblasOperation_t`):
            (undocumented)

        diag (`~.hipblasDiagType_t`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        AP (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        x (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)
    """
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")                    
    if not isinstance(transA,_hipblasOperation_t__Base):
        raise TypeError("argument 'transA' must be of type '_hipblasOperation_t__Base'")                    
    if not isinstance(diag,_hipblasDiagType_t__Base):
        raise TypeError("argument 'diag' must be of type '_hipblasDiagType_t__Base'")
    _hipblasDtpmv__retval = hipblasStatus_t(chipblas.hipblasDtpmv(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,uplo.value,transA.value,diag.value,n,
        <const double *>hip._util.types.Pointer.fromPyobj(AP)._ptr,
        <double *>hip._util.types.Pointer.fromPyobj(x)._ptr,incx))
    return (_hipblasDtpmv__retval,)


@cython.embedsignature(True)
def hipblasCtpmv(object handle, object uplo, object transA, object diag, int n, object AP, object x, int incx):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        uplo (`~.hipblasFillMode_t`):
            (undocumented)

        transA (`~.hipblasOperation_t`):
            (undocumented)

        diag (`~.hipblasDiagType_t`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        AP (`~.hipblasComplex`/`~.object`):
            (undocumented)

        x (`~.hipblasComplex`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)
    """
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")                    
    if not isinstance(transA,_hipblasOperation_t__Base):
        raise TypeError("argument 'transA' must be of type '_hipblasOperation_t__Base'")                    
    if not isinstance(diag,_hipblasDiagType_t__Base):
        raise TypeError("argument 'diag' must be of type '_hipblasDiagType_t__Base'")
    _hipblasCtpmv__retval = hipblasStatus_t(chipblas.hipblasCtpmv(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,uplo.value,transA.value,diag.value,n,
        hipblasComplex.fromPyobj(AP).getElementPtr(),
        hipblasComplex.fromPyobj(x).getElementPtr(),incx))
    return (_hipblasCtpmv__retval,)


@cython.embedsignature(True)
def hipblasZtpmv(object handle, object uplo, object transA, object diag, int n, object AP, object x, int incx):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        uplo (`~.hipblasFillMode_t`):
            (undocumented)

        transA (`~.hipblasOperation_t`):
            (undocumented)

        diag (`~.hipblasDiagType_t`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        AP (`~.hipblasDoubleComplex`/`~.object`):
            (undocumented)

        x (`~.hipblasDoubleComplex`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)
    """
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")                    
    if not isinstance(transA,_hipblasOperation_t__Base):
        raise TypeError("argument 'transA' must be of type '_hipblasOperation_t__Base'")                    
    if not isinstance(diag,_hipblasDiagType_t__Base):
        raise TypeError("argument 'diag' must be of type '_hipblasDiagType_t__Base'")
    _hipblasZtpmv__retval = hipblasStatus_t(chipblas.hipblasZtpmv(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,uplo.value,transA.value,diag.value,n,
        hipblasDoubleComplex.fromPyobj(AP).getElementPtr(),
        hipblasDoubleComplex.fromPyobj(x).getElementPtr(),incx))
    return (_hipblasZtpmv__retval,)


@cython.embedsignature(True)
def hipblasCtpmv_v2(object handle, object uplo, object transA, object diag, int n, object AP, object x, int incx):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        uplo (`~.hipblasFillMode_t`):
            (undocumented)

        transA (`~.hipblasOperation_t`):
            (undocumented)

        diag (`~.hipblasDiagType_t`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        AP (`~.float2`/`~.object`):
            (undocumented)

        x (`~.float2`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)
    """
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")                    
    if not isinstance(transA,_hipblasOperation_t__Base):
        raise TypeError("argument 'transA' must be of type '_hipblasOperation_t__Base'")                    
    if not isinstance(diag,_hipblasDiagType_t__Base):
        raise TypeError("argument 'diag' must be of type '_hipblasDiagType_t__Base'")
    _hipblasCtpmv_v2__retval = hipblasStatus_t(chipblas.hipblasCtpmv_v2(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,uplo.value,transA.value,diag.value,n,
        float2.fromPyobj(AP).getElementPtr(),
        float2.fromPyobj(x).getElementPtr(),incx))
    return (_hipblasCtpmv_v2__retval,)


@cython.embedsignature(True)
def hipblasZtpmv_v2(object handle, object uplo, object transA, object diag, int n, object AP, object x, int incx):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        uplo (`~.hipblasFillMode_t`):
            (undocumented)

        transA (`~.hipblasOperation_t`):
            (undocumented)

        diag (`~.hipblasDiagType_t`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        AP (`~.double2`/`~.object`):
            (undocumented)

        x (`~.double2`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)
    """
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")                    
    if not isinstance(transA,_hipblasOperation_t__Base):
        raise TypeError("argument 'transA' must be of type '_hipblasOperation_t__Base'")                    
    if not isinstance(diag,_hipblasDiagType_t__Base):
        raise TypeError("argument 'diag' must be of type '_hipblasDiagType_t__Base'")
    _hipblasZtpmv_v2__retval = hipblasStatus_t(chipblas.hipblasZtpmv_v2(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,uplo.value,transA.value,diag.value,n,
        double2.fromPyobj(AP).getElementPtr(),
        double2.fromPyobj(x).getElementPtr(),incx))
    return (_hipblasZtpmv_v2__retval,)


@cython.embedsignature(True)
def hipblasStpmv_64(object handle, object uplo, object transA, object diag, long n, object AP, object x, long incx):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        uplo (`~.hipblasFillMode_t`):
            (undocumented)

        transA (`~.hipblasOperation_t`):
            (undocumented)

        diag (`~.hipblasDiagType_t`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        AP (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        x (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)
    """
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")                    
    if not isinstance(transA,_hipblasOperation_t__Base):
        raise TypeError("argument 'transA' must be of type '_hipblasOperation_t__Base'")                    
    if not isinstance(diag,_hipblasDiagType_t__Base):
        raise TypeError("argument 'diag' must be of type '_hipblasDiagType_t__Base'")
    _hipblasStpmv_64__retval = hipblasStatus_t(chipblas.hipblasStpmv_64(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,uplo.value,transA.value,diag.value,n,
        <const float *>hip._util.types.Pointer.fromPyobj(AP)._ptr,
        <float *>hip._util.types.Pointer.fromPyobj(x)._ptr,incx))
    return (_hipblasStpmv_64__retval,)


@cython.embedsignature(True)
def hipblasDtpmv_64(object handle, object uplo, object transA, object diag, long n, object AP, object x, long incx):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        uplo (`~.hipblasFillMode_t`):
            (undocumented)

        transA (`~.hipblasOperation_t`):
            (undocumented)

        diag (`~.hipblasDiagType_t`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        AP (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        x (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)
    """
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")                    
    if not isinstance(transA,_hipblasOperation_t__Base):
        raise TypeError("argument 'transA' must be of type '_hipblasOperation_t__Base'")                    
    if not isinstance(diag,_hipblasDiagType_t__Base):
        raise TypeError("argument 'diag' must be of type '_hipblasDiagType_t__Base'")
    _hipblasDtpmv_64__retval = hipblasStatus_t(chipblas.hipblasDtpmv_64(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,uplo.value,transA.value,diag.value,n,
        <const double *>hip._util.types.Pointer.fromPyobj(AP)._ptr,
        <double *>hip._util.types.Pointer.fromPyobj(x)._ptr,incx))
    return (_hipblasDtpmv_64__retval,)


@cython.embedsignature(True)
def hipblasCtpmv_64(object handle, object uplo, object transA, object diag, long n, object AP, object x, long incx):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        uplo (`~.hipblasFillMode_t`):
            (undocumented)

        transA (`~.hipblasOperation_t`):
            (undocumented)

        diag (`~.hipblasDiagType_t`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        AP (`~.hipblasComplex`/`~.object`):
            (undocumented)

        x (`~.hipblasComplex`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)
    """
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")                    
    if not isinstance(transA,_hipblasOperation_t__Base):
        raise TypeError("argument 'transA' must be of type '_hipblasOperation_t__Base'")                    
    if not isinstance(diag,_hipblasDiagType_t__Base):
        raise TypeError("argument 'diag' must be of type '_hipblasDiagType_t__Base'")
    _hipblasCtpmv_64__retval = hipblasStatus_t(chipblas.hipblasCtpmv_64(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,uplo.value,transA.value,diag.value,n,
        hipblasComplex.fromPyobj(AP).getElementPtr(),
        hipblasComplex.fromPyobj(x).getElementPtr(),incx))
    return (_hipblasCtpmv_64__retval,)


@cython.embedsignature(True)
def hipblasZtpmv_64(object handle, object uplo, object transA, object diag, long n, object AP, object x, long incx):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        uplo (`~.hipblasFillMode_t`):
            (undocumented)

        transA (`~.hipblasOperation_t`):
            (undocumented)

        diag (`~.hipblasDiagType_t`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        AP (`~.hipblasDoubleComplex`/`~.object`):
            (undocumented)

        x (`~.hipblasDoubleComplex`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)
    """
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")                    
    if not isinstance(transA,_hipblasOperation_t__Base):
        raise TypeError("argument 'transA' must be of type '_hipblasOperation_t__Base'")                    
    if not isinstance(diag,_hipblasDiagType_t__Base):
        raise TypeError("argument 'diag' must be of type '_hipblasDiagType_t__Base'")
    _hipblasZtpmv_64__retval = hipblasStatus_t(chipblas.hipblasZtpmv_64(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,uplo.value,transA.value,diag.value,n,
        hipblasDoubleComplex.fromPyobj(AP).getElementPtr(),
        hipblasDoubleComplex.fromPyobj(x).getElementPtr(),incx))
    return (_hipblasZtpmv_64__retval,)


@cython.embedsignature(True)
def hipblasCtpmv_v2_64(object handle, object uplo, object transA, object diag, long n, object AP, object x, long incx):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        uplo (`~.hipblasFillMode_t`):
            (undocumented)

        transA (`~.hipblasOperation_t`):
            (undocumented)

        diag (`~.hipblasDiagType_t`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        AP (`~.float2`/`~.object`):
            (undocumented)

        x (`~.float2`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)
    """
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")                    
    if not isinstance(transA,_hipblasOperation_t__Base):
        raise TypeError("argument 'transA' must be of type '_hipblasOperation_t__Base'")                    
    if not isinstance(diag,_hipblasDiagType_t__Base):
        raise TypeError("argument 'diag' must be of type '_hipblasDiagType_t__Base'")
    _hipblasCtpmv_v2_64__retval = hipblasStatus_t(chipblas.hipblasCtpmv_v2_64(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,uplo.value,transA.value,diag.value,n,
        float2.fromPyobj(AP).getElementPtr(),
        float2.fromPyobj(x).getElementPtr(),incx))
    return (_hipblasCtpmv_v2_64__retval,)


@cython.embedsignature(True)
def hipblasZtpmv_v2_64(object handle, object uplo, object transA, object diag, long n, object AP, object x, long incx):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        uplo (`~.hipblasFillMode_t`):
            (undocumented)

        transA (`~.hipblasOperation_t`):
            (undocumented)

        diag (`~.hipblasDiagType_t`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        AP (`~.double2`/`~.object`):
            (undocumented)

        x (`~.double2`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)
    """
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")                    
    if not isinstance(transA,_hipblasOperation_t__Base):
        raise TypeError("argument 'transA' must be of type '_hipblasOperation_t__Base'")                    
    if not isinstance(diag,_hipblasDiagType_t__Base):
        raise TypeError("argument 'diag' must be of type '_hipblasDiagType_t__Base'")
    _hipblasZtpmv_v2_64__retval = hipblasStatus_t(chipblas.hipblasZtpmv_v2_64(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,uplo.value,transA.value,diag.value,n,
        double2.fromPyobj(AP).getElementPtr(),
        double2.fromPyobj(x).getElementPtr(),incx))
    return (_hipblasZtpmv_v2_64__retval,)


@cython.embedsignature(True)
def hipblasStpmvBatched(object handle, object uplo, object transA, object diag, int n, object AP, object x, int incx, int batchCount):
    r"""BLAS Level 2 API

    @{

    tpmvBatched performs one of the matrix-vector operations

    x_i = A_i*x_i or x_i = A**T*x_i, 0 \le i < batchCount

    where x_i is an n element vector and A_i is an n by n (unit, or non-unit, upper or lower triangular matrix)

    The vectors x_i are overwritten.

    - Supported precisions in rocBLAS : s,d,c,z
    - Supported precisions in cuBLAS  : No support

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`) -- *IN*:
            [hipblasHandle_t]
            handle to the hipblas library context queue.

        uplo (`~.hipblasFillMode_t`) -- *IN*:
            [hipblasFillMode_t]
            HIPBLAS_FILL_MODE_UPPER:  A_i is an upper triangular matrix.
            HIPBLAS_FILL_MODE_LOWER:  A_i is a  lower triangular matrix.

        transA (`~.hipblasOperation_t`) -- *IN*:
            [hipblasOperation_t]

        diag (`~.hipblasDiagType_t`) -- *IN*:
            [hipblasDiagType_t]
            HIPBLAS_DIAG_UNIT:     A_i is assumed to be unit triangular.
            HIPBLAS_DIAG_NON_UNIT:  A_i is not assumed to be unit triangular.

        n (`~.int`) -- *IN*:
            [int]
            n specifies the number of rows of matrices A_i. n >= 0.

        AP (`~.hip._util.types.Pointer`/`~.object`) -- *IN*:
            device pointer storing pointer of matrices A_i,
            of dimension ( lda, n )

        x (`~.hip._util.types.ListOfPointer`/`~.object`) -- *IN*:
            device pointer storing vectors x_i.

        incx (`~.int`) -- *IN*:
            [int]
            specifies the increment for the elements of vectors x_i.

        batchCount (`~.int`) -- *IN*:
            [int]
            The number of batched matrices/vectors.
    """
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")                    
    if not isinstance(transA,_hipblasOperation_t__Base):
        raise TypeError("argument 'transA' must be of type '_hipblasOperation_t__Base'")                    
    if not isinstance(diag,_hipblasDiagType_t__Base):
        raise TypeError("argument 'diag' must be of type '_hipblasDiagType_t__Base'")
    _hipblasStpmvBatched__retval = hipblasStatus_t(chipblas.hipblasStpmvBatched(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,uplo.value,transA.value,diag.value,n,
        <const float *const*>hip._util.types.Pointer.fromPyobj(AP)._ptr,
        <float *const*>hip._util.types.ListOfPointer.fromPyobj(x)._ptr,incx,batchCount))
    return (_hipblasStpmvBatched__retval,)


@cython.embedsignature(True)
def hipblasDtpmvBatched(object handle, object uplo, object transA, object diag, int n, object AP, object x, int incx, int batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        uplo (`~.hipblasFillMode_t`):
            (undocumented)

        transA (`~.hipblasOperation_t`):
            (undocumented)

        diag (`~.hipblasDiagType_t`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        AP (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        x (`~.hip._util.types.ListOfPointer`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")                    
    if not isinstance(transA,_hipblasOperation_t__Base):
        raise TypeError("argument 'transA' must be of type '_hipblasOperation_t__Base'")                    
    if not isinstance(diag,_hipblasDiagType_t__Base):
        raise TypeError("argument 'diag' must be of type '_hipblasDiagType_t__Base'")
    _hipblasDtpmvBatched__retval = hipblasStatus_t(chipblas.hipblasDtpmvBatched(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,uplo.value,transA.value,diag.value,n,
        <const double *const*>hip._util.types.Pointer.fromPyobj(AP)._ptr,
        <double *const*>hip._util.types.ListOfPointer.fromPyobj(x)._ptr,incx,batchCount))
    return (_hipblasDtpmvBatched__retval,)


@cython.embedsignature(True)
def hipblasCtpmvBatched(object handle, object uplo, object transA, object diag, int n, object AP, object x, int incx, int batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        uplo (`~.hipblasFillMode_t`):
            (undocumented)

        transA (`~.hipblasOperation_t`):
            (undocumented)

        diag (`~.hipblasDiagType_t`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        AP (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        x (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")                    
    if not isinstance(transA,_hipblasOperation_t__Base):
        raise TypeError("argument 'transA' must be of type '_hipblasOperation_t__Base'")                    
    if not isinstance(diag,_hipblasDiagType_t__Base):
        raise TypeError("argument 'diag' must be of type '_hipblasDiagType_t__Base'")
    _hipblasCtpmvBatched__retval = hipblasStatus_t(chipblas.hipblasCtpmvBatched(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,uplo.value,transA.value,diag.value,n,
        <chipblas.hipblasComplex *const*>hip._util.types.Pointer.fromPyobj(AP)._ptr,
        <chipblas.hipblasComplex *const*>hip._util.types.Pointer.fromPyobj(x)._ptr,incx,batchCount))
    return (_hipblasCtpmvBatched__retval,)


@cython.embedsignature(True)
def hipblasZtpmvBatched(object handle, object uplo, object transA, object diag, int n, object AP, object x, int incx, int batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        uplo (`~.hipblasFillMode_t`):
            (undocumented)

        transA (`~.hipblasOperation_t`):
            (undocumented)

        diag (`~.hipblasDiagType_t`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        AP (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        x (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")                    
    if not isinstance(transA,_hipblasOperation_t__Base):
        raise TypeError("argument 'transA' must be of type '_hipblasOperation_t__Base'")                    
    if not isinstance(diag,_hipblasDiagType_t__Base):
        raise TypeError("argument 'diag' must be of type '_hipblasDiagType_t__Base'")
    _hipblasZtpmvBatched__retval = hipblasStatus_t(chipblas.hipblasZtpmvBatched(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,uplo.value,transA.value,diag.value,n,
        <chipblas.hipblasDoubleComplex *const*>hip._util.types.Pointer.fromPyobj(AP)._ptr,
        <chipblas.hipblasDoubleComplex *const*>hip._util.types.Pointer.fromPyobj(x)._ptr,incx,batchCount))
    return (_hipblasZtpmvBatched__retval,)


@cython.embedsignature(True)
def hipblasCtpmvBatched_v2(object handle, object uplo, object transA, object diag, int n, object AP, object x, int incx, int batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        uplo (`~.hipblasFillMode_t`):
            (undocumented)

        transA (`~.hipblasOperation_t`):
            (undocumented)

        diag (`~.hipblasDiagType_t`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        AP (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        x (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")                    
    if not isinstance(transA,_hipblasOperation_t__Base):
        raise TypeError("argument 'transA' must be of type '_hipblasOperation_t__Base'")                    
    if not isinstance(diag,_hipblasDiagType_t__Base):
        raise TypeError("argument 'diag' must be of type '_hipblasDiagType_t__Base'")
    _hipblasCtpmvBatched_v2__retval = hipblasStatus_t(chipblas.hipblasCtpmvBatched_v2(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,uplo.value,transA.value,diag.value,n,
        <chipblas.float2 *const*>hip._util.types.Pointer.fromPyobj(AP)._ptr,
        <chipblas.float2 *const*>hip._util.types.Pointer.fromPyobj(x)._ptr,incx,batchCount))
    return (_hipblasCtpmvBatched_v2__retval,)


@cython.embedsignature(True)
def hipblasZtpmvBatched_v2(object handle, object uplo, object transA, object diag, int n, object AP, object x, int incx, int batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        uplo (`~.hipblasFillMode_t`):
            (undocumented)

        transA (`~.hipblasOperation_t`):
            (undocumented)

        diag (`~.hipblasDiagType_t`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        AP (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        x (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")                    
    if not isinstance(transA,_hipblasOperation_t__Base):
        raise TypeError("argument 'transA' must be of type '_hipblasOperation_t__Base'")                    
    if not isinstance(diag,_hipblasDiagType_t__Base):
        raise TypeError("argument 'diag' must be of type '_hipblasDiagType_t__Base'")
    _hipblasZtpmvBatched_v2__retval = hipblasStatus_t(chipblas.hipblasZtpmvBatched_v2(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,uplo.value,transA.value,diag.value,n,
        <chipblas.double2 *const*>hip._util.types.Pointer.fromPyobj(AP)._ptr,
        <chipblas.double2 *const*>hip._util.types.Pointer.fromPyobj(x)._ptr,incx,batchCount))
    return (_hipblasZtpmvBatched_v2__retval,)


@cython.embedsignature(True)
def hipblasStpmvBatched_64(object handle, object uplo, object transA, object diag, long n, object AP, object x, long incx, long batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        uplo (`~.hipblasFillMode_t`):
            (undocumented)

        transA (`~.hipblasOperation_t`):
            (undocumented)

        diag (`~.hipblasDiagType_t`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        AP (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        x (`~.hip._util.types.ListOfPointer`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")                    
    if not isinstance(transA,_hipblasOperation_t__Base):
        raise TypeError("argument 'transA' must be of type '_hipblasOperation_t__Base'")                    
    if not isinstance(diag,_hipblasDiagType_t__Base):
        raise TypeError("argument 'diag' must be of type '_hipblasDiagType_t__Base'")
    _hipblasStpmvBatched_64__retval = hipblasStatus_t(chipblas.hipblasStpmvBatched_64(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,uplo.value,transA.value,diag.value,n,
        <const float *const*>hip._util.types.Pointer.fromPyobj(AP)._ptr,
        <float *const*>hip._util.types.ListOfPointer.fromPyobj(x)._ptr,incx,batchCount))
    return (_hipblasStpmvBatched_64__retval,)


@cython.embedsignature(True)
def hipblasDtpmvBatched_64(object handle, object uplo, object transA, object diag, long n, object AP, object x, long incx, long batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        uplo (`~.hipblasFillMode_t`):
            (undocumented)

        transA (`~.hipblasOperation_t`):
            (undocumented)

        diag (`~.hipblasDiagType_t`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        AP (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        x (`~.hip._util.types.ListOfPointer`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")                    
    if not isinstance(transA,_hipblasOperation_t__Base):
        raise TypeError("argument 'transA' must be of type '_hipblasOperation_t__Base'")                    
    if not isinstance(diag,_hipblasDiagType_t__Base):
        raise TypeError("argument 'diag' must be of type '_hipblasDiagType_t__Base'")
    _hipblasDtpmvBatched_64__retval = hipblasStatus_t(chipblas.hipblasDtpmvBatched_64(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,uplo.value,transA.value,diag.value,n,
        <const double *const*>hip._util.types.Pointer.fromPyobj(AP)._ptr,
        <double *const*>hip._util.types.ListOfPointer.fromPyobj(x)._ptr,incx,batchCount))
    return (_hipblasDtpmvBatched_64__retval,)


@cython.embedsignature(True)
def hipblasCtpmvBatched_64(object handle, object uplo, object transA, object diag, long n, object AP, object x, long incx, long batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        uplo (`~.hipblasFillMode_t`):
            (undocumented)

        transA (`~.hipblasOperation_t`):
            (undocumented)

        diag (`~.hipblasDiagType_t`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        AP (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        x (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")                    
    if not isinstance(transA,_hipblasOperation_t__Base):
        raise TypeError("argument 'transA' must be of type '_hipblasOperation_t__Base'")                    
    if not isinstance(diag,_hipblasDiagType_t__Base):
        raise TypeError("argument 'diag' must be of type '_hipblasDiagType_t__Base'")
    _hipblasCtpmvBatched_64__retval = hipblasStatus_t(chipblas.hipblasCtpmvBatched_64(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,uplo.value,transA.value,diag.value,n,
        <chipblas.hipblasComplex *const*>hip._util.types.Pointer.fromPyobj(AP)._ptr,
        <chipblas.hipblasComplex *const*>hip._util.types.Pointer.fromPyobj(x)._ptr,incx,batchCount))
    return (_hipblasCtpmvBatched_64__retval,)


@cython.embedsignature(True)
def hipblasZtpmvBatched_64(object handle, object uplo, object transA, object diag, long n, object AP, object x, long incx, long batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        uplo (`~.hipblasFillMode_t`):
            (undocumented)

        transA (`~.hipblasOperation_t`):
            (undocumented)

        diag (`~.hipblasDiagType_t`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        AP (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        x (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")                    
    if not isinstance(transA,_hipblasOperation_t__Base):
        raise TypeError("argument 'transA' must be of type '_hipblasOperation_t__Base'")                    
    if not isinstance(diag,_hipblasDiagType_t__Base):
        raise TypeError("argument 'diag' must be of type '_hipblasDiagType_t__Base'")
    _hipblasZtpmvBatched_64__retval = hipblasStatus_t(chipblas.hipblasZtpmvBatched_64(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,uplo.value,transA.value,diag.value,n,
        <chipblas.hipblasDoubleComplex *const*>hip._util.types.Pointer.fromPyobj(AP)._ptr,
        <chipblas.hipblasDoubleComplex *const*>hip._util.types.Pointer.fromPyobj(x)._ptr,incx,batchCount))
    return (_hipblasZtpmvBatched_64__retval,)


@cython.embedsignature(True)
def hipblasCtpmvBatched_v2_64(object handle, object uplo, object transA, object diag, long n, object AP, object x, long incx, long batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        uplo (`~.hipblasFillMode_t`):
            (undocumented)

        transA (`~.hipblasOperation_t`):
            (undocumented)

        diag (`~.hipblasDiagType_t`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        AP (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        x (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")                    
    if not isinstance(transA,_hipblasOperation_t__Base):
        raise TypeError("argument 'transA' must be of type '_hipblasOperation_t__Base'")                    
    if not isinstance(diag,_hipblasDiagType_t__Base):
        raise TypeError("argument 'diag' must be of type '_hipblasDiagType_t__Base'")
    _hipblasCtpmvBatched_v2_64__retval = hipblasStatus_t(chipblas.hipblasCtpmvBatched_v2_64(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,uplo.value,transA.value,diag.value,n,
        <chipblas.float2 *const*>hip._util.types.Pointer.fromPyobj(AP)._ptr,
        <chipblas.float2 *const*>hip._util.types.Pointer.fromPyobj(x)._ptr,incx,batchCount))
    return (_hipblasCtpmvBatched_v2_64__retval,)


@cython.embedsignature(True)
def hipblasZtpmvBatched_v2_64(object handle, object uplo, object transA, object diag, long n, object AP, object x, long incx, long batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        uplo (`~.hipblasFillMode_t`):
            (undocumented)

        transA (`~.hipblasOperation_t`):
            (undocumented)

        diag (`~.hipblasDiagType_t`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        AP (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        x (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")                    
    if not isinstance(transA,_hipblasOperation_t__Base):
        raise TypeError("argument 'transA' must be of type '_hipblasOperation_t__Base'")                    
    if not isinstance(diag,_hipblasDiagType_t__Base):
        raise TypeError("argument 'diag' must be of type '_hipblasDiagType_t__Base'")
    _hipblasZtpmvBatched_v2_64__retval = hipblasStatus_t(chipblas.hipblasZtpmvBatched_v2_64(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,uplo.value,transA.value,diag.value,n,
        <chipblas.double2 *const*>hip._util.types.Pointer.fromPyobj(AP)._ptr,
        <chipblas.double2 *const*>hip._util.types.Pointer.fromPyobj(x)._ptr,incx,batchCount))
    return (_hipblasZtpmvBatched_v2_64__retval,)


@cython.embedsignature(True)
def hipblasStpmvStridedBatched(object handle, object uplo, object transA, object diag, int n, object AP, long strideA, object x, int incx, long stridex, int batchCount):
    r"""BLAS Level 2 API

    @{

    tpmvStridedBatched performs one of the matrix-vector operations

    x_i = A_i*x_i or x_i = A**T*x_i, 0 \le i < batchCount

    where x_i is an n element vector and A_i is an n by n (unit, or non-unit, upper or lower triangular matrix)
    with strides specifying how to retrieve $x_i$ (resp. $A_i$) from $x_{i-1}$ (resp. $A_i$).

    The vectors x_i are overwritten.

    - Supported precisions in rocBLAS : s,d,c,z
    - Supported precisions in cuBLAS  : No support

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`) -- *IN*:
            [hipblasHandle_t]
            handle to the hipblas library context queue.

        uplo (`~.hipblasFillMode_t`) -- *IN*:
            [hipblasFillMode_t]
            HIPBLAS_FILL_MODE_UPPER:  A_i is an upper triangular matrix.
            HIPBLAS_FILL_MODE_LOWER:  A_i is a  lower triangular matrix.

        transA (`~.hipblasOperation_t`) -- *IN*:
            [hipblasOperation_t]

        diag (`~.hipblasDiagType_t`) -- *IN*:
            [hipblasDiagType_t]
            HIPBLAS_DIAG_UNIT:     A_i is assumed to be unit triangular.
            HIPBLAS_DIAG_NON_UNIT:  A_i is not assumed to be unit triangular.

        n (`~.int`) -- *IN*:
            [int]
            n specifies the number of rows of matrices A_i. n >= 0.

        AP (`~.hip._util.types.Pointer`/`~.object`) -- *IN*:
            device pointer of the matrix A_0,
            of dimension ( lda, n )

        strideA (`~.int`) -- *IN*:
            [hipblasStride]
            stride from the start of one A_i matrix to the next A_{i + 1}

        x (`~.hip._util.types.Pointer`/`~.object`) -- *IN*:
            device pointer storing the vector x_0.

        incx (`~.int`) -- *IN*:
            [int]
            specifies the increment for the elements of one vector x.

        stridex (`~.int`) -- *IN*:
            [hipblasStride]
            stride from the start of one x_i vector to the next x_{i + 1}

        batchCount (`~.int`) -- *IN*:
            [int]
            The number of batched matrices/vectors.
    """
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")                    
    if not isinstance(transA,_hipblasOperation_t__Base):
        raise TypeError("argument 'transA' must be of type '_hipblasOperation_t__Base'")                    
    if not isinstance(diag,_hipblasDiagType_t__Base):
        raise TypeError("argument 'diag' must be of type '_hipblasDiagType_t__Base'")
    _hipblasStpmvStridedBatched__retval = hipblasStatus_t(chipblas.hipblasStpmvStridedBatched(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,uplo.value,transA.value,diag.value,n,
        <const float *>hip._util.types.Pointer.fromPyobj(AP)._ptr,strideA,
        <float *>hip._util.types.Pointer.fromPyobj(x)._ptr,incx,stridex,batchCount))
    return (_hipblasStpmvStridedBatched__retval,)


@cython.embedsignature(True)
def hipblasDtpmvStridedBatched(object handle, object uplo, object transA, object diag, int n, object AP, long strideA, object x, int incx, long stridex, int batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        uplo (`~.hipblasFillMode_t`):
            (undocumented)

        transA (`~.hipblasOperation_t`):
            (undocumented)

        diag (`~.hipblasDiagType_t`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        AP (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        strideA (`~.int`):
            (undocumented)

        x (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        stridex (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")                    
    if not isinstance(transA,_hipblasOperation_t__Base):
        raise TypeError("argument 'transA' must be of type '_hipblasOperation_t__Base'")                    
    if not isinstance(diag,_hipblasDiagType_t__Base):
        raise TypeError("argument 'diag' must be of type '_hipblasDiagType_t__Base'")
    _hipblasDtpmvStridedBatched__retval = hipblasStatus_t(chipblas.hipblasDtpmvStridedBatched(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,uplo.value,transA.value,diag.value,n,
        <const double *>hip._util.types.Pointer.fromPyobj(AP)._ptr,strideA,
        <double *>hip._util.types.Pointer.fromPyobj(x)._ptr,incx,stridex,batchCount))
    return (_hipblasDtpmvStridedBatched__retval,)


@cython.embedsignature(True)
def hipblasCtpmvStridedBatched(object handle, object uplo, object transA, object diag, int n, object AP, long strideA, object x, int incx, long stridex, int batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        uplo (`~.hipblasFillMode_t`):
            (undocumented)

        transA (`~.hipblasOperation_t`):
            (undocumented)

        diag (`~.hipblasDiagType_t`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        AP (`~.hipblasComplex`/`~.object`):
            (undocumented)

        strideA (`~.int`):
            (undocumented)

        x (`~.hipblasComplex`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        stridex (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")                    
    if not isinstance(transA,_hipblasOperation_t__Base):
        raise TypeError("argument 'transA' must be of type '_hipblasOperation_t__Base'")                    
    if not isinstance(diag,_hipblasDiagType_t__Base):
        raise TypeError("argument 'diag' must be of type '_hipblasDiagType_t__Base'")
    _hipblasCtpmvStridedBatched__retval = hipblasStatus_t(chipblas.hipblasCtpmvStridedBatched(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,uplo.value,transA.value,diag.value,n,
        hipblasComplex.fromPyobj(AP).getElementPtr(),strideA,
        hipblasComplex.fromPyobj(x).getElementPtr(),incx,stridex,batchCount))
    return (_hipblasCtpmvStridedBatched__retval,)


@cython.embedsignature(True)
def hipblasZtpmvStridedBatched(object handle, object uplo, object transA, object diag, int n, object AP, long strideA, object x, int incx, long stridex, int batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        uplo (`~.hipblasFillMode_t`):
            (undocumented)

        transA (`~.hipblasOperation_t`):
            (undocumented)

        diag (`~.hipblasDiagType_t`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        AP (`~.hipblasDoubleComplex`/`~.object`):
            (undocumented)

        strideA (`~.int`):
            (undocumented)

        x (`~.hipblasDoubleComplex`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        stridex (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")                    
    if not isinstance(transA,_hipblasOperation_t__Base):
        raise TypeError("argument 'transA' must be of type '_hipblasOperation_t__Base'")                    
    if not isinstance(diag,_hipblasDiagType_t__Base):
        raise TypeError("argument 'diag' must be of type '_hipblasDiagType_t__Base'")
    _hipblasZtpmvStridedBatched__retval = hipblasStatus_t(chipblas.hipblasZtpmvStridedBatched(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,uplo.value,transA.value,diag.value,n,
        hipblasDoubleComplex.fromPyobj(AP).getElementPtr(),strideA,
        hipblasDoubleComplex.fromPyobj(x).getElementPtr(),incx,stridex,batchCount))
    return (_hipblasZtpmvStridedBatched__retval,)


@cython.embedsignature(True)
def hipblasCtpmvStridedBatched_v2(object handle, object uplo, object transA, object diag, int n, object AP, long strideA, object x, int incx, long stridex, int batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        uplo (`~.hipblasFillMode_t`):
            (undocumented)

        transA (`~.hipblasOperation_t`):
            (undocumented)

        diag (`~.hipblasDiagType_t`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        AP (`~.float2`/`~.object`):
            (undocumented)

        strideA (`~.int`):
            (undocumented)

        x (`~.float2`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        stridex (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")                    
    if not isinstance(transA,_hipblasOperation_t__Base):
        raise TypeError("argument 'transA' must be of type '_hipblasOperation_t__Base'")                    
    if not isinstance(diag,_hipblasDiagType_t__Base):
        raise TypeError("argument 'diag' must be of type '_hipblasDiagType_t__Base'")
    _hipblasCtpmvStridedBatched_v2__retval = hipblasStatus_t(chipblas.hipblasCtpmvStridedBatched_v2(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,uplo.value,transA.value,diag.value,n,
        float2.fromPyobj(AP).getElementPtr(),strideA,
        float2.fromPyobj(x).getElementPtr(),incx,stridex,batchCount))
    return (_hipblasCtpmvStridedBatched_v2__retval,)


@cython.embedsignature(True)
def hipblasZtpmvStridedBatched_v2(object handle, object uplo, object transA, object diag, int n, object AP, long strideA, object x, int incx, long stridex, int batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        uplo (`~.hipblasFillMode_t`):
            (undocumented)

        transA (`~.hipblasOperation_t`):
            (undocumented)

        diag (`~.hipblasDiagType_t`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        AP (`~.double2`/`~.object`):
            (undocumented)

        strideA (`~.int`):
            (undocumented)

        x (`~.double2`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        stridex (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")                    
    if not isinstance(transA,_hipblasOperation_t__Base):
        raise TypeError("argument 'transA' must be of type '_hipblasOperation_t__Base'")                    
    if not isinstance(diag,_hipblasDiagType_t__Base):
        raise TypeError("argument 'diag' must be of type '_hipblasDiagType_t__Base'")
    _hipblasZtpmvStridedBatched_v2__retval = hipblasStatus_t(chipblas.hipblasZtpmvStridedBatched_v2(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,uplo.value,transA.value,diag.value,n,
        double2.fromPyobj(AP).getElementPtr(),strideA,
        double2.fromPyobj(x).getElementPtr(),incx,stridex,batchCount))
    return (_hipblasZtpmvStridedBatched_v2__retval,)


@cython.embedsignature(True)
def hipblasStpmvStridedBatched_64(object handle, object uplo, object transA, object diag, long n, object AP, long strideA, object x, long incx, long stridex, long batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        uplo (`~.hipblasFillMode_t`):
            (undocumented)

        transA (`~.hipblasOperation_t`):
            (undocumented)

        diag (`~.hipblasDiagType_t`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        AP (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        strideA (`~.int`):
            (undocumented)

        x (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        stridex (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")                    
    if not isinstance(transA,_hipblasOperation_t__Base):
        raise TypeError("argument 'transA' must be of type '_hipblasOperation_t__Base'")                    
    if not isinstance(diag,_hipblasDiagType_t__Base):
        raise TypeError("argument 'diag' must be of type '_hipblasDiagType_t__Base'")
    _hipblasStpmvStridedBatched_64__retval = hipblasStatus_t(chipblas.hipblasStpmvStridedBatched_64(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,uplo.value,transA.value,diag.value,n,
        <const float *>hip._util.types.Pointer.fromPyobj(AP)._ptr,strideA,
        <float *>hip._util.types.Pointer.fromPyobj(x)._ptr,incx,stridex,batchCount))
    return (_hipblasStpmvStridedBatched_64__retval,)


@cython.embedsignature(True)
def hipblasDtpmvStridedBatched_64(object handle, object uplo, object transA, object diag, long n, object AP, long strideA, object x, long incx, long stridex, long batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        uplo (`~.hipblasFillMode_t`):
            (undocumented)

        transA (`~.hipblasOperation_t`):
            (undocumented)

        diag (`~.hipblasDiagType_t`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        AP (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        strideA (`~.int`):
            (undocumented)

        x (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        stridex (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")                    
    if not isinstance(transA,_hipblasOperation_t__Base):
        raise TypeError("argument 'transA' must be of type '_hipblasOperation_t__Base'")                    
    if not isinstance(diag,_hipblasDiagType_t__Base):
        raise TypeError("argument 'diag' must be of type '_hipblasDiagType_t__Base'")
    _hipblasDtpmvStridedBatched_64__retval = hipblasStatus_t(chipblas.hipblasDtpmvStridedBatched_64(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,uplo.value,transA.value,diag.value,n,
        <const double *>hip._util.types.Pointer.fromPyobj(AP)._ptr,strideA,
        <double *>hip._util.types.Pointer.fromPyobj(x)._ptr,incx,stridex,batchCount))
    return (_hipblasDtpmvStridedBatched_64__retval,)


@cython.embedsignature(True)
def hipblasCtpmvStridedBatched_64(object handle, object uplo, object transA, object diag, long n, object AP, long strideA, object x, long incx, long stridex, long batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        uplo (`~.hipblasFillMode_t`):
            (undocumented)

        transA (`~.hipblasOperation_t`):
            (undocumented)

        diag (`~.hipblasDiagType_t`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        AP (`~.hipblasComplex`/`~.object`):
            (undocumented)

        strideA (`~.int`):
            (undocumented)

        x (`~.hipblasComplex`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        stridex (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")                    
    if not isinstance(transA,_hipblasOperation_t__Base):
        raise TypeError("argument 'transA' must be of type '_hipblasOperation_t__Base'")                    
    if not isinstance(diag,_hipblasDiagType_t__Base):
        raise TypeError("argument 'diag' must be of type '_hipblasDiagType_t__Base'")
    _hipblasCtpmvStridedBatched_64__retval = hipblasStatus_t(chipblas.hipblasCtpmvStridedBatched_64(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,uplo.value,transA.value,diag.value,n,
        hipblasComplex.fromPyobj(AP).getElementPtr(),strideA,
        hipblasComplex.fromPyobj(x).getElementPtr(),incx,stridex,batchCount))
    return (_hipblasCtpmvStridedBatched_64__retval,)


@cython.embedsignature(True)
def hipblasZtpmvStridedBatched_64(object handle, object uplo, object transA, object diag, long n, object AP, long strideA, object x, long incx, long stridex, long batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        uplo (`~.hipblasFillMode_t`):
            (undocumented)

        transA (`~.hipblasOperation_t`):
            (undocumented)

        diag (`~.hipblasDiagType_t`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        AP (`~.hipblasDoubleComplex`/`~.object`):
            (undocumented)

        strideA (`~.int`):
            (undocumented)

        x (`~.hipblasDoubleComplex`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        stridex (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")                    
    if not isinstance(transA,_hipblasOperation_t__Base):
        raise TypeError("argument 'transA' must be of type '_hipblasOperation_t__Base'")                    
    if not isinstance(diag,_hipblasDiagType_t__Base):
        raise TypeError("argument 'diag' must be of type '_hipblasDiagType_t__Base'")
    _hipblasZtpmvStridedBatched_64__retval = hipblasStatus_t(chipblas.hipblasZtpmvStridedBatched_64(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,uplo.value,transA.value,diag.value,n,
        hipblasDoubleComplex.fromPyobj(AP).getElementPtr(),strideA,
        hipblasDoubleComplex.fromPyobj(x).getElementPtr(),incx,stridex,batchCount))
    return (_hipblasZtpmvStridedBatched_64__retval,)


@cython.embedsignature(True)
def hipblasCtpmvStridedBatched_v2_64(object handle, object uplo, object transA, object diag, long n, object AP, long strideA, object x, long incx, long stridex, long batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        uplo (`~.hipblasFillMode_t`):
            (undocumented)

        transA (`~.hipblasOperation_t`):
            (undocumented)

        diag (`~.hipblasDiagType_t`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        AP (`~.float2`/`~.object`):
            (undocumented)

        strideA (`~.int`):
            (undocumented)

        x (`~.float2`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        stridex (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")                    
    if not isinstance(transA,_hipblasOperation_t__Base):
        raise TypeError("argument 'transA' must be of type '_hipblasOperation_t__Base'")                    
    if not isinstance(diag,_hipblasDiagType_t__Base):
        raise TypeError("argument 'diag' must be of type '_hipblasDiagType_t__Base'")
    _hipblasCtpmvStridedBatched_v2_64__retval = hipblasStatus_t(chipblas.hipblasCtpmvStridedBatched_v2_64(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,uplo.value,transA.value,diag.value,n,
        float2.fromPyobj(AP).getElementPtr(),strideA,
        float2.fromPyobj(x).getElementPtr(),incx,stridex,batchCount))
    return (_hipblasCtpmvStridedBatched_v2_64__retval,)


@cython.embedsignature(True)
def hipblasZtpmvStridedBatched_v2_64(object handle, object uplo, object transA, object diag, long n, object AP, long strideA, object x, long incx, long stridex, long batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        uplo (`~.hipblasFillMode_t`):
            (undocumented)

        transA (`~.hipblasOperation_t`):
            (undocumented)

        diag (`~.hipblasDiagType_t`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        AP (`~.double2`/`~.object`):
            (undocumented)

        strideA (`~.int`):
            (undocumented)

        x (`~.double2`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        stridex (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")                    
    if not isinstance(transA,_hipblasOperation_t__Base):
        raise TypeError("argument 'transA' must be of type '_hipblasOperation_t__Base'")                    
    if not isinstance(diag,_hipblasDiagType_t__Base):
        raise TypeError("argument 'diag' must be of type '_hipblasDiagType_t__Base'")
    _hipblasZtpmvStridedBatched_v2_64__retval = hipblasStatus_t(chipblas.hipblasZtpmvStridedBatched_v2_64(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,uplo.value,transA.value,diag.value,n,
        double2.fromPyobj(AP).getElementPtr(),strideA,
        double2.fromPyobj(x).getElementPtr(),incx,stridex,batchCount))
    return (_hipblasZtpmvStridedBatched_v2_64__retval,)


@cython.embedsignature(True)
def hipblasStpsv(object handle, object uplo, object transA, object diag, int n, object AP, object x, int incx):
    r"""BLAS Level 2 API

    @{

    tpsv solves

    A*x = b or A**T*x = b, or A**H*x = b,

    where x and b are vectors and A is a triangular matrix stored in the packed format.

    The input vector b is overwritten by the output vector x.

    - Supported precisions in rocBLAS : s,d,c,z
    - Supported precisions in cuBLAS  : s,d,c,z

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`) -- *IN*:
            [hipblasHandle_t]
            handle to the hipblas library context queue.

        uplo (`~.hipblasFillMode_t`) -- *IN*:
            [hipblasFillMode_t]
            HIPBLAS_FILL_MODE_UPPER:  A is an upper triangular matrix.
            HIPBLAS_FILL_MODE_LOWER:  A is a  lower triangular matrix.

        transA (`~.hipblasOperation_t`) -- *IN*:
            [hipblasOperation_t]
            HIPBLAS_OP_N: Solves A*x = b
            HIPBLAS_OP_T: Solves A**T*x = b
            HIPBLAS_OP_C: Solves A**H*x = b

        diag (`~.hipblasDiagType_t`) -- *IN*:
            [hipblasDiagType_t]
            HIPBLAS_DIAG_UNIT:     A is assumed to be unit triangular (i.e. the diagonal elements
                                       of A are not used in computations).
            HIPBLAS_DIAG_NON_UNIT: A is not assumed to be unit triangular.

        n (`~.int`) -- *IN*:
            [int]
            n specifies the number of rows of b. n >= 0.

        AP (`~.hip._util.types.Pointer`/`~.object`) -- *IN*:
            device pointer storing the packed version of matrix A,
            of dimension >= (n * (n + 1) / 2)

        x (`~.hip._util.types.Pointer`/`~.object`) -- *INOUT*:
            device pointer storing vector b on input, overwritten by x on output.

        incx (`~.int`) -- *IN*:
            [int]
            specifies the increment for the elements of x.
    """
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")                    
    if not isinstance(transA,_hipblasOperation_t__Base):
        raise TypeError("argument 'transA' must be of type '_hipblasOperation_t__Base'")                    
    if not isinstance(diag,_hipblasDiagType_t__Base):
        raise TypeError("argument 'diag' must be of type '_hipblasDiagType_t__Base'")
    _hipblasStpsv__retval = hipblasStatus_t(chipblas.hipblasStpsv(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,uplo.value,transA.value,diag.value,n,
        <const float *>hip._util.types.Pointer.fromPyobj(AP)._ptr,
        <float *>hip._util.types.Pointer.fromPyobj(x)._ptr,incx))
    return (_hipblasStpsv__retval,)


@cython.embedsignature(True)
def hipblasDtpsv(object handle, object uplo, object transA, object diag, int n, object AP, object x, int incx):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        uplo (`~.hipblasFillMode_t`):
            (undocumented)

        transA (`~.hipblasOperation_t`):
            (undocumented)

        diag (`~.hipblasDiagType_t`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        AP (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        x (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)
    """
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")                    
    if not isinstance(transA,_hipblasOperation_t__Base):
        raise TypeError("argument 'transA' must be of type '_hipblasOperation_t__Base'")                    
    if not isinstance(diag,_hipblasDiagType_t__Base):
        raise TypeError("argument 'diag' must be of type '_hipblasDiagType_t__Base'")
    _hipblasDtpsv__retval = hipblasStatus_t(chipblas.hipblasDtpsv(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,uplo.value,transA.value,diag.value,n,
        <const double *>hip._util.types.Pointer.fromPyobj(AP)._ptr,
        <double *>hip._util.types.Pointer.fromPyobj(x)._ptr,incx))
    return (_hipblasDtpsv__retval,)


@cython.embedsignature(True)
def hipblasCtpsv(object handle, object uplo, object transA, object diag, int n, object AP, object x, int incx):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        uplo (`~.hipblasFillMode_t`):
            (undocumented)

        transA (`~.hipblasOperation_t`):
            (undocumented)

        diag (`~.hipblasDiagType_t`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        AP (`~.hipblasComplex`/`~.object`):
            (undocumented)

        x (`~.hipblasComplex`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)
    """
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")                    
    if not isinstance(transA,_hipblasOperation_t__Base):
        raise TypeError("argument 'transA' must be of type '_hipblasOperation_t__Base'")                    
    if not isinstance(diag,_hipblasDiagType_t__Base):
        raise TypeError("argument 'diag' must be of type '_hipblasDiagType_t__Base'")
    _hipblasCtpsv__retval = hipblasStatus_t(chipblas.hipblasCtpsv(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,uplo.value,transA.value,diag.value,n,
        hipblasComplex.fromPyobj(AP).getElementPtr(),
        hipblasComplex.fromPyobj(x).getElementPtr(),incx))
    return (_hipblasCtpsv__retval,)


@cython.embedsignature(True)
def hipblasZtpsv(object handle, object uplo, object transA, object diag, int n, object AP, object x, int incx):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        uplo (`~.hipblasFillMode_t`):
            (undocumented)

        transA (`~.hipblasOperation_t`):
            (undocumented)

        diag (`~.hipblasDiagType_t`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        AP (`~.hipblasDoubleComplex`/`~.object`):
            (undocumented)

        x (`~.hipblasDoubleComplex`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)
    """
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")                    
    if not isinstance(transA,_hipblasOperation_t__Base):
        raise TypeError("argument 'transA' must be of type '_hipblasOperation_t__Base'")                    
    if not isinstance(diag,_hipblasDiagType_t__Base):
        raise TypeError("argument 'diag' must be of type '_hipblasDiagType_t__Base'")
    _hipblasZtpsv__retval = hipblasStatus_t(chipblas.hipblasZtpsv(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,uplo.value,transA.value,diag.value,n,
        hipblasDoubleComplex.fromPyobj(AP).getElementPtr(),
        hipblasDoubleComplex.fromPyobj(x).getElementPtr(),incx))
    return (_hipblasZtpsv__retval,)


@cython.embedsignature(True)
def hipblasCtpsv_v2(object handle, object uplo, object transA, object diag, int n, object AP, object x, int incx):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        uplo (`~.hipblasFillMode_t`):
            (undocumented)

        transA (`~.hipblasOperation_t`):
            (undocumented)

        diag (`~.hipblasDiagType_t`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        AP (`~.float2`/`~.object`):
            (undocumented)

        x (`~.float2`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)
    """
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")                    
    if not isinstance(transA,_hipblasOperation_t__Base):
        raise TypeError("argument 'transA' must be of type '_hipblasOperation_t__Base'")                    
    if not isinstance(diag,_hipblasDiagType_t__Base):
        raise TypeError("argument 'diag' must be of type '_hipblasDiagType_t__Base'")
    _hipblasCtpsv_v2__retval = hipblasStatus_t(chipblas.hipblasCtpsv_v2(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,uplo.value,transA.value,diag.value,n,
        float2.fromPyobj(AP).getElementPtr(),
        float2.fromPyobj(x).getElementPtr(),incx))
    return (_hipblasCtpsv_v2__retval,)


@cython.embedsignature(True)
def hipblasZtpsv_v2(object handle, object uplo, object transA, object diag, int n, object AP, object x, int incx):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        uplo (`~.hipblasFillMode_t`):
            (undocumented)

        transA (`~.hipblasOperation_t`):
            (undocumented)

        diag (`~.hipblasDiagType_t`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        AP (`~.double2`/`~.object`):
            (undocumented)

        x (`~.double2`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)
    """
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")                    
    if not isinstance(transA,_hipblasOperation_t__Base):
        raise TypeError("argument 'transA' must be of type '_hipblasOperation_t__Base'")                    
    if not isinstance(diag,_hipblasDiagType_t__Base):
        raise TypeError("argument 'diag' must be of type '_hipblasDiagType_t__Base'")
    _hipblasZtpsv_v2__retval = hipblasStatus_t(chipblas.hipblasZtpsv_v2(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,uplo.value,transA.value,diag.value,n,
        double2.fromPyobj(AP).getElementPtr(),
        double2.fromPyobj(x).getElementPtr(),incx))
    return (_hipblasZtpsv_v2__retval,)


@cython.embedsignature(True)
def hipblasStpsv_64(object handle, object uplo, object transA, object diag, long n, object AP, object x, long incx):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        uplo (`~.hipblasFillMode_t`):
            (undocumented)

        transA (`~.hipblasOperation_t`):
            (undocumented)

        diag (`~.hipblasDiagType_t`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        AP (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        x (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)
    """
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")                    
    if not isinstance(transA,_hipblasOperation_t__Base):
        raise TypeError("argument 'transA' must be of type '_hipblasOperation_t__Base'")                    
    if not isinstance(diag,_hipblasDiagType_t__Base):
        raise TypeError("argument 'diag' must be of type '_hipblasDiagType_t__Base'")
    _hipblasStpsv_64__retval = hipblasStatus_t(chipblas.hipblasStpsv_64(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,uplo.value,transA.value,diag.value,n,
        <const float *>hip._util.types.Pointer.fromPyobj(AP)._ptr,
        <float *>hip._util.types.Pointer.fromPyobj(x)._ptr,incx))
    return (_hipblasStpsv_64__retval,)


@cython.embedsignature(True)
def hipblasDtpsv_64(object handle, object uplo, object transA, object diag, long n, object AP, object x, long incx):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        uplo (`~.hipblasFillMode_t`):
            (undocumented)

        transA (`~.hipblasOperation_t`):
            (undocumented)

        diag (`~.hipblasDiagType_t`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        AP (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        x (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)
    """
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")                    
    if not isinstance(transA,_hipblasOperation_t__Base):
        raise TypeError("argument 'transA' must be of type '_hipblasOperation_t__Base'")                    
    if not isinstance(diag,_hipblasDiagType_t__Base):
        raise TypeError("argument 'diag' must be of type '_hipblasDiagType_t__Base'")
    _hipblasDtpsv_64__retval = hipblasStatus_t(chipblas.hipblasDtpsv_64(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,uplo.value,transA.value,diag.value,n,
        <const double *>hip._util.types.Pointer.fromPyobj(AP)._ptr,
        <double *>hip._util.types.Pointer.fromPyobj(x)._ptr,incx))
    return (_hipblasDtpsv_64__retval,)


@cython.embedsignature(True)
def hipblasCtpsv_64(object handle, object uplo, object transA, object diag, long n, object AP, object x, long incx):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        uplo (`~.hipblasFillMode_t`):
            (undocumented)

        transA (`~.hipblasOperation_t`):
            (undocumented)

        diag (`~.hipblasDiagType_t`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        AP (`~.hipblasComplex`/`~.object`):
            (undocumented)

        x (`~.hipblasComplex`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)
    """
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")                    
    if not isinstance(transA,_hipblasOperation_t__Base):
        raise TypeError("argument 'transA' must be of type '_hipblasOperation_t__Base'")                    
    if not isinstance(diag,_hipblasDiagType_t__Base):
        raise TypeError("argument 'diag' must be of type '_hipblasDiagType_t__Base'")
    _hipblasCtpsv_64__retval = hipblasStatus_t(chipblas.hipblasCtpsv_64(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,uplo.value,transA.value,diag.value,n,
        hipblasComplex.fromPyobj(AP).getElementPtr(),
        hipblasComplex.fromPyobj(x).getElementPtr(),incx))
    return (_hipblasCtpsv_64__retval,)


@cython.embedsignature(True)
def hipblasZtpsv_64(object handle, object uplo, object transA, object diag, long n, object AP, object x, long incx):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        uplo (`~.hipblasFillMode_t`):
            (undocumented)

        transA (`~.hipblasOperation_t`):
            (undocumented)

        diag (`~.hipblasDiagType_t`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        AP (`~.hipblasDoubleComplex`/`~.object`):
            (undocumented)

        x (`~.hipblasDoubleComplex`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)
    """
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")                    
    if not isinstance(transA,_hipblasOperation_t__Base):
        raise TypeError("argument 'transA' must be of type '_hipblasOperation_t__Base'")                    
    if not isinstance(diag,_hipblasDiagType_t__Base):
        raise TypeError("argument 'diag' must be of type '_hipblasDiagType_t__Base'")
    _hipblasZtpsv_64__retval = hipblasStatus_t(chipblas.hipblasZtpsv_64(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,uplo.value,transA.value,diag.value,n,
        hipblasDoubleComplex.fromPyobj(AP).getElementPtr(),
        hipblasDoubleComplex.fromPyobj(x).getElementPtr(),incx))
    return (_hipblasZtpsv_64__retval,)


@cython.embedsignature(True)
def hipblasCtpsv_v2_64(object handle, object uplo, object transA, object diag, long n, object AP, object x, long incx):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        uplo (`~.hipblasFillMode_t`):
            (undocumented)

        transA (`~.hipblasOperation_t`):
            (undocumented)

        diag (`~.hipblasDiagType_t`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        AP (`~.float2`/`~.object`):
            (undocumented)

        x (`~.float2`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)
    """
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")                    
    if not isinstance(transA,_hipblasOperation_t__Base):
        raise TypeError("argument 'transA' must be of type '_hipblasOperation_t__Base'")                    
    if not isinstance(diag,_hipblasDiagType_t__Base):
        raise TypeError("argument 'diag' must be of type '_hipblasDiagType_t__Base'")
    _hipblasCtpsv_v2_64__retval = hipblasStatus_t(chipblas.hipblasCtpsv_v2_64(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,uplo.value,transA.value,diag.value,n,
        float2.fromPyobj(AP).getElementPtr(),
        float2.fromPyobj(x).getElementPtr(),incx))
    return (_hipblasCtpsv_v2_64__retval,)


@cython.embedsignature(True)
def hipblasZtpsv_v2_64(object handle, object uplo, object transA, object diag, long n, object AP, object x, long incx):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        uplo (`~.hipblasFillMode_t`):
            (undocumented)

        transA (`~.hipblasOperation_t`):
            (undocumented)

        diag (`~.hipblasDiagType_t`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        AP (`~.double2`/`~.object`):
            (undocumented)

        x (`~.double2`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)
    """
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")                    
    if not isinstance(transA,_hipblasOperation_t__Base):
        raise TypeError("argument 'transA' must be of type '_hipblasOperation_t__Base'")                    
    if not isinstance(diag,_hipblasDiagType_t__Base):
        raise TypeError("argument 'diag' must be of type '_hipblasDiagType_t__Base'")
    _hipblasZtpsv_v2_64__retval = hipblasStatus_t(chipblas.hipblasZtpsv_v2_64(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,uplo.value,transA.value,diag.value,n,
        double2.fromPyobj(AP).getElementPtr(),
        double2.fromPyobj(x).getElementPtr(),incx))
    return (_hipblasZtpsv_v2_64__retval,)


@cython.embedsignature(True)
def hipblasStpsvBatched(object handle, object uplo, object transA, object diag, int n, object AP, object x, int incx, int batchCount):
    r"""BLAS Level 2 API

    @{

    tpsvBatched solves

    A_i*x_i = b_i or A_i**T*x_i = b_i, or A_i**H*x_i = b_i,

    where x_i and b_i are vectors and A_i is a triangular matrix stored in the packed format,
    for i in [1, batchCount].

    The input vectors b_i are overwritten by the output vectors x_i.

    - Supported precisions in rocBLAS : s,d,c,z
    - Supported precisions in cuBLAS  : No support

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`) -- *IN*:
            [hipblasHandle_t]
            handle to the hipblas library context queue.

        uplo (`~.hipblasFillMode_t`) -- *IN*:
            [hipblasFillMode_t]
            HIPBLAS_FILL_MODE_UPPER:  each A_i is an upper triangular matrix.
            HIPBLAS_FILL_MODE_LOWER:  each A_i is a  lower triangular matrix.

        transA (`~.hipblasOperation_t`) -- *IN*:
            [hipblasOperation_t]
            HIPBLAS_OP_N: Solves A*x = b
            HIPBLAS_OP_T: Solves A**T*x = b
            HIPBLAS_OP_C: Solves A**H*x = b

        diag (`~.hipblasDiagType_t`) -- *IN*:
            [hipblasDiagType_t]
            HIPBLAS_DIAG_UNIT:     each A_i is assumed to be unit triangular (i.e. the diagonal elements
                                       of each A_i are not used in computations).
            HIPBLAS_DIAG_NON_UNIT: each A_i is not assumed to be unit triangular.

        n (`~.int`) -- *IN*:
            [int]
            n specifies the number of rows of each b_i. n >= 0.

        AP (`~.hip._util.types.Pointer`/`~.object`) -- *IN*:
            device array of device pointers storing the packed versions of each matrix A_i,
            of dimension >= (n * (n + 1) / 2)

        x (`~.hip._util.types.ListOfPointer`/`~.object`) -- *INOUT*:
            device array of device pointers storing each input vector b_i, overwritten by x_i on output.

        incx (`~.int`) -- *IN*:
            [int]
            specifies the increment for the elements of each x_i.

        batchCount (`~.int`) -- *IN*:
            [int]
            specifies the number of instances in the batch.
    """
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")                    
    if not isinstance(transA,_hipblasOperation_t__Base):
        raise TypeError("argument 'transA' must be of type '_hipblasOperation_t__Base'")                    
    if not isinstance(diag,_hipblasDiagType_t__Base):
        raise TypeError("argument 'diag' must be of type '_hipblasDiagType_t__Base'")
    _hipblasStpsvBatched__retval = hipblasStatus_t(chipblas.hipblasStpsvBatched(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,uplo.value,transA.value,diag.value,n,
        <const float *const*>hip._util.types.Pointer.fromPyobj(AP)._ptr,
        <float *const*>hip._util.types.ListOfPointer.fromPyobj(x)._ptr,incx,batchCount))
    return (_hipblasStpsvBatched__retval,)


@cython.embedsignature(True)
def hipblasDtpsvBatched(object handle, object uplo, object transA, object diag, int n, object AP, object x, int incx, int batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        uplo (`~.hipblasFillMode_t`):
            (undocumented)

        transA (`~.hipblasOperation_t`):
            (undocumented)

        diag (`~.hipblasDiagType_t`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        AP (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        x (`~.hip._util.types.ListOfPointer`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")                    
    if not isinstance(transA,_hipblasOperation_t__Base):
        raise TypeError("argument 'transA' must be of type '_hipblasOperation_t__Base'")                    
    if not isinstance(diag,_hipblasDiagType_t__Base):
        raise TypeError("argument 'diag' must be of type '_hipblasDiagType_t__Base'")
    _hipblasDtpsvBatched__retval = hipblasStatus_t(chipblas.hipblasDtpsvBatched(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,uplo.value,transA.value,diag.value,n,
        <const double *const*>hip._util.types.Pointer.fromPyobj(AP)._ptr,
        <double *const*>hip._util.types.ListOfPointer.fromPyobj(x)._ptr,incx,batchCount))
    return (_hipblasDtpsvBatched__retval,)


@cython.embedsignature(True)
def hipblasCtpsvBatched(object handle, object uplo, object transA, object diag, int n, object AP, object x, int incx, int batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        uplo (`~.hipblasFillMode_t`):
            (undocumented)

        transA (`~.hipblasOperation_t`):
            (undocumented)

        diag (`~.hipblasDiagType_t`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        AP (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        x (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")                    
    if not isinstance(transA,_hipblasOperation_t__Base):
        raise TypeError("argument 'transA' must be of type '_hipblasOperation_t__Base'")                    
    if not isinstance(diag,_hipblasDiagType_t__Base):
        raise TypeError("argument 'diag' must be of type '_hipblasDiagType_t__Base'")
    _hipblasCtpsvBatched__retval = hipblasStatus_t(chipblas.hipblasCtpsvBatched(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,uplo.value,transA.value,diag.value,n,
        <chipblas.hipblasComplex *const*>hip._util.types.Pointer.fromPyobj(AP)._ptr,
        <chipblas.hipblasComplex *const*>hip._util.types.Pointer.fromPyobj(x)._ptr,incx,batchCount))
    return (_hipblasCtpsvBatched__retval,)


@cython.embedsignature(True)
def hipblasZtpsvBatched(object handle, object uplo, object transA, object diag, int n, object AP, object x, int incx, int batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        uplo (`~.hipblasFillMode_t`):
            (undocumented)

        transA (`~.hipblasOperation_t`):
            (undocumented)

        diag (`~.hipblasDiagType_t`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        AP (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        x (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")                    
    if not isinstance(transA,_hipblasOperation_t__Base):
        raise TypeError("argument 'transA' must be of type '_hipblasOperation_t__Base'")                    
    if not isinstance(diag,_hipblasDiagType_t__Base):
        raise TypeError("argument 'diag' must be of type '_hipblasDiagType_t__Base'")
    _hipblasZtpsvBatched__retval = hipblasStatus_t(chipblas.hipblasZtpsvBatched(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,uplo.value,transA.value,diag.value,n,
        <chipblas.hipblasDoubleComplex *const*>hip._util.types.Pointer.fromPyobj(AP)._ptr,
        <chipblas.hipblasDoubleComplex *const*>hip._util.types.Pointer.fromPyobj(x)._ptr,incx,batchCount))
    return (_hipblasZtpsvBatched__retval,)


@cython.embedsignature(True)
def hipblasCtpsvBatched_v2(object handle, object uplo, object transA, object diag, int n, object AP, object x, int incx, int batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        uplo (`~.hipblasFillMode_t`):
            (undocumented)

        transA (`~.hipblasOperation_t`):
            (undocumented)

        diag (`~.hipblasDiagType_t`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        AP (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        x (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")                    
    if not isinstance(transA,_hipblasOperation_t__Base):
        raise TypeError("argument 'transA' must be of type '_hipblasOperation_t__Base'")                    
    if not isinstance(diag,_hipblasDiagType_t__Base):
        raise TypeError("argument 'diag' must be of type '_hipblasDiagType_t__Base'")
    _hipblasCtpsvBatched_v2__retval = hipblasStatus_t(chipblas.hipblasCtpsvBatched_v2(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,uplo.value,transA.value,diag.value,n,
        <chipblas.float2 *const*>hip._util.types.Pointer.fromPyobj(AP)._ptr,
        <chipblas.float2 *const*>hip._util.types.Pointer.fromPyobj(x)._ptr,incx,batchCount))
    return (_hipblasCtpsvBatched_v2__retval,)


@cython.embedsignature(True)
def hipblasZtpsvBatched_v2(object handle, object uplo, object transA, object diag, int n, object AP, object x, int incx, int batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        uplo (`~.hipblasFillMode_t`):
            (undocumented)

        transA (`~.hipblasOperation_t`):
            (undocumented)

        diag (`~.hipblasDiagType_t`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        AP (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        x (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")                    
    if not isinstance(transA,_hipblasOperation_t__Base):
        raise TypeError("argument 'transA' must be of type '_hipblasOperation_t__Base'")                    
    if not isinstance(diag,_hipblasDiagType_t__Base):
        raise TypeError("argument 'diag' must be of type '_hipblasDiagType_t__Base'")
    _hipblasZtpsvBatched_v2__retval = hipblasStatus_t(chipblas.hipblasZtpsvBatched_v2(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,uplo.value,transA.value,diag.value,n,
        <chipblas.double2 *const*>hip._util.types.Pointer.fromPyobj(AP)._ptr,
        <chipblas.double2 *const*>hip._util.types.Pointer.fromPyobj(x)._ptr,incx,batchCount))
    return (_hipblasZtpsvBatched_v2__retval,)


@cython.embedsignature(True)
def hipblasStpsvBatched_64(object handle, object uplo, object transA, object diag, long n, object AP, object x, long incx, long batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        uplo (`~.hipblasFillMode_t`):
            (undocumented)

        transA (`~.hipblasOperation_t`):
            (undocumented)

        diag (`~.hipblasDiagType_t`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        AP (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        x (`~.hip._util.types.ListOfPointer`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")                    
    if not isinstance(transA,_hipblasOperation_t__Base):
        raise TypeError("argument 'transA' must be of type '_hipblasOperation_t__Base'")                    
    if not isinstance(diag,_hipblasDiagType_t__Base):
        raise TypeError("argument 'diag' must be of type '_hipblasDiagType_t__Base'")
    _hipblasStpsvBatched_64__retval = hipblasStatus_t(chipblas.hipblasStpsvBatched_64(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,uplo.value,transA.value,diag.value,n,
        <const float *const*>hip._util.types.Pointer.fromPyobj(AP)._ptr,
        <float *const*>hip._util.types.ListOfPointer.fromPyobj(x)._ptr,incx,batchCount))
    return (_hipblasStpsvBatched_64__retval,)


@cython.embedsignature(True)
def hipblasDtpsvBatched_64(object handle, object uplo, object transA, object diag, long n, object AP, object x, long incx, long batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        uplo (`~.hipblasFillMode_t`):
            (undocumented)

        transA (`~.hipblasOperation_t`):
            (undocumented)

        diag (`~.hipblasDiagType_t`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        AP (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        x (`~.hip._util.types.ListOfPointer`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")                    
    if not isinstance(transA,_hipblasOperation_t__Base):
        raise TypeError("argument 'transA' must be of type '_hipblasOperation_t__Base'")                    
    if not isinstance(diag,_hipblasDiagType_t__Base):
        raise TypeError("argument 'diag' must be of type '_hipblasDiagType_t__Base'")
    _hipblasDtpsvBatched_64__retval = hipblasStatus_t(chipblas.hipblasDtpsvBatched_64(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,uplo.value,transA.value,diag.value,n,
        <const double *const*>hip._util.types.Pointer.fromPyobj(AP)._ptr,
        <double *const*>hip._util.types.ListOfPointer.fromPyobj(x)._ptr,incx,batchCount))
    return (_hipblasDtpsvBatched_64__retval,)


@cython.embedsignature(True)
def hipblasCtpsvBatched_64(object handle, object uplo, object transA, object diag, long n, object AP, object x, long incx, long batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        uplo (`~.hipblasFillMode_t`):
            (undocumented)

        transA (`~.hipblasOperation_t`):
            (undocumented)

        diag (`~.hipblasDiagType_t`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        AP (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        x (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")                    
    if not isinstance(transA,_hipblasOperation_t__Base):
        raise TypeError("argument 'transA' must be of type '_hipblasOperation_t__Base'")                    
    if not isinstance(diag,_hipblasDiagType_t__Base):
        raise TypeError("argument 'diag' must be of type '_hipblasDiagType_t__Base'")
    _hipblasCtpsvBatched_64__retval = hipblasStatus_t(chipblas.hipblasCtpsvBatched_64(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,uplo.value,transA.value,diag.value,n,
        <chipblas.hipblasComplex *const*>hip._util.types.Pointer.fromPyobj(AP)._ptr,
        <chipblas.hipblasComplex *const*>hip._util.types.Pointer.fromPyobj(x)._ptr,incx,batchCount))
    return (_hipblasCtpsvBatched_64__retval,)


@cython.embedsignature(True)
def hipblasZtpsvBatched_64(object handle, object uplo, object transA, object diag, long n, object AP, object x, long incx, long batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        uplo (`~.hipblasFillMode_t`):
            (undocumented)

        transA (`~.hipblasOperation_t`):
            (undocumented)

        diag (`~.hipblasDiagType_t`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        AP (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        x (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")                    
    if not isinstance(transA,_hipblasOperation_t__Base):
        raise TypeError("argument 'transA' must be of type '_hipblasOperation_t__Base'")                    
    if not isinstance(diag,_hipblasDiagType_t__Base):
        raise TypeError("argument 'diag' must be of type '_hipblasDiagType_t__Base'")
    _hipblasZtpsvBatched_64__retval = hipblasStatus_t(chipblas.hipblasZtpsvBatched_64(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,uplo.value,transA.value,diag.value,n,
        <chipblas.hipblasDoubleComplex *const*>hip._util.types.Pointer.fromPyobj(AP)._ptr,
        <chipblas.hipblasDoubleComplex *const*>hip._util.types.Pointer.fromPyobj(x)._ptr,incx,batchCount))
    return (_hipblasZtpsvBatched_64__retval,)


@cython.embedsignature(True)
def hipblasCtpsvBatched_v2_64(object handle, object uplo, object transA, object diag, long n, object AP, object x, long incx, long batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        uplo (`~.hipblasFillMode_t`):
            (undocumented)

        transA (`~.hipblasOperation_t`):
            (undocumented)

        diag (`~.hipblasDiagType_t`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        AP (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        x (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")                    
    if not isinstance(transA,_hipblasOperation_t__Base):
        raise TypeError("argument 'transA' must be of type '_hipblasOperation_t__Base'")                    
    if not isinstance(diag,_hipblasDiagType_t__Base):
        raise TypeError("argument 'diag' must be of type '_hipblasDiagType_t__Base'")
    _hipblasCtpsvBatched_v2_64__retval = hipblasStatus_t(chipblas.hipblasCtpsvBatched_v2_64(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,uplo.value,transA.value,diag.value,n,
        <chipblas.float2 *const*>hip._util.types.Pointer.fromPyobj(AP)._ptr,
        <chipblas.float2 *const*>hip._util.types.Pointer.fromPyobj(x)._ptr,incx,batchCount))
    return (_hipblasCtpsvBatched_v2_64__retval,)


@cython.embedsignature(True)
def hipblasZtpsvBatched_v2_64(object handle, object uplo, object transA, object diag, long n, object AP, object x, long incx, long batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        uplo (`~.hipblasFillMode_t`):
            (undocumented)

        transA (`~.hipblasOperation_t`):
            (undocumented)

        diag (`~.hipblasDiagType_t`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        AP (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        x (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")                    
    if not isinstance(transA,_hipblasOperation_t__Base):
        raise TypeError("argument 'transA' must be of type '_hipblasOperation_t__Base'")                    
    if not isinstance(diag,_hipblasDiagType_t__Base):
        raise TypeError("argument 'diag' must be of type '_hipblasDiagType_t__Base'")
    _hipblasZtpsvBatched_v2_64__retval = hipblasStatus_t(chipblas.hipblasZtpsvBatched_v2_64(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,uplo.value,transA.value,diag.value,n,
        <chipblas.double2 *const*>hip._util.types.Pointer.fromPyobj(AP)._ptr,
        <chipblas.double2 *const*>hip._util.types.Pointer.fromPyobj(x)._ptr,incx,batchCount))
    return (_hipblasZtpsvBatched_v2_64__retval,)


@cython.embedsignature(True)
def hipblasStpsvStridedBatched(object handle, object uplo, object transA, object diag, int n, object AP, long strideA, object x, int incx, long stridex, int batchCount):
    r"""BLAS Level 2 API

    @{

    tpsvStridedBatched solves

    A_i*x_i = b_i or A_i**T*x_i = b_i, or A_i**H*x_i = b_i,

    where x_i and b_i are vectors and A_i is a triangular matrix stored in the packed format,
    for i in [1, batchCount].

    The input vectors b_i are overwritten by the output vectors x_i.

    - Supported precisions in rocBLAS : s,d,c,z
    - Supported precisions in cuBLAS  : No support

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`) -- *IN*:
            [hipblasHandle_t]
            handle to the hipblas library context queue.

        uplo (`~.hipblasFillMode_t`) -- *IN*:
            [hipblasFillMode_t]
            HIPBLAS_FILL_MODE_UPPER:  each A_i is an upper triangular matrix.
            HIPBLAS_FILL_MODE_LOWER:  each A_i is a  lower triangular matrix.

        transA (`~.hipblasOperation_t`) -- *IN*:
            [hipblasOperation_t]
            HIPBLAS_OP_N: Solves A*x = b
            HIPBLAS_OP_T: Solves A**T*x = b
            HIPBLAS_OP_C: Solves A**H*x = b

        diag (`~.hipblasDiagType_t`) -- *IN*:
            [hipblasDiagType_t]
            HIPBLAS_DIAG_UNIT:     each A_i is assumed to be unit triangular (i.e. the diagonal elements
                                       of each A_i are not used in computations).
            HIPBLAS_DIAG_NON_UNIT: each A_i is not assumed to be unit triangular.

        n (`~.int`) -- *IN*:
            [int]
            n specifies the number of rows of each b_i. n >= 0.

        AP (`~.hip._util.types.Pointer`/`~.object`) -- *IN*:
            device pointer pointing to the first packed matrix A_1,
            of dimension >= (n * (n + 1) / 2)

        strideA (`~.int`) -- *IN*:
            [hipblasStride]
            stride from the beginning of one packed matrix (AP_i) and the next (AP_i+1).

        x (`~.hip._util.types.Pointer`/`~.object`) -- *INOUT*:
            device pointer pointing to the first input vector b_1. Overwritten by each x_i on output.

        incx (`~.int`) -- *IN*:
            [int]
            specifies the increment for the elements of each x_i.

        stridex (`~.int`) -- *IN*:
            [hipblasStride]
            stride from the beginning of one vector (x_i) and the next (x_i+1).

        batchCount (`~.int`) -- *IN*:
            [int]
            specifies the number of instances in the batch.
    """
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")                    
    if not isinstance(transA,_hipblasOperation_t__Base):
        raise TypeError("argument 'transA' must be of type '_hipblasOperation_t__Base'")                    
    if not isinstance(diag,_hipblasDiagType_t__Base):
        raise TypeError("argument 'diag' must be of type '_hipblasDiagType_t__Base'")
    _hipblasStpsvStridedBatched__retval = hipblasStatus_t(chipblas.hipblasStpsvStridedBatched(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,uplo.value,transA.value,diag.value,n,
        <const float *>hip._util.types.Pointer.fromPyobj(AP)._ptr,strideA,
        <float *>hip._util.types.Pointer.fromPyobj(x)._ptr,incx,stridex,batchCount))
    return (_hipblasStpsvStridedBatched__retval,)


@cython.embedsignature(True)
def hipblasDtpsvStridedBatched(object handle, object uplo, object transA, object diag, int n, object AP, long strideA, object x, int incx, long stridex, int batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        uplo (`~.hipblasFillMode_t`):
            (undocumented)

        transA (`~.hipblasOperation_t`):
            (undocumented)

        diag (`~.hipblasDiagType_t`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        AP (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        strideA (`~.int`):
            (undocumented)

        x (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        stridex (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")                    
    if not isinstance(transA,_hipblasOperation_t__Base):
        raise TypeError("argument 'transA' must be of type '_hipblasOperation_t__Base'")                    
    if not isinstance(diag,_hipblasDiagType_t__Base):
        raise TypeError("argument 'diag' must be of type '_hipblasDiagType_t__Base'")
    _hipblasDtpsvStridedBatched__retval = hipblasStatus_t(chipblas.hipblasDtpsvStridedBatched(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,uplo.value,transA.value,diag.value,n,
        <const double *>hip._util.types.Pointer.fromPyobj(AP)._ptr,strideA,
        <double *>hip._util.types.Pointer.fromPyobj(x)._ptr,incx,stridex,batchCount))
    return (_hipblasDtpsvStridedBatched__retval,)


@cython.embedsignature(True)
def hipblasCtpsvStridedBatched(object handle, object uplo, object transA, object diag, int n, object AP, long strideA, object x, int incx, long stridex, int batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        uplo (`~.hipblasFillMode_t`):
            (undocumented)

        transA (`~.hipblasOperation_t`):
            (undocumented)

        diag (`~.hipblasDiagType_t`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        AP (`~.hipblasComplex`/`~.object`):
            (undocumented)

        strideA (`~.int`):
            (undocumented)

        x (`~.hipblasComplex`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        stridex (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")                    
    if not isinstance(transA,_hipblasOperation_t__Base):
        raise TypeError("argument 'transA' must be of type '_hipblasOperation_t__Base'")                    
    if not isinstance(diag,_hipblasDiagType_t__Base):
        raise TypeError("argument 'diag' must be of type '_hipblasDiagType_t__Base'")
    _hipblasCtpsvStridedBatched__retval = hipblasStatus_t(chipblas.hipblasCtpsvStridedBatched(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,uplo.value,transA.value,diag.value,n,
        hipblasComplex.fromPyobj(AP).getElementPtr(),strideA,
        hipblasComplex.fromPyobj(x).getElementPtr(),incx,stridex,batchCount))
    return (_hipblasCtpsvStridedBatched__retval,)


@cython.embedsignature(True)
def hipblasZtpsvStridedBatched(object handle, object uplo, object transA, object diag, int n, object AP, long strideA, object x, int incx, long stridex, int batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        uplo (`~.hipblasFillMode_t`):
            (undocumented)

        transA (`~.hipblasOperation_t`):
            (undocumented)

        diag (`~.hipblasDiagType_t`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        AP (`~.hipblasDoubleComplex`/`~.object`):
            (undocumented)

        strideA (`~.int`):
            (undocumented)

        x (`~.hipblasDoubleComplex`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        stridex (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")                    
    if not isinstance(transA,_hipblasOperation_t__Base):
        raise TypeError("argument 'transA' must be of type '_hipblasOperation_t__Base'")                    
    if not isinstance(diag,_hipblasDiagType_t__Base):
        raise TypeError("argument 'diag' must be of type '_hipblasDiagType_t__Base'")
    _hipblasZtpsvStridedBatched__retval = hipblasStatus_t(chipblas.hipblasZtpsvStridedBatched(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,uplo.value,transA.value,diag.value,n,
        hipblasDoubleComplex.fromPyobj(AP).getElementPtr(),strideA,
        hipblasDoubleComplex.fromPyobj(x).getElementPtr(),incx,stridex,batchCount))
    return (_hipblasZtpsvStridedBatched__retval,)


@cython.embedsignature(True)
def hipblasCtpsvStridedBatched_v2(object handle, object uplo, object transA, object diag, int n, object AP, long strideA, object x, int incx, long stridex, int batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        uplo (`~.hipblasFillMode_t`):
            (undocumented)

        transA (`~.hipblasOperation_t`):
            (undocumented)

        diag (`~.hipblasDiagType_t`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        AP (`~.float2`/`~.object`):
            (undocumented)

        strideA (`~.int`):
            (undocumented)

        x (`~.float2`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        stridex (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")                    
    if not isinstance(transA,_hipblasOperation_t__Base):
        raise TypeError("argument 'transA' must be of type '_hipblasOperation_t__Base'")                    
    if not isinstance(diag,_hipblasDiagType_t__Base):
        raise TypeError("argument 'diag' must be of type '_hipblasDiagType_t__Base'")
    _hipblasCtpsvStridedBatched_v2__retval = hipblasStatus_t(chipblas.hipblasCtpsvStridedBatched_v2(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,uplo.value,transA.value,diag.value,n,
        float2.fromPyobj(AP).getElementPtr(),strideA,
        float2.fromPyobj(x).getElementPtr(),incx,stridex,batchCount))
    return (_hipblasCtpsvStridedBatched_v2__retval,)


@cython.embedsignature(True)
def hipblasZtpsvStridedBatched_v2(object handle, object uplo, object transA, object diag, int n, object AP, long strideA, object x, int incx, long stridex, int batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        uplo (`~.hipblasFillMode_t`):
            (undocumented)

        transA (`~.hipblasOperation_t`):
            (undocumented)

        diag (`~.hipblasDiagType_t`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        AP (`~.double2`/`~.object`):
            (undocumented)

        strideA (`~.int`):
            (undocumented)

        x (`~.double2`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        stridex (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")                    
    if not isinstance(transA,_hipblasOperation_t__Base):
        raise TypeError("argument 'transA' must be of type '_hipblasOperation_t__Base'")                    
    if not isinstance(diag,_hipblasDiagType_t__Base):
        raise TypeError("argument 'diag' must be of type '_hipblasDiagType_t__Base'")
    _hipblasZtpsvStridedBatched_v2__retval = hipblasStatus_t(chipblas.hipblasZtpsvStridedBatched_v2(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,uplo.value,transA.value,diag.value,n,
        double2.fromPyobj(AP).getElementPtr(),strideA,
        double2.fromPyobj(x).getElementPtr(),incx,stridex,batchCount))
    return (_hipblasZtpsvStridedBatched_v2__retval,)


@cython.embedsignature(True)
def hipblasStpsvStridedBatched_64(object handle, object uplo, object transA, object diag, long n, object AP, long strideA, object x, long incx, long stridex, long batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        uplo (`~.hipblasFillMode_t`):
            (undocumented)

        transA (`~.hipblasOperation_t`):
            (undocumented)

        diag (`~.hipblasDiagType_t`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        AP (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        strideA (`~.int`):
            (undocumented)

        x (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        stridex (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")                    
    if not isinstance(transA,_hipblasOperation_t__Base):
        raise TypeError("argument 'transA' must be of type '_hipblasOperation_t__Base'")                    
    if not isinstance(diag,_hipblasDiagType_t__Base):
        raise TypeError("argument 'diag' must be of type '_hipblasDiagType_t__Base'")
    _hipblasStpsvStridedBatched_64__retval = hipblasStatus_t(chipblas.hipblasStpsvStridedBatched_64(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,uplo.value,transA.value,diag.value,n,
        <const float *>hip._util.types.Pointer.fromPyobj(AP)._ptr,strideA,
        <float *>hip._util.types.Pointer.fromPyobj(x)._ptr,incx,stridex,batchCount))
    return (_hipblasStpsvStridedBatched_64__retval,)


@cython.embedsignature(True)
def hipblasDtpsvStridedBatched_64(object handle, object uplo, object transA, object diag, long n, object AP, long strideA, object x, long incx, long stridex, long batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        uplo (`~.hipblasFillMode_t`):
            (undocumented)

        transA (`~.hipblasOperation_t`):
            (undocumented)

        diag (`~.hipblasDiagType_t`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        AP (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        strideA (`~.int`):
            (undocumented)

        x (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        stridex (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")                    
    if not isinstance(transA,_hipblasOperation_t__Base):
        raise TypeError("argument 'transA' must be of type '_hipblasOperation_t__Base'")                    
    if not isinstance(diag,_hipblasDiagType_t__Base):
        raise TypeError("argument 'diag' must be of type '_hipblasDiagType_t__Base'")
    _hipblasDtpsvStridedBatched_64__retval = hipblasStatus_t(chipblas.hipblasDtpsvStridedBatched_64(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,uplo.value,transA.value,diag.value,n,
        <const double *>hip._util.types.Pointer.fromPyobj(AP)._ptr,strideA,
        <double *>hip._util.types.Pointer.fromPyobj(x)._ptr,incx,stridex,batchCount))
    return (_hipblasDtpsvStridedBatched_64__retval,)


@cython.embedsignature(True)
def hipblasCtpsvStridedBatched_64(object handle, object uplo, object transA, object diag, long n, object AP, long strideA, object x, long incx, long stridex, long batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        uplo (`~.hipblasFillMode_t`):
            (undocumented)

        transA (`~.hipblasOperation_t`):
            (undocumented)

        diag (`~.hipblasDiagType_t`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        AP (`~.hipblasComplex`/`~.object`):
            (undocumented)

        strideA (`~.int`):
            (undocumented)

        x (`~.hipblasComplex`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        stridex (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")                    
    if not isinstance(transA,_hipblasOperation_t__Base):
        raise TypeError("argument 'transA' must be of type '_hipblasOperation_t__Base'")                    
    if not isinstance(diag,_hipblasDiagType_t__Base):
        raise TypeError("argument 'diag' must be of type '_hipblasDiagType_t__Base'")
    _hipblasCtpsvStridedBatched_64__retval = hipblasStatus_t(chipblas.hipblasCtpsvStridedBatched_64(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,uplo.value,transA.value,diag.value,n,
        hipblasComplex.fromPyobj(AP).getElementPtr(),strideA,
        hipblasComplex.fromPyobj(x).getElementPtr(),incx,stridex,batchCount))
    return (_hipblasCtpsvStridedBatched_64__retval,)


@cython.embedsignature(True)
def hipblasZtpsvStridedBatched_64(object handle, object uplo, object transA, object diag, long n, object AP, long strideA, object x, long incx, long stridex, long batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        uplo (`~.hipblasFillMode_t`):
            (undocumented)

        transA (`~.hipblasOperation_t`):
            (undocumented)

        diag (`~.hipblasDiagType_t`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        AP (`~.hipblasDoubleComplex`/`~.object`):
            (undocumented)

        strideA (`~.int`):
            (undocumented)

        x (`~.hipblasDoubleComplex`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        stridex (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")                    
    if not isinstance(transA,_hipblasOperation_t__Base):
        raise TypeError("argument 'transA' must be of type '_hipblasOperation_t__Base'")                    
    if not isinstance(diag,_hipblasDiagType_t__Base):
        raise TypeError("argument 'diag' must be of type '_hipblasDiagType_t__Base'")
    _hipblasZtpsvStridedBatched_64__retval = hipblasStatus_t(chipblas.hipblasZtpsvStridedBatched_64(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,uplo.value,transA.value,diag.value,n,
        hipblasDoubleComplex.fromPyobj(AP).getElementPtr(),strideA,
        hipblasDoubleComplex.fromPyobj(x).getElementPtr(),incx,stridex,batchCount))
    return (_hipblasZtpsvStridedBatched_64__retval,)


@cython.embedsignature(True)
def hipblasCtpsvStridedBatched_v2_64(object handle, object uplo, object transA, object diag, long n, object AP, long strideA, object x, long incx, long stridex, long batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        uplo (`~.hipblasFillMode_t`):
            (undocumented)

        transA (`~.hipblasOperation_t`):
            (undocumented)

        diag (`~.hipblasDiagType_t`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        AP (`~.float2`/`~.object`):
            (undocumented)

        strideA (`~.int`):
            (undocumented)

        x (`~.float2`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        stridex (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")                    
    if not isinstance(transA,_hipblasOperation_t__Base):
        raise TypeError("argument 'transA' must be of type '_hipblasOperation_t__Base'")                    
    if not isinstance(diag,_hipblasDiagType_t__Base):
        raise TypeError("argument 'diag' must be of type '_hipblasDiagType_t__Base'")
    _hipblasCtpsvStridedBatched_v2_64__retval = hipblasStatus_t(chipblas.hipblasCtpsvStridedBatched_v2_64(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,uplo.value,transA.value,diag.value,n,
        float2.fromPyobj(AP).getElementPtr(),strideA,
        float2.fromPyobj(x).getElementPtr(),incx,stridex,batchCount))
    return (_hipblasCtpsvStridedBatched_v2_64__retval,)


@cython.embedsignature(True)
def hipblasZtpsvStridedBatched_v2_64(object handle, object uplo, object transA, object diag, long n, object AP, long strideA, object x, long incx, long stridex, long batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        uplo (`~.hipblasFillMode_t`):
            (undocumented)

        transA (`~.hipblasOperation_t`):
            (undocumented)

        diag (`~.hipblasDiagType_t`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        AP (`~.double2`/`~.object`):
            (undocumented)

        strideA (`~.int`):
            (undocumented)

        x (`~.double2`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        stridex (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")                    
    if not isinstance(transA,_hipblasOperation_t__Base):
        raise TypeError("argument 'transA' must be of type '_hipblasOperation_t__Base'")                    
    if not isinstance(diag,_hipblasDiagType_t__Base):
        raise TypeError("argument 'diag' must be of type '_hipblasDiagType_t__Base'")
    _hipblasZtpsvStridedBatched_v2_64__retval = hipblasStatus_t(chipblas.hipblasZtpsvStridedBatched_v2_64(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,uplo.value,transA.value,diag.value,n,
        double2.fromPyobj(AP).getElementPtr(),strideA,
        double2.fromPyobj(x).getElementPtr(),incx,stridex,batchCount))
    return (_hipblasZtpsvStridedBatched_v2_64__retval,)


@cython.embedsignature(True)
def hipblasStrmv(object handle, object uplo, object transA, object diag, int n, object AP, int lda, object x, int incx):
    r"""BLAS Level 2 API

    @{

    trmv performs one of the matrix-vector operations

    x = A*x or x = A**T*x,

    where x is an n element vector and A is an n by n unit, or non-unit, upper or lower triangular matrix.

    The vector x is overwritten.

    - Supported precisions in rocBLAS : s,d,c,z
    - Supported precisions in cuBLAS  : s,d,c,z

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`) -- *IN*:
            [hipblasHandle_t]
            handle to the hipblas library context queue.

        uplo (`~.hipblasFillMode_t`) -- *IN*:
            [hipblasFillMode_t]
            HIPBLAS_FILL_MODE_UPPER:  A is an upper triangular matrix.
            HIPBLAS_FILL_MODE_LOWER:  A is a  lower triangular matrix.

        transA (`~.hipblasOperation_t`) -- *IN*:
            [hipblasOperation_t]

        diag (`~.hipblasDiagType_t`) -- *IN*:
            [hipblasDiagType_t]
            HIPBLAS_DIAG_UNIT:     A is assumed to be unit triangular.
            HIPBLAS_DIAG_NON_UNIT:  A is not assumed to be unit triangular.

        n (`~.int`) -- *IN*:
            [int]
            n specifies the number of rows of A. n >= 0.

        AP (`~.hip._util.types.Pointer`/`~.object`) -- *IN*:
            device pointer storing matrix A,
            of dimension ( lda, n )

        lda (`~.int`) -- *IN*:
            [int]
            specifies the leading dimension of A.
            lda = max( 1, n ).

        x (`~.hip._util.types.Pointer`/`~.object`) -- *IN*:
            device pointer storing vector x.

        incx (`~.int`) -- *IN*:
            [int]
            specifies the increment for the elements of x.
    """
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")                    
    if not isinstance(transA,_hipblasOperation_t__Base):
        raise TypeError("argument 'transA' must be of type '_hipblasOperation_t__Base'")                    
    if not isinstance(diag,_hipblasDiagType_t__Base):
        raise TypeError("argument 'diag' must be of type '_hipblasDiagType_t__Base'")
    _hipblasStrmv__retval = hipblasStatus_t(chipblas.hipblasStrmv(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,uplo.value,transA.value,diag.value,n,
        <const float *>hip._util.types.Pointer.fromPyobj(AP)._ptr,lda,
        <float *>hip._util.types.Pointer.fromPyobj(x)._ptr,incx))
    return (_hipblasStrmv__retval,)


@cython.embedsignature(True)
def hipblasDtrmv(object handle, object uplo, object transA, object diag, int n, object AP, int lda, object x, int incx):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        uplo (`~.hipblasFillMode_t`):
            (undocumented)

        transA (`~.hipblasOperation_t`):
            (undocumented)

        diag (`~.hipblasDiagType_t`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        AP (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        x (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)
    """
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")                    
    if not isinstance(transA,_hipblasOperation_t__Base):
        raise TypeError("argument 'transA' must be of type '_hipblasOperation_t__Base'")                    
    if not isinstance(diag,_hipblasDiagType_t__Base):
        raise TypeError("argument 'diag' must be of type '_hipblasDiagType_t__Base'")
    _hipblasDtrmv__retval = hipblasStatus_t(chipblas.hipblasDtrmv(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,uplo.value,transA.value,diag.value,n,
        <const double *>hip._util.types.Pointer.fromPyobj(AP)._ptr,lda,
        <double *>hip._util.types.Pointer.fromPyobj(x)._ptr,incx))
    return (_hipblasDtrmv__retval,)


@cython.embedsignature(True)
def hipblasCtrmv(object handle, object uplo, object transA, object diag, int n, object AP, int lda, object x, int incx):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        uplo (`~.hipblasFillMode_t`):
            (undocumented)

        transA (`~.hipblasOperation_t`):
            (undocumented)

        diag (`~.hipblasDiagType_t`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        AP (`~.hipblasComplex`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        x (`~.hipblasComplex`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)
    """
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")                    
    if not isinstance(transA,_hipblasOperation_t__Base):
        raise TypeError("argument 'transA' must be of type '_hipblasOperation_t__Base'")                    
    if not isinstance(diag,_hipblasDiagType_t__Base):
        raise TypeError("argument 'diag' must be of type '_hipblasDiagType_t__Base'")
    _hipblasCtrmv__retval = hipblasStatus_t(chipblas.hipblasCtrmv(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,uplo.value,transA.value,diag.value,n,
        hipblasComplex.fromPyobj(AP).getElementPtr(),lda,
        hipblasComplex.fromPyobj(x).getElementPtr(),incx))
    return (_hipblasCtrmv__retval,)


@cython.embedsignature(True)
def hipblasZtrmv(object handle, object uplo, object transA, object diag, int n, object AP, int lda, object x, int incx):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        uplo (`~.hipblasFillMode_t`):
            (undocumented)

        transA (`~.hipblasOperation_t`):
            (undocumented)

        diag (`~.hipblasDiagType_t`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        AP (`~.hipblasDoubleComplex`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        x (`~.hipblasDoubleComplex`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)
    """
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")                    
    if not isinstance(transA,_hipblasOperation_t__Base):
        raise TypeError("argument 'transA' must be of type '_hipblasOperation_t__Base'")                    
    if not isinstance(diag,_hipblasDiagType_t__Base):
        raise TypeError("argument 'diag' must be of type '_hipblasDiagType_t__Base'")
    _hipblasZtrmv__retval = hipblasStatus_t(chipblas.hipblasZtrmv(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,uplo.value,transA.value,diag.value,n,
        hipblasDoubleComplex.fromPyobj(AP).getElementPtr(),lda,
        hipblasDoubleComplex.fromPyobj(x).getElementPtr(),incx))
    return (_hipblasZtrmv__retval,)


@cython.embedsignature(True)
def hipblasCtrmv_v2(object handle, object uplo, object transA, object diag, int n, object AP, int lda, object x, int incx):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        uplo (`~.hipblasFillMode_t`):
            (undocumented)

        transA (`~.hipblasOperation_t`):
            (undocumented)

        diag (`~.hipblasDiagType_t`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        AP (`~.float2`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        x (`~.float2`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)
    """
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")                    
    if not isinstance(transA,_hipblasOperation_t__Base):
        raise TypeError("argument 'transA' must be of type '_hipblasOperation_t__Base'")                    
    if not isinstance(diag,_hipblasDiagType_t__Base):
        raise TypeError("argument 'diag' must be of type '_hipblasDiagType_t__Base'")
    _hipblasCtrmv_v2__retval = hipblasStatus_t(chipblas.hipblasCtrmv_v2(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,uplo.value,transA.value,diag.value,n,
        float2.fromPyobj(AP).getElementPtr(),lda,
        float2.fromPyobj(x).getElementPtr(),incx))
    return (_hipblasCtrmv_v2__retval,)


@cython.embedsignature(True)
def hipblasZtrmv_v2(object handle, object uplo, object transA, object diag, int n, object AP, int lda, object x, int incx):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        uplo (`~.hipblasFillMode_t`):
            (undocumented)

        transA (`~.hipblasOperation_t`):
            (undocumented)

        diag (`~.hipblasDiagType_t`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        AP (`~.double2`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        x (`~.double2`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)
    """
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")                    
    if not isinstance(transA,_hipblasOperation_t__Base):
        raise TypeError("argument 'transA' must be of type '_hipblasOperation_t__Base'")                    
    if not isinstance(diag,_hipblasDiagType_t__Base):
        raise TypeError("argument 'diag' must be of type '_hipblasDiagType_t__Base'")
    _hipblasZtrmv_v2__retval = hipblasStatus_t(chipblas.hipblasZtrmv_v2(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,uplo.value,transA.value,diag.value,n,
        double2.fromPyobj(AP).getElementPtr(),lda,
        double2.fromPyobj(x).getElementPtr(),incx))
    return (_hipblasZtrmv_v2__retval,)


@cython.embedsignature(True)
def hipblasStrmv_64(object handle, object uplo, object transA, object diag, long n, object AP, long lda, object x, long incx):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        uplo (`~.hipblasFillMode_t`):
            (undocumented)

        transA (`~.hipblasOperation_t`):
            (undocumented)

        diag (`~.hipblasDiagType_t`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        AP (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        x (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)
    """
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")                    
    if not isinstance(transA,_hipblasOperation_t__Base):
        raise TypeError("argument 'transA' must be of type '_hipblasOperation_t__Base'")                    
    if not isinstance(diag,_hipblasDiagType_t__Base):
        raise TypeError("argument 'diag' must be of type '_hipblasDiagType_t__Base'")
    _hipblasStrmv_64__retval = hipblasStatus_t(chipblas.hipblasStrmv_64(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,uplo.value,transA.value,diag.value,n,
        <const float *>hip._util.types.Pointer.fromPyobj(AP)._ptr,lda,
        <float *>hip._util.types.Pointer.fromPyobj(x)._ptr,incx))
    return (_hipblasStrmv_64__retval,)


@cython.embedsignature(True)
def hipblasDtrmv_64(object handle, object uplo, object transA, object diag, long n, object AP, long lda, object x, long incx):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        uplo (`~.hipblasFillMode_t`):
            (undocumented)

        transA (`~.hipblasOperation_t`):
            (undocumented)

        diag (`~.hipblasDiagType_t`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        AP (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        x (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)
    """
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")                    
    if not isinstance(transA,_hipblasOperation_t__Base):
        raise TypeError("argument 'transA' must be of type '_hipblasOperation_t__Base'")                    
    if not isinstance(diag,_hipblasDiagType_t__Base):
        raise TypeError("argument 'diag' must be of type '_hipblasDiagType_t__Base'")
    _hipblasDtrmv_64__retval = hipblasStatus_t(chipblas.hipblasDtrmv_64(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,uplo.value,transA.value,diag.value,n,
        <const double *>hip._util.types.Pointer.fromPyobj(AP)._ptr,lda,
        <double *>hip._util.types.Pointer.fromPyobj(x)._ptr,incx))
    return (_hipblasDtrmv_64__retval,)


@cython.embedsignature(True)
def hipblasCtrmv_64(object handle, object uplo, object transA, object diag, long n, object AP, long lda, object x, long incx):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        uplo (`~.hipblasFillMode_t`):
            (undocumented)

        transA (`~.hipblasOperation_t`):
            (undocumented)

        diag (`~.hipblasDiagType_t`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        AP (`~.hipblasComplex`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        x (`~.hipblasComplex`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)
    """
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")                    
    if not isinstance(transA,_hipblasOperation_t__Base):
        raise TypeError("argument 'transA' must be of type '_hipblasOperation_t__Base'")                    
    if not isinstance(diag,_hipblasDiagType_t__Base):
        raise TypeError("argument 'diag' must be of type '_hipblasDiagType_t__Base'")
    _hipblasCtrmv_64__retval = hipblasStatus_t(chipblas.hipblasCtrmv_64(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,uplo.value,transA.value,diag.value,n,
        hipblasComplex.fromPyobj(AP).getElementPtr(),lda,
        hipblasComplex.fromPyobj(x).getElementPtr(),incx))
    return (_hipblasCtrmv_64__retval,)


@cython.embedsignature(True)
def hipblasZtrmv_64(object handle, object uplo, object transA, object diag, long n, object AP, long lda, object x, long incx):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        uplo (`~.hipblasFillMode_t`):
            (undocumented)

        transA (`~.hipblasOperation_t`):
            (undocumented)

        diag (`~.hipblasDiagType_t`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        AP (`~.hipblasDoubleComplex`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        x (`~.hipblasDoubleComplex`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)
    """
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")                    
    if not isinstance(transA,_hipblasOperation_t__Base):
        raise TypeError("argument 'transA' must be of type '_hipblasOperation_t__Base'")                    
    if not isinstance(diag,_hipblasDiagType_t__Base):
        raise TypeError("argument 'diag' must be of type '_hipblasDiagType_t__Base'")
    _hipblasZtrmv_64__retval = hipblasStatus_t(chipblas.hipblasZtrmv_64(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,uplo.value,transA.value,diag.value,n,
        hipblasDoubleComplex.fromPyobj(AP).getElementPtr(),lda,
        hipblasDoubleComplex.fromPyobj(x).getElementPtr(),incx))
    return (_hipblasZtrmv_64__retval,)


@cython.embedsignature(True)
def hipblasCtrmv_v2_64(object handle, object uplo, object transA, object diag, long n, object AP, long lda, object x, long incx):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        uplo (`~.hipblasFillMode_t`):
            (undocumented)

        transA (`~.hipblasOperation_t`):
            (undocumented)

        diag (`~.hipblasDiagType_t`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        AP (`~.float2`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        x (`~.float2`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)
    """
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")                    
    if not isinstance(transA,_hipblasOperation_t__Base):
        raise TypeError("argument 'transA' must be of type '_hipblasOperation_t__Base'")                    
    if not isinstance(diag,_hipblasDiagType_t__Base):
        raise TypeError("argument 'diag' must be of type '_hipblasDiagType_t__Base'")
    _hipblasCtrmv_v2_64__retval = hipblasStatus_t(chipblas.hipblasCtrmv_v2_64(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,uplo.value,transA.value,diag.value,n,
        float2.fromPyobj(AP).getElementPtr(),lda,
        float2.fromPyobj(x).getElementPtr(),incx))
    return (_hipblasCtrmv_v2_64__retval,)


@cython.embedsignature(True)
def hipblasZtrmv_v2_64(object handle, object uplo, object transA, object diag, long n, object AP, long lda, object x, long incx):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        uplo (`~.hipblasFillMode_t`):
            (undocumented)

        transA (`~.hipblasOperation_t`):
            (undocumented)

        diag (`~.hipblasDiagType_t`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        AP (`~.double2`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        x (`~.double2`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)
    """
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")                    
    if not isinstance(transA,_hipblasOperation_t__Base):
        raise TypeError("argument 'transA' must be of type '_hipblasOperation_t__Base'")                    
    if not isinstance(diag,_hipblasDiagType_t__Base):
        raise TypeError("argument 'diag' must be of type '_hipblasDiagType_t__Base'")
    _hipblasZtrmv_v2_64__retval = hipblasStatus_t(chipblas.hipblasZtrmv_v2_64(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,uplo.value,transA.value,diag.value,n,
        double2.fromPyobj(AP).getElementPtr(),lda,
        double2.fromPyobj(x).getElementPtr(),incx))
    return (_hipblasZtrmv_v2_64__retval,)


@cython.embedsignature(True)
def hipblasStrmvBatched(object handle, object uplo, object transA, object diag, int n, object AP, int lda, object x, int incx, int batchCount):
    r"""BLAS Level 2 API

    @{

    trmvBatched performs one of the matrix-vector operations

    x_i = A_i*x_i or x_i = A**T*x_i, 0 \le i < batchCount

    where x_i is an n element vector and A_i is an n by n (unit, or non-unit, upper or lower triangular matrix)

    The vectors x_i are overwritten.

    - Supported precisions in rocBLAS : s,d,c,z
    - Supported precisions in cuBLAS  : No support

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`) -- *IN*:
            [hipblasHandle_t]
            handle to the hipblas library context queue.

        uplo (`~.hipblasFillMode_t`) -- *IN*:
            [hipblasFillMode_t]
            HIPBLAS_FILL_MODE_UPPER:  A_i is an upper triangular matrix.
            HIPBLAS_FILL_MODE_LOWER:  A_i is a  lower triangular matrix.

        transA (`~.hipblasOperation_t`) -- *IN*:
            [hipblasOperation_t]

        diag (`~.hipblasDiagType_t`) -- *IN*:
            [hipblasDiagType_t]
            HIPBLAS_DIAG_UNIT:     A_i is assumed to be unit triangular.
            HIPBLAS_DIAG_NON_UNIT:  A_i is not assumed to be unit triangular.

        n (`~.int`) -- *IN*:
            [int]
            n specifies the number of rows of matrices A_i. n >= 0.

        AP (`~.hip._util.types.Pointer`/`~.object`) -- *IN*:
            device pointer storing pointer of matrices A_i,
            of dimension ( lda, n )

        lda (`~.int`) -- *IN*:
            [int]
            specifies the leading dimension of A_i.
            lda >= max( 1, n ).

        x (`~.hip._util.types.ListOfPointer`/`~.object`) -- *IN*:
            device pointer storing vectors x_i.

        incx (`~.int`) -- *IN*:
            [int]
            specifies the increment for the elements of vectors x_i.

        batchCount (`~.int`) -- *IN*:
            [int]
            The number of batched matrices/vectors.
    """
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")                    
    if not isinstance(transA,_hipblasOperation_t__Base):
        raise TypeError("argument 'transA' must be of type '_hipblasOperation_t__Base'")                    
    if not isinstance(diag,_hipblasDiagType_t__Base):
        raise TypeError("argument 'diag' must be of type '_hipblasDiagType_t__Base'")
    _hipblasStrmvBatched__retval = hipblasStatus_t(chipblas.hipblasStrmvBatched(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,uplo.value,transA.value,diag.value,n,
        <const float *const*>hip._util.types.Pointer.fromPyobj(AP)._ptr,lda,
        <float *const*>hip._util.types.ListOfPointer.fromPyobj(x)._ptr,incx,batchCount))
    return (_hipblasStrmvBatched__retval,)


@cython.embedsignature(True)
def hipblasDtrmvBatched(object handle, object uplo, object transA, object diag, int n, object AP, int lda, object x, int incx, int batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        uplo (`~.hipblasFillMode_t`):
            (undocumented)

        transA (`~.hipblasOperation_t`):
            (undocumented)

        diag (`~.hipblasDiagType_t`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        AP (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        x (`~.hip._util.types.ListOfPointer`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")                    
    if not isinstance(transA,_hipblasOperation_t__Base):
        raise TypeError("argument 'transA' must be of type '_hipblasOperation_t__Base'")                    
    if not isinstance(diag,_hipblasDiagType_t__Base):
        raise TypeError("argument 'diag' must be of type '_hipblasDiagType_t__Base'")
    _hipblasDtrmvBatched__retval = hipblasStatus_t(chipblas.hipblasDtrmvBatched(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,uplo.value,transA.value,diag.value,n,
        <const double *const*>hip._util.types.Pointer.fromPyobj(AP)._ptr,lda,
        <double *const*>hip._util.types.ListOfPointer.fromPyobj(x)._ptr,incx,batchCount))
    return (_hipblasDtrmvBatched__retval,)


@cython.embedsignature(True)
def hipblasCtrmvBatched(object handle, object uplo, object transA, object diag, int n, object AP, int lda, object x, int incx, int batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        uplo (`~.hipblasFillMode_t`):
            (undocumented)

        transA (`~.hipblasOperation_t`):
            (undocumented)

        diag (`~.hipblasDiagType_t`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        AP (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        x (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")                    
    if not isinstance(transA,_hipblasOperation_t__Base):
        raise TypeError("argument 'transA' must be of type '_hipblasOperation_t__Base'")                    
    if not isinstance(diag,_hipblasDiagType_t__Base):
        raise TypeError("argument 'diag' must be of type '_hipblasDiagType_t__Base'")
    _hipblasCtrmvBatched__retval = hipblasStatus_t(chipblas.hipblasCtrmvBatched(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,uplo.value,transA.value,diag.value,n,
        <chipblas.hipblasComplex *const*>hip._util.types.Pointer.fromPyobj(AP)._ptr,lda,
        <chipblas.hipblasComplex *const*>hip._util.types.Pointer.fromPyobj(x)._ptr,incx,batchCount))
    return (_hipblasCtrmvBatched__retval,)


@cython.embedsignature(True)
def hipblasZtrmvBatched(object handle, object uplo, object transA, object diag, int n, object AP, int lda, object x, int incx, int batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        uplo (`~.hipblasFillMode_t`):
            (undocumented)

        transA (`~.hipblasOperation_t`):
            (undocumented)

        diag (`~.hipblasDiagType_t`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        AP (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        x (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")                    
    if not isinstance(transA,_hipblasOperation_t__Base):
        raise TypeError("argument 'transA' must be of type '_hipblasOperation_t__Base'")                    
    if not isinstance(diag,_hipblasDiagType_t__Base):
        raise TypeError("argument 'diag' must be of type '_hipblasDiagType_t__Base'")
    _hipblasZtrmvBatched__retval = hipblasStatus_t(chipblas.hipblasZtrmvBatched(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,uplo.value,transA.value,diag.value,n,
        <chipblas.hipblasDoubleComplex *const*>hip._util.types.Pointer.fromPyobj(AP)._ptr,lda,
        <chipblas.hipblasDoubleComplex *const*>hip._util.types.Pointer.fromPyobj(x)._ptr,incx,batchCount))
    return (_hipblasZtrmvBatched__retval,)


@cython.embedsignature(True)
def hipblasCtrmvBatched_v2(object handle, object uplo, object transA, object diag, int n, object AP, int lda, object x, int incx, int batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        uplo (`~.hipblasFillMode_t`):
            (undocumented)

        transA (`~.hipblasOperation_t`):
            (undocumented)

        diag (`~.hipblasDiagType_t`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        AP (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        x (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")                    
    if not isinstance(transA,_hipblasOperation_t__Base):
        raise TypeError("argument 'transA' must be of type '_hipblasOperation_t__Base'")                    
    if not isinstance(diag,_hipblasDiagType_t__Base):
        raise TypeError("argument 'diag' must be of type '_hipblasDiagType_t__Base'")
    _hipblasCtrmvBatched_v2__retval = hipblasStatus_t(chipblas.hipblasCtrmvBatched_v2(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,uplo.value,transA.value,diag.value,n,
        <chipblas.float2 *const*>hip._util.types.Pointer.fromPyobj(AP)._ptr,lda,
        <chipblas.float2 *const*>hip._util.types.Pointer.fromPyobj(x)._ptr,incx,batchCount))
    return (_hipblasCtrmvBatched_v2__retval,)


@cython.embedsignature(True)
def hipblasZtrmvBatched_v2(object handle, object uplo, object transA, object diag, int n, object AP, int lda, object x, int incx, int batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        uplo (`~.hipblasFillMode_t`):
            (undocumented)

        transA (`~.hipblasOperation_t`):
            (undocumented)

        diag (`~.hipblasDiagType_t`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        AP (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        x (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")                    
    if not isinstance(transA,_hipblasOperation_t__Base):
        raise TypeError("argument 'transA' must be of type '_hipblasOperation_t__Base'")                    
    if not isinstance(diag,_hipblasDiagType_t__Base):
        raise TypeError("argument 'diag' must be of type '_hipblasDiagType_t__Base'")
    _hipblasZtrmvBatched_v2__retval = hipblasStatus_t(chipblas.hipblasZtrmvBatched_v2(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,uplo.value,transA.value,diag.value,n,
        <chipblas.double2 *const*>hip._util.types.Pointer.fromPyobj(AP)._ptr,lda,
        <chipblas.double2 *const*>hip._util.types.Pointer.fromPyobj(x)._ptr,incx,batchCount))
    return (_hipblasZtrmvBatched_v2__retval,)


@cython.embedsignature(True)
def hipblasStrmvBatched_64(object handle, object uplo, object transA, object diag, long n, object AP, long lda, object x, long incx, long batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        uplo (`~.hipblasFillMode_t`):
            (undocumented)

        transA (`~.hipblasOperation_t`):
            (undocumented)

        diag (`~.hipblasDiagType_t`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        AP (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        x (`~.hip._util.types.ListOfPointer`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")                    
    if not isinstance(transA,_hipblasOperation_t__Base):
        raise TypeError("argument 'transA' must be of type '_hipblasOperation_t__Base'")                    
    if not isinstance(diag,_hipblasDiagType_t__Base):
        raise TypeError("argument 'diag' must be of type '_hipblasDiagType_t__Base'")
    _hipblasStrmvBatched_64__retval = hipblasStatus_t(chipblas.hipblasStrmvBatched_64(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,uplo.value,transA.value,diag.value,n,
        <const float *const*>hip._util.types.Pointer.fromPyobj(AP)._ptr,lda,
        <float *const*>hip._util.types.ListOfPointer.fromPyobj(x)._ptr,incx,batchCount))
    return (_hipblasStrmvBatched_64__retval,)


@cython.embedsignature(True)
def hipblasDtrmvBatched_64(object handle, object uplo, object transA, object diag, long n, object AP, long lda, object x, long incx, long batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        uplo (`~.hipblasFillMode_t`):
            (undocumented)

        transA (`~.hipblasOperation_t`):
            (undocumented)

        diag (`~.hipblasDiagType_t`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        AP (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        x (`~.hip._util.types.ListOfPointer`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")                    
    if not isinstance(transA,_hipblasOperation_t__Base):
        raise TypeError("argument 'transA' must be of type '_hipblasOperation_t__Base'")                    
    if not isinstance(diag,_hipblasDiagType_t__Base):
        raise TypeError("argument 'diag' must be of type '_hipblasDiagType_t__Base'")
    _hipblasDtrmvBatched_64__retval = hipblasStatus_t(chipblas.hipblasDtrmvBatched_64(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,uplo.value,transA.value,diag.value,n,
        <const double *const*>hip._util.types.Pointer.fromPyobj(AP)._ptr,lda,
        <double *const*>hip._util.types.ListOfPointer.fromPyobj(x)._ptr,incx,batchCount))
    return (_hipblasDtrmvBatched_64__retval,)


@cython.embedsignature(True)
def hipblasCtrmvBatched_64(object handle, object uplo, object transA, object diag, long n, object AP, long lda, object x, long incx, long batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        uplo (`~.hipblasFillMode_t`):
            (undocumented)

        transA (`~.hipblasOperation_t`):
            (undocumented)

        diag (`~.hipblasDiagType_t`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        AP (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        x (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")                    
    if not isinstance(transA,_hipblasOperation_t__Base):
        raise TypeError("argument 'transA' must be of type '_hipblasOperation_t__Base'")                    
    if not isinstance(diag,_hipblasDiagType_t__Base):
        raise TypeError("argument 'diag' must be of type '_hipblasDiagType_t__Base'")
    _hipblasCtrmvBatched_64__retval = hipblasStatus_t(chipblas.hipblasCtrmvBatched_64(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,uplo.value,transA.value,diag.value,n,
        <chipblas.hipblasComplex *const*>hip._util.types.Pointer.fromPyobj(AP)._ptr,lda,
        <chipblas.hipblasComplex *const*>hip._util.types.Pointer.fromPyobj(x)._ptr,incx,batchCount))
    return (_hipblasCtrmvBatched_64__retval,)


@cython.embedsignature(True)
def hipblasZtrmvBatched_64(object handle, object uplo, object transA, object diag, long n, object AP, long lda, object x, long incx, long batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        uplo (`~.hipblasFillMode_t`):
            (undocumented)

        transA (`~.hipblasOperation_t`):
            (undocumented)

        diag (`~.hipblasDiagType_t`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        AP (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        x (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")                    
    if not isinstance(transA,_hipblasOperation_t__Base):
        raise TypeError("argument 'transA' must be of type '_hipblasOperation_t__Base'")                    
    if not isinstance(diag,_hipblasDiagType_t__Base):
        raise TypeError("argument 'diag' must be of type '_hipblasDiagType_t__Base'")
    _hipblasZtrmvBatched_64__retval = hipblasStatus_t(chipblas.hipblasZtrmvBatched_64(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,uplo.value,transA.value,diag.value,n,
        <chipblas.hipblasDoubleComplex *const*>hip._util.types.Pointer.fromPyobj(AP)._ptr,lda,
        <chipblas.hipblasDoubleComplex *const*>hip._util.types.Pointer.fromPyobj(x)._ptr,incx,batchCount))
    return (_hipblasZtrmvBatched_64__retval,)


@cython.embedsignature(True)
def hipblasCtrmvBatched_v2_64(object handle, object uplo, object transA, object diag, long n, object AP, long lda, object x, long incx, long batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        uplo (`~.hipblasFillMode_t`):
            (undocumented)

        transA (`~.hipblasOperation_t`):
            (undocumented)

        diag (`~.hipblasDiagType_t`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        AP (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        x (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")                    
    if not isinstance(transA,_hipblasOperation_t__Base):
        raise TypeError("argument 'transA' must be of type '_hipblasOperation_t__Base'")                    
    if not isinstance(diag,_hipblasDiagType_t__Base):
        raise TypeError("argument 'diag' must be of type '_hipblasDiagType_t__Base'")
    _hipblasCtrmvBatched_v2_64__retval = hipblasStatus_t(chipblas.hipblasCtrmvBatched_v2_64(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,uplo.value,transA.value,diag.value,n,
        <chipblas.float2 *const*>hip._util.types.Pointer.fromPyobj(AP)._ptr,lda,
        <chipblas.float2 *const*>hip._util.types.Pointer.fromPyobj(x)._ptr,incx,batchCount))
    return (_hipblasCtrmvBatched_v2_64__retval,)


@cython.embedsignature(True)
def hipblasZtrmvBatched_v2_64(object handle, object uplo, object transA, object diag, long n, object AP, long lda, object x, long incx, long batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        uplo (`~.hipblasFillMode_t`):
            (undocumented)

        transA (`~.hipblasOperation_t`):
            (undocumented)

        diag (`~.hipblasDiagType_t`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        AP (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        x (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")                    
    if not isinstance(transA,_hipblasOperation_t__Base):
        raise TypeError("argument 'transA' must be of type '_hipblasOperation_t__Base'")                    
    if not isinstance(diag,_hipblasDiagType_t__Base):
        raise TypeError("argument 'diag' must be of type '_hipblasDiagType_t__Base'")
    _hipblasZtrmvBatched_v2_64__retval = hipblasStatus_t(chipblas.hipblasZtrmvBatched_v2_64(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,uplo.value,transA.value,diag.value,n,
        <chipblas.double2 *const*>hip._util.types.Pointer.fromPyobj(AP)._ptr,lda,
        <chipblas.double2 *const*>hip._util.types.Pointer.fromPyobj(x)._ptr,incx,batchCount))
    return (_hipblasZtrmvBatched_v2_64__retval,)


@cython.embedsignature(True)
def hipblasStrmvStridedBatched(object handle, object uplo, object transA, object diag, int n, object AP, int lda, long strideA, object x, int incx, long stridex, int batchCount):
    r"""BLAS Level 2 API

    @{

    trmvStridedBatched performs one of the matrix-vector operations

    x_i = A_i*x_i or x_i = A**T*x_i, 0 \le i < batchCount

    where x_i is an n element vector and A_i is an n by n (unit, or non-unit, upper or lower triangular matrix)
    with strides specifying how to retrieve $x_i$ (resp. $A_i$) from $x_{i-1}$ (resp. $A_i$).

    The vectors x_i are overwritten.

    - Supported precisions in rocBLAS : s,d,c,z
    - Supported precisions in cuBLAS  : No support

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`) -- *IN*:
            [hipblasHandle_t]
            handle to the hipblas library context queue.

        uplo (`~.hipblasFillMode_t`) -- *IN*:
            [hipblasFillMode_t]
            HIPBLAS_FILL_MODE_UPPER:  A_i is an upper triangular matrix.
            HIPBLAS_FILL_MODE_LOWER:  A_i is a  lower triangular matrix.

        transA (`~.hipblasOperation_t`) -- *IN*:
            [hipblasOperation_t]

        diag (`~.hipblasDiagType_t`) -- *IN*:
            [hipblasDiagType_t]
            HIPBLAS_DIAG_UNIT:     A_i is assumed to be unit triangular.
            HIPBLAS_DIAG_NON_UNIT:  A_i is not assumed to be unit triangular.

        n (`~.int`) -- *IN*:
            [int]
            n specifies the number of rows of matrices A_i. n >= 0.

        AP (`~.hip._util.types.Pointer`/`~.object`) -- *IN*:
            device pointer of the matrix A_0,
            of dimension ( lda, n )

        lda (`~.int`) -- *IN*:
            [int]
            specifies the leading dimension of A_i.
            lda >= max( 1, n ).

        strideA (`~.int`) -- *IN*:
            [hipblasStride]
            stride from the start of one A_i matrix to the next A_{i + 1}

        x (`~.hip._util.types.Pointer`/`~.object`) -- *IN*:
            device pointer storing the vector x_0.

        incx (`~.int`) -- *IN*:
            [int]
            specifies the increment for the elements of one vector x.

        stridex (`~.int`) -- *IN*:
            [hipblasStride]
            stride from the start of one x_i vector to the next x_{i + 1}

        batchCount (`~.int`) -- *IN*:
            [int]
            The number of batched matrices/vectors.
    """
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")                    
    if not isinstance(transA,_hipblasOperation_t__Base):
        raise TypeError("argument 'transA' must be of type '_hipblasOperation_t__Base'")                    
    if not isinstance(diag,_hipblasDiagType_t__Base):
        raise TypeError("argument 'diag' must be of type '_hipblasDiagType_t__Base'")
    _hipblasStrmvStridedBatched__retval = hipblasStatus_t(chipblas.hipblasStrmvStridedBatched(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,uplo.value,transA.value,diag.value,n,
        <const float *>hip._util.types.Pointer.fromPyobj(AP)._ptr,lda,strideA,
        <float *>hip._util.types.Pointer.fromPyobj(x)._ptr,incx,stridex,batchCount))
    return (_hipblasStrmvStridedBatched__retval,)


@cython.embedsignature(True)
def hipblasDtrmvStridedBatched(object handle, object uplo, object transA, object diag, int n, object AP, int lda, long strideA, object x, int incx, long stridex, int batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        uplo (`~.hipblasFillMode_t`):
            (undocumented)

        transA (`~.hipblasOperation_t`):
            (undocumented)

        diag (`~.hipblasDiagType_t`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        AP (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        strideA (`~.int`):
            (undocumented)

        x (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        stridex (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")                    
    if not isinstance(transA,_hipblasOperation_t__Base):
        raise TypeError("argument 'transA' must be of type '_hipblasOperation_t__Base'")                    
    if not isinstance(diag,_hipblasDiagType_t__Base):
        raise TypeError("argument 'diag' must be of type '_hipblasDiagType_t__Base'")
    _hipblasDtrmvStridedBatched__retval = hipblasStatus_t(chipblas.hipblasDtrmvStridedBatched(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,uplo.value,transA.value,diag.value,n,
        <const double *>hip._util.types.Pointer.fromPyobj(AP)._ptr,lda,strideA,
        <double *>hip._util.types.Pointer.fromPyobj(x)._ptr,incx,stridex,batchCount))
    return (_hipblasDtrmvStridedBatched__retval,)


@cython.embedsignature(True)
def hipblasCtrmvStridedBatched(object handle, object uplo, object transA, object diag, int n, object AP, int lda, long strideA, object x, int incx, long stridex, int batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        uplo (`~.hipblasFillMode_t`):
            (undocumented)

        transA (`~.hipblasOperation_t`):
            (undocumented)

        diag (`~.hipblasDiagType_t`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        AP (`~.hipblasComplex`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        strideA (`~.int`):
            (undocumented)

        x (`~.hipblasComplex`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        stridex (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")                    
    if not isinstance(transA,_hipblasOperation_t__Base):
        raise TypeError("argument 'transA' must be of type '_hipblasOperation_t__Base'")                    
    if not isinstance(diag,_hipblasDiagType_t__Base):
        raise TypeError("argument 'diag' must be of type '_hipblasDiagType_t__Base'")
    _hipblasCtrmvStridedBatched__retval = hipblasStatus_t(chipblas.hipblasCtrmvStridedBatched(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,uplo.value,transA.value,diag.value,n,
        hipblasComplex.fromPyobj(AP).getElementPtr(),lda,strideA,
        hipblasComplex.fromPyobj(x).getElementPtr(),incx,stridex,batchCount))
    return (_hipblasCtrmvStridedBatched__retval,)


@cython.embedsignature(True)
def hipblasZtrmvStridedBatched(object handle, object uplo, object transA, object diag, int n, object AP, int lda, long strideA, object x, int incx, long stridex, int batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        uplo (`~.hipblasFillMode_t`):
            (undocumented)

        transA (`~.hipblasOperation_t`):
            (undocumented)

        diag (`~.hipblasDiagType_t`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        AP (`~.hipblasDoubleComplex`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        strideA (`~.int`):
            (undocumented)

        x (`~.hipblasDoubleComplex`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        stridex (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")                    
    if not isinstance(transA,_hipblasOperation_t__Base):
        raise TypeError("argument 'transA' must be of type '_hipblasOperation_t__Base'")                    
    if not isinstance(diag,_hipblasDiagType_t__Base):
        raise TypeError("argument 'diag' must be of type '_hipblasDiagType_t__Base'")
    _hipblasZtrmvStridedBatched__retval = hipblasStatus_t(chipblas.hipblasZtrmvStridedBatched(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,uplo.value,transA.value,diag.value,n,
        hipblasDoubleComplex.fromPyobj(AP).getElementPtr(),lda,strideA,
        hipblasDoubleComplex.fromPyobj(x).getElementPtr(),incx,stridex,batchCount))
    return (_hipblasZtrmvStridedBatched__retval,)


@cython.embedsignature(True)
def hipblasCtrmvStridedBatched_v2(object handle, object uplo, object transA, object diag, int n, object AP, int lda, long strideA, object x, int incx, long stridex, int batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        uplo (`~.hipblasFillMode_t`):
            (undocumented)

        transA (`~.hipblasOperation_t`):
            (undocumented)

        diag (`~.hipblasDiagType_t`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        AP (`~.float2`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        strideA (`~.int`):
            (undocumented)

        x (`~.float2`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        stridex (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")                    
    if not isinstance(transA,_hipblasOperation_t__Base):
        raise TypeError("argument 'transA' must be of type '_hipblasOperation_t__Base'")                    
    if not isinstance(diag,_hipblasDiagType_t__Base):
        raise TypeError("argument 'diag' must be of type '_hipblasDiagType_t__Base'")
    _hipblasCtrmvStridedBatched_v2__retval = hipblasStatus_t(chipblas.hipblasCtrmvStridedBatched_v2(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,uplo.value,transA.value,diag.value,n,
        float2.fromPyobj(AP).getElementPtr(),lda,strideA,
        float2.fromPyobj(x).getElementPtr(),incx,stridex,batchCount))
    return (_hipblasCtrmvStridedBatched_v2__retval,)


@cython.embedsignature(True)
def hipblasZtrmvStridedBatched_v2(object handle, object uplo, object transA, object diag, int n, object AP, int lda, long strideA, object x, int incx, long stridex, int batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        uplo (`~.hipblasFillMode_t`):
            (undocumented)

        transA (`~.hipblasOperation_t`):
            (undocumented)

        diag (`~.hipblasDiagType_t`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        AP (`~.double2`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        strideA (`~.int`):
            (undocumented)

        x (`~.double2`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        stridex (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")                    
    if not isinstance(transA,_hipblasOperation_t__Base):
        raise TypeError("argument 'transA' must be of type '_hipblasOperation_t__Base'")                    
    if not isinstance(diag,_hipblasDiagType_t__Base):
        raise TypeError("argument 'diag' must be of type '_hipblasDiagType_t__Base'")
    _hipblasZtrmvStridedBatched_v2__retval = hipblasStatus_t(chipblas.hipblasZtrmvStridedBatched_v2(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,uplo.value,transA.value,diag.value,n,
        double2.fromPyobj(AP).getElementPtr(),lda,strideA,
        double2.fromPyobj(x).getElementPtr(),incx,stridex,batchCount))
    return (_hipblasZtrmvStridedBatched_v2__retval,)


@cython.embedsignature(True)
def hipblasStrmvStridedBatched_64(object handle, object uplo, object transA, object diag, long n, object AP, long lda, long strideA, object x, long incx, long stridex, long batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        uplo (`~.hipblasFillMode_t`):
            (undocumented)

        transA (`~.hipblasOperation_t`):
            (undocumented)

        diag (`~.hipblasDiagType_t`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        AP (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        strideA (`~.int`):
            (undocumented)

        x (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        stridex (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")                    
    if not isinstance(transA,_hipblasOperation_t__Base):
        raise TypeError("argument 'transA' must be of type '_hipblasOperation_t__Base'")                    
    if not isinstance(diag,_hipblasDiagType_t__Base):
        raise TypeError("argument 'diag' must be of type '_hipblasDiagType_t__Base'")
    _hipblasStrmvStridedBatched_64__retval = hipblasStatus_t(chipblas.hipblasStrmvStridedBatched_64(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,uplo.value,transA.value,diag.value,n,
        <const float *>hip._util.types.Pointer.fromPyobj(AP)._ptr,lda,strideA,
        <float *>hip._util.types.Pointer.fromPyobj(x)._ptr,incx,stridex,batchCount))
    return (_hipblasStrmvStridedBatched_64__retval,)


@cython.embedsignature(True)
def hipblasDtrmvStridedBatched_64(object handle, object uplo, object transA, object diag, long n, object AP, long lda, long strideA, object x, long incx, long stridex, long batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        uplo (`~.hipblasFillMode_t`):
            (undocumented)

        transA (`~.hipblasOperation_t`):
            (undocumented)

        diag (`~.hipblasDiagType_t`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        AP (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        strideA (`~.int`):
            (undocumented)

        x (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        stridex (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")                    
    if not isinstance(transA,_hipblasOperation_t__Base):
        raise TypeError("argument 'transA' must be of type '_hipblasOperation_t__Base'")                    
    if not isinstance(diag,_hipblasDiagType_t__Base):
        raise TypeError("argument 'diag' must be of type '_hipblasDiagType_t__Base'")
    _hipblasDtrmvStridedBatched_64__retval = hipblasStatus_t(chipblas.hipblasDtrmvStridedBatched_64(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,uplo.value,transA.value,diag.value,n,
        <const double *>hip._util.types.Pointer.fromPyobj(AP)._ptr,lda,strideA,
        <double *>hip._util.types.Pointer.fromPyobj(x)._ptr,incx,stridex,batchCount))
    return (_hipblasDtrmvStridedBatched_64__retval,)


@cython.embedsignature(True)
def hipblasCtrmvStridedBatched_64(object handle, object uplo, object transA, object diag, long n, object AP, long lda, long strideA, object x, long incx, long stridex, long batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        uplo (`~.hipblasFillMode_t`):
            (undocumented)

        transA (`~.hipblasOperation_t`):
            (undocumented)

        diag (`~.hipblasDiagType_t`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        AP (`~.hipblasComplex`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        strideA (`~.int`):
            (undocumented)

        x (`~.hipblasComplex`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        stridex (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")                    
    if not isinstance(transA,_hipblasOperation_t__Base):
        raise TypeError("argument 'transA' must be of type '_hipblasOperation_t__Base'")                    
    if not isinstance(diag,_hipblasDiagType_t__Base):
        raise TypeError("argument 'diag' must be of type '_hipblasDiagType_t__Base'")
    _hipblasCtrmvStridedBatched_64__retval = hipblasStatus_t(chipblas.hipblasCtrmvStridedBatched_64(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,uplo.value,transA.value,diag.value,n,
        hipblasComplex.fromPyobj(AP).getElementPtr(),lda,strideA,
        hipblasComplex.fromPyobj(x).getElementPtr(),incx,stridex,batchCount))
    return (_hipblasCtrmvStridedBatched_64__retval,)


@cython.embedsignature(True)
def hipblasZtrmvStridedBatched_64(object handle, object uplo, object transA, object diag, long n, object AP, long lda, long strideA, object x, long incx, long stridex, long batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        uplo (`~.hipblasFillMode_t`):
            (undocumented)

        transA (`~.hipblasOperation_t`):
            (undocumented)

        diag (`~.hipblasDiagType_t`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        AP (`~.hipblasDoubleComplex`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        strideA (`~.int`):
            (undocumented)

        x (`~.hipblasDoubleComplex`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        stridex (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")                    
    if not isinstance(transA,_hipblasOperation_t__Base):
        raise TypeError("argument 'transA' must be of type '_hipblasOperation_t__Base'")                    
    if not isinstance(diag,_hipblasDiagType_t__Base):
        raise TypeError("argument 'diag' must be of type '_hipblasDiagType_t__Base'")
    _hipblasZtrmvStridedBatched_64__retval = hipblasStatus_t(chipblas.hipblasZtrmvStridedBatched_64(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,uplo.value,transA.value,diag.value,n,
        hipblasDoubleComplex.fromPyobj(AP).getElementPtr(),lda,strideA,
        hipblasDoubleComplex.fromPyobj(x).getElementPtr(),incx,stridex,batchCount))
    return (_hipblasZtrmvStridedBatched_64__retval,)


@cython.embedsignature(True)
def hipblasCtrmvStridedBatched_v2_64(object handle, object uplo, object transA, object diag, long n, object AP, long lda, long strideA, object x, long incx, long stridex, long batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        uplo (`~.hipblasFillMode_t`):
            (undocumented)

        transA (`~.hipblasOperation_t`):
            (undocumented)

        diag (`~.hipblasDiagType_t`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        AP (`~.float2`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        strideA (`~.int`):
            (undocumented)

        x (`~.float2`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        stridex (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")                    
    if not isinstance(transA,_hipblasOperation_t__Base):
        raise TypeError("argument 'transA' must be of type '_hipblasOperation_t__Base'")                    
    if not isinstance(diag,_hipblasDiagType_t__Base):
        raise TypeError("argument 'diag' must be of type '_hipblasDiagType_t__Base'")
    _hipblasCtrmvStridedBatched_v2_64__retval = hipblasStatus_t(chipblas.hipblasCtrmvStridedBatched_v2_64(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,uplo.value,transA.value,diag.value,n,
        float2.fromPyobj(AP).getElementPtr(),lda,strideA,
        float2.fromPyobj(x).getElementPtr(),incx,stridex,batchCount))
    return (_hipblasCtrmvStridedBatched_v2_64__retval,)


@cython.embedsignature(True)
def hipblasZtrmvStridedBatched_v2_64(object handle, object uplo, object transA, object diag, long n, object AP, long lda, long strideA, object x, long incx, long stridex, long batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        uplo (`~.hipblasFillMode_t`):
            (undocumented)

        transA (`~.hipblasOperation_t`):
            (undocumented)

        diag (`~.hipblasDiagType_t`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        AP (`~.double2`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        strideA (`~.int`):
            (undocumented)

        x (`~.double2`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        stridex (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")                    
    if not isinstance(transA,_hipblasOperation_t__Base):
        raise TypeError("argument 'transA' must be of type '_hipblasOperation_t__Base'")                    
    if not isinstance(diag,_hipblasDiagType_t__Base):
        raise TypeError("argument 'diag' must be of type '_hipblasDiagType_t__Base'")
    _hipblasZtrmvStridedBatched_v2_64__retval = hipblasStatus_t(chipblas.hipblasZtrmvStridedBatched_v2_64(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,uplo.value,transA.value,diag.value,n,
        double2.fromPyobj(AP).getElementPtr(),lda,strideA,
        double2.fromPyobj(x).getElementPtr(),incx,stridex,batchCount))
    return (_hipblasZtrmvStridedBatched_v2_64__retval,)


@cython.embedsignature(True)
def hipblasStrsv(object handle, object uplo, object transA, object diag, int n, object AP, int lda, object x, int incx):
    r"""BLAS Level 2 API

    @{

    trsv solves

    A*x = b or A**T*x = b,

    where x and b are vectors and A is a triangular matrix.

    The vector x is overwritten on b.

    - Supported precisions in rocBLAS : s,d,c,z
    - Supported precisions in cuBLAS  : s,d,c,z

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`) -- *IN*:
            [hipblasHandle_t]
            handle to the hipblas library context queue.

        uplo (`~.hipblasFillMode_t`) -- *IN*:
            [hipblasFillMode_t]
            HIPBLAS_FILL_MODE_UPPER:  A is an upper triangular matrix.
            HIPBLAS_FILL_MODE_LOWER:  A is a  lower triangular matrix.

        transA (`~.hipblasOperation_t`) -- *IN*:
            [hipblasOperation_t]

        diag (`~.hipblasDiagType_t`) -- *IN*:
            [hipblasDiagType_t]
            HIPBLAS_DIAG_UNIT:     A is assumed to be unit triangular.
            HIPBLAS_DIAG_NON_UNIT:  A is not assumed to be unit triangular.

        n (`~.int`) -- *IN*:
            [int]
            n specifies the number of rows of b. n >= 0.

        AP (`~.hip._util.types.Pointer`/`~.object`) -- *IN*:
            device pointer storing matrix A,
            of dimension ( lda, n )

        lda (`~.int`) -- *IN*:
            [int]
            specifies the leading dimension of A.
            lda = max( 1, n ).

        x (`~.hip._util.types.Pointer`/`~.object`) -- *IN*:
            device pointer storing vector x.

        incx (`~.int`) -- *IN*:
            [int]
            specifies the increment for the elements of x.
    """
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")                    
    if not isinstance(transA,_hipblasOperation_t__Base):
        raise TypeError("argument 'transA' must be of type '_hipblasOperation_t__Base'")                    
    if not isinstance(diag,_hipblasDiagType_t__Base):
        raise TypeError("argument 'diag' must be of type '_hipblasDiagType_t__Base'")
    _hipblasStrsv__retval = hipblasStatus_t(chipblas.hipblasStrsv(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,uplo.value,transA.value,diag.value,n,
        <const float *>hip._util.types.Pointer.fromPyobj(AP)._ptr,lda,
        <float *>hip._util.types.Pointer.fromPyobj(x)._ptr,incx))
    return (_hipblasStrsv__retval,)


@cython.embedsignature(True)
def hipblasDtrsv(object handle, object uplo, object transA, object diag, int n, object AP, int lda, object x, int incx):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        uplo (`~.hipblasFillMode_t`):
            (undocumented)

        transA (`~.hipblasOperation_t`):
            (undocumented)

        diag (`~.hipblasDiagType_t`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        AP (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        x (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)
    """
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")                    
    if not isinstance(transA,_hipblasOperation_t__Base):
        raise TypeError("argument 'transA' must be of type '_hipblasOperation_t__Base'")                    
    if not isinstance(diag,_hipblasDiagType_t__Base):
        raise TypeError("argument 'diag' must be of type '_hipblasDiagType_t__Base'")
    _hipblasDtrsv__retval = hipblasStatus_t(chipblas.hipblasDtrsv(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,uplo.value,transA.value,diag.value,n,
        <const double *>hip._util.types.Pointer.fromPyobj(AP)._ptr,lda,
        <double *>hip._util.types.Pointer.fromPyobj(x)._ptr,incx))
    return (_hipblasDtrsv__retval,)


@cython.embedsignature(True)
def hipblasCtrsv(object handle, object uplo, object transA, object diag, int n, object AP, int lda, object x, int incx):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        uplo (`~.hipblasFillMode_t`):
            (undocumented)

        transA (`~.hipblasOperation_t`):
            (undocumented)

        diag (`~.hipblasDiagType_t`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        AP (`~.hipblasComplex`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        x (`~.hipblasComplex`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)
    """
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")                    
    if not isinstance(transA,_hipblasOperation_t__Base):
        raise TypeError("argument 'transA' must be of type '_hipblasOperation_t__Base'")                    
    if not isinstance(diag,_hipblasDiagType_t__Base):
        raise TypeError("argument 'diag' must be of type '_hipblasDiagType_t__Base'")
    _hipblasCtrsv__retval = hipblasStatus_t(chipblas.hipblasCtrsv(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,uplo.value,transA.value,diag.value,n,
        hipblasComplex.fromPyobj(AP).getElementPtr(),lda,
        hipblasComplex.fromPyobj(x).getElementPtr(),incx))
    return (_hipblasCtrsv__retval,)


@cython.embedsignature(True)
def hipblasZtrsv(object handle, object uplo, object transA, object diag, int n, object AP, int lda, object x, int incx):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        uplo (`~.hipblasFillMode_t`):
            (undocumented)

        transA (`~.hipblasOperation_t`):
            (undocumented)

        diag (`~.hipblasDiagType_t`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        AP (`~.hipblasDoubleComplex`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        x (`~.hipblasDoubleComplex`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)
    """
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")                    
    if not isinstance(transA,_hipblasOperation_t__Base):
        raise TypeError("argument 'transA' must be of type '_hipblasOperation_t__Base'")                    
    if not isinstance(diag,_hipblasDiagType_t__Base):
        raise TypeError("argument 'diag' must be of type '_hipblasDiagType_t__Base'")
    _hipblasZtrsv__retval = hipblasStatus_t(chipblas.hipblasZtrsv(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,uplo.value,transA.value,diag.value,n,
        hipblasDoubleComplex.fromPyobj(AP).getElementPtr(),lda,
        hipblasDoubleComplex.fromPyobj(x).getElementPtr(),incx))
    return (_hipblasZtrsv__retval,)


@cython.embedsignature(True)
def hipblasCtrsv_v2(object handle, object uplo, object transA, object diag, int n, object AP, int lda, object x, int incx):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        uplo (`~.hipblasFillMode_t`):
            (undocumented)

        transA (`~.hipblasOperation_t`):
            (undocumented)

        diag (`~.hipblasDiagType_t`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        AP (`~.float2`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        x (`~.float2`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)
    """
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")                    
    if not isinstance(transA,_hipblasOperation_t__Base):
        raise TypeError("argument 'transA' must be of type '_hipblasOperation_t__Base'")                    
    if not isinstance(diag,_hipblasDiagType_t__Base):
        raise TypeError("argument 'diag' must be of type '_hipblasDiagType_t__Base'")
    _hipblasCtrsv_v2__retval = hipblasStatus_t(chipblas.hipblasCtrsv_v2(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,uplo.value,transA.value,diag.value,n,
        float2.fromPyobj(AP).getElementPtr(),lda,
        float2.fromPyobj(x).getElementPtr(),incx))
    return (_hipblasCtrsv_v2__retval,)


@cython.embedsignature(True)
def hipblasZtrsv_v2(object handle, object uplo, object transA, object diag, int n, object AP, int lda, object x, int incx):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        uplo (`~.hipblasFillMode_t`):
            (undocumented)

        transA (`~.hipblasOperation_t`):
            (undocumented)

        diag (`~.hipblasDiagType_t`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        AP (`~.double2`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        x (`~.double2`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)
    """
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")                    
    if not isinstance(transA,_hipblasOperation_t__Base):
        raise TypeError("argument 'transA' must be of type '_hipblasOperation_t__Base'")                    
    if not isinstance(diag,_hipblasDiagType_t__Base):
        raise TypeError("argument 'diag' must be of type '_hipblasDiagType_t__Base'")
    _hipblasZtrsv_v2__retval = hipblasStatus_t(chipblas.hipblasZtrsv_v2(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,uplo.value,transA.value,diag.value,n,
        double2.fromPyobj(AP).getElementPtr(),lda,
        double2.fromPyobj(x).getElementPtr(),incx))
    return (_hipblasZtrsv_v2__retval,)


@cython.embedsignature(True)
def hipblasStrsv_64(object handle, object uplo, object transA, object diag, long n, object AP, long lda, object x, long incx):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        uplo (`~.hipblasFillMode_t`):
            (undocumented)

        transA (`~.hipblasOperation_t`):
            (undocumented)

        diag (`~.hipblasDiagType_t`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        AP (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        x (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)
    """
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")                    
    if not isinstance(transA,_hipblasOperation_t__Base):
        raise TypeError("argument 'transA' must be of type '_hipblasOperation_t__Base'")                    
    if not isinstance(diag,_hipblasDiagType_t__Base):
        raise TypeError("argument 'diag' must be of type '_hipblasDiagType_t__Base'")
    _hipblasStrsv_64__retval = hipblasStatus_t(chipblas.hipblasStrsv_64(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,uplo.value,transA.value,diag.value,n,
        <const float *>hip._util.types.Pointer.fromPyobj(AP)._ptr,lda,
        <float *>hip._util.types.Pointer.fromPyobj(x)._ptr,incx))
    return (_hipblasStrsv_64__retval,)


@cython.embedsignature(True)
def hipblasDtrsv_64(object handle, object uplo, object transA, object diag, long n, object AP, long lda, object x, long incx):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        uplo (`~.hipblasFillMode_t`):
            (undocumented)

        transA (`~.hipblasOperation_t`):
            (undocumented)

        diag (`~.hipblasDiagType_t`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        AP (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        x (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)
    """
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")                    
    if not isinstance(transA,_hipblasOperation_t__Base):
        raise TypeError("argument 'transA' must be of type '_hipblasOperation_t__Base'")                    
    if not isinstance(diag,_hipblasDiagType_t__Base):
        raise TypeError("argument 'diag' must be of type '_hipblasDiagType_t__Base'")
    _hipblasDtrsv_64__retval = hipblasStatus_t(chipblas.hipblasDtrsv_64(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,uplo.value,transA.value,diag.value,n,
        <const double *>hip._util.types.Pointer.fromPyobj(AP)._ptr,lda,
        <double *>hip._util.types.Pointer.fromPyobj(x)._ptr,incx))
    return (_hipblasDtrsv_64__retval,)


@cython.embedsignature(True)
def hipblasCtrsv_64(object handle, object uplo, object transA, object diag, long n, object AP, long lda, object x, long incx):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        uplo (`~.hipblasFillMode_t`):
            (undocumented)

        transA (`~.hipblasOperation_t`):
            (undocumented)

        diag (`~.hipblasDiagType_t`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        AP (`~.hipblasComplex`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        x (`~.hipblasComplex`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)
    """
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")                    
    if not isinstance(transA,_hipblasOperation_t__Base):
        raise TypeError("argument 'transA' must be of type '_hipblasOperation_t__Base'")                    
    if not isinstance(diag,_hipblasDiagType_t__Base):
        raise TypeError("argument 'diag' must be of type '_hipblasDiagType_t__Base'")
    _hipblasCtrsv_64__retval = hipblasStatus_t(chipblas.hipblasCtrsv_64(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,uplo.value,transA.value,diag.value,n,
        hipblasComplex.fromPyobj(AP).getElementPtr(),lda,
        hipblasComplex.fromPyobj(x).getElementPtr(),incx))
    return (_hipblasCtrsv_64__retval,)


@cython.embedsignature(True)
def hipblasZtrsv_64(object handle, object uplo, object transA, object diag, long n, object AP, long lda, object x, long incx):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        uplo (`~.hipblasFillMode_t`):
            (undocumented)

        transA (`~.hipblasOperation_t`):
            (undocumented)

        diag (`~.hipblasDiagType_t`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        AP (`~.hipblasDoubleComplex`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        x (`~.hipblasDoubleComplex`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)
    """
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")                    
    if not isinstance(transA,_hipblasOperation_t__Base):
        raise TypeError("argument 'transA' must be of type '_hipblasOperation_t__Base'")                    
    if not isinstance(diag,_hipblasDiagType_t__Base):
        raise TypeError("argument 'diag' must be of type '_hipblasDiagType_t__Base'")
    _hipblasZtrsv_64__retval = hipblasStatus_t(chipblas.hipblasZtrsv_64(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,uplo.value,transA.value,diag.value,n,
        hipblasDoubleComplex.fromPyobj(AP).getElementPtr(),lda,
        hipblasDoubleComplex.fromPyobj(x).getElementPtr(),incx))
    return (_hipblasZtrsv_64__retval,)


@cython.embedsignature(True)
def hipblasCtrsv_v2_64(object handle, object uplo, object transA, object diag, long n, object AP, long lda, object x, long incx):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        uplo (`~.hipblasFillMode_t`):
            (undocumented)

        transA (`~.hipblasOperation_t`):
            (undocumented)

        diag (`~.hipblasDiagType_t`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        AP (`~.float2`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        x (`~.float2`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)
    """
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")                    
    if not isinstance(transA,_hipblasOperation_t__Base):
        raise TypeError("argument 'transA' must be of type '_hipblasOperation_t__Base'")                    
    if not isinstance(diag,_hipblasDiagType_t__Base):
        raise TypeError("argument 'diag' must be of type '_hipblasDiagType_t__Base'")
    _hipblasCtrsv_v2_64__retval = hipblasStatus_t(chipblas.hipblasCtrsv_v2_64(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,uplo.value,transA.value,diag.value,n,
        float2.fromPyobj(AP).getElementPtr(),lda,
        float2.fromPyobj(x).getElementPtr(),incx))
    return (_hipblasCtrsv_v2_64__retval,)


@cython.embedsignature(True)
def hipblasZtrsv_v2_64(object handle, object uplo, object transA, object diag, long n, object AP, long lda, object x, long incx):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        uplo (`~.hipblasFillMode_t`):
            (undocumented)

        transA (`~.hipblasOperation_t`):
            (undocumented)

        diag (`~.hipblasDiagType_t`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        AP (`~.double2`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        x (`~.double2`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)
    """
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")                    
    if not isinstance(transA,_hipblasOperation_t__Base):
        raise TypeError("argument 'transA' must be of type '_hipblasOperation_t__Base'")                    
    if not isinstance(diag,_hipblasDiagType_t__Base):
        raise TypeError("argument 'diag' must be of type '_hipblasDiagType_t__Base'")
    _hipblasZtrsv_v2_64__retval = hipblasStatus_t(chipblas.hipblasZtrsv_v2_64(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,uplo.value,transA.value,diag.value,n,
        double2.fromPyobj(AP).getElementPtr(),lda,
        double2.fromPyobj(x).getElementPtr(),incx))
    return (_hipblasZtrsv_v2_64__retval,)


@cython.embedsignature(True)
def hipblasStrsvBatched(object handle, object uplo, object transA, object diag, int n, object AP, int lda, object x, int incx, int batchCount):
    r"""BLAS Level 2 API

    @{

    trsvBatched solves

    A_i*x_i = b_i or A_i**T*x_i = b_i,

    where (A_i, x_i, b_i) is the i-th instance of the batch.
    x_i and b_i are vectors and A_i is an
    n by n triangular matrix.

    The vector x is overwritten on b.

    - Supported precisions in rocBLAS : s,d,c,z
    - Supported precisions in cuBLAS  : No support

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`) -- *IN*:
            [hipblasHandle_t]
            handle to the hipblas library context queue.

        uplo (`~.hipblasFillMode_t`) -- *IN*:
            [hipblasFillMode_t]
            HIPBLAS_FILL_MODE_UPPER:  A is an upper triangular matrix.
            HIPBLAS_FILL_MODE_LOWER:  A is a  lower triangular matrix.

        transA (`~.hipblasOperation_t`) -- *IN*:
            [hipblasOperation_t]

        diag (`~.hipblasDiagType_t`) -- *IN*:
            [hipblasDiagType_t]
            HIPBLAS_DIAG_UNIT:     A is assumed to be unit triangular.
            HIPBLAS_DIAG_NON_UNIT:  A is not assumed to be unit triangular.

        n (`~.int`) -- *IN*:
            [int]
            n specifies the number of rows of b. n >= 0.

        AP (`~.hip._util.types.Pointer`/`~.object`) -- *IN*:
            device array of device pointers storing each matrix A_i.

        lda (`~.int`) -- *IN*:
            [int]
            specifies the leading dimension of each A_i.
            lda = max(1, n)

        x (`~.hip._util.types.ListOfPointer`/`~.object`) -- *IN*:
            device array of device pointers storing each vector x_i.

        incx (`~.int`) -- *IN*:
            [int]
            specifies the increment for the elements of x.

        batchCount (`~.int`) -- *IN*:
            [int]
            number of instances in the batch
    """
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")                    
    if not isinstance(transA,_hipblasOperation_t__Base):
        raise TypeError("argument 'transA' must be of type '_hipblasOperation_t__Base'")                    
    if not isinstance(diag,_hipblasDiagType_t__Base):
        raise TypeError("argument 'diag' must be of type '_hipblasDiagType_t__Base'")
    _hipblasStrsvBatched__retval = hipblasStatus_t(chipblas.hipblasStrsvBatched(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,uplo.value,transA.value,diag.value,n,
        <const float *const*>hip._util.types.Pointer.fromPyobj(AP)._ptr,lda,
        <float *const*>hip._util.types.ListOfPointer.fromPyobj(x)._ptr,incx,batchCount))
    return (_hipblasStrsvBatched__retval,)


@cython.embedsignature(True)
def hipblasDtrsvBatched(object handle, object uplo, object transA, object diag, int n, object AP, int lda, object x, int incx, int batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        uplo (`~.hipblasFillMode_t`):
            (undocumented)

        transA (`~.hipblasOperation_t`):
            (undocumented)

        diag (`~.hipblasDiagType_t`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        AP (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        x (`~.hip._util.types.ListOfPointer`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")                    
    if not isinstance(transA,_hipblasOperation_t__Base):
        raise TypeError("argument 'transA' must be of type '_hipblasOperation_t__Base'")                    
    if not isinstance(diag,_hipblasDiagType_t__Base):
        raise TypeError("argument 'diag' must be of type '_hipblasDiagType_t__Base'")
    _hipblasDtrsvBatched__retval = hipblasStatus_t(chipblas.hipblasDtrsvBatched(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,uplo.value,transA.value,diag.value,n,
        <const double *const*>hip._util.types.Pointer.fromPyobj(AP)._ptr,lda,
        <double *const*>hip._util.types.ListOfPointer.fromPyobj(x)._ptr,incx,batchCount))
    return (_hipblasDtrsvBatched__retval,)


@cython.embedsignature(True)
def hipblasCtrsvBatched(object handle, object uplo, object transA, object diag, int n, object AP, int lda, object x, int incx, int batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        uplo (`~.hipblasFillMode_t`):
            (undocumented)

        transA (`~.hipblasOperation_t`):
            (undocumented)

        diag (`~.hipblasDiagType_t`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        AP (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        x (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")                    
    if not isinstance(transA,_hipblasOperation_t__Base):
        raise TypeError("argument 'transA' must be of type '_hipblasOperation_t__Base'")                    
    if not isinstance(diag,_hipblasDiagType_t__Base):
        raise TypeError("argument 'diag' must be of type '_hipblasDiagType_t__Base'")
    _hipblasCtrsvBatched__retval = hipblasStatus_t(chipblas.hipblasCtrsvBatched(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,uplo.value,transA.value,diag.value,n,
        <chipblas.hipblasComplex *const*>hip._util.types.Pointer.fromPyobj(AP)._ptr,lda,
        <chipblas.hipblasComplex *const*>hip._util.types.Pointer.fromPyobj(x)._ptr,incx,batchCount))
    return (_hipblasCtrsvBatched__retval,)


@cython.embedsignature(True)
def hipblasZtrsvBatched(object handle, object uplo, object transA, object diag, int n, object AP, int lda, object x, int incx, int batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        uplo (`~.hipblasFillMode_t`):
            (undocumented)

        transA (`~.hipblasOperation_t`):
            (undocumented)

        diag (`~.hipblasDiagType_t`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        AP (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        x (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")                    
    if not isinstance(transA,_hipblasOperation_t__Base):
        raise TypeError("argument 'transA' must be of type '_hipblasOperation_t__Base'")                    
    if not isinstance(diag,_hipblasDiagType_t__Base):
        raise TypeError("argument 'diag' must be of type '_hipblasDiagType_t__Base'")
    _hipblasZtrsvBatched__retval = hipblasStatus_t(chipblas.hipblasZtrsvBatched(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,uplo.value,transA.value,diag.value,n,
        <chipblas.hipblasDoubleComplex *const*>hip._util.types.Pointer.fromPyobj(AP)._ptr,lda,
        <chipblas.hipblasDoubleComplex *const*>hip._util.types.Pointer.fromPyobj(x)._ptr,incx,batchCount))
    return (_hipblasZtrsvBatched__retval,)


@cython.embedsignature(True)
def hipblasCtrsvBatched_v2(object handle, object uplo, object transA, object diag, int n, object AP, int lda, object x, int incx, int batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        uplo (`~.hipblasFillMode_t`):
            (undocumented)

        transA (`~.hipblasOperation_t`):
            (undocumented)

        diag (`~.hipblasDiagType_t`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        AP (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        x (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")                    
    if not isinstance(transA,_hipblasOperation_t__Base):
        raise TypeError("argument 'transA' must be of type '_hipblasOperation_t__Base'")                    
    if not isinstance(diag,_hipblasDiagType_t__Base):
        raise TypeError("argument 'diag' must be of type '_hipblasDiagType_t__Base'")
    _hipblasCtrsvBatched_v2__retval = hipblasStatus_t(chipblas.hipblasCtrsvBatched_v2(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,uplo.value,transA.value,diag.value,n,
        <chipblas.float2 *const*>hip._util.types.Pointer.fromPyobj(AP)._ptr,lda,
        <chipblas.float2 *const*>hip._util.types.Pointer.fromPyobj(x)._ptr,incx,batchCount))
    return (_hipblasCtrsvBatched_v2__retval,)


@cython.embedsignature(True)
def hipblasZtrsvBatched_v2(object handle, object uplo, object transA, object diag, int n, object AP, int lda, object x, int incx, int batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        uplo (`~.hipblasFillMode_t`):
            (undocumented)

        transA (`~.hipblasOperation_t`):
            (undocumented)

        diag (`~.hipblasDiagType_t`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        AP (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        x (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")                    
    if not isinstance(transA,_hipblasOperation_t__Base):
        raise TypeError("argument 'transA' must be of type '_hipblasOperation_t__Base'")                    
    if not isinstance(diag,_hipblasDiagType_t__Base):
        raise TypeError("argument 'diag' must be of type '_hipblasDiagType_t__Base'")
    _hipblasZtrsvBatched_v2__retval = hipblasStatus_t(chipblas.hipblasZtrsvBatched_v2(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,uplo.value,transA.value,diag.value,n,
        <chipblas.double2 *const*>hip._util.types.Pointer.fromPyobj(AP)._ptr,lda,
        <chipblas.double2 *const*>hip._util.types.Pointer.fromPyobj(x)._ptr,incx,batchCount))
    return (_hipblasZtrsvBatched_v2__retval,)


@cython.embedsignature(True)
def hipblasStrsvBatched_64(object handle, object uplo, object transA, object diag, long n, object AP, long lda, object x, long incx, long batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        uplo (`~.hipblasFillMode_t`):
            (undocumented)

        transA (`~.hipblasOperation_t`):
            (undocumented)

        diag (`~.hipblasDiagType_t`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        AP (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        x (`~.hip._util.types.ListOfPointer`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")                    
    if not isinstance(transA,_hipblasOperation_t__Base):
        raise TypeError("argument 'transA' must be of type '_hipblasOperation_t__Base'")                    
    if not isinstance(diag,_hipblasDiagType_t__Base):
        raise TypeError("argument 'diag' must be of type '_hipblasDiagType_t__Base'")
    _hipblasStrsvBatched_64__retval = hipblasStatus_t(chipblas.hipblasStrsvBatched_64(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,uplo.value,transA.value,diag.value,n,
        <const float *const*>hip._util.types.Pointer.fromPyobj(AP)._ptr,lda,
        <float *const*>hip._util.types.ListOfPointer.fromPyobj(x)._ptr,incx,batchCount))
    return (_hipblasStrsvBatched_64__retval,)


@cython.embedsignature(True)
def hipblasDtrsvBatched_64(object handle, object uplo, object transA, object diag, long n, object AP, long lda, object x, long incx, long batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        uplo (`~.hipblasFillMode_t`):
            (undocumented)

        transA (`~.hipblasOperation_t`):
            (undocumented)

        diag (`~.hipblasDiagType_t`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        AP (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        x (`~.hip._util.types.ListOfPointer`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")                    
    if not isinstance(transA,_hipblasOperation_t__Base):
        raise TypeError("argument 'transA' must be of type '_hipblasOperation_t__Base'")                    
    if not isinstance(diag,_hipblasDiagType_t__Base):
        raise TypeError("argument 'diag' must be of type '_hipblasDiagType_t__Base'")
    _hipblasDtrsvBatched_64__retval = hipblasStatus_t(chipblas.hipblasDtrsvBatched_64(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,uplo.value,transA.value,diag.value,n,
        <const double *const*>hip._util.types.Pointer.fromPyobj(AP)._ptr,lda,
        <double *const*>hip._util.types.ListOfPointer.fromPyobj(x)._ptr,incx,batchCount))
    return (_hipblasDtrsvBatched_64__retval,)


@cython.embedsignature(True)
def hipblasCtrsvBatched_64(object handle, object uplo, object transA, object diag, long n, object AP, long lda, object x, long incx, long batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        uplo (`~.hipblasFillMode_t`):
            (undocumented)

        transA (`~.hipblasOperation_t`):
            (undocumented)

        diag (`~.hipblasDiagType_t`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        AP (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        x (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")                    
    if not isinstance(transA,_hipblasOperation_t__Base):
        raise TypeError("argument 'transA' must be of type '_hipblasOperation_t__Base'")                    
    if not isinstance(diag,_hipblasDiagType_t__Base):
        raise TypeError("argument 'diag' must be of type '_hipblasDiagType_t__Base'")
    _hipblasCtrsvBatched_64__retval = hipblasStatus_t(chipblas.hipblasCtrsvBatched_64(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,uplo.value,transA.value,diag.value,n,
        <chipblas.hipblasComplex *const*>hip._util.types.Pointer.fromPyobj(AP)._ptr,lda,
        <chipblas.hipblasComplex *const*>hip._util.types.Pointer.fromPyobj(x)._ptr,incx,batchCount))
    return (_hipblasCtrsvBatched_64__retval,)


@cython.embedsignature(True)
def hipblasZtrsvBatched_64(object handle, object uplo, object transA, object diag, long n, object AP, long lda, object x, long incx, long batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        uplo (`~.hipblasFillMode_t`):
            (undocumented)

        transA (`~.hipblasOperation_t`):
            (undocumented)

        diag (`~.hipblasDiagType_t`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        AP (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        x (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")                    
    if not isinstance(transA,_hipblasOperation_t__Base):
        raise TypeError("argument 'transA' must be of type '_hipblasOperation_t__Base'")                    
    if not isinstance(diag,_hipblasDiagType_t__Base):
        raise TypeError("argument 'diag' must be of type '_hipblasDiagType_t__Base'")
    _hipblasZtrsvBatched_64__retval = hipblasStatus_t(chipblas.hipblasZtrsvBatched_64(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,uplo.value,transA.value,diag.value,n,
        <chipblas.hipblasDoubleComplex *const*>hip._util.types.Pointer.fromPyobj(AP)._ptr,lda,
        <chipblas.hipblasDoubleComplex *const*>hip._util.types.Pointer.fromPyobj(x)._ptr,incx,batchCount))
    return (_hipblasZtrsvBatched_64__retval,)


@cython.embedsignature(True)
def hipblasCtrsvBatched_v2_64(object handle, object uplo, object transA, object diag, long n, object AP, long lda, object x, long incx, long batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        uplo (`~.hipblasFillMode_t`):
            (undocumented)

        transA (`~.hipblasOperation_t`):
            (undocumented)

        diag (`~.hipblasDiagType_t`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        AP (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        x (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")                    
    if not isinstance(transA,_hipblasOperation_t__Base):
        raise TypeError("argument 'transA' must be of type '_hipblasOperation_t__Base'")                    
    if not isinstance(diag,_hipblasDiagType_t__Base):
        raise TypeError("argument 'diag' must be of type '_hipblasDiagType_t__Base'")
    _hipblasCtrsvBatched_v2_64__retval = hipblasStatus_t(chipblas.hipblasCtrsvBatched_v2_64(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,uplo.value,transA.value,diag.value,n,
        <chipblas.float2 *const*>hip._util.types.Pointer.fromPyobj(AP)._ptr,lda,
        <chipblas.float2 *const*>hip._util.types.Pointer.fromPyobj(x)._ptr,incx,batchCount))
    return (_hipblasCtrsvBatched_v2_64__retval,)


@cython.embedsignature(True)
def hipblasZtrsvBatched_v2_64(object handle, object uplo, object transA, object diag, long n, object AP, long lda, object x, long incx, long batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        uplo (`~.hipblasFillMode_t`):
            (undocumented)

        transA (`~.hipblasOperation_t`):
            (undocumented)

        diag (`~.hipblasDiagType_t`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        AP (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        x (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")                    
    if not isinstance(transA,_hipblasOperation_t__Base):
        raise TypeError("argument 'transA' must be of type '_hipblasOperation_t__Base'")                    
    if not isinstance(diag,_hipblasDiagType_t__Base):
        raise TypeError("argument 'diag' must be of type '_hipblasDiagType_t__Base'")
    _hipblasZtrsvBatched_v2_64__retval = hipblasStatus_t(chipblas.hipblasZtrsvBatched_v2_64(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,uplo.value,transA.value,diag.value,n,
        <chipblas.double2 *const*>hip._util.types.Pointer.fromPyobj(AP)._ptr,lda,
        <chipblas.double2 *const*>hip._util.types.Pointer.fromPyobj(x)._ptr,incx,batchCount))
    return (_hipblasZtrsvBatched_v2_64__retval,)


@cython.embedsignature(True)
def hipblasStrsvStridedBatched(object handle, object uplo, object transA, object diag, int n, object AP, int lda, long strideA, object x, int incx, long stridex, int batchCount):
    r"""BLAS Level 2 API

    @{

    trsvStridedBatched solves

    A_i*x_i = b_i or A_i**T*x_i = b_i,

    where (A_i, x_i, b_i) is the i-th instance of the batch.
    x_i and b_i are vectors and A_i is an n by n triangular matrix, for i = 1, ..., batchCount.

    The vector x is overwritten on b.

    - Supported precisions in rocBLAS : s,d,c,z
    - Supported precisions in cuBLAS  : No support

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`) -- *IN*:
            [hipblasHandle_t]
            handle to the hipblas library context queue.

        uplo (`~.hipblasFillMode_t`) -- *IN*:
            [hipblasFillMode_t]
            HIPBLAS_FILL_MODE_UPPER:  A is an upper triangular matrix.
            HIPBLAS_FILL_MODE_LOWER:  A is a  lower triangular matrix.

        transA (`~.hipblasOperation_t`) -- *IN*:
            [hipblasOperation_t]

        diag (`~.hipblasDiagType_t`) -- *IN*:
            [hipblasDiagType_t]
            HIPBLAS_DIAG_UNIT:     A is assumed to be unit triangular.
            HIPBLAS_DIAG_NON_UNIT:  A is not assumed to be unit triangular.

        n (`~.int`) -- *IN*:
            [int]
            n specifies the number of rows of each b_i. n >= 0.

        AP (`~.hip._util.types.Pointer`/`~.object`) -- *IN*:
            device pointer to the first matrix (A_1) in the batch, of dimension ( lda, n )

        lda (`~.int`) -- *IN*:
            [int]
            specifies the leading dimension of each A_i.
            lda = max( 1, n ).

        strideA (`~.int`) -- *IN*:
            [hipblasStride]
            stride from the start of one A_i matrix to the next A_(i + 1)

        x (`~.hip._util.types.Pointer`/`~.object`) -- *IN,OUT*:
            device pointer to the first vector (x_1) in the batch.

        incx (`~.int`) -- *IN*:
            [int]
            specifies the increment for the elements of each x_i.

        stridex (`~.int`) -- *IN*:
            [hipblasStride]
            stride from the start of one x_i vector to the next x_(i + 1)

        batchCount (`~.int`) -- *IN*:
            [int]
            number of instances in the batch
    """
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")                    
    if not isinstance(transA,_hipblasOperation_t__Base):
        raise TypeError("argument 'transA' must be of type '_hipblasOperation_t__Base'")                    
    if not isinstance(diag,_hipblasDiagType_t__Base):
        raise TypeError("argument 'diag' must be of type '_hipblasDiagType_t__Base'")
    _hipblasStrsvStridedBatched__retval = hipblasStatus_t(chipblas.hipblasStrsvStridedBatched(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,uplo.value,transA.value,diag.value,n,
        <const float *>hip._util.types.Pointer.fromPyobj(AP)._ptr,lda,strideA,
        <float *>hip._util.types.Pointer.fromPyobj(x)._ptr,incx,stridex,batchCount))
    return (_hipblasStrsvStridedBatched__retval,)


@cython.embedsignature(True)
def hipblasDtrsvStridedBatched(object handle, object uplo, object transA, object diag, int n, object AP, int lda, long strideA, object x, int incx, long stridex, int batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        uplo (`~.hipblasFillMode_t`):
            (undocumented)

        transA (`~.hipblasOperation_t`):
            (undocumented)

        diag (`~.hipblasDiagType_t`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        AP (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        strideA (`~.int`):
            (undocumented)

        x (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        stridex (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")                    
    if not isinstance(transA,_hipblasOperation_t__Base):
        raise TypeError("argument 'transA' must be of type '_hipblasOperation_t__Base'")                    
    if not isinstance(diag,_hipblasDiagType_t__Base):
        raise TypeError("argument 'diag' must be of type '_hipblasDiagType_t__Base'")
    _hipblasDtrsvStridedBatched__retval = hipblasStatus_t(chipblas.hipblasDtrsvStridedBatched(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,uplo.value,transA.value,diag.value,n,
        <const double *>hip._util.types.Pointer.fromPyobj(AP)._ptr,lda,strideA,
        <double *>hip._util.types.Pointer.fromPyobj(x)._ptr,incx,stridex,batchCount))
    return (_hipblasDtrsvStridedBatched__retval,)


@cython.embedsignature(True)
def hipblasCtrsvStridedBatched(object handle, object uplo, object transA, object diag, int n, object AP, int lda, long strideA, object x, int incx, long stridex, int batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        uplo (`~.hipblasFillMode_t`):
            (undocumented)

        transA (`~.hipblasOperation_t`):
            (undocumented)

        diag (`~.hipblasDiagType_t`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        AP (`~.hipblasComplex`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        strideA (`~.int`):
            (undocumented)

        x (`~.hipblasComplex`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        stridex (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")                    
    if not isinstance(transA,_hipblasOperation_t__Base):
        raise TypeError("argument 'transA' must be of type '_hipblasOperation_t__Base'")                    
    if not isinstance(diag,_hipblasDiagType_t__Base):
        raise TypeError("argument 'diag' must be of type '_hipblasDiagType_t__Base'")
    _hipblasCtrsvStridedBatched__retval = hipblasStatus_t(chipblas.hipblasCtrsvStridedBatched(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,uplo.value,transA.value,diag.value,n,
        hipblasComplex.fromPyobj(AP).getElementPtr(),lda,strideA,
        hipblasComplex.fromPyobj(x).getElementPtr(),incx,stridex,batchCount))
    return (_hipblasCtrsvStridedBatched__retval,)


@cython.embedsignature(True)
def hipblasZtrsvStridedBatched(object handle, object uplo, object transA, object diag, int n, object AP, int lda, long strideA, object x, int incx, long stridex, int batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        uplo (`~.hipblasFillMode_t`):
            (undocumented)

        transA (`~.hipblasOperation_t`):
            (undocumented)

        diag (`~.hipblasDiagType_t`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        AP (`~.hipblasDoubleComplex`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        strideA (`~.int`):
            (undocumented)

        x (`~.hipblasDoubleComplex`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        stridex (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")                    
    if not isinstance(transA,_hipblasOperation_t__Base):
        raise TypeError("argument 'transA' must be of type '_hipblasOperation_t__Base'")                    
    if not isinstance(diag,_hipblasDiagType_t__Base):
        raise TypeError("argument 'diag' must be of type '_hipblasDiagType_t__Base'")
    _hipblasZtrsvStridedBatched__retval = hipblasStatus_t(chipblas.hipblasZtrsvStridedBatched(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,uplo.value,transA.value,diag.value,n,
        hipblasDoubleComplex.fromPyobj(AP).getElementPtr(),lda,strideA,
        hipblasDoubleComplex.fromPyobj(x).getElementPtr(),incx,stridex,batchCount))
    return (_hipblasZtrsvStridedBatched__retval,)


@cython.embedsignature(True)
def hipblasCtrsvStridedBatched_v2(object handle, object uplo, object transA, object diag, int n, object AP, int lda, long strideA, object x, int incx, long stridex, int batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        uplo (`~.hipblasFillMode_t`):
            (undocumented)

        transA (`~.hipblasOperation_t`):
            (undocumented)

        diag (`~.hipblasDiagType_t`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        AP (`~.float2`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        strideA (`~.int`):
            (undocumented)

        x (`~.float2`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        stridex (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")                    
    if not isinstance(transA,_hipblasOperation_t__Base):
        raise TypeError("argument 'transA' must be of type '_hipblasOperation_t__Base'")                    
    if not isinstance(diag,_hipblasDiagType_t__Base):
        raise TypeError("argument 'diag' must be of type '_hipblasDiagType_t__Base'")
    _hipblasCtrsvStridedBatched_v2__retval = hipblasStatus_t(chipblas.hipblasCtrsvStridedBatched_v2(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,uplo.value,transA.value,diag.value,n,
        float2.fromPyobj(AP).getElementPtr(),lda,strideA,
        float2.fromPyobj(x).getElementPtr(),incx,stridex,batchCount))
    return (_hipblasCtrsvStridedBatched_v2__retval,)


@cython.embedsignature(True)
def hipblasZtrsvStridedBatched_v2(object handle, object uplo, object transA, object diag, int n, object AP, int lda, long strideA, object x, int incx, long stridex, int batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        uplo (`~.hipblasFillMode_t`):
            (undocumented)

        transA (`~.hipblasOperation_t`):
            (undocumented)

        diag (`~.hipblasDiagType_t`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        AP (`~.double2`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        strideA (`~.int`):
            (undocumented)

        x (`~.double2`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        stridex (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")                    
    if not isinstance(transA,_hipblasOperation_t__Base):
        raise TypeError("argument 'transA' must be of type '_hipblasOperation_t__Base'")                    
    if not isinstance(diag,_hipblasDiagType_t__Base):
        raise TypeError("argument 'diag' must be of type '_hipblasDiagType_t__Base'")
    _hipblasZtrsvStridedBatched_v2__retval = hipblasStatus_t(chipblas.hipblasZtrsvStridedBatched_v2(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,uplo.value,transA.value,diag.value,n,
        double2.fromPyobj(AP).getElementPtr(),lda,strideA,
        double2.fromPyobj(x).getElementPtr(),incx,stridex,batchCount))
    return (_hipblasZtrsvStridedBatched_v2__retval,)


@cython.embedsignature(True)
def hipblasStrsvStridedBatched_64(object handle, object uplo, object transA, object diag, long n, object AP, long lda, long strideA, object x, long incx, long stridex, long batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        uplo (`~.hipblasFillMode_t`):
            (undocumented)

        transA (`~.hipblasOperation_t`):
            (undocumented)

        diag (`~.hipblasDiagType_t`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        AP (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        strideA (`~.int`):
            (undocumented)

        x (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        stridex (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")                    
    if not isinstance(transA,_hipblasOperation_t__Base):
        raise TypeError("argument 'transA' must be of type '_hipblasOperation_t__Base'")                    
    if not isinstance(diag,_hipblasDiagType_t__Base):
        raise TypeError("argument 'diag' must be of type '_hipblasDiagType_t__Base'")
    _hipblasStrsvStridedBatched_64__retval = hipblasStatus_t(chipblas.hipblasStrsvStridedBatched_64(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,uplo.value,transA.value,diag.value,n,
        <const float *>hip._util.types.Pointer.fromPyobj(AP)._ptr,lda,strideA,
        <float *>hip._util.types.Pointer.fromPyobj(x)._ptr,incx,stridex,batchCount))
    return (_hipblasStrsvStridedBatched_64__retval,)


@cython.embedsignature(True)
def hipblasDtrsvStridedBatched_64(object handle, object uplo, object transA, object diag, long n, object AP, long lda, long strideA, object x, long incx, long stridex, long batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        uplo (`~.hipblasFillMode_t`):
            (undocumented)

        transA (`~.hipblasOperation_t`):
            (undocumented)

        diag (`~.hipblasDiagType_t`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        AP (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        strideA (`~.int`):
            (undocumented)

        x (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        stridex (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")                    
    if not isinstance(transA,_hipblasOperation_t__Base):
        raise TypeError("argument 'transA' must be of type '_hipblasOperation_t__Base'")                    
    if not isinstance(diag,_hipblasDiagType_t__Base):
        raise TypeError("argument 'diag' must be of type '_hipblasDiagType_t__Base'")
    _hipblasDtrsvStridedBatched_64__retval = hipblasStatus_t(chipblas.hipblasDtrsvStridedBatched_64(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,uplo.value,transA.value,diag.value,n,
        <const double *>hip._util.types.Pointer.fromPyobj(AP)._ptr,lda,strideA,
        <double *>hip._util.types.Pointer.fromPyobj(x)._ptr,incx,stridex,batchCount))
    return (_hipblasDtrsvStridedBatched_64__retval,)


@cython.embedsignature(True)
def hipblasCtrsvStridedBatched_64(object handle, object uplo, object transA, object diag, long n, object AP, long lda, long strideA, object x, long incx, long stridex, long batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        uplo (`~.hipblasFillMode_t`):
            (undocumented)

        transA (`~.hipblasOperation_t`):
            (undocumented)

        diag (`~.hipblasDiagType_t`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        AP (`~.hipblasComplex`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        strideA (`~.int`):
            (undocumented)

        x (`~.hipblasComplex`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        stridex (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")                    
    if not isinstance(transA,_hipblasOperation_t__Base):
        raise TypeError("argument 'transA' must be of type '_hipblasOperation_t__Base'")                    
    if not isinstance(diag,_hipblasDiagType_t__Base):
        raise TypeError("argument 'diag' must be of type '_hipblasDiagType_t__Base'")
    _hipblasCtrsvStridedBatched_64__retval = hipblasStatus_t(chipblas.hipblasCtrsvStridedBatched_64(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,uplo.value,transA.value,diag.value,n,
        hipblasComplex.fromPyobj(AP).getElementPtr(),lda,strideA,
        hipblasComplex.fromPyobj(x).getElementPtr(),incx,stridex,batchCount))
    return (_hipblasCtrsvStridedBatched_64__retval,)


@cython.embedsignature(True)
def hipblasZtrsvStridedBatched_64(object handle, object uplo, object transA, object diag, long n, object AP, long lda, long strideA, object x, long incx, long stridex, long batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        uplo (`~.hipblasFillMode_t`):
            (undocumented)

        transA (`~.hipblasOperation_t`):
            (undocumented)

        diag (`~.hipblasDiagType_t`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        AP (`~.hipblasDoubleComplex`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        strideA (`~.int`):
            (undocumented)

        x (`~.hipblasDoubleComplex`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        stridex (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")                    
    if not isinstance(transA,_hipblasOperation_t__Base):
        raise TypeError("argument 'transA' must be of type '_hipblasOperation_t__Base'")                    
    if not isinstance(diag,_hipblasDiagType_t__Base):
        raise TypeError("argument 'diag' must be of type '_hipblasDiagType_t__Base'")
    _hipblasZtrsvStridedBatched_64__retval = hipblasStatus_t(chipblas.hipblasZtrsvStridedBatched_64(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,uplo.value,transA.value,diag.value,n,
        hipblasDoubleComplex.fromPyobj(AP).getElementPtr(),lda,strideA,
        hipblasDoubleComplex.fromPyobj(x).getElementPtr(),incx,stridex,batchCount))
    return (_hipblasZtrsvStridedBatched_64__retval,)


@cython.embedsignature(True)
def hipblasCtrsvStridedBatched_v2_64(object handle, object uplo, object transA, object diag, long n, object AP, long lda, long strideA, object x, long incx, long stridex, long batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        uplo (`~.hipblasFillMode_t`):
            (undocumented)

        transA (`~.hipblasOperation_t`):
            (undocumented)

        diag (`~.hipblasDiagType_t`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        AP (`~.float2`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        strideA (`~.int`):
            (undocumented)

        x (`~.float2`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        stridex (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")                    
    if not isinstance(transA,_hipblasOperation_t__Base):
        raise TypeError("argument 'transA' must be of type '_hipblasOperation_t__Base'")                    
    if not isinstance(diag,_hipblasDiagType_t__Base):
        raise TypeError("argument 'diag' must be of type '_hipblasDiagType_t__Base'")
    _hipblasCtrsvStridedBatched_v2_64__retval = hipblasStatus_t(chipblas.hipblasCtrsvStridedBatched_v2_64(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,uplo.value,transA.value,diag.value,n,
        float2.fromPyobj(AP).getElementPtr(),lda,strideA,
        float2.fromPyobj(x).getElementPtr(),incx,stridex,batchCount))
    return (_hipblasCtrsvStridedBatched_v2_64__retval,)


@cython.embedsignature(True)
def hipblasZtrsvStridedBatched_v2_64(object handle, object uplo, object transA, object diag, long n, object AP, long lda, long strideA, object x, long incx, long stridex, long batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        uplo (`~.hipblasFillMode_t`):
            (undocumented)

        transA (`~.hipblasOperation_t`):
            (undocumented)

        diag (`~.hipblasDiagType_t`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        AP (`~.double2`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        strideA (`~.int`):
            (undocumented)

        x (`~.double2`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        stridex (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")                    
    if not isinstance(transA,_hipblasOperation_t__Base):
        raise TypeError("argument 'transA' must be of type '_hipblasOperation_t__Base'")                    
    if not isinstance(diag,_hipblasDiagType_t__Base):
        raise TypeError("argument 'diag' must be of type '_hipblasDiagType_t__Base'")
    _hipblasZtrsvStridedBatched_v2_64__retval = hipblasStatus_t(chipblas.hipblasZtrsvStridedBatched_v2_64(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,uplo.value,transA.value,diag.value,n,
        double2.fromPyobj(AP).getElementPtr(),lda,strideA,
        double2.fromPyobj(x).getElementPtr(),incx,stridex,batchCount))
    return (_hipblasZtrsvStridedBatched_v2_64__retval,)


@cython.embedsignature(True)
def hipblasHgemm(object handle, object transA, object transB, int m, int n, int k, object alpha, object AP, int lda, object BP, int ldb, object beta, object CP, int ldc):
    r"""BLAS Level 3 API

    @{

    gemm performs one of the matrix-matrix operations

    C = alpha*op( A )*op( B ) + beta*C,

    where op( X ) is one of

        op( X ) = X      or
        op( X ) = X**T   or
        op( X ) = X**H,

    alpha and beta are scalars, and A, B and C are matrices, with
    op( A ) an m by k matrix, op( B ) a k by n matrix and C an m by n matrix.

    - Supported precisions in rocBLAS : h,s,d,c,z
    - Supported precisions in cuBLAS  : h,s,d,c,z

    .

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`) -- *IN*:
            [hipblasHandle_t]

        transA (`~.hipblasOperation_t`) -- *IN*:
            [hipblasOperation_t]
            specifies the form of op( A )

        transB (`~.hipblasOperation_t`) -- *IN*:
            [hipblasOperation_t]
            specifies the form of op( B )

        m (`~.int`) -- *IN*:
            [int]
            number or rows of matrices op( A ) and C

        n (`~.int`) -- *IN*:
            [int]
            number of columns of matrices op( B ) and C

        k (`~.int`) -- *IN*:
            [int]
            number of columns of matrix op( A ) and number of rows of matrix op( B )

        alpha (`~.hip._util.types.Pointer`/`~.object`) -- *IN*:
            device pointer or host pointer specifying the scalar alpha.

        AP (`~.hip._util.types.Pointer`/`~.object`) -- *IN*:
            device pointer storing matrix A.

        lda (`~.int`) -- *IN*:
            [int]
            specifies the leading dimension of A.

        BP (`~.hip._util.types.Pointer`/`~.object`) -- *IN*:
            device pointer storing matrix B.

        ldb (`~.int`) -- *IN*:
            [int]
            specifies the leading dimension of B.

        beta (`~.hip._util.types.Pointer`/`~.object`) -- *IN*:
            device pointer or host pointer specifying the scalar beta.

        CP (`~.hip._util.types.Pointer`/`~.object`) -- *IN,OUT*:
            device pointer storing matrix C on the GPU.

        ldc (`~.int`) -- *IN*:
            [int]
            specifies the leading dimension of C.
    """
    if not isinstance(transA,_hipblasOperation_t__Base):
        raise TypeError("argument 'transA' must be of type '_hipblasOperation_t__Base'")                    
    if not isinstance(transB,_hipblasOperation_t__Base):
        raise TypeError("argument 'transB' must be of type '_hipblasOperation_t__Base'")
    _hipblasHgemm__retval = hipblasStatus_t(chipblas.hipblasHgemm(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,transA.value,transB.value,m,n,k,
        <const unsigned short *>hip._util.types.Pointer.fromPyobj(alpha)._ptr,
        <const unsigned short *>hip._util.types.Pointer.fromPyobj(AP)._ptr,lda,
        <const unsigned short *>hip._util.types.Pointer.fromPyobj(BP)._ptr,ldb,
        <const unsigned short *>hip._util.types.Pointer.fromPyobj(beta)._ptr,
        <unsigned short *>hip._util.types.Pointer.fromPyobj(CP)._ptr,ldc))
    return (_hipblasHgemm__retval,)


@cython.embedsignature(True)
def hipblasSgemm(object handle, object transA, object transB, int m, int n, int k, object alpha, object AP, int lda, object BP, int ldb, object beta, object CP, int ldc):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        transA (`~.hipblasOperation_t`):
            (undocumented)

        transB (`~.hipblasOperation_t`):
            (undocumented)

        m (`~.int`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        k (`~.int`):
            (undocumented)

        alpha (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        AP (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        BP (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        ldb (`~.int`):
            (undocumented)

        beta (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        CP (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        ldc (`~.int`):
            (undocumented)
    """
    if not isinstance(transA,_hipblasOperation_t__Base):
        raise TypeError("argument 'transA' must be of type '_hipblasOperation_t__Base'")                    
    if not isinstance(transB,_hipblasOperation_t__Base):
        raise TypeError("argument 'transB' must be of type '_hipblasOperation_t__Base'")
    _hipblasSgemm__retval = hipblasStatus_t(chipblas.hipblasSgemm(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,transA.value,transB.value,m,n,k,
        <const float *>hip._util.types.Pointer.fromPyobj(alpha)._ptr,
        <const float *>hip._util.types.Pointer.fromPyobj(AP)._ptr,lda,
        <const float *>hip._util.types.Pointer.fromPyobj(BP)._ptr,ldb,
        <const float *>hip._util.types.Pointer.fromPyobj(beta)._ptr,
        <float *>hip._util.types.Pointer.fromPyobj(CP)._ptr,ldc))
    return (_hipblasSgemm__retval,)


@cython.embedsignature(True)
def hipblasDgemm(object handle, object transA, object transB, int m, int n, int k, object alpha, object AP, int lda, object BP, int ldb, object beta, object CP, int ldc):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        transA (`~.hipblasOperation_t`):
            (undocumented)

        transB (`~.hipblasOperation_t`):
            (undocumented)

        m (`~.int`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        k (`~.int`):
            (undocumented)

        alpha (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        AP (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        BP (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        ldb (`~.int`):
            (undocumented)

        beta (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        CP (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        ldc (`~.int`):
            (undocumented)
    """
    if not isinstance(transA,_hipblasOperation_t__Base):
        raise TypeError("argument 'transA' must be of type '_hipblasOperation_t__Base'")                    
    if not isinstance(transB,_hipblasOperation_t__Base):
        raise TypeError("argument 'transB' must be of type '_hipblasOperation_t__Base'")
    _hipblasDgemm__retval = hipblasStatus_t(chipblas.hipblasDgemm(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,transA.value,transB.value,m,n,k,
        <const double *>hip._util.types.Pointer.fromPyobj(alpha)._ptr,
        <const double *>hip._util.types.Pointer.fromPyobj(AP)._ptr,lda,
        <const double *>hip._util.types.Pointer.fromPyobj(BP)._ptr,ldb,
        <const double *>hip._util.types.Pointer.fromPyobj(beta)._ptr,
        <double *>hip._util.types.Pointer.fromPyobj(CP)._ptr,ldc))
    return (_hipblasDgemm__retval,)


@cython.embedsignature(True)
def hipblasCgemm(object handle, object transA, object transB, int m, int n, int k, object alpha, object AP, int lda, object BP, int ldb, object beta, object CP, int ldc):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        transA (`~.hipblasOperation_t`):
            (undocumented)

        transB (`~.hipblasOperation_t`):
            (undocumented)

        m (`~.int`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        k (`~.int`):
            (undocumented)

        alpha (`~.hipblasComplex`/`~.object`):
            (undocumented)

        AP (`~.hipblasComplex`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        BP (`~.hipblasComplex`/`~.object`):
            (undocumented)

        ldb (`~.int`):
            (undocumented)

        beta (`~.hipblasComplex`/`~.object`):
            (undocumented)

        CP (`~.hipblasComplex`/`~.object`):
            (undocumented)

        ldc (`~.int`):
            (undocumented)
    """
    if not isinstance(transA,_hipblasOperation_t__Base):
        raise TypeError("argument 'transA' must be of type '_hipblasOperation_t__Base'")                    
    if not isinstance(transB,_hipblasOperation_t__Base):
        raise TypeError("argument 'transB' must be of type '_hipblasOperation_t__Base'")
    _hipblasCgemm__retval = hipblasStatus_t(chipblas.hipblasCgemm(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,transA.value,transB.value,m,n,k,
        hipblasComplex.fromPyobj(alpha).getElementPtr(),
        hipblasComplex.fromPyobj(AP).getElementPtr(),lda,
        hipblasComplex.fromPyobj(BP).getElementPtr(),ldb,
        hipblasComplex.fromPyobj(beta).getElementPtr(),
        hipblasComplex.fromPyobj(CP).getElementPtr(),ldc))
    return (_hipblasCgemm__retval,)


@cython.embedsignature(True)
def hipblasZgemm(object handle, object transA, object transB, int m, int n, int k, object alpha, object AP, int lda, object BP, int ldb, object beta, object CP, int ldc):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        transA (`~.hipblasOperation_t`):
            (undocumented)

        transB (`~.hipblasOperation_t`):
            (undocumented)

        m (`~.int`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        k (`~.int`):
            (undocumented)

        alpha (`~.hipblasDoubleComplex`/`~.object`):
            (undocumented)

        AP (`~.hipblasDoubleComplex`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        BP (`~.hipblasDoubleComplex`/`~.object`):
            (undocumented)

        ldb (`~.int`):
            (undocumented)

        beta (`~.hipblasDoubleComplex`/`~.object`):
            (undocumented)

        CP (`~.hipblasDoubleComplex`/`~.object`):
            (undocumented)

        ldc (`~.int`):
            (undocumented)
    """
    if not isinstance(transA,_hipblasOperation_t__Base):
        raise TypeError("argument 'transA' must be of type '_hipblasOperation_t__Base'")                    
    if not isinstance(transB,_hipblasOperation_t__Base):
        raise TypeError("argument 'transB' must be of type '_hipblasOperation_t__Base'")
    _hipblasZgemm__retval = hipblasStatus_t(chipblas.hipblasZgemm(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,transA.value,transB.value,m,n,k,
        hipblasDoubleComplex.fromPyobj(alpha).getElementPtr(),
        hipblasDoubleComplex.fromPyobj(AP).getElementPtr(),lda,
        hipblasDoubleComplex.fromPyobj(BP).getElementPtr(),ldb,
        hipblasDoubleComplex.fromPyobj(beta).getElementPtr(),
        hipblasDoubleComplex.fromPyobj(CP).getElementPtr(),ldc))
    return (_hipblasZgemm__retval,)


@cython.embedsignature(True)
def hipblasCgemm_v2(object handle, object transA, object transB, int m, int n, int k, object alpha, object AP, int lda, object BP, int ldb, object beta, object CP, int ldc):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        transA (`~.hipblasOperation_t`):
            (undocumented)

        transB (`~.hipblasOperation_t`):
            (undocumented)

        m (`~.int`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        k (`~.int`):
            (undocumented)

        alpha (`~.float2`/`~.object`):
            (undocumented)

        AP (`~.float2`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        BP (`~.float2`/`~.object`):
            (undocumented)

        ldb (`~.int`):
            (undocumented)

        beta (`~.float2`/`~.object`):
            (undocumented)

        CP (`~.float2`/`~.object`):
            (undocumented)

        ldc (`~.int`):
            (undocumented)
    """
    if not isinstance(transA,_hipblasOperation_t__Base):
        raise TypeError("argument 'transA' must be of type '_hipblasOperation_t__Base'")                    
    if not isinstance(transB,_hipblasOperation_t__Base):
        raise TypeError("argument 'transB' must be of type '_hipblasOperation_t__Base'")
    _hipblasCgemm_v2__retval = hipblasStatus_t(chipblas.hipblasCgemm_v2(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,transA.value,transB.value,m,n,k,
        float2.fromPyobj(alpha).getElementPtr(),
        float2.fromPyobj(AP).getElementPtr(),lda,
        float2.fromPyobj(BP).getElementPtr(),ldb,
        float2.fromPyobj(beta).getElementPtr(),
        float2.fromPyobj(CP).getElementPtr(),ldc))
    return (_hipblasCgemm_v2__retval,)


@cython.embedsignature(True)
def hipblasZgemm_v2(object handle, object transA, object transB, int m, int n, int k, object alpha, object AP, int lda, object BP, int ldb, object beta, object CP, int ldc):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        transA (`~.hipblasOperation_t`):
            (undocumented)

        transB (`~.hipblasOperation_t`):
            (undocumented)

        m (`~.int`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        k (`~.int`):
            (undocumented)

        alpha (`~.double2`/`~.object`):
            (undocumented)

        AP (`~.double2`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        BP (`~.double2`/`~.object`):
            (undocumented)

        ldb (`~.int`):
            (undocumented)

        beta (`~.double2`/`~.object`):
            (undocumented)

        CP (`~.double2`/`~.object`):
            (undocumented)

        ldc (`~.int`):
            (undocumented)
    """
    if not isinstance(transA,_hipblasOperation_t__Base):
        raise TypeError("argument 'transA' must be of type '_hipblasOperation_t__Base'")                    
    if not isinstance(transB,_hipblasOperation_t__Base):
        raise TypeError("argument 'transB' must be of type '_hipblasOperation_t__Base'")
    _hipblasZgemm_v2__retval = hipblasStatus_t(chipblas.hipblasZgemm_v2(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,transA.value,transB.value,m,n,k,
        double2.fromPyobj(alpha).getElementPtr(),
        double2.fromPyobj(AP).getElementPtr(),lda,
        double2.fromPyobj(BP).getElementPtr(),ldb,
        double2.fromPyobj(beta).getElementPtr(),
        double2.fromPyobj(CP).getElementPtr(),ldc))
    return (_hipblasZgemm_v2__retval,)


@cython.embedsignature(True)
def hipblasHgemmBatched(object handle, object transA, object transB, int m, int n, int k, object alpha, object AP, int lda, object BP, int ldb, object beta, object CP, int ldc, int batchCount):
    r"""BLAS Level 3 API

    @{

    gemmBatched performs one of the batched matrix-matrix operations
         C_i = alpha*op( A_i )*op( B_i ) + beta*C_i, for i = 1, ..., batchCount.
     where op( X ) is one of
         op( X ) = X      or
        op( X ) = X**T   or
        op( X ) = X**H,
     alpha and beta are scalars, and A, B and C are strided batched matrices, with
    op( A ) an m by k by batchCount strided_batched matrix,
    op( B ) an k by n by batchCount strided_batched matrix and
    C an m by n by batchCount strided_batched matrix.

    - Supported precisions in rocBLAS : h,s,d,c,z
    - Supported precisions in cuBLAS  : h,s,d,c,z

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`) -- *IN*:
            [hipblasHandle_t]
            handle to the hipblas library context queue.

        transA (`~.hipblasOperation_t`) -- *IN*:
            [hipblasOperation_t]
            specifies the form of op( A )

        transB (`~.hipblasOperation_t`) -- *IN*:
            [hipblasOperation_t]
            specifies the form of op( B )

        m (`~.int`) -- *IN*:
            [int]
            matrix dimension m.

        n (`~.int`) -- *IN*:
            [int]
            matrix dimension n.

        k (`~.int`) -- *IN*:
            [int]
            matrix dimension k.

        alpha (`~.hip._util.types.Pointer`/`~.object`) -- *IN*:
            device pointer or host pointer specifying the scalar alpha.

        AP (`~.hip._util.types.Pointer`/`~.object`) -- *IN*:
            device array of device pointers storing each matrix A_i.

        lda (`~.int`) -- *IN*:
            [int]
            specifies the leading dimension of each A_i.

        BP (`~.hip._util.types.Pointer`/`~.object`) -- *IN*:
            device array of device pointers storing each matrix B_i.

        ldb (`~.int`) -- *IN*:
            [int]
            specifies the leading dimension of each B_i.

        beta (`~.hip._util.types.Pointer`/`~.object`) -- *IN*:
            device pointer or host pointer specifying the scalar beta.

        CP (`~.hip._util.types.Pointer`/`~.object`) -- *IN,OUT*:
            device array of device pointers storing each matrix C_i.

        ldc (`~.int`) -- *IN*:
            [int]
            specifies the leading dimension of each C_i.

        batchCount (`~.int`) -- *IN*:
            [int]
            number of gemm operations in the batch
    """
    if not isinstance(transA,_hipblasOperation_t__Base):
        raise TypeError("argument 'transA' must be of type '_hipblasOperation_t__Base'")                    
    if not isinstance(transB,_hipblasOperation_t__Base):
        raise TypeError("argument 'transB' must be of type '_hipblasOperation_t__Base'")
    _hipblasHgemmBatched__retval = hipblasStatus_t(chipblas.hipblasHgemmBatched(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,transA.value,transB.value,m,n,k,
        <const unsigned short *>hip._util.types.Pointer.fromPyobj(alpha)._ptr,
        <const unsigned short *const*>hip._util.types.Pointer.fromPyobj(AP)._ptr,lda,
        <const unsigned short *const*>hip._util.types.Pointer.fromPyobj(BP)._ptr,ldb,
        <const unsigned short *>hip._util.types.Pointer.fromPyobj(beta)._ptr,
        <unsigned short *const*>hip._util.types.Pointer.fromPyobj(CP)._ptr,ldc,batchCount))
    return (_hipblasHgemmBatched__retval,)


@cython.embedsignature(True)
def hipblasSgemmBatched(object handle, object transA, object transB, int m, int n, int k, object alpha, object AP, int lda, object BP, int ldb, object beta, object CP, int ldc, int batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        transA (`~.hipblasOperation_t`):
            (undocumented)

        transB (`~.hipblasOperation_t`):
            (undocumented)

        m (`~.int`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        k (`~.int`):
            (undocumented)

        alpha (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        AP (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        BP (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        ldb (`~.int`):
            (undocumented)

        beta (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        CP (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        ldc (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    if not isinstance(transA,_hipblasOperation_t__Base):
        raise TypeError("argument 'transA' must be of type '_hipblasOperation_t__Base'")                    
    if not isinstance(transB,_hipblasOperation_t__Base):
        raise TypeError("argument 'transB' must be of type '_hipblasOperation_t__Base'")
    _hipblasSgemmBatched__retval = hipblasStatus_t(chipblas.hipblasSgemmBatched(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,transA.value,transB.value,m,n,k,
        <const float *>hip._util.types.Pointer.fromPyobj(alpha)._ptr,
        <const float *const*>hip._util.types.Pointer.fromPyobj(AP)._ptr,lda,
        <const float *const*>hip._util.types.Pointer.fromPyobj(BP)._ptr,ldb,
        <const float *>hip._util.types.Pointer.fromPyobj(beta)._ptr,
        <float *const*>hip._util.types.Pointer.fromPyobj(CP)._ptr,ldc,batchCount))
    return (_hipblasSgemmBatched__retval,)


@cython.embedsignature(True)
def hipblasDgemmBatched(object handle, object transA, object transB, int m, int n, int k, object alpha, object AP, int lda, object BP, int ldb, object beta, object CP, int ldc, int batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        transA (`~.hipblasOperation_t`):
            (undocumented)

        transB (`~.hipblasOperation_t`):
            (undocumented)

        m (`~.int`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        k (`~.int`):
            (undocumented)

        alpha (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        AP (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        BP (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        ldb (`~.int`):
            (undocumented)

        beta (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        CP (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        ldc (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    if not isinstance(transA,_hipblasOperation_t__Base):
        raise TypeError("argument 'transA' must be of type '_hipblasOperation_t__Base'")                    
    if not isinstance(transB,_hipblasOperation_t__Base):
        raise TypeError("argument 'transB' must be of type '_hipblasOperation_t__Base'")
    _hipblasDgemmBatched__retval = hipblasStatus_t(chipblas.hipblasDgemmBatched(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,transA.value,transB.value,m,n,k,
        <const double *>hip._util.types.Pointer.fromPyobj(alpha)._ptr,
        <const double *const*>hip._util.types.Pointer.fromPyobj(AP)._ptr,lda,
        <const double *const*>hip._util.types.Pointer.fromPyobj(BP)._ptr,ldb,
        <const double *>hip._util.types.Pointer.fromPyobj(beta)._ptr,
        <double *const*>hip._util.types.Pointer.fromPyobj(CP)._ptr,ldc,batchCount))
    return (_hipblasDgemmBatched__retval,)


@cython.embedsignature(True)
def hipblasCgemmBatched(object handle, object transA, object transB, int m, int n, int k, object alpha, object AP, int lda, object BP, int ldb, object beta, object CP, int ldc, int batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        transA (`~.hipblasOperation_t`):
            (undocumented)

        transB (`~.hipblasOperation_t`):
            (undocumented)

        m (`~.int`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        k (`~.int`):
            (undocumented)

        alpha (`~.hipblasComplex`/`~.object`):
            (undocumented)

        AP (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        BP (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        ldb (`~.int`):
            (undocumented)

        beta (`~.hipblasComplex`/`~.object`):
            (undocumented)

        CP (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        ldc (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    if not isinstance(transA,_hipblasOperation_t__Base):
        raise TypeError("argument 'transA' must be of type '_hipblasOperation_t__Base'")                    
    if not isinstance(transB,_hipblasOperation_t__Base):
        raise TypeError("argument 'transB' must be of type '_hipblasOperation_t__Base'")
    _hipblasCgemmBatched__retval = hipblasStatus_t(chipblas.hipblasCgemmBatched(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,transA.value,transB.value,m,n,k,
        hipblasComplex.fromPyobj(alpha).getElementPtr(),
        <chipblas.hipblasComplex *const*>hip._util.types.Pointer.fromPyobj(AP)._ptr,lda,
        <chipblas.hipblasComplex *const*>hip._util.types.Pointer.fromPyobj(BP)._ptr,ldb,
        hipblasComplex.fromPyobj(beta).getElementPtr(),
        <chipblas.hipblasComplex *const*>hip._util.types.Pointer.fromPyobj(CP)._ptr,ldc,batchCount))
    return (_hipblasCgemmBatched__retval,)


@cython.embedsignature(True)
def hipblasZgemmBatched(object handle, object transA, object transB, int m, int n, int k, object alpha, object AP, int lda, object BP, int ldb, object beta, object CP, int ldc, int batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        transA (`~.hipblasOperation_t`):
            (undocumented)

        transB (`~.hipblasOperation_t`):
            (undocumented)

        m (`~.int`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        k (`~.int`):
            (undocumented)

        alpha (`~.hipblasDoubleComplex`/`~.object`):
            (undocumented)

        AP (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        BP (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        ldb (`~.int`):
            (undocumented)

        beta (`~.hipblasDoubleComplex`/`~.object`):
            (undocumented)

        CP (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        ldc (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    if not isinstance(transA,_hipblasOperation_t__Base):
        raise TypeError("argument 'transA' must be of type '_hipblasOperation_t__Base'")                    
    if not isinstance(transB,_hipblasOperation_t__Base):
        raise TypeError("argument 'transB' must be of type '_hipblasOperation_t__Base'")
    _hipblasZgemmBatched__retval = hipblasStatus_t(chipblas.hipblasZgemmBatched(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,transA.value,transB.value,m,n,k,
        hipblasDoubleComplex.fromPyobj(alpha).getElementPtr(),
        <chipblas.hipblasDoubleComplex *const*>hip._util.types.Pointer.fromPyobj(AP)._ptr,lda,
        <chipblas.hipblasDoubleComplex *const*>hip._util.types.Pointer.fromPyobj(BP)._ptr,ldb,
        hipblasDoubleComplex.fromPyobj(beta).getElementPtr(),
        <chipblas.hipblasDoubleComplex *const*>hip._util.types.Pointer.fromPyobj(CP)._ptr,ldc,batchCount))
    return (_hipblasZgemmBatched__retval,)


@cython.embedsignature(True)
def hipblasCgemmBatched_v2(object handle, object transA, object transB, int m, int n, int k, object alpha, object AP, int lda, object BP, int ldb, object beta, object CP, int ldc, int batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        transA (`~.hipblasOperation_t`):
            (undocumented)

        transB (`~.hipblasOperation_t`):
            (undocumented)

        m (`~.int`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        k (`~.int`):
            (undocumented)

        alpha (`~.float2`/`~.object`):
            (undocumented)

        AP (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        BP (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        ldb (`~.int`):
            (undocumented)

        beta (`~.float2`/`~.object`):
            (undocumented)

        CP (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        ldc (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    if not isinstance(transA,_hipblasOperation_t__Base):
        raise TypeError("argument 'transA' must be of type '_hipblasOperation_t__Base'")                    
    if not isinstance(transB,_hipblasOperation_t__Base):
        raise TypeError("argument 'transB' must be of type '_hipblasOperation_t__Base'")
    _hipblasCgemmBatched_v2__retval = hipblasStatus_t(chipblas.hipblasCgemmBatched_v2(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,transA.value,transB.value,m,n,k,
        float2.fromPyobj(alpha).getElementPtr(),
        <chipblas.float2 *const*>hip._util.types.Pointer.fromPyobj(AP)._ptr,lda,
        <chipblas.float2 *const*>hip._util.types.Pointer.fromPyobj(BP)._ptr,ldb,
        float2.fromPyobj(beta).getElementPtr(),
        <chipblas.float2 *const*>hip._util.types.Pointer.fromPyobj(CP)._ptr,ldc,batchCount))
    return (_hipblasCgemmBatched_v2__retval,)


@cython.embedsignature(True)
def hipblasZgemmBatched_v2(object handle, object transA, object transB, int m, int n, int k, object alpha, object AP, int lda, object BP, int ldb, object beta, object CP, int ldc, int batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        transA (`~.hipblasOperation_t`):
            (undocumented)

        transB (`~.hipblasOperation_t`):
            (undocumented)

        m (`~.int`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        k (`~.int`):
            (undocumented)

        alpha (`~.double2`/`~.object`):
            (undocumented)

        AP (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        BP (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        ldb (`~.int`):
            (undocumented)

        beta (`~.double2`/`~.object`):
            (undocumented)

        CP (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        ldc (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    if not isinstance(transA,_hipblasOperation_t__Base):
        raise TypeError("argument 'transA' must be of type '_hipblasOperation_t__Base'")                    
    if not isinstance(transB,_hipblasOperation_t__Base):
        raise TypeError("argument 'transB' must be of type '_hipblasOperation_t__Base'")
    _hipblasZgemmBatched_v2__retval = hipblasStatus_t(chipblas.hipblasZgemmBatched_v2(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,transA.value,transB.value,m,n,k,
        double2.fromPyobj(alpha).getElementPtr(),
        <chipblas.double2 *const*>hip._util.types.Pointer.fromPyobj(AP)._ptr,lda,
        <chipblas.double2 *const*>hip._util.types.Pointer.fromPyobj(BP)._ptr,ldb,
        double2.fromPyobj(beta).getElementPtr(),
        <chipblas.double2 *const*>hip._util.types.Pointer.fromPyobj(CP)._ptr,ldc,batchCount))
    return (_hipblasZgemmBatched_v2__retval,)


@cython.embedsignature(True)
def hipblasHgemmStridedBatched(object handle, object transA, object transB, int m, int n, int k, object alpha, object AP, int lda, long long strideA, object BP, int ldb, long long strideB, object beta, object CP, int ldc, long long strideC, int batchCount):
    r"""BLAS Level 3 API

    @{

    gemmStridedBatched performs one of the strided batched matrix-matrix operations

    C_i = alpha*op( A_i )*op( B_i ) + beta*C_i, for i = 1, ..., batchCount.

    where op( X ) is one of

        op( X ) = X      or
        op( X ) = X**T   or
        op( X ) = X**H,

    alpha and beta are scalars, and A, B and C are strided batched matrices, with
    op( A ) an m by k by batchCount strided_batched matrix,
    op( B ) an k by n by batchCount strided_batched matrix and
    C an m by n by batchCount strided_batched matrix.

    - Supported precisions in rocBLAS : h,s,d,c,z
    - Supported precisions in cuBLAS  : h,s,d,c,z

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`) -- *IN*:
            [hipblasHandle_t]
            handle to the hipblas library context queue.

        transA (`~.hipblasOperation_t`) -- *IN*:
            [hipblasOperation_t]
            specifies the form of op( A )

        transB (`~.hipblasOperation_t`) -- *IN*:
            [hipblasOperation_t]
            specifies the form of op( B )

        m (`~.int`) -- *IN*:
            [int]
            matrix dimension m.

        n (`~.int`) -- *IN*:
            [int]
            matrix dimension n.

        k (`~.int`) -- *IN*:
            [int]
            matrix dimension k.

        alpha (`~.hip._util.types.Pointer`/`~.object`) -- *IN*:
            device pointer or host pointer specifying the scalar alpha.

        AP (`~.hip._util.types.Pointer`/`~.object`) -- *IN*:
            device pointer pointing to the first matrix A_1.

        lda (`~.int`) -- *IN*:
            [int]
            specifies the leading dimension of each A_i.

        strideA (`~.int`) -- *IN*:
            [hipblasStride]
            stride from the start of one A_i matrix to the next A_(i + 1).

        BP (`~.hip._util.types.Pointer`/`~.object`) -- *IN*:
            device pointer pointing to the first matrix B_1.

        ldb (`~.int`) -- *IN*:
            [int]
            specifies the leading dimension of each B_i.

        strideB (`~.int`) -- *IN*:
            [hipblasStride]
            stride from the start of one B_i matrix to the next B_(i + 1).

        beta (`~.hip._util.types.Pointer`/`~.object`) -- *IN*:
            device pointer or host pointer specifying the scalar beta.

        CP (`~.hip._util.types.Pointer`/`~.object`) -- *IN,OUT*:
            device pointer pointing to the first matrix C_1.

        ldc (`~.int`) -- *IN*:
            [int]
            specifies the leading dimension of each C_i.

        strideC (`~.int`) -- *IN*:
            [hipblasStride]
            stride from the start of one C_i matrix to the next C_(i + 1).

        batchCount (`~.int`) -- *IN*:
            [int]
            number of gemm operatons in the batch
    """
    if not isinstance(transA,_hipblasOperation_t__Base):
        raise TypeError("argument 'transA' must be of type '_hipblasOperation_t__Base'")                    
    if not isinstance(transB,_hipblasOperation_t__Base):
        raise TypeError("argument 'transB' must be of type '_hipblasOperation_t__Base'")
    _hipblasHgemmStridedBatched__retval = hipblasStatus_t(chipblas.hipblasHgemmStridedBatched(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,transA.value,transB.value,m,n,k,
        <const unsigned short *>hip._util.types.Pointer.fromPyobj(alpha)._ptr,
        <const unsigned short *>hip._util.types.Pointer.fromPyobj(AP)._ptr,lda,strideA,
        <const unsigned short *>hip._util.types.Pointer.fromPyobj(BP)._ptr,ldb,strideB,
        <const unsigned short *>hip._util.types.Pointer.fromPyobj(beta)._ptr,
        <unsigned short *>hip._util.types.Pointer.fromPyobj(CP)._ptr,ldc,strideC,batchCount))
    return (_hipblasHgemmStridedBatched__retval,)


@cython.embedsignature(True)
def hipblasSgemmStridedBatched(object handle, object transA, object transB, int m, int n, int k, object alpha, object AP, int lda, long long strideA, object BP, int ldb, long long strideB, object beta, object CP, int ldc, long long strideC, int batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        transA (`~.hipblasOperation_t`):
            (undocumented)

        transB (`~.hipblasOperation_t`):
            (undocumented)

        m (`~.int`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        k (`~.int`):
            (undocumented)

        alpha (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        AP (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        strideA (`~.int`):
            (undocumented)

        BP (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        ldb (`~.int`):
            (undocumented)

        strideB (`~.int`):
            (undocumented)

        beta (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        CP (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        ldc (`~.int`):
            (undocumented)

        strideC (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    if not isinstance(transA,_hipblasOperation_t__Base):
        raise TypeError("argument 'transA' must be of type '_hipblasOperation_t__Base'")                    
    if not isinstance(transB,_hipblasOperation_t__Base):
        raise TypeError("argument 'transB' must be of type '_hipblasOperation_t__Base'")
    _hipblasSgemmStridedBatched__retval = hipblasStatus_t(chipblas.hipblasSgemmStridedBatched(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,transA.value,transB.value,m,n,k,
        <const float *>hip._util.types.Pointer.fromPyobj(alpha)._ptr,
        <const float *>hip._util.types.Pointer.fromPyobj(AP)._ptr,lda,strideA,
        <const float *>hip._util.types.Pointer.fromPyobj(BP)._ptr,ldb,strideB,
        <const float *>hip._util.types.Pointer.fromPyobj(beta)._ptr,
        <float *>hip._util.types.Pointer.fromPyobj(CP)._ptr,ldc,strideC,batchCount))
    return (_hipblasSgemmStridedBatched__retval,)


@cython.embedsignature(True)
def hipblasDgemmStridedBatched(object handle, object transA, object transB, int m, int n, int k, object alpha, object AP, int lda, long long strideA, object BP, int ldb, long long strideB, object beta, object CP, int ldc, long long strideC, int batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        transA (`~.hipblasOperation_t`):
            (undocumented)

        transB (`~.hipblasOperation_t`):
            (undocumented)

        m (`~.int`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        k (`~.int`):
            (undocumented)

        alpha (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        AP (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        strideA (`~.int`):
            (undocumented)

        BP (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        ldb (`~.int`):
            (undocumented)

        strideB (`~.int`):
            (undocumented)

        beta (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        CP (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        ldc (`~.int`):
            (undocumented)

        strideC (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    if not isinstance(transA,_hipblasOperation_t__Base):
        raise TypeError("argument 'transA' must be of type '_hipblasOperation_t__Base'")                    
    if not isinstance(transB,_hipblasOperation_t__Base):
        raise TypeError("argument 'transB' must be of type '_hipblasOperation_t__Base'")
    _hipblasDgemmStridedBatched__retval = hipblasStatus_t(chipblas.hipblasDgemmStridedBatched(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,transA.value,transB.value,m,n,k,
        <const double *>hip._util.types.Pointer.fromPyobj(alpha)._ptr,
        <const double *>hip._util.types.Pointer.fromPyobj(AP)._ptr,lda,strideA,
        <const double *>hip._util.types.Pointer.fromPyobj(BP)._ptr,ldb,strideB,
        <const double *>hip._util.types.Pointer.fromPyobj(beta)._ptr,
        <double *>hip._util.types.Pointer.fromPyobj(CP)._ptr,ldc,strideC,batchCount))
    return (_hipblasDgemmStridedBatched__retval,)


@cython.embedsignature(True)
def hipblasCgemmStridedBatched(object handle, object transA, object transB, int m, int n, int k, object alpha, object AP, int lda, long long strideA, object BP, int ldb, long long strideB, object beta, object CP, int ldc, long long strideC, int batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        transA (`~.hipblasOperation_t`):
            (undocumented)

        transB (`~.hipblasOperation_t`):
            (undocumented)

        m (`~.int`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        k (`~.int`):
            (undocumented)

        alpha (`~.hipblasComplex`/`~.object`):
            (undocumented)

        AP (`~.hipblasComplex`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        strideA (`~.int`):
            (undocumented)

        BP (`~.hipblasComplex`/`~.object`):
            (undocumented)

        ldb (`~.int`):
            (undocumented)

        strideB (`~.int`):
            (undocumented)

        beta (`~.hipblasComplex`/`~.object`):
            (undocumented)

        CP (`~.hipblasComplex`/`~.object`):
            (undocumented)

        ldc (`~.int`):
            (undocumented)

        strideC (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    if not isinstance(transA,_hipblasOperation_t__Base):
        raise TypeError("argument 'transA' must be of type '_hipblasOperation_t__Base'")                    
    if not isinstance(transB,_hipblasOperation_t__Base):
        raise TypeError("argument 'transB' must be of type '_hipblasOperation_t__Base'")
    _hipblasCgemmStridedBatched__retval = hipblasStatus_t(chipblas.hipblasCgemmStridedBatched(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,transA.value,transB.value,m,n,k,
        hipblasComplex.fromPyobj(alpha).getElementPtr(),
        hipblasComplex.fromPyobj(AP).getElementPtr(),lda,strideA,
        hipblasComplex.fromPyobj(BP).getElementPtr(),ldb,strideB,
        hipblasComplex.fromPyobj(beta).getElementPtr(),
        hipblasComplex.fromPyobj(CP).getElementPtr(),ldc,strideC,batchCount))
    return (_hipblasCgemmStridedBatched__retval,)


@cython.embedsignature(True)
def hipblasZgemmStridedBatched(object handle, object transA, object transB, int m, int n, int k, object alpha, object AP, int lda, long long strideA, object BP, int ldb, long long strideB, object beta, object CP, int ldc, long long strideC, int batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        transA (`~.hipblasOperation_t`):
            (undocumented)

        transB (`~.hipblasOperation_t`):
            (undocumented)

        m (`~.int`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        k (`~.int`):
            (undocumented)

        alpha (`~.hipblasDoubleComplex`/`~.object`):
            (undocumented)

        AP (`~.hipblasDoubleComplex`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        strideA (`~.int`):
            (undocumented)

        BP (`~.hipblasDoubleComplex`/`~.object`):
            (undocumented)

        ldb (`~.int`):
            (undocumented)

        strideB (`~.int`):
            (undocumented)

        beta (`~.hipblasDoubleComplex`/`~.object`):
            (undocumented)

        CP (`~.hipblasDoubleComplex`/`~.object`):
            (undocumented)

        ldc (`~.int`):
            (undocumented)

        strideC (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    if not isinstance(transA,_hipblasOperation_t__Base):
        raise TypeError("argument 'transA' must be of type '_hipblasOperation_t__Base'")                    
    if not isinstance(transB,_hipblasOperation_t__Base):
        raise TypeError("argument 'transB' must be of type '_hipblasOperation_t__Base'")
    _hipblasZgemmStridedBatched__retval = hipblasStatus_t(chipblas.hipblasZgemmStridedBatched(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,transA.value,transB.value,m,n,k,
        hipblasDoubleComplex.fromPyobj(alpha).getElementPtr(),
        hipblasDoubleComplex.fromPyobj(AP).getElementPtr(),lda,strideA,
        hipblasDoubleComplex.fromPyobj(BP).getElementPtr(),ldb,strideB,
        hipblasDoubleComplex.fromPyobj(beta).getElementPtr(),
        hipblasDoubleComplex.fromPyobj(CP).getElementPtr(),ldc,strideC,batchCount))
    return (_hipblasZgemmStridedBatched__retval,)


@cython.embedsignature(True)
def hipblasCgemmStridedBatched_v2(object handle, object transA, object transB, int m, int n, int k, object alpha, object AP, int lda, long long strideA, object BP, int ldb, long long strideB, object beta, object CP, int ldc, long long strideC, int batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        transA (`~.hipblasOperation_t`):
            (undocumented)

        transB (`~.hipblasOperation_t`):
            (undocumented)

        m (`~.int`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        k (`~.int`):
            (undocumented)

        alpha (`~.float2`/`~.object`):
            (undocumented)

        AP (`~.float2`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        strideA (`~.int`):
            (undocumented)

        BP (`~.float2`/`~.object`):
            (undocumented)

        ldb (`~.int`):
            (undocumented)

        strideB (`~.int`):
            (undocumented)

        beta (`~.float2`/`~.object`):
            (undocumented)

        CP (`~.float2`/`~.object`):
            (undocumented)

        ldc (`~.int`):
            (undocumented)

        strideC (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    if not isinstance(transA,_hipblasOperation_t__Base):
        raise TypeError("argument 'transA' must be of type '_hipblasOperation_t__Base'")                    
    if not isinstance(transB,_hipblasOperation_t__Base):
        raise TypeError("argument 'transB' must be of type '_hipblasOperation_t__Base'")
    _hipblasCgemmStridedBatched_v2__retval = hipblasStatus_t(chipblas.hipblasCgemmStridedBatched_v2(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,transA.value,transB.value,m,n,k,
        float2.fromPyobj(alpha).getElementPtr(),
        float2.fromPyobj(AP).getElementPtr(),lda,strideA,
        float2.fromPyobj(BP).getElementPtr(),ldb,strideB,
        float2.fromPyobj(beta).getElementPtr(),
        float2.fromPyobj(CP).getElementPtr(),ldc,strideC,batchCount))
    return (_hipblasCgemmStridedBatched_v2__retval,)


@cython.embedsignature(True)
def hipblasZgemmStridedBatched_v2(object handle, object transA, object transB, int m, int n, int k, object alpha, object AP, int lda, long long strideA, object BP, int ldb, long long strideB, object beta, object CP, int ldc, long long strideC, int batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        transA (`~.hipblasOperation_t`):
            (undocumented)

        transB (`~.hipblasOperation_t`):
            (undocumented)

        m (`~.int`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        k (`~.int`):
            (undocumented)

        alpha (`~.double2`/`~.object`):
            (undocumented)

        AP (`~.double2`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        strideA (`~.int`):
            (undocumented)

        BP (`~.double2`/`~.object`):
            (undocumented)

        ldb (`~.int`):
            (undocumented)

        strideB (`~.int`):
            (undocumented)

        beta (`~.double2`/`~.object`):
            (undocumented)

        CP (`~.double2`/`~.object`):
            (undocumented)

        ldc (`~.int`):
            (undocumented)

        strideC (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    if not isinstance(transA,_hipblasOperation_t__Base):
        raise TypeError("argument 'transA' must be of type '_hipblasOperation_t__Base'")                    
    if not isinstance(transB,_hipblasOperation_t__Base):
        raise TypeError("argument 'transB' must be of type '_hipblasOperation_t__Base'")
    _hipblasZgemmStridedBatched_v2__retval = hipblasStatus_t(chipblas.hipblasZgemmStridedBatched_v2(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,transA.value,transB.value,m,n,k,
        double2.fromPyobj(alpha).getElementPtr(),
        double2.fromPyobj(AP).getElementPtr(),lda,strideA,
        double2.fromPyobj(BP).getElementPtr(),ldb,strideB,
        double2.fromPyobj(beta).getElementPtr(),
        double2.fromPyobj(CP).getElementPtr(),ldc,strideC,batchCount))
    return (_hipblasZgemmStridedBatched_v2__retval,)


@cython.embedsignature(True)
def hipblasCherk(object handle, object uplo, object transA, int n, int k, object alpha, object AP, int lda, object beta, object CP, int ldc):
    r"""BLAS Level 3 API

    @{

    herk performs one of the matrix-matrix operations for a Hermitian rank-k update

    C := alpha*op( A )*op( A )^H + beta*C

    where  alpha and beta are scalars, op(A) is an n by k matrix, and
    C is a n x n Hermitian matrix stored as either upper or lower.

        op( A ) = A,  and A is n by k if transA == HIPBLAS_OP_N
        op( A ) = A^H and A is k by n if transA == HIPBLAS_OP_C

    - Supported precisions in rocBLAS : c,z
    - Supported precisions in cuBLAS  : c,z

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`) -- *IN*:
            [hipblasHandle_t]
            handle to the hipblas library context queue.

        uplo (`~.hipblasFillMode_t`) -- *IN*:
            [hipblasFillMode_t]
            HIPBLAS_FILL_MODE_UPPER:  C is an upper triangular matrix
            HIPBLAS_FILL_MODE_LOWER:  C is a  lower triangular matrix

        transA (`~.hipblasOperation_t`) -- *IN*:
            [hipblasOperation_t]
            HIPBLAS_OP_C:  op(A) = A^H
            HIPBLAS_ON_N:  op(A) = A

        n (`~.int`) -- *IN*:
            [int]
            n specifies the number of rows and columns of C. n >= 0.

        k (`~.int`) -- *IN*:
            [int]
            k specifies the number of columns of op(A). k >= 0.

        alpha (`~.hip._util.types.Pointer`/`~.object`) -- *IN*:
            alpha specifies the scalar alpha. When alpha is
            zero then A is not referenced and A need not be set before
            entry.

        AP (`~.hipblasComplex`/`~.object`) -- *IN*:
            pointer storing matrix A on the GPU.
            Martrix dimension is ( lda, k ) when if transA = HIPBLAS_OP_N, otherwise (lda, n)
            only the upper/lower triangular part is accessed.

        lda (`~.int`) -- *IN*:
            [int]
            lda specifies the first dimension of A.
            if transA = HIPBLAS_OP_N,  lda >= max( 1, n ),
            otherwise lda >= max( 1, k ).

        beta (`~.hip._util.types.Pointer`/`~.object`) -- *IN*:
            beta specifies the scalar beta. When beta is
            zero then C need not be set before entry.

        CP (`~.hipblasComplex`/`~.object`) -- *IN*:
            pointer storing matrix C on the GPU.
            The imaginary component of the diagonal elements are not used but are set to zero unless quick return.

        ldc (`~.int`) -- *IN*:
            [int]
            ldc specifies the first dimension of C. ldc >= max( 1, n ).
    """
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")                    
    if not isinstance(transA,_hipblasOperation_t__Base):
        raise TypeError("argument 'transA' must be of type '_hipblasOperation_t__Base'")
    _hipblasCherk__retval = hipblasStatus_t(chipblas.hipblasCherk(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,uplo.value,transA.value,n,k,
        <const float *>hip._util.types.Pointer.fromPyobj(alpha)._ptr,
        hipblasComplex.fromPyobj(AP).getElementPtr(),lda,
        <const float *>hip._util.types.Pointer.fromPyobj(beta)._ptr,
        hipblasComplex.fromPyobj(CP).getElementPtr(),ldc))
    return (_hipblasCherk__retval,)


@cython.embedsignature(True)
def hipblasZherk(object handle, object uplo, object transA, int n, int k, object alpha, object AP, int lda, object beta, object CP, int ldc):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        uplo (`~.hipblasFillMode_t`):
            (undocumented)

        transA (`~.hipblasOperation_t`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        k (`~.int`):
            (undocumented)

        alpha (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        AP (`~.hipblasDoubleComplex`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        beta (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        CP (`~.hipblasDoubleComplex`/`~.object`):
            (undocumented)

        ldc (`~.int`):
            (undocumented)
    """
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")                    
    if not isinstance(transA,_hipblasOperation_t__Base):
        raise TypeError("argument 'transA' must be of type '_hipblasOperation_t__Base'")
    _hipblasZherk__retval = hipblasStatus_t(chipblas.hipblasZherk(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,uplo.value,transA.value,n,k,
        <const double *>hip._util.types.Pointer.fromPyobj(alpha)._ptr,
        hipblasDoubleComplex.fromPyobj(AP).getElementPtr(),lda,
        <const double *>hip._util.types.Pointer.fromPyobj(beta)._ptr,
        hipblasDoubleComplex.fromPyobj(CP).getElementPtr(),ldc))
    return (_hipblasZherk__retval,)


@cython.embedsignature(True)
def hipblasCherk_v2(object handle, object uplo, object transA, int n, int k, object alpha, object AP, int lda, object beta, object CP, int ldc):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        uplo (`~.hipblasFillMode_t`):
            (undocumented)

        transA (`~.hipblasOperation_t`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        k (`~.int`):
            (undocumented)

        alpha (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        AP (`~.float2`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        beta (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        CP (`~.float2`/`~.object`):
            (undocumented)

        ldc (`~.int`):
            (undocumented)
    """
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")                    
    if not isinstance(transA,_hipblasOperation_t__Base):
        raise TypeError("argument 'transA' must be of type '_hipblasOperation_t__Base'")
    _hipblasCherk_v2__retval = hipblasStatus_t(chipblas.hipblasCherk_v2(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,uplo.value,transA.value,n,k,
        <const float *>hip._util.types.Pointer.fromPyobj(alpha)._ptr,
        float2.fromPyobj(AP).getElementPtr(),lda,
        <const float *>hip._util.types.Pointer.fromPyobj(beta)._ptr,
        float2.fromPyobj(CP).getElementPtr(),ldc))
    return (_hipblasCherk_v2__retval,)


@cython.embedsignature(True)
def hipblasZherk_v2(object handle, object uplo, object transA, int n, int k, object alpha, object AP, int lda, object beta, object CP, int ldc):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        uplo (`~.hipblasFillMode_t`):
            (undocumented)

        transA (`~.hipblasOperation_t`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        k (`~.int`):
            (undocumented)

        alpha (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        AP (`~.double2`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        beta (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        CP (`~.double2`/`~.object`):
            (undocumented)

        ldc (`~.int`):
            (undocumented)
    """
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")                    
    if not isinstance(transA,_hipblasOperation_t__Base):
        raise TypeError("argument 'transA' must be of type '_hipblasOperation_t__Base'")
    _hipblasZherk_v2__retval = hipblasStatus_t(chipblas.hipblasZherk_v2(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,uplo.value,transA.value,n,k,
        <const double *>hip._util.types.Pointer.fromPyobj(alpha)._ptr,
        double2.fromPyobj(AP).getElementPtr(),lda,
        <const double *>hip._util.types.Pointer.fromPyobj(beta)._ptr,
        double2.fromPyobj(CP).getElementPtr(),ldc))
    return (_hipblasZherk_v2__retval,)


@cython.embedsignature(True)
def hipblasCherkBatched(object handle, object uplo, object transA, int n, int k, object alpha, object AP, int lda, object beta, object CP, int ldc, int batchCount):
    r"""BLAS Level 3 API

    @{

    herkBatched performs a batch of the matrix-matrix operations for a Hermitian rank-k update

    C_i := alpha*op( A_i )*op( A_i )^H + beta*C_i

    where  alpha and beta are scalars, op(A) is an n by k matrix, and
    C_i is a n x n Hermitian matrix stored as either upper or lower.

        op( A_i ) = A_i, and A_i is n by k if transA == HIPBLAS_OP_N
        op( A_i ) = A_i^H and A_i is k by n if transA == HIPBLAS_OP_C

    - Supported precisions in rocBLAS : c,z
    - Supported precisions in cuBLAS  : No support

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`) -- *IN*:
            [hipblasHandle_t]
            handle to the hipblas library context queue.

        uplo (`~.hipblasFillMode_t`) -- *IN*:
            [hipblasFillMode_t]
            HIPBLAS_FILL_MODE_UPPER:  C_i is an upper triangular matrix
            HIPBLAS_FILL_MODE_LOWER:  C_i is a  lower triangular matrix

        transA (`~.hipblasOperation_t`) -- *IN*:
            [hipblasOperation_t]
            HIPBLAS_OP_C: op(A) = A^H
            HIPBLAS_OP_N: op(A) = A

        n (`~.int`) -- *IN*:
            [int]
            n specifies the number of rows and columns of C_i. n >= 0.

        k (`~.int`) -- *IN*:
            [int]
            k specifies the number of columns of op(A). k >= 0.

        alpha (`~.hip._util.types.Pointer`/`~.object`) -- *IN*:
            alpha specifies the scalar alpha. When alpha is
            zero then A is not referenced and A need not be set before
            entry.

        AP (`~.hip._util.types.Pointer`/`~.object`) -- *IN*:
            device array of device pointers storing each matrix_i A of dimension (lda, k)
            when transA is HIPBLAS_OP_N, otherwise of dimension (lda, n)

        lda (`~.int`) -- *IN*:
            [int]
            lda specifies the first dimension of A_i.
            if transA = HIPBLAS_OP_N,  lda >= max( 1, n ),
            otherwise lda >= max( 1, k ).

        beta (`~.hip._util.types.Pointer`/`~.object`) -- *IN*:
            beta specifies the scalar beta. When beta is
            zero then C need not be set before entry.

        CP (`~.hip._util.types.Pointer`/`~.object`) -- *IN*:
            device array of device pointers storing each matrix C_i on the GPU.
            The imaginary component of the diagonal elements are not used but are set to zero unless quick return.

        ldc (`~.int`) -- *IN*:
            [int]
            ldc specifies the first dimension of C. ldc >= max( 1, n ).

        batchCount (`~.int`) -- *IN*:
            [int]
            number of instances in the batch.
    """
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")                    
    if not isinstance(transA,_hipblasOperation_t__Base):
        raise TypeError("argument 'transA' must be of type '_hipblasOperation_t__Base'")
    _hipblasCherkBatched__retval = hipblasStatus_t(chipblas.hipblasCherkBatched(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,uplo.value,transA.value,n,k,
        <const float *>hip._util.types.Pointer.fromPyobj(alpha)._ptr,
        <chipblas.hipblasComplex *const*>hip._util.types.Pointer.fromPyobj(AP)._ptr,lda,
        <const float *>hip._util.types.Pointer.fromPyobj(beta)._ptr,
        <chipblas.hipblasComplex *const*>hip._util.types.Pointer.fromPyobj(CP)._ptr,ldc,batchCount))
    return (_hipblasCherkBatched__retval,)


@cython.embedsignature(True)
def hipblasZherkBatched(object handle, object uplo, object transA, int n, int k, object alpha, object AP, int lda, object beta, object CP, int ldc, int batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        uplo (`~.hipblasFillMode_t`):
            (undocumented)

        transA (`~.hipblasOperation_t`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        k (`~.int`):
            (undocumented)

        alpha (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        AP (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        beta (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        CP (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        ldc (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")                    
    if not isinstance(transA,_hipblasOperation_t__Base):
        raise TypeError("argument 'transA' must be of type '_hipblasOperation_t__Base'")
    _hipblasZherkBatched__retval = hipblasStatus_t(chipblas.hipblasZherkBatched(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,uplo.value,transA.value,n,k,
        <const double *>hip._util.types.Pointer.fromPyobj(alpha)._ptr,
        <chipblas.hipblasDoubleComplex *const*>hip._util.types.Pointer.fromPyobj(AP)._ptr,lda,
        <const double *>hip._util.types.Pointer.fromPyobj(beta)._ptr,
        <chipblas.hipblasDoubleComplex *const*>hip._util.types.Pointer.fromPyobj(CP)._ptr,ldc,batchCount))
    return (_hipblasZherkBatched__retval,)


@cython.embedsignature(True)
def hipblasCherkBatched_v2(object handle, object uplo, object transA, int n, int k, object alpha, object AP, int lda, object beta, object CP, int ldc, int batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        uplo (`~.hipblasFillMode_t`):
            (undocumented)

        transA (`~.hipblasOperation_t`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        k (`~.int`):
            (undocumented)

        alpha (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        AP (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        beta (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        CP (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        ldc (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")                    
    if not isinstance(transA,_hipblasOperation_t__Base):
        raise TypeError("argument 'transA' must be of type '_hipblasOperation_t__Base'")
    _hipblasCherkBatched_v2__retval = hipblasStatus_t(chipblas.hipblasCherkBatched_v2(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,uplo.value,transA.value,n,k,
        <const float *>hip._util.types.Pointer.fromPyobj(alpha)._ptr,
        <chipblas.float2 *const*>hip._util.types.Pointer.fromPyobj(AP)._ptr,lda,
        <const float *>hip._util.types.Pointer.fromPyobj(beta)._ptr,
        <chipblas.float2 *const*>hip._util.types.Pointer.fromPyobj(CP)._ptr,ldc,batchCount))
    return (_hipblasCherkBatched_v2__retval,)


@cython.embedsignature(True)
def hipblasZherkBatched_v2(object handle, object uplo, object transA, int n, int k, object alpha, object AP, int lda, object beta, object CP, int ldc, int batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        uplo (`~.hipblasFillMode_t`):
            (undocumented)

        transA (`~.hipblasOperation_t`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        k (`~.int`):
            (undocumented)

        alpha (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        AP (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        beta (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        CP (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        ldc (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")                    
    if not isinstance(transA,_hipblasOperation_t__Base):
        raise TypeError("argument 'transA' must be of type '_hipblasOperation_t__Base'")
    _hipblasZherkBatched_v2__retval = hipblasStatus_t(chipblas.hipblasZherkBatched_v2(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,uplo.value,transA.value,n,k,
        <const double *>hip._util.types.Pointer.fromPyobj(alpha)._ptr,
        <chipblas.double2 *const*>hip._util.types.Pointer.fromPyobj(AP)._ptr,lda,
        <const double *>hip._util.types.Pointer.fromPyobj(beta)._ptr,
        <chipblas.double2 *const*>hip._util.types.Pointer.fromPyobj(CP)._ptr,ldc,batchCount))
    return (_hipblasZherkBatched_v2__retval,)


@cython.embedsignature(True)
def hipblasCherkStridedBatched(object handle, object uplo, object transA, int n, int k, object alpha, object AP, int lda, long strideA, object beta, object CP, int ldc, long strideC, int batchCount):
    r"""BLAS Level 3 API

    @{

    herkStridedBatched performs a batch of the matrix-matrix operations for a Hermitian rank-k update

    C_i := alpha*op( A_i )*op( A_i )^H + beta*C_i

    where  alpha and beta are scalars, op(A) is an n by k matrix, and
    C_i is a n x n Hermitian matrix stored as either upper or lower.

        op( A_i ) = A_i, and A_i is n by k if transA == HIPBLAS_OP_N
        op( A_i ) = A_i^H and A_i is k by n if transA == HIPBLAS_OP_C

    - Supported precisions in rocBLAS : c,z
    - Supported precisions in cuBLAS  : No support

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`) -- *IN*:
            [hipblasHandle_t]
            handle to the hipblas library context queue.

        uplo (`~.hipblasFillMode_t`) -- *IN*:
            [hipblasFillMode_t]
            HIPBLAS_FILL_MODE_UPPER:  C_i is an upper triangular matrix
            HIPBLAS_FILL_MODE_LOWER:  C_i is a  lower triangular matrix

        transA (`~.hipblasOperation_t`) -- *IN*:
            [hipblasOperation_t]
            HIPBLAS_OP_C: op(A) = A^H
            HIPBLAS_OP_N: op(A) = A

        n (`~.int`) -- *IN*:
            [int]
            n specifies the number of rows and columns of C_i. n >= 0.

        k (`~.int`) -- *IN*:
            [int]
            k specifies the number of columns of op(A). k >= 0.

        alpha (`~.hip._util.types.Pointer`/`~.object`) -- *IN*:
            alpha specifies the scalar alpha. When alpha is
            zero then A is not referenced and A need not be set before
            entry.

        AP (`~.hipblasComplex`/`~.object`) -- *IN*:
            Device pointer to the first matrix A_1 on the GPU of dimension (lda, k)
            when transA is HIPBLAS_OP_N, otherwise of dimension (lda, n)

        lda (`~.int`) -- *IN*:
            [int]
            lda specifies the first dimension of A_i.
            if transA = HIPBLAS_OP_N,  lda >= max( 1, n ),
            otherwise lda >= max( 1, k ).

        strideA (`~.int`) -- *IN*:
            [hipblasStride]
            stride from the start of one matrix (A_i) and the next one (A_i+1)

        beta (`~.hip._util.types.Pointer`/`~.object`) -- *IN*:
            beta specifies the scalar beta. When beta is
            zero then C need not be set before entry.

        CP (`~.hipblasComplex`/`~.object`) -- *IN*:
            Device pointer to the first matrix C_1 on the GPU.
            The imaginary component of the diagonal elements are not used but are set to zero unless quick return.

        ldc (`~.int`) -- *IN*:
            [int]
            ldc specifies the first dimension of C. ldc >= max( 1, n ).

        strideC (`~.int`) -- *INOUT*:
            [hipblasStride]
            stride from the start of one matrix (C_i) and the next one (C_i+1)

        batchCount (`~.int`) -- *IN*:
            [int]
            number of instances in the batch.
    """
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")                    
    if not isinstance(transA,_hipblasOperation_t__Base):
        raise TypeError("argument 'transA' must be of type '_hipblasOperation_t__Base'")
    _hipblasCherkStridedBatched__retval = hipblasStatus_t(chipblas.hipblasCherkStridedBatched(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,uplo.value,transA.value,n,k,
        <const float *>hip._util.types.Pointer.fromPyobj(alpha)._ptr,
        hipblasComplex.fromPyobj(AP).getElementPtr(),lda,strideA,
        <const float *>hip._util.types.Pointer.fromPyobj(beta)._ptr,
        hipblasComplex.fromPyobj(CP).getElementPtr(),ldc,strideC,batchCount))
    return (_hipblasCherkStridedBatched__retval,)


@cython.embedsignature(True)
def hipblasZherkStridedBatched(object handle, object uplo, object transA, int n, int k, object alpha, object AP, int lda, long strideA, object beta, object CP, int ldc, long strideC, int batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        uplo (`~.hipblasFillMode_t`):
            (undocumented)

        transA (`~.hipblasOperation_t`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        k (`~.int`):
            (undocumented)

        alpha (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        AP (`~.hipblasDoubleComplex`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        strideA (`~.int`):
            (undocumented)

        beta (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        CP (`~.hipblasDoubleComplex`/`~.object`):
            (undocumented)

        ldc (`~.int`):
            (undocumented)

        strideC (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")                    
    if not isinstance(transA,_hipblasOperation_t__Base):
        raise TypeError("argument 'transA' must be of type '_hipblasOperation_t__Base'")
    _hipblasZherkStridedBatched__retval = hipblasStatus_t(chipblas.hipblasZherkStridedBatched(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,uplo.value,transA.value,n,k,
        <const double *>hip._util.types.Pointer.fromPyobj(alpha)._ptr,
        hipblasDoubleComplex.fromPyobj(AP).getElementPtr(),lda,strideA,
        <const double *>hip._util.types.Pointer.fromPyobj(beta)._ptr,
        hipblasDoubleComplex.fromPyobj(CP).getElementPtr(),ldc,strideC,batchCount))
    return (_hipblasZherkStridedBatched__retval,)


@cython.embedsignature(True)
def hipblasCherkStridedBatched_v2(object handle, object uplo, object transA, int n, int k, object alpha, object AP, int lda, long strideA, object beta, object CP, int ldc, long strideC, int batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        uplo (`~.hipblasFillMode_t`):
            (undocumented)

        transA (`~.hipblasOperation_t`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        k (`~.int`):
            (undocumented)

        alpha (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        AP (`~.float2`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        strideA (`~.int`):
            (undocumented)

        beta (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        CP (`~.float2`/`~.object`):
            (undocumented)

        ldc (`~.int`):
            (undocumented)

        strideC (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")                    
    if not isinstance(transA,_hipblasOperation_t__Base):
        raise TypeError("argument 'transA' must be of type '_hipblasOperation_t__Base'")
    _hipblasCherkStridedBatched_v2__retval = hipblasStatus_t(chipblas.hipblasCherkStridedBatched_v2(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,uplo.value,transA.value,n,k,
        <const float *>hip._util.types.Pointer.fromPyobj(alpha)._ptr,
        float2.fromPyobj(AP).getElementPtr(),lda,strideA,
        <const float *>hip._util.types.Pointer.fromPyobj(beta)._ptr,
        float2.fromPyobj(CP).getElementPtr(),ldc,strideC,batchCount))
    return (_hipblasCherkStridedBatched_v2__retval,)


@cython.embedsignature(True)
def hipblasZherkStridedBatched_v2(object handle, object uplo, object transA, int n, int k, object alpha, object AP, int lda, long strideA, object beta, object CP, int ldc, long strideC, int batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        uplo (`~.hipblasFillMode_t`):
            (undocumented)

        transA (`~.hipblasOperation_t`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        k (`~.int`):
            (undocumented)

        alpha (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        AP (`~.double2`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        strideA (`~.int`):
            (undocumented)

        beta (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        CP (`~.double2`/`~.object`):
            (undocumented)

        ldc (`~.int`):
            (undocumented)

        strideC (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")                    
    if not isinstance(transA,_hipblasOperation_t__Base):
        raise TypeError("argument 'transA' must be of type '_hipblasOperation_t__Base'")
    _hipblasZherkStridedBatched_v2__retval = hipblasStatus_t(chipblas.hipblasZherkStridedBatched_v2(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,uplo.value,transA.value,n,k,
        <const double *>hip._util.types.Pointer.fromPyobj(alpha)._ptr,
        double2.fromPyobj(AP).getElementPtr(),lda,strideA,
        <const double *>hip._util.types.Pointer.fromPyobj(beta)._ptr,
        double2.fromPyobj(CP).getElementPtr(),ldc,strideC,batchCount))
    return (_hipblasZherkStridedBatched_v2__retval,)


@cython.embedsignature(True)
def hipblasCherkx(object handle, object uplo, object transA, int n, int k, object alpha, object AP, int lda, object BP, int ldb, object beta, object CP, int ldc):
    r"""BLAS Level 3 API

    @{

    herkx performs one of the matrix-matrix operations for a Hermitian rank-k update

    C := alpha*op( A )*op( B )^H + beta*C

    where  alpha and beta are scalars, op(A) and op(B) are n by k matrices, and
    C is a n x n Hermitian matrix stored as either upper or lower.
    This routine should only be used when the caller can guarantee that the result of op( A )*op( B )^T will be Hermitian.

        op( A ) = A, op( B ) = B, and A and B are n by k if trans == HIPBLAS_OP_N
        op( A ) = A^H, op( B ) = B^H,  and A and B are k by n if trans == HIPBLAS_OP_C

    - Supported precisions in rocBLAS : c,z
    - Supported precisions in cuBLAS  : c,z

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`) -- *IN*:
            [hipblasHandle_t]
            handle to the hipblas library context queue.

        uplo (`~.hipblasFillMode_t`) -- *IN*:
            [hipblasFillMode_t]
            HIPBLAS_FILL_MODE_UPPER:  C is an upper triangular matrix
            HIPBLAS_FILL_MODE_LOWER:  C is a  lower triangular matrix

        transA (`~.hipblasOperation_t`) -- *IN*:
            [hipblasOperation_t]
            HIPBLAS_OP_C:  op( A ) = A^H, op( B ) = B^H
            HIPBLAS_OP_N:  op( A ) = A, op( B ) = B

        n (`~.int`) -- *IN*:
            [int]
            n specifies the number of rows and columns of C. n >= 0.

        k (`~.int`) -- *IN*:
            [int]
            k specifies the number of columns of op(A). k >= 0.

        alpha (`~.hipblasComplex`/`~.object`) -- *IN*:
            alpha specifies the scalar alpha. When alpha is
            zero then A is not referenced and A need not be set before
            entry.

        AP (`~.hipblasComplex`/`~.object`) -- *IN*:
            pointer storing matrix A on the GPU.
            Martrix dimension is ( lda, k ) when if trans = HIPBLAS_OP_N, otherwise (lda, n)
            only the upper/lower triangular part is accessed.

        lda (`~.int`) -- *IN*:
            [int]
            lda specifies the first dimension of A.
            if trans = HIPBLAS_OP_N,  lda >= max( 1, n ),
            otherwise lda >= max( 1, k ).

        BP (`~.hipblasComplex`/`~.object`) -- *IN*:
            pointer storing matrix B on the GPU.
            Martrix dimension is ( ldb, k ) when if trans = HIPBLAS_OP_N, otherwise (ldb, n)
            only the upper/lower triangular part is accessed.

        ldb (`~.int`) -- *IN*:
            [int]
            ldb specifies the first dimension of B.
            if trans = HIPBLAS_OP_N,  ldb >= max( 1, n ),
            otherwise ldb >= max( 1, k ).

        beta (`~.hip._util.types.Pointer`/`~.object`) -- *IN*:
            beta specifies the scalar beta. When beta is
            zero then C need not be set before entry.

        CP (`~.hipblasComplex`/`~.object`) -- *IN*:
            pointer storing matrix C on the GPU.
            The imaginary component of the diagonal elements are not used but are set to zero unless quick return.

        ldc (`~.int`) -- *IN*:
            [int]
            ldc specifies the first dimension of C. ldc >= max( 1, n ).
    """
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")                    
    if not isinstance(transA,_hipblasOperation_t__Base):
        raise TypeError("argument 'transA' must be of type '_hipblasOperation_t__Base'")
    _hipblasCherkx__retval = hipblasStatus_t(chipblas.hipblasCherkx(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,uplo.value,transA.value,n,k,
        hipblasComplex.fromPyobj(alpha).getElementPtr(),
        hipblasComplex.fromPyobj(AP).getElementPtr(),lda,
        hipblasComplex.fromPyobj(BP).getElementPtr(),ldb,
        <const float *>hip._util.types.Pointer.fromPyobj(beta)._ptr,
        hipblasComplex.fromPyobj(CP).getElementPtr(),ldc))
    return (_hipblasCherkx__retval,)


@cython.embedsignature(True)
def hipblasZherkx(object handle, object uplo, object transA, int n, int k, object alpha, object AP, int lda, object BP, int ldb, object beta, object CP, int ldc):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        uplo (`~.hipblasFillMode_t`):
            (undocumented)

        transA (`~.hipblasOperation_t`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        k (`~.int`):
            (undocumented)

        alpha (`~.hipblasDoubleComplex`/`~.object`):
            (undocumented)

        AP (`~.hipblasDoubleComplex`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        BP (`~.hipblasDoubleComplex`/`~.object`):
            (undocumented)

        ldb (`~.int`):
            (undocumented)

        beta (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        CP (`~.hipblasDoubleComplex`/`~.object`):
            (undocumented)

        ldc (`~.int`):
            (undocumented)
    """
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")                    
    if not isinstance(transA,_hipblasOperation_t__Base):
        raise TypeError("argument 'transA' must be of type '_hipblasOperation_t__Base'")
    _hipblasZherkx__retval = hipblasStatus_t(chipblas.hipblasZherkx(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,uplo.value,transA.value,n,k,
        hipblasDoubleComplex.fromPyobj(alpha).getElementPtr(),
        hipblasDoubleComplex.fromPyobj(AP).getElementPtr(),lda,
        hipblasDoubleComplex.fromPyobj(BP).getElementPtr(),ldb,
        <const double *>hip._util.types.Pointer.fromPyobj(beta)._ptr,
        hipblasDoubleComplex.fromPyobj(CP).getElementPtr(),ldc))
    return (_hipblasZherkx__retval,)


@cython.embedsignature(True)
def hipblasCherkx_v2(object handle, object uplo, object transA, int n, int k, object alpha, object AP, int lda, object BP, int ldb, object beta, object CP, int ldc):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        uplo (`~.hipblasFillMode_t`):
            (undocumented)

        transA (`~.hipblasOperation_t`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        k (`~.int`):
            (undocumented)

        alpha (`~.float2`/`~.object`):
            (undocumented)

        AP (`~.float2`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        BP (`~.float2`/`~.object`):
            (undocumented)

        ldb (`~.int`):
            (undocumented)

        beta (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        CP (`~.float2`/`~.object`):
            (undocumented)

        ldc (`~.int`):
            (undocumented)
    """
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")                    
    if not isinstance(transA,_hipblasOperation_t__Base):
        raise TypeError("argument 'transA' must be of type '_hipblasOperation_t__Base'")
    _hipblasCherkx_v2__retval = hipblasStatus_t(chipblas.hipblasCherkx_v2(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,uplo.value,transA.value,n,k,
        float2.fromPyobj(alpha).getElementPtr(),
        float2.fromPyobj(AP).getElementPtr(),lda,
        float2.fromPyobj(BP).getElementPtr(),ldb,
        <const float *>hip._util.types.Pointer.fromPyobj(beta)._ptr,
        float2.fromPyobj(CP).getElementPtr(),ldc))
    return (_hipblasCherkx_v2__retval,)


@cython.embedsignature(True)
def hipblasZherkx_v2(object handle, object uplo, object transA, int n, int k, object alpha, object AP, int lda, object BP, int ldb, object beta, object CP, int ldc):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        uplo (`~.hipblasFillMode_t`):
            (undocumented)

        transA (`~.hipblasOperation_t`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        k (`~.int`):
            (undocumented)

        alpha (`~.double2`/`~.object`):
            (undocumented)

        AP (`~.double2`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        BP (`~.double2`/`~.object`):
            (undocumented)

        ldb (`~.int`):
            (undocumented)

        beta (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        CP (`~.double2`/`~.object`):
            (undocumented)

        ldc (`~.int`):
            (undocumented)
    """
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")                    
    if not isinstance(transA,_hipblasOperation_t__Base):
        raise TypeError("argument 'transA' must be of type '_hipblasOperation_t__Base'")
    _hipblasZherkx_v2__retval = hipblasStatus_t(chipblas.hipblasZherkx_v2(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,uplo.value,transA.value,n,k,
        double2.fromPyobj(alpha).getElementPtr(),
        double2.fromPyobj(AP).getElementPtr(),lda,
        double2.fromPyobj(BP).getElementPtr(),ldb,
        <const double *>hip._util.types.Pointer.fromPyobj(beta)._ptr,
        double2.fromPyobj(CP).getElementPtr(),ldc))
    return (_hipblasZherkx_v2__retval,)


@cython.embedsignature(True)
def hipblasCherkxBatched(object handle, object uplo, object transA, int n, int k, object alpha, object AP, int lda, object BP, int ldb, object beta, object CP, int ldc, int batchCount):
    r"""BLAS Level 3 API

    @{

    herkxBatched performs a batch of the matrix-matrix operations for a Hermitian rank-k update

    C_i := alpha*op( A_i )*op( B_i )^H + beta*C_i

    where  alpha and beta are scalars, op(A_i) and op(B_i) are n by k matrices, and
    C_i is a n x n Hermitian matrix stored as either upper or lower.
    This routine should only be used when the caller can guarantee that the result of op( A )*op( B )^T will be Hermitian.

        op( A_i ) = A_i, op( B_i ) = B_i, and A_i and B_i are n by k if trans == HIPBLAS_OP_N
        op( A_i ) = A_i^H, op( B_i ) = B_i^H,  and A_i and B_i are k by n if trans == HIPBLAS_OP_C

    - Supported precisions in rocBLAS : c,z
    - Supported precisions in cuBLAS  : No support

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`) -- *IN*:
            [hipblasHandle_t]
            handle to the hipblas library context queue.

        uplo (`~.hipblasFillMode_t`) -- *IN*:
            [hipblasFillMode_t]
            HIPBLAS_FILL_MODE_UPPER:  C_i is an upper triangular matrix
            HIPBLAS_FILL_MODE_LOWER:  C_i is a  lower triangular matrix

        transA (`~.hipblasOperation_t`) -- *IN*:
            [hipblasOperation_t]
            HIPBLAS_OP_C: op(A) = A^H
            HIPBLAS_OP_N: op(A) = A

        n (`~.int`) -- *IN*:
            [int]
            n specifies the number of rows and columns of C_i. n >= 0.

        k (`~.int`) -- *IN*:
            [int]
            k specifies the number of columns of op(A). k >= 0.

        alpha (`~.hipblasComplex`/`~.object`) -- *IN*:
            alpha specifies the scalar alpha. When alpha is
            zero then A is not referenced and A need not be set before
            entry.

        AP (`~.hip._util.types.Pointer`/`~.object`) -- *IN*:
            device array of device pointers storing each matrix_i A of dimension (lda, k)
            when trans is HIPBLAS_OP_N, otherwise of dimension (lda, n)

        lda (`~.int`) -- *IN*:
            [int]
            lda specifies the first dimension of A_i.
            if trans = HIPBLAS_OP_N,  lda >= max( 1, n ),
            otherwise lda >= max( 1, k ).

        BP (`~.hip._util.types.Pointer`/`~.object`) -- *IN*:
            device array of device pointers storing each matrix_i B of dimension (ldb, k)
            when trans is HIPBLAS_OP_N, otherwise of dimension (ldb, n)

        ldb (`~.int`) -- *IN*:
            [int]
            ldb specifies the first dimension of B_i.
            if trans = HIPBLAS_OP_N,  ldb >= max( 1, n ),
            otherwise ldb >= max( 1, k ).

        beta (`~.hip._util.types.Pointer`/`~.object`) -- *IN*:
            beta specifies the scalar beta. When beta is
            zero then C need not be set before entry.

        CP (`~.hip._util.types.Pointer`/`~.object`) -- *IN*:
            device array of device pointers storing each matrix C_i on the GPU.
            The imaginary component of the diagonal elements are not used but are set to zero unless quick return.

        ldc (`~.int`) -- *IN*:
            [int]
            ldc specifies the first dimension of C. ldc >= max( 1, n ).

        batchCount (`~.int`) -- *IN*:
            [int]
            number of instances in the batch.
    """
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")                    
    if not isinstance(transA,_hipblasOperation_t__Base):
        raise TypeError("argument 'transA' must be of type '_hipblasOperation_t__Base'")
    _hipblasCherkxBatched__retval = hipblasStatus_t(chipblas.hipblasCherkxBatched(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,uplo.value,transA.value,n,k,
        hipblasComplex.fromPyobj(alpha).getElementPtr(),
        <chipblas.hipblasComplex *const*>hip._util.types.Pointer.fromPyobj(AP)._ptr,lda,
        <chipblas.hipblasComplex *const*>hip._util.types.Pointer.fromPyobj(BP)._ptr,ldb,
        <const float *>hip._util.types.Pointer.fromPyobj(beta)._ptr,
        <chipblas.hipblasComplex *const*>hip._util.types.Pointer.fromPyobj(CP)._ptr,ldc,batchCount))
    return (_hipblasCherkxBatched__retval,)


@cython.embedsignature(True)
def hipblasZherkxBatched(object handle, object uplo, object transA, int n, int k, object alpha, object AP, int lda, object BP, int ldb, object beta, object CP, int ldc, int batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        uplo (`~.hipblasFillMode_t`):
            (undocumented)

        transA (`~.hipblasOperation_t`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        k (`~.int`):
            (undocumented)

        alpha (`~.hipblasDoubleComplex`/`~.object`):
            (undocumented)

        AP (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        BP (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        ldb (`~.int`):
            (undocumented)

        beta (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        CP (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        ldc (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")                    
    if not isinstance(transA,_hipblasOperation_t__Base):
        raise TypeError("argument 'transA' must be of type '_hipblasOperation_t__Base'")
    _hipblasZherkxBatched__retval = hipblasStatus_t(chipblas.hipblasZherkxBatched(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,uplo.value,transA.value,n,k,
        hipblasDoubleComplex.fromPyobj(alpha).getElementPtr(),
        <chipblas.hipblasDoubleComplex *const*>hip._util.types.Pointer.fromPyobj(AP)._ptr,lda,
        <chipblas.hipblasDoubleComplex *const*>hip._util.types.Pointer.fromPyobj(BP)._ptr,ldb,
        <const double *>hip._util.types.Pointer.fromPyobj(beta)._ptr,
        <chipblas.hipblasDoubleComplex *const*>hip._util.types.Pointer.fromPyobj(CP)._ptr,ldc,batchCount))
    return (_hipblasZherkxBatched__retval,)


@cython.embedsignature(True)
def hipblasCherkxBatched_v2(object handle, object uplo, object transA, int n, int k, object alpha, object AP, int lda, object BP, int ldb, object beta, object CP, int ldc, int batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        uplo (`~.hipblasFillMode_t`):
            (undocumented)

        transA (`~.hipblasOperation_t`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        k (`~.int`):
            (undocumented)

        alpha (`~.float2`/`~.object`):
            (undocumented)

        AP (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        BP (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        ldb (`~.int`):
            (undocumented)

        beta (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        CP (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        ldc (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")                    
    if not isinstance(transA,_hipblasOperation_t__Base):
        raise TypeError("argument 'transA' must be of type '_hipblasOperation_t__Base'")
    _hipblasCherkxBatched_v2__retval = hipblasStatus_t(chipblas.hipblasCherkxBatched_v2(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,uplo.value,transA.value,n,k,
        float2.fromPyobj(alpha).getElementPtr(),
        <chipblas.float2 *const*>hip._util.types.Pointer.fromPyobj(AP)._ptr,lda,
        <chipblas.float2 *const*>hip._util.types.Pointer.fromPyobj(BP)._ptr,ldb,
        <const float *>hip._util.types.Pointer.fromPyobj(beta)._ptr,
        <chipblas.float2 *const*>hip._util.types.Pointer.fromPyobj(CP)._ptr,ldc,batchCount))
    return (_hipblasCherkxBatched_v2__retval,)


@cython.embedsignature(True)
def hipblasZherkxBatched_v2(object handle, object uplo, object transA, int n, int k, object alpha, object AP, int lda, object BP, int ldb, object beta, object CP, int ldc, int batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        uplo (`~.hipblasFillMode_t`):
            (undocumented)

        transA (`~.hipblasOperation_t`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        k (`~.int`):
            (undocumented)

        alpha (`~.double2`/`~.object`):
            (undocumented)

        AP (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        BP (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        ldb (`~.int`):
            (undocumented)

        beta (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        CP (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        ldc (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")                    
    if not isinstance(transA,_hipblasOperation_t__Base):
        raise TypeError("argument 'transA' must be of type '_hipblasOperation_t__Base'")
    _hipblasZherkxBatched_v2__retval = hipblasStatus_t(chipblas.hipblasZherkxBatched_v2(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,uplo.value,transA.value,n,k,
        double2.fromPyobj(alpha).getElementPtr(),
        <chipblas.double2 *const*>hip._util.types.Pointer.fromPyobj(AP)._ptr,lda,
        <chipblas.double2 *const*>hip._util.types.Pointer.fromPyobj(BP)._ptr,ldb,
        <const double *>hip._util.types.Pointer.fromPyobj(beta)._ptr,
        <chipblas.double2 *const*>hip._util.types.Pointer.fromPyobj(CP)._ptr,ldc,batchCount))
    return (_hipblasZherkxBatched_v2__retval,)


@cython.embedsignature(True)
def hipblasCherkxStridedBatched(object handle, object uplo, object transA, int n, int k, object alpha, object AP, int lda, long strideA, object BP, int ldb, long strideB, object beta, object CP, int ldc, long strideC, int batchCount):
    r"""BLAS Level 3 API

    @{

    herkxStridedBatched performs a batch of the matrix-matrix operations for a Hermitian rank-k update

    C_i := alpha*op( A_i )*op( B_i )^H + beta*C_i

    where  alpha and beta are scalars, op(A_i) and op(B_i) are n by k matrices, and
    C_i is a n x n Hermitian matrix stored as either upper or lower.
    This routine should only be used when the caller can guarantee that the result of op( A )*op( B )^T will be Hermitian.

        op( A_i ) = A_i, op( B_i ) = B_i, and A_i and B_i are n by k if trans == HIPBLAS_OP_N
        op( A_i ) = A_i^H, op( B_i ) = B_i^H,  and A_i and B_i are k by n if trans == HIPBLAS_OP_C

    - Supported precisions in rocBLAS : c,z
    - Supported precisions in cuBLAS  : No support

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`) -- *IN*:
            [hipblasHandle_t]
            handle to the hipblas library context queue.

        uplo (`~.hipblasFillMode_t`) -- *IN*:
            [hipblasFillMode_t]
            HIPBLAS_FILL_MODE_UPPER:  C_i is an upper triangular matrix
            HIPBLAS_FILL_MODE_LOWER:  C_i is a  lower triangular matrix

        transA (`~.hipblasOperation_t`) -- *IN*:
            [hipblasOperation_t]
            HIPBLAS_OP_C: op( A_i ) = A_i^H, op( B_i ) = B_i^H
            HIPBLAS_OP_N: op( A_i ) = A_i, op( B_i ) = B_i

        n (`~.int`) -- *IN*:
            [int]
            n specifies the number of rows and columns of C_i. n >= 0.

        k (`~.int`) -- *IN*:
            [int]
            k specifies the number of columns of op(A). k >= 0.

        alpha (`~.hipblasComplex`/`~.object`) -- *IN*:
            alpha specifies the scalar alpha. When alpha is
            zero then A is not referenced and A need not be set before
            entry.

        AP (`~.hipblasComplex`/`~.object`) -- *IN*:
            Device pointer to the first matrix A_1 on the GPU of dimension (lda, k)
            when trans is HIPBLAS_OP_N, otherwise of dimension (lda, n)

        lda (`~.int`) -- *IN*:
            [int]
            lda specifies the first dimension of A_i.
            if trans = HIPBLAS_OP_N,  lda >= max( 1, n ),
            otherwise lda >= max( 1, k ).

        strideA (`~.int`) -- *IN*:
            [hipblasStride]
            stride from the start of one matrix (A_i) and the next one (A_i+1)

        BP (`~.hipblasComplex`/`~.object`) -- *IN*:
            Device pointer to the first matrix B_1 on the GPU of dimension (ldb, k)
            when trans is HIPBLAS_OP_N, otherwise of dimension (ldb, n)

        ldb (`~.int`) -- *IN*:
            [int]
            ldb specifies the first dimension of B_i.
            if trans = HIPBLAS_OP_N,  ldb >= max( 1, n ),
            otherwise ldb >= max( 1, k ).

        strideB (`~.int`) -- *IN*:
            [hipblasStride]
            stride from the start of one matrix (B_i) and the next one (B_i+1)

        beta (`~.hip._util.types.Pointer`/`~.object`) -- *IN*:
            beta specifies the scalar beta. When beta is
            zero then C need not be set before entry.

        CP (`~.hipblasComplex`/`~.object`) -- *IN*:
            Device pointer to the first matrix C_1 on the GPU.
            The imaginary component of the diagonal elements are not used but are set to zero unless quick return.

        ldc (`~.int`) -- *IN*:
            [int]
            ldc specifies the first dimension of C. ldc >= max( 1, n ).

        strideC (`~.int`) -- *INOUT*:
            [hipblasStride]
            stride from the start of one matrix (C_i) and the next one (C_i+1)

        batchCount (`~.int`) -- *IN*:
            [int]
            number of instances in the batch.
    """
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")                    
    if not isinstance(transA,_hipblasOperation_t__Base):
        raise TypeError("argument 'transA' must be of type '_hipblasOperation_t__Base'")
    _hipblasCherkxStridedBatched__retval = hipblasStatus_t(chipblas.hipblasCherkxStridedBatched(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,uplo.value,transA.value,n,k,
        hipblasComplex.fromPyobj(alpha).getElementPtr(),
        hipblasComplex.fromPyobj(AP).getElementPtr(),lda,strideA,
        hipblasComplex.fromPyobj(BP).getElementPtr(),ldb,strideB,
        <const float *>hip._util.types.Pointer.fromPyobj(beta)._ptr,
        hipblasComplex.fromPyobj(CP).getElementPtr(),ldc,strideC,batchCount))
    return (_hipblasCherkxStridedBatched__retval,)


@cython.embedsignature(True)
def hipblasZherkxStridedBatched(object handle, object uplo, object transA, int n, int k, object alpha, object AP, int lda, long strideA, object BP, int ldb, long strideB, object beta, object CP, int ldc, long strideC, int batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        uplo (`~.hipblasFillMode_t`):
            (undocumented)

        transA (`~.hipblasOperation_t`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        k (`~.int`):
            (undocumented)

        alpha (`~.hipblasDoubleComplex`/`~.object`):
            (undocumented)

        AP (`~.hipblasDoubleComplex`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        strideA (`~.int`):
            (undocumented)

        BP (`~.hipblasDoubleComplex`/`~.object`):
            (undocumented)

        ldb (`~.int`):
            (undocumented)

        strideB (`~.int`):
            (undocumented)

        beta (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        CP (`~.hipblasDoubleComplex`/`~.object`):
            (undocumented)

        ldc (`~.int`):
            (undocumented)

        strideC (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")                    
    if not isinstance(transA,_hipblasOperation_t__Base):
        raise TypeError("argument 'transA' must be of type '_hipblasOperation_t__Base'")
    _hipblasZherkxStridedBatched__retval = hipblasStatus_t(chipblas.hipblasZherkxStridedBatched(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,uplo.value,transA.value,n,k,
        hipblasDoubleComplex.fromPyobj(alpha).getElementPtr(),
        hipblasDoubleComplex.fromPyobj(AP).getElementPtr(),lda,strideA,
        hipblasDoubleComplex.fromPyobj(BP).getElementPtr(),ldb,strideB,
        <const double *>hip._util.types.Pointer.fromPyobj(beta)._ptr,
        hipblasDoubleComplex.fromPyobj(CP).getElementPtr(),ldc,strideC,batchCount))
    return (_hipblasZherkxStridedBatched__retval,)


@cython.embedsignature(True)
def hipblasCherkxStridedBatched_v2(object handle, object uplo, object transA, int n, int k, object alpha, object AP, int lda, long strideA, object BP, int ldb, long strideB, object beta, object CP, int ldc, long strideC, int batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        uplo (`~.hipblasFillMode_t`):
            (undocumented)

        transA (`~.hipblasOperation_t`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        k (`~.int`):
            (undocumented)

        alpha (`~.float2`/`~.object`):
            (undocumented)

        AP (`~.float2`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        strideA (`~.int`):
            (undocumented)

        BP (`~.float2`/`~.object`):
            (undocumented)

        ldb (`~.int`):
            (undocumented)

        strideB (`~.int`):
            (undocumented)

        beta (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        CP (`~.float2`/`~.object`):
            (undocumented)

        ldc (`~.int`):
            (undocumented)

        strideC (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")                    
    if not isinstance(transA,_hipblasOperation_t__Base):
        raise TypeError("argument 'transA' must be of type '_hipblasOperation_t__Base'")
    _hipblasCherkxStridedBatched_v2__retval = hipblasStatus_t(chipblas.hipblasCherkxStridedBatched_v2(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,uplo.value,transA.value,n,k,
        float2.fromPyobj(alpha).getElementPtr(),
        float2.fromPyobj(AP).getElementPtr(),lda,strideA,
        float2.fromPyobj(BP).getElementPtr(),ldb,strideB,
        <const float *>hip._util.types.Pointer.fromPyobj(beta)._ptr,
        float2.fromPyobj(CP).getElementPtr(),ldc,strideC,batchCount))
    return (_hipblasCherkxStridedBatched_v2__retval,)


@cython.embedsignature(True)
def hipblasZherkxStridedBatched_v2(object handle, object uplo, object transA, int n, int k, object alpha, object AP, int lda, long strideA, object BP, int ldb, long strideB, object beta, object CP, int ldc, long strideC, int batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        uplo (`~.hipblasFillMode_t`):
            (undocumented)

        transA (`~.hipblasOperation_t`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        k (`~.int`):
            (undocumented)

        alpha (`~.double2`/`~.object`):
            (undocumented)

        AP (`~.double2`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        strideA (`~.int`):
            (undocumented)

        BP (`~.double2`/`~.object`):
            (undocumented)

        ldb (`~.int`):
            (undocumented)

        strideB (`~.int`):
            (undocumented)

        beta (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        CP (`~.double2`/`~.object`):
            (undocumented)

        ldc (`~.int`):
            (undocumented)

        strideC (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")                    
    if not isinstance(transA,_hipblasOperation_t__Base):
        raise TypeError("argument 'transA' must be of type '_hipblasOperation_t__Base'")
    _hipblasZherkxStridedBatched_v2__retval = hipblasStatus_t(chipblas.hipblasZherkxStridedBatched_v2(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,uplo.value,transA.value,n,k,
        double2.fromPyobj(alpha).getElementPtr(),
        double2.fromPyobj(AP).getElementPtr(),lda,strideA,
        double2.fromPyobj(BP).getElementPtr(),ldb,strideB,
        <const double *>hip._util.types.Pointer.fromPyobj(beta)._ptr,
        double2.fromPyobj(CP).getElementPtr(),ldc,strideC,batchCount))
    return (_hipblasZherkxStridedBatched_v2__retval,)


@cython.embedsignature(True)
def hipblasCher2k(object handle, object uplo, object transA, int n, int k, object alpha, object AP, int lda, object BP, int ldb, object beta, object CP, int ldc):
    r"""BLAS Level 3 API

    @{

    her2k performs one of the matrix-matrix operations for a Hermitian rank-2k update

    C := alpha*op( A )*op( B )^H + conj(alpha)*op( B )*op( A )^H + beta*C

    where  alpha and beta are scalars, op(A) and op(B) are n by k matrices, and
    C is a n x n Hermitian matrix stored as either upper or lower.

        op( A ) = A, op( B ) = B, and A and B are n by k if trans == HIPBLAS_OP_N
        op( A ) = A^H, op( B ) = B^H,  and A and B are k by n if trans == HIPBLAS_OP_C

    - Supported precisions in rocBLAS : c,z
    - Supported precisions in cuBLAS  : c,z

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`) -- *IN*:
            [hipblasHandle_t]
            handle to the hipblas library context queue.

        uplo (`~.hipblasFillMode_t`) -- *IN*:
            [hipblasFillMode_t]
            HIPBLAS_FILL_MODE_UPPER:  C is an upper triangular matrix
            HIPBLAS_FILL_MODE_LOWER:  C is a  lower triangular matrix

        transA (`~.hipblasOperation_t`) -- *IN*:
            [hipblasOperation_t]
            HIPBLAS_OP_C:  op( A ) = A^H, op( B ) = B^H
            HIPBLAS_OP_N:  op( A ) = A, op( B ) = B

        n (`~.int`) -- *IN*:
            [int]
            n specifies the number of rows and columns of C. n >= 0.

        k (`~.int`) -- *IN*:
            [int]
            k specifies the number of columns of op(A). k >= 0.

        alpha (`~.hipblasComplex`/`~.object`) -- *IN*:
            alpha specifies the scalar alpha. When alpha is
            zero then A is not referenced and A need not be set before
            entry.

        AP (`~.hipblasComplex`/`~.object`) -- *IN*:
            pointer storing matrix A on the GPU.
            Martrix dimension is ( lda, k ) when if trans = HIPBLAS_OP_N, otherwise (lda, n)
            only the upper/lower triangular part is accessed.

        lda (`~.int`) -- *IN*:
            [int]
            lda specifies the first dimension of A.
            if trans = HIPBLAS_OP_N,  lda >= max( 1, n ),
            otherwise lda >= max( 1, k ).

        BP (`~.hipblasComplex`/`~.object`) -- *IN*:
            pointer storing matrix B on the GPU.
            Martrix dimension is ( ldb, k ) when if trans = HIPBLAS_OP_N, otherwise (ldb, n)
            only the upper/lower triangular part is accessed.

        ldb (`~.int`) -- *IN*:
            [int]
            ldb specifies the first dimension of B.
            if trans = HIPBLAS_OP_N,  ldb >= max( 1, n ),
            otherwise ldb >= max( 1, k ).

        beta (`~.hip._util.types.Pointer`/`~.object`) -- *IN*:
            beta specifies the scalar beta. When beta is
            zero then C need not be set before entry.

        CP (`~.hipblasComplex`/`~.object`) -- *IN*:
            pointer storing matrix C on the GPU.
            The imaginary component of the diagonal elements are not used but are set to zero unless quick return.

        ldc (`~.int`) -- *IN*:
            [int]
            ldc specifies the first dimension of C. ldc >= max( 1, n ).
    """
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")                    
    if not isinstance(transA,_hipblasOperation_t__Base):
        raise TypeError("argument 'transA' must be of type '_hipblasOperation_t__Base'")
    _hipblasCher2k__retval = hipblasStatus_t(chipblas.hipblasCher2k(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,uplo.value,transA.value,n,k,
        hipblasComplex.fromPyobj(alpha).getElementPtr(),
        hipblasComplex.fromPyobj(AP).getElementPtr(),lda,
        hipblasComplex.fromPyobj(BP).getElementPtr(),ldb,
        <const float *>hip._util.types.Pointer.fromPyobj(beta)._ptr,
        hipblasComplex.fromPyobj(CP).getElementPtr(),ldc))
    return (_hipblasCher2k__retval,)


@cython.embedsignature(True)
def hipblasZher2k(object handle, object uplo, object transA, int n, int k, object alpha, object AP, int lda, object BP, int ldb, object beta, object CP, int ldc):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        uplo (`~.hipblasFillMode_t`):
            (undocumented)

        transA (`~.hipblasOperation_t`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        k (`~.int`):
            (undocumented)

        alpha (`~.hipblasDoubleComplex`/`~.object`):
            (undocumented)

        AP (`~.hipblasDoubleComplex`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        BP (`~.hipblasDoubleComplex`/`~.object`):
            (undocumented)

        ldb (`~.int`):
            (undocumented)

        beta (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        CP (`~.hipblasDoubleComplex`/`~.object`):
            (undocumented)

        ldc (`~.int`):
            (undocumented)
    """
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")                    
    if not isinstance(transA,_hipblasOperation_t__Base):
        raise TypeError("argument 'transA' must be of type '_hipblasOperation_t__Base'")
    _hipblasZher2k__retval = hipblasStatus_t(chipblas.hipblasZher2k(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,uplo.value,transA.value,n,k,
        hipblasDoubleComplex.fromPyobj(alpha).getElementPtr(),
        hipblasDoubleComplex.fromPyobj(AP).getElementPtr(),lda,
        hipblasDoubleComplex.fromPyobj(BP).getElementPtr(),ldb,
        <const double *>hip._util.types.Pointer.fromPyobj(beta)._ptr,
        hipblasDoubleComplex.fromPyobj(CP).getElementPtr(),ldc))
    return (_hipblasZher2k__retval,)


@cython.embedsignature(True)
def hipblasCher2k_v2(object handle, object uplo, object transA, int n, int k, object alpha, object AP, int lda, object BP, int ldb, object beta, object CP, int ldc):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        uplo (`~.hipblasFillMode_t`):
            (undocumented)

        transA (`~.hipblasOperation_t`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        k (`~.int`):
            (undocumented)

        alpha (`~.float2`/`~.object`):
            (undocumented)

        AP (`~.float2`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        BP (`~.float2`/`~.object`):
            (undocumented)

        ldb (`~.int`):
            (undocumented)

        beta (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        CP (`~.float2`/`~.object`):
            (undocumented)

        ldc (`~.int`):
            (undocumented)
    """
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")                    
    if not isinstance(transA,_hipblasOperation_t__Base):
        raise TypeError("argument 'transA' must be of type '_hipblasOperation_t__Base'")
    _hipblasCher2k_v2__retval = hipblasStatus_t(chipblas.hipblasCher2k_v2(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,uplo.value,transA.value,n,k,
        float2.fromPyobj(alpha).getElementPtr(),
        float2.fromPyobj(AP).getElementPtr(),lda,
        float2.fromPyobj(BP).getElementPtr(),ldb,
        <const float *>hip._util.types.Pointer.fromPyobj(beta)._ptr,
        float2.fromPyobj(CP).getElementPtr(),ldc))
    return (_hipblasCher2k_v2__retval,)


@cython.embedsignature(True)
def hipblasZher2k_v2(object handle, object uplo, object transA, int n, int k, object alpha, object AP, int lda, object BP, int ldb, object beta, object CP, int ldc):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        uplo (`~.hipblasFillMode_t`):
            (undocumented)

        transA (`~.hipblasOperation_t`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        k (`~.int`):
            (undocumented)

        alpha (`~.double2`/`~.object`):
            (undocumented)

        AP (`~.double2`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        BP (`~.double2`/`~.object`):
            (undocumented)

        ldb (`~.int`):
            (undocumented)

        beta (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        CP (`~.double2`/`~.object`):
            (undocumented)

        ldc (`~.int`):
            (undocumented)
    """
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")                    
    if not isinstance(transA,_hipblasOperation_t__Base):
        raise TypeError("argument 'transA' must be of type '_hipblasOperation_t__Base'")
    _hipblasZher2k_v2__retval = hipblasStatus_t(chipblas.hipblasZher2k_v2(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,uplo.value,transA.value,n,k,
        double2.fromPyobj(alpha).getElementPtr(),
        double2.fromPyobj(AP).getElementPtr(),lda,
        double2.fromPyobj(BP).getElementPtr(),ldb,
        <const double *>hip._util.types.Pointer.fromPyobj(beta)._ptr,
        double2.fromPyobj(CP).getElementPtr(),ldc))
    return (_hipblasZher2k_v2__retval,)


@cython.embedsignature(True)
def hipblasCher2kBatched(object handle, object uplo, object transA, int n, int k, object alpha, object AP, int lda, object BP, int ldb, object beta, object CP, int ldc, int batchCount):
    r"""BLAS Level 3 API

    @{

    her2kBatched performs a batch of the matrix-matrix operations for a Hermitian rank-2k update

    C_i := alpha*op( A_i )*op( B_i )^H + conj(alpha)*op( B_i )*op( A_i )^H + beta*C_i

    where  alpha and beta are scalars, op(A_i) and op(B_i) are n by k matrices, and
    C_i is a n x n Hermitian matrix stored as either upper or lower.

        op( A_i ) = A_i, op( B_i ) = B_i, and A_i and B_i are n by k if trans == HIPBLAS_OP_N
        op( A_i ) = A_i^H, op( B_i ) = B_i^H,  and A_i and B_i are k by n if trans == HIPBLAS_OP_C

    - Supported precisions in rocBLAS : c,z
    - Supported precisions in cuBLAS  : No support

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`) -- *IN*:
            [hipblasHandle_t]
            handle to the hipblas library context queue.

        uplo (`~.hipblasFillMode_t`) -- *IN*:
            [hipblasFillMode_t]
            HIPBLAS_FILL_MODE_UPPER:  C_i is an upper triangular matrix
            HIPBLAS_FILL_MODE_LOWER:  C_i is a  lower triangular matrix

        transA (`~.hipblasOperation_t`) -- *IN*:
            [hipblasOperation_t]
            HIPBLAS_OP_C: op(A) = A^H
            HIPBLAS_OP_N: op(A) = A

        n (`~.int`) -- *IN*:
            [int]
            n specifies the number of rows and columns of C_i. n >= 0.

        k (`~.int`) -- *IN*:
            [int]
            k specifies the number of columns of op(A). k >= 0.

        alpha (`~.hipblasComplex`/`~.object`) -- *IN*:
            alpha specifies the scalar alpha. When alpha is
            zero then A is not referenced and A need not be set before
            entry.

        AP (`~.hip._util.types.Pointer`/`~.object`) -- *IN*:
            device array of device pointers storing each matrix_i A of dimension (lda, k)
            when trans is HIPBLAS_OP_N, otherwise of dimension (lda, n)

        lda (`~.int`) -- *IN*:
            [int]
            lda specifies the first dimension of A_i.
            if trans = HIPBLAS_OP_N,  lda >= max( 1, n ),
            otherwise lda >= max( 1, k ).

        BP (`~.hip._util.types.Pointer`/`~.object`) -- *IN*:
            device array of device pointers storing each matrix_i B of dimension (ldb, k)
            when trans is HIPBLAS_OP_N, otherwise of dimension (ldb, n)

        ldb (`~.int`) -- *IN*:
            [int]
            ldb specifies the first dimension of B_i.
            if trans = HIPBLAS_OP_N,  ldb >= max( 1, n ),
            otherwise ldb >= max( 1, k ).

        beta (`~.hip._util.types.Pointer`/`~.object`) -- *IN*:
            beta specifies the scalar beta. When beta is
            zero then C need not be set before entry.

        CP (`~.hip._util.types.Pointer`/`~.object`) -- *IN*:
            device array of device pointers storing each matrix C_i on the GPU.
            The imaginary component of the diagonal elements are not used but are set to zero unless quick return.

        ldc (`~.int`) -- *IN*:
            [int]
            ldc specifies the first dimension of C. ldc >= max( 1, n ).

        batchCount (`~.int`) -- *IN*:
            [int]
            number of instances in the batch.
    """
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")                    
    if not isinstance(transA,_hipblasOperation_t__Base):
        raise TypeError("argument 'transA' must be of type '_hipblasOperation_t__Base'")
    _hipblasCher2kBatched__retval = hipblasStatus_t(chipblas.hipblasCher2kBatched(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,uplo.value,transA.value,n,k,
        hipblasComplex.fromPyobj(alpha).getElementPtr(),
        <chipblas.hipblasComplex *const*>hip._util.types.Pointer.fromPyobj(AP)._ptr,lda,
        <chipblas.hipblasComplex *const*>hip._util.types.Pointer.fromPyobj(BP)._ptr,ldb,
        <const float *>hip._util.types.Pointer.fromPyobj(beta)._ptr,
        <chipblas.hipblasComplex *const*>hip._util.types.Pointer.fromPyobj(CP)._ptr,ldc,batchCount))
    return (_hipblasCher2kBatched__retval,)


@cython.embedsignature(True)
def hipblasZher2kBatched(object handle, object uplo, object transA, int n, int k, object alpha, object AP, int lda, object BP, int ldb, object beta, object CP, int ldc, int batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        uplo (`~.hipblasFillMode_t`):
            (undocumented)

        transA (`~.hipblasOperation_t`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        k (`~.int`):
            (undocumented)

        alpha (`~.hipblasDoubleComplex`/`~.object`):
            (undocumented)

        AP (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        BP (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        ldb (`~.int`):
            (undocumented)

        beta (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        CP (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        ldc (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")                    
    if not isinstance(transA,_hipblasOperation_t__Base):
        raise TypeError("argument 'transA' must be of type '_hipblasOperation_t__Base'")
    _hipblasZher2kBatched__retval = hipblasStatus_t(chipblas.hipblasZher2kBatched(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,uplo.value,transA.value,n,k,
        hipblasDoubleComplex.fromPyobj(alpha).getElementPtr(),
        <chipblas.hipblasDoubleComplex *const*>hip._util.types.Pointer.fromPyobj(AP)._ptr,lda,
        <chipblas.hipblasDoubleComplex *const*>hip._util.types.Pointer.fromPyobj(BP)._ptr,ldb,
        <const double *>hip._util.types.Pointer.fromPyobj(beta)._ptr,
        <chipblas.hipblasDoubleComplex *const*>hip._util.types.Pointer.fromPyobj(CP)._ptr,ldc,batchCount))
    return (_hipblasZher2kBatched__retval,)


@cython.embedsignature(True)
def hipblasCher2kBatched_v2(object handle, object uplo, object transA, int n, int k, object alpha, object AP, int lda, object BP, int ldb, object beta, object CP, int ldc, int batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        uplo (`~.hipblasFillMode_t`):
            (undocumented)

        transA (`~.hipblasOperation_t`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        k (`~.int`):
            (undocumented)

        alpha (`~.float2`/`~.object`):
            (undocumented)

        AP (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        BP (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        ldb (`~.int`):
            (undocumented)

        beta (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        CP (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        ldc (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")                    
    if not isinstance(transA,_hipblasOperation_t__Base):
        raise TypeError("argument 'transA' must be of type '_hipblasOperation_t__Base'")
    _hipblasCher2kBatched_v2__retval = hipblasStatus_t(chipblas.hipblasCher2kBatched_v2(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,uplo.value,transA.value,n,k,
        float2.fromPyobj(alpha).getElementPtr(),
        <chipblas.float2 *const*>hip._util.types.Pointer.fromPyobj(AP)._ptr,lda,
        <chipblas.float2 *const*>hip._util.types.Pointer.fromPyobj(BP)._ptr,ldb,
        <const float *>hip._util.types.Pointer.fromPyobj(beta)._ptr,
        <chipblas.float2 *const*>hip._util.types.Pointer.fromPyobj(CP)._ptr,ldc,batchCount))
    return (_hipblasCher2kBatched_v2__retval,)


@cython.embedsignature(True)
def hipblasZher2kBatched_v2(object handle, object uplo, object transA, int n, int k, object alpha, object AP, int lda, object BP, int ldb, object beta, object CP, int ldc, int batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        uplo (`~.hipblasFillMode_t`):
            (undocumented)

        transA (`~.hipblasOperation_t`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        k (`~.int`):
            (undocumented)

        alpha (`~.double2`/`~.object`):
            (undocumented)

        AP (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        BP (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        ldb (`~.int`):
            (undocumented)

        beta (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        CP (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        ldc (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")                    
    if not isinstance(transA,_hipblasOperation_t__Base):
        raise TypeError("argument 'transA' must be of type '_hipblasOperation_t__Base'")
    _hipblasZher2kBatched_v2__retval = hipblasStatus_t(chipblas.hipblasZher2kBatched_v2(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,uplo.value,transA.value,n,k,
        double2.fromPyobj(alpha).getElementPtr(),
        <chipblas.double2 *const*>hip._util.types.Pointer.fromPyobj(AP)._ptr,lda,
        <chipblas.double2 *const*>hip._util.types.Pointer.fromPyobj(BP)._ptr,ldb,
        <const double *>hip._util.types.Pointer.fromPyobj(beta)._ptr,
        <chipblas.double2 *const*>hip._util.types.Pointer.fromPyobj(CP)._ptr,ldc,batchCount))
    return (_hipblasZher2kBatched_v2__retval,)


@cython.embedsignature(True)
def hipblasCher2kStridedBatched(object handle, object uplo, object transA, int n, int k, object alpha, object AP, int lda, long strideA, object BP, int ldb, long strideB, object beta, object CP, int ldc, long strideC, int batchCount):
    r"""BLAS Level 3 API

    @{

    her2kStridedBatched performs a batch of the matrix-matrix operations for a Hermitian rank-2k update

    C_i := alpha*op( A_i )*op( B_i )^H + conj(alpha)*op( B_i )*op( A_i )^H + beta*C_i

    where  alpha and beta are scalars, op(A_i) and op(B_i) are n by k matrices, and
    C_i is a n x n Hermitian matrix stored as either upper or lower.

        op( A_i ) = A_i, op( B_i ) = B_i, and A_i and B_i are n by k if trans == HIPBLAS_OP_N
        op( A_i ) = A_i^H, op( B_i ) = B_i^H,  and A_i and B_i are k by n if trans == HIPBLAS_OP_C

    - Supported precisions in rocBLAS : c,z
    - Supported precisions in cuBLAS  : No support

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`) -- *IN*:
            [hipblasHandle_t]
            handle to the hipblas library context queue.

        uplo (`~.hipblasFillMode_t`) -- *IN*:
            [hipblasFillMode_t]
            HIPBLAS_FILL_MODE_UPPER:  C_i is an upper triangular matrix
            HIPBLAS_FILL_MODE_LOWER:  C_i is a  lower triangular matrix

        transA (`~.hipblasOperation_t`) -- *IN*:
            [hipblasOperation_t]
            HIPBLAS_OP_C: op( A_i ) = A_i^H, op( B_i ) = B_i^H
            HIPBLAS_OP_N: op( A_i ) = A_i, op( B_i ) = B_i

        n (`~.int`) -- *IN*:
            [int]
            n specifies the number of rows and columns of C_i. n >= 0.

        k (`~.int`) -- *IN*:
            [int]
            k specifies the number of columns of op(A). k >= 0.

        alpha (`~.hipblasComplex`/`~.object`) -- *IN*:
            alpha specifies the scalar alpha. When alpha is
            zero then A is not referenced and A need not be set before
            entry.

        AP (`~.hipblasComplex`/`~.object`) -- *IN*:
            Device pointer to the first matrix A_1 on the GPU of dimension (lda, k)
            when trans is HIPBLAS_OP_N, otherwise of dimension (lda, n)

        lda (`~.int`) -- *IN*:
            [int]
            lda specifies the first dimension of A_i.
            if trans = HIPBLAS_OP_N,  lda >= max( 1, n ),
            otherwise lda >= max( 1, k ).

        strideA (`~.int`) -- *IN*:
            [hipblasStride]
            stride from the start of one matrix (A_i) and the next one (A_i+1)

        BP (`~.hipblasComplex`/`~.object`) -- *IN*:
            Device pointer to the first matrix B_1 on the GPU of dimension (ldb, k)
            when trans is HIPBLAS_OP_N, otherwise of dimension (ldb, n)

        ldb (`~.int`) -- *IN*:
            [int]
            ldb specifies the first dimension of B_i.
            if trans = HIPBLAS_OP_N,  ldb >= max( 1, n ),
            otherwise ldb >= max( 1, k ).

        strideB (`~.int`) -- *IN*:
            [hipblasStride]
            stride from the start of one matrix (B_i) and the next one (B_i+1)

        beta (`~.hip._util.types.Pointer`/`~.object`) -- *IN*:
            beta specifies the scalar beta. When beta is
            zero then C need not be set before entry.

        CP (`~.hipblasComplex`/`~.object`) -- *IN*:
            Device pointer to the first matrix C_1 on the GPU.
            The imaginary component of the diagonal elements are not used but are set to zero unless quick return.

        ldc (`~.int`) -- *IN*:
            [int]
            ldc specifies the first dimension of C. ldc >= max( 1, n ).

        strideC (`~.int`) -- *INOUT*:
            [hipblasStride]
            stride from the start of one matrix (C_i) and the next one (C_i+1)

        batchCount (`~.int`) -- *IN*:
            [int]
            number of instances in the batch.
    """
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")                    
    if not isinstance(transA,_hipblasOperation_t__Base):
        raise TypeError("argument 'transA' must be of type '_hipblasOperation_t__Base'")
    _hipblasCher2kStridedBatched__retval = hipblasStatus_t(chipblas.hipblasCher2kStridedBatched(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,uplo.value,transA.value,n,k,
        hipblasComplex.fromPyobj(alpha).getElementPtr(),
        hipblasComplex.fromPyobj(AP).getElementPtr(),lda,strideA,
        hipblasComplex.fromPyobj(BP).getElementPtr(),ldb,strideB,
        <const float *>hip._util.types.Pointer.fromPyobj(beta)._ptr,
        hipblasComplex.fromPyobj(CP).getElementPtr(),ldc,strideC,batchCount))
    return (_hipblasCher2kStridedBatched__retval,)


@cython.embedsignature(True)
def hipblasZher2kStridedBatched(object handle, object uplo, object transA, int n, int k, object alpha, object AP, int lda, long strideA, object BP, int ldb, long strideB, object beta, object CP, int ldc, long strideC, int batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        uplo (`~.hipblasFillMode_t`):
            (undocumented)

        transA (`~.hipblasOperation_t`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        k (`~.int`):
            (undocumented)

        alpha (`~.hipblasDoubleComplex`/`~.object`):
            (undocumented)

        AP (`~.hipblasDoubleComplex`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        strideA (`~.int`):
            (undocumented)

        BP (`~.hipblasDoubleComplex`/`~.object`):
            (undocumented)

        ldb (`~.int`):
            (undocumented)

        strideB (`~.int`):
            (undocumented)

        beta (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        CP (`~.hipblasDoubleComplex`/`~.object`):
            (undocumented)

        ldc (`~.int`):
            (undocumented)

        strideC (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")                    
    if not isinstance(transA,_hipblasOperation_t__Base):
        raise TypeError("argument 'transA' must be of type '_hipblasOperation_t__Base'")
    _hipblasZher2kStridedBatched__retval = hipblasStatus_t(chipblas.hipblasZher2kStridedBatched(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,uplo.value,transA.value,n,k,
        hipblasDoubleComplex.fromPyobj(alpha).getElementPtr(),
        hipblasDoubleComplex.fromPyobj(AP).getElementPtr(),lda,strideA,
        hipblasDoubleComplex.fromPyobj(BP).getElementPtr(),ldb,strideB,
        <const double *>hip._util.types.Pointer.fromPyobj(beta)._ptr,
        hipblasDoubleComplex.fromPyobj(CP).getElementPtr(),ldc,strideC,batchCount))
    return (_hipblasZher2kStridedBatched__retval,)


@cython.embedsignature(True)
def hipblasCher2kStridedBatched_v2(object handle, object uplo, object transA, int n, int k, object alpha, object AP, int lda, long strideA, object BP, int ldb, long strideB, object beta, object CP, int ldc, long strideC, int batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        uplo (`~.hipblasFillMode_t`):
            (undocumented)

        transA (`~.hipblasOperation_t`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        k (`~.int`):
            (undocumented)

        alpha (`~.float2`/`~.object`):
            (undocumented)

        AP (`~.float2`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        strideA (`~.int`):
            (undocumented)

        BP (`~.float2`/`~.object`):
            (undocumented)

        ldb (`~.int`):
            (undocumented)

        strideB (`~.int`):
            (undocumented)

        beta (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        CP (`~.float2`/`~.object`):
            (undocumented)

        ldc (`~.int`):
            (undocumented)

        strideC (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")                    
    if not isinstance(transA,_hipblasOperation_t__Base):
        raise TypeError("argument 'transA' must be of type '_hipblasOperation_t__Base'")
    _hipblasCher2kStridedBatched_v2__retval = hipblasStatus_t(chipblas.hipblasCher2kStridedBatched_v2(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,uplo.value,transA.value,n,k,
        float2.fromPyobj(alpha).getElementPtr(),
        float2.fromPyobj(AP).getElementPtr(),lda,strideA,
        float2.fromPyobj(BP).getElementPtr(),ldb,strideB,
        <const float *>hip._util.types.Pointer.fromPyobj(beta)._ptr,
        float2.fromPyobj(CP).getElementPtr(),ldc,strideC,batchCount))
    return (_hipblasCher2kStridedBatched_v2__retval,)


@cython.embedsignature(True)
def hipblasZher2kStridedBatched_v2(object handle, object uplo, object transA, int n, int k, object alpha, object AP, int lda, long strideA, object BP, int ldb, long strideB, object beta, object CP, int ldc, long strideC, int batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        uplo (`~.hipblasFillMode_t`):
            (undocumented)

        transA (`~.hipblasOperation_t`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        k (`~.int`):
            (undocumented)

        alpha (`~.double2`/`~.object`):
            (undocumented)

        AP (`~.double2`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        strideA (`~.int`):
            (undocumented)

        BP (`~.double2`/`~.object`):
            (undocumented)

        ldb (`~.int`):
            (undocumented)

        strideB (`~.int`):
            (undocumented)

        beta (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        CP (`~.double2`/`~.object`):
            (undocumented)

        ldc (`~.int`):
            (undocumented)

        strideC (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")                    
    if not isinstance(transA,_hipblasOperation_t__Base):
        raise TypeError("argument 'transA' must be of type '_hipblasOperation_t__Base'")
    _hipblasZher2kStridedBatched_v2__retval = hipblasStatus_t(chipblas.hipblasZher2kStridedBatched_v2(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,uplo.value,transA.value,n,k,
        double2.fromPyobj(alpha).getElementPtr(),
        double2.fromPyobj(AP).getElementPtr(),lda,strideA,
        double2.fromPyobj(BP).getElementPtr(),ldb,strideB,
        <const double *>hip._util.types.Pointer.fromPyobj(beta)._ptr,
        double2.fromPyobj(CP).getElementPtr(),ldc,strideC,batchCount))
    return (_hipblasZher2kStridedBatched_v2__retval,)


@cython.embedsignature(True)
def hipblasSsymm(object handle, object side, object uplo, int m, int n, object alpha, object AP, int lda, object BP, int ldb, object beta, object CP, int ldc):
    r"""BLAS Level 3 API

    @{

    symm performs one of the matrix-matrix operations:

    C := alpha*A*B + beta*C if side == HIPBLAS_SIDE_LEFT,
    C := alpha*B*A + beta*C if side == HIPBLAS_SIDE_RIGHT,

    where alpha and beta are scalars, B and C are m by n matrices, and
    A is a symmetric matrix stored as either upper or lower.

    - Supported precisions in rocBLAS : s,d,c,z
    - Supported precisions in cuBLAS  : s,d,c,z

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`) -- *IN*:
            [hipblasHandle_t]
            handle to the hipblas library context queue.

        side (`~.hipblasSideMode_t`) -- *IN*:
            [hipblasSideMode_t]
            HIPBLAS_SIDE_LEFT:      C := alpha*A*B + beta*C
            HIPBLAS_SIDE_RIGHT:     C := alpha*B*A + beta*C

        uplo (`~.hipblasFillMode_t`) -- *IN*:
            [hipblasFillMode_t]
            HIPBLAS_FILL_MODE_UPPER:  A is an upper triangular matrix
            HIPBLAS_FILL_MODE_LOWER:  A is a  lower triangular matrix

        m (`~.int`) -- *IN*:
            [int]
            m specifies the number of rows of B and C. m >= 0.

        n (`~.int`) -- *IN*:
            [int]
            n specifies the number of columns of B and C. n >= 0.

        alpha (`~.hip._util.types.Pointer`/`~.object`) -- *IN*:
            alpha specifies the scalar alpha. When alpha is
            zero then A and B are not referenced.

        AP (`~.hip._util.types.Pointer`/`~.object`) -- *IN*:
            pointer storing matrix A on the GPU.
            A is m by m if side == HIPBLAS_SIDE_LEFT
            A is n by n if side == HIPBLAS_SIDE_RIGHT
            only the upper/lower triangular part is accessed.

        lda (`~.int`) -- *IN*:
            [int]
            lda specifies the first dimension of A.
            if side = HIPBLAS_SIDE_LEFT,  lda >= max( 1, m ),
            otherwise lda >= max( 1, n ).

        BP (`~.hip._util.types.Pointer`/`~.object`) -- *IN*:
            pointer storing matrix B on the GPU.
            Matrix dimension is m by n

        ldb (`~.int`) -- *IN*:
            [int]
            ldb specifies the first dimension of B. ldb >= max( 1, m )

        beta (`~.hip._util.types.Pointer`/`~.object`) -- *IN*:
            beta specifies the scalar beta. When beta is
            zero then C need not be set before entry.

        CP (`~.hip._util.types.Pointer`/`~.object`) -- *IN*:
            pointer storing matrix C on the GPU.
            Matrix dimension is m by n

        ldc (`~.int`) -- *IN*:
            [int]
            ldc specifies the first dimension of C. ldc >= max( 1, m )
    """
    if not isinstance(side,_hipblasSideMode_t__Base):
        raise TypeError("argument 'side' must be of type '_hipblasSideMode_t__Base'")                    
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")
    _hipblasSsymm__retval = hipblasStatus_t(chipblas.hipblasSsymm(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,side.value,uplo.value,m,n,
        <const float *>hip._util.types.Pointer.fromPyobj(alpha)._ptr,
        <const float *>hip._util.types.Pointer.fromPyobj(AP)._ptr,lda,
        <const float *>hip._util.types.Pointer.fromPyobj(BP)._ptr,ldb,
        <const float *>hip._util.types.Pointer.fromPyobj(beta)._ptr,
        <float *>hip._util.types.Pointer.fromPyobj(CP)._ptr,ldc))
    return (_hipblasSsymm__retval,)


@cython.embedsignature(True)
def hipblasDsymm(object handle, object side, object uplo, int m, int n, object alpha, object AP, int lda, object BP, int ldb, object beta, object CP, int ldc):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        side (`~.hipblasSideMode_t`):
            (undocumented)

        uplo (`~.hipblasFillMode_t`):
            (undocumented)

        m (`~.int`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        alpha (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        AP (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        BP (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        ldb (`~.int`):
            (undocumented)

        beta (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        CP (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        ldc (`~.int`):
            (undocumented)
    """
    if not isinstance(side,_hipblasSideMode_t__Base):
        raise TypeError("argument 'side' must be of type '_hipblasSideMode_t__Base'")                    
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")
    _hipblasDsymm__retval = hipblasStatus_t(chipblas.hipblasDsymm(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,side.value,uplo.value,m,n,
        <const double *>hip._util.types.Pointer.fromPyobj(alpha)._ptr,
        <const double *>hip._util.types.Pointer.fromPyobj(AP)._ptr,lda,
        <const double *>hip._util.types.Pointer.fromPyobj(BP)._ptr,ldb,
        <const double *>hip._util.types.Pointer.fromPyobj(beta)._ptr,
        <double *>hip._util.types.Pointer.fromPyobj(CP)._ptr,ldc))
    return (_hipblasDsymm__retval,)


@cython.embedsignature(True)
def hipblasCsymm(object handle, object side, object uplo, int m, int n, object alpha, object AP, int lda, object BP, int ldb, object beta, object CP, int ldc):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        side (`~.hipblasSideMode_t`):
            (undocumented)

        uplo (`~.hipblasFillMode_t`):
            (undocumented)

        m (`~.int`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        alpha (`~.hipblasComplex`/`~.object`):
            (undocumented)

        AP (`~.hipblasComplex`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        BP (`~.hipblasComplex`/`~.object`):
            (undocumented)

        ldb (`~.int`):
            (undocumented)

        beta (`~.hipblasComplex`/`~.object`):
            (undocumented)

        CP (`~.hipblasComplex`/`~.object`):
            (undocumented)

        ldc (`~.int`):
            (undocumented)
    """
    if not isinstance(side,_hipblasSideMode_t__Base):
        raise TypeError("argument 'side' must be of type '_hipblasSideMode_t__Base'")                    
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")
    _hipblasCsymm__retval = hipblasStatus_t(chipblas.hipblasCsymm(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,side.value,uplo.value,m,n,
        hipblasComplex.fromPyobj(alpha).getElementPtr(),
        hipblasComplex.fromPyobj(AP).getElementPtr(),lda,
        hipblasComplex.fromPyobj(BP).getElementPtr(),ldb,
        hipblasComplex.fromPyobj(beta).getElementPtr(),
        hipblasComplex.fromPyobj(CP).getElementPtr(),ldc))
    return (_hipblasCsymm__retval,)


@cython.embedsignature(True)
def hipblasZsymm(object handle, object side, object uplo, int m, int n, object alpha, object AP, int lda, object BP, int ldb, object beta, object CP, int ldc):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        side (`~.hipblasSideMode_t`):
            (undocumented)

        uplo (`~.hipblasFillMode_t`):
            (undocumented)

        m (`~.int`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        alpha (`~.hipblasDoubleComplex`/`~.object`):
            (undocumented)

        AP (`~.hipblasDoubleComplex`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        BP (`~.hipblasDoubleComplex`/`~.object`):
            (undocumented)

        ldb (`~.int`):
            (undocumented)

        beta (`~.hipblasDoubleComplex`/`~.object`):
            (undocumented)

        CP (`~.hipblasDoubleComplex`/`~.object`):
            (undocumented)

        ldc (`~.int`):
            (undocumented)
    """
    if not isinstance(side,_hipblasSideMode_t__Base):
        raise TypeError("argument 'side' must be of type '_hipblasSideMode_t__Base'")                    
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")
    _hipblasZsymm__retval = hipblasStatus_t(chipblas.hipblasZsymm(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,side.value,uplo.value,m,n,
        hipblasDoubleComplex.fromPyobj(alpha).getElementPtr(),
        hipblasDoubleComplex.fromPyobj(AP).getElementPtr(),lda,
        hipblasDoubleComplex.fromPyobj(BP).getElementPtr(),ldb,
        hipblasDoubleComplex.fromPyobj(beta).getElementPtr(),
        hipblasDoubleComplex.fromPyobj(CP).getElementPtr(),ldc))
    return (_hipblasZsymm__retval,)


@cython.embedsignature(True)
def hipblasCsymm_v2(object handle, object side, object uplo, int m, int n, object alpha, object AP, int lda, object BP, int ldb, object beta, object CP, int ldc):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        side (`~.hipblasSideMode_t`):
            (undocumented)

        uplo (`~.hipblasFillMode_t`):
            (undocumented)

        m (`~.int`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        alpha (`~.float2`/`~.object`):
            (undocumented)

        AP (`~.float2`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        BP (`~.float2`/`~.object`):
            (undocumented)

        ldb (`~.int`):
            (undocumented)

        beta (`~.float2`/`~.object`):
            (undocumented)

        CP (`~.float2`/`~.object`):
            (undocumented)

        ldc (`~.int`):
            (undocumented)
    """
    if not isinstance(side,_hipblasSideMode_t__Base):
        raise TypeError("argument 'side' must be of type '_hipblasSideMode_t__Base'")                    
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")
    _hipblasCsymm_v2__retval = hipblasStatus_t(chipblas.hipblasCsymm_v2(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,side.value,uplo.value,m,n,
        float2.fromPyobj(alpha).getElementPtr(),
        float2.fromPyobj(AP).getElementPtr(),lda,
        float2.fromPyobj(BP).getElementPtr(),ldb,
        float2.fromPyobj(beta).getElementPtr(),
        float2.fromPyobj(CP).getElementPtr(),ldc))
    return (_hipblasCsymm_v2__retval,)


@cython.embedsignature(True)
def hipblasZsymm_v2(object handle, object side, object uplo, int m, int n, object alpha, object AP, int lda, object BP, int ldb, object beta, object CP, int ldc):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        side (`~.hipblasSideMode_t`):
            (undocumented)

        uplo (`~.hipblasFillMode_t`):
            (undocumented)

        m (`~.int`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        alpha (`~.double2`/`~.object`):
            (undocumented)

        AP (`~.double2`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        BP (`~.double2`/`~.object`):
            (undocumented)

        ldb (`~.int`):
            (undocumented)

        beta (`~.double2`/`~.object`):
            (undocumented)

        CP (`~.double2`/`~.object`):
            (undocumented)

        ldc (`~.int`):
            (undocumented)
    """
    if not isinstance(side,_hipblasSideMode_t__Base):
        raise TypeError("argument 'side' must be of type '_hipblasSideMode_t__Base'")                    
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")
    _hipblasZsymm_v2__retval = hipblasStatus_t(chipblas.hipblasZsymm_v2(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,side.value,uplo.value,m,n,
        double2.fromPyobj(alpha).getElementPtr(),
        double2.fromPyobj(AP).getElementPtr(),lda,
        double2.fromPyobj(BP).getElementPtr(),ldb,
        double2.fromPyobj(beta).getElementPtr(),
        double2.fromPyobj(CP).getElementPtr(),ldc))
    return (_hipblasZsymm_v2__retval,)


@cython.embedsignature(True)
def hipblasSsymmBatched(object handle, object side, object uplo, int m, int n, object alpha, object AP, int lda, object BP, int ldb, object beta, object CP, int ldc, int batchCount):
    r"""BLAS Level 3 API

    @{

    symmBatched performs a batch of the matrix-matrix operations:

    C_i := alpha*A_i*B_i + beta*C_i if side == HIPBLAS_SIDE_LEFT,
    C_i := alpha*B_i*A_i + beta*C_i if side == HIPBLAS_SIDE_RIGHT,

    where alpha and beta are scalars, B_i and C_i are m by n matrices, and
    A_i is a symmetric matrix stored as either upper or lower.

    - Supported precisions in rocBLAS : s,d,c,z
    - Supported precisions in cuBLAS  : No support

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`) -- *IN*:
            [hipblasHandle_t]
            handle to the hipblas library context queue.

        side (`~.hipblasSideMode_t`) -- *IN*:
            [hipblasSideMode_t]
            HIPBLAS_SIDE_LEFT:      C_i := alpha*A_i*B_i + beta*C_i
            HIPBLAS_SIDE_RIGHT:     C_i := alpha*B_i*A_i + beta*C_i

        uplo (`~.hipblasFillMode_t`) -- *IN*:
            [hipblasFillMode_t]
            HIPBLAS_FILL_MODE_UPPER:  A_i is an upper triangular matrix
            HIPBLAS_FILL_MODE_LOWER:  A_i is a  lower triangular matrix

        m (`~.int`) -- *IN*:
            [int]
            m specifies the number of rows of B_i and C_i. m >= 0.

        n (`~.int`) -- *IN*:
            [int]
            n specifies the number of columns of B_i and C_i. n >= 0.

        alpha (`~.hip._util.types.Pointer`/`~.object`) -- *IN*:
            alpha specifies the scalar alpha. When alpha is
            zero then A_i and B_i are not referenced.

        AP (`~.hip._util.types.Pointer`/`~.object`) -- *IN*:
            device array of device pointers storing each matrix A_i on the GPU.
            A_i is m by m if side == HIPBLAS_SIDE_LEFT
            A_i is n by n if side == HIPBLAS_SIDE_RIGHT
            only the upper/lower triangular part is accessed.

        lda (`~.int`) -- *IN*:
            [int]
            lda specifies the first dimension of A_i.
            if side = HIPBLAS_SIDE_LEFT,  lda >= max( 1, m ),
            otherwise lda >= max( 1, n ).

        BP (`~.hip._util.types.Pointer`/`~.object`) -- *IN*:
            device array of device pointers storing each matrix B_i on the GPU.
            Matrix dimension is m by n

        ldb (`~.int`) -- *IN*:
            [int]
            ldb specifies the first dimension of B_i. ldb >= max( 1, m )

        beta (`~.hip._util.types.Pointer`/`~.object`) -- *IN*:
            beta specifies the scalar beta. When beta is
            zero then C_i need not be set before entry.

        CP (`~.hip._util.types.Pointer`/`~.object`) -- *IN*:
            device array of device pointers storing each matrix C_i on the GPU.
            Matrix dimension is m by n

        ldc (`~.int`) -- *IN*:
            [int]
            ldc specifies the first dimension of C_i. ldc >= max( 1, m )

        batchCount (`~.int`) -- *IN*:
            [int]
            number of instances in the batch.
    """
    if not isinstance(side,_hipblasSideMode_t__Base):
        raise TypeError("argument 'side' must be of type '_hipblasSideMode_t__Base'")                    
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")
    _hipblasSsymmBatched__retval = hipblasStatus_t(chipblas.hipblasSsymmBatched(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,side.value,uplo.value,m,n,
        <const float *>hip._util.types.Pointer.fromPyobj(alpha)._ptr,
        <const float *const*>hip._util.types.Pointer.fromPyobj(AP)._ptr,lda,
        <const float *const*>hip._util.types.Pointer.fromPyobj(BP)._ptr,ldb,
        <const float *>hip._util.types.Pointer.fromPyobj(beta)._ptr,
        <float *const*>hip._util.types.Pointer.fromPyobj(CP)._ptr,ldc,batchCount))
    return (_hipblasSsymmBatched__retval,)


@cython.embedsignature(True)
def hipblasDsymmBatched(object handle, object side, object uplo, int m, int n, object alpha, object AP, int lda, object BP, int ldb, object beta, object CP, int ldc, int batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        side (`~.hipblasSideMode_t`):
            (undocumented)

        uplo (`~.hipblasFillMode_t`):
            (undocumented)

        m (`~.int`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        alpha (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        AP (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        BP (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        ldb (`~.int`):
            (undocumented)

        beta (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        CP (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        ldc (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    if not isinstance(side,_hipblasSideMode_t__Base):
        raise TypeError("argument 'side' must be of type '_hipblasSideMode_t__Base'")                    
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")
    _hipblasDsymmBatched__retval = hipblasStatus_t(chipblas.hipblasDsymmBatched(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,side.value,uplo.value,m,n,
        <const double *>hip._util.types.Pointer.fromPyobj(alpha)._ptr,
        <const double *const*>hip._util.types.Pointer.fromPyobj(AP)._ptr,lda,
        <const double *const*>hip._util.types.Pointer.fromPyobj(BP)._ptr,ldb,
        <const double *>hip._util.types.Pointer.fromPyobj(beta)._ptr,
        <double *const*>hip._util.types.Pointer.fromPyobj(CP)._ptr,ldc,batchCount))
    return (_hipblasDsymmBatched__retval,)


@cython.embedsignature(True)
def hipblasCsymmBatched(object handle, object side, object uplo, int m, int n, object alpha, object AP, int lda, object BP, int ldb, object beta, object CP, int ldc, int batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        side (`~.hipblasSideMode_t`):
            (undocumented)

        uplo (`~.hipblasFillMode_t`):
            (undocumented)

        m (`~.int`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        alpha (`~.hipblasComplex`/`~.object`):
            (undocumented)

        AP (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        BP (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        ldb (`~.int`):
            (undocumented)

        beta (`~.hipblasComplex`/`~.object`):
            (undocumented)

        CP (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        ldc (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    if not isinstance(side,_hipblasSideMode_t__Base):
        raise TypeError("argument 'side' must be of type '_hipblasSideMode_t__Base'")                    
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")
    _hipblasCsymmBatched__retval = hipblasStatus_t(chipblas.hipblasCsymmBatched(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,side.value,uplo.value,m,n,
        hipblasComplex.fromPyobj(alpha).getElementPtr(),
        <chipblas.hipblasComplex *const*>hip._util.types.Pointer.fromPyobj(AP)._ptr,lda,
        <chipblas.hipblasComplex *const*>hip._util.types.Pointer.fromPyobj(BP)._ptr,ldb,
        hipblasComplex.fromPyobj(beta).getElementPtr(),
        <chipblas.hipblasComplex *const*>hip._util.types.Pointer.fromPyobj(CP)._ptr,ldc,batchCount))
    return (_hipblasCsymmBatched__retval,)


@cython.embedsignature(True)
def hipblasZsymmBatched(object handle, object side, object uplo, int m, int n, object alpha, object AP, int lda, object BP, int ldb, object beta, object CP, int ldc, int batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        side (`~.hipblasSideMode_t`):
            (undocumented)

        uplo (`~.hipblasFillMode_t`):
            (undocumented)

        m (`~.int`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        alpha (`~.hipblasDoubleComplex`/`~.object`):
            (undocumented)

        AP (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        BP (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        ldb (`~.int`):
            (undocumented)

        beta (`~.hipblasDoubleComplex`/`~.object`):
            (undocumented)

        CP (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        ldc (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    if not isinstance(side,_hipblasSideMode_t__Base):
        raise TypeError("argument 'side' must be of type '_hipblasSideMode_t__Base'")                    
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")
    _hipblasZsymmBatched__retval = hipblasStatus_t(chipblas.hipblasZsymmBatched(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,side.value,uplo.value,m,n,
        hipblasDoubleComplex.fromPyobj(alpha).getElementPtr(),
        <chipblas.hipblasDoubleComplex *const*>hip._util.types.Pointer.fromPyobj(AP)._ptr,lda,
        <chipblas.hipblasDoubleComplex *const*>hip._util.types.Pointer.fromPyobj(BP)._ptr,ldb,
        hipblasDoubleComplex.fromPyobj(beta).getElementPtr(),
        <chipblas.hipblasDoubleComplex *const*>hip._util.types.Pointer.fromPyobj(CP)._ptr,ldc,batchCount))
    return (_hipblasZsymmBatched__retval,)


@cython.embedsignature(True)
def hipblasCsymmBatched_v2(object handle, object side, object uplo, int m, int n, object alpha, object AP, int lda, object BP, int ldb, object beta, object CP, int ldc, int batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        side (`~.hipblasSideMode_t`):
            (undocumented)

        uplo (`~.hipblasFillMode_t`):
            (undocumented)

        m (`~.int`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        alpha (`~.float2`/`~.object`):
            (undocumented)

        AP (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        BP (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        ldb (`~.int`):
            (undocumented)

        beta (`~.float2`/`~.object`):
            (undocumented)

        CP (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        ldc (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    if not isinstance(side,_hipblasSideMode_t__Base):
        raise TypeError("argument 'side' must be of type '_hipblasSideMode_t__Base'")                    
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")
    _hipblasCsymmBatched_v2__retval = hipblasStatus_t(chipblas.hipblasCsymmBatched_v2(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,side.value,uplo.value,m,n,
        float2.fromPyobj(alpha).getElementPtr(),
        <chipblas.float2 *const*>hip._util.types.Pointer.fromPyobj(AP)._ptr,lda,
        <chipblas.float2 *const*>hip._util.types.Pointer.fromPyobj(BP)._ptr,ldb,
        float2.fromPyobj(beta).getElementPtr(),
        <chipblas.float2 *const*>hip._util.types.Pointer.fromPyobj(CP)._ptr,ldc,batchCount))
    return (_hipblasCsymmBatched_v2__retval,)


@cython.embedsignature(True)
def hipblasZsymmBatched_v2(object handle, object side, object uplo, int m, int n, object alpha, object AP, int lda, object BP, int ldb, object beta, object CP, int ldc, int batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        side (`~.hipblasSideMode_t`):
            (undocumented)

        uplo (`~.hipblasFillMode_t`):
            (undocumented)

        m (`~.int`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        alpha (`~.double2`/`~.object`):
            (undocumented)

        AP (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        BP (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        ldb (`~.int`):
            (undocumented)

        beta (`~.double2`/`~.object`):
            (undocumented)

        CP (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        ldc (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    if not isinstance(side,_hipblasSideMode_t__Base):
        raise TypeError("argument 'side' must be of type '_hipblasSideMode_t__Base'")                    
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")
    _hipblasZsymmBatched_v2__retval = hipblasStatus_t(chipblas.hipblasZsymmBatched_v2(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,side.value,uplo.value,m,n,
        double2.fromPyobj(alpha).getElementPtr(),
        <chipblas.double2 *const*>hip._util.types.Pointer.fromPyobj(AP)._ptr,lda,
        <chipblas.double2 *const*>hip._util.types.Pointer.fromPyobj(BP)._ptr,ldb,
        double2.fromPyobj(beta).getElementPtr(),
        <chipblas.double2 *const*>hip._util.types.Pointer.fromPyobj(CP)._ptr,ldc,batchCount))
    return (_hipblasZsymmBatched_v2__retval,)


@cython.embedsignature(True)
def hipblasSsymmStridedBatched(object handle, object side, object uplo, int m, int n, object alpha, object AP, int lda, long strideA, object BP, int ldb, long strideB, object beta, object CP, int ldc, long strideC, int batchCount):
    r"""BLAS Level 3 API

    @{

    symmStridedBatched performs a batch of the matrix-matrix operations:

    C_i := alpha*A_i*B_i + beta*C_i if side == HIPBLAS_SIDE_LEFT,
    C_i := alpha*B_i*A_i + beta*C_i if side == HIPBLAS_SIDE_RIGHT,

    where alpha and beta are scalars, B_i and C_i are m by n matrices, and
    A_i is a symmetric matrix stored as either upper or lower.

    - Supported precisions in rocBLAS : s,d,c,z
    - Supported precisions in cuBLAS  : No support

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`) -- *IN*:
            [hipblasHandle_t]
            handle to the hipblas library context queue.

        side (`~.hipblasSideMode_t`) -- *IN*:
            [hipblasSideMode_t]
            HIPBLAS_SIDE_LEFT:      C_i := alpha*A_i*B_i + beta*C_i
            HIPBLAS_SIDE_RIGHT:     C_i := alpha*B_i*A_i + beta*C_i

        uplo (`~.hipblasFillMode_t`) -- *IN*:
            [hipblasFillMode_t]
            HIPBLAS_FILL_MODE_UPPER:  A_i is an upper triangular matrix
            HIPBLAS_FILL_MODE_LOWER:  A_i is a  lower triangular matrix

        m (`~.int`) -- *IN*:
            [int]
            m specifies the number of rows of B_i and C_i. m >= 0.

        n (`~.int`) -- *IN*:
            [int]
            n specifies the number of columns of B_i and C_i. n >= 0.

        alpha (`~.hip._util.types.Pointer`/`~.object`) -- *IN*:
            alpha specifies the scalar alpha. When alpha is
            zero then A_i and B_i are not referenced.

        AP (`~.hip._util.types.Pointer`/`~.object`) -- *IN*:
            device pointer to first matrix A_1
            A_i is m by m if side == HIPBLAS_SIDE_LEFT
            A_i is n by n if side == HIPBLAS_SIDE_RIGHT
            only the upper/lower triangular part is accessed.

        lda (`~.int`) -- *IN*:
            [int]
            lda specifies the first dimension of A_i.
            if side = HIPBLAS_SIDE_LEFT,  lda >= max( 1, m ),
            otherwise lda >= max( 1, n ).

        strideA (`~.int`) -- *IN*:
            [hipblasStride]
            stride from the start of one matrix (A_i) and the next one (A_i+1)

        BP (`~.hip._util.types.Pointer`/`~.object`) -- *IN*:
            device pointer to first matrix B_1 of dimension (ldb, n) on the GPU.

        ldb (`~.int`) -- *IN*:
            [int]
            ldb specifies the first dimension of B_i. ldb >= max( 1, m )

        strideB (`~.int`) -- *IN*:
            [hipblasStride]
            stride from the start of one matrix (B_i) and the next one (B_i+1)

        beta (`~.hip._util.types.Pointer`/`~.object`) -- *IN*:
            beta specifies the scalar beta. When beta is
            zero then C need not be set before entry.

        CP (`~.hip._util.types.Pointer`/`~.object`) -- *IN*:
            device pointer to first matrix C_1 of dimension (ldc, n) on the GPU.

        ldc (`~.int`) -- *IN*:
            [int]
            ldc specifies the first dimension of C. ldc >= max( 1, m ).

        strideC (`~.int`) -- *INOUT*:
            [hipblasStride]
            stride from the start of one matrix (C_i) and the next one (C_i+1)

        batchCount (`~.int`) -- *IN*:
            [int]
            number of instances in the batch.
    """
    if not isinstance(side,_hipblasSideMode_t__Base):
        raise TypeError("argument 'side' must be of type '_hipblasSideMode_t__Base'")                    
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")
    _hipblasSsymmStridedBatched__retval = hipblasStatus_t(chipblas.hipblasSsymmStridedBatched(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,side.value,uplo.value,m,n,
        <const float *>hip._util.types.Pointer.fromPyobj(alpha)._ptr,
        <const float *>hip._util.types.Pointer.fromPyobj(AP)._ptr,lda,strideA,
        <const float *>hip._util.types.Pointer.fromPyobj(BP)._ptr,ldb,strideB,
        <const float *>hip._util.types.Pointer.fromPyobj(beta)._ptr,
        <float *>hip._util.types.Pointer.fromPyobj(CP)._ptr,ldc,strideC,batchCount))
    return (_hipblasSsymmStridedBatched__retval,)


@cython.embedsignature(True)
def hipblasDsymmStridedBatched(object handle, object side, object uplo, int m, int n, object alpha, object AP, int lda, long strideA, object BP, int ldb, long strideB, object beta, object CP, int ldc, long strideC, int batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        side (`~.hipblasSideMode_t`):
            (undocumented)

        uplo (`~.hipblasFillMode_t`):
            (undocumented)

        m (`~.int`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        alpha (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        AP (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        strideA (`~.int`):
            (undocumented)

        BP (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        ldb (`~.int`):
            (undocumented)

        strideB (`~.int`):
            (undocumented)

        beta (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        CP (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        ldc (`~.int`):
            (undocumented)

        strideC (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    if not isinstance(side,_hipblasSideMode_t__Base):
        raise TypeError("argument 'side' must be of type '_hipblasSideMode_t__Base'")                    
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")
    _hipblasDsymmStridedBatched__retval = hipblasStatus_t(chipblas.hipblasDsymmStridedBatched(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,side.value,uplo.value,m,n,
        <const double *>hip._util.types.Pointer.fromPyobj(alpha)._ptr,
        <const double *>hip._util.types.Pointer.fromPyobj(AP)._ptr,lda,strideA,
        <const double *>hip._util.types.Pointer.fromPyobj(BP)._ptr,ldb,strideB,
        <const double *>hip._util.types.Pointer.fromPyobj(beta)._ptr,
        <double *>hip._util.types.Pointer.fromPyobj(CP)._ptr,ldc,strideC,batchCount))
    return (_hipblasDsymmStridedBatched__retval,)


@cython.embedsignature(True)
def hipblasCsymmStridedBatched(object handle, object side, object uplo, int m, int n, object alpha, object AP, int lda, long strideA, object BP, int ldb, long strideB, object beta, object CP, int ldc, long strideC, int batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        side (`~.hipblasSideMode_t`):
            (undocumented)

        uplo (`~.hipblasFillMode_t`):
            (undocumented)

        m (`~.int`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        alpha (`~.hipblasComplex`/`~.object`):
            (undocumented)

        AP (`~.hipblasComplex`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        strideA (`~.int`):
            (undocumented)

        BP (`~.hipblasComplex`/`~.object`):
            (undocumented)

        ldb (`~.int`):
            (undocumented)

        strideB (`~.int`):
            (undocumented)

        beta (`~.hipblasComplex`/`~.object`):
            (undocumented)

        CP (`~.hipblasComplex`/`~.object`):
            (undocumented)

        ldc (`~.int`):
            (undocumented)

        strideC (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    if not isinstance(side,_hipblasSideMode_t__Base):
        raise TypeError("argument 'side' must be of type '_hipblasSideMode_t__Base'")                    
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")
    _hipblasCsymmStridedBatched__retval = hipblasStatus_t(chipblas.hipblasCsymmStridedBatched(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,side.value,uplo.value,m,n,
        hipblasComplex.fromPyobj(alpha).getElementPtr(),
        hipblasComplex.fromPyobj(AP).getElementPtr(),lda,strideA,
        hipblasComplex.fromPyobj(BP).getElementPtr(),ldb,strideB,
        hipblasComplex.fromPyobj(beta).getElementPtr(),
        hipblasComplex.fromPyobj(CP).getElementPtr(),ldc,strideC,batchCount))
    return (_hipblasCsymmStridedBatched__retval,)


@cython.embedsignature(True)
def hipblasZsymmStridedBatched(object handle, object side, object uplo, int m, int n, object alpha, object AP, int lda, long strideA, object BP, int ldb, long strideB, object beta, object CP, int ldc, long strideC, int batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        side (`~.hipblasSideMode_t`):
            (undocumented)

        uplo (`~.hipblasFillMode_t`):
            (undocumented)

        m (`~.int`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        alpha (`~.hipblasDoubleComplex`/`~.object`):
            (undocumented)

        AP (`~.hipblasDoubleComplex`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        strideA (`~.int`):
            (undocumented)

        BP (`~.hipblasDoubleComplex`/`~.object`):
            (undocumented)

        ldb (`~.int`):
            (undocumented)

        strideB (`~.int`):
            (undocumented)

        beta (`~.hipblasDoubleComplex`/`~.object`):
            (undocumented)

        CP (`~.hipblasDoubleComplex`/`~.object`):
            (undocumented)

        ldc (`~.int`):
            (undocumented)

        strideC (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    if not isinstance(side,_hipblasSideMode_t__Base):
        raise TypeError("argument 'side' must be of type '_hipblasSideMode_t__Base'")                    
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")
    _hipblasZsymmStridedBatched__retval = hipblasStatus_t(chipblas.hipblasZsymmStridedBatched(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,side.value,uplo.value,m,n,
        hipblasDoubleComplex.fromPyobj(alpha).getElementPtr(),
        hipblasDoubleComplex.fromPyobj(AP).getElementPtr(),lda,strideA,
        hipblasDoubleComplex.fromPyobj(BP).getElementPtr(),ldb,strideB,
        hipblasDoubleComplex.fromPyobj(beta).getElementPtr(),
        hipblasDoubleComplex.fromPyobj(CP).getElementPtr(),ldc,strideC,batchCount))
    return (_hipblasZsymmStridedBatched__retval,)


@cython.embedsignature(True)
def hipblasCsymmStridedBatched_v2(object handle, object side, object uplo, int m, int n, object alpha, object AP, int lda, long strideA, object BP, int ldb, long strideB, object beta, object CP, int ldc, long strideC, int batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        side (`~.hipblasSideMode_t`):
            (undocumented)

        uplo (`~.hipblasFillMode_t`):
            (undocumented)

        m (`~.int`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        alpha (`~.float2`/`~.object`):
            (undocumented)

        AP (`~.float2`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        strideA (`~.int`):
            (undocumented)

        BP (`~.float2`/`~.object`):
            (undocumented)

        ldb (`~.int`):
            (undocumented)

        strideB (`~.int`):
            (undocumented)

        beta (`~.float2`/`~.object`):
            (undocumented)

        CP (`~.float2`/`~.object`):
            (undocumented)

        ldc (`~.int`):
            (undocumented)

        strideC (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    if not isinstance(side,_hipblasSideMode_t__Base):
        raise TypeError("argument 'side' must be of type '_hipblasSideMode_t__Base'")                    
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")
    _hipblasCsymmStridedBatched_v2__retval = hipblasStatus_t(chipblas.hipblasCsymmStridedBatched_v2(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,side.value,uplo.value,m,n,
        float2.fromPyobj(alpha).getElementPtr(),
        float2.fromPyobj(AP).getElementPtr(),lda,strideA,
        float2.fromPyobj(BP).getElementPtr(),ldb,strideB,
        float2.fromPyobj(beta).getElementPtr(),
        float2.fromPyobj(CP).getElementPtr(),ldc,strideC,batchCount))
    return (_hipblasCsymmStridedBatched_v2__retval,)


@cython.embedsignature(True)
def hipblasZsymmStridedBatched_v2(object handle, object side, object uplo, int m, int n, object alpha, object AP, int lda, long strideA, object BP, int ldb, long strideB, object beta, object CP, int ldc, long strideC, int batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        side (`~.hipblasSideMode_t`):
            (undocumented)

        uplo (`~.hipblasFillMode_t`):
            (undocumented)

        m (`~.int`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        alpha (`~.double2`/`~.object`):
            (undocumented)

        AP (`~.double2`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        strideA (`~.int`):
            (undocumented)

        BP (`~.double2`/`~.object`):
            (undocumented)

        ldb (`~.int`):
            (undocumented)

        strideB (`~.int`):
            (undocumented)

        beta (`~.double2`/`~.object`):
            (undocumented)

        CP (`~.double2`/`~.object`):
            (undocumented)

        ldc (`~.int`):
            (undocumented)

        strideC (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    if not isinstance(side,_hipblasSideMode_t__Base):
        raise TypeError("argument 'side' must be of type '_hipblasSideMode_t__Base'")                    
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")
    _hipblasZsymmStridedBatched_v2__retval = hipblasStatus_t(chipblas.hipblasZsymmStridedBatched_v2(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,side.value,uplo.value,m,n,
        double2.fromPyobj(alpha).getElementPtr(),
        double2.fromPyobj(AP).getElementPtr(),lda,strideA,
        double2.fromPyobj(BP).getElementPtr(),ldb,strideB,
        double2.fromPyobj(beta).getElementPtr(),
        double2.fromPyobj(CP).getElementPtr(),ldc,strideC,batchCount))
    return (_hipblasZsymmStridedBatched_v2__retval,)


@cython.embedsignature(True)
def hipblasSsyrk(object handle, object uplo, object transA, int n, int k, object alpha, object AP, int lda, object beta, object CP, int ldc):
    r"""BLAS Level 3 API

    @{

    syrk performs one of the matrix-matrix operations for a symmetric rank-k update

    C := alpha*op( A )*op( A )^T + beta*C

    where  alpha and beta are scalars, op(A) is an n by k matrix, and
    C is a symmetric n x n matrix stored as either upper or lower.

        op( A ) = A, and A is n by k if transA == HIPBLAS_OP_N
        op( A ) = A^T and A is k by n if transA == HIPBLAS_OP_T

    - Supported precisions in rocBLAS : s,d,c,z
    - Supported precisions in cuBLAS  : s,d,c,z

    HIPBLAS_OP_C is not supported for complex types, see cherk
    and zherk.

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`) -- *IN*:
            [hipblasHandle_t]
            handle to the hipblas library context queue.

        uplo (`~.hipblasFillMode_t`) -- *IN*:
            [hipblasFillMode_t]
            HIPBLAS_FILL_MODE_UPPER:  C is an upper triangular matrix
            HIPBLAS_FILL_MODE_LOWER:  C is a  lower triangular matrix

        transA (`~.hipblasOperation_t`) -- *IN*:
            [hipblasOperation_t]
            HIPBLAS_OP_T: op(A) = A^T
            HIPBLAS_OP_N: op(A) = A
            HIPBLAS_OP_C: op(A) = A^T

        n (`~.int`) -- *IN*:
            [int]
            n specifies the number of rows and columns of C. n >= 0.

        k (`~.int`) -- *IN*:
            [int]
            k specifies the number of columns of op(A). k >= 0.

        alpha (`~.hip._util.types.Pointer`/`~.object`) -- *IN*:
            alpha specifies the scalar alpha. When alpha is
            zero then A is not referenced and A need not be set before
            entry.

        AP (`~.hip._util.types.Pointer`/`~.object`) -- *IN*:
            pointer storing matrix A on the GPU.
            Martrix dimension is ( lda, k ) when if transA = HIPBLAS_OP_N, otherwise (lda, n)
            only the upper/lower triangular part is accessed.

        lda (`~.int`) -- *IN*:
            [int]
            lda specifies the first dimension of A.
            if transA = HIPBLAS_OP_N,  lda >= max( 1, n ),
            otherwise lda >= max( 1, k ).

        beta (`~.hip._util.types.Pointer`/`~.object`) -- *IN*:
            beta specifies the scalar beta. When beta is
            zero then C need not be set before entry.

        CP (`~.hip._util.types.Pointer`/`~.object`) -- *IN*:
            pointer storing matrix C on the GPU.

        ldc (`~.int`) -- *IN*:
            [int]
            ldc specifies the first dimension of C. ldc >= max( 1, n ).
    """
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")                    
    if not isinstance(transA,_hipblasOperation_t__Base):
        raise TypeError("argument 'transA' must be of type '_hipblasOperation_t__Base'")
    _hipblasSsyrk__retval = hipblasStatus_t(chipblas.hipblasSsyrk(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,uplo.value,transA.value,n,k,
        <const float *>hip._util.types.Pointer.fromPyobj(alpha)._ptr,
        <const float *>hip._util.types.Pointer.fromPyobj(AP)._ptr,lda,
        <const float *>hip._util.types.Pointer.fromPyobj(beta)._ptr,
        <float *>hip._util.types.Pointer.fromPyobj(CP)._ptr,ldc))
    return (_hipblasSsyrk__retval,)


@cython.embedsignature(True)
def hipblasDsyrk(object handle, object uplo, object transA, int n, int k, object alpha, object AP, int lda, object beta, object CP, int ldc):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        uplo (`~.hipblasFillMode_t`):
            (undocumented)

        transA (`~.hipblasOperation_t`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        k (`~.int`):
            (undocumented)

        alpha (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        AP (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        beta (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        CP (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        ldc (`~.int`):
            (undocumented)
    """
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")                    
    if not isinstance(transA,_hipblasOperation_t__Base):
        raise TypeError("argument 'transA' must be of type '_hipblasOperation_t__Base'")
    _hipblasDsyrk__retval = hipblasStatus_t(chipblas.hipblasDsyrk(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,uplo.value,transA.value,n,k,
        <const double *>hip._util.types.Pointer.fromPyobj(alpha)._ptr,
        <const double *>hip._util.types.Pointer.fromPyobj(AP)._ptr,lda,
        <const double *>hip._util.types.Pointer.fromPyobj(beta)._ptr,
        <double *>hip._util.types.Pointer.fromPyobj(CP)._ptr,ldc))
    return (_hipblasDsyrk__retval,)


@cython.embedsignature(True)
def hipblasCsyrk(object handle, object uplo, object transA, int n, int k, object alpha, object AP, int lda, object beta, object CP, int ldc):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        uplo (`~.hipblasFillMode_t`):
            (undocumented)

        transA (`~.hipblasOperation_t`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        k (`~.int`):
            (undocumented)

        alpha (`~.hipblasComplex`/`~.object`):
            (undocumented)

        AP (`~.hipblasComplex`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        beta (`~.hipblasComplex`/`~.object`):
            (undocumented)

        CP (`~.hipblasComplex`/`~.object`):
            (undocumented)

        ldc (`~.int`):
            (undocumented)
    """
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")                    
    if not isinstance(transA,_hipblasOperation_t__Base):
        raise TypeError("argument 'transA' must be of type '_hipblasOperation_t__Base'")
    _hipblasCsyrk__retval = hipblasStatus_t(chipblas.hipblasCsyrk(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,uplo.value,transA.value,n,k,
        hipblasComplex.fromPyobj(alpha).getElementPtr(),
        hipblasComplex.fromPyobj(AP).getElementPtr(),lda,
        hipblasComplex.fromPyobj(beta).getElementPtr(),
        hipblasComplex.fromPyobj(CP).getElementPtr(),ldc))
    return (_hipblasCsyrk__retval,)


@cython.embedsignature(True)
def hipblasZsyrk(object handle, object uplo, object transA, int n, int k, object alpha, object AP, int lda, object beta, object CP, int ldc):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        uplo (`~.hipblasFillMode_t`):
            (undocumented)

        transA (`~.hipblasOperation_t`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        k (`~.int`):
            (undocumented)

        alpha (`~.hipblasDoubleComplex`/`~.object`):
            (undocumented)

        AP (`~.hipblasDoubleComplex`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        beta (`~.hipblasDoubleComplex`/`~.object`):
            (undocumented)

        CP (`~.hipblasDoubleComplex`/`~.object`):
            (undocumented)

        ldc (`~.int`):
            (undocumented)
    """
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")                    
    if not isinstance(transA,_hipblasOperation_t__Base):
        raise TypeError("argument 'transA' must be of type '_hipblasOperation_t__Base'")
    _hipblasZsyrk__retval = hipblasStatus_t(chipblas.hipblasZsyrk(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,uplo.value,transA.value,n,k,
        hipblasDoubleComplex.fromPyobj(alpha).getElementPtr(),
        hipblasDoubleComplex.fromPyobj(AP).getElementPtr(),lda,
        hipblasDoubleComplex.fromPyobj(beta).getElementPtr(),
        hipblasDoubleComplex.fromPyobj(CP).getElementPtr(),ldc))
    return (_hipblasZsyrk__retval,)


@cython.embedsignature(True)
def hipblasCsyrk_v2(object handle, object uplo, object transA, int n, int k, object alpha, object AP, int lda, object beta, object CP, int ldc):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        uplo (`~.hipblasFillMode_t`):
            (undocumented)

        transA (`~.hipblasOperation_t`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        k (`~.int`):
            (undocumented)

        alpha (`~.float2`/`~.object`):
            (undocumented)

        AP (`~.float2`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        beta (`~.float2`/`~.object`):
            (undocumented)

        CP (`~.float2`/`~.object`):
            (undocumented)

        ldc (`~.int`):
            (undocumented)
    """
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")                    
    if not isinstance(transA,_hipblasOperation_t__Base):
        raise TypeError("argument 'transA' must be of type '_hipblasOperation_t__Base'")
    _hipblasCsyrk_v2__retval = hipblasStatus_t(chipblas.hipblasCsyrk_v2(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,uplo.value,transA.value,n,k,
        float2.fromPyobj(alpha).getElementPtr(),
        float2.fromPyobj(AP).getElementPtr(),lda,
        float2.fromPyobj(beta).getElementPtr(),
        float2.fromPyobj(CP).getElementPtr(),ldc))
    return (_hipblasCsyrk_v2__retval,)


@cython.embedsignature(True)
def hipblasZsyrk_v2(object handle, object uplo, object transA, int n, int k, object alpha, object AP, int lda, object beta, object CP, int ldc):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        uplo (`~.hipblasFillMode_t`):
            (undocumented)

        transA (`~.hipblasOperation_t`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        k (`~.int`):
            (undocumented)

        alpha (`~.double2`/`~.object`):
            (undocumented)

        AP (`~.double2`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        beta (`~.double2`/`~.object`):
            (undocumented)

        CP (`~.double2`/`~.object`):
            (undocumented)

        ldc (`~.int`):
            (undocumented)
    """
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")                    
    if not isinstance(transA,_hipblasOperation_t__Base):
        raise TypeError("argument 'transA' must be of type '_hipblasOperation_t__Base'")
    _hipblasZsyrk_v2__retval = hipblasStatus_t(chipblas.hipblasZsyrk_v2(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,uplo.value,transA.value,n,k,
        double2.fromPyobj(alpha).getElementPtr(),
        double2.fromPyobj(AP).getElementPtr(),lda,
        double2.fromPyobj(beta).getElementPtr(),
        double2.fromPyobj(CP).getElementPtr(),ldc))
    return (_hipblasZsyrk_v2__retval,)


@cython.embedsignature(True)
def hipblasSsyrkBatched(object handle, object uplo, object transA, int n, int k, object alpha, object AP, int lda, object beta, object CP, int ldc, int batchCount):
    r"""BLAS Level 3 API

    @{

    syrkBatched performs a batch of the matrix-matrix operations for a symmetric rank-k update

    C_i := alpha*op( A_i )*op( A_i )^T + beta*C_i

    where  alpha and beta are scalars, op(A_i) is an n by k matrix, and
    C_i is a symmetric n x n matrix stored as either upper or lower.

        op( A_i ) = A_i, and A_i is n by k if transA == HIPBLAS_OP_N
        op( A_i ) = A_i^T and A_i is k by n if transA == HIPBLAS_OP_T

    - Supported precisions in rocBLAS : s,d,c,z
    - Supported precisions in cuBLAS  : No support

    HIPBLAS_OP_C is not supported for complex types, see cherk
    and zherk.

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`) -- *IN*:
            [hipblasHandle_t]
            handle to the hipblas library context queue.

        uplo (`~.hipblasFillMode_t`) -- *IN*:
            [hipblasFillMode_t]
            HIPBLAS_FILL_MODE_UPPER:  C_i is an upper triangular matrix
            HIPBLAS_FILL_MODE_LOWER:  C_i is a  lower triangular matrix

        transA (`~.hipblasOperation_t`) -- *IN*:
            [hipblasOperation_t]
            HIPBLAS_OP_T: op(A) = A^T
            HIPBLAS_OP_N: op(A) = A
            HIPBLAS_OP_C: op(A) = A^T

        n (`~.int`) -- *IN*:
            [int]
            n specifies the number of rows and columns of C_i. n >= 0.

        k (`~.int`) -- *IN*:
            [int]
            k specifies the number of columns of op(A). k >= 0.

        alpha (`~.hip._util.types.Pointer`/`~.object`) -- *IN*:
            alpha specifies the scalar alpha. When alpha is
            zero then A is not referenced and A need not be set before
            entry.

        AP (`~.hip._util.types.Pointer`/`~.object`) -- *IN*:
            device array of device pointers storing each matrix_i A of dimension (lda, k)
            when transA is HIPBLAS_OP_N, otherwise of dimension (lda, n)

        lda (`~.int`) -- *IN*:
            [int]
            lda specifies the first dimension of A_i.
            if transA = HIPBLAS_OP_N,  lda >= max( 1, n ),
            otherwise lda >= max( 1, k ).

        beta (`~.hip._util.types.Pointer`/`~.object`) -- *IN*:
            beta specifies the scalar beta. When beta is
            zero then C need not be set before entry.

        CP (`~.hip._util.types.Pointer`/`~.object`) -- *IN*:
            device array of device pointers storing each matrix C_i on the GPU.

        ldc (`~.int`) -- *IN*:
            [int]
            ldc specifies the first dimension of C. ldc >= max( 1, n ).

        batchCount (`~.int`) -- *IN*:
            [int]
            number of instances in the batch.
    """
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")                    
    if not isinstance(transA,_hipblasOperation_t__Base):
        raise TypeError("argument 'transA' must be of type '_hipblasOperation_t__Base'")
    _hipblasSsyrkBatched__retval = hipblasStatus_t(chipblas.hipblasSsyrkBatched(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,uplo.value,transA.value,n,k,
        <const float *>hip._util.types.Pointer.fromPyobj(alpha)._ptr,
        <const float *const*>hip._util.types.Pointer.fromPyobj(AP)._ptr,lda,
        <const float *>hip._util.types.Pointer.fromPyobj(beta)._ptr,
        <float *const*>hip._util.types.Pointer.fromPyobj(CP)._ptr,ldc,batchCount))
    return (_hipblasSsyrkBatched__retval,)


@cython.embedsignature(True)
def hipblasDsyrkBatched(object handle, object uplo, object transA, int n, int k, object alpha, object AP, int lda, object beta, object CP, int ldc, int batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        uplo (`~.hipblasFillMode_t`):
            (undocumented)

        transA (`~.hipblasOperation_t`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        k (`~.int`):
            (undocumented)

        alpha (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        AP (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        beta (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        CP (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        ldc (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")                    
    if not isinstance(transA,_hipblasOperation_t__Base):
        raise TypeError("argument 'transA' must be of type '_hipblasOperation_t__Base'")
    _hipblasDsyrkBatched__retval = hipblasStatus_t(chipblas.hipblasDsyrkBatched(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,uplo.value,transA.value,n,k,
        <const double *>hip._util.types.Pointer.fromPyobj(alpha)._ptr,
        <const double *const*>hip._util.types.Pointer.fromPyobj(AP)._ptr,lda,
        <const double *>hip._util.types.Pointer.fromPyobj(beta)._ptr,
        <double *const*>hip._util.types.Pointer.fromPyobj(CP)._ptr,ldc,batchCount))
    return (_hipblasDsyrkBatched__retval,)


@cython.embedsignature(True)
def hipblasCsyrkBatched(object handle, object uplo, object transA, int n, int k, object alpha, object AP, int lda, object beta, object CP, int ldc, int batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        uplo (`~.hipblasFillMode_t`):
            (undocumented)

        transA (`~.hipblasOperation_t`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        k (`~.int`):
            (undocumented)

        alpha (`~.hipblasComplex`/`~.object`):
            (undocumented)

        AP (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        beta (`~.hipblasComplex`/`~.object`):
            (undocumented)

        CP (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        ldc (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")                    
    if not isinstance(transA,_hipblasOperation_t__Base):
        raise TypeError("argument 'transA' must be of type '_hipblasOperation_t__Base'")
    _hipblasCsyrkBatched__retval = hipblasStatus_t(chipblas.hipblasCsyrkBatched(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,uplo.value,transA.value,n,k,
        hipblasComplex.fromPyobj(alpha).getElementPtr(),
        <chipblas.hipblasComplex *const*>hip._util.types.Pointer.fromPyobj(AP)._ptr,lda,
        hipblasComplex.fromPyobj(beta).getElementPtr(),
        <chipblas.hipblasComplex *const*>hip._util.types.Pointer.fromPyobj(CP)._ptr,ldc,batchCount))
    return (_hipblasCsyrkBatched__retval,)


@cython.embedsignature(True)
def hipblasZsyrkBatched(object handle, object uplo, object transA, int n, int k, object alpha, object AP, int lda, object beta, object CP, int ldc, int batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        uplo (`~.hipblasFillMode_t`):
            (undocumented)

        transA (`~.hipblasOperation_t`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        k (`~.int`):
            (undocumented)

        alpha (`~.hipblasDoubleComplex`/`~.object`):
            (undocumented)

        AP (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        beta (`~.hipblasDoubleComplex`/`~.object`):
            (undocumented)

        CP (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        ldc (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")                    
    if not isinstance(transA,_hipblasOperation_t__Base):
        raise TypeError("argument 'transA' must be of type '_hipblasOperation_t__Base'")
    _hipblasZsyrkBatched__retval = hipblasStatus_t(chipblas.hipblasZsyrkBatched(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,uplo.value,transA.value,n,k,
        hipblasDoubleComplex.fromPyobj(alpha).getElementPtr(),
        <chipblas.hipblasDoubleComplex *const*>hip._util.types.Pointer.fromPyobj(AP)._ptr,lda,
        hipblasDoubleComplex.fromPyobj(beta).getElementPtr(),
        <chipblas.hipblasDoubleComplex *const*>hip._util.types.Pointer.fromPyobj(CP)._ptr,ldc,batchCount))
    return (_hipblasZsyrkBatched__retval,)


@cython.embedsignature(True)
def hipblasCsyrkBatched_v2(object handle, object uplo, object transA, int n, int k, object alpha, object AP, int lda, object beta, object CP, int ldc, int batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        uplo (`~.hipblasFillMode_t`):
            (undocumented)

        transA (`~.hipblasOperation_t`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        k (`~.int`):
            (undocumented)

        alpha (`~.float2`/`~.object`):
            (undocumented)

        AP (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        beta (`~.float2`/`~.object`):
            (undocumented)

        CP (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        ldc (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")                    
    if not isinstance(transA,_hipblasOperation_t__Base):
        raise TypeError("argument 'transA' must be of type '_hipblasOperation_t__Base'")
    _hipblasCsyrkBatched_v2__retval = hipblasStatus_t(chipblas.hipblasCsyrkBatched_v2(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,uplo.value,transA.value,n,k,
        float2.fromPyobj(alpha).getElementPtr(),
        <chipblas.float2 *const*>hip._util.types.Pointer.fromPyobj(AP)._ptr,lda,
        float2.fromPyobj(beta).getElementPtr(),
        <chipblas.float2 *const*>hip._util.types.Pointer.fromPyobj(CP)._ptr,ldc,batchCount))
    return (_hipblasCsyrkBatched_v2__retval,)


@cython.embedsignature(True)
def hipblasZsyrkBatched_v2(object handle, object uplo, object transA, int n, int k, object alpha, object AP, int lda, object beta, object CP, int ldc, int batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        uplo (`~.hipblasFillMode_t`):
            (undocumented)

        transA (`~.hipblasOperation_t`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        k (`~.int`):
            (undocumented)

        alpha (`~.double2`/`~.object`):
            (undocumented)

        AP (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        beta (`~.double2`/`~.object`):
            (undocumented)

        CP (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        ldc (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")                    
    if not isinstance(transA,_hipblasOperation_t__Base):
        raise TypeError("argument 'transA' must be of type '_hipblasOperation_t__Base'")
    _hipblasZsyrkBatched_v2__retval = hipblasStatus_t(chipblas.hipblasZsyrkBatched_v2(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,uplo.value,transA.value,n,k,
        double2.fromPyobj(alpha).getElementPtr(),
        <chipblas.double2 *const*>hip._util.types.Pointer.fromPyobj(AP)._ptr,lda,
        double2.fromPyobj(beta).getElementPtr(),
        <chipblas.double2 *const*>hip._util.types.Pointer.fromPyobj(CP)._ptr,ldc,batchCount))
    return (_hipblasZsyrkBatched_v2__retval,)


@cython.embedsignature(True)
def hipblasSsyrkStridedBatched(object handle, object uplo, object transA, int n, int k, object alpha, object AP, int lda, long strideA, object beta, object CP, int ldc, long strideC, int batchCount):
    r"""BLAS Level 3 API

    @{

    syrkStridedBatched performs a batch of the matrix-matrix operations for a symmetric rank-k update

    C_i := alpha*op( A_i )*op( A_i )^T + beta*C_i

    where  alpha and beta are scalars, op(A_i) is an n by k matrix, and
    C_i is a symmetric n x n matrix stored as either upper or lower.

        op( A_i ) = A_i, and A_i is n by k if transA == HIPBLAS_OP_N
        op( A_i ) = A_i^T and A_i is k by n if transA == HIPBLAS_OP_T

    - Supported precisions in rocBLAS : s,d,c,z
    - Supported precisions in cuBLAS  : No support

    HIPBLAS_OP_C is not supported for complex types, see cherk
    and zherk.

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`) -- *IN*:
            [hipblasHandle_t]
            handle to the hipblas library context queue.

        uplo (`~.hipblasFillMode_t`) -- *IN*:
            [hipblasFillMode_t]
            HIPBLAS_FILL_MODE_UPPER:  C_i is an upper triangular matrix
            HIPBLAS_FILL_MODE_LOWER:  C_i is a  lower triangular matrix

        transA (`~.hipblasOperation_t`) -- *IN*:
            [hipblasOperation_t]
            HIPBLAS_OP_T: op(A) = A^T
            HIPBLAS_OP_N: op(A) = A
            HIPBLAS_OP_C: op(A) = A^T

        n (`~.int`) -- *IN*:
            [int]
            n specifies the number of rows and columns of C_i. n >= 0.

        k (`~.int`) -- *IN*:
            [int]
            k specifies the number of columns of op(A). k >= 0.

        alpha (`~.hip._util.types.Pointer`/`~.object`) -- *IN*:
            alpha specifies the scalar alpha. When alpha is
            zero then A is not referenced and A need not be set before
            entry.

        AP (`~.hip._util.types.Pointer`/`~.object`) -- *IN*:
            Device pointer to the first matrix A_1 on the GPU of dimension (lda, k)
            when transA is HIPBLAS_OP_N, otherwise of dimension (lda, n)

        lda (`~.int`) -- *IN*:
            [int]
            lda specifies the first dimension of A_i.
            if transA = HIPBLAS_OP_N,  lda >= max( 1, n ),
            otherwise lda >= max( 1, k ).

        strideA (`~.int`) -- *IN*:
            [hipblasStride]
            stride from the start of one matrix (A_i) and the next one (A_i+1)

        beta (`~.hip._util.types.Pointer`/`~.object`) -- *IN*:
            beta specifies the scalar beta. When beta is
            zero then C need not be set before entry.

        CP (`~.hip._util.types.Pointer`/`~.object`) -- *IN*:
            Device pointer to the first matrix C_1 on the GPU. on the GPU.

        ldc (`~.int`) -- *IN*:
            [int]
            ldc specifies the first dimension of C. ldc >= max( 1, n ).

        strideC (`~.int`) -- *INOUT*:
            [hipblasStride]
            stride from the start of one matrix (C_i) and the next one (C_i+1)

        batchCount (`~.int`) -- *IN*:
            [int]
            number of instances in the batch.
    """
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")                    
    if not isinstance(transA,_hipblasOperation_t__Base):
        raise TypeError("argument 'transA' must be of type '_hipblasOperation_t__Base'")
    _hipblasSsyrkStridedBatched__retval = hipblasStatus_t(chipblas.hipblasSsyrkStridedBatched(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,uplo.value,transA.value,n,k,
        <const float *>hip._util.types.Pointer.fromPyobj(alpha)._ptr,
        <const float *>hip._util.types.Pointer.fromPyobj(AP)._ptr,lda,strideA,
        <const float *>hip._util.types.Pointer.fromPyobj(beta)._ptr,
        <float *>hip._util.types.Pointer.fromPyobj(CP)._ptr,ldc,strideC,batchCount))
    return (_hipblasSsyrkStridedBatched__retval,)


@cython.embedsignature(True)
def hipblasDsyrkStridedBatched(object handle, object uplo, object transA, int n, int k, object alpha, object AP, int lda, long strideA, object beta, object CP, int ldc, long strideC, int batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        uplo (`~.hipblasFillMode_t`):
            (undocumented)

        transA (`~.hipblasOperation_t`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        k (`~.int`):
            (undocumented)

        alpha (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        AP (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        strideA (`~.int`):
            (undocumented)

        beta (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        CP (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        ldc (`~.int`):
            (undocumented)

        strideC (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")                    
    if not isinstance(transA,_hipblasOperation_t__Base):
        raise TypeError("argument 'transA' must be of type '_hipblasOperation_t__Base'")
    _hipblasDsyrkStridedBatched__retval = hipblasStatus_t(chipblas.hipblasDsyrkStridedBatched(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,uplo.value,transA.value,n,k,
        <const double *>hip._util.types.Pointer.fromPyobj(alpha)._ptr,
        <const double *>hip._util.types.Pointer.fromPyobj(AP)._ptr,lda,strideA,
        <const double *>hip._util.types.Pointer.fromPyobj(beta)._ptr,
        <double *>hip._util.types.Pointer.fromPyobj(CP)._ptr,ldc,strideC,batchCount))
    return (_hipblasDsyrkStridedBatched__retval,)


@cython.embedsignature(True)
def hipblasCsyrkStridedBatched(object handle, object uplo, object transA, int n, int k, object alpha, object AP, int lda, long strideA, object beta, object CP, int ldc, long strideC, int batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        uplo (`~.hipblasFillMode_t`):
            (undocumented)

        transA (`~.hipblasOperation_t`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        k (`~.int`):
            (undocumented)

        alpha (`~.hipblasComplex`/`~.object`):
            (undocumented)

        AP (`~.hipblasComplex`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        strideA (`~.int`):
            (undocumented)

        beta (`~.hipblasComplex`/`~.object`):
            (undocumented)

        CP (`~.hipblasComplex`/`~.object`):
            (undocumented)

        ldc (`~.int`):
            (undocumented)

        strideC (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")                    
    if not isinstance(transA,_hipblasOperation_t__Base):
        raise TypeError("argument 'transA' must be of type '_hipblasOperation_t__Base'")
    _hipblasCsyrkStridedBatched__retval = hipblasStatus_t(chipblas.hipblasCsyrkStridedBatched(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,uplo.value,transA.value,n,k,
        hipblasComplex.fromPyobj(alpha).getElementPtr(),
        hipblasComplex.fromPyobj(AP).getElementPtr(),lda,strideA,
        hipblasComplex.fromPyobj(beta).getElementPtr(),
        hipblasComplex.fromPyobj(CP).getElementPtr(),ldc,strideC,batchCount))
    return (_hipblasCsyrkStridedBatched__retval,)


@cython.embedsignature(True)
def hipblasZsyrkStridedBatched(object handle, object uplo, object transA, int n, int k, object alpha, object AP, int lda, long strideA, object beta, object CP, int ldc, long strideC, int batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        uplo (`~.hipblasFillMode_t`):
            (undocumented)

        transA (`~.hipblasOperation_t`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        k (`~.int`):
            (undocumented)

        alpha (`~.hipblasDoubleComplex`/`~.object`):
            (undocumented)

        AP (`~.hipblasDoubleComplex`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        strideA (`~.int`):
            (undocumented)

        beta (`~.hipblasDoubleComplex`/`~.object`):
            (undocumented)

        CP (`~.hipblasDoubleComplex`/`~.object`):
            (undocumented)

        ldc (`~.int`):
            (undocumented)

        strideC (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")                    
    if not isinstance(transA,_hipblasOperation_t__Base):
        raise TypeError("argument 'transA' must be of type '_hipblasOperation_t__Base'")
    _hipblasZsyrkStridedBatched__retval = hipblasStatus_t(chipblas.hipblasZsyrkStridedBatched(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,uplo.value,transA.value,n,k,
        hipblasDoubleComplex.fromPyobj(alpha).getElementPtr(),
        hipblasDoubleComplex.fromPyobj(AP).getElementPtr(),lda,strideA,
        hipblasDoubleComplex.fromPyobj(beta).getElementPtr(),
        hipblasDoubleComplex.fromPyobj(CP).getElementPtr(),ldc,strideC,batchCount))
    return (_hipblasZsyrkStridedBatched__retval,)


@cython.embedsignature(True)
def hipblasCsyrkStridedBatched_v2(object handle, object uplo, object transA, int n, int k, object alpha, object AP, int lda, long strideA, object beta, object CP, int ldc, long strideC, int batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        uplo (`~.hipblasFillMode_t`):
            (undocumented)

        transA (`~.hipblasOperation_t`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        k (`~.int`):
            (undocumented)

        alpha (`~.float2`/`~.object`):
            (undocumented)

        AP (`~.float2`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        strideA (`~.int`):
            (undocumented)

        beta (`~.float2`/`~.object`):
            (undocumented)

        CP (`~.float2`/`~.object`):
            (undocumented)

        ldc (`~.int`):
            (undocumented)

        strideC (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")                    
    if not isinstance(transA,_hipblasOperation_t__Base):
        raise TypeError("argument 'transA' must be of type '_hipblasOperation_t__Base'")
    _hipblasCsyrkStridedBatched_v2__retval = hipblasStatus_t(chipblas.hipblasCsyrkStridedBatched_v2(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,uplo.value,transA.value,n,k,
        float2.fromPyobj(alpha).getElementPtr(),
        float2.fromPyobj(AP).getElementPtr(),lda,strideA,
        float2.fromPyobj(beta).getElementPtr(),
        float2.fromPyobj(CP).getElementPtr(),ldc,strideC,batchCount))
    return (_hipblasCsyrkStridedBatched_v2__retval,)


@cython.embedsignature(True)
def hipblasZsyrkStridedBatched_v2(object handle, object uplo, object transA, int n, int k, object alpha, object AP, int lda, long strideA, object beta, object CP, int ldc, long strideC, int batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        uplo (`~.hipblasFillMode_t`):
            (undocumented)

        transA (`~.hipblasOperation_t`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        k (`~.int`):
            (undocumented)

        alpha (`~.double2`/`~.object`):
            (undocumented)

        AP (`~.double2`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        strideA (`~.int`):
            (undocumented)

        beta (`~.double2`/`~.object`):
            (undocumented)

        CP (`~.double2`/`~.object`):
            (undocumented)

        ldc (`~.int`):
            (undocumented)

        strideC (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")                    
    if not isinstance(transA,_hipblasOperation_t__Base):
        raise TypeError("argument 'transA' must be of type '_hipblasOperation_t__Base'")
    _hipblasZsyrkStridedBatched_v2__retval = hipblasStatus_t(chipblas.hipblasZsyrkStridedBatched_v2(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,uplo.value,transA.value,n,k,
        double2.fromPyobj(alpha).getElementPtr(),
        double2.fromPyobj(AP).getElementPtr(),lda,strideA,
        double2.fromPyobj(beta).getElementPtr(),
        double2.fromPyobj(CP).getElementPtr(),ldc,strideC,batchCount))
    return (_hipblasZsyrkStridedBatched_v2__retval,)


@cython.embedsignature(True)
def hipblasSsyr2k(object handle, object uplo, object transA, int n, int k, object alpha, object AP, int lda, object BP, int ldb, object beta, object CP, int ldc):
    r"""BLAS Level 3 API

    @{

    syr2k performs one of the matrix-matrix operations for a symmetric rank-2k update

    C := alpha*(op( A )*op( B )^T + op( B )*op( A )^T) + beta*C

    where  alpha and beta are scalars, op(A) and op(B) are n by k matrix, and
    C is a symmetric n x n matrix stored as either upper or lower.

        op( A ) = A, op( B ) = B, and A and B are n by k if trans == HIPBLAS_OP_N
        op( A ) = A^T, op( B ) = B^T,  and A and B are k by n if trans == HIPBLAS_OP_T

    - Supported precisions in rocBLAS : s,d,c,z
    - Supported precisions in cuBLAS  : s,d,c,z

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`) -- *IN*:
            [hipblasHandle_t]
            handle to the hipblas library context queue.

        uplo (`~.hipblasFillMode_t`) -- *IN*:
            [hipblasFillMode_t]
            HIPBLAS_FILL_MODE_UPPER:  C is an upper triangular matrix
            HIPBLAS_FILL_MODE_LOWER:  C is a  lower triangular matrix

        transA (`~.hipblasOperation_t`) -- *IN*:
            [hipblasOperation_t]
            HIPBLAS_OP_T:      op( A ) = A^T, op( B ) = B^T
            HIPBLAS_OP_N:           op( A ) = A, op( B ) = B

        n (`~.int`) -- *IN*:
            [int]
            n specifies the number of rows and columns of C. n >= 0.

        k (`~.int`) -- *IN*:
            [int]
            k specifies the number of columns of op(A) and op(B). k >= 0.

        alpha (`~.hip._util.types.Pointer`/`~.object`) -- *IN*:
            alpha specifies the scalar alpha. When alpha is
            zero then A is not referenced and A need not be set before
            entry.

        AP (`~.hip._util.types.Pointer`/`~.object`) -- *IN*:
            pointer storing matrix A on the GPU.
            Martrix dimension is ( lda, k ) when if trans = HIPBLAS_OP_N, otherwise (lda, n)
            only the upper/lower triangular part is accessed.

        lda (`~.int`) -- *IN*:
            [int]
            lda specifies the first dimension of A.
            if trans = HIPBLAS_OP_N,  lda >= max( 1, n ),
            otherwise lda >= max( 1, k ).

        BP (`~.hip._util.types.Pointer`/`~.object`) -- *IN*:
            pointer storing matrix B on the GPU.
            Martrix dimension is ( ldb, k ) when if trans = HIPBLAS_OP_N, otherwise (ldb, n)
            only the upper/lower triangular part is accessed.

        ldb (`~.int`) -- *IN*:
            [int]
            ldb specifies the first dimension of B.
            if trans = HIPBLAS_OP_N,  ldb >= max( 1, n ),
            otherwise ldb >= max( 1, k ).

        beta (`~.hip._util.types.Pointer`/`~.object`) -- *IN*:
            beta specifies the scalar beta. When beta is
            zero then C need not be set before entry.

        CP (`~.hip._util.types.Pointer`/`~.object`) -- *IN*:
            pointer storing matrix C on the GPU.

        ldc (`~.int`) -- *IN*:
            [int]
            ldc specifies the first dimension of C. ldc >= max( 1, n ).
    """
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")                    
    if not isinstance(transA,_hipblasOperation_t__Base):
        raise TypeError("argument 'transA' must be of type '_hipblasOperation_t__Base'")
    _hipblasSsyr2k__retval = hipblasStatus_t(chipblas.hipblasSsyr2k(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,uplo.value,transA.value,n,k,
        <const float *>hip._util.types.Pointer.fromPyobj(alpha)._ptr,
        <const float *>hip._util.types.Pointer.fromPyobj(AP)._ptr,lda,
        <const float *>hip._util.types.Pointer.fromPyobj(BP)._ptr,ldb,
        <const float *>hip._util.types.Pointer.fromPyobj(beta)._ptr,
        <float *>hip._util.types.Pointer.fromPyobj(CP)._ptr,ldc))
    return (_hipblasSsyr2k__retval,)


@cython.embedsignature(True)
def hipblasDsyr2k(object handle, object uplo, object transA, int n, int k, object alpha, object AP, int lda, object BP, int ldb, object beta, object CP, int ldc):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        uplo (`~.hipblasFillMode_t`):
            (undocumented)

        transA (`~.hipblasOperation_t`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        k (`~.int`):
            (undocumented)

        alpha (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        AP (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        BP (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        ldb (`~.int`):
            (undocumented)

        beta (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        CP (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        ldc (`~.int`):
            (undocumented)
    """
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")                    
    if not isinstance(transA,_hipblasOperation_t__Base):
        raise TypeError("argument 'transA' must be of type '_hipblasOperation_t__Base'")
    _hipblasDsyr2k__retval = hipblasStatus_t(chipblas.hipblasDsyr2k(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,uplo.value,transA.value,n,k,
        <const double *>hip._util.types.Pointer.fromPyobj(alpha)._ptr,
        <const double *>hip._util.types.Pointer.fromPyobj(AP)._ptr,lda,
        <const double *>hip._util.types.Pointer.fromPyobj(BP)._ptr,ldb,
        <const double *>hip._util.types.Pointer.fromPyobj(beta)._ptr,
        <double *>hip._util.types.Pointer.fromPyobj(CP)._ptr,ldc))
    return (_hipblasDsyr2k__retval,)


@cython.embedsignature(True)
def hipblasCsyr2k(object handle, object uplo, object transA, int n, int k, object alpha, object AP, int lda, object BP, int ldb, object beta, object CP, int ldc):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        uplo (`~.hipblasFillMode_t`):
            (undocumented)

        transA (`~.hipblasOperation_t`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        k (`~.int`):
            (undocumented)

        alpha (`~.hipblasComplex`/`~.object`):
            (undocumented)

        AP (`~.hipblasComplex`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        BP (`~.hipblasComplex`/`~.object`):
            (undocumented)

        ldb (`~.int`):
            (undocumented)

        beta (`~.hipblasComplex`/`~.object`):
            (undocumented)

        CP (`~.hipblasComplex`/`~.object`):
            (undocumented)

        ldc (`~.int`):
            (undocumented)
    """
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")                    
    if not isinstance(transA,_hipblasOperation_t__Base):
        raise TypeError("argument 'transA' must be of type '_hipblasOperation_t__Base'")
    _hipblasCsyr2k__retval = hipblasStatus_t(chipblas.hipblasCsyr2k(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,uplo.value,transA.value,n,k,
        hipblasComplex.fromPyobj(alpha).getElementPtr(),
        hipblasComplex.fromPyobj(AP).getElementPtr(),lda,
        hipblasComplex.fromPyobj(BP).getElementPtr(),ldb,
        hipblasComplex.fromPyobj(beta).getElementPtr(),
        hipblasComplex.fromPyobj(CP).getElementPtr(),ldc))
    return (_hipblasCsyr2k__retval,)


@cython.embedsignature(True)
def hipblasZsyr2k(object handle, object uplo, object transA, int n, int k, object alpha, object AP, int lda, object BP, int ldb, object beta, object CP, int ldc):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        uplo (`~.hipblasFillMode_t`):
            (undocumented)

        transA (`~.hipblasOperation_t`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        k (`~.int`):
            (undocumented)

        alpha (`~.hipblasDoubleComplex`/`~.object`):
            (undocumented)

        AP (`~.hipblasDoubleComplex`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        BP (`~.hipblasDoubleComplex`/`~.object`):
            (undocumented)

        ldb (`~.int`):
            (undocumented)

        beta (`~.hipblasDoubleComplex`/`~.object`):
            (undocumented)

        CP (`~.hipblasDoubleComplex`/`~.object`):
            (undocumented)

        ldc (`~.int`):
            (undocumented)
    """
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")                    
    if not isinstance(transA,_hipblasOperation_t__Base):
        raise TypeError("argument 'transA' must be of type '_hipblasOperation_t__Base'")
    _hipblasZsyr2k__retval = hipblasStatus_t(chipblas.hipblasZsyr2k(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,uplo.value,transA.value,n,k,
        hipblasDoubleComplex.fromPyobj(alpha).getElementPtr(),
        hipblasDoubleComplex.fromPyobj(AP).getElementPtr(),lda,
        hipblasDoubleComplex.fromPyobj(BP).getElementPtr(),ldb,
        hipblasDoubleComplex.fromPyobj(beta).getElementPtr(),
        hipblasDoubleComplex.fromPyobj(CP).getElementPtr(),ldc))
    return (_hipblasZsyr2k__retval,)


@cython.embedsignature(True)
def hipblasCsyr2k_v2(object handle, object uplo, object transA, int n, int k, object alpha, object AP, int lda, object BP, int ldb, object beta, object CP, int ldc):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        uplo (`~.hipblasFillMode_t`):
            (undocumented)

        transA (`~.hipblasOperation_t`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        k (`~.int`):
            (undocumented)

        alpha (`~.float2`/`~.object`):
            (undocumented)

        AP (`~.float2`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        BP (`~.float2`/`~.object`):
            (undocumented)

        ldb (`~.int`):
            (undocumented)

        beta (`~.float2`/`~.object`):
            (undocumented)

        CP (`~.float2`/`~.object`):
            (undocumented)

        ldc (`~.int`):
            (undocumented)
    """
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")                    
    if not isinstance(transA,_hipblasOperation_t__Base):
        raise TypeError("argument 'transA' must be of type '_hipblasOperation_t__Base'")
    _hipblasCsyr2k_v2__retval = hipblasStatus_t(chipblas.hipblasCsyr2k_v2(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,uplo.value,transA.value,n,k,
        float2.fromPyobj(alpha).getElementPtr(),
        float2.fromPyobj(AP).getElementPtr(),lda,
        float2.fromPyobj(BP).getElementPtr(),ldb,
        float2.fromPyobj(beta).getElementPtr(),
        float2.fromPyobj(CP).getElementPtr(),ldc))
    return (_hipblasCsyr2k_v2__retval,)


@cython.embedsignature(True)
def hipblasZsyr2k_v2(object handle, object uplo, object transA, int n, int k, object alpha, object AP, int lda, object BP, int ldb, object beta, object CP, int ldc):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        uplo (`~.hipblasFillMode_t`):
            (undocumented)

        transA (`~.hipblasOperation_t`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        k (`~.int`):
            (undocumented)

        alpha (`~.double2`/`~.object`):
            (undocumented)

        AP (`~.double2`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        BP (`~.double2`/`~.object`):
            (undocumented)

        ldb (`~.int`):
            (undocumented)

        beta (`~.double2`/`~.object`):
            (undocumented)

        CP (`~.double2`/`~.object`):
            (undocumented)

        ldc (`~.int`):
            (undocumented)
    """
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")                    
    if not isinstance(transA,_hipblasOperation_t__Base):
        raise TypeError("argument 'transA' must be of type '_hipblasOperation_t__Base'")
    _hipblasZsyr2k_v2__retval = hipblasStatus_t(chipblas.hipblasZsyr2k_v2(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,uplo.value,transA.value,n,k,
        double2.fromPyobj(alpha).getElementPtr(),
        double2.fromPyobj(AP).getElementPtr(),lda,
        double2.fromPyobj(BP).getElementPtr(),ldb,
        double2.fromPyobj(beta).getElementPtr(),
        double2.fromPyobj(CP).getElementPtr(),ldc))
    return (_hipblasZsyr2k_v2__retval,)


@cython.embedsignature(True)
def hipblasSsyr2kBatched(object handle, object uplo, object transA, int n, int k, object alpha, object AP, int lda, object BP, int ldb, object beta, object CP, int ldc, int batchCount):
    r"""BLAS Level 3 API

    @{

    syr2kBatched performs a batch of the matrix-matrix operations for a symmetric rank-2k update

    C_i := alpha*(op( A_i )*op( B_i )^T + op( B_i )*op( A_i )^T) + beta*C_i

    where  alpha and beta are scalars, op(A_i) and op(B_i) are n by k matrix, and
    C_i is a symmetric n x n matrix stored as either upper or lower.

        op( A_i ) = A_i, op( B_i ) = B_i, and A_i and B_i are n by k if trans == HIPBLAS_OP_N
        op( A_i ) = A_i^T, op( B_i ) = B_i^T,  and A_i and B_i are k by n if trans == HIPBLAS_OP_T

    - Supported precisions in rocBLAS : s,d,c,z
    - Supported precisions in cuBLAS  : No support

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`) -- *IN*:
            [hipblasHandle_t]
            handle to the hipblas library context queue.

        uplo (`~.hipblasFillMode_t`) -- *IN*:
            [hipblasFillMode_t]
            HIPBLAS_FILL_MODE_UPPER:  C_i is an upper triangular matrix
            HIPBLAS_FILL_MODE_LOWER:  C_i is a  lower triangular matrix

        transA (`~.hipblasOperation_t`) -- *IN*:
            [hipblasOperation_t]
            HIPBLAS_OP_T:      op( A_i ) = A_i^T, op( B_i ) = B_i^T
            HIPBLAS_OP_N:           op( A_i ) = A_i, op( B_i ) = B_i

        n (`~.int`) -- *IN*:
            [int]
            n specifies the number of rows and columns of C_i. n >= 0.

        k (`~.int`) -- *IN*:
            [int]
            k specifies the number of columns of op(A). k >= 0.

        alpha (`~.hip._util.types.Pointer`/`~.object`) -- *IN*:
            alpha specifies the scalar alpha. When alpha is
            zero then A is not referenced and A need not be set before
            entry.

        AP (`~.hip._util.types.Pointer`/`~.object`) -- *IN*:
            device array of device pointers storing each matrix_i A of dimension (lda, k)
            when trans is HIPBLAS_OP_N, otherwise of dimension (lda, n)

        lda (`~.int`) -- *IN*:
            [int]
            lda specifies the first dimension of A_i.
            if trans = HIPBLAS_OP_N,  lda >= max( 1, n ),
            otherwise lda >= max( 1, k ).

        BP (`~.hip._util.types.Pointer`/`~.object`) -- *IN*:
            device array of device pointers storing each matrix_i B of dimension (ldb, k)
            when trans is HIPBLAS_OP_N, otherwise of dimension (ldb, n)

        ldb (`~.int`) -- *IN*:
            [int]
            ldb specifies the first dimension of B.
            if trans = HIPBLAS_OP_N,  ldb >= max( 1, n ),
            otherwise ldb >= max( 1, k ).

        beta (`~.hip._util.types.Pointer`/`~.object`) -- *IN*:
            beta specifies the scalar beta. When beta is
            zero then C need not be set before entry.

        CP (`~.hip._util.types.Pointer`/`~.object`) -- *IN*:
            device array of device pointers storing each matrix C_i on the GPU.

        ldc (`~.int`) -- *IN*:
            [int]
            ldc specifies the first dimension of C. ldc >= max( 1, n ).

        batchCount (`~.int`) -- *IN*:
            [int]
            number of instances in the batch.
    """
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")                    
    if not isinstance(transA,_hipblasOperation_t__Base):
        raise TypeError("argument 'transA' must be of type '_hipblasOperation_t__Base'")
    _hipblasSsyr2kBatched__retval = hipblasStatus_t(chipblas.hipblasSsyr2kBatched(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,uplo.value,transA.value,n,k,
        <const float *>hip._util.types.Pointer.fromPyobj(alpha)._ptr,
        <const float *const*>hip._util.types.Pointer.fromPyobj(AP)._ptr,lda,
        <const float *const*>hip._util.types.Pointer.fromPyobj(BP)._ptr,ldb,
        <const float *>hip._util.types.Pointer.fromPyobj(beta)._ptr,
        <float *const*>hip._util.types.Pointer.fromPyobj(CP)._ptr,ldc,batchCount))
    return (_hipblasSsyr2kBatched__retval,)


@cython.embedsignature(True)
def hipblasDsyr2kBatched(object handle, object uplo, object transA, int n, int k, object alpha, object AP, int lda, object BP, int ldb, object beta, object CP, int ldc, int batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        uplo (`~.hipblasFillMode_t`):
            (undocumented)

        transA (`~.hipblasOperation_t`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        k (`~.int`):
            (undocumented)

        alpha (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        AP (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        BP (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        ldb (`~.int`):
            (undocumented)

        beta (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        CP (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        ldc (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")                    
    if not isinstance(transA,_hipblasOperation_t__Base):
        raise TypeError("argument 'transA' must be of type '_hipblasOperation_t__Base'")
    _hipblasDsyr2kBatched__retval = hipblasStatus_t(chipblas.hipblasDsyr2kBatched(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,uplo.value,transA.value,n,k,
        <const double *>hip._util.types.Pointer.fromPyobj(alpha)._ptr,
        <const double *const*>hip._util.types.Pointer.fromPyobj(AP)._ptr,lda,
        <const double *const*>hip._util.types.Pointer.fromPyobj(BP)._ptr,ldb,
        <const double *>hip._util.types.Pointer.fromPyobj(beta)._ptr,
        <double *const*>hip._util.types.Pointer.fromPyobj(CP)._ptr,ldc,batchCount))
    return (_hipblasDsyr2kBatched__retval,)


@cython.embedsignature(True)
def hipblasCsyr2kBatched(object handle, object uplo, object transA, int n, int k, object alpha, object AP, int lda, object BP, int ldb, object beta, object CP, int ldc, int batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        uplo (`~.hipblasFillMode_t`):
            (undocumented)

        transA (`~.hipblasOperation_t`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        k (`~.int`):
            (undocumented)

        alpha (`~.hipblasComplex`/`~.object`):
            (undocumented)

        AP (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        BP (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        ldb (`~.int`):
            (undocumented)

        beta (`~.hipblasComplex`/`~.object`):
            (undocumented)

        CP (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        ldc (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")                    
    if not isinstance(transA,_hipblasOperation_t__Base):
        raise TypeError("argument 'transA' must be of type '_hipblasOperation_t__Base'")
    _hipblasCsyr2kBatched__retval = hipblasStatus_t(chipblas.hipblasCsyr2kBatched(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,uplo.value,transA.value,n,k,
        hipblasComplex.fromPyobj(alpha).getElementPtr(),
        <chipblas.hipblasComplex *const*>hip._util.types.Pointer.fromPyobj(AP)._ptr,lda,
        <chipblas.hipblasComplex *const*>hip._util.types.Pointer.fromPyobj(BP)._ptr,ldb,
        hipblasComplex.fromPyobj(beta).getElementPtr(),
        <chipblas.hipblasComplex *const*>hip._util.types.Pointer.fromPyobj(CP)._ptr,ldc,batchCount))
    return (_hipblasCsyr2kBatched__retval,)


@cython.embedsignature(True)
def hipblasZsyr2kBatched(object handle, object uplo, object transA, int n, int k, object alpha, object AP, int lda, object BP, int ldb, object beta, object CP, int ldc, int batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        uplo (`~.hipblasFillMode_t`):
            (undocumented)

        transA (`~.hipblasOperation_t`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        k (`~.int`):
            (undocumented)

        alpha (`~.hipblasDoubleComplex`/`~.object`):
            (undocumented)

        AP (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        BP (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        ldb (`~.int`):
            (undocumented)

        beta (`~.hipblasDoubleComplex`/`~.object`):
            (undocumented)

        CP (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        ldc (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")                    
    if not isinstance(transA,_hipblasOperation_t__Base):
        raise TypeError("argument 'transA' must be of type '_hipblasOperation_t__Base'")
    _hipblasZsyr2kBatched__retval = hipblasStatus_t(chipblas.hipblasZsyr2kBatched(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,uplo.value,transA.value,n,k,
        hipblasDoubleComplex.fromPyobj(alpha).getElementPtr(),
        <chipblas.hipblasDoubleComplex *const*>hip._util.types.Pointer.fromPyobj(AP)._ptr,lda,
        <chipblas.hipblasDoubleComplex *const*>hip._util.types.Pointer.fromPyobj(BP)._ptr,ldb,
        hipblasDoubleComplex.fromPyobj(beta).getElementPtr(),
        <chipblas.hipblasDoubleComplex *const*>hip._util.types.Pointer.fromPyobj(CP)._ptr,ldc,batchCount))
    return (_hipblasZsyr2kBatched__retval,)


@cython.embedsignature(True)
def hipblasCsyr2kBatched_v2(object handle, object uplo, object transA, int n, int k, object alpha, object AP, int lda, object BP, int ldb, object beta, object CP, int ldc, int batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        uplo (`~.hipblasFillMode_t`):
            (undocumented)

        transA (`~.hipblasOperation_t`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        k (`~.int`):
            (undocumented)

        alpha (`~.float2`/`~.object`):
            (undocumented)

        AP (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        BP (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        ldb (`~.int`):
            (undocumented)

        beta (`~.float2`/`~.object`):
            (undocumented)

        CP (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        ldc (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")                    
    if not isinstance(transA,_hipblasOperation_t__Base):
        raise TypeError("argument 'transA' must be of type '_hipblasOperation_t__Base'")
    _hipblasCsyr2kBatched_v2__retval = hipblasStatus_t(chipblas.hipblasCsyr2kBatched_v2(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,uplo.value,transA.value,n,k,
        float2.fromPyobj(alpha).getElementPtr(),
        <chipblas.float2 *const*>hip._util.types.Pointer.fromPyobj(AP)._ptr,lda,
        <chipblas.float2 *const*>hip._util.types.Pointer.fromPyobj(BP)._ptr,ldb,
        float2.fromPyobj(beta).getElementPtr(),
        <chipblas.float2 *const*>hip._util.types.Pointer.fromPyobj(CP)._ptr,ldc,batchCount))
    return (_hipblasCsyr2kBatched_v2__retval,)


@cython.embedsignature(True)
def hipblasZsyr2kBatched_v2(object handle, object uplo, object transA, int n, int k, object alpha, object AP, int lda, object BP, int ldb, object beta, object CP, int ldc, int batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        uplo (`~.hipblasFillMode_t`):
            (undocumented)

        transA (`~.hipblasOperation_t`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        k (`~.int`):
            (undocumented)

        alpha (`~.double2`/`~.object`):
            (undocumented)

        AP (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        BP (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        ldb (`~.int`):
            (undocumented)

        beta (`~.double2`/`~.object`):
            (undocumented)

        CP (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        ldc (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")                    
    if not isinstance(transA,_hipblasOperation_t__Base):
        raise TypeError("argument 'transA' must be of type '_hipblasOperation_t__Base'")
    _hipblasZsyr2kBatched_v2__retval = hipblasStatus_t(chipblas.hipblasZsyr2kBatched_v2(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,uplo.value,transA.value,n,k,
        double2.fromPyobj(alpha).getElementPtr(),
        <chipblas.double2 *const*>hip._util.types.Pointer.fromPyobj(AP)._ptr,lda,
        <chipblas.double2 *const*>hip._util.types.Pointer.fromPyobj(BP)._ptr,ldb,
        double2.fromPyobj(beta).getElementPtr(),
        <chipblas.double2 *const*>hip._util.types.Pointer.fromPyobj(CP)._ptr,ldc,batchCount))
    return (_hipblasZsyr2kBatched_v2__retval,)


@cython.embedsignature(True)
def hipblasSsyr2kStridedBatched(object handle, object uplo, object transA, int n, int k, object alpha, object AP, int lda, long strideA, object BP, int ldb, long strideB, object beta, object CP, int ldc, long strideC, int batchCount):
    r"""BLAS Level 3 API

    @{

    syr2kStridedBatched performs a batch of the matrix-matrix operations for a symmetric rank-2k update

    C_i := alpha*(op( A_i )*op( B_i )^T + op( B_i )*op( A_i )^T) + beta*C_i

    where  alpha and beta are scalars, op(A_i) and op(B_i) are n by k matrix, and
    C_i is a symmetric n x n matrix stored as either upper or lower.

        op( A_i ) = A_i, op( B_i ) = B_i, and A_i and B_i are n by k if trans == HIPBLAS_OP_N
        op( A_i ) = A_i^T, op( B_i ) = B_i^T,  and A_i and B_i are k by n if trans == HIPBLAS_OP_T

    - Supported precisions in rocBLAS : s,d,c,z
    - Supported precisions in cuBLAS  : No support

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`) -- *IN*:
            [hipblasHandle_t]
            handle to the hipblas library context queue.

        uplo (`~.hipblasFillMode_t`) -- *IN*:
            [hipblasFillMode_t]
            HIPBLAS_FILL_MODE_UPPER:  C_i is an upper triangular matrix
            HIPBLAS_FILL_MODE_LOWER:  C_i is a  lower triangular matrix

        transA (`~.hipblasOperation_t`) -- *IN*:
            [hipblasOperation_t]
            HIPBLAS_OP_T:      op( A_i ) = A_i^T, op( B_i ) = B_i^T
            HIPBLAS_OP_N:           op( A_i ) = A_i, op( B_i ) = B_i

        n (`~.int`) -- *IN*:
            [int]
            n specifies the number of rows and columns of C_i. n >= 0.

        k (`~.int`) -- *IN*:
            [int]
            k specifies the number of columns of op(A). k >= 0.

        alpha (`~.hip._util.types.Pointer`/`~.object`) -- *IN*:
            alpha specifies the scalar alpha. When alpha is
            zero then A is not referenced and A need not be set before
            entry.

        AP (`~.hip._util.types.Pointer`/`~.object`) -- *IN*:
            Device pointer to the first matrix A_1 on the GPU of dimension (lda, k)
            when trans is HIPBLAS_OP_N, otherwise of dimension (lda, n)

        lda (`~.int`) -- *IN*:
            [int]
            lda specifies the first dimension of A_i.
            if trans = HIPBLAS_OP_N,  lda >= max( 1, n ),
            otherwise lda >= max( 1, k ).

        strideA (`~.int`) -- *IN*:
            [hipblasStride]
            stride from the start of one matrix (A_i) and the next one (A_i+1)

        BP (`~.hip._util.types.Pointer`/`~.object`) -- *IN*:
            Device pointer to the first matrix B_1 on the GPU of dimension (ldb, k)
            when trans is HIPBLAS_OP_N, otherwise of dimension (ldb, n)

        ldb (`~.int`) -- *IN*:
            [int]
            ldb specifies the first dimension of B_i.
            if trans = HIPBLAS_OP_N,  ldb >= max( 1, n ),
            otherwise ldb >= max( 1, k ).

        strideB (`~.int`) -- *IN*:
            [hipblasStride]
            stride from the start of one matrix (B_i) and the next one (B_i+1)

        beta (`~.hip._util.types.Pointer`/`~.object`) -- *IN*:
            beta specifies the scalar beta. When beta is
            zero then C need not be set before entry.

        CP (`~.hip._util.types.Pointer`/`~.object`) -- *IN*:
            Device pointer to the first matrix C_1 on the GPU.

        ldc (`~.int`) -- *IN*:
            [int]
            ldc specifies the first dimension of C. ldc >= max( 1, n ).

        strideC (`~.int`) -- *INOUT*:
            [hipblasStride]
            stride from the start of one matrix (C_i) and the next one (C_i+1)

        batchCount (`~.int`) -- *IN*:
            [int]
            number of instances in the batch.
    """
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")                    
    if not isinstance(transA,_hipblasOperation_t__Base):
        raise TypeError("argument 'transA' must be of type '_hipblasOperation_t__Base'")
    _hipblasSsyr2kStridedBatched__retval = hipblasStatus_t(chipblas.hipblasSsyr2kStridedBatched(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,uplo.value,transA.value,n,k,
        <const float *>hip._util.types.Pointer.fromPyobj(alpha)._ptr,
        <const float *>hip._util.types.Pointer.fromPyobj(AP)._ptr,lda,strideA,
        <const float *>hip._util.types.Pointer.fromPyobj(BP)._ptr,ldb,strideB,
        <const float *>hip._util.types.Pointer.fromPyobj(beta)._ptr,
        <float *>hip._util.types.Pointer.fromPyobj(CP)._ptr,ldc,strideC,batchCount))
    return (_hipblasSsyr2kStridedBatched__retval,)


@cython.embedsignature(True)
def hipblasDsyr2kStridedBatched(object handle, object uplo, object transA, int n, int k, object alpha, object AP, int lda, long strideA, object BP, int ldb, long strideB, object beta, object CP, int ldc, long strideC, int batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        uplo (`~.hipblasFillMode_t`):
            (undocumented)

        transA (`~.hipblasOperation_t`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        k (`~.int`):
            (undocumented)

        alpha (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        AP (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        strideA (`~.int`):
            (undocumented)

        BP (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        ldb (`~.int`):
            (undocumented)

        strideB (`~.int`):
            (undocumented)

        beta (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        CP (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        ldc (`~.int`):
            (undocumented)

        strideC (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")                    
    if not isinstance(transA,_hipblasOperation_t__Base):
        raise TypeError("argument 'transA' must be of type '_hipblasOperation_t__Base'")
    _hipblasDsyr2kStridedBatched__retval = hipblasStatus_t(chipblas.hipblasDsyr2kStridedBatched(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,uplo.value,transA.value,n,k,
        <const double *>hip._util.types.Pointer.fromPyobj(alpha)._ptr,
        <const double *>hip._util.types.Pointer.fromPyobj(AP)._ptr,lda,strideA,
        <const double *>hip._util.types.Pointer.fromPyobj(BP)._ptr,ldb,strideB,
        <const double *>hip._util.types.Pointer.fromPyobj(beta)._ptr,
        <double *>hip._util.types.Pointer.fromPyobj(CP)._ptr,ldc,strideC,batchCount))
    return (_hipblasDsyr2kStridedBatched__retval,)


@cython.embedsignature(True)
def hipblasCsyr2kStridedBatched(object handle, object uplo, object transA, int n, int k, object alpha, object AP, int lda, long strideA, object BP, int ldb, long strideB, object beta, object CP, int ldc, long strideC, int batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        uplo (`~.hipblasFillMode_t`):
            (undocumented)

        transA (`~.hipblasOperation_t`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        k (`~.int`):
            (undocumented)

        alpha (`~.hipblasComplex`/`~.object`):
            (undocumented)

        AP (`~.hipblasComplex`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        strideA (`~.int`):
            (undocumented)

        BP (`~.hipblasComplex`/`~.object`):
            (undocumented)

        ldb (`~.int`):
            (undocumented)

        strideB (`~.int`):
            (undocumented)

        beta (`~.hipblasComplex`/`~.object`):
            (undocumented)

        CP (`~.hipblasComplex`/`~.object`):
            (undocumented)

        ldc (`~.int`):
            (undocumented)

        strideC (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")                    
    if not isinstance(transA,_hipblasOperation_t__Base):
        raise TypeError("argument 'transA' must be of type '_hipblasOperation_t__Base'")
    _hipblasCsyr2kStridedBatched__retval = hipblasStatus_t(chipblas.hipblasCsyr2kStridedBatched(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,uplo.value,transA.value,n,k,
        hipblasComplex.fromPyobj(alpha).getElementPtr(),
        hipblasComplex.fromPyobj(AP).getElementPtr(),lda,strideA,
        hipblasComplex.fromPyobj(BP).getElementPtr(),ldb,strideB,
        hipblasComplex.fromPyobj(beta).getElementPtr(),
        hipblasComplex.fromPyobj(CP).getElementPtr(),ldc,strideC,batchCount))
    return (_hipblasCsyr2kStridedBatched__retval,)


@cython.embedsignature(True)
def hipblasZsyr2kStridedBatched(object handle, object uplo, object transA, int n, int k, object alpha, object AP, int lda, long strideA, object BP, int ldb, long strideB, object beta, object CP, int ldc, long strideC, int batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        uplo (`~.hipblasFillMode_t`):
            (undocumented)

        transA (`~.hipblasOperation_t`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        k (`~.int`):
            (undocumented)

        alpha (`~.hipblasDoubleComplex`/`~.object`):
            (undocumented)

        AP (`~.hipblasDoubleComplex`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        strideA (`~.int`):
            (undocumented)

        BP (`~.hipblasDoubleComplex`/`~.object`):
            (undocumented)

        ldb (`~.int`):
            (undocumented)

        strideB (`~.int`):
            (undocumented)

        beta (`~.hipblasDoubleComplex`/`~.object`):
            (undocumented)

        CP (`~.hipblasDoubleComplex`/`~.object`):
            (undocumented)

        ldc (`~.int`):
            (undocumented)

        strideC (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")                    
    if not isinstance(transA,_hipblasOperation_t__Base):
        raise TypeError("argument 'transA' must be of type '_hipblasOperation_t__Base'")
    _hipblasZsyr2kStridedBatched__retval = hipblasStatus_t(chipblas.hipblasZsyr2kStridedBatched(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,uplo.value,transA.value,n,k,
        hipblasDoubleComplex.fromPyobj(alpha).getElementPtr(),
        hipblasDoubleComplex.fromPyobj(AP).getElementPtr(),lda,strideA,
        hipblasDoubleComplex.fromPyobj(BP).getElementPtr(),ldb,strideB,
        hipblasDoubleComplex.fromPyobj(beta).getElementPtr(),
        hipblasDoubleComplex.fromPyobj(CP).getElementPtr(),ldc,strideC,batchCount))
    return (_hipblasZsyr2kStridedBatched__retval,)


@cython.embedsignature(True)
def hipblasCsyr2kStridedBatched_v2(object handle, object uplo, object transA, int n, int k, object alpha, object AP, int lda, long strideA, object BP, int ldb, long strideB, object beta, object CP, int ldc, long strideC, int batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        uplo (`~.hipblasFillMode_t`):
            (undocumented)

        transA (`~.hipblasOperation_t`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        k (`~.int`):
            (undocumented)

        alpha (`~.float2`/`~.object`):
            (undocumented)

        AP (`~.float2`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        strideA (`~.int`):
            (undocumented)

        BP (`~.float2`/`~.object`):
            (undocumented)

        ldb (`~.int`):
            (undocumented)

        strideB (`~.int`):
            (undocumented)

        beta (`~.float2`/`~.object`):
            (undocumented)

        CP (`~.float2`/`~.object`):
            (undocumented)

        ldc (`~.int`):
            (undocumented)

        strideC (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")                    
    if not isinstance(transA,_hipblasOperation_t__Base):
        raise TypeError("argument 'transA' must be of type '_hipblasOperation_t__Base'")
    _hipblasCsyr2kStridedBatched_v2__retval = hipblasStatus_t(chipblas.hipblasCsyr2kStridedBatched_v2(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,uplo.value,transA.value,n,k,
        float2.fromPyobj(alpha).getElementPtr(),
        float2.fromPyobj(AP).getElementPtr(),lda,strideA,
        float2.fromPyobj(BP).getElementPtr(),ldb,strideB,
        float2.fromPyobj(beta).getElementPtr(),
        float2.fromPyobj(CP).getElementPtr(),ldc,strideC,batchCount))
    return (_hipblasCsyr2kStridedBatched_v2__retval,)


@cython.embedsignature(True)
def hipblasZsyr2kStridedBatched_v2(object handle, object uplo, object transA, int n, int k, object alpha, object AP, int lda, long strideA, object BP, int ldb, long strideB, object beta, object CP, int ldc, long strideC, int batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        uplo (`~.hipblasFillMode_t`):
            (undocumented)

        transA (`~.hipblasOperation_t`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        k (`~.int`):
            (undocumented)

        alpha (`~.double2`/`~.object`):
            (undocumented)

        AP (`~.double2`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        strideA (`~.int`):
            (undocumented)

        BP (`~.double2`/`~.object`):
            (undocumented)

        ldb (`~.int`):
            (undocumented)

        strideB (`~.int`):
            (undocumented)

        beta (`~.double2`/`~.object`):
            (undocumented)

        CP (`~.double2`/`~.object`):
            (undocumented)

        ldc (`~.int`):
            (undocumented)

        strideC (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")                    
    if not isinstance(transA,_hipblasOperation_t__Base):
        raise TypeError("argument 'transA' must be of type '_hipblasOperation_t__Base'")
    _hipblasZsyr2kStridedBatched_v2__retval = hipblasStatus_t(chipblas.hipblasZsyr2kStridedBatched_v2(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,uplo.value,transA.value,n,k,
        double2.fromPyobj(alpha).getElementPtr(),
        double2.fromPyobj(AP).getElementPtr(),lda,strideA,
        double2.fromPyobj(BP).getElementPtr(),ldb,strideB,
        double2.fromPyobj(beta).getElementPtr(),
        double2.fromPyobj(CP).getElementPtr(),ldc,strideC,batchCount))
    return (_hipblasZsyr2kStridedBatched_v2__retval,)


@cython.embedsignature(True)
def hipblasSsyrkx(object handle, object uplo, object transA, int n, int k, object alpha, object AP, int lda, object BP, int ldb, object beta, object CP, int ldc):
    r"""BLAS Level 3 API

    @{

    syrkx performs one of the matrix-matrix operations for a symmetric rank-k update

    C := alpha*op( A )*op( B )^T + beta*C

    where  alpha and beta are scalars, op(A) and op(B) are n by k matrix, and
    C is a symmetric n x n matrix stored as either upper or lower.
    This routine should only be used when the caller can guarantee that the result of op( A )*op( B )^T will be symmetric.

        op( A ) = A, op( B ) = B, and A and B are n by k if trans == HIPBLAS_OP_N
        op( A ) = A^T, op( B ) = B^T,  and A and B are k by n if trans == HIPBLAS_OP_T

    - Supported precisions in rocBLAS : s,d,c,z
    - Supported precisions in cuBLAS  : s,d,c,z

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`) -- *IN*:
            [hipblasHandle_t]
            handle to the hipblas library context queue.

        uplo (`~.hipblasFillMode_t`) -- *IN*:
            [hipblasFillMode_t]
            HIPBLAS_FILL_MODE_UPPER:  C is an upper triangular matrix
            HIPBLAS_FILL_MODE_LOWER:  C is a  lower triangular matrix

        transA (`~.hipblasOperation_t`) -- *IN*:
            [hipblasOperation_t]
            HIPBLAS_OP_T:      op( A ) = A^T, op( B ) = B^T
            HIPBLAS_OP_N:           op( A ) = A, op( B ) = B

        n (`~.int`) -- *IN*:
            [int]
            n specifies the number of rows and columns of C. n >= 0.

        k (`~.int`) -- *IN*:
            [int]
            k specifies the number of columns of op(A) and op(B). k >= 0.

        alpha (`~.hip._util.types.Pointer`/`~.object`) -- *IN*:
            alpha specifies the scalar alpha. When alpha is
            zero then A is not referenced and A need not be set before
            entry.

        AP (`~.hip._util.types.Pointer`/`~.object`) -- *IN*:
            pointer storing matrix A on the GPU.
            Martrix dimension is ( lda, k ) when if trans = HIPBLAS_OP_N, otherwise (lda, n)
            only the upper/lower triangular part is accessed.

        lda (`~.int`) -- *IN*:
            [int]
            lda specifies the first dimension of A.
            if trans = HIPBLAS_OP_N,  lda >= max( 1, n ),
            otherwise lda >= max( 1, k ).

        BP (`~.hip._util.types.Pointer`/`~.object`) -- *IN*:
            pointer storing matrix B on the GPU.
            Martrix dimension is ( ldb, k ) when if trans = HIPBLAS_OP_N, otherwise (ldb, n)
            only the upper/lower triangular part is accessed.

        ldb (`~.int`) -- *IN*:
            [int]
            ldb specifies the first dimension of B.
            if trans = HIPBLAS_OP_N,  ldb >= max( 1, n ),
            otherwise ldb >= max( 1, k ).

        beta (`~.hip._util.types.Pointer`/`~.object`) -- *IN*:
            beta specifies the scalar beta. When beta is
            zero then C need not be set before entry.

        CP (`~.hip._util.types.Pointer`/`~.object`) -- *IN*:
            pointer storing matrix C on the GPU.

        ldc (`~.int`) -- *IN*:
            [int]
            ldc specifies the first dimension of C. ldc >= max( 1, n ).
    """
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")                    
    if not isinstance(transA,_hipblasOperation_t__Base):
        raise TypeError("argument 'transA' must be of type '_hipblasOperation_t__Base'")
    _hipblasSsyrkx__retval = hipblasStatus_t(chipblas.hipblasSsyrkx(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,uplo.value,transA.value,n,k,
        <const float *>hip._util.types.Pointer.fromPyobj(alpha)._ptr,
        <const float *>hip._util.types.Pointer.fromPyobj(AP)._ptr,lda,
        <const float *>hip._util.types.Pointer.fromPyobj(BP)._ptr,ldb,
        <const float *>hip._util.types.Pointer.fromPyobj(beta)._ptr,
        <float *>hip._util.types.Pointer.fromPyobj(CP)._ptr,ldc))
    return (_hipblasSsyrkx__retval,)


@cython.embedsignature(True)
def hipblasDsyrkx(object handle, object uplo, object transA, int n, int k, object alpha, object AP, int lda, object BP, int ldb, object beta, object CP, int ldc):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        uplo (`~.hipblasFillMode_t`):
            (undocumented)

        transA (`~.hipblasOperation_t`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        k (`~.int`):
            (undocumented)

        alpha (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        AP (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        BP (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        ldb (`~.int`):
            (undocumented)

        beta (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        CP (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        ldc (`~.int`):
            (undocumented)
    """
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")                    
    if not isinstance(transA,_hipblasOperation_t__Base):
        raise TypeError("argument 'transA' must be of type '_hipblasOperation_t__Base'")
    _hipblasDsyrkx__retval = hipblasStatus_t(chipblas.hipblasDsyrkx(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,uplo.value,transA.value,n,k,
        <const double *>hip._util.types.Pointer.fromPyobj(alpha)._ptr,
        <const double *>hip._util.types.Pointer.fromPyobj(AP)._ptr,lda,
        <const double *>hip._util.types.Pointer.fromPyobj(BP)._ptr,ldb,
        <const double *>hip._util.types.Pointer.fromPyobj(beta)._ptr,
        <double *>hip._util.types.Pointer.fromPyobj(CP)._ptr,ldc))
    return (_hipblasDsyrkx__retval,)


@cython.embedsignature(True)
def hipblasCsyrkx(object handle, object uplo, object transA, int n, int k, object alpha, object AP, int lda, object BP, int ldb, object beta, object CP, int ldc):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        uplo (`~.hipblasFillMode_t`):
            (undocumented)

        transA (`~.hipblasOperation_t`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        k (`~.int`):
            (undocumented)

        alpha (`~.hipblasComplex`/`~.object`):
            (undocumented)

        AP (`~.hipblasComplex`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        BP (`~.hipblasComplex`/`~.object`):
            (undocumented)

        ldb (`~.int`):
            (undocumented)

        beta (`~.hipblasComplex`/`~.object`):
            (undocumented)

        CP (`~.hipblasComplex`/`~.object`):
            (undocumented)

        ldc (`~.int`):
            (undocumented)
    """
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")                    
    if not isinstance(transA,_hipblasOperation_t__Base):
        raise TypeError("argument 'transA' must be of type '_hipblasOperation_t__Base'")
    _hipblasCsyrkx__retval = hipblasStatus_t(chipblas.hipblasCsyrkx(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,uplo.value,transA.value,n,k,
        hipblasComplex.fromPyobj(alpha).getElementPtr(),
        hipblasComplex.fromPyobj(AP).getElementPtr(),lda,
        hipblasComplex.fromPyobj(BP).getElementPtr(),ldb,
        hipblasComplex.fromPyobj(beta).getElementPtr(),
        hipblasComplex.fromPyobj(CP).getElementPtr(),ldc))
    return (_hipblasCsyrkx__retval,)


@cython.embedsignature(True)
def hipblasZsyrkx(object handle, object uplo, object transA, int n, int k, object alpha, object AP, int lda, object BP, int ldb, object beta, object CP, int ldc):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        uplo (`~.hipblasFillMode_t`):
            (undocumented)

        transA (`~.hipblasOperation_t`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        k (`~.int`):
            (undocumented)

        alpha (`~.hipblasDoubleComplex`/`~.object`):
            (undocumented)

        AP (`~.hipblasDoubleComplex`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        BP (`~.hipblasDoubleComplex`/`~.object`):
            (undocumented)

        ldb (`~.int`):
            (undocumented)

        beta (`~.hipblasDoubleComplex`/`~.object`):
            (undocumented)

        CP (`~.hipblasDoubleComplex`/`~.object`):
            (undocumented)

        ldc (`~.int`):
            (undocumented)
    """
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")                    
    if not isinstance(transA,_hipblasOperation_t__Base):
        raise TypeError("argument 'transA' must be of type '_hipblasOperation_t__Base'")
    _hipblasZsyrkx__retval = hipblasStatus_t(chipblas.hipblasZsyrkx(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,uplo.value,transA.value,n,k,
        hipblasDoubleComplex.fromPyobj(alpha).getElementPtr(),
        hipblasDoubleComplex.fromPyobj(AP).getElementPtr(),lda,
        hipblasDoubleComplex.fromPyobj(BP).getElementPtr(),ldb,
        hipblasDoubleComplex.fromPyobj(beta).getElementPtr(),
        hipblasDoubleComplex.fromPyobj(CP).getElementPtr(),ldc))
    return (_hipblasZsyrkx__retval,)


@cython.embedsignature(True)
def hipblasCsyrkx_v2(object handle, object uplo, object transA, int n, int k, object alpha, object AP, int lda, object BP, int ldb, object beta, object CP, int ldc):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        uplo (`~.hipblasFillMode_t`):
            (undocumented)

        transA (`~.hipblasOperation_t`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        k (`~.int`):
            (undocumented)

        alpha (`~.float2`/`~.object`):
            (undocumented)

        AP (`~.float2`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        BP (`~.float2`/`~.object`):
            (undocumented)

        ldb (`~.int`):
            (undocumented)

        beta (`~.float2`/`~.object`):
            (undocumented)

        CP (`~.float2`/`~.object`):
            (undocumented)

        ldc (`~.int`):
            (undocumented)
    """
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")                    
    if not isinstance(transA,_hipblasOperation_t__Base):
        raise TypeError("argument 'transA' must be of type '_hipblasOperation_t__Base'")
    _hipblasCsyrkx_v2__retval = hipblasStatus_t(chipblas.hipblasCsyrkx_v2(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,uplo.value,transA.value,n,k,
        float2.fromPyobj(alpha).getElementPtr(),
        float2.fromPyobj(AP).getElementPtr(),lda,
        float2.fromPyobj(BP).getElementPtr(),ldb,
        float2.fromPyobj(beta).getElementPtr(),
        float2.fromPyobj(CP).getElementPtr(),ldc))
    return (_hipblasCsyrkx_v2__retval,)


@cython.embedsignature(True)
def hipblasZsyrkx_v2(object handle, object uplo, object transA, int n, int k, object alpha, object AP, int lda, object BP, int ldb, object beta, object CP, int ldc):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        uplo (`~.hipblasFillMode_t`):
            (undocumented)

        transA (`~.hipblasOperation_t`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        k (`~.int`):
            (undocumented)

        alpha (`~.double2`/`~.object`):
            (undocumented)

        AP (`~.double2`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        BP (`~.double2`/`~.object`):
            (undocumented)

        ldb (`~.int`):
            (undocumented)

        beta (`~.double2`/`~.object`):
            (undocumented)

        CP (`~.double2`/`~.object`):
            (undocumented)

        ldc (`~.int`):
            (undocumented)
    """
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")                    
    if not isinstance(transA,_hipblasOperation_t__Base):
        raise TypeError("argument 'transA' must be of type '_hipblasOperation_t__Base'")
    _hipblasZsyrkx_v2__retval = hipblasStatus_t(chipblas.hipblasZsyrkx_v2(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,uplo.value,transA.value,n,k,
        double2.fromPyobj(alpha).getElementPtr(),
        double2.fromPyobj(AP).getElementPtr(),lda,
        double2.fromPyobj(BP).getElementPtr(),ldb,
        double2.fromPyobj(beta).getElementPtr(),
        double2.fromPyobj(CP).getElementPtr(),ldc))
    return (_hipblasZsyrkx_v2__retval,)


@cython.embedsignature(True)
def hipblasSsyrkxBatched(object handle, object uplo, object transA, int n, int k, object alpha, object AP, int lda, object BP, int ldb, object beta, object CP, int ldc, int batchCount):
    r"""BLAS Level 3 API

    @{

    syrkxBatched performs a batch of the matrix-matrix operations for a symmetric rank-k update

    C_i := alpha*op( A_i )*op( B_i )^T + beta*C_i

    where  alpha and beta are scalars, op(A_i) and op(B_i) are n by k matrix, and
    C_i is a symmetric n x n matrix stored as either upper or lower.
    This routine should only be used when the caller can guarantee that the result of op( A_i )*op( B_i )^T will be symmetric.

        op( A_i ) = A_i, op( B_i ) = B_i, and A_i and B_i are n by k if trans == HIPBLAS_OP_N
        op( A_i ) = A_i^T, op( B_i ) = B_i^T,  and A_i and B_i are k by n if trans == HIPBLAS_OP_T

    - Supported precisions in rocBLAS : s,d,c,z
    - Supported precisions in cuBLAS  : No support

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`) -- *IN*:
            [hipblasHandle_t]
            handle to the hipblas library context queue.

        uplo (`~.hipblasFillMode_t`) -- *IN*:
            [hipblasFillMode_t]
            HIPBLAS_FILL_MODE_UPPER:  C_i is an upper triangular matrix
            HIPBLAS_FILL_MODE_LOWER:  C_i is a  lower triangular matrix

        transA (`~.hipblasOperation_t`) -- *IN*:
            [hipblasOperation_t]
            HIPBLAS_OP_T:      op( A_i ) = A_i^T, op( B_i ) = B_i^T
            HIPBLAS_OP_N:           op( A_i ) = A_i, op( B_i ) = B_i

        n (`~.int`) -- *IN*:
            [int]
            n specifies the number of rows and columns of C_i. n >= 0.

        k (`~.int`) -- *IN*:
            [int]
            k specifies the number of columns of op(A). k >= 0.

        alpha (`~.hip._util.types.Pointer`/`~.object`) -- *IN*:
            alpha specifies the scalar alpha. When alpha is
            zero then A is not referenced and A need not be set before
            entry.

        AP (`~.hip._util.types.Pointer`/`~.object`) -- *IN*:
            device array of device pointers storing each matrix_i A of dimension (lda, k)
            when trans is HIPBLAS_OP_N, otherwise of dimension (lda, n)

        lda (`~.int`) -- *IN*:
            [int]
            lda specifies the first dimension of A_i.
            if trans = HIPBLAS_OP_N,  lda >= max( 1, n ),
            otherwise lda >= max( 1, k ).

        BP (`~.hip._util.types.Pointer`/`~.object`) -- *IN*:
            device array of device pointers storing each matrix_i B of dimension (ldb, k)
            when trans is HIPBLAS_OP_N, otherwise of dimension (ldb, n)

        ldb (`~.int`) -- *IN*:
            [int]
            ldb specifies the first dimension of B.
            if trans = HIPBLAS_OP_N,  ldb >= max( 1, n ),
            otherwise ldb >= max( 1, k ).

        beta (`~.hip._util.types.Pointer`/`~.object`) -- *IN*:
            beta specifies the scalar beta. When beta is
            zero then C need not be set before entry.

        CP (`~.hip._util.types.Pointer`/`~.object`) -- *IN*:
            device array of device pointers storing each matrix C_i on the GPU.

        ldc (`~.int`) -- *IN*:
            [int]
            ldc specifies the first dimension of C. ldc >= max( 1, n ).

        batchCount (`~.int`) -- *IN*:
            [int]
            number of instances in the batch.
    """
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")                    
    if not isinstance(transA,_hipblasOperation_t__Base):
        raise TypeError("argument 'transA' must be of type '_hipblasOperation_t__Base'")
    _hipblasSsyrkxBatched__retval = hipblasStatus_t(chipblas.hipblasSsyrkxBatched(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,uplo.value,transA.value,n,k,
        <const float *>hip._util.types.Pointer.fromPyobj(alpha)._ptr,
        <const float *const*>hip._util.types.Pointer.fromPyobj(AP)._ptr,lda,
        <const float *const*>hip._util.types.Pointer.fromPyobj(BP)._ptr,ldb,
        <const float *>hip._util.types.Pointer.fromPyobj(beta)._ptr,
        <float *const*>hip._util.types.Pointer.fromPyobj(CP)._ptr,ldc,batchCount))
    return (_hipblasSsyrkxBatched__retval,)


@cython.embedsignature(True)
def hipblasDsyrkxBatched(object handle, object uplo, object transA, int n, int k, object alpha, object AP, int lda, object BP, int ldb, object beta, object CP, int ldc, int batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        uplo (`~.hipblasFillMode_t`):
            (undocumented)

        transA (`~.hipblasOperation_t`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        k (`~.int`):
            (undocumented)

        alpha (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        AP (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        BP (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        ldb (`~.int`):
            (undocumented)

        beta (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        CP (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        ldc (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")                    
    if not isinstance(transA,_hipblasOperation_t__Base):
        raise TypeError("argument 'transA' must be of type '_hipblasOperation_t__Base'")
    _hipblasDsyrkxBatched__retval = hipblasStatus_t(chipblas.hipblasDsyrkxBatched(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,uplo.value,transA.value,n,k,
        <const double *>hip._util.types.Pointer.fromPyobj(alpha)._ptr,
        <const double *const*>hip._util.types.Pointer.fromPyobj(AP)._ptr,lda,
        <const double *const*>hip._util.types.Pointer.fromPyobj(BP)._ptr,ldb,
        <const double *>hip._util.types.Pointer.fromPyobj(beta)._ptr,
        <double *const*>hip._util.types.Pointer.fromPyobj(CP)._ptr,ldc,batchCount))
    return (_hipblasDsyrkxBatched__retval,)


@cython.embedsignature(True)
def hipblasCsyrkxBatched(object handle, object uplo, object transA, int n, int k, object alpha, object AP, int lda, object BP, int ldb, object beta, object CP, int ldc, int batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        uplo (`~.hipblasFillMode_t`):
            (undocumented)

        transA (`~.hipblasOperation_t`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        k (`~.int`):
            (undocumented)

        alpha (`~.hipblasComplex`/`~.object`):
            (undocumented)

        AP (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        BP (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        ldb (`~.int`):
            (undocumented)

        beta (`~.hipblasComplex`/`~.object`):
            (undocumented)

        CP (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        ldc (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")                    
    if not isinstance(transA,_hipblasOperation_t__Base):
        raise TypeError("argument 'transA' must be of type '_hipblasOperation_t__Base'")
    _hipblasCsyrkxBatched__retval = hipblasStatus_t(chipblas.hipblasCsyrkxBatched(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,uplo.value,transA.value,n,k,
        hipblasComplex.fromPyobj(alpha).getElementPtr(),
        <chipblas.hipblasComplex *const*>hip._util.types.Pointer.fromPyobj(AP)._ptr,lda,
        <chipblas.hipblasComplex *const*>hip._util.types.Pointer.fromPyobj(BP)._ptr,ldb,
        hipblasComplex.fromPyobj(beta).getElementPtr(),
        <chipblas.hipblasComplex *const*>hip._util.types.Pointer.fromPyobj(CP)._ptr,ldc,batchCount))
    return (_hipblasCsyrkxBatched__retval,)


@cython.embedsignature(True)
def hipblasZsyrkxBatched(object handle, object uplo, object transA, int n, int k, object alpha, object AP, int lda, object BP, int ldb, object beta, object CP, int ldc, int batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        uplo (`~.hipblasFillMode_t`):
            (undocumented)

        transA (`~.hipblasOperation_t`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        k (`~.int`):
            (undocumented)

        alpha (`~.hipblasDoubleComplex`/`~.object`):
            (undocumented)

        AP (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        BP (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        ldb (`~.int`):
            (undocumented)

        beta (`~.hipblasDoubleComplex`/`~.object`):
            (undocumented)

        CP (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        ldc (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")                    
    if not isinstance(transA,_hipblasOperation_t__Base):
        raise TypeError("argument 'transA' must be of type '_hipblasOperation_t__Base'")
    _hipblasZsyrkxBatched__retval = hipblasStatus_t(chipblas.hipblasZsyrkxBatched(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,uplo.value,transA.value,n,k,
        hipblasDoubleComplex.fromPyobj(alpha).getElementPtr(),
        <chipblas.hipblasDoubleComplex *const*>hip._util.types.Pointer.fromPyobj(AP)._ptr,lda,
        <chipblas.hipblasDoubleComplex *const*>hip._util.types.Pointer.fromPyobj(BP)._ptr,ldb,
        hipblasDoubleComplex.fromPyobj(beta).getElementPtr(),
        <chipblas.hipblasDoubleComplex *const*>hip._util.types.Pointer.fromPyobj(CP)._ptr,ldc,batchCount))
    return (_hipblasZsyrkxBatched__retval,)


@cython.embedsignature(True)
def hipblasCsyrkxBatched_v2(object handle, object uplo, object transA, int n, int k, object alpha, object AP, int lda, object BP, int ldb, object beta, object CP, int ldc, int batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        uplo (`~.hipblasFillMode_t`):
            (undocumented)

        transA (`~.hipblasOperation_t`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        k (`~.int`):
            (undocumented)

        alpha (`~.float2`/`~.object`):
            (undocumented)

        AP (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        BP (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        ldb (`~.int`):
            (undocumented)

        beta (`~.float2`/`~.object`):
            (undocumented)

        CP (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        ldc (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")                    
    if not isinstance(transA,_hipblasOperation_t__Base):
        raise TypeError("argument 'transA' must be of type '_hipblasOperation_t__Base'")
    _hipblasCsyrkxBatched_v2__retval = hipblasStatus_t(chipblas.hipblasCsyrkxBatched_v2(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,uplo.value,transA.value,n,k,
        float2.fromPyobj(alpha).getElementPtr(),
        <chipblas.float2 *const*>hip._util.types.Pointer.fromPyobj(AP)._ptr,lda,
        <chipblas.float2 *const*>hip._util.types.Pointer.fromPyobj(BP)._ptr,ldb,
        float2.fromPyobj(beta).getElementPtr(),
        <chipblas.float2 *const*>hip._util.types.Pointer.fromPyobj(CP)._ptr,ldc,batchCount))
    return (_hipblasCsyrkxBatched_v2__retval,)


@cython.embedsignature(True)
def hipblasZsyrkxBatched_v2(object handle, object uplo, object transA, int n, int k, object alpha, object AP, int lda, object BP, int ldb, object beta, object CP, int ldc, int batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        uplo (`~.hipblasFillMode_t`):
            (undocumented)

        transA (`~.hipblasOperation_t`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        k (`~.int`):
            (undocumented)

        alpha (`~.double2`/`~.object`):
            (undocumented)

        AP (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        BP (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        ldb (`~.int`):
            (undocumented)

        beta (`~.double2`/`~.object`):
            (undocumented)

        CP (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        ldc (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")                    
    if not isinstance(transA,_hipblasOperation_t__Base):
        raise TypeError("argument 'transA' must be of type '_hipblasOperation_t__Base'")
    _hipblasZsyrkxBatched_v2__retval = hipblasStatus_t(chipblas.hipblasZsyrkxBatched_v2(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,uplo.value,transA.value,n,k,
        double2.fromPyobj(alpha).getElementPtr(),
        <chipblas.double2 *const*>hip._util.types.Pointer.fromPyobj(AP)._ptr,lda,
        <chipblas.double2 *const*>hip._util.types.Pointer.fromPyobj(BP)._ptr,ldb,
        double2.fromPyobj(beta).getElementPtr(),
        <chipblas.double2 *const*>hip._util.types.Pointer.fromPyobj(CP)._ptr,ldc,batchCount))
    return (_hipblasZsyrkxBatched_v2__retval,)


@cython.embedsignature(True)
def hipblasSsyrkxStridedBatched(object handle, object uplo, object transA, int n, int k, object alpha, object AP, int lda, long strideA, object BP, int ldb, long strideB, object beta, object CP, int ldc, long strideC, int batchCount):
    r"""BLAS Level 3 API

    @{

    syrkxStridedBatched performs a batch of the matrix-matrix operations for a symmetric rank-k update

    C_i := alpha*op( A_i )*op( B_i )^T + beta*C_i

    where  alpha and beta are scalars, op(A_i) and op(B_i) are n by k matrix, and
    C_i is a symmetric n x n matrix stored as either upper or lower.
    This routine should only be used when the caller can guarantee that the result of op( A_i )*op( B_i )^T will be symmetric.

        op( A_i ) = A_i, op( B_i ) = B_i, and A_i and B_i are n by k if trans == HIPBLAS_OP_N
        op( A_i ) = A_i^T, op( B_i ) = B_i^T,  and A_i and B_i are k by n if trans == HIPBLAS_OP_T

    - Supported precisions in rocBLAS : s,d,c,z
    - Supported precisions in cuBLAS  : No support

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`) -- *IN*:
            [hipblasHandle_t]
            handle to the hipblas library context queue.

        uplo (`~.hipblasFillMode_t`) -- *IN*:
            [hipblasFillMode_t]
            HIPBLAS_FILL_MODE_UPPER:  C_i is an upper triangular matrix
            HIPBLAS_FILL_MODE_LOWER:  C_i is a  lower triangular matrix

        transA (`~.hipblasOperation_t`) -- *IN*:
            [hipblasOperation_t]
            HIPBLAS_OP_T:      op( A_i ) = A_i^T, op( B_i ) = B_i^T
            HIPBLAS_OP_N:           op( A_i ) = A_i, op( B_i ) = B_i

        n (`~.int`) -- *IN*:
            [int]
            n specifies the number of rows and columns of C_i. n >= 0.

        k (`~.int`) -- *IN*:
            [int]
            k specifies the number of columns of op(A). k >= 0.

        alpha (`~.hip._util.types.Pointer`/`~.object`) -- *IN*:
            alpha specifies the scalar alpha. When alpha is
            zero then A is not referenced and A need not be set before
            entry.

        AP (`~.hip._util.types.Pointer`/`~.object`) -- *IN*:
            Device pointer to the first matrix A_1 on the GPU of dimension (lda, k)
            when trans is HIPBLAS_OP_N, otherwise of dimension (lda, n)

        lda (`~.int`) -- *IN*:
            [int]
            lda specifies the first dimension of A_i.
            if trans = HIPBLAS_OP_N,  lda >= max( 1, n ),
            otherwise lda >= max( 1, k ).

        strideA (`~.int`) -- *IN*:
            [hipblasStride]
            stride from the start of one matrix (A_i) and the next one (A_i+1)

        BP (`~.hip._util.types.Pointer`/`~.object`) -- *IN*:
            Device pointer to the first matrix B_1 on the GPU of dimension (ldb, k)
            when trans is HIPBLAS_OP_N, otherwise of dimension (ldb, n)

        ldb (`~.int`) -- *IN*:
            [int]
            ldb specifies the first dimension of B_i.
            if trans = HIPBLAS_OP_N,  ldb >= max( 1, n ),
            otherwise ldb >= max( 1, k ).

        strideB (`~.int`) -- *IN*:
            [hipblasStride]
            stride from the start of one matrix (B_i) and the next one (B_i+1)

        beta (`~.hip._util.types.Pointer`/`~.object`) -- *IN*:
            beta specifies the scalar beta. When beta is
            zero then C need not be set before entry.

        CP (`~.hip._util.types.Pointer`/`~.object`) -- *IN*:
            Device pointer to the first matrix C_1 on the GPU.

        ldc (`~.int`) -- *IN*:
            [int]
            ldc specifies the first dimension of C. ldc >= max( 1, n ).

        strideC (`~.int`) -- *INOUT*:
            [hipblasStride]
            stride from the start of one matrix (C_i) and the next one (C_i+1)

        batchCount (`~.int`) -- *IN*:
            [int]
            number of instances in the batch.
    """
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")                    
    if not isinstance(transA,_hipblasOperation_t__Base):
        raise TypeError("argument 'transA' must be of type '_hipblasOperation_t__Base'")
    _hipblasSsyrkxStridedBatched__retval = hipblasStatus_t(chipblas.hipblasSsyrkxStridedBatched(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,uplo.value,transA.value,n,k,
        <const float *>hip._util.types.Pointer.fromPyobj(alpha)._ptr,
        <const float *>hip._util.types.Pointer.fromPyobj(AP)._ptr,lda,strideA,
        <const float *>hip._util.types.Pointer.fromPyobj(BP)._ptr,ldb,strideB,
        <const float *>hip._util.types.Pointer.fromPyobj(beta)._ptr,
        <float *>hip._util.types.Pointer.fromPyobj(CP)._ptr,ldc,strideC,batchCount))
    return (_hipblasSsyrkxStridedBatched__retval,)


@cython.embedsignature(True)
def hipblasDsyrkxStridedBatched(object handle, object uplo, object transA, int n, int k, object alpha, object AP, int lda, long strideA, object BP, int ldb, long strideB, object beta, object CP, int ldc, long strideC, int batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        uplo (`~.hipblasFillMode_t`):
            (undocumented)

        transA (`~.hipblasOperation_t`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        k (`~.int`):
            (undocumented)

        alpha (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        AP (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        strideA (`~.int`):
            (undocumented)

        BP (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        ldb (`~.int`):
            (undocumented)

        strideB (`~.int`):
            (undocumented)

        beta (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        CP (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        ldc (`~.int`):
            (undocumented)

        strideC (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")                    
    if not isinstance(transA,_hipblasOperation_t__Base):
        raise TypeError("argument 'transA' must be of type '_hipblasOperation_t__Base'")
    _hipblasDsyrkxStridedBatched__retval = hipblasStatus_t(chipblas.hipblasDsyrkxStridedBatched(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,uplo.value,transA.value,n,k,
        <const double *>hip._util.types.Pointer.fromPyobj(alpha)._ptr,
        <const double *>hip._util.types.Pointer.fromPyobj(AP)._ptr,lda,strideA,
        <const double *>hip._util.types.Pointer.fromPyobj(BP)._ptr,ldb,strideB,
        <const double *>hip._util.types.Pointer.fromPyobj(beta)._ptr,
        <double *>hip._util.types.Pointer.fromPyobj(CP)._ptr,ldc,strideC,batchCount))
    return (_hipblasDsyrkxStridedBatched__retval,)


@cython.embedsignature(True)
def hipblasCsyrkxStridedBatched(object handle, object uplo, object transA, int n, int k, object alpha, object AP, int lda, long strideA, object BP, int ldb, long strideB, object beta, object CP, int ldc, long strideC, int batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        uplo (`~.hipblasFillMode_t`):
            (undocumented)

        transA (`~.hipblasOperation_t`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        k (`~.int`):
            (undocumented)

        alpha (`~.hipblasComplex`/`~.object`):
            (undocumented)

        AP (`~.hipblasComplex`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        strideA (`~.int`):
            (undocumented)

        BP (`~.hipblasComplex`/`~.object`):
            (undocumented)

        ldb (`~.int`):
            (undocumented)

        strideB (`~.int`):
            (undocumented)

        beta (`~.hipblasComplex`/`~.object`):
            (undocumented)

        CP (`~.hipblasComplex`/`~.object`):
            (undocumented)

        ldc (`~.int`):
            (undocumented)

        strideC (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")                    
    if not isinstance(transA,_hipblasOperation_t__Base):
        raise TypeError("argument 'transA' must be of type '_hipblasOperation_t__Base'")
    _hipblasCsyrkxStridedBatched__retval = hipblasStatus_t(chipblas.hipblasCsyrkxStridedBatched(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,uplo.value,transA.value,n,k,
        hipblasComplex.fromPyobj(alpha).getElementPtr(),
        hipblasComplex.fromPyobj(AP).getElementPtr(),lda,strideA,
        hipblasComplex.fromPyobj(BP).getElementPtr(),ldb,strideB,
        hipblasComplex.fromPyobj(beta).getElementPtr(),
        hipblasComplex.fromPyobj(CP).getElementPtr(),ldc,strideC,batchCount))
    return (_hipblasCsyrkxStridedBatched__retval,)


@cython.embedsignature(True)
def hipblasZsyrkxStridedBatched(object handle, object uplo, object transA, int n, int k, object alpha, object AP, int lda, long strideA, object BP, int ldb, long strideB, object beta, object CP, int ldc, long strideC, int batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        uplo (`~.hipblasFillMode_t`):
            (undocumented)

        transA (`~.hipblasOperation_t`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        k (`~.int`):
            (undocumented)

        alpha (`~.hipblasDoubleComplex`/`~.object`):
            (undocumented)

        AP (`~.hipblasDoubleComplex`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        strideA (`~.int`):
            (undocumented)

        BP (`~.hipblasDoubleComplex`/`~.object`):
            (undocumented)

        ldb (`~.int`):
            (undocumented)

        strideB (`~.int`):
            (undocumented)

        beta (`~.hipblasDoubleComplex`/`~.object`):
            (undocumented)

        CP (`~.hipblasDoubleComplex`/`~.object`):
            (undocumented)

        ldc (`~.int`):
            (undocumented)

        strideC (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")                    
    if not isinstance(transA,_hipblasOperation_t__Base):
        raise TypeError("argument 'transA' must be of type '_hipblasOperation_t__Base'")
    _hipblasZsyrkxStridedBatched__retval = hipblasStatus_t(chipblas.hipblasZsyrkxStridedBatched(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,uplo.value,transA.value,n,k,
        hipblasDoubleComplex.fromPyobj(alpha).getElementPtr(),
        hipblasDoubleComplex.fromPyobj(AP).getElementPtr(),lda,strideA,
        hipblasDoubleComplex.fromPyobj(BP).getElementPtr(),ldb,strideB,
        hipblasDoubleComplex.fromPyobj(beta).getElementPtr(),
        hipblasDoubleComplex.fromPyobj(CP).getElementPtr(),ldc,strideC,batchCount))
    return (_hipblasZsyrkxStridedBatched__retval,)


@cython.embedsignature(True)
def hipblasCsyrkxStridedBatched_v2(object handle, object uplo, object transA, int n, int k, object alpha, object AP, int lda, long strideA, object BP, int ldb, long strideB, object beta, object CP, int ldc, long strideC, int batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        uplo (`~.hipblasFillMode_t`):
            (undocumented)

        transA (`~.hipblasOperation_t`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        k (`~.int`):
            (undocumented)

        alpha (`~.float2`/`~.object`):
            (undocumented)

        AP (`~.float2`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        strideA (`~.int`):
            (undocumented)

        BP (`~.float2`/`~.object`):
            (undocumented)

        ldb (`~.int`):
            (undocumented)

        strideB (`~.int`):
            (undocumented)

        beta (`~.float2`/`~.object`):
            (undocumented)

        CP (`~.float2`/`~.object`):
            (undocumented)

        ldc (`~.int`):
            (undocumented)

        strideC (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")                    
    if not isinstance(transA,_hipblasOperation_t__Base):
        raise TypeError("argument 'transA' must be of type '_hipblasOperation_t__Base'")
    _hipblasCsyrkxStridedBatched_v2__retval = hipblasStatus_t(chipblas.hipblasCsyrkxStridedBatched_v2(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,uplo.value,transA.value,n,k,
        float2.fromPyobj(alpha).getElementPtr(),
        float2.fromPyobj(AP).getElementPtr(),lda,strideA,
        float2.fromPyobj(BP).getElementPtr(),ldb,strideB,
        float2.fromPyobj(beta).getElementPtr(),
        float2.fromPyobj(CP).getElementPtr(),ldc,strideC,batchCount))
    return (_hipblasCsyrkxStridedBatched_v2__retval,)


@cython.embedsignature(True)
def hipblasZsyrkxStridedBatched_v2(object handle, object uplo, object transA, int n, int k, object alpha, object AP, int lda, long strideA, object BP, int ldb, long strideB, object beta, object CP, int ldc, long strideC, int batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        uplo (`~.hipblasFillMode_t`):
            (undocumented)

        transA (`~.hipblasOperation_t`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        k (`~.int`):
            (undocumented)

        alpha (`~.double2`/`~.object`):
            (undocumented)

        AP (`~.double2`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        strideA (`~.int`):
            (undocumented)

        BP (`~.double2`/`~.object`):
            (undocumented)

        ldb (`~.int`):
            (undocumented)

        strideB (`~.int`):
            (undocumented)

        beta (`~.double2`/`~.object`):
            (undocumented)

        CP (`~.double2`/`~.object`):
            (undocumented)

        ldc (`~.int`):
            (undocumented)

        strideC (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")                    
    if not isinstance(transA,_hipblasOperation_t__Base):
        raise TypeError("argument 'transA' must be of type '_hipblasOperation_t__Base'")
    _hipblasZsyrkxStridedBatched_v2__retval = hipblasStatus_t(chipblas.hipblasZsyrkxStridedBatched_v2(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,uplo.value,transA.value,n,k,
        double2.fromPyobj(alpha).getElementPtr(),
        double2.fromPyobj(AP).getElementPtr(),lda,strideA,
        double2.fromPyobj(BP).getElementPtr(),ldb,strideB,
        double2.fromPyobj(beta).getElementPtr(),
        double2.fromPyobj(CP).getElementPtr(),ldc,strideC,batchCount))
    return (_hipblasZsyrkxStridedBatched_v2__retval,)


@cython.embedsignature(True)
def hipblasSgeam(object handle, object transA, object transB, int m, int n, object alpha, object AP, int lda, object beta, object BP, int ldb, object CP, int ldc):
    r"""BLAS Level 3 API

    @{

    geam performs one of the matrix-matrix operations

    C = alpha*op( A ) + beta*op( B ),

    where op( X ) is one of

        op( X ) = X      or
        op( X ) = X**T   or
        op( X ) = X**H,

    alpha and beta are scalars, and A, B and C are matrices, with
    op( A ) an m by n matrix, op( B ) an m by n matrix, and C an m by n matrix.

    - Supported precisions in rocBLAS : s,d,c,z
    - Supported precisions in cuBLAS  : s,d,c,z

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`) -- *IN*:
            [hipblasHandle_t]
            handle to the hipblas library context queue.

        transA (`~.hipblasOperation_t`) -- *IN*:
            [hipblasOperation_t]
            specifies the form of op( A )

        transB (`~.hipblasOperation_t`) -- *IN*:
            [hipblasOperation_t]
            specifies the form of op( B )

        m (`~.int`) -- *IN*:
            [int]
            matrix dimension m.

        n (`~.int`) -- *IN*:
            [int]
            matrix dimension n.

        alpha (`~.hip._util.types.Pointer`/`~.object`) -- *IN*:
            device pointer or host pointer specifying the scalar alpha.

        AP (`~.hip._util.types.Pointer`/`~.object`) -- *IN*:
            device pointer storing matrix A.

        lda (`~.int`) -- *IN*:
            [int]
            specifies the leading dimension of A.

        beta (`~.hip._util.types.Pointer`/`~.object`) -- *IN*:
            device pointer or host pointer specifying the scalar beta.

        BP (`~.hip._util.types.Pointer`/`~.object`) -- *IN*:
            device pointer storing matrix B.

        ldb (`~.int`) -- *IN*:
            [int]
            specifies the leading dimension of B.

        CP (`~.hip._util.types.Pointer`/`~.object`) -- *IN,OUT*:
            device pointer storing matrix C.

        ldc (`~.int`) -- *IN*:
            [int]
            specifies the leading dimension of C.
    """
    if not isinstance(transA,_hipblasOperation_t__Base):
        raise TypeError("argument 'transA' must be of type '_hipblasOperation_t__Base'")                    
    if not isinstance(transB,_hipblasOperation_t__Base):
        raise TypeError("argument 'transB' must be of type '_hipblasOperation_t__Base'")
    _hipblasSgeam__retval = hipblasStatus_t(chipblas.hipblasSgeam(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,transA.value,transB.value,m,n,
        <const float *>hip._util.types.Pointer.fromPyobj(alpha)._ptr,
        <const float *>hip._util.types.Pointer.fromPyobj(AP)._ptr,lda,
        <const float *>hip._util.types.Pointer.fromPyobj(beta)._ptr,
        <const float *>hip._util.types.Pointer.fromPyobj(BP)._ptr,ldb,
        <float *>hip._util.types.Pointer.fromPyobj(CP)._ptr,ldc))
    return (_hipblasSgeam__retval,)


@cython.embedsignature(True)
def hipblasDgeam(object handle, object transA, object transB, int m, int n, object alpha, object AP, int lda, object beta, object BP, int ldb, object CP, int ldc):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        transA (`~.hipblasOperation_t`):
            (undocumented)

        transB (`~.hipblasOperation_t`):
            (undocumented)

        m (`~.int`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        alpha (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        AP (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        beta (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        BP (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        ldb (`~.int`):
            (undocumented)

        CP (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        ldc (`~.int`):
            (undocumented)
    """
    if not isinstance(transA,_hipblasOperation_t__Base):
        raise TypeError("argument 'transA' must be of type '_hipblasOperation_t__Base'")                    
    if not isinstance(transB,_hipblasOperation_t__Base):
        raise TypeError("argument 'transB' must be of type '_hipblasOperation_t__Base'")
    _hipblasDgeam__retval = hipblasStatus_t(chipblas.hipblasDgeam(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,transA.value,transB.value,m,n,
        <const double *>hip._util.types.Pointer.fromPyobj(alpha)._ptr,
        <const double *>hip._util.types.Pointer.fromPyobj(AP)._ptr,lda,
        <const double *>hip._util.types.Pointer.fromPyobj(beta)._ptr,
        <const double *>hip._util.types.Pointer.fromPyobj(BP)._ptr,ldb,
        <double *>hip._util.types.Pointer.fromPyobj(CP)._ptr,ldc))
    return (_hipblasDgeam__retval,)


@cython.embedsignature(True)
def hipblasCgeam(object handle, object transA, object transB, int m, int n, object alpha, object AP, int lda, object beta, object BP, int ldb, object CP, int ldc):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        transA (`~.hipblasOperation_t`):
            (undocumented)

        transB (`~.hipblasOperation_t`):
            (undocumented)

        m (`~.int`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        alpha (`~.hipblasComplex`/`~.object`):
            (undocumented)

        AP (`~.hipblasComplex`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        beta (`~.hipblasComplex`/`~.object`):
            (undocumented)

        BP (`~.hipblasComplex`/`~.object`):
            (undocumented)

        ldb (`~.int`):
            (undocumented)

        CP (`~.hipblasComplex`/`~.object`):
            (undocumented)

        ldc (`~.int`):
            (undocumented)
    """
    if not isinstance(transA,_hipblasOperation_t__Base):
        raise TypeError("argument 'transA' must be of type '_hipblasOperation_t__Base'")                    
    if not isinstance(transB,_hipblasOperation_t__Base):
        raise TypeError("argument 'transB' must be of type '_hipblasOperation_t__Base'")
    _hipblasCgeam__retval = hipblasStatus_t(chipblas.hipblasCgeam(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,transA.value,transB.value,m,n,
        hipblasComplex.fromPyobj(alpha).getElementPtr(),
        hipblasComplex.fromPyobj(AP).getElementPtr(),lda,
        hipblasComplex.fromPyobj(beta).getElementPtr(),
        hipblasComplex.fromPyobj(BP).getElementPtr(),ldb,
        hipblasComplex.fromPyobj(CP).getElementPtr(),ldc))
    return (_hipblasCgeam__retval,)


@cython.embedsignature(True)
def hipblasZgeam(object handle, object transA, object transB, int m, int n, object alpha, object AP, int lda, object beta, object BP, int ldb, object CP, int ldc):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        transA (`~.hipblasOperation_t`):
            (undocumented)

        transB (`~.hipblasOperation_t`):
            (undocumented)

        m (`~.int`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        alpha (`~.hipblasDoubleComplex`/`~.object`):
            (undocumented)

        AP (`~.hipblasDoubleComplex`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        beta (`~.hipblasDoubleComplex`/`~.object`):
            (undocumented)

        BP (`~.hipblasDoubleComplex`/`~.object`):
            (undocumented)

        ldb (`~.int`):
            (undocumented)

        CP (`~.hipblasDoubleComplex`/`~.object`):
            (undocumented)

        ldc (`~.int`):
            (undocumented)
    """
    if not isinstance(transA,_hipblasOperation_t__Base):
        raise TypeError("argument 'transA' must be of type '_hipblasOperation_t__Base'")                    
    if not isinstance(transB,_hipblasOperation_t__Base):
        raise TypeError("argument 'transB' must be of type '_hipblasOperation_t__Base'")
    _hipblasZgeam__retval = hipblasStatus_t(chipblas.hipblasZgeam(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,transA.value,transB.value,m,n,
        hipblasDoubleComplex.fromPyobj(alpha).getElementPtr(),
        hipblasDoubleComplex.fromPyobj(AP).getElementPtr(),lda,
        hipblasDoubleComplex.fromPyobj(beta).getElementPtr(),
        hipblasDoubleComplex.fromPyobj(BP).getElementPtr(),ldb,
        hipblasDoubleComplex.fromPyobj(CP).getElementPtr(),ldc))
    return (_hipblasZgeam__retval,)


@cython.embedsignature(True)
def hipblasCgeam_v2(object handle, object transA, object transB, int m, int n, object alpha, object AP, int lda, object beta, object BP, int ldb, object CP, int ldc):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        transA (`~.hipblasOperation_t`):
            (undocumented)

        transB (`~.hipblasOperation_t`):
            (undocumented)

        m (`~.int`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        alpha (`~.float2`/`~.object`):
            (undocumented)

        AP (`~.float2`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        beta (`~.float2`/`~.object`):
            (undocumented)

        BP (`~.float2`/`~.object`):
            (undocumented)

        ldb (`~.int`):
            (undocumented)

        CP (`~.float2`/`~.object`):
            (undocumented)

        ldc (`~.int`):
            (undocumented)
    """
    if not isinstance(transA,_hipblasOperation_t__Base):
        raise TypeError("argument 'transA' must be of type '_hipblasOperation_t__Base'")                    
    if not isinstance(transB,_hipblasOperation_t__Base):
        raise TypeError("argument 'transB' must be of type '_hipblasOperation_t__Base'")
    _hipblasCgeam_v2__retval = hipblasStatus_t(chipblas.hipblasCgeam_v2(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,transA.value,transB.value,m,n,
        float2.fromPyobj(alpha).getElementPtr(),
        float2.fromPyobj(AP).getElementPtr(),lda,
        float2.fromPyobj(beta).getElementPtr(),
        float2.fromPyobj(BP).getElementPtr(),ldb,
        float2.fromPyobj(CP).getElementPtr(),ldc))
    return (_hipblasCgeam_v2__retval,)


@cython.embedsignature(True)
def hipblasZgeam_v2(object handle, object transA, object transB, int m, int n, object alpha, object AP, int lda, object beta, object BP, int ldb, object CP, int ldc):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        transA (`~.hipblasOperation_t`):
            (undocumented)

        transB (`~.hipblasOperation_t`):
            (undocumented)

        m (`~.int`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        alpha (`~.double2`/`~.object`):
            (undocumented)

        AP (`~.double2`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        beta (`~.double2`/`~.object`):
            (undocumented)

        BP (`~.double2`/`~.object`):
            (undocumented)

        ldb (`~.int`):
            (undocumented)

        CP (`~.double2`/`~.object`):
            (undocumented)

        ldc (`~.int`):
            (undocumented)
    """
    if not isinstance(transA,_hipblasOperation_t__Base):
        raise TypeError("argument 'transA' must be of type '_hipblasOperation_t__Base'")                    
    if not isinstance(transB,_hipblasOperation_t__Base):
        raise TypeError("argument 'transB' must be of type '_hipblasOperation_t__Base'")
    _hipblasZgeam_v2__retval = hipblasStatus_t(chipblas.hipblasZgeam_v2(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,transA.value,transB.value,m,n,
        double2.fromPyobj(alpha).getElementPtr(),
        double2.fromPyobj(AP).getElementPtr(),lda,
        double2.fromPyobj(beta).getElementPtr(),
        double2.fromPyobj(BP).getElementPtr(),ldb,
        double2.fromPyobj(CP).getElementPtr(),ldc))
    return (_hipblasZgeam_v2__retval,)


@cython.embedsignature(True)
def hipblasSgeamBatched(object handle, object transA, object transB, int m, int n, object alpha, object AP, int lda, object beta, object BP, int ldb, object CP, int ldc, int batchCount):
    r"""BLAS Level 3 API

    @{

    geamBatched performs one of the batched matrix-matrix operations

    C_i = alpha*op( A_i ) + beta*op( B_i )  for i = 0, 1, ... batchCount - 1

    where alpha and beta are scalars, and op(A_i), op(B_i) and C_i are m by n matrices
    and op( X ) is one of

        op( X ) = X      or
        op( X ) = X**T

    - Supported precisions in rocBLAS : s,d,c,z
    - Supported precisions in cuBLAS  : No support

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`) -- *IN*:
            [hipblasHandle_t]
            handle to the hipblas library context queue.

        transA (`~.hipblasOperation_t`) -- *IN*:
            [hipblasOperation_t]
            specifies the form of op( A )

        transB (`~.hipblasOperation_t`) -- *IN*:
            [hipblasOperation_t]
            specifies the form of op( B )

        m (`~.int`) -- *IN*:
            [int]
            matrix dimension m.

        n (`~.int`) -- *IN*:
            [int]
            matrix dimension n.

        alpha (`~.hip._util.types.Pointer`/`~.object`) -- *IN*:
            device pointer or host pointer specifying the scalar alpha.

        AP (`~.hip._util.types.Pointer`/`~.object`) -- *IN*:
            device array of device pointers storing each matrix A_i on the GPU.
            Each A_i is of dimension ( lda, k ), where k is m
            when  transA == HIPBLAS_OP_N and
            is  n  when  transA == HIPBLAS_OP_T.

        lda (`~.int`) -- *IN*:
            [int]
            specifies the leading dimension of A.

        beta (`~.hip._util.types.Pointer`/`~.object`) -- *IN*:
            device pointer or host pointer specifying the scalar beta.

        BP (`~.hip._util.types.Pointer`/`~.object`) -- *IN*:
            device array of device pointers storing each matrix B_i on the GPU.
            Each B_i is of dimension ( ldb, k ), where k is m
            when  transB == HIPBLAS_OP_N and
            is  n  when  transB == HIPBLAS_OP_T.

        ldb (`~.int`) -- *IN*:
            [int]
            specifies the leading dimension of B.

        CP (`~.hip._util.types.Pointer`/`~.object`) -- *IN,OUT*:
            device array of device pointers storing each matrix C_i on the GPU.
            Each C_i is of dimension ( ldc, n ).

        ldc (`~.int`) -- *IN*:
            [int]
            specifies the leading dimension of C.

        batchCount (`~.int`) -- *IN*:
            [int]
            number of instances i in the batch.
    """
    if not isinstance(transA,_hipblasOperation_t__Base):
        raise TypeError("argument 'transA' must be of type '_hipblasOperation_t__Base'")                    
    if not isinstance(transB,_hipblasOperation_t__Base):
        raise TypeError("argument 'transB' must be of type '_hipblasOperation_t__Base'")
    _hipblasSgeamBatched__retval = hipblasStatus_t(chipblas.hipblasSgeamBatched(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,transA.value,transB.value,m,n,
        <const float *>hip._util.types.Pointer.fromPyobj(alpha)._ptr,
        <const float *const*>hip._util.types.Pointer.fromPyobj(AP)._ptr,lda,
        <const float *>hip._util.types.Pointer.fromPyobj(beta)._ptr,
        <const float *const*>hip._util.types.Pointer.fromPyobj(BP)._ptr,ldb,
        <float *const*>hip._util.types.Pointer.fromPyobj(CP)._ptr,ldc,batchCount))
    return (_hipblasSgeamBatched__retval,)


@cython.embedsignature(True)
def hipblasDgeamBatched(object handle, object transA, object transB, int m, int n, object alpha, object AP, int lda, object beta, object BP, int ldb, object CP, int ldc, int batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        transA (`~.hipblasOperation_t`):
            (undocumented)

        transB (`~.hipblasOperation_t`):
            (undocumented)

        m (`~.int`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        alpha (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        AP (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        beta (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        BP (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        ldb (`~.int`):
            (undocumented)

        CP (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        ldc (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    if not isinstance(transA,_hipblasOperation_t__Base):
        raise TypeError("argument 'transA' must be of type '_hipblasOperation_t__Base'")                    
    if not isinstance(transB,_hipblasOperation_t__Base):
        raise TypeError("argument 'transB' must be of type '_hipblasOperation_t__Base'")
    _hipblasDgeamBatched__retval = hipblasStatus_t(chipblas.hipblasDgeamBatched(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,transA.value,transB.value,m,n,
        <const double *>hip._util.types.Pointer.fromPyobj(alpha)._ptr,
        <const double *const*>hip._util.types.Pointer.fromPyobj(AP)._ptr,lda,
        <const double *>hip._util.types.Pointer.fromPyobj(beta)._ptr,
        <const double *const*>hip._util.types.Pointer.fromPyobj(BP)._ptr,ldb,
        <double *const*>hip._util.types.Pointer.fromPyobj(CP)._ptr,ldc,batchCount))
    return (_hipblasDgeamBatched__retval,)


@cython.embedsignature(True)
def hipblasCgeamBatched(object handle, object transA, object transB, int m, int n, object alpha, object AP, int lda, object beta, object BP, int ldb, object CP, int ldc, int batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        transA (`~.hipblasOperation_t`):
            (undocumented)

        transB (`~.hipblasOperation_t`):
            (undocumented)

        m (`~.int`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        alpha (`~.hipblasComplex`/`~.object`):
            (undocumented)

        AP (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        beta (`~.hipblasComplex`/`~.object`):
            (undocumented)

        BP (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        ldb (`~.int`):
            (undocumented)

        CP (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        ldc (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    if not isinstance(transA,_hipblasOperation_t__Base):
        raise TypeError("argument 'transA' must be of type '_hipblasOperation_t__Base'")                    
    if not isinstance(transB,_hipblasOperation_t__Base):
        raise TypeError("argument 'transB' must be of type '_hipblasOperation_t__Base'")
    _hipblasCgeamBatched__retval = hipblasStatus_t(chipblas.hipblasCgeamBatched(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,transA.value,transB.value,m,n,
        hipblasComplex.fromPyobj(alpha).getElementPtr(),
        <chipblas.hipblasComplex *const*>hip._util.types.Pointer.fromPyobj(AP)._ptr,lda,
        hipblasComplex.fromPyobj(beta).getElementPtr(),
        <chipblas.hipblasComplex *const*>hip._util.types.Pointer.fromPyobj(BP)._ptr,ldb,
        <chipblas.hipblasComplex *const*>hip._util.types.Pointer.fromPyobj(CP)._ptr,ldc,batchCount))
    return (_hipblasCgeamBatched__retval,)


@cython.embedsignature(True)
def hipblasZgeamBatched(object handle, object transA, object transB, int m, int n, object alpha, object AP, int lda, object beta, object BP, int ldb, object CP, int ldc, int batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        transA (`~.hipblasOperation_t`):
            (undocumented)

        transB (`~.hipblasOperation_t`):
            (undocumented)

        m (`~.int`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        alpha (`~.hipblasDoubleComplex`/`~.object`):
            (undocumented)

        AP (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        beta (`~.hipblasDoubleComplex`/`~.object`):
            (undocumented)

        BP (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        ldb (`~.int`):
            (undocumented)

        CP (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        ldc (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    if not isinstance(transA,_hipblasOperation_t__Base):
        raise TypeError("argument 'transA' must be of type '_hipblasOperation_t__Base'")                    
    if not isinstance(transB,_hipblasOperation_t__Base):
        raise TypeError("argument 'transB' must be of type '_hipblasOperation_t__Base'")
    _hipblasZgeamBatched__retval = hipblasStatus_t(chipblas.hipblasZgeamBatched(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,transA.value,transB.value,m,n,
        hipblasDoubleComplex.fromPyobj(alpha).getElementPtr(),
        <chipblas.hipblasDoubleComplex *const*>hip._util.types.Pointer.fromPyobj(AP)._ptr,lda,
        hipblasDoubleComplex.fromPyobj(beta).getElementPtr(),
        <chipblas.hipblasDoubleComplex *const*>hip._util.types.Pointer.fromPyobj(BP)._ptr,ldb,
        <chipblas.hipblasDoubleComplex *const*>hip._util.types.Pointer.fromPyobj(CP)._ptr,ldc,batchCount))
    return (_hipblasZgeamBatched__retval,)


@cython.embedsignature(True)
def hipblasCgeamBatched_v2(object handle, object transA, object transB, int m, int n, object alpha, object AP, int lda, object beta, object BP, int ldb, object CP, int ldc, int batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        transA (`~.hipblasOperation_t`):
            (undocumented)

        transB (`~.hipblasOperation_t`):
            (undocumented)

        m (`~.int`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        alpha (`~.float2`/`~.object`):
            (undocumented)

        AP (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        beta (`~.float2`/`~.object`):
            (undocumented)

        BP (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        ldb (`~.int`):
            (undocumented)

        CP (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        ldc (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    if not isinstance(transA,_hipblasOperation_t__Base):
        raise TypeError("argument 'transA' must be of type '_hipblasOperation_t__Base'")                    
    if not isinstance(transB,_hipblasOperation_t__Base):
        raise TypeError("argument 'transB' must be of type '_hipblasOperation_t__Base'")
    _hipblasCgeamBatched_v2__retval = hipblasStatus_t(chipblas.hipblasCgeamBatched_v2(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,transA.value,transB.value,m,n,
        float2.fromPyobj(alpha).getElementPtr(),
        <chipblas.float2 *const*>hip._util.types.Pointer.fromPyobj(AP)._ptr,lda,
        float2.fromPyobj(beta).getElementPtr(),
        <chipblas.float2 *const*>hip._util.types.Pointer.fromPyobj(BP)._ptr,ldb,
        <chipblas.float2 *const*>hip._util.types.Pointer.fromPyobj(CP)._ptr,ldc,batchCount))
    return (_hipblasCgeamBatched_v2__retval,)


@cython.embedsignature(True)
def hipblasZgeamBatched_v2(object handle, object transA, object transB, int m, int n, object alpha, object AP, int lda, object beta, object BP, int ldb, object CP, int ldc, int batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        transA (`~.hipblasOperation_t`):
            (undocumented)

        transB (`~.hipblasOperation_t`):
            (undocumented)

        m (`~.int`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        alpha (`~.double2`/`~.object`):
            (undocumented)

        AP (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        beta (`~.double2`/`~.object`):
            (undocumented)

        BP (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        ldb (`~.int`):
            (undocumented)

        CP (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        ldc (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    if not isinstance(transA,_hipblasOperation_t__Base):
        raise TypeError("argument 'transA' must be of type '_hipblasOperation_t__Base'")                    
    if not isinstance(transB,_hipblasOperation_t__Base):
        raise TypeError("argument 'transB' must be of type '_hipblasOperation_t__Base'")
    _hipblasZgeamBatched_v2__retval = hipblasStatus_t(chipblas.hipblasZgeamBatched_v2(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,transA.value,transB.value,m,n,
        double2.fromPyobj(alpha).getElementPtr(),
        <chipblas.double2 *const*>hip._util.types.Pointer.fromPyobj(AP)._ptr,lda,
        double2.fromPyobj(beta).getElementPtr(),
        <chipblas.double2 *const*>hip._util.types.Pointer.fromPyobj(BP)._ptr,ldb,
        <chipblas.double2 *const*>hip._util.types.Pointer.fromPyobj(CP)._ptr,ldc,batchCount))
    return (_hipblasZgeamBatched_v2__retval,)


@cython.embedsignature(True)
def hipblasSgeamStridedBatched(object handle, object transA, object transB, int m, int n, object alpha, object AP, int lda, long strideA, object beta, object BP, int ldb, long strideB, object CP, int ldc, long strideC, int batchCount):
    r"""BLAS Level 3 API

    @{

    geamStridedBatched performs one of the batched matrix-matrix operations

    C_i = alpha*op( A_i ) + beta*op( B_i )  for i = 0, 1, ... batchCount - 1

    where alpha and beta are scalars, and op(A_i), op(B_i) and C_i are m by n matrices
    and op( X ) is one of

        op( X ) = X      or
        op( X ) = X**T

    - Supported precisions in rocBLAS : s,d,c,z
    - Supported precisions in cuBLAS  : No support

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`) -- *IN*:
            [hipblasHandle_t]
            handle to the hipblas library context queue.

        transA (`~.hipblasOperation_t`) -- *IN*:
            [hipblasOperation_t]
            specifies the form of op( A )

        transB (`~.hipblasOperation_t`) -- *IN*:
            [hipblasOperation_t]
            specifies the form of op( B )

        m (`~.int`) -- *IN*:
            [int]
            matrix dimension m.

        n (`~.int`) -- *IN*:
            [int]
            matrix dimension n.

        alpha (`~.hip._util.types.Pointer`/`~.object`) -- *IN*:
            device pointer or host pointer specifying the scalar alpha.

        AP (`~.hip._util.types.Pointer`/`~.object`) -- *IN*:
            device pointer to the first matrix A_0 on the GPU.
            Each A_i is of dimension ( lda, k ), where k is m
            when  transA == HIPBLAS_OP_N and
            is  n  when  transA == HIPBLAS_OP_T.

        lda (`~.int`) -- *IN*:
            [int]
            specifies the leading dimension of A.

        strideA (`~.int`) -- *IN*:
            [hipblasStride]
            stride from the start of one matrix (A_i) and the next one (A_i+1)

        beta (`~.hip._util.types.Pointer`/`~.object`) -- *IN*:
            device pointer or host pointer specifying the scalar beta.

        BP (`~.hip._util.types.Pointer`/`~.object`) -- *IN*:
            pointer to the first matrix B_0 on the GPU.
            Each B_i is of dimension ( ldb, k ), where k is m
            when  transB == HIPBLAS_OP_N and
            is  n  when  transB == HIPBLAS_OP_T.

        ldb (`~.int`) -- *IN*:
            [int]
            specifies the leading dimension of B.

        strideB (`~.int`) -- *IN*:
            [hipblasStride]
            stride from the start of one matrix (B_i) and the next one (B_i+1)

        CP (`~.hip._util.types.Pointer`/`~.object`) -- *IN,OUT*:
            pointer to the first matrix C_0 on the GPU.
            Each C_i is of dimension ( ldc, n ).

        ldc (`~.int`) -- *IN*:
            [int]
            specifies the leading dimension of C.

        strideC (`~.int`) -- *IN*:
            [hipblasStride]
            stride from the start of one matrix (C_i) and the next one (C_i+1)

        batchCount (`~.int`) -- *IN*:
            [int]
            number of instances i in the batch.
    """
    if not isinstance(transA,_hipblasOperation_t__Base):
        raise TypeError("argument 'transA' must be of type '_hipblasOperation_t__Base'")                    
    if not isinstance(transB,_hipblasOperation_t__Base):
        raise TypeError("argument 'transB' must be of type '_hipblasOperation_t__Base'")
    _hipblasSgeamStridedBatched__retval = hipblasStatus_t(chipblas.hipblasSgeamStridedBatched(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,transA.value,transB.value,m,n,
        <const float *>hip._util.types.Pointer.fromPyobj(alpha)._ptr,
        <const float *>hip._util.types.Pointer.fromPyobj(AP)._ptr,lda,strideA,
        <const float *>hip._util.types.Pointer.fromPyobj(beta)._ptr,
        <const float *>hip._util.types.Pointer.fromPyobj(BP)._ptr,ldb,strideB,
        <float *>hip._util.types.Pointer.fromPyobj(CP)._ptr,ldc,strideC,batchCount))
    return (_hipblasSgeamStridedBatched__retval,)


@cython.embedsignature(True)
def hipblasDgeamStridedBatched(object handle, object transA, object transB, int m, int n, object alpha, object AP, int lda, long strideA, object beta, object BP, int ldb, long strideB, object CP, int ldc, long strideC, int batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        transA (`~.hipblasOperation_t`):
            (undocumented)

        transB (`~.hipblasOperation_t`):
            (undocumented)

        m (`~.int`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        alpha (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        AP (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        strideA (`~.int`):
            (undocumented)

        beta (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        BP (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        ldb (`~.int`):
            (undocumented)

        strideB (`~.int`):
            (undocumented)

        CP (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        ldc (`~.int`):
            (undocumented)

        strideC (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    if not isinstance(transA,_hipblasOperation_t__Base):
        raise TypeError("argument 'transA' must be of type '_hipblasOperation_t__Base'")                    
    if not isinstance(transB,_hipblasOperation_t__Base):
        raise TypeError("argument 'transB' must be of type '_hipblasOperation_t__Base'")
    _hipblasDgeamStridedBatched__retval = hipblasStatus_t(chipblas.hipblasDgeamStridedBatched(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,transA.value,transB.value,m,n,
        <const double *>hip._util.types.Pointer.fromPyobj(alpha)._ptr,
        <const double *>hip._util.types.Pointer.fromPyobj(AP)._ptr,lda,strideA,
        <const double *>hip._util.types.Pointer.fromPyobj(beta)._ptr,
        <const double *>hip._util.types.Pointer.fromPyobj(BP)._ptr,ldb,strideB,
        <double *>hip._util.types.Pointer.fromPyobj(CP)._ptr,ldc,strideC,batchCount))
    return (_hipblasDgeamStridedBatched__retval,)


@cython.embedsignature(True)
def hipblasCgeamStridedBatched(object handle, object transA, object transB, int m, int n, object alpha, object AP, int lda, long strideA, object beta, object BP, int ldb, long strideB, object CP, int ldc, long strideC, int batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        transA (`~.hipblasOperation_t`):
            (undocumented)

        transB (`~.hipblasOperation_t`):
            (undocumented)

        m (`~.int`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        alpha (`~.hipblasComplex`/`~.object`):
            (undocumented)

        AP (`~.hipblasComplex`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        strideA (`~.int`):
            (undocumented)

        beta (`~.hipblasComplex`/`~.object`):
            (undocumented)

        BP (`~.hipblasComplex`/`~.object`):
            (undocumented)

        ldb (`~.int`):
            (undocumented)

        strideB (`~.int`):
            (undocumented)

        CP (`~.hipblasComplex`/`~.object`):
            (undocumented)

        ldc (`~.int`):
            (undocumented)

        strideC (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    if not isinstance(transA,_hipblasOperation_t__Base):
        raise TypeError("argument 'transA' must be of type '_hipblasOperation_t__Base'")                    
    if not isinstance(transB,_hipblasOperation_t__Base):
        raise TypeError("argument 'transB' must be of type '_hipblasOperation_t__Base'")
    _hipblasCgeamStridedBatched__retval = hipblasStatus_t(chipblas.hipblasCgeamStridedBatched(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,transA.value,transB.value,m,n,
        hipblasComplex.fromPyobj(alpha).getElementPtr(),
        hipblasComplex.fromPyobj(AP).getElementPtr(),lda,strideA,
        hipblasComplex.fromPyobj(beta).getElementPtr(),
        hipblasComplex.fromPyobj(BP).getElementPtr(),ldb,strideB,
        hipblasComplex.fromPyobj(CP).getElementPtr(),ldc,strideC,batchCount))
    return (_hipblasCgeamStridedBatched__retval,)


@cython.embedsignature(True)
def hipblasZgeamStridedBatched(object handle, object transA, object transB, int m, int n, object alpha, object AP, int lda, long strideA, object beta, object BP, int ldb, long strideB, object CP, int ldc, long strideC, int batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        transA (`~.hipblasOperation_t`):
            (undocumented)

        transB (`~.hipblasOperation_t`):
            (undocumented)

        m (`~.int`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        alpha (`~.hipblasDoubleComplex`/`~.object`):
            (undocumented)

        AP (`~.hipblasDoubleComplex`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        strideA (`~.int`):
            (undocumented)

        beta (`~.hipblasDoubleComplex`/`~.object`):
            (undocumented)

        BP (`~.hipblasDoubleComplex`/`~.object`):
            (undocumented)

        ldb (`~.int`):
            (undocumented)

        strideB (`~.int`):
            (undocumented)

        CP (`~.hipblasDoubleComplex`/`~.object`):
            (undocumented)

        ldc (`~.int`):
            (undocumented)

        strideC (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    if not isinstance(transA,_hipblasOperation_t__Base):
        raise TypeError("argument 'transA' must be of type '_hipblasOperation_t__Base'")                    
    if not isinstance(transB,_hipblasOperation_t__Base):
        raise TypeError("argument 'transB' must be of type '_hipblasOperation_t__Base'")
    _hipblasZgeamStridedBatched__retval = hipblasStatus_t(chipblas.hipblasZgeamStridedBatched(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,transA.value,transB.value,m,n,
        hipblasDoubleComplex.fromPyobj(alpha).getElementPtr(),
        hipblasDoubleComplex.fromPyobj(AP).getElementPtr(),lda,strideA,
        hipblasDoubleComplex.fromPyobj(beta).getElementPtr(),
        hipblasDoubleComplex.fromPyobj(BP).getElementPtr(),ldb,strideB,
        hipblasDoubleComplex.fromPyobj(CP).getElementPtr(),ldc,strideC,batchCount))
    return (_hipblasZgeamStridedBatched__retval,)


@cython.embedsignature(True)
def hipblasCgeamStridedBatched_v2(object handle, object transA, object transB, int m, int n, object alpha, object AP, int lda, long strideA, object beta, object BP, int ldb, long strideB, object CP, int ldc, long strideC, int batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        transA (`~.hipblasOperation_t`):
            (undocumented)

        transB (`~.hipblasOperation_t`):
            (undocumented)

        m (`~.int`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        alpha (`~.float2`/`~.object`):
            (undocumented)

        AP (`~.float2`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        strideA (`~.int`):
            (undocumented)

        beta (`~.float2`/`~.object`):
            (undocumented)

        BP (`~.float2`/`~.object`):
            (undocumented)

        ldb (`~.int`):
            (undocumented)

        strideB (`~.int`):
            (undocumented)

        CP (`~.float2`/`~.object`):
            (undocumented)

        ldc (`~.int`):
            (undocumented)

        strideC (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    if not isinstance(transA,_hipblasOperation_t__Base):
        raise TypeError("argument 'transA' must be of type '_hipblasOperation_t__Base'")                    
    if not isinstance(transB,_hipblasOperation_t__Base):
        raise TypeError("argument 'transB' must be of type '_hipblasOperation_t__Base'")
    _hipblasCgeamStridedBatched_v2__retval = hipblasStatus_t(chipblas.hipblasCgeamStridedBatched_v2(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,transA.value,transB.value,m,n,
        float2.fromPyobj(alpha).getElementPtr(),
        float2.fromPyobj(AP).getElementPtr(),lda,strideA,
        float2.fromPyobj(beta).getElementPtr(),
        float2.fromPyobj(BP).getElementPtr(),ldb,strideB,
        float2.fromPyobj(CP).getElementPtr(),ldc,strideC,batchCount))
    return (_hipblasCgeamStridedBatched_v2__retval,)


@cython.embedsignature(True)
def hipblasZgeamStridedBatched_v2(object handle, object transA, object transB, int m, int n, object alpha, object AP, int lda, long strideA, object beta, object BP, int ldb, long strideB, object CP, int ldc, long strideC, int batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        transA (`~.hipblasOperation_t`):
            (undocumented)

        transB (`~.hipblasOperation_t`):
            (undocumented)

        m (`~.int`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        alpha (`~.double2`/`~.object`):
            (undocumented)

        AP (`~.double2`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        strideA (`~.int`):
            (undocumented)

        beta (`~.double2`/`~.object`):
            (undocumented)

        BP (`~.double2`/`~.object`):
            (undocumented)

        ldb (`~.int`):
            (undocumented)

        strideB (`~.int`):
            (undocumented)

        CP (`~.double2`/`~.object`):
            (undocumented)

        ldc (`~.int`):
            (undocumented)

        strideC (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    if not isinstance(transA,_hipblasOperation_t__Base):
        raise TypeError("argument 'transA' must be of type '_hipblasOperation_t__Base'")                    
    if not isinstance(transB,_hipblasOperation_t__Base):
        raise TypeError("argument 'transB' must be of type '_hipblasOperation_t__Base'")
    _hipblasZgeamStridedBatched_v2__retval = hipblasStatus_t(chipblas.hipblasZgeamStridedBatched_v2(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,transA.value,transB.value,m,n,
        double2.fromPyobj(alpha).getElementPtr(),
        double2.fromPyobj(AP).getElementPtr(),lda,strideA,
        double2.fromPyobj(beta).getElementPtr(),
        double2.fromPyobj(BP).getElementPtr(),ldb,strideB,
        double2.fromPyobj(CP).getElementPtr(),ldc,strideC,batchCount))
    return (_hipblasZgeamStridedBatched_v2__retval,)


@cython.embedsignature(True)
def hipblasChemm(object handle, object side, object uplo, int n, int k, object alpha, object AP, int lda, object BP, int ldb, object beta, object CP, int ldc):
    r"""BLAS Level 3 API

    @{

    hemm performs one of the matrix-matrix operations:

    C := alpha*A*B + beta*C if side == HIPBLAS_SIDE_LEFT,
    C := alpha*B*A + beta*C if side == HIPBLAS_SIDE_RIGHT,

    where alpha and beta are scalars, B and C are m by n matrices, and
    A is a Hermitian matrix stored as either upper or lower.

    - Supported precisions in rocBLAS : c,z
    - Supported precisions in cuBLAS  : c,z

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`) -- *IN*:
            [hipblasHandle_t]
            handle to the hipblas library context queue.

        side (`~.hipblasSideMode_t`) -- *IN*:
            [hipblasSideMode_t]
            HIPBLAS_SIDE_LEFT:      C := alpha*A*B + beta*C
            HIPBLAS_SIDE_RIGHT:     C := alpha*B*A + beta*C

        uplo (`~.hipblasFillMode_t`) -- *IN*:
            [hipblasFillMode_t]
            HIPBLAS_FILL_MODE_UPPER:  A is an upper triangular matrix
            HIPBLAS_FILL_MODE_LOWER:  A is a  lower triangular matrix

        n (`~.int`) -- *IN*:
            [int]
            n specifies the number of rows of B and C. n >= 0.

        k (`~.int`) -- *IN*:
            [int]
            n specifies the number of columns of B and C. k >= 0.

        alpha (`~.hipblasComplex`/`~.object`) -- *IN*:
            alpha specifies the scalar alpha. When alpha is
            zero then A and B are not referenced.

        AP (`~.hipblasComplex`/`~.object`) -- *IN*:
            pointer storing matrix A on the GPU.
            A is m by m if side == HIPBLAS_SIDE_LEFT
            A is n by n if side == HIPBLAS_SIDE_RIGHT
            Only the upper/lower triangular part is accessed.
            The imaginary component of the diagonal elements is not used.

        lda (`~.int`) -- *IN*:
            [int]
            lda specifies the first dimension of A.
            if side = HIPBLAS_SIDE_LEFT,  lda >= max( 1, m ),
            otherwise lda >= max( 1, n ).

        BP (`~.hipblasComplex`/`~.object`) -- *IN*:
            pointer storing matrix B on the GPU.
            Matrix dimension is m by n

        ldb (`~.int`) -- *IN*:
            [int]
            ldb specifies the first dimension of B. ldb >= max( 1, m )

        beta (`~.hipblasComplex`/`~.object`) -- *IN*:
            beta specifies the scalar beta. When beta is
            zero then C need not be set before entry.

        CP (`~.hipblasComplex`/`~.object`) -- *IN*:
            pointer storing matrix C on the GPU.
            Matrix dimension is m by n

        ldc (`~.int`) -- *IN*:
            [int]
            ldc specifies the first dimension of C. ldc >= max( 1, m )
    """
    if not isinstance(side,_hipblasSideMode_t__Base):
        raise TypeError("argument 'side' must be of type '_hipblasSideMode_t__Base'")                    
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")
    _hipblasChemm__retval = hipblasStatus_t(chipblas.hipblasChemm(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,side.value,uplo.value,n,k,
        hipblasComplex.fromPyobj(alpha).getElementPtr(),
        hipblasComplex.fromPyobj(AP).getElementPtr(),lda,
        hipblasComplex.fromPyobj(BP).getElementPtr(),ldb,
        hipblasComplex.fromPyobj(beta).getElementPtr(),
        hipblasComplex.fromPyobj(CP).getElementPtr(),ldc))
    return (_hipblasChemm__retval,)


@cython.embedsignature(True)
def hipblasZhemm(object handle, object side, object uplo, int n, int k, object alpha, object AP, int lda, object BP, int ldb, object beta, object CP, int ldc):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        side (`~.hipblasSideMode_t`):
            (undocumented)

        uplo (`~.hipblasFillMode_t`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        k (`~.int`):
            (undocumented)

        alpha (`~.hipblasDoubleComplex`/`~.object`):
            (undocumented)

        AP (`~.hipblasDoubleComplex`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        BP (`~.hipblasDoubleComplex`/`~.object`):
            (undocumented)

        ldb (`~.int`):
            (undocumented)

        beta (`~.hipblasDoubleComplex`/`~.object`):
            (undocumented)

        CP (`~.hipblasDoubleComplex`/`~.object`):
            (undocumented)

        ldc (`~.int`):
            (undocumented)
    """
    if not isinstance(side,_hipblasSideMode_t__Base):
        raise TypeError("argument 'side' must be of type '_hipblasSideMode_t__Base'")                    
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")
    _hipblasZhemm__retval = hipblasStatus_t(chipblas.hipblasZhemm(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,side.value,uplo.value,n,k,
        hipblasDoubleComplex.fromPyobj(alpha).getElementPtr(),
        hipblasDoubleComplex.fromPyobj(AP).getElementPtr(),lda,
        hipblasDoubleComplex.fromPyobj(BP).getElementPtr(),ldb,
        hipblasDoubleComplex.fromPyobj(beta).getElementPtr(),
        hipblasDoubleComplex.fromPyobj(CP).getElementPtr(),ldc))
    return (_hipblasZhemm__retval,)


@cython.embedsignature(True)
def hipblasChemm_v2(object handle, object side, object uplo, int n, int k, object alpha, object AP, int lda, object BP, int ldb, object beta, object CP, int ldc):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        side (`~.hipblasSideMode_t`):
            (undocumented)

        uplo (`~.hipblasFillMode_t`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        k (`~.int`):
            (undocumented)

        alpha (`~.float2`/`~.object`):
            (undocumented)

        AP (`~.float2`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        BP (`~.float2`/`~.object`):
            (undocumented)

        ldb (`~.int`):
            (undocumented)

        beta (`~.float2`/`~.object`):
            (undocumented)

        CP (`~.float2`/`~.object`):
            (undocumented)

        ldc (`~.int`):
            (undocumented)
    """
    if not isinstance(side,_hipblasSideMode_t__Base):
        raise TypeError("argument 'side' must be of type '_hipblasSideMode_t__Base'")                    
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")
    _hipblasChemm_v2__retval = hipblasStatus_t(chipblas.hipblasChemm_v2(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,side.value,uplo.value,n,k,
        float2.fromPyobj(alpha).getElementPtr(),
        float2.fromPyobj(AP).getElementPtr(),lda,
        float2.fromPyobj(BP).getElementPtr(),ldb,
        float2.fromPyobj(beta).getElementPtr(),
        float2.fromPyobj(CP).getElementPtr(),ldc))
    return (_hipblasChemm_v2__retval,)


@cython.embedsignature(True)
def hipblasZhemm_v2(object handle, object side, object uplo, int n, int k, object alpha, object AP, int lda, object BP, int ldb, object beta, object CP, int ldc):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        side (`~.hipblasSideMode_t`):
            (undocumented)

        uplo (`~.hipblasFillMode_t`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        k (`~.int`):
            (undocumented)

        alpha (`~.double2`/`~.object`):
            (undocumented)

        AP (`~.double2`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        BP (`~.double2`/`~.object`):
            (undocumented)

        ldb (`~.int`):
            (undocumented)

        beta (`~.double2`/`~.object`):
            (undocumented)

        CP (`~.double2`/`~.object`):
            (undocumented)

        ldc (`~.int`):
            (undocumented)
    """
    if not isinstance(side,_hipblasSideMode_t__Base):
        raise TypeError("argument 'side' must be of type '_hipblasSideMode_t__Base'")                    
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")
    _hipblasZhemm_v2__retval = hipblasStatus_t(chipblas.hipblasZhemm_v2(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,side.value,uplo.value,n,k,
        double2.fromPyobj(alpha).getElementPtr(),
        double2.fromPyobj(AP).getElementPtr(),lda,
        double2.fromPyobj(BP).getElementPtr(),ldb,
        double2.fromPyobj(beta).getElementPtr(),
        double2.fromPyobj(CP).getElementPtr(),ldc))
    return (_hipblasZhemm_v2__retval,)


@cython.embedsignature(True)
def hipblasChemmBatched(object handle, object side, object uplo, int n, int k, object alpha, object AP, int lda, object BP, int ldb, object beta, object CP, int ldc, int batchCount):
    r"""BLAS Level 3 API

    @{

    hemmBatched performs a batch of the matrix-matrix operations:

    C_i := alpha*A_i*B_i + beta*C_i if side == HIPBLAS_SIDE_LEFT,
    C_i := alpha*B_i*A_i + beta*C_i if side == HIPBLAS_SIDE_RIGHT,

    where alpha and beta are scalars, B_i and C_i are m by n matrices, and
    A_i is a Hermitian matrix stored as either upper or lower.

    - Supported precisions in rocBLAS : c,z
    - Supported precisions in cuBLAS  : No support

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`) -- *IN*:
            [hipblasHandle_t]
            handle to the hipblas library context queue.

        side (`~.hipblasSideMode_t`) -- *IN*:
            [hipblasSideMode_t]
            HIPBLAS_SIDE_LEFT:      C_i := alpha*A_i*B_i + beta*C_i
            HIPBLAS_SIDE_RIGHT:     C_i := alpha*B_i*A_i + beta*C_i

        uplo (`~.hipblasFillMode_t`) -- *IN*:
            [hipblasFillMode_t]
            HIPBLAS_FILL_MODE_UPPER:  A_i is an upper triangular matrix
            HIPBLAS_FILL_MODE_LOWER:  A_i is a  lower triangular matrix

        n (`~.int`) -- *IN*:
            [int]
            n specifies the number of rows of B_i and C_i. n >= 0.

        k (`~.int`) -- *IN*:
            [int]
            k specifies the number of columns of B_i and C_i. k >= 0.

        alpha (`~.hipblasComplex`/`~.object`) -- *IN*:
            alpha specifies the scalar alpha. When alpha is
            zero then A_i and B_i are not referenced.

        AP (`~.hip._util.types.Pointer`/`~.object`) -- *IN*:
            device array of device pointers storing each matrix A_i on the GPU.
            A_i is m by m if side == HIPBLAS_SIDE_LEFT
            A_i is n by n if side == HIPBLAS_SIDE_RIGHT
            Only the upper/lower triangular part is accessed.
            The imaginary component of the diagonal elements is not used.

        lda (`~.int`) -- *IN*:
            [int]
            lda specifies the first dimension of A_i.
            if side = HIPBLAS_SIDE_LEFT,  lda >= max( 1, m ),
            otherwise lda >= max( 1, n ).

        BP (`~.hip._util.types.Pointer`/`~.object`) -- *IN*:
            device array of device pointers storing each matrix B_i on the GPU.
            Matrix dimension is m by n

        ldb (`~.int`) -- *IN*:
            [int]
            ldb specifies the first dimension of B_i. ldb >= max( 1, m )

        beta (`~.hipblasComplex`/`~.object`) -- *IN*:
            beta specifies the scalar beta. When beta is
            zero then C_i need not be set before entry.

        CP (`~.hip._util.types.Pointer`/`~.object`) -- *IN*:
            device array of device pointers storing each matrix C_i on the GPU.
            Matrix dimension is m by n

        ldc (`~.int`) -- *IN*:
            [int]
            ldc specifies the first dimension of C_i. ldc >= max( 1, m )

        batchCount (`~.int`) -- *IN*:
            [int]
            number of instances in the batch.
    """
    if not isinstance(side,_hipblasSideMode_t__Base):
        raise TypeError("argument 'side' must be of type '_hipblasSideMode_t__Base'")                    
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")
    _hipblasChemmBatched__retval = hipblasStatus_t(chipblas.hipblasChemmBatched(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,side.value,uplo.value,n,k,
        hipblasComplex.fromPyobj(alpha).getElementPtr(),
        <chipblas.hipblasComplex *const*>hip._util.types.Pointer.fromPyobj(AP)._ptr,lda,
        <chipblas.hipblasComplex *const*>hip._util.types.Pointer.fromPyobj(BP)._ptr,ldb,
        hipblasComplex.fromPyobj(beta).getElementPtr(),
        <chipblas.hipblasComplex *const*>hip._util.types.Pointer.fromPyobj(CP)._ptr,ldc,batchCount))
    return (_hipblasChemmBatched__retval,)


@cython.embedsignature(True)
def hipblasZhemmBatched(object handle, object side, object uplo, int n, int k, object alpha, object AP, int lda, object BP, int ldb, object beta, object CP, int ldc, int batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        side (`~.hipblasSideMode_t`):
            (undocumented)

        uplo (`~.hipblasFillMode_t`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        k (`~.int`):
            (undocumented)

        alpha (`~.hipblasDoubleComplex`/`~.object`):
            (undocumented)

        AP (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        BP (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        ldb (`~.int`):
            (undocumented)

        beta (`~.hipblasDoubleComplex`/`~.object`):
            (undocumented)

        CP (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        ldc (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    if not isinstance(side,_hipblasSideMode_t__Base):
        raise TypeError("argument 'side' must be of type '_hipblasSideMode_t__Base'")                    
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")
    _hipblasZhemmBatched__retval = hipblasStatus_t(chipblas.hipblasZhemmBatched(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,side.value,uplo.value,n,k,
        hipblasDoubleComplex.fromPyobj(alpha).getElementPtr(),
        <chipblas.hipblasDoubleComplex *const*>hip._util.types.Pointer.fromPyobj(AP)._ptr,lda,
        <chipblas.hipblasDoubleComplex *const*>hip._util.types.Pointer.fromPyobj(BP)._ptr,ldb,
        hipblasDoubleComplex.fromPyobj(beta).getElementPtr(),
        <chipblas.hipblasDoubleComplex *const*>hip._util.types.Pointer.fromPyobj(CP)._ptr,ldc,batchCount))
    return (_hipblasZhemmBatched__retval,)


@cython.embedsignature(True)
def hipblasChemmBatched_v2(object handle, object side, object uplo, int n, int k, object alpha, object AP, int lda, object BP, int ldb, object beta, object CP, int ldc, int batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        side (`~.hipblasSideMode_t`):
            (undocumented)

        uplo (`~.hipblasFillMode_t`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        k (`~.int`):
            (undocumented)

        alpha (`~.float2`/`~.object`):
            (undocumented)

        AP (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        BP (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        ldb (`~.int`):
            (undocumented)

        beta (`~.float2`/`~.object`):
            (undocumented)

        CP (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        ldc (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    if not isinstance(side,_hipblasSideMode_t__Base):
        raise TypeError("argument 'side' must be of type '_hipblasSideMode_t__Base'")                    
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")
    _hipblasChemmBatched_v2__retval = hipblasStatus_t(chipblas.hipblasChemmBatched_v2(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,side.value,uplo.value,n,k,
        float2.fromPyobj(alpha).getElementPtr(),
        <chipblas.float2 *const*>hip._util.types.Pointer.fromPyobj(AP)._ptr,lda,
        <chipblas.float2 *const*>hip._util.types.Pointer.fromPyobj(BP)._ptr,ldb,
        float2.fromPyobj(beta).getElementPtr(),
        <chipblas.float2 *const*>hip._util.types.Pointer.fromPyobj(CP)._ptr,ldc,batchCount))
    return (_hipblasChemmBatched_v2__retval,)


@cython.embedsignature(True)
def hipblasZhemmBatched_v2(object handle, object side, object uplo, int n, int k, object alpha, object AP, int lda, object BP, int ldb, object beta, object CP, int ldc, int batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        side (`~.hipblasSideMode_t`):
            (undocumented)

        uplo (`~.hipblasFillMode_t`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        k (`~.int`):
            (undocumented)

        alpha (`~.double2`/`~.object`):
            (undocumented)

        AP (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        BP (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        ldb (`~.int`):
            (undocumented)

        beta (`~.double2`/`~.object`):
            (undocumented)

        CP (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        ldc (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    if not isinstance(side,_hipblasSideMode_t__Base):
        raise TypeError("argument 'side' must be of type '_hipblasSideMode_t__Base'")                    
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")
    _hipblasZhemmBatched_v2__retval = hipblasStatus_t(chipblas.hipblasZhemmBatched_v2(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,side.value,uplo.value,n,k,
        double2.fromPyobj(alpha).getElementPtr(),
        <chipblas.double2 *const*>hip._util.types.Pointer.fromPyobj(AP)._ptr,lda,
        <chipblas.double2 *const*>hip._util.types.Pointer.fromPyobj(BP)._ptr,ldb,
        double2.fromPyobj(beta).getElementPtr(),
        <chipblas.double2 *const*>hip._util.types.Pointer.fromPyobj(CP)._ptr,ldc,batchCount))
    return (_hipblasZhemmBatched_v2__retval,)


@cython.embedsignature(True)
def hipblasChemmStridedBatched(object handle, object side, object uplo, int n, int k, object alpha, object AP, int lda, long strideA, object BP, int ldb, long strideB, object beta, object CP, int ldc, long strideC, int batchCount):
    r"""BLAS Level 3 API

    @{

    hemmStridedBatched performs a batch of the matrix-matrix operations:

    C_i := alpha*A_i*B_i + beta*C_i if side == HIPBLAS_SIDE_LEFT,
    C_i := alpha*B_i*A_i + beta*C_i if side == HIPBLAS_SIDE_RIGHT,

    where alpha and beta are scalars, B_i and C_i are m by n matrices, and
    A_i is a Hermitian matrix stored as either upper or lower.

    - Supported precisions in rocBLAS : c,z
    - Supported precisions in cuBLAS  : No support

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`) -- *IN*:
            [hipblasHandle_t]
            handle to the hipblas library context queue.

        side (`~.hipblasSideMode_t`) -- *IN*:
            [hipblasSideMode_t]
            HIPBLAS_SIDE_LEFT:      C_i := alpha*A_i*B_i + beta*C_i
            HIPBLAS_SIDE_RIGHT:     C_i := alpha*B_i*A_i + beta*C_i

        uplo (`~.hipblasFillMode_t`) -- *IN*:
            [hipblasFillMode_t]
            HIPBLAS_FILL_MODE_UPPER:  A_i is an upper triangular matrix
            HIPBLAS_FILL_MODE_LOWER:  A_i is a  lower triangular matrix

        n (`~.int`) -- *IN*:
            [int]
            n specifies the number of rows of B_i and C_i. n >= 0.

        k (`~.int`) -- *IN*:
            [int]
            k specifies the number of columns of B_i and C_i. k >= 0.

        alpha (`~.hipblasComplex`/`~.object`) -- *IN*:
            alpha specifies the scalar alpha. When alpha is
            zero then A_i and B_i are not referenced.

        AP (`~.hipblasComplex`/`~.object`) -- *IN*:
            device pointer to first matrix A_1
            A_i is m by m if side == HIPBLAS_SIDE_LEFT
            A_i is n by n if side == HIPBLAS_SIDE_RIGHT
            Only the upper/lower triangular part is accessed.
            The imaginary component of the diagonal elements is not used.

        lda (`~.int`) -- *IN*:
            [int]
            lda specifies the first dimension of A_i.
            if side = HIPBLAS_SIDE_LEFT,  lda >= max( 1, m ),
            otherwise lda >= max( 1, n ).

        strideA (`~.int`) -- *IN*:
            [hipblasStride]
            stride from the start of one matrix (A_i) and the next one (A_i+1)

        BP (`~.hipblasComplex`/`~.object`) -- *IN*:
            device pointer to first matrix B_1 of dimension (ldb, n) on the GPU

        ldb (`~.int`) -- *IN*:
            [int]
            ldb specifies the first dimension of B_i.
            if side = HIPBLAS_OP_N,  ldb >= max( 1, m ),
            otherwise ldb >= max( 1, n ).

        strideB (`~.int`) -- *IN*:
            [hipblasStride]
            stride from the start of one matrix (B_i) and the next one (B_i+1)

        beta (`~.hipblasComplex`/`~.object`) -- *IN*:
            beta specifies the scalar beta. When beta is
            zero then C need not be set before entry.

        CP (`~.hipblasComplex`/`~.object`) -- *IN*:
            device pointer to first matrix C_1 of dimension (ldc, n) on the GPU.

        ldc (`~.int`) -- *IN*:
            [int]
            ldc specifies the first dimension of C. ldc >= max( 1, m )

        strideC (`~.int`) -- *INOUT*:
            [hipblasStride]
            stride from the start of one matrix (C_i) and the next one (C_i+1)

        batchCount (`~.int`) -- *IN*:
            [int]
            number of instances in the batch
    """
    if not isinstance(side,_hipblasSideMode_t__Base):
        raise TypeError("argument 'side' must be of type '_hipblasSideMode_t__Base'")                    
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")
    _hipblasChemmStridedBatched__retval = hipblasStatus_t(chipblas.hipblasChemmStridedBatched(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,side.value,uplo.value,n,k,
        hipblasComplex.fromPyobj(alpha).getElementPtr(),
        hipblasComplex.fromPyobj(AP).getElementPtr(),lda,strideA,
        hipblasComplex.fromPyobj(BP).getElementPtr(),ldb,strideB,
        hipblasComplex.fromPyobj(beta).getElementPtr(),
        hipblasComplex.fromPyobj(CP).getElementPtr(),ldc,strideC,batchCount))
    return (_hipblasChemmStridedBatched__retval,)


@cython.embedsignature(True)
def hipblasZhemmStridedBatched(object handle, object side, object uplo, int n, int k, object alpha, object AP, int lda, long strideA, object BP, int ldb, long strideB, object beta, object CP, int ldc, long strideC, int batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        side (`~.hipblasSideMode_t`):
            (undocumented)

        uplo (`~.hipblasFillMode_t`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        k (`~.int`):
            (undocumented)

        alpha (`~.hipblasDoubleComplex`/`~.object`):
            (undocumented)

        AP (`~.hipblasDoubleComplex`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        strideA (`~.int`):
            (undocumented)

        BP (`~.hipblasDoubleComplex`/`~.object`):
            (undocumented)

        ldb (`~.int`):
            (undocumented)

        strideB (`~.int`):
            (undocumented)

        beta (`~.hipblasDoubleComplex`/`~.object`):
            (undocumented)

        CP (`~.hipblasDoubleComplex`/`~.object`):
            (undocumented)

        ldc (`~.int`):
            (undocumented)

        strideC (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    if not isinstance(side,_hipblasSideMode_t__Base):
        raise TypeError("argument 'side' must be of type '_hipblasSideMode_t__Base'")                    
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")
    _hipblasZhemmStridedBatched__retval = hipblasStatus_t(chipblas.hipblasZhemmStridedBatched(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,side.value,uplo.value,n,k,
        hipblasDoubleComplex.fromPyobj(alpha).getElementPtr(),
        hipblasDoubleComplex.fromPyobj(AP).getElementPtr(),lda,strideA,
        hipblasDoubleComplex.fromPyobj(BP).getElementPtr(),ldb,strideB,
        hipblasDoubleComplex.fromPyobj(beta).getElementPtr(),
        hipblasDoubleComplex.fromPyobj(CP).getElementPtr(),ldc,strideC,batchCount))
    return (_hipblasZhemmStridedBatched__retval,)


@cython.embedsignature(True)
def hipblasChemmStridedBatched_v2(object handle, object side, object uplo, int n, int k, object alpha, object AP, int lda, long strideA, object BP, int ldb, long strideB, object beta, object CP, int ldc, long strideC, int batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        side (`~.hipblasSideMode_t`):
            (undocumented)

        uplo (`~.hipblasFillMode_t`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        k (`~.int`):
            (undocumented)

        alpha (`~.float2`/`~.object`):
            (undocumented)

        AP (`~.float2`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        strideA (`~.int`):
            (undocumented)

        BP (`~.float2`/`~.object`):
            (undocumented)

        ldb (`~.int`):
            (undocumented)

        strideB (`~.int`):
            (undocumented)

        beta (`~.float2`/`~.object`):
            (undocumented)

        CP (`~.float2`/`~.object`):
            (undocumented)

        ldc (`~.int`):
            (undocumented)

        strideC (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    if not isinstance(side,_hipblasSideMode_t__Base):
        raise TypeError("argument 'side' must be of type '_hipblasSideMode_t__Base'")                    
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")
    _hipblasChemmStridedBatched_v2__retval = hipblasStatus_t(chipblas.hipblasChemmStridedBatched_v2(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,side.value,uplo.value,n,k,
        float2.fromPyobj(alpha).getElementPtr(),
        float2.fromPyobj(AP).getElementPtr(),lda,strideA,
        float2.fromPyobj(BP).getElementPtr(),ldb,strideB,
        float2.fromPyobj(beta).getElementPtr(),
        float2.fromPyobj(CP).getElementPtr(),ldc,strideC,batchCount))
    return (_hipblasChemmStridedBatched_v2__retval,)


@cython.embedsignature(True)
def hipblasZhemmStridedBatched_v2(object handle, object side, object uplo, int n, int k, object alpha, object AP, int lda, long strideA, object BP, int ldb, long strideB, object beta, object CP, int ldc, long strideC, int batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        side (`~.hipblasSideMode_t`):
            (undocumented)

        uplo (`~.hipblasFillMode_t`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        k (`~.int`):
            (undocumented)

        alpha (`~.double2`/`~.object`):
            (undocumented)

        AP (`~.double2`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        strideA (`~.int`):
            (undocumented)

        BP (`~.double2`/`~.object`):
            (undocumented)

        ldb (`~.int`):
            (undocumented)

        strideB (`~.int`):
            (undocumented)

        beta (`~.double2`/`~.object`):
            (undocumented)

        CP (`~.double2`/`~.object`):
            (undocumented)

        ldc (`~.int`):
            (undocumented)

        strideC (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    if not isinstance(side,_hipblasSideMode_t__Base):
        raise TypeError("argument 'side' must be of type '_hipblasSideMode_t__Base'")                    
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")
    _hipblasZhemmStridedBatched_v2__retval = hipblasStatus_t(chipblas.hipblasZhemmStridedBatched_v2(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,side.value,uplo.value,n,k,
        double2.fromPyobj(alpha).getElementPtr(),
        double2.fromPyobj(AP).getElementPtr(),lda,strideA,
        double2.fromPyobj(BP).getElementPtr(),ldb,strideB,
        double2.fromPyobj(beta).getElementPtr(),
        double2.fromPyobj(CP).getElementPtr(),ldc,strideC,batchCount))
    return (_hipblasZhemmStridedBatched_v2__retval,)


@cython.embedsignature(True)
def hipblasStrmm(object handle, object side, object uplo, object transA, object diag, int m, int n, object alpha, object A, int lda, object B, int ldb, object C, int ldc):
    r"""BLAS Level 3 API

    @{

    trmm performs one of the matrix-matrix operations

    C := alpha*op( A )*B,   or   C := alpha*B*op( A )

    where  alpha  is a scalar, B and C are an m by n matrices,  A  is a unit, or
    non-unit,  upper or lower triangular matrix  and  op( A )  is one  of

        op( A ) = A   or   op( A ) = A^T   or   op( A ) = A^H.

    Note that trmm can provide in-place functionality by passing in the same address for both
    matrices B and C and by setting ldb equal to ldc.

    - Supported precisions in rocBLAS : s,d,c,z
    - Supported precisions in cuBLAS  : s,d,c,z

    When uplo == HIPBLAS_FILL_MODE_UPPER the  leading  k by k
    upper triangular part of the array  A must contain the upper
    triangular matrix  and the strictly lower triangular part of
    A is not referenced.

    When uplo == HIPBLAS_FILL_MODE_LOWER the  leading  k by k
    lower triangular part of the array  A must contain the lower
    triangular matrix  and the strictly upper triangular part of
    A is not referenced.

    Note that when  diag == HIPBLAS_DIAG_UNIT  the diagonal elements of
    A  are not referenced either,  but are assumed to be  unity.

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`) -- *IN*:
            [hipblasHandle_t]
            handle to the hipblas library context queue.

        side (`~.hipblasSideMode_t`) -- *IN*:
            [hipblasSideMode_t]
            Specifies whether op(A) multiplies B from the left or right as follows:
            HIPBLAS_SIDE_LEFT:       C := alpha*op( A )*B.
            HIPBLAS_SIDE_RIGHT:      C := alpha*B*op( A ).

        uplo (`~.hipblasFillMode_t`) -- *IN*:
            [hipblasFillMode_t]
            Specifies whether the matrix A is an upper or lower triangular matrix as follows:
            HIPBLAS_FILL_MODE_UPPER:  A is an upper triangular matrix.
            HIPBLAS_FILL_MODE_LOWER:  A is a  lower triangular matrix.

        transA (`~.hipblasOperation_t`) -- *IN*:
            [hipblasOperation_t]
            Specifies the form of op(A) to be used in the matrix multiplication as follows:
            HIPBLAS_OP_N: op(A) = A.
            HIPBLAS_OP_T: op(A) = A^T.
            HIPBLAS_OP_C: op(A) = A^H.

        diag (`~.hipblasDiagType_t`) -- *IN*:
            [hipblasDiagType_t]
            Specifies whether or not A is unit triangular as follows:
            HIPBLAS_DIAG_UNIT:      A is assumed to be unit triangular.
            HIPBLAS_DIAG_NON_UNIT:  A is not assumed to be unit triangular.

        m (`~.int`) -- *IN*:
            [int]
            m specifies the number of rows of B and C. m >= 0.

        n (`~.int`) -- *IN*:
            [int]
            n specifies the number of columns of B and C. n >= 0.

        alpha (`~.hip._util.types.Pointer`/`~.object`) -- *IN*:
            alpha specifies the scalar alpha. When alpha is
            zero then A is not referenced and B need not be set before
            entry.

        A (`~.hip._util.types.Pointer`/`~.object`) -- *IN*:
            Device pointer to matrix A on the GPU.
            A has dimension ( lda, k ), where k is m
            when  side == HIPBLAS_SIDE_LEFT  and
            is  n  when  side == HIPBLAS_SIDE_RIGHT.

        lda (`~.int`) -- *IN*:
            [int]
            lda specifies the first dimension of A.
            if side == HIPBLAS_SIDE_LEFT,  lda >= max( 1, m ),
            if side == HIPBLAS_SIDE_RIGHT, lda >= max( 1, n ).

        B (`~.hip._util.types.Pointer`/`~.object`) -- *INOUT*:
            Device pointer to the matrix B of dimension (ldb, n) on the GPU.

        ldb (`~.int`) -- *IN*:
            [int]
            ldb specifies the first dimension of B. ldb >= max( 1, m ).

        C (`~.hip._util.types.Pointer`/`~.object`) -- *IN*:
            Device pointer to the matrix C of dimension (ldc, n) on the GPU.
            Users can pass in the same matrix B to parameter C to achieve
            in-place functionality of trmm.

        ldc (`~.int`) -- *IN*:
            [int]
            ldc specifies the first dimension of C. ldc >= max( 1, m ).
    """
    if not isinstance(side,_hipblasSideMode_t__Base):
        raise TypeError("argument 'side' must be of type '_hipblasSideMode_t__Base'")                    
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")                    
    if not isinstance(transA,_hipblasOperation_t__Base):
        raise TypeError("argument 'transA' must be of type '_hipblasOperation_t__Base'")                    
    if not isinstance(diag,_hipblasDiagType_t__Base):
        raise TypeError("argument 'diag' must be of type '_hipblasDiagType_t__Base'")
    _hipblasStrmm__retval = hipblasStatus_t(chipblas.hipblasStrmm(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,side.value,uplo.value,transA.value,diag.value,m,n,
        <const float *>hip._util.types.Pointer.fromPyobj(alpha)._ptr,
        <const float *>hip._util.types.Pointer.fromPyobj(A)._ptr,lda,
        <const float *>hip._util.types.Pointer.fromPyobj(B)._ptr,ldb,
        <float *>hip._util.types.Pointer.fromPyobj(C)._ptr,ldc))
    return (_hipblasStrmm__retval,)


@cython.embedsignature(True)
def hipblasDtrmm(object handle, object side, object uplo, object transA, object diag, int m, int n, object alpha, object A, int lda, object B, int ldb, object C, int ldc):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        side (`~.hipblasSideMode_t`):
            (undocumented)

        uplo (`~.hipblasFillMode_t`):
            (undocumented)

        transA (`~.hipblasOperation_t`):
            (undocumented)

        diag (`~.hipblasDiagType_t`):
            (undocumented)

        m (`~.int`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        alpha (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        A (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        B (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        ldb (`~.int`):
            (undocumented)

        C (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        ldc (`~.int`):
            (undocumented)
    """
    if not isinstance(side,_hipblasSideMode_t__Base):
        raise TypeError("argument 'side' must be of type '_hipblasSideMode_t__Base'")                    
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")                    
    if not isinstance(transA,_hipblasOperation_t__Base):
        raise TypeError("argument 'transA' must be of type '_hipblasOperation_t__Base'")                    
    if not isinstance(diag,_hipblasDiagType_t__Base):
        raise TypeError("argument 'diag' must be of type '_hipblasDiagType_t__Base'")
    _hipblasDtrmm__retval = hipblasStatus_t(chipblas.hipblasDtrmm(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,side.value,uplo.value,transA.value,diag.value,m,n,
        <const double *>hip._util.types.Pointer.fromPyobj(alpha)._ptr,
        <const double *>hip._util.types.Pointer.fromPyobj(A)._ptr,lda,
        <const double *>hip._util.types.Pointer.fromPyobj(B)._ptr,ldb,
        <double *>hip._util.types.Pointer.fromPyobj(C)._ptr,ldc))
    return (_hipblasDtrmm__retval,)


@cython.embedsignature(True)
def hipblasCtrmm(object handle, object side, object uplo, object transA, object diag, int m, int n, object alpha, object A, int lda, object B, int ldb, object C, int ldc):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        side (`~.hipblasSideMode_t`):
            (undocumented)

        uplo (`~.hipblasFillMode_t`):
            (undocumented)

        transA (`~.hipblasOperation_t`):
            (undocumented)

        diag (`~.hipblasDiagType_t`):
            (undocumented)

        m (`~.int`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        alpha (`~.hipblasComplex`/`~.object`):
            (undocumented)

        A (`~.hipblasComplex`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        B (`~.hipblasComplex`/`~.object`):
            (undocumented)

        ldb (`~.int`):
            (undocumented)

        C (`~.hipblasComplex`/`~.object`):
            (undocumented)

        ldc (`~.int`):
            (undocumented)
    """
    if not isinstance(side,_hipblasSideMode_t__Base):
        raise TypeError("argument 'side' must be of type '_hipblasSideMode_t__Base'")                    
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")                    
    if not isinstance(transA,_hipblasOperation_t__Base):
        raise TypeError("argument 'transA' must be of type '_hipblasOperation_t__Base'")                    
    if not isinstance(diag,_hipblasDiagType_t__Base):
        raise TypeError("argument 'diag' must be of type '_hipblasDiagType_t__Base'")
    _hipblasCtrmm__retval = hipblasStatus_t(chipblas.hipblasCtrmm(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,side.value,uplo.value,transA.value,diag.value,m,n,
        hipblasComplex.fromPyobj(alpha).getElementPtr(),
        hipblasComplex.fromPyobj(A).getElementPtr(),lda,
        hipblasComplex.fromPyobj(B).getElementPtr(),ldb,
        hipblasComplex.fromPyobj(C).getElementPtr(),ldc))
    return (_hipblasCtrmm__retval,)


@cython.embedsignature(True)
def hipblasZtrmm(object handle, object side, object uplo, object transA, object diag, int m, int n, object alpha, object A, int lda, object B, int ldb, object C, int ldc):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        side (`~.hipblasSideMode_t`):
            (undocumented)

        uplo (`~.hipblasFillMode_t`):
            (undocumented)

        transA (`~.hipblasOperation_t`):
            (undocumented)

        diag (`~.hipblasDiagType_t`):
            (undocumented)

        m (`~.int`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        alpha (`~.hipblasDoubleComplex`/`~.object`):
            (undocumented)

        A (`~.hipblasDoubleComplex`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        B (`~.hipblasDoubleComplex`/`~.object`):
            (undocumented)

        ldb (`~.int`):
            (undocumented)

        C (`~.hipblasDoubleComplex`/`~.object`):
            (undocumented)

        ldc (`~.int`):
            (undocumented)
    """
    if not isinstance(side,_hipblasSideMode_t__Base):
        raise TypeError("argument 'side' must be of type '_hipblasSideMode_t__Base'")                    
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")                    
    if not isinstance(transA,_hipblasOperation_t__Base):
        raise TypeError("argument 'transA' must be of type '_hipblasOperation_t__Base'")                    
    if not isinstance(diag,_hipblasDiagType_t__Base):
        raise TypeError("argument 'diag' must be of type '_hipblasDiagType_t__Base'")
    _hipblasZtrmm__retval = hipblasStatus_t(chipblas.hipblasZtrmm(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,side.value,uplo.value,transA.value,diag.value,m,n,
        hipblasDoubleComplex.fromPyobj(alpha).getElementPtr(),
        hipblasDoubleComplex.fromPyobj(A).getElementPtr(),lda,
        hipblasDoubleComplex.fromPyobj(B).getElementPtr(),ldb,
        hipblasDoubleComplex.fromPyobj(C).getElementPtr(),ldc))
    return (_hipblasZtrmm__retval,)


@cython.embedsignature(True)
def hipblasCtrmm_v2(object handle, object side, object uplo, object transA, object diag, int m, int n, object alpha, object A, int lda, object B, int ldb, object C, int ldc):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        side (`~.hipblasSideMode_t`):
            (undocumented)

        uplo (`~.hipblasFillMode_t`):
            (undocumented)

        transA (`~.hipblasOperation_t`):
            (undocumented)

        diag (`~.hipblasDiagType_t`):
            (undocumented)

        m (`~.int`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        alpha (`~.float2`/`~.object`):
            (undocumented)

        A (`~.float2`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        B (`~.float2`/`~.object`):
            (undocumented)

        ldb (`~.int`):
            (undocumented)

        C (`~.float2`/`~.object`):
            (undocumented)

        ldc (`~.int`):
            (undocumented)
    """
    if not isinstance(side,_hipblasSideMode_t__Base):
        raise TypeError("argument 'side' must be of type '_hipblasSideMode_t__Base'")                    
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")                    
    if not isinstance(transA,_hipblasOperation_t__Base):
        raise TypeError("argument 'transA' must be of type '_hipblasOperation_t__Base'")                    
    if not isinstance(diag,_hipblasDiagType_t__Base):
        raise TypeError("argument 'diag' must be of type '_hipblasDiagType_t__Base'")
    _hipblasCtrmm_v2__retval = hipblasStatus_t(chipblas.hipblasCtrmm_v2(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,side.value,uplo.value,transA.value,diag.value,m,n,
        float2.fromPyobj(alpha).getElementPtr(),
        float2.fromPyobj(A).getElementPtr(),lda,
        float2.fromPyobj(B).getElementPtr(),ldb,
        float2.fromPyobj(C).getElementPtr(),ldc))
    return (_hipblasCtrmm_v2__retval,)


@cython.embedsignature(True)
def hipblasZtrmm_v2(object handle, object side, object uplo, object transA, object diag, int m, int n, object alpha, object A, int lda, object B, int ldb, object C, int ldc):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        side (`~.hipblasSideMode_t`):
            (undocumented)

        uplo (`~.hipblasFillMode_t`):
            (undocumented)

        transA (`~.hipblasOperation_t`):
            (undocumented)

        diag (`~.hipblasDiagType_t`):
            (undocumented)

        m (`~.int`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        alpha (`~.double2`/`~.object`):
            (undocumented)

        A (`~.double2`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        B (`~.double2`/`~.object`):
            (undocumented)

        ldb (`~.int`):
            (undocumented)

        C (`~.double2`/`~.object`):
            (undocumented)

        ldc (`~.int`):
            (undocumented)
    """
    if not isinstance(side,_hipblasSideMode_t__Base):
        raise TypeError("argument 'side' must be of type '_hipblasSideMode_t__Base'")                    
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")                    
    if not isinstance(transA,_hipblasOperation_t__Base):
        raise TypeError("argument 'transA' must be of type '_hipblasOperation_t__Base'")                    
    if not isinstance(diag,_hipblasDiagType_t__Base):
        raise TypeError("argument 'diag' must be of type '_hipblasDiagType_t__Base'")
    _hipblasZtrmm_v2__retval = hipblasStatus_t(chipblas.hipblasZtrmm_v2(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,side.value,uplo.value,transA.value,diag.value,m,n,
        double2.fromPyobj(alpha).getElementPtr(),
        double2.fromPyobj(A).getElementPtr(),lda,
        double2.fromPyobj(B).getElementPtr(),ldb,
        double2.fromPyobj(C).getElementPtr(),ldc))
    return (_hipblasZtrmm_v2__retval,)


@cython.embedsignature(True)
def hipblasStrmmBatched(object handle, object side, object uplo, object transA, object diag, int m, int n, object alpha, object A, int lda, object B, int ldb, object C, int ldc, int batchCount):
    r"""BLAS Level 3 API

    @{

    trmmBatched performs one of the batched matrix-matrix operations

    C_i := alpha*op( A_i )*B_i,   or   C_i := alpha*B_i*op( A_i )  for i = 0, 1, ... batchCount -1

    where alpha is a scalar, B_i and C_i are m by n matrices, A_i is a unit, or
    non-unit, upper or lower triangular matrix and op( A_i ) is one of

        op( A_i ) = A_i   or   op( A_i ) = A_i^T   or   op( A_i ) = A_i^H.

    Note that trmmBatched can provide in-place functionality by passing in the same address for both
    matrices B and C and by setting ldb equal to ldc.

    - Supported precisions in rocBLAS : s,d,c,z
    - Supported precisions in cuBLAS  : No support

    When uplo == HIPBLAS_FILL_MODE_UPPER the  leading  k by k
    upper triangular part of the array  A must contain the upper
    triangular matrix  and the strictly lower triangular part of
    A is not referenced.

    When uplo == HIPBLAS_FILL_MODE_LOWER the  leading  k by k
    lower triangular part of the array  A must contain the lower
    triangular matrix  and the strictly upper triangular part of
    A is not referenced.

    Note that when  diag == HIPBLAS_DIAG_UNIT  the diagonal elements of
    A_i  are not referenced either,  but are assumed to be  unity.

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`) -- *IN*:
            [hipblasHandle_t]
            handle to the hipblas library context queue.

        side (`~.hipblasSideMode_t`) -- *IN*:
            [hipblasSideMode_t]
            Specifies whether op(A_i) multiplies B_i from the left or right as follows:
            HIPBLAS_SIDE_LEFT:       B_i := alpha*op( A_i )*B_i.
            HIPBLAS_SIDE_RIGHT:      B_i := alpha*B_i*op( A_i ).

        uplo (`~.hipblasFillMode_t`) -- *IN*:
            [hipblasFillMode_t]
            Specifies whether the matrix A is an upper or lower triangular matrix as follows:
            HIPBLAS_FILL_MODE_UPPER:  A is an upper triangular matrix.
            HIPBLAS_FILL_MODE_LOWER:  A is a  lower triangular matrix.

        transA (`~.hipblasOperation_t`) -- *IN*:
            [hipblasOperation_t]
            Specifies the form of op(A_i) to be used in the matrix multiplication as follows:
            HIPBLAS_OP_N:  op(A_i) = A_i.
            HIPBLAS_OP_T:  op(A_i) = A_i^T.
            HIPBLAS_OP_C:  op(A_i) = A_i^H.

        diag (`~.hipblasDiagType_t`) -- *IN*:
            [hipblasDiagType_t]
            Specifies whether or not A_i is unit triangular as follows:
            HIPBLAS_DIAG_UNIT:      A_i is assumed to be unit triangular.
            HIPBLAS_DIAG_NON_UNIT:  A_i is not assumed to be unit triangular.

        m (`~.int`) -- *IN*:
            [int]
            m specifies the number of rows of B_i and C_i. m >= 0.

        n (`~.int`) -- *IN*:
            [int]
            n specifies the number of columns of B_i and C_i. n >= 0.

        alpha (`~.hip._util.types.Pointer`/`~.object`) -- *IN*:
            alpha specifies the scalar alpha. When alpha is
            zero then A_i is not referenced and B_i need not be set before
            entry.

        A (`~.hip._util.types.ListOfPointer`/`~.object`) -- *IN*:
            Device array of device pointers storing each matrix A_i on the GPU.
            Each A_i is of dimension ( lda, k ), where k is m
            when  side == HIPBLAS_SIDE_LEFT  and
            is  n  when  side == HIPBLAS_SIDE_RIGHT.

        lda (`~.int`) -- *IN*:
            [int]
            lda specifies the first dimension of A.
            if side == HIPBLAS_SIDE_LEFT,  lda >= max( 1, m ),
            if side == HIPBLAS_SIDE_RIGHT, lda >= max( 1, n ).

        B (`~.hip._util.types.ListOfPointer`/`~.object`) -- *INOUT*:
            device array of device pointers storing each matrix B_i of
            dimension (ldb, n) on the GPU.

        ldb (`~.int`) -- *IN*:
            [int]
            ldb specifies the first dimension of B_i. ldb >= max( 1, m ).

        C (`~.hip._util.types.ListOfPointer`/`~.object`) -- *IN*:
            device array of device pointers storing each matrix C_i of
            dimension (ldc, n) on the GPU. Users can pass in the same
            matrices B to parameter C to achieve in-place functionality of trmmBatched.

        ldc (`~.int`) -- *IN*:
            lec specifies the first dimension of C_i. ldc >= max( 1, m ).

        batchCount (`~.int`) -- *IN*:
            [int]
            number of instances i in the batch.
    """
    if not isinstance(side,_hipblasSideMode_t__Base):
        raise TypeError("argument 'side' must be of type '_hipblasSideMode_t__Base'")                    
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")                    
    if not isinstance(transA,_hipblasOperation_t__Base):
        raise TypeError("argument 'transA' must be of type '_hipblasOperation_t__Base'")                    
    if not isinstance(diag,_hipblasDiagType_t__Base):
        raise TypeError("argument 'diag' must be of type '_hipblasDiagType_t__Base'")
    _hipblasStrmmBatched__retval = hipblasStatus_t(chipblas.hipblasStrmmBatched(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,side.value,uplo.value,transA.value,diag.value,m,n,
        <const float *>hip._util.types.Pointer.fromPyobj(alpha)._ptr,
        <const float *const*>hip._util.types.ListOfPointer.fromPyobj(A)._ptr,lda,
        <const float *const*>hip._util.types.ListOfPointer.fromPyobj(B)._ptr,ldb,
        <float *const*>hip._util.types.ListOfPointer.fromPyobj(C)._ptr,ldc,batchCount))
    return (_hipblasStrmmBatched__retval,)


@cython.embedsignature(True)
def hipblasDtrmmBatched(object handle, object side, object uplo, object transA, object diag, int m, int n, object alpha, object A, int lda, object B, int ldb, object C, int ldc, int batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        side (`~.hipblasSideMode_t`):
            (undocumented)

        uplo (`~.hipblasFillMode_t`):
            (undocumented)

        transA (`~.hipblasOperation_t`):
            (undocumented)

        diag (`~.hipblasDiagType_t`):
            (undocumented)

        m (`~.int`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        alpha (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        A (`~.hip._util.types.ListOfPointer`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        B (`~.hip._util.types.ListOfPointer`/`~.object`):
            (undocumented)

        ldb (`~.int`):
            (undocumented)

        C (`~.hip._util.types.ListOfPointer`/`~.object`):
            (undocumented)

        ldc (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    if not isinstance(side,_hipblasSideMode_t__Base):
        raise TypeError("argument 'side' must be of type '_hipblasSideMode_t__Base'")                    
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")                    
    if not isinstance(transA,_hipblasOperation_t__Base):
        raise TypeError("argument 'transA' must be of type '_hipblasOperation_t__Base'")                    
    if not isinstance(diag,_hipblasDiagType_t__Base):
        raise TypeError("argument 'diag' must be of type '_hipblasDiagType_t__Base'")
    _hipblasDtrmmBatched__retval = hipblasStatus_t(chipblas.hipblasDtrmmBatched(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,side.value,uplo.value,transA.value,diag.value,m,n,
        <const double *>hip._util.types.Pointer.fromPyobj(alpha)._ptr,
        <const double *const*>hip._util.types.ListOfPointer.fromPyobj(A)._ptr,lda,
        <const double *const*>hip._util.types.ListOfPointer.fromPyobj(B)._ptr,ldb,
        <double *const*>hip._util.types.ListOfPointer.fromPyobj(C)._ptr,ldc,batchCount))
    return (_hipblasDtrmmBatched__retval,)


@cython.embedsignature(True)
def hipblasCtrmmBatched(object handle, object side, object uplo, object transA, object diag, int m, int n, object alpha, object A, int lda, object B, int ldb, object C, int ldc, int batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        side (`~.hipblasSideMode_t`):
            (undocumented)

        uplo (`~.hipblasFillMode_t`):
            (undocumented)

        transA (`~.hipblasOperation_t`):
            (undocumented)

        diag (`~.hipblasDiagType_t`):
            (undocumented)

        m (`~.int`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        alpha (`~.hipblasComplex`/`~.object`):
            (undocumented)

        A (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        B (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        ldb (`~.int`):
            (undocumented)

        C (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        ldc (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    if not isinstance(side,_hipblasSideMode_t__Base):
        raise TypeError("argument 'side' must be of type '_hipblasSideMode_t__Base'")                    
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")                    
    if not isinstance(transA,_hipblasOperation_t__Base):
        raise TypeError("argument 'transA' must be of type '_hipblasOperation_t__Base'")                    
    if not isinstance(diag,_hipblasDiagType_t__Base):
        raise TypeError("argument 'diag' must be of type '_hipblasDiagType_t__Base'")
    _hipblasCtrmmBatched__retval = hipblasStatus_t(chipblas.hipblasCtrmmBatched(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,side.value,uplo.value,transA.value,diag.value,m,n,
        hipblasComplex.fromPyobj(alpha).getElementPtr(),
        <chipblas.hipblasComplex *const*>hip._util.types.Pointer.fromPyobj(A)._ptr,lda,
        <chipblas.hipblasComplex *const*>hip._util.types.Pointer.fromPyobj(B)._ptr,ldb,
        <chipblas.hipblasComplex *const*>hip._util.types.Pointer.fromPyobj(C)._ptr,ldc,batchCount))
    return (_hipblasCtrmmBatched__retval,)


@cython.embedsignature(True)
def hipblasZtrmmBatched(object handle, object side, object uplo, object transA, object diag, int m, int n, object alpha, object A, int lda, object B, int ldb, object C, int ldc, int batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        side (`~.hipblasSideMode_t`):
            (undocumented)

        uplo (`~.hipblasFillMode_t`):
            (undocumented)

        transA (`~.hipblasOperation_t`):
            (undocumented)

        diag (`~.hipblasDiagType_t`):
            (undocumented)

        m (`~.int`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        alpha (`~.hipblasDoubleComplex`/`~.object`):
            (undocumented)

        A (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        B (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        ldb (`~.int`):
            (undocumented)

        C (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        ldc (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    if not isinstance(side,_hipblasSideMode_t__Base):
        raise TypeError("argument 'side' must be of type '_hipblasSideMode_t__Base'")                    
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")                    
    if not isinstance(transA,_hipblasOperation_t__Base):
        raise TypeError("argument 'transA' must be of type '_hipblasOperation_t__Base'")                    
    if not isinstance(diag,_hipblasDiagType_t__Base):
        raise TypeError("argument 'diag' must be of type '_hipblasDiagType_t__Base'")
    _hipblasZtrmmBatched__retval = hipblasStatus_t(chipblas.hipblasZtrmmBatched(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,side.value,uplo.value,transA.value,diag.value,m,n,
        hipblasDoubleComplex.fromPyobj(alpha).getElementPtr(),
        <chipblas.hipblasDoubleComplex *const*>hip._util.types.Pointer.fromPyobj(A)._ptr,lda,
        <chipblas.hipblasDoubleComplex *const*>hip._util.types.Pointer.fromPyobj(B)._ptr,ldb,
        <chipblas.hipblasDoubleComplex *const*>hip._util.types.Pointer.fromPyobj(C)._ptr,ldc,batchCount))
    return (_hipblasZtrmmBatched__retval,)


@cython.embedsignature(True)
def hipblasCtrmmBatched_v2(object handle, object side, object uplo, object transA, object diag, int m, int n, object alpha, object A, int lda, object B, int ldb, object C, int ldc, int batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        side (`~.hipblasSideMode_t`):
            (undocumented)

        uplo (`~.hipblasFillMode_t`):
            (undocumented)

        transA (`~.hipblasOperation_t`):
            (undocumented)

        diag (`~.hipblasDiagType_t`):
            (undocumented)

        m (`~.int`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        alpha (`~.float2`/`~.object`):
            (undocumented)

        A (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        B (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        ldb (`~.int`):
            (undocumented)

        C (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        ldc (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    if not isinstance(side,_hipblasSideMode_t__Base):
        raise TypeError("argument 'side' must be of type '_hipblasSideMode_t__Base'")                    
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")                    
    if not isinstance(transA,_hipblasOperation_t__Base):
        raise TypeError("argument 'transA' must be of type '_hipblasOperation_t__Base'")                    
    if not isinstance(diag,_hipblasDiagType_t__Base):
        raise TypeError("argument 'diag' must be of type '_hipblasDiagType_t__Base'")
    _hipblasCtrmmBatched_v2__retval = hipblasStatus_t(chipblas.hipblasCtrmmBatched_v2(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,side.value,uplo.value,transA.value,diag.value,m,n,
        float2.fromPyobj(alpha).getElementPtr(),
        <chipblas.float2 *const*>hip._util.types.Pointer.fromPyobj(A)._ptr,lda,
        <chipblas.float2 *const*>hip._util.types.Pointer.fromPyobj(B)._ptr,ldb,
        <chipblas.float2 *const*>hip._util.types.Pointer.fromPyobj(C)._ptr,ldc,batchCount))
    return (_hipblasCtrmmBatched_v2__retval,)


@cython.embedsignature(True)
def hipblasZtrmmBatched_v2(object handle, object side, object uplo, object transA, object diag, int m, int n, object alpha, object A, int lda, object B, int ldb, object C, int ldc, int batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        side (`~.hipblasSideMode_t`):
            (undocumented)

        uplo (`~.hipblasFillMode_t`):
            (undocumented)

        transA (`~.hipblasOperation_t`):
            (undocumented)

        diag (`~.hipblasDiagType_t`):
            (undocumented)

        m (`~.int`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        alpha (`~.double2`/`~.object`):
            (undocumented)

        A (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        B (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        ldb (`~.int`):
            (undocumented)

        C (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        ldc (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    if not isinstance(side,_hipblasSideMode_t__Base):
        raise TypeError("argument 'side' must be of type '_hipblasSideMode_t__Base'")                    
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")                    
    if not isinstance(transA,_hipblasOperation_t__Base):
        raise TypeError("argument 'transA' must be of type '_hipblasOperation_t__Base'")                    
    if not isinstance(diag,_hipblasDiagType_t__Base):
        raise TypeError("argument 'diag' must be of type '_hipblasDiagType_t__Base'")
    _hipblasZtrmmBatched_v2__retval = hipblasStatus_t(chipblas.hipblasZtrmmBatched_v2(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,side.value,uplo.value,transA.value,diag.value,m,n,
        double2.fromPyobj(alpha).getElementPtr(),
        <chipblas.double2 *const*>hip._util.types.Pointer.fromPyobj(A)._ptr,lda,
        <chipblas.double2 *const*>hip._util.types.Pointer.fromPyobj(B)._ptr,ldb,
        <chipblas.double2 *const*>hip._util.types.Pointer.fromPyobj(C)._ptr,ldc,batchCount))
    return (_hipblasZtrmmBatched_v2__retval,)


@cython.embedsignature(True)
def hipblasStrmmStridedBatched(object handle, object side, object uplo, object transA, object diag, int m, int n, object alpha, object A, int lda, long strideA, object B, int ldb, long strideB, object C, int ldc, long strideC, int batchCount):
    r"""BLAS Level 3 API

    @{

    trmmStridedBatched performs one of the strided_batched matrix-matrix operations

    C_i := alpha*op( A_i )*B_i,   or   C_i := alpha*B_i*op( A_i )  for i = 0, 1, ... batchCount -1

    where alpha is a scalar,  B_i and C_i are m by n matrices, A_i is a unit, or
    non-unit, upper or lower triangular matrix and op( A_i ) is one of

        op( A_i ) = A_i   or   op( A_i ) = A_i^T   or   op( A_i ) = A_i^H.

    Note that trmmStridedBatched can provide in-place functionality by passing
    in the same address for both matrices B and C and by setting ldb equal to ldc.

    - Supported precisions in rocBLAS : s,d,c,z
    - Supported precisions in cuBLAS  : No support

    When uplo == HIPBLAS_FILL_MODE_UPPER the  leading  k by k
    upper triangular part of the array  A must contain the upper
    triangular matrix  and the strictly lower triangular part of
    A is not referenced.

    When uplo == HIPBLAS_FILL_MODE_LOWER the  leading  k by k
    lower triangular part of the array  A must contain the lower
    triangular matrix  and the strictly upper triangular part of
    A is not referenced.

    Note that when  diag == HIPBLAS_DIAG_UNIT  the diagonal elements of
    A_i  are not referenced either,  but are assumed to be  unity.

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`) -- *IN*:
            [hipblasHandle_t]
            handle to the hipblas library context queue.

        side (`~.hipblasSideMode_t`) -- *IN*:
            [hipblasSideMode_t]
            Specifies whether op(A_i) multiplies B_i from the left or right as follows:
            HIPBLAS_SIDE_LEFT:       C_i := alpha*op( A_i )*B_i.
            HIPBLAS_SIDE_RIGHT:      C_i := alpha*B_i*op( A_i ).

        uplo (`~.hipblasFillMode_t`) -- *IN*:
            [hipblasFillMode_t]
            Specifies whether the matrix A is an upper or lower triangular matrix as follows:
            HIPBLAS_FILL_MODE_UPPER:  A is an upper triangular matrix.
            HIPBLAS_FILL_MODE_LOWER:  A is a  lower triangular matrix.

        transA (`~.hipblasOperation_t`) -- *IN*:
            [hipblasOperation_t]
            Specifies the form of op(A_i) to be used in the matrix multiplication as follows:
            HIPBLAS_OP_N:  op(A_i) = A_i.
            HIPBLAS_OP_T:  op(A_i) = A_i^T.
            HIPBLAS_OP_C:  op(A_i) = A_i^H.

        diag (`~.hipblasDiagType_t`) -- *IN*:
            [hipblasDiagType_t]
            Specifies whether or not A_i is unit triangular as follows:
            HIPBLAS_DIAG_UNIT:      A_i is assumed to be unit triangular.
            HIPBLAS_DIAG_NON_UNIT:  A_i is not assumed to be unit triangular.

        m (`~.int`) -- *IN*:
            [int]
            m specifies the number of rows of B_i and C_i. m >= 0.

        n (`~.int`) -- *IN*:
            [int]
            n specifies the number of columns of B_i and C_i. n >= 0.

        alpha (`~.hip._util.types.Pointer`/`~.object`) -- *IN*:
            alpha specifies the scalar alpha. When alpha is
            zero then A_i is not referenced and B_i need not be set before
            entry.

        A (`~.hip._util.types.Pointer`/`~.object`) -- *IN*:
            Device pointer to the first matrix A_0 on the GPU.
            Each A_i is of dimension ( lda, k ), where k is m
            when  side == HIPBLAS_SIDE_LEFT  and
            is  n  when  side == HIPBLAS_SIDE_RIGHT.

        lda (`~.int`) -- *IN*:
            [int]
            lda specifies the first dimension of A.
            if side == HIPBLAS_SIDE_LEFT,  lda >= max( 1, m ),
            if side == HIPBLAS_SIDE_RIGHT, lda >= max( 1, n ).

        strideA (`~.int`) -- *IN*:
            [hipblasStride]
            stride from the start of one matrix (A_i) and the next one (A_i+1)

        B (`~.hip._util.types.Pointer`/`~.object`) -- *INOUT*:
            Device pointer to the first matrix B_0 on the GPU. Each B_i is of
            dimension ( ldb, n )

        ldb (`~.int`) -- *IN*:
            [int]
            ldb specifies the first dimension of B_i. ldb >= max( 1, m ).

        strideB (`~.int`) -- *IN*:
            [hipblasStride]
            stride from the start of one matrix (B_i) and the next one (B_i+1)

        C (`~.hip._util.types.Pointer`/`~.object`) -- *IN*:
            Device pointer to the first matrix C_0 on the GPU. Each C_i is of
            dimension ( ldc, n ).

        ldc (`~.int`) -- *IN*:
            [int]
            ldc specifies the first dimension of C_i. ldc >= max( 1, m ).

        strideC (`~.int`) -- *IN*:
            [hipblasStride]
            stride from the start of one matrix (C_i) and the next one (C_i+1)

        batchCount (`~.int`) -- *IN*:
            [int]
            number of instances i in the batch.
    """
    if not isinstance(side,_hipblasSideMode_t__Base):
        raise TypeError("argument 'side' must be of type '_hipblasSideMode_t__Base'")                    
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")                    
    if not isinstance(transA,_hipblasOperation_t__Base):
        raise TypeError("argument 'transA' must be of type '_hipblasOperation_t__Base'")                    
    if not isinstance(diag,_hipblasDiagType_t__Base):
        raise TypeError("argument 'diag' must be of type '_hipblasDiagType_t__Base'")
    _hipblasStrmmStridedBatched__retval = hipblasStatus_t(chipblas.hipblasStrmmStridedBatched(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,side.value,uplo.value,transA.value,diag.value,m,n,
        <const float *>hip._util.types.Pointer.fromPyobj(alpha)._ptr,
        <const float *>hip._util.types.Pointer.fromPyobj(A)._ptr,lda,strideA,
        <const float *>hip._util.types.Pointer.fromPyobj(B)._ptr,ldb,strideB,
        <float *>hip._util.types.Pointer.fromPyobj(C)._ptr,ldc,strideC,batchCount))
    return (_hipblasStrmmStridedBatched__retval,)


@cython.embedsignature(True)
def hipblasDtrmmStridedBatched(object handle, object side, object uplo, object transA, object diag, int m, int n, object alpha, object A, int lda, long strideA, object B, int ldb, long strideB, object C, int ldc, long strideC, int batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        side (`~.hipblasSideMode_t`):
            (undocumented)

        uplo (`~.hipblasFillMode_t`):
            (undocumented)

        transA (`~.hipblasOperation_t`):
            (undocumented)

        diag (`~.hipblasDiagType_t`):
            (undocumented)

        m (`~.int`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        alpha (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        A (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        strideA (`~.int`):
            (undocumented)

        B (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        ldb (`~.int`):
            (undocumented)

        strideB (`~.int`):
            (undocumented)

        C (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        ldc (`~.int`):
            (undocumented)

        strideC (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    if not isinstance(side,_hipblasSideMode_t__Base):
        raise TypeError("argument 'side' must be of type '_hipblasSideMode_t__Base'")                    
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")                    
    if not isinstance(transA,_hipblasOperation_t__Base):
        raise TypeError("argument 'transA' must be of type '_hipblasOperation_t__Base'")                    
    if not isinstance(diag,_hipblasDiagType_t__Base):
        raise TypeError("argument 'diag' must be of type '_hipblasDiagType_t__Base'")
    _hipblasDtrmmStridedBatched__retval = hipblasStatus_t(chipblas.hipblasDtrmmStridedBatched(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,side.value,uplo.value,transA.value,diag.value,m,n,
        <const double *>hip._util.types.Pointer.fromPyobj(alpha)._ptr,
        <const double *>hip._util.types.Pointer.fromPyobj(A)._ptr,lda,strideA,
        <const double *>hip._util.types.Pointer.fromPyobj(B)._ptr,ldb,strideB,
        <double *>hip._util.types.Pointer.fromPyobj(C)._ptr,ldc,strideC,batchCount))
    return (_hipblasDtrmmStridedBatched__retval,)


@cython.embedsignature(True)
def hipblasCtrmmStridedBatched(object handle, object side, object uplo, object transA, object diag, int m, int n, object alpha, object A, int lda, long strideA, object B, int ldb, long strideB, object C, int ldc, long strideC, int batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        side (`~.hipblasSideMode_t`):
            (undocumented)

        uplo (`~.hipblasFillMode_t`):
            (undocumented)

        transA (`~.hipblasOperation_t`):
            (undocumented)

        diag (`~.hipblasDiagType_t`):
            (undocumented)

        m (`~.int`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        alpha (`~.hipblasComplex`/`~.object`):
            (undocumented)

        A (`~.hipblasComplex`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        strideA (`~.int`):
            (undocumented)

        B (`~.hipblasComplex`/`~.object`):
            (undocumented)

        ldb (`~.int`):
            (undocumented)

        strideB (`~.int`):
            (undocumented)

        C (`~.hipblasComplex`/`~.object`):
            (undocumented)

        ldc (`~.int`):
            (undocumented)

        strideC (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    if not isinstance(side,_hipblasSideMode_t__Base):
        raise TypeError("argument 'side' must be of type '_hipblasSideMode_t__Base'")                    
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")                    
    if not isinstance(transA,_hipblasOperation_t__Base):
        raise TypeError("argument 'transA' must be of type '_hipblasOperation_t__Base'")                    
    if not isinstance(diag,_hipblasDiagType_t__Base):
        raise TypeError("argument 'diag' must be of type '_hipblasDiagType_t__Base'")
    _hipblasCtrmmStridedBatched__retval = hipblasStatus_t(chipblas.hipblasCtrmmStridedBatched(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,side.value,uplo.value,transA.value,diag.value,m,n,
        hipblasComplex.fromPyobj(alpha).getElementPtr(),
        hipblasComplex.fromPyobj(A).getElementPtr(),lda,strideA,
        hipblasComplex.fromPyobj(B).getElementPtr(),ldb,strideB,
        hipblasComplex.fromPyobj(C).getElementPtr(),ldc,strideC,batchCount))
    return (_hipblasCtrmmStridedBatched__retval,)


@cython.embedsignature(True)
def hipblasZtrmmStridedBatched(object handle, object side, object uplo, object transA, object diag, int m, int n, object alpha, object A, int lda, long strideA, object B, int ldb, long strideB, object C, int ldc, long strideC, int batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        side (`~.hipblasSideMode_t`):
            (undocumented)

        uplo (`~.hipblasFillMode_t`):
            (undocumented)

        transA (`~.hipblasOperation_t`):
            (undocumented)

        diag (`~.hipblasDiagType_t`):
            (undocumented)

        m (`~.int`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        alpha (`~.hipblasDoubleComplex`/`~.object`):
            (undocumented)

        A (`~.hipblasDoubleComplex`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        strideA (`~.int`):
            (undocumented)

        B (`~.hipblasDoubleComplex`/`~.object`):
            (undocumented)

        ldb (`~.int`):
            (undocumented)

        strideB (`~.int`):
            (undocumented)

        C (`~.hipblasDoubleComplex`/`~.object`):
            (undocumented)

        ldc (`~.int`):
            (undocumented)

        strideC (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    if not isinstance(side,_hipblasSideMode_t__Base):
        raise TypeError("argument 'side' must be of type '_hipblasSideMode_t__Base'")                    
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")                    
    if not isinstance(transA,_hipblasOperation_t__Base):
        raise TypeError("argument 'transA' must be of type '_hipblasOperation_t__Base'")                    
    if not isinstance(diag,_hipblasDiagType_t__Base):
        raise TypeError("argument 'diag' must be of type '_hipblasDiagType_t__Base'")
    _hipblasZtrmmStridedBatched__retval = hipblasStatus_t(chipblas.hipblasZtrmmStridedBatched(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,side.value,uplo.value,transA.value,diag.value,m,n,
        hipblasDoubleComplex.fromPyobj(alpha).getElementPtr(),
        hipblasDoubleComplex.fromPyobj(A).getElementPtr(),lda,strideA,
        hipblasDoubleComplex.fromPyobj(B).getElementPtr(),ldb,strideB,
        hipblasDoubleComplex.fromPyobj(C).getElementPtr(),ldc,strideC,batchCount))
    return (_hipblasZtrmmStridedBatched__retval,)


@cython.embedsignature(True)
def hipblasCtrmmStridedBatched_v2(object handle, object side, object uplo, object transA, object diag, int m, int n, object alpha, object A, int lda, long strideA, object B, int ldb, long strideB, object C, int ldc, long strideC, int batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        side (`~.hipblasSideMode_t`):
            (undocumented)

        uplo (`~.hipblasFillMode_t`):
            (undocumented)

        transA (`~.hipblasOperation_t`):
            (undocumented)

        diag (`~.hipblasDiagType_t`):
            (undocumented)

        m (`~.int`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        alpha (`~.float2`/`~.object`):
            (undocumented)

        A (`~.float2`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        strideA (`~.int`):
            (undocumented)

        B (`~.float2`/`~.object`):
            (undocumented)

        ldb (`~.int`):
            (undocumented)

        strideB (`~.int`):
            (undocumented)

        C (`~.float2`/`~.object`):
            (undocumented)

        ldc (`~.int`):
            (undocumented)

        strideC (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    if not isinstance(side,_hipblasSideMode_t__Base):
        raise TypeError("argument 'side' must be of type '_hipblasSideMode_t__Base'")                    
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")                    
    if not isinstance(transA,_hipblasOperation_t__Base):
        raise TypeError("argument 'transA' must be of type '_hipblasOperation_t__Base'")                    
    if not isinstance(diag,_hipblasDiagType_t__Base):
        raise TypeError("argument 'diag' must be of type '_hipblasDiagType_t__Base'")
    _hipblasCtrmmStridedBatched_v2__retval = hipblasStatus_t(chipblas.hipblasCtrmmStridedBatched_v2(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,side.value,uplo.value,transA.value,diag.value,m,n,
        float2.fromPyobj(alpha).getElementPtr(),
        float2.fromPyobj(A).getElementPtr(),lda,strideA,
        float2.fromPyobj(B).getElementPtr(),ldb,strideB,
        float2.fromPyobj(C).getElementPtr(),ldc,strideC,batchCount))
    return (_hipblasCtrmmStridedBatched_v2__retval,)


@cython.embedsignature(True)
def hipblasZtrmmStridedBatched_v2(object handle, object side, object uplo, object transA, object diag, int m, int n, object alpha, object A, int lda, long strideA, object B, int ldb, long strideB, object C, int ldc, long strideC, int batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        side (`~.hipblasSideMode_t`):
            (undocumented)

        uplo (`~.hipblasFillMode_t`):
            (undocumented)

        transA (`~.hipblasOperation_t`):
            (undocumented)

        diag (`~.hipblasDiagType_t`):
            (undocumented)

        m (`~.int`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        alpha (`~.double2`/`~.object`):
            (undocumented)

        A (`~.double2`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        strideA (`~.int`):
            (undocumented)

        B (`~.double2`/`~.object`):
            (undocumented)

        ldb (`~.int`):
            (undocumented)

        strideB (`~.int`):
            (undocumented)

        C (`~.double2`/`~.object`):
            (undocumented)

        ldc (`~.int`):
            (undocumented)

        strideC (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    if not isinstance(side,_hipblasSideMode_t__Base):
        raise TypeError("argument 'side' must be of type '_hipblasSideMode_t__Base'")                    
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")                    
    if not isinstance(transA,_hipblasOperation_t__Base):
        raise TypeError("argument 'transA' must be of type '_hipblasOperation_t__Base'")                    
    if not isinstance(diag,_hipblasDiagType_t__Base):
        raise TypeError("argument 'diag' must be of type '_hipblasDiagType_t__Base'")
    _hipblasZtrmmStridedBatched_v2__retval = hipblasStatus_t(chipblas.hipblasZtrmmStridedBatched_v2(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,side.value,uplo.value,transA.value,diag.value,m,n,
        double2.fromPyobj(alpha).getElementPtr(),
        double2.fromPyobj(A).getElementPtr(),lda,strideA,
        double2.fromPyobj(B).getElementPtr(),ldb,strideB,
        double2.fromPyobj(C).getElementPtr(),ldc,strideC,batchCount))
    return (_hipblasZtrmmStridedBatched_v2__retval,)


@cython.embedsignature(True)
def hipblasStrsm(object handle, object side, object uplo, object transA, object diag, int m, int n, object alpha, object AP, int lda, object BP, int ldb):
    r"""BLAS Level 3 API

    @{

    trsm solves

        op(A)*X = alpha*B or  X*op(A) = alpha*B,

    where alpha is a scalar, X and B are m by n matrices,
    A is triangular matrix and op(A) is one of

        op( A ) = A   or   op( A ) = A^T   or   op( A ) = A^H.

    The matrix X is overwritten on B.

    Note about memory allocation:
    When trsm is launched with a k evenly divisible by the internal block size of 128,
    and is no larger than 10 of these blocks, the API takes advantage of utilizing pre-allocated
    memory found in the handle to increase overall performance. This memory can be managed by using
    the environment variable WORKBUF_TRSM_B_CHNK. When this variable is not set the device memory
    used for temporary storage will default to 1 MB and may result in chunking, which in turn may
    reduce performance. Under these circumstances it is recommended that WORKBUF_TRSM_B_CHNK be set
    to the desired chunk of right hand sides to be used at a time.

    (where k is m when HIPBLAS_SIDE_LEFT and is n when HIPBLAS_SIDE_RIGHT)

    - Supported precisions in rocBLAS : s,d,c,z
    - Supported precisions in cuBLAS  : s,d,c,z

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`) -- *IN*:
            [hipblasHandle_t]
            handle to the hipblas library context queue.

        side (`~.hipblasSideMode_t`) -- *IN*:
            [hipblasSideMode_t]
            HIPBLAS_SIDE_LEFT:       op(A)*X = alpha*B.
            HIPBLAS_SIDE_RIGHT:      X*op(A) = alpha*B.

        uplo (`~.hipblasFillMode_t`) -- *IN*:
            [hipblasFillMode_t]
            HIPBLAS_FILL_MODE_UPPER:  A is an upper triangular matrix.
            HIPBLAS_FILL_MODE_LOWER:  A is a  lower triangular matrix.

        transA (`~.hipblasOperation_t`) -- *IN*:
            [hipblasOperation_t]
            HIPBLAS_OP_N: op(A) = A.
            HIPBLAS_OP_T: op(A) = A^T.
            HIPBLAS_OP_C: op(A) = A^H.

        diag (`~.hipblasDiagType_t`) -- *IN*:
            [hipblasDiagType_t]
            HIPBLAS_DIAG_UNIT:     A is assumed to be unit triangular.
            HIPBLAS_DIAG_NON_UNIT:  A is not assumed to be unit triangular.

        m (`~.int`) -- *IN*:
            [int]
            m specifies the number of rows of B. m >= 0.

        n (`~.int`) -- *IN*:
            [int]
            n specifies the number of columns of B. n >= 0.

        alpha (`~.hip._util.types.Pointer`/`~.object`) -- *IN*:
            device pointer or host pointer specifying the scalar alpha. When alpha is
            &zero then A is not referenced and B need not be set before
            entry.

        AP (`~.hip._util.types.Pointer`/`~.object`) -- *IN*:
            device pointer storing matrix A.
            of dimension ( lda, k ), where k is m
            when  HIPBLAS_SIDE_LEFT  and
            is  n  when  HIPBLAS_SIDE_RIGHT
            only the upper/lower triangular part is accessed.

        lda (`~.int`) -- *IN*:
            [int]
            lda specifies the first dimension of A.
            if side = HIPBLAS_SIDE_LEFT,  lda >= max( 1, m ),
            if side = HIPBLAS_SIDE_RIGHT, lda >= max( 1, n ).

        BP (`~.hip._util.types.Pointer`/`~.object`) -- *IN,OUT*:
            device pointer storing matrix B.

        ldb (`~.int`) -- *IN*:
            [int]
            ldb specifies the first dimension of B. ldb >= max( 1, m ).
    """
    if not isinstance(side,_hipblasSideMode_t__Base):
        raise TypeError("argument 'side' must be of type '_hipblasSideMode_t__Base'")                    
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")                    
    if not isinstance(transA,_hipblasOperation_t__Base):
        raise TypeError("argument 'transA' must be of type '_hipblasOperation_t__Base'")                    
    if not isinstance(diag,_hipblasDiagType_t__Base):
        raise TypeError("argument 'diag' must be of type '_hipblasDiagType_t__Base'")
    _hipblasStrsm__retval = hipblasStatus_t(chipblas.hipblasStrsm(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,side.value,uplo.value,transA.value,diag.value,m,n,
        <const float *>hip._util.types.Pointer.fromPyobj(alpha)._ptr,
        <const float *>hip._util.types.Pointer.fromPyobj(AP)._ptr,lda,
        <float *>hip._util.types.Pointer.fromPyobj(BP)._ptr,ldb))
    return (_hipblasStrsm__retval,)


@cython.embedsignature(True)
def hipblasDtrsm(object handle, object side, object uplo, object transA, object diag, int m, int n, object alpha, object AP, int lda, object BP, int ldb):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        side (`~.hipblasSideMode_t`):
            (undocumented)

        uplo (`~.hipblasFillMode_t`):
            (undocumented)

        transA (`~.hipblasOperation_t`):
            (undocumented)

        diag (`~.hipblasDiagType_t`):
            (undocumented)

        m (`~.int`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        alpha (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        AP (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        BP (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        ldb (`~.int`):
            (undocumented)
    """
    if not isinstance(side,_hipblasSideMode_t__Base):
        raise TypeError("argument 'side' must be of type '_hipblasSideMode_t__Base'")                    
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")                    
    if not isinstance(transA,_hipblasOperation_t__Base):
        raise TypeError("argument 'transA' must be of type '_hipblasOperation_t__Base'")                    
    if not isinstance(diag,_hipblasDiagType_t__Base):
        raise TypeError("argument 'diag' must be of type '_hipblasDiagType_t__Base'")
    _hipblasDtrsm__retval = hipblasStatus_t(chipblas.hipblasDtrsm(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,side.value,uplo.value,transA.value,diag.value,m,n,
        <const double *>hip._util.types.Pointer.fromPyobj(alpha)._ptr,
        <const double *>hip._util.types.Pointer.fromPyobj(AP)._ptr,lda,
        <double *>hip._util.types.Pointer.fromPyobj(BP)._ptr,ldb))
    return (_hipblasDtrsm__retval,)


@cython.embedsignature(True)
def hipblasCtrsm(object handle, object side, object uplo, object transA, object diag, int m, int n, object alpha, object AP, int lda, object BP, int ldb):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        side (`~.hipblasSideMode_t`):
            (undocumented)

        uplo (`~.hipblasFillMode_t`):
            (undocumented)

        transA (`~.hipblasOperation_t`):
            (undocumented)

        diag (`~.hipblasDiagType_t`):
            (undocumented)

        m (`~.int`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        alpha (`~.hipblasComplex`/`~.object`):
            (undocumented)

        AP (`~.hipblasComplex`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        BP (`~.hipblasComplex`/`~.object`):
            (undocumented)

        ldb (`~.int`):
            (undocumented)
    """
    if not isinstance(side,_hipblasSideMode_t__Base):
        raise TypeError("argument 'side' must be of type '_hipblasSideMode_t__Base'")                    
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")                    
    if not isinstance(transA,_hipblasOperation_t__Base):
        raise TypeError("argument 'transA' must be of type '_hipblasOperation_t__Base'")                    
    if not isinstance(diag,_hipblasDiagType_t__Base):
        raise TypeError("argument 'diag' must be of type '_hipblasDiagType_t__Base'")
    _hipblasCtrsm__retval = hipblasStatus_t(chipblas.hipblasCtrsm(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,side.value,uplo.value,transA.value,diag.value,m,n,
        hipblasComplex.fromPyobj(alpha).getElementPtr(),
        hipblasComplex.fromPyobj(AP).getElementPtr(),lda,
        hipblasComplex.fromPyobj(BP).getElementPtr(),ldb))
    return (_hipblasCtrsm__retval,)


@cython.embedsignature(True)
def hipblasZtrsm(object handle, object side, object uplo, object transA, object diag, int m, int n, object alpha, object AP, int lda, object BP, int ldb):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        side (`~.hipblasSideMode_t`):
            (undocumented)

        uplo (`~.hipblasFillMode_t`):
            (undocumented)

        transA (`~.hipblasOperation_t`):
            (undocumented)

        diag (`~.hipblasDiagType_t`):
            (undocumented)

        m (`~.int`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        alpha (`~.hipblasDoubleComplex`/`~.object`):
            (undocumented)

        AP (`~.hipblasDoubleComplex`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        BP (`~.hipblasDoubleComplex`/`~.object`):
            (undocumented)

        ldb (`~.int`):
            (undocumented)
    """
    if not isinstance(side,_hipblasSideMode_t__Base):
        raise TypeError("argument 'side' must be of type '_hipblasSideMode_t__Base'")                    
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")                    
    if not isinstance(transA,_hipblasOperation_t__Base):
        raise TypeError("argument 'transA' must be of type '_hipblasOperation_t__Base'")                    
    if not isinstance(diag,_hipblasDiagType_t__Base):
        raise TypeError("argument 'diag' must be of type '_hipblasDiagType_t__Base'")
    _hipblasZtrsm__retval = hipblasStatus_t(chipblas.hipblasZtrsm(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,side.value,uplo.value,transA.value,diag.value,m,n,
        hipblasDoubleComplex.fromPyobj(alpha).getElementPtr(),
        hipblasDoubleComplex.fromPyobj(AP).getElementPtr(),lda,
        hipblasDoubleComplex.fromPyobj(BP).getElementPtr(),ldb))
    return (_hipblasZtrsm__retval,)


@cython.embedsignature(True)
def hipblasCtrsm_v2(object handle, object side, object uplo, object transA, object diag, int m, int n, object alpha, object AP, int lda, object BP, int ldb):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        side (`~.hipblasSideMode_t`):
            (undocumented)

        uplo (`~.hipblasFillMode_t`):
            (undocumented)

        transA (`~.hipblasOperation_t`):
            (undocumented)

        diag (`~.hipblasDiagType_t`):
            (undocumented)

        m (`~.int`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        alpha (`~.float2`/`~.object`):
            (undocumented)

        AP (`~.float2`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        BP (`~.float2`/`~.object`):
            (undocumented)

        ldb (`~.int`):
            (undocumented)
    """
    if not isinstance(side,_hipblasSideMode_t__Base):
        raise TypeError("argument 'side' must be of type '_hipblasSideMode_t__Base'")                    
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")                    
    if not isinstance(transA,_hipblasOperation_t__Base):
        raise TypeError("argument 'transA' must be of type '_hipblasOperation_t__Base'")                    
    if not isinstance(diag,_hipblasDiagType_t__Base):
        raise TypeError("argument 'diag' must be of type '_hipblasDiagType_t__Base'")
    _hipblasCtrsm_v2__retval = hipblasStatus_t(chipblas.hipblasCtrsm_v2(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,side.value,uplo.value,transA.value,diag.value,m,n,
        float2.fromPyobj(alpha).getElementPtr(),
        float2.fromPyobj(AP).getElementPtr(),lda,
        float2.fromPyobj(BP).getElementPtr(),ldb))
    return (_hipblasCtrsm_v2__retval,)


@cython.embedsignature(True)
def hipblasZtrsm_v2(object handle, object side, object uplo, object transA, object diag, int m, int n, object alpha, object AP, int lda, object BP, int ldb):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        side (`~.hipblasSideMode_t`):
            (undocumented)

        uplo (`~.hipblasFillMode_t`):
            (undocumented)

        transA (`~.hipblasOperation_t`):
            (undocumented)

        diag (`~.hipblasDiagType_t`):
            (undocumented)

        m (`~.int`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        alpha (`~.double2`/`~.object`):
            (undocumented)

        AP (`~.double2`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        BP (`~.double2`/`~.object`):
            (undocumented)

        ldb (`~.int`):
            (undocumented)
    """
    if not isinstance(side,_hipblasSideMode_t__Base):
        raise TypeError("argument 'side' must be of type '_hipblasSideMode_t__Base'")                    
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")                    
    if not isinstance(transA,_hipblasOperation_t__Base):
        raise TypeError("argument 'transA' must be of type '_hipblasOperation_t__Base'")                    
    if not isinstance(diag,_hipblasDiagType_t__Base):
        raise TypeError("argument 'diag' must be of type '_hipblasDiagType_t__Base'")
    _hipblasZtrsm_v2__retval = hipblasStatus_t(chipblas.hipblasZtrsm_v2(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,side.value,uplo.value,transA.value,diag.value,m,n,
        double2.fromPyobj(alpha).getElementPtr(),
        double2.fromPyobj(AP).getElementPtr(),lda,
        double2.fromPyobj(BP).getElementPtr(),ldb))
    return (_hipblasZtrsm_v2__retval,)


@cython.embedsignature(True)
def hipblasStrsmBatched(object handle, object side, object uplo, object transA, object diag, int m, int n, object alpha, object AP, int lda, object BP, int ldb, int batchCount):
    r"""BLAS Level 3 API

    @{

    trsmBatched performs the following batched operation:

    op(A_i)*X_i = alpha*B_i or  X_i*op(A_i) = alpha*B_i, for i = 1, ..., batchCount.

    where alpha is a scalar, X and B are batched m by n matrices,
    A is triangular batched matrix and op(A) is one of

        op( A ) = A   or   op( A ) = A^T   or   op( A ) = A^H.

    Each matrix X_i is overwritten on B_i for i = 1, ..., batchCount.

    Note about memory allocation:
    When trsm is launched with a k evenly divisible by the internal block size of 128,
    and is no larger than 10 of these blocks, the API takes advantage of utilizing pre-allocated
    memory found in the handle to increase overall performance. This memory can be managed by using
    the environment variable WORKBUF_TRSM_B_CHNK. When this variable is not set the device memory
    used for temporary storage will default to 1 MB and may result in chunking, which in turn may
    reduce performance. Under these circumstances it is recommended that WORKBUF_TRSM_B_CHNK be set
    to the desired chunk of right hand sides to be used at a time.
    (where k is m when HIPBLAS_SIDE_LEFT and is n when HIPBLAS_SIDE_RIGHT)

    - Supported precisions in rocBLAS : s,d,c,z
    - Supported precisions in cuBLAS  : s,d,c,z

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`) -- *IN*:
            [hipblasHandle_t]
            handle to the hipblas library context queue.

        side (`~.hipblasSideMode_t`) -- *IN*:
            [hipblasSideMode_t]
            HIPBLAS_SIDE_LEFT:       op(A)*X = alpha*B.
            HIPBLAS_SIDE_RIGHT:      X*op(A) = alpha*B.

        uplo (`~.hipblasFillMode_t`) -- *IN*:
            [hipblasFillMode_t]
            HIPBLAS_FILL_MODE_UPPER:  each A_i is an upper triangular matrix.
            HIPBLAS_FILL_MODE_LOWER:  each A_i is a  lower triangular matrix.

        transA (`~.hipblasOperation_t`) -- *IN*:
            [hipblasOperation_t]
            HIPBLAS_OP_N: op(A) = A.
            HIPBLAS_OP_T: op(A) = A^T.
            HIPBLAS_OP_C: op(A) = A^H.

        diag (`~.hipblasDiagType_t`) -- *IN*:
            [hipblasDiagType_t]
            HIPBLAS_DIAG_UNIT:     each A_i is assumed to be unit triangular.
            HIPBLAS_DIAG_NON_UNIT:  each A_i is not assumed to be unit triangular.

        m (`~.int`) -- *IN*:
            [int]
            m specifies the number of rows of each B_i. m >= 0.

        n (`~.int`) -- *IN*:
            [int]
            n specifies the number of columns of each B_i. n >= 0.

        alpha (`~.hip._util.types.Pointer`/`~.object`) -- *IN*:
            device pointer or host pointer specifying the scalar alpha. When alpha is
            &zero then A is not referenced and B need not be set before
            entry.

        AP (`~.hip._util.types.Pointer`/`~.object`) -- *IN*:
            device array of device pointers storing each matrix A_i on the GPU.
            Matricies are of dimension ( lda, k ), where k is m
            when  HIPBLAS_SIDE_LEFT  and is  n  when  HIPBLAS_SIDE_RIGHT
            only the upper/lower triangular part is accessed.

        lda (`~.int`) -- *IN*:
            [int]
            lda specifies the first dimension of each A_i.
            if side = HIPBLAS_SIDE_LEFT,  lda >= max( 1, m ),
            if side = HIPBLAS_SIDE_RIGHT, lda >= max( 1, n ).

        BP (`~.hip._util.types.Pointer`/`~.object`) -- *IN,OUT*:
            device array of device pointers storing each matrix B_i on the GPU.

        ldb (`~.int`) -- *IN*:
            [int]
            ldb specifies the first dimension of each B_i. ldb >= max( 1, m ).

        batchCount (`~.int`) -- *IN*:
            [int]
            number of trsm operatons in the batch.
    """
    if not isinstance(side,_hipblasSideMode_t__Base):
        raise TypeError("argument 'side' must be of type '_hipblasSideMode_t__Base'")                    
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")                    
    if not isinstance(transA,_hipblasOperation_t__Base):
        raise TypeError("argument 'transA' must be of type '_hipblasOperation_t__Base'")                    
    if not isinstance(diag,_hipblasDiagType_t__Base):
        raise TypeError("argument 'diag' must be of type '_hipblasDiagType_t__Base'")
    _hipblasStrsmBatched__retval = hipblasStatus_t(chipblas.hipblasStrsmBatched(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,side.value,uplo.value,transA.value,diag.value,m,n,
        <const float *>hip._util.types.Pointer.fromPyobj(alpha)._ptr,
        <const float *const*>hip._util.types.Pointer.fromPyobj(AP)._ptr,lda,
        <float *const*>hip._util.types.Pointer.fromPyobj(BP)._ptr,ldb,batchCount))
    return (_hipblasStrsmBatched__retval,)


@cython.embedsignature(True)
def hipblasDtrsmBatched(object handle, object side, object uplo, object transA, object diag, int m, int n, object alpha, object AP, int lda, object BP, int ldb, int batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        side (`~.hipblasSideMode_t`):
            (undocumented)

        uplo (`~.hipblasFillMode_t`):
            (undocumented)

        transA (`~.hipblasOperation_t`):
            (undocumented)

        diag (`~.hipblasDiagType_t`):
            (undocumented)

        m (`~.int`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        alpha (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        AP (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        BP (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        ldb (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    if not isinstance(side,_hipblasSideMode_t__Base):
        raise TypeError("argument 'side' must be of type '_hipblasSideMode_t__Base'")                    
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")                    
    if not isinstance(transA,_hipblasOperation_t__Base):
        raise TypeError("argument 'transA' must be of type '_hipblasOperation_t__Base'")                    
    if not isinstance(diag,_hipblasDiagType_t__Base):
        raise TypeError("argument 'diag' must be of type '_hipblasDiagType_t__Base'")
    _hipblasDtrsmBatched__retval = hipblasStatus_t(chipblas.hipblasDtrsmBatched(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,side.value,uplo.value,transA.value,diag.value,m,n,
        <const double *>hip._util.types.Pointer.fromPyobj(alpha)._ptr,
        <const double *const*>hip._util.types.Pointer.fromPyobj(AP)._ptr,lda,
        <double *const*>hip._util.types.Pointer.fromPyobj(BP)._ptr,ldb,batchCount))
    return (_hipblasDtrsmBatched__retval,)


@cython.embedsignature(True)
def hipblasCtrsmBatched(object handle, object side, object uplo, object transA, object diag, int m, int n, object alpha, object AP, int lda, object BP, int ldb, int batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        side (`~.hipblasSideMode_t`):
            (undocumented)

        uplo (`~.hipblasFillMode_t`):
            (undocumented)

        transA (`~.hipblasOperation_t`):
            (undocumented)

        diag (`~.hipblasDiagType_t`):
            (undocumented)

        m (`~.int`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        alpha (`~.hipblasComplex`/`~.object`):
            (undocumented)

        AP (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        BP (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        ldb (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    if not isinstance(side,_hipblasSideMode_t__Base):
        raise TypeError("argument 'side' must be of type '_hipblasSideMode_t__Base'")                    
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")                    
    if not isinstance(transA,_hipblasOperation_t__Base):
        raise TypeError("argument 'transA' must be of type '_hipblasOperation_t__Base'")                    
    if not isinstance(diag,_hipblasDiagType_t__Base):
        raise TypeError("argument 'diag' must be of type '_hipblasDiagType_t__Base'")
    _hipblasCtrsmBatched__retval = hipblasStatus_t(chipblas.hipblasCtrsmBatched(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,side.value,uplo.value,transA.value,diag.value,m,n,
        hipblasComplex.fromPyobj(alpha).getElementPtr(),
        <chipblas.hipblasComplex *const*>hip._util.types.Pointer.fromPyobj(AP)._ptr,lda,
        <chipblas.hipblasComplex *const*>hip._util.types.Pointer.fromPyobj(BP)._ptr,ldb,batchCount))
    return (_hipblasCtrsmBatched__retval,)


@cython.embedsignature(True)
def hipblasZtrsmBatched(object handle, object side, object uplo, object transA, object diag, int m, int n, object alpha, object AP, int lda, object BP, int ldb, int batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        side (`~.hipblasSideMode_t`):
            (undocumented)

        uplo (`~.hipblasFillMode_t`):
            (undocumented)

        transA (`~.hipblasOperation_t`):
            (undocumented)

        diag (`~.hipblasDiagType_t`):
            (undocumented)

        m (`~.int`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        alpha (`~.hipblasDoubleComplex`/`~.object`):
            (undocumented)

        AP (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        BP (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        ldb (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    if not isinstance(side,_hipblasSideMode_t__Base):
        raise TypeError("argument 'side' must be of type '_hipblasSideMode_t__Base'")                    
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")                    
    if not isinstance(transA,_hipblasOperation_t__Base):
        raise TypeError("argument 'transA' must be of type '_hipblasOperation_t__Base'")                    
    if not isinstance(diag,_hipblasDiagType_t__Base):
        raise TypeError("argument 'diag' must be of type '_hipblasDiagType_t__Base'")
    _hipblasZtrsmBatched__retval = hipblasStatus_t(chipblas.hipblasZtrsmBatched(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,side.value,uplo.value,transA.value,diag.value,m,n,
        hipblasDoubleComplex.fromPyobj(alpha).getElementPtr(),
        <chipblas.hipblasDoubleComplex *const*>hip._util.types.Pointer.fromPyobj(AP)._ptr,lda,
        <chipblas.hipblasDoubleComplex *const*>hip._util.types.Pointer.fromPyobj(BP)._ptr,ldb,batchCount))
    return (_hipblasZtrsmBatched__retval,)


@cython.embedsignature(True)
def hipblasCtrsmBatched_v2(object handle, object side, object uplo, object transA, object diag, int m, int n, object alpha, object AP, int lda, object BP, int ldb, int batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        side (`~.hipblasSideMode_t`):
            (undocumented)

        uplo (`~.hipblasFillMode_t`):
            (undocumented)

        transA (`~.hipblasOperation_t`):
            (undocumented)

        diag (`~.hipblasDiagType_t`):
            (undocumented)

        m (`~.int`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        alpha (`~.float2`/`~.object`):
            (undocumented)

        AP (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        BP (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        ldb (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    if not isinstance(side,_hipblasSideMode_t__Base):
        raise TypeError("argument 'side' must be of type '_hipblasSideMode_t__Base'")                    
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")                    
    if not isinstance(transA,_hipblasOperation_t__Base):
        raise TypeError("argument 'transA' must be of type '_hipblasOperation_t__Base'")                    
    if not isinstance(diag,_hipblasDiagType_t__Base):
        raise TypeError("argument 'diag' must be of type '_hipblasDiagType_t__Base'")
    _hipblasCtrsmBatched_v2__retval = hipblasStatus_t(chipblas.hipblasCtrsmBatched_v2(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,side.value,uplo.value,transA.value,diag.value,m,n,
        float2.fromPyobj(alpha).getElementPtr(),
        <chipblas.float2 *const*>hip._util.types.Pointer.fromPyobj(AP)._ptr,lda,
        <chipblas.float2 *const*>hip._util.types.Pointer.fromPyobj(BP)._ptr,ldb,batchCount))
    return (_hipblasCtrsmBatched_v2__retval,)


@cython.embedsignature(True)
def hipblasZtrsmBatched_v2(object handle, object side, object uplo, object transA, object diag, int m, int n, object alpha, object AP, int lda, object BP, int ldb, int batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        side (`~.hipblasSideMode_t`):
            (undocumented)

        uplo (`~.hipblasFillMode_t`):
            (undocumented)

        transA (`~.hipblasOperation_t`):
            (undocumented)

        diag (`~.hipblasDiagType_t`):
            (undocumented)

        m (`~.int`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        alpha (`~.double2`/`~.object`):
            (undocumented)

        AP (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        BP (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        ldb (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    if not isinstance(side,_hipblasSideMode_t__Base):
        raise TypeError("argument 'side' must be of type '_hipblasSideMode_t__Base'")                    
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")                    
    if not isinstance(transA,_hipblasOperation_t__Base):
        raise TypeError("argument 'transA' must be of type '_hipblasOperation_t__Base'")                    
    if not isinstance(diag,_hipblasDiagType_t__Base):
        raise TypeError("argument 'diag' must be of type '_hipblasDiagType_t__Base'")
    _hipblasZtrsmBatched_v2__retval = hipblasStatus_t(chipblas.hipblasZtrsmBatched_v2(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,side.value,uplo.value,transA.value,diag.value,m,n,
        double2.fromPyobj(alpha).getElementPtr(),
        <chipblas.double2 *const*>hip._util.types.Pointer.fromPyobj(AP)._ptr,lda,
        <chipblas.double2 *const*>hip._util.types.Pointer.fromPyobj(BP)._ptr,ldb,batchCount))
    return (_hipblasZtrsmBatched_v2__retval,)


@cython.embedsignature(True)
def hipblasStrsmStridedBatched(object handle, object side, object uplo, object transA, object diag, int m, int n, object alpha, object AP, int lda, long strideA, object BP, int ldb, long strideB, int batchCount):
    r"""BLAS Level 3 API

    @{

    trsmSridedBatched performs the following strided batched operation:

    op(A_i)*X_i = alpha*B_i or  X_i*op(A_i) = alpha*B_i, for i = 1, ..., batchCount.

    where alpha is a scalar, X and B are strided batched m by n matrices,
    A is triangular strided batched matrix and op(A) is one of

        op( A ) = A   or   op( A ) = A^T   or   op( A ) = A^H.

    Each matrix X_i is overwritten on B_i for i = 1, ..., batchCount.

    Note about memory allocation:
    When trsm is launched with a k evenly divisible by the internal block size of 128,
    and is no larger than 10 of these blocks, the API takes advantage of utilizing pre-allocated
    memory found in the handle to increase overall performance. This memory can be managed by using
    the environment variable WORKBUF_TRSM_B_CHNK. When this variable is not set the device memory
    used for temporary storage will default to 1 MB and may result in chunking, which in turn may
    reduce performance. Under these circumstances it is recommended that WORKBUF_TRSM_B_CHNK be set
    to the desired chunk of right hand sides to be used at a time.
    (where k is m when HIPBLAS_SIDE_LEFT and is n when HIPBLAS_SIDE_RIGHT)

    - Supported precisions in rocBLAS : s,d,c,z
    - Supported precisions in cuBLAS  : No support

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`) -- *IN*:
            [hipblasHandle_t]
            handle to the hipblas library context queue.

        side (`~.hipblasSideMode_t`) -- *IN*:
            [hipblasSideMode_t]
            HIPBLAS_SIDE_LEFT:       op(A)*X = alpha*B.
            HIPBLAS_SIDE_RIGHT:      X*op(A) = alpha*B.

        uplo (`~.hipblasFillMode_t`) -- *IN*:
            [hipblasFillMode_t]
            HIPBLAS_FILL_MODE_UPPER:  each A_i is an upper triangular matrix.
            HIPBLAS_FILL_MODE_LOWER:  each A_i is a  lower triangular matrix.

        transA (`~.hipblasOperation_t`) -- *IN*:
            [hipblasOperation_t]
            HIPBLAS_OP_N: op(A) = A.
            HIPBLAS_OP_T: op(A) = A^T.
            HIPBLAS_OP_C: op(A) = A^H.

        diag (`~.hipblasDiagType_t`) -- *IN*:
            [hipblasDiagType_t]
            HIPBLAS_DIAG_UNIT:     each A_i is assumed to be unit triangular.
            HIPBLAS_DIAG_NON_UNIT:  each A_i is not assumed to be unit triangular.

        m (`~.int`) -- *IN*:
            [int]
            m specifies the number of rows of each B_i. m >= 0.

        n (`~.int`) -- *IN*:
            [int]
            n specifies the number of columns of each B_i. n >= 0.

        alpha (`~.hip._util.types.Pointer`/`~.object`) -- *IN*:
            device pointer or host pointer specifying the scalar alpha. When alpha is
            &zero then A is not referenced and B need not be set before
            entry.

        AP (`~.hip._util.types.Pointer`/`~.object`) -- *IN*:
            device pointer pointing to the first matrix A_1.
            of dimension ( lda, k ), where k is m
            when  HIPBLAS_SIDE_LEFT  and
            is  n  when  HIPBLAS_SIDE_RIGHT
            only the upper/lower triangular part is accessed.

        lda (`~.int`) -- *IN*:
            [int]
            lda specifies the first dimension of each A_i.
            if side = HIPBLAS_SIDE_LEFT,  lda >= max( 1, m ),
            if side = HIPBLAS_SIDE_RIGHT, lda >= max( 1, n ).

        strideA (`~.int`) -- *IN*:
            [hipblasStride]
            stride from the start of one A_i matrix to the next A_(i + 1).

        BP (`~.hip._util.types.Pointer`/`~.object`) -- *IN,OUT*:
            device pointer pointing to the first matrix B_1.

        ldb (`~.int`) -- *IN*:
            [int]
            ldb specifies the first dimension of each B_i. ldb >= max( 1, m ).

        strideB (`~.int`) -- *IN*:
            [hipblasStride]
            stride from the start of one B_i matrix to the next B_(i + 1).

        batchCount (`~.int`) -- *IN*:
            [int]
            number of trsm operatons in the batch.
    """
    if not isinstance(side,_hipblasSideMode_t__Base):
        raise TypeError("argument 'side' must be of type '_hipblasSideMode_t__Base'")                    
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")                    
    if not isinstance(transA,_hipblasOperation_t__Base):
        raise TypeError("argument 'transA' must be of type '_hipblasOperation_t__Base'")                    
    if not isinstance(diag,_hipblasDiagType_t__Base):
        raise TypeError("argument 'diag' must be of type '_hipblasDiagType_t__Base'")
    _hipblasStrsmStridedBatched__retval = hipblasStatus_t(chipblas.hipblasStrsmStridedBatched(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,side.value,uplo.value,transA.value,diag.value,m,n,
        <const float *>hip._util.types.Pointer.fromPyobj(alpha)._ptr,
        <const float *>hip._util.types.Pointer.fromPyobj(AP)._ptr,lda,strideA,
        <float *>hip._util.types.Pointer.fromPyobj(BP)._ptr,ldb,strideB,batchCount))
    return (_hipblasStrsmStridedBatched__retval,)


@cython.embedsignature(True)
def hipblasDtrsmStridedBatched(object handle, object side, object uplo, object transA, object diag, int m, int n, object alpha, object AP, int lda, long strideA, object BP, int ldb, long strideB, int batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        side (`~.hipblasSideMode_t`):
            (undocumented)

        uplo (`~.hipblasFillMode_t`):
            (undocumented)

        transA (`~.hipblasOperation_t`):
            (undocumented)

        diag (`~.hipblasDiagType_t`):
            (undocumented)

        m (`~.int`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        alpha (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        AP (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        strideA (`~.int`):
            (undocumented)

        BP (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        ldb (`~.int`):
            (undocumented)

        strideB (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    if not isinstance(side,_hipblasSideMode_t__Base):
        raise TypeError("argument 'side' must be of type '_hipblasSideMode_t__Base'")                    
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")                    
    if not isinstance(transA,_hipblasOperation_t__Base):
        raise TypeError("argument 'transA' must be of type '_hipblasOperation_t__Base'")                    
    if not isinstance(diag,_hipblasDiagType_t__Base):
        raise TypeError("argument 'diag' must be of type '_hipblasDiagType_t__Base'")
    _hipblasDtrsmStridedBatched__retval = hipblasStatus_t(chipblas.hipblasDtrsmStridedBatched(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,side.value,uplo.value,transA.value,diag.value,m,n,
        <const double *>hip._util.types.Pointer.fromPyobj(alpha)._ptr,
        <const double *>hip._util.types.Pointer.fromPyobj(AP)._ptr,lda,strideA,
        <double *>hip._util.types.Pointer.fromPyobj(BP)._ptr,ldb,strideB,batchCount))
    return (_hipblasDtrsmStridedBatched__retval,)


@cython.embedsignature(True)
def hipblasCtrsmStridedBatched(object handle, object side, object uplo, object transA, object diag, int m, int n, object alpha, object AP, int lda, long strideA, object BP, int ldb, long strideB, int batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        side (`~.hipblasSideMode_t`):
            (undocumented)

        uplo (`~.hipblasFillMode_t`):
            (undocumented)

        transA (`~.hipblasOperation_t`):
            (undocumented)

        diag (`~.hipblasDiagType_t`):
            (undocumented)

        m (`~.int`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        alpha (`~.hipblasComplex`/`~.object`):
            (undocumented)

        AP (`~.hipblasComplex`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        strideA (`~.int`):
            (undocumented)

        BP (`~.hipblasComplex`/`~.object`):
            (undocumented)

        ldb (`~.int`):
            (undocumented)

        strideB (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    if not isinstance(side,_hipblasSideMode_t__Base):
        raise TypeError("argument 'side' must be of type '_hipblasSideMode_t__Base'")                    
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")                    
    if not isinstance(transA,_hipblasOperation_t__Base):
        raise TypeError("argument 'transA' must be of type '_hipblasOperation_t__Base'")                    
    if not isinstance(diag,_hipblasDiagType_t__Base):
        raise TypeError("argument 'diag' must be of type '_hipblasDiagType_t__Base'")
    _hipblasCtrsmStridedBatched__retval = hipblasStatus_t(chipblas.hipblasCtrsmStridedBatched(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,side.value,uplo.value,transA.value,diag.value,m,n,
        hipblasComplex.fromPyobj(alpha).getElementPtr(),
        hipblasComplex.fromPyobj(AP).getElementPtr(),lda,strideA,
        hipblasComplex.fromPyobj(BP).getElementPtr(),ldb,strideB,batchCount))
    return (_hipblasCtrsmStridedBatched__retval,)


@cython.embedsignature(True)
def hipblasZtrsmStridedBatched(object handle, object side, object uplo, object transA, object diag, int m, int n, object alpha, object AP, int lda, long strideA, object BP, int ldb, long strideB, int batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        side (`~.hipblasSideMode_t`):
            (undocumented)

        uplo (`~.hipblasFillMode_t`):
            (undocumented)

        transA (`~.hipblasOperation_t`):
            (undocumented)

        diag (`~.hipblasDiagType_t`):
            (undocumented)

        m (`~.int`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        alpha (`~.hipblasDoubleComplex`/`~.object`):
            (undocumented)

        AP (`~.hipblasDoubleComplex`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        strideA (`~.int`):
            (undocumented)

        BP (`~.hipblasDoubleComplex`/`~.object`):
            (undocumented)

        ldb (`~.int`):
            (undocumented)

        strideB (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    if not isinstance(side,_hipblasSideMode_t__Base):
        raise TypeError("argument 'side' must be of type '_hipblasSideMode_t__Base'")                    
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")                    
    if not isinstance(transA,_hipblasOperation_t__Base):
        raise TypeError("argument 'transA' must be of type '_hipblasOperation_t__Base'")                    
    if not isinstance(diag,_hipblasDiagType_t__Base):
        raise TypeError("argument 'diag' must be of type '_hipblasDiagType_t__Base'")
    _hipblasZtrsmStridedBatched__retval = hipblasStatus_t(chipblas.hipblasZtrsmStridedBatched(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,side.value,uplo.value,transA.value,diag.value,m,n,
        hipblasDoubleComplex.fromPyobj(alpha).getElementPtr(),
        hipblasDoubleComplex.fromPyobj(AP).getElementPtr(),lda,strideA,
        hipblasDoubleComplex.fromPyobj(BP).getElementPtr(),ldb,strideB,batchCount))
    return (_hipblasZtrsmStridedBatched__retval,)


@cython.embedsignature(True)
def hipblasCtrsmStridedBatched_v2(object handle, object side, object uplo, object transA, object diag, int m, int n, object alpha, object AP, int lda, long strideA, object BP, int ldb, long strideB, int batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        side (`~.hipblasSideMode_t`):
            (undocumented)

        uplo (`~.hipblasFillMode_t`):
            (undocumented)

        transA (`~.hipblasOperation_t`):
            (undocumented)

        diag (`~.hipblasDiagType_t`):
            (undocumented)

        m (`~.int`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        alpha (`~.float2`/`~.object`):
            (undocumented)

        AP (`~.float2`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        strideA (`~.int`):
            (undocumented)

        BP (`~.float2`/`~.object`):
            (undocumented)

        ldb (`~.int`):
            (undocumented)

        strideB (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    if not isinstance(side,_hipblasSideMode_t__Base):
        raise TypeError("argument 'side' must be of type '_hipblasSideMode_t__Base'")                    
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")                    
    if not isinstance(transA,_hipblasOperation_t__Base):
        raise TypeError("argument 'transA' must be of type '_hipblasOperation_t__Base'")                    
    if not isinstance(diag,_hipblasDiagType_t__Base):
        raise TypeError("argument 'diag' must be of type '_hipblasDiagType_t__Base'")
    _hipblasCtrsmStridedBatched_v2__retval = hipblasStatus_t(chipblas.hipblasCtrsmStridedBatched_v2(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,side.value,uplo.value,transA.value,diag.value,m,n,
        float2.fromPyobj(alpha).getElementPtr(),
        float2.fromPyobj(AP).getElementPtr(),lda,strideA,
        float2.fromPyobj(BP).getElementPtr(),ldb,strideB,batchCount))
    return (_hipblasCtrsmStridedBatched_v2__retval,)


@cython.embedsignature(True)
def hipblasZtrsmStridedBatched_v2(object handle, object side, object uplo, object transA, object diag, int m, int n, object alpha, object AP, int lda, long strideA, object BP, int ldb, long strideB, int batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        side (`~.hipblasSideMode_t`):
            (undocumented)

        uplo (`~.hipblasFillMode_t`):
            (undocumented)

        transA (`~.hipblasOperation_t`):
            (undocumented)

        diag (`~.hipblasDiagType_t`):
            (undocumented)

        m (`~.int`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        alpha (`~.double2`/`~.object`):
            (undocumented)

        AP (`~.double2`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        strideA (`~.int`):
            (undocumented)

        BP (`~.double2`/`~.object`):
            (undocumented)

        ldb (`~.int`):
            (undocumented)

        strideB (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    if not isinstance(side,_hipblasSideMode_t__Base):
        raise TypeError("argument 'side' must be of type '_hipblasSideMode_t__Base'")                    
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")                    
    if not isinstance(transA,_hipblasOperation_t__Base):
        raise TypeError("argument 'transA' must be of type '_hipblasOperation_t__Base'")                    
    if not isinstance(diag,_hipblasDiagType_t__Base):
        raise TypeError("argument 'diag' must be of type '_hipblasDiagType_t__Base'")
    _hipblasZtrsmStridedBatched_v2__retval = hipblasStatus_t(chipblas.hipblasZtrsmStridedBatched_v2(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,side.value,uplo.value,transA.value,diag.value,m,n,
        double2.fromPyobj(alpha).getElementPtr(),
        double2.fromPyobj(AP).getElementPtr(),lda,strideA,
        double2.fromPyobj(BP).getElementPtr(),ldb,strideB,batchCount))
    return (_hipblasZtrsmStridedBatched_v2__retval,)


@cython.embedsignature(True)
def hipblasStrtri(object handle, object uplo, object diag, int n, object AP, int lda, object invA, int ldinvA):
    r"""BLAS Level 3 API

    @{

    trtri  compute the inverse of a matrix A, namely, invA

    and write the result into invA;

    - Supported precisions in rocBLAS : s,d,c,z
    - Supported precisions in cuBLAS  : No support

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`) -- *IN*:
            [hipblasHandle_t]
            handle to the hipblas library context queue.

        uplo (`~.hipblasFillMode_t`) -- *IN*:
            [hipblasFillMode_t]
            specifies whether the upper 'HIPBLAS_FILL_MODE_UPPER' or lower 'HIPBLAS_FILL_MODE_LOWER'
            if HIPBLAS_FILL_MODE_UPPER, the lower part of A is not referenced
            if HIPBLAS_FILL_MODE_LOWER, the upper part of A is not referenced

        diag (`~.hipblasDiagType_t`) -- *IN*:
            [hipblasDiagType_t]
            = 'HIPBLAS_DIAG_NON_UNIT', A is non-unit triangular;
            = 'HIPBLAS_DIAG_UNIT', A is unit triangular;

        n (`~.int`) -- *IN*:
            [int]
            size of matrix A and invA

        AP (`~.hip._util.types.Pointer`/`~.object`) -- *IN*:
            device pointer storing matrix A.

        lda (`~.int`) -- *IN*:
            [int]
            specifies the leading dimension of A.

        invA (`~.hip._util.types.Pointer`/`~.object`) -- *OUT*:
            device pointer storing matrix invA.

        ldinvA (`~.int`) -- *IN*:
            [int]
            specifies the leading dimension of invA.
    """
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")                    
    if not isinstance(diag,_hipblasDiagType_t__Base):
        raise TypeError("argument 'diag' must be of type '_hipblasDiagType_t__Base'")
    _hipblasStrtri__retval = hipblasStatus_t(chipblas.hipblasStrtri(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,uplo.value,diag.value,n,
        <const float *>hip._util.types.Pointer.fromPyobj(AP)._ptr,lda,
        <float *>hip._util.types.Pointer.fromPyobj(invA)._ptr,ldinvA))
    return (_hipblasStrtri__retval,)


@cython.embedsignature(True)
def hipblasDtrtri(object handle, object uplo, object diag, int n, object AP, int lda, object invA, int ldinvA):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        uplo (`~.hipblasFillMode_t`):
            (undocumented)

        diag (`~.hipblasDiagType_t`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        AP (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        invA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        ldinvA (`~.int`):
            (undocumented)
    """
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")                    
    if not isinstance(diag,_hipblasDiagType_t__Base):
        raise TypeError("argument 'diag' must be of type '_hipblasDiagType_t__Base'")
    _hipblasDtrtri__retval = hipblasStatus_t(chipblas.hipblasDtrtri(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,uplo.value,diag.value,n,
        <const double *>hip._util.types.Pointer.fromPyobj(AP)._ptr,lda,
        <double *>hip._util.types.Pointer.fromPyobj(invA)._ptr,ldinvA))
    return (_hipblasDtrtri__retval,)


@cython.embedsignature(True)
def hipblasCtrtri(object handle, object uplo, object diag, int n, object AP, int lda, object invA, int ldinvA):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        uplo (`~.hipblasFillMode_t`):
            (undocumented)

        diag (`~.hipblasDiagType_t`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        AP (`~.hipblasComplex`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        invA (`~.hipblasComplex`/`~.object`):
            (undocumented)

        ldinvA (`~.int`):
            (undocumented)
    """
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")                    
    if not isinstance(diag,_hipblasDiagType_t__Base):
        raise TypeError("argument 'diag' must be of type '_hipblasDiagType_t__Base'")
    _hipblasCtrtri__retval = hipblasStatus_t(chipblas.hipblasCtrtri(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,uplo.value,diag.value,n,
        hipblasComplex.fromPyobj(AP).getElementPtr(),lda,
        hipblasComplex.fromPyobj(invA).getElementPtr(),ldinvA))
    return (_hipblasCtrtri__retval,)


@cython.embedsignature(True)
def hipblasZtrtri(object handle, object uplo, object diag, int n, object AP, int lda, object invA, int ldinvA):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        uplo (`~.hipblasFillMode_t`):
            (undocumented)

        diag (`~.hipblasDiagType_t`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        AP (`~.hipblasDoubleComplex`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        invA (`~.hipblasDoubleComplex`/`~.object`):
            (undocumented)

        ldinvA (`~.int`):
            (undocumented)
    """
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")                    
    if not isinstance(diag,_hipblasDiagType_t__Base):
        raise TypeError("argument 'diag' must be of type '_hipblasDiagType_t__Base'")
    _hipblasZtrtri__retval = hipblasStatus_t(chipblas.hipblasZtrtri(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,uplo.value,diag.value,n,
        hipblasDoubleComplex.fromPyobj(AP).getElementPtr(),lda,
        hipblasDoubleComplex.fromPyobj(invA).getElementPtr(),ldinvA))
    return (_hipblasZtrtri__retval,)


@cython.embedsignature(True)
def hipblasCtrtri_v2(object handle, object uplo, object diag, int n, object AP, int lda, object invA, int ldinvA):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        uplo (`~.hipblasFillMode_t`):
            (undocumented)

        diag (`~.hipblasDiagType_t`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        AP (`~.float2`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        invA (`~.float2`/`~.object`):
            (undocumented)

        ldinvA (`~.int`):
            (undocumented)
    """
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")                    
    if not isinstance(diag,_hipblasDiagType_t__Base):
        raise TypeError("argument 'diag' must be of type '_hipblasDiagType_t__Base'")
    _hipblasCtrtri_v2__retval = hipblasStatus_t(chipblas.hipblasCtrtri_v2(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,uplo.value,diag.value,n,
        float2.fromPyobj(AP).getElementPtr(),lda,
        float2.fromPyobj(invA).getElementPtr(),ldinvA))
    return (_hipblasCtrtri_v2__retval,)


@cython.embedsignature(True)
def hipblasZtrtri_v2(object handle, object uplo, object diag, int n, object AP, int lda, object invA, int ldinvA):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        uplo (`~.hipblasFillMode_t`):
            (undocumented)

        diag (`~.hipblasDiagType_t`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        AP (`~.double2`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        invA (`~.double2`/`~.object`):
            (undocumented)

        ldinvA (`~.int`):
            (undocumented)
    """
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")                    
    if not isinstance(diag,_hipblasDiagType_t__Base):
        raise TypeError("argument 'diag' must be of type '_hipblasDiagType_t__Base'")
    _hipblasZtrtri_v2__retval = hipblasStatus_t(chipblas.hipblasZtrtri_v2(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,uplo.value,diag.value,n,
        double2.fromPyobj(AP).getElementPtr(),lda,
        double2.fromPyobj(invA).getElementPtr(),ldinvA))
    return (_hipblasZtrtri_v2__retval,)


@cython.embedsignature(True)
def hipblasStrtriBatched(object handle, object uplo, object diag, int n, object AP, int lda, object invA, int ldinvA, int batchCount):
    r"""BLAS Level 3 API

    @{

    trtriBatched  compute the inverse of A_i and write into invA_i where
    A_i and invA_i are the i-th matrices in the batch,
    for i = 1, ..., batchCount.

    - Supported precisions in rocBLAS : s,d,c,z
    - Supported precisions in cuBLAS  : No support

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`) -- *IN*:
            [hipblasHandle_t]
            handle to the hipblas library context queue.

        uplo (`~.hipblasFillMode_t`) -- *IN*:
            [hipblasFillMode_t]
            specifies whether the upper 'HIPBLAS_FILL_MODE_UPPER' or lower 'HIPBLAS_FILL_MODE_LOWER'

        diag (`~.hipblasDiagType_t`) -- *IN*:
            [hipblasDiagType_t]
            = 'HIPBLAS_DIAG_NON_UNIT', A is non-unit triangular;
            = 'HIPBLAS_DIAG_UNIT', A is unit triangular;

        n (`~.int`) -- *IN*:
            [int]

        AP (`~.hip._util.types.Pointer`/`~.object`) -- *IN*:
            device array of device pointers storing each matrix A_i.

        lda (`~.int`) -- *IN*:
            [int]
            specifies the leading dimension of each A_i.

        invA (`~.hip._util.types.Pointer`/`~.object`) -- *OUT*:
            device array of device pointers storing the inverse of each matrix A_i.
            Partial inplace operation is supported, see below.
            If UPLO = 'U', the leading N-by-N upper triangular part of the invA will store
            the inverse of the upper triangular matrix, and the strictly lower
            triangular part of invA is cleared.
            If UPLO = 'L', the leading N-by-N lower triangular part of the invA will store
            the inverse of the lower triangular matrix, and the strictly upper
            triangular part of invA is cleared.

        ldinvA (`~.int`) -- *IN*:
            [int]
            specifies the leading dimension of each invA_i.

        batchCount (`~.int`) -- *IN*:
            [int]
            numbers of matrices in the batch
    """
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")                    
    if not isinstance(diag,_hipblasDiagType_t__Base):
        raise TypeError("argument 'diag' must be of type '_hipblasDiagType_t__Base'")
    _hipblasStrtriBatched__retval = hipblasStatus_t(chipblas.hipblasStrtriBatched(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,uplo.value,diag.value,n,
        <const float *const*>hip._util.types.Pointer.fromPyobj(AP)._ptr,lda,
        <float **>hip._util.types.Pointer.fromPyobj(invA)._ptr,ldinvA,batchCount))
    return (_hipblasStrtriBatched__retval,)


@cython.embedsignature(True)
def hipblasDtrtriBatched(object handle, object uplo, object diag, int n, object AP, int lda, object invA, int ldinvA, int batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        uplo (`~.hipblasFillMode_t`):
            (undocumented)

        diag (`~.hipblasDiagType_t`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        AP (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        invA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        ldinvA (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")                    
    if not isinstance(diag,_hipblasDiagType_t__Base):
        raise TypeError("argument 'diag' must be of type '_hipblasDiagType_t__Base'")
    _hipblasDtrtriBatched__retval = hipblasStatus_t(chipblas.hipblasDtrtriBatched(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,uplo.value,diag.value,n,
        <const double *const*>hip._util.types.Pointer.fromPyobj(AP)._ptr,lda,
        <double **>hip._util.types.Pointer.fromPyobj(invA)._ptr,ldinvA,batchCount))
    return (_hipblasDtrtriBatched__retval,)


@cython.embedsignature(True)
def hipblasCtrtriBatched(object handle, object uplo, object diag, int n, object AP, int lda, object invA, int ldinvA, int batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        uplo (`~.hipblasFillMode_t`):
            (undocumented)

        diag (`~.hipblasDiagType_t`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        AP (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        invA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        ldinvA (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")                    
    if not isinstance(diag,_hipblasDiagType_t__Base):
        raise TypeError("argument 'diag' must be of type '_hipblasDiagType_t__Base'")
    _hipblasCtrtriBatched__retval = hipblasStatus_t(chipblas.hipblasCtrtriBatched(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,uplo.value,diag.value,n,
        <chipblas.hipblasComplex *const*>hip._util.types.Pointer.fromPyobj(AP)._ptr,lda,
        <chipblas.hipblasComplex **>hip._util.types.Pointer.fromPyobj(invA)._ptr,ldinvA,batchCount))
    return (_hipblasCtrtriBatched__retval,)


@cython.embedsignature(True)
def hipblasZtrtriBatched(object handle, object uplo, object diag, int n, object AP, int lda, object invA, int ldinvA, int batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        uplo (`~.hipblasFillMode_t`):
            (undocumented)

        diag (`~.hipblasDiagType_t`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        AP (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        invA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        ldinvA (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")                    
    if not isinstance(diag,_hipblasDiagType_t__Base):
        raise TypeError("argument 'diag' must be of type '_hipblasDiagType_t__Base'")
    _hipblasZtrtriBatched__retval = hipblasStatus_t(chipblas.hipblasZtrtriBatched(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,uplo.value,diag.value,n,
        <chipblas.hipblasDoubleComplex *const*>hip._util.types.Pointer.fromPyobj(AP)._ptr,lda,
        <chipblas.hipblasDoubleComplex **>hip._util.types.Pointer.fromPyobj(invA)._ptr,ldinvA,batchCount))
    return (_hipblasZtrtriBatched__retval,)


@cython.embedsignature(True)
def hipblasCtrtriBatched_v2(object handle, object uplo, object diag, int n, object AP, int lda, object invA, int ldinvA, int batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        uplo (`~.hipblasFillMode_t`):
            (undocumented)

        diag (`~.hipblasDiagType_t`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        AP (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        invA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        ldinvA (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")                    
    if not isinstance(diag,_hipblasDiagType_t__Base):
        raise TypeError("argument 'diag' must be of type '_hipblasDiagType_t__Base'")
    _hipblasCtrtriBatched_v2__retval = hipblasStatus_t(chipblas.hipblasCtrtriBatched_v2(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,uplo.value,diag.value,n,
        <chipblas.float2 *const*>hip._util.types.Pointer.fromPyobj(AP)._ptr,lda,
        <chipblas.float2 **>hip._util.types.Pointer.fromPyobj(invA)._ptr,ldinvA,batchCount))
    return (_hipblasCtrtriBatched_v2__retval,)


@cython.embedsignature(True)
def hipblasZtrtriBatched_v2(object handle, object uplo, object diag, int n, object AP, int lda, object invA, int ldinvA, int batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        uplo (`~.hipblasFillMode_t`):
            (undocumented)

        diag (`~.hipblasDiagType_t`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        AP (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        invA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        ldinvA (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")                    
    if not isinstance(diag,_hipblasDiagType_t__Base):
        raise TypeError("argument 'diag' must be of type '_hipblasDiagType_t__Base'")
    _hipblasZtrtriBatched_v2__retval = hipblasStatus_t(chipblas.hipblasZtrtriBatched_v2(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,uplo.value,diag.value,n,
        <chipblas.double2 *const*>hip._util.types.Pointer.fromPyobj(AP)._ptr,lda,
        <chipblas.double2 **>hip._util.types.Pointer.fromPyobj(invA)._ptr,ldinvA,batchCount))
    return (_hipblasZtrtriBatched_v2__retval,)


@cython.embedsignature(True)
def hipblasStrtriStridedBatched(object handle, object uplo, object diag, int n, object AP, int lda, long strideA, object invA, int ldinvA, long stride_invA, int batchCount):
    r"""BLAS Level 3 API

    @{

    trtriStridedBatched compute the inverse of A_i and write into invA_i where
    A_i and invA_i are the i-th matrices in the batch,
    for i = 1, ..., batchCount

    - Supported precisions in rocBLAS : s,d,c,z
    - Supported precisions in cuBLAS  : No support

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`) -- *IN*:
            [hipblasHandle_t]
            handle to the hipblas library context queue.

        uplo (`~.hipblasFillMode_t`) -- *IN*:
            [hipblasFillMode_t]
            specifies whether the upper 'HIPBLAS_FILL_MODE_UPPER' or lower 'HIPBLAS_FILL_MODE_LOWER'

        diag (`~.hipblasDiagType_t`) -- *IN*:
            [hipblasDiagType_t]
            = 'HIPBLAS_DIAG_NON_UNIT', A is non-unit triangular;
            = 'HIPBLAS_DIAG_UNIT', A is unit triangular;

        n (`~.int`) -- *IN*:
            [int]

        AP (`~.hip._util.types.Pointer`/`~.object`) -- *IN*:
            device pointer pointing to address of first matrix A_1.

        lda (`~.int`) -- *IN*:
            [int]
            specifies the leading dimension of each A.

        strideA (`~.int`) -- *IN*:
            [hipblasStride]
            "batch stride a": stride from the start of one A_i matrix to the next A_(i + 1).

        invA (`~.hip._util.types.Pointer`/`~.object`) -- *OUT*:
            device pointer storing the inverses of each matrix A_i.
            Partial inplace operation is supported, see below.
            If UPLO = 'U', the leading N-by-N upper triangular part of the invA will store
            the inverse of the upper triangular matrix, and the strictly lower
            triangular part of invA is cleared.
            If UPLO = 'L', the leading N-by-N lower triangular part of the invA will store
            the inverse of the lower triangular matrix, and the strictly upper
            triangular part of invA is cleared.

        ldinvA (`~.int`) -- *IN*:
            [int]
            specifies the leading dimension of each invA_i.

        stride_invA (`~.int`) -- *IN*:
            [hipblasStride]
            "batch stride invA": stride from the start of one invA_i matrix to the next invA_(i + 1).

        batchCount (`~.int`) -- *IN*:
            [int]
            numbers of matrices in the batch
    """
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")                    
    if not isinstance(diag,_hipblasDiagType_t__Base):
        raise TypeError("argument 'diag' must be of type '_hipblasDiagType_t__Base'")
    _hipblasStrtriStridedBatched__retval = hipblasStatus_t(chipblas.hipblasStrtriStridedBatched(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,uplo.value,diag.value,n,
        <const float *>hip._util.types.Pointer.fromPyobj(AP)._ptr,lda,strideA,
        <float *>hip._util.types.Pointer.fromPyobj(invA)._ptr,ldinvA,stride_invA,batchCount))
    return (_hipblasStrtriStridedBatched__retval,)


@cython.embedsignature(True)
def hipblasDtrtriStridedBatched(object handle, object uplo, object diag, int n, object AP, int lda, long strideA, object invA, int ldinvA, long stride_invA, int batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        uplo (`~.hipblasFillMode_t`):
            (undocumented)

        diag (`~.hipblasDiagType_t`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        AP (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        strideA (`~.int`):
            (undocumented)

        invA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        ldinvA (`~.int`):
            (undocumented)

        stride_invA (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")                    
    if not isinstance(diag,_hipblasDiagType_t__Base):
        raise TypeError("argument 'diag' must be of type '_hipblasDiagType_t__Base'")
    _hipblasDtrtriStridedBatched__retval = hipblasStatus_t(chipblas.hipblasDtrtriStridedBatched(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,uplo.value,diag.value,n,
        <const double *>hip._util.types.Pointer.fromPyobj(AP)._ptr,lda,strideA,
        <double *>hip._util.types.Pointer.fromPyobj(invA)._ptr,ldinvA,stride_invA,batchCount))
    return (_hipblasDtrtriStridedBatched__retval,)


@cython.embedsignature(True)
def hipblasCtrtriStridedBatched(object handle, object uplo, object diag, int n, object AP, int lda, long strideA, object invA, int ldinvA, long stride_invA, int batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        uplo (`~.hipblasFillMode_t`):
            (undocumented)

        diag (`~.hipblasDiagType_t`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        AP (`~.hipblasComplex`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        strideA (`~.int`):
            (undocumented)

        invA (`~.hipblasComplex`/`~.object`):
            (undocumented)

        ldinvA (`~.int`):
            (undocumented)

        stride_invA (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")                    
    if not isinstance(diag,_hipblasDiagType_t__Base):
        raise TypeError("argument 'diag' must be of type '_hipblasDiagType_t__Base'")
    _hipblasCtrtriStridedBatched__retval = hipblasStatus_t(chipblas.hipblasCtrtriStridedBatched(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,uplo.value,diag.value,n,
        hipblasComplex.fromPyobj(AP).getElementPtr(),lda,strideA,
        hipblasComplex.fromPyobj(invA).getElementPtr(),ldinvA,stride_invA,batchCount))
    return (_hipblasCtrtriStridedBatched__retval,)


@cython.embedsignature(True)
def hipblasZtrtriStridedBatched(object handle, object uplo, object diag, int n, object AP, int lda, long strideA, object invA, int ldinvA, long stride_invA, int batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        uplo (`~.hipblasFillMode_t`):
            (undocumented)

        diag (`~.hipblasDiagType_t`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        AP (`~.hipblasDoubleComplex`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        strideA (`~.int`):
            (undocumented)

        invA (`~.hipblasDoubleComplex`/`~.object`):
            (undocumented)

        ldinvA (`~.int`):
            (undocumented)

        stride_invA (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")                    
    if not isinstance(diag,_hipblasDiagType_t__Base):
        raise TypeError("argument 'diag' must be of type '_hipblasDiagType_t__Base'")
    _hipblasZtrtriStridedBatched__retval = hipblasStatus_t(chipblas.hipblasZtrtriStridedBatched(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,uplo.value,diag.value,n,
        hipblasDoubleComplex.fromPyobj(AP).getElementPtr(),lda,strideA,
        hipblasDoubleComplex.fromPyobj(invA).getElementPtr(),ldinvA,stride_invA,batchCount))
    return (_hipblasZtrtriStridedBatched__retval,)


@cython.embedsignature(True)
def hipblasCtrtriStridedBatched_v2(object handle, object uplo, object diag, int n, object AP, int lda, long strideA, object invA, int ldinvA, long stride_invA, int batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        uplo (`~.hipblasFillMode_t`):
            (undocumented)

        diag (`~.hipblasDiagType_t`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        AP (`~.float2`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        strideA (`~.int`):
            (undocumented)

        invA (`~.float2`/`~.object`):
            (undocumented)

        ldinvA (`~.int`):
            (undocumented)

        stride_invA (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")                    
    if not isinstance(diag,_hipblasDiagType_t__Base):
        raise TypeError("argument 'diag' must be of type '_hipblasDiagType_t__Base'")
    _hipblasCtrtriStridedBatched_v2__retval = hipblasStatus_t(chipblas.hipblasCtrtriStridedBatched_v2(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,uplo.value,diag.value,n,
        float2.fromPyobj(AP).getElementPtr(),lda,strideA,
        float2.fromPyobj(invA).getElementPtr(),ldinvA,stride_invA,batchCount))
    return (_hipblasCtrtriStridedBatched_v2__retval,)


@cython.embedsignature(True)
def hipblasZtrtriStridedBatched_v2(object handle, object uplo, object diag, int n, object AP, int lda, long strideA, object invA, int ldinvA, long stride_invA, int batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        uplo (`~.hipblasFillMode_t`):
            (undocumented)

        diag (`~.hipblasDiagType_t`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        AP (`~.double2`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        strideA (`~.int`):
            (undocumented)

        invA (`~.double2`/`~.object`):
            (undocumented)

        ldinvA (`~.int`):
            (undocumented)

        stride_invA (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")                    
    if not isinstance(diag,_hipblasDiagType_t__Base):
        raise TypeError("argument 'diag' must be of type '_hipblasDiagType_t__Base'")
    _hipblasZtrtriStridedBatched_v2__retval = hipblasStatus_t(chipblas.hipblasZtrtriStridedBatched_v2(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,uplo.value,diag.value,n,
        double2.fromPyobj(AP).getElementPtr(),lda,strideA,
        double2.fromPyobj(invA).getElementPtr(),ldinvA,stride_invA,batchCount))
    return (_hipblasZtrtriStridedBatched_v2__retval,)


@cython.embedsignature(True)
def hipblasSdgmm(object handle, object side, int m, int n, object AP, int lda, object x, int incx, object CP, int ldc):
    r"""BLAS Level 3 API

    @{

    dgmm performs one of the matrix-matrix operations

    C = A * diag(x) if side == HIPBLAS_SIDE_RIGHT
        C = diag(x) * A if side == HIPBLAS_SIDE_LEFT

    where C and A are m by n dimensional matrices. diag( x ) is a diagonal matrix
    and x is vector of dimension n if side == HIPBLAS_SIDE_RIGHT and dimension m
    if side == HIPBLAS_SIDE_LEFT.

    - Supported precisions in rocBLAS : s,d,c,z
    - Supported precisions in cuBLAS  : s,d,c,z

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`) -- *IN*:
            [hipblasHandle_t]
            handle to the hipblas library context queue.

        side (`~.hipblasSideMode_t`) -- *IN*:
            [hipblasSideMode_t]
            specifies the side of diag(x)

        m (`~.int`) -- *IN*:
            [int]
            matrix dimension m.

        n (`~.int`) -- *IN*:
            [int]
            matrix dimension n.

        AP (`~.hip._util.types.Pointer`/`~.object`) -- *IN*:
            device pointer storing matrix A.

        lda (`~.int`) -- *IN*:
            [int]
            specifies the leading dimension of A.

        x (`~.hip._util.types.Pointer`/`~.object`) -- *IN*:
            device pointer storing vector x.

        incx (`~.int`) -- *IN*:
            [int]
            specifies the increment between values of x

        CP (`~.hip._util.types.Pointer`/`~.object`) -- *IN,OUT*:
            device pointer storing matrix C.

        ldc (`~.int`) -- *IN*:
            [int]
            specifies the leading dimension of C.
    """
    if not isinstance(side,_hipblasSideMode_t__Base):
        raise TypeError("argument 'side' must be of type '_hipblasSideMode_t__Base'")
    _hipblasSdgmm__retval = hipblasStatus_t(chipblas.hipblasSdgmm(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,side.value,m,n,
        <const float *>hip._util.types.Pointer.fromPyobj(AP)._ptr,lda,
        <const float *>hip._util.types.Pointer.fromPyobj(x)._ptr,incx,
        <float *>hip._util.types.Pointer.fromPyobj(CP)._ptr,ldc))
    return (_hipblasSdgmm__retval,)


@cython.embedsignature(True)
def hipblasDdgmm(object handle, object side, int m, int n, object AP, int lda, object x, int incx, object CP, int ldc):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        side (`~.hipblasSideMode_t`):
            (undocumented)

        m (`~.int`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        AP (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        x (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        CP (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        ldc (`~.int`):
            (undocumented)
    """
    if not isinstance(side,_hipblasSideMode_t__Base):
        raise TypeError("argument 'side' must be of type '_hipblasSideMode_t__Base'")
    _hipblasDdgmm__retval = hipblasStatus_t(chipblas.hipblasDdgmm(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,side.value,m,n,
        <const double *>hip._util.types.Pointer.fromPyobj(AP)._ptr,lda,
        <const double *>hip._util.types.Pointer.fromPyobj(x)._ptr,incx,
        <double *>hip._util.types.Pointer.fromPyobj(CP)._ptr,ldc))
    return (_hipblasDdgmm__retval,)


@cython.embedsignature(True)
def hipblasCdgmm(object handle, object side, int m, int n, object AP, int lda, object x, int incx, object CP, int ldc):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        side (`~.hipblasSideMode_t`):
            (undocumented)

        m (`~.int`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        AP (`~.hipblasComplex`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        x (`~.hipblasComplex`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        CP (`~.hipblasComplex`/`~.object`):
            (undocumented)

        ldc (`~.int`):
            (undocumented)
    """
    if not isinstance(side,_hipblasSideMode_t__Base):
        raise TypeError("argument 'side' must be of type '_hipblasSideMode_t__Base'")
    _hipblasCdgmm__retval = hipblasStatus_t(chipblas.hipblasCdgmm(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,side.value,m,n,
        hipblasComplex.fromPyobj(AP).getElementPtr(),lda,
        hipblasComplex.fromPyobj(x).getElementPtr(),incx,
        hipblasComplex.fromPyobj(CP).getElementPtr(),ldc))
    return (_hipblasCdgmm__retval,)


@cython.embedsignature(True)
def hipblasZdgmm(object handle, object side, int m, int n, object AP, int lda, object x, int incx, object CP, int ldc):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        side (`~.hipblasSideMode_t`):
            (undocumented)

        m (`~.int`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        AP (`~.hipblasDoubleComplex`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        x (`~.hipblasDoubleComplex`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        CP (`~.hipblasDoubleComplex`/`~.object`):
            (undocumented)

        ldc (`~.int`):
            (undocumented)
    """
    if not isinstance(side,_hipblasSideMode_t__Base):
        raise TypeError("argument 'side' must be of type '_hipblasSideMode_t__Base'")
    _hipblasZdgmm__retval = hipblasStatus_t(chipblas.hipblasZdgmm(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,side.value,m,n,
        hipblasDoubleComplex.fromPyobj(AP).getElementPtr(),lda,
        hipblasDoubleComplex.fromPyobj(x).getElementPtr(),incx,
        hipblasDoubleComplex.fromPyobj(CP).getElementPtr(),ldc))
    return (_hipblasZdgmm__retval,)


@cython.embedsignature(True)
def hipblasCdgmm_v2(object handle, object side, int m, int n, object AP, int lda, object x, int incx, object CP, int ldc):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        side (`~.hipblasSideMode_t`):
            (undocumented)

        m (`~.int`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        AP (`~.float2`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        x (`~.float2`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        CP (`~.float2`/`~.object`):
            (undocumented)

        ldc (`~.int`):
            (undocumented)
    """
    if not isinstance(side,_hipblasSideMode_t__Base):
        raise TypeError("argument 'side' must be of type '_hipblasSideMode_t__Base'")
    _hipblasCdgmm_v2__retval = hipblasStatus_t(chipblas.hipblasCdgmm_v2(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,side.value,m,n,
        float2.fromPyobj(AP).getElementPtr(),lda,
        float2.fromPyobj(x).getElementPtr(),incx,
        float2.fromPyobj(CP).getElementPtr(),ldc))
    return (_hipblasCdgmm_v2__retval,)


@cython.embedsignature(True)
def hipblasZdgmm_v2(object handle, object side, int m, int n, object AP, int lda, object x, int incx, object CP, int ldc):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        side (`~.hipblasSideMode_t`):
            (undocumented)

        m (`~.int`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        AP (`~.double2`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        x (`~.double2`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        CP (`~.double2`/`~.object`):
            (undocumented)

        ldc (`~.int`):
            (undocumented)
    """
    if not isinstance(side,_hipblasSideMode_t__Base):
        raise TypeError("argument 'side' must be of type '_hipblasSideMode_t__Base'")
    _hipblasZdgmm_v2__retval = hipblasStatus_t(chipblas.hipblasZdgmm_v2(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,side.value,m,n,
        double2.fromPyobj(AP).getElementPtr(),lda,
        double2.fromPyobj(x).getElementPtr(),incx,
        double2.fromPyobj(CP).getElementPtr(),ldc))
    return (_hipblasZdgmm_v2__retval,)


@cython.embedsignature(True)
def hipblasSdgmmBatched(object handle, object side, int m, int n, object AP, int lda, object x, int incx, object CP, int ldc, int batchCount):
    r"""BLAS Level 3 API

    @{

    dgmmBatched performs one of the batched matrix-matrix operations

    C_i = A_i * diag(x_i) for i = 0, 1, ... batchCount-1 if side == HIPBLAS_SIDE_RIGHT
        C_i = diag(x_i) * A_i for i = 0, 1, ... batchCount-1 if side == HIPBLAS_SIDE_LEFT

    where C_i and A_i are m by n dimensional matrices. diag(x_i) is a diagonal matrix
    and x_i is vector of dimension n if side == HIPBLAS_SIDE_RIGHT and dimension m
    if side == HIPBLAS_SIDE_LEFT.

    - Supported precisions in rocBLAS : s,d,c,z
    - Supported precisions in cuBLAS  : No support

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`) -- *IN*:
            [hipblasHandle_t]
            handle to the hipblas library context queue.

        side (`~.hipblasSideMode_t`) -- *IN*:
            [hipblasSideMode_t]
            specifies the side of diag(x)

        m (`~.int`) -- *IN*:
            [int]
            matrix dimension m.

        n (`~.int`) -- *IN*:
            [int]
            matrix dimension n.

        AP (`~.hip._util.types.Pointer`/`~.object`) -- *IN*:
            device array of device pointers storing each matrix A_i on the GPU.
            Each A_i is of dimension ( lda, n )

        lda (`~.int`) -- *IN*:
            [int]
            specifies the leading dimension of A_i.

        x (`~.hip._util.types.ListOfPointer`/`~.object`) -- *IN*:
            device array of device pointers storing each vector x_i on the GPU.
            Each x_i is of dimension n if side == HIPBLAS_SIDE_RIGHT and dimension
            m if side == HIPBLAS_SIDE_LEFT

        incx (`~.int`) -- *IN*:
            [int]
            specifies the increment between values of x_i

        CP (`~.hip._util.types.Pointer`/`~.object`) -- *IN,OUT*:
            device array of device pointers storing each matrix C_i on the GPU.
            Each C_i is of dimension ( ldc, n ).

        ldc (`~.int`) -- *IN*:
            [int]
            specifies the leading dimension of C_i.

        batchCount (`~.int`) -- *IN*:
            [int]
            number of instances in the batch.
    """
    if not isinstance(side,_hipblasSideMode_t__Base):
        raise TypeError("argument 'side' must be of type '_hipblasSideMode_t__Base'")
    _hipblasSdgmmBatched__retval = hipblasStatus_t(chipblas.hipblasSdgmmBatched(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,side.value,m,n,
        <const float *const*>hip._util.types.Pointer.fromPyobj(AP)._ptr,lda,
        <const float *const*>hip._util.types.ListOfPointer.fromPyobj(x)._ptr,incx,
        <float *const*>hip._util.types.Pointer.fromPyobj(CP)._ptr,ldc,batchCount))
    return (_hipblasSdgmmBatched__retval,)


@cython.embedsignature(True)
def hipblasDdgmmBatched(object handle, object side, int m, int n, object AP, int lda, object x, int incx, object CP, int ldc, int batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        side (`~.hipblasSideMode_t`):
            (undocumented)

        m (`~.int`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        AP (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        x (`~.hip._util.types.ListOfPointer`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        CP (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        ldc (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    if not isinstance(side,_hipblasSideMode_t__Base):
        raise TypeError("argument 'side' must be of type '_hipblasSideMode_t__Base'")
    _hipblasDdgmmBatched__retval = hipblasStatus_t(chipblas.hipblasDdgmmBatched(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,side.value,m,n,
        <const double *const*>hip._util.types.Pointer.fromPyobj(AP)._ptr,lda,
        <const double *const*>hip._util.types.ListOfPointer.fromPyobj(x)._ptr,incx,
        <double *const*>hip._util.types.Pointer.fromPyobj(CP)._ptr,ldc,batchCount))
    return (_hipblasDdgmmBatched__retval,)


@cython.embedsignature(True)
def hipblasCdgmmBatched(object handle, object side, int m, int n, object AP, int lda, object x, int incx, object CP, int ldc, int batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        side (`~.hipblasSideMode_t`):
            (undocumented)

        m (`~.int`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        AP (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        x (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        CP (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        ldc (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    if not isinstance(side,_hipblasSideMode_t__Base):
        raise TypeError("argument 'side' must be of type '_hipblasSideMode_t__Base'")
    _hipblasCdgmmBatched__retval = hipblasStatus_t(chipblas.hipblasCdgmmBatched(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,side.value,m,n,
        <chipblas.hipblasComplex *const*>hip._util.types.Pointer.fromPyobj(AP)._ptr,lda,
        <chipblas.hipblasComplex *const*>hip._util.types.Pointer.fromPyobj(x)._ptr,incx,
        <chipblas.hipblasComplex *const*>hip._util.types.Pointer.fromPyobj(CP)._ptr,ldc,batchCount))
    return (_hipblasCdgmmBatched__retval,)


@cython.embedsignature(True)
def hipblasZdgmmBatched(object handle, object side, int m, int n, object AP, int lda, object x, int incx, object CP, int ldc, int batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        side (`~.hipblasSideMode_t`):
            (undocumented)

        m (`~.int`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        AP (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        x (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        CP (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        ldc (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    if not isinstance(side,_hipblasSideMode_t__Base):
        raise TypeError("argument 'side' must be of type '_hipblasSideMode_t__Base'")
    _hipblasZdgmmBatched__retval = hipblasStatus_t(chipblas.hipblasZdgmmBatched(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,side.value,m,n,
        <chipblas.hipblasDoubleComplex *const*>hip._util.types.Pointer.fromPyobj(AP)._ptr,lda,
        <chipblas.hipblasDoubleComplex *const*>hip._util.types.Pointer.fromPyobj(x)._ptr,incx,
        <chipblas.hipblasDoubleComplex *const*>hip._util.types.Pointer.fromPyobj(CP)._ptr,ldc,batchCount))
    return (_hipblasZdgmmBatched__retval,)


@cython.embedsignature(True)
def hipblasCdgmmBatched_v2(object handle, object side, int m, int n, object AP, int lda, object x, int incx, object CP, int ldc, int batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        side (`~.hipblasSideMode_t`):
            (undocumented)

        m (`~.int`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        AP (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        x (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        CP (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        ldc (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    if not isinstance(side,_hipblasSideMode_t__Base):
        raise TypeError("argument 'side' must be of type '_hipblasSideMode_t__Base'")
    _hipblasCdgmmBatched_v2__retval = hipblasStatus_t(chipblas.hipblasCdgmmBatched_v2(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,side.value,m,n,
        <chipblas.float2 *const*>hip._util.types.Pointer.fromPyobj(AP)._ptr,lda,
        <chipblas.float2 *const*>hip._util.types.Pointer.fromPyobj(x)._ptr,incx,
        <chipblas.float2 *const*>hip._util.types.Pointer.fromPyobj(CP)._ptr,ldc,batchCount))
    return (_hipblasCdgmmBatched_v2__retval,)


@cython.embedsignature(True)
def hipblasZdgmmBatched_v2(object handle, object side, int m, int n, object AP, int lda, object x, int incx, object CP, int ldc, int batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        side (`~.hipblasSideMode_t`):
            (undocumented)

        m (`~.int`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        AP (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        x (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        CP (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        ldc (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    if not isinstance(side,_hipblasSideMode_t__Base):
        raise TypeError("argument 'side' must be of type '_hipblasSideMode_t__Base'")
    _hipblasZdgmmBatched_v2__retval = hipblasStatus_t(chipblas.hipblasZdgmmBatched_v2(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,side.value,m,n,
        <chipblas.double2 *const*>hip._util.types.Pointer.fromPyobj(AP)._ptr,lda,
        <chipblas.double2 *const*>hip._util.types.Pointer.fromPyobj(x)._ptr,incx,
        <chipblas.double2 *const*>hip._util.types.Pointer.fromPyobj(CP)._ptr,ldc,batchCount))
    return (_hipblasZdgmmBatched_v2__retval,)


@cython.embedsignature(True)
def hipblasSdgmmStridedBatched(object handle, object side, int m, int n, object AP, int lda, long strideA, object x, int incx, long stridex, object CP, int ldc, long strideC, int batchCount):
    r"""BLAS Level 3 API

    @{

    dgmmStridedBatched performs one of the batched matrix-matrix operations

    C_i = A_i * diag(x_i)   if side == HIPBLAS_SIDE_RIGHT   for i = 0, 1, ... batchCount-1
        C_i = diag(x_i) * A_i   if side == HIPBLAS_SIDE_LEFT    for i = 0, 1, ... batchCount-1

    where C_i and A_i are m by n dimensional matrices. diag(x_i) is a diagonal matrix
    and x_i is vector of dimension n if side == HIPBLAS_SIDE_RIGHT and dimension m
    if side == HIPBLAS_SIDE_LEFT.

    - Supported precisions in rocBLAS : s,d,c,z
    - Supported precisions in cuBLAS  : No support

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`) -- *IN*:
            [hipblasHandle_t]
            handle to the hipblas library context queue.

        side (`~.hipblasSideMode_t`) -- *IN*:
            [hipblasSideMode_t]
            specifies the side of diag(x)

        m (`~.int`) -- *IN*:
            [int]
            matrix dimension m.

        n (`~.int`) -- *IN*:
            [int]
            matrix dimension n.

        AP (`~.hip._util.types.Pointer`/`~.object`) -- *IN*:
            device pointer to the first matrix A_0 on the GPU.
            Each A_i is of dimension ( lda, n )

        lda (`~.int`) -- *IN*:
            [int]
            specifies the leading dimension of A.

        strideA (`~.int`) -- *IN*:
            [hipblasStride]
            stride from the start of one matrix (A_i) and the next one (A_i+1)

        x (`~.hip._util.types.Pointer`/`~.object`) -- *IN*:
            pointer to the first vector x_0 on the GPU.
            Each x_i is of dimension n if side == HIPBLAS_SIDE_RIGHT and dimension
            m if side == HIPBLAS_SIDE_LEFT

        incx (`~.int`) -- *IN*:
            [int]
            specifies the increment between values of x

        stridex (`~.int`) -- *IN*:
            [hipblasStride]
            stride from the start of one vector(x_i) and the next one (x_i+1)

        CP (`~.hip._util.types.Pointer`/`~.object`) -- *IN,OUT*:
            device pointer to the first matrix C_0 on the GPU.
            Each C_i is of dimension ( ldc, n ).

        ldc (`~.int`) -- *IN*:
            [int]
            specifies the leading dimension of C.

        strideC (`~.int`) -- *IN*:
            [hipblasStride]
            stride from the start of one matrix (C_i) and the next one (C_i+1)

        batchCount (`~.int`) -- *IN*:
            [int]
            number of instances i in the batch.
    """
    if not isinstance(side,_hipblasSideMode_t__Base):
        raise TypeError("argument 'side' must be of type '_hipblasSideMode_t__Base'")
    _hipblasSdgmmStridedBatched__retval = hipblasStatus_t(chipblas.hipblasSdgmmStridedBatched(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,side.value,m,n,
        <const float *>hip._util.types.Pointer.fromPyobj(AP)._ptr,lda,strideA,
        <const float *>hip._util.types.Pointer.fromPyobj(x)._ptr,incx,stridex,
        <float *>hip._util.types.Pointer.fromPyobj(CP)._ptr,ldc,strideC,batchCount))
    return (_hipblasSdgmmStridedBatched__retval,)


@cython.embedsignature(True)
def hipblasDdgmmStridedBatched(object handle, object side, int m, int n, object AP, int lda, long strideA, object x, int incx, long stridex, object CP, int ldc, long strideC, int batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        side (`~.hipblasSideMode_t`):
            (undocumented)

        m (`~.int`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        AP (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        strideA (`~.int`):
            (undocumented)

        x (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        stridex (`~.int`):
            (undocumented)

        CP (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        ldc (`~.int`):
            (undocumented)

        strideC (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    if not isinstance(side,_hipblasSideMode_t__Base):
        raise TypeError("argument 'side' must be of type '_hipblasSideMode_t__Base'")
    _hipblasDdgmmStridedBatched__retval = hipblasStatus_t(chipblas.hipblasDdgmmStridedBatched(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,side.value,m,n,
        <const double *>hip._util.types.Pointer.fromPyobj(AP)._ptr,lda,strideA,
        <const double *>hip._util.types.Pointer.fromPyobj(x)._ptr,incx,stridex,
        <double *>hip._util.types.Pointer.fromPyobj(CP)._ptr,ldc,strideC,batchCount))
    return (_hipblasDdgmmStridedBatched__retval,)


@cython.embedsignature(True)
def hipblasCdgmmStridedBatched(object handle, object side, int m, int n, object AP, int lda, long strideA, object x, int incx, long stridex, object CP, int ldc, long strideC, int batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        side (`~.hipblasSideMode_t`):
            (undocumented)

        m (`~.int`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        AP (`~.hipblasComplex`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        strideA (`~.int`):
            (undocumented)

        x (`~.hipblasComplex`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        stridex (`~.int`):
            (undocumented)

        CP (`~.hipblasComplex`/`~.object`):
            (undocumented)

        ldc (`~.int`):
            (undocumented)

        strideC (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    if not isinstance(side,_hipblasSideMode_t__Base):
        raise TypeError("argument 'side' must be of type '_hipblasSideMode_t__Base'")
    _hipblasCdgmmStridedBatched__retval = hipblasStatus_t(chipblas.hipblasCdgmmStridedBatched(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,side.value,m,n,
        hipblasComplex.fromPyobj(AP).getElementPtr(),lda,strideA,
        hipblasComplex.fromPyobj(x).getElementPtr(),incx,stridex,
        hipblasComplex.fromPyobj(CP).getElementPtr(),ldc,strideC,batchCount))
    return (_hipblasCdgmmStridedBatched__retval,)


@cython.embedsignature(True)
def hipblasZdgmmStridedBatched(object handle, object side, int m, int n, object AP, int lda, long strideA, object x, int incx, long stridex, object CP, int ldc, long strideC, int batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        side (`~.hipblasSideMode_t`):
            (undocumented)

        m (`~.int`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        AP (`~.hipblasDoubleComplex`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        strideA (`~.int`):
            (undocumented)

        x (`~.hipblasDoubleComplex`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        stridex (`~.int`):
            (undocumented)

        CP (`~.hipblasDoubleComplex`/`~.object`):
            (undocumented)

        ldc (`~.int`):
            (undocumented)

        strideC (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    if not isinstance(side,_hipblasSideMode_t__Base):
        raise TypeError("argument 'side' must be of type '_hipblasSideMode_t__Base'")
    _hipblasZdgmmStridedBatched__retval = hipblasStatus_t(chipblas.hipblasZdgmmStridedBatched(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,side.value,m,n,
        hipblasDoubleComplex.fromPyobj(AP).getElementPtr(),lda,strideA,
        hipblasDoubleComplex.fromPyobj(x).getElementPtr(),incx,stridex,
        hipblasDoubleComplex.fromPyobj(CP).getElementPtr(),ldc,strideC,batchCount))
    return (_hipblasZdgmmStridedBatched__retval,)


@cython.embedsignature(True)
def hipblasCdgmmStridedBatched_v2(object handle, object side, int m, int n, object AP, int lda, long strideA, object x, int incx, long stridex, object CP, int ldc, long strideC, int batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        side (`~.hipblasSideMode_t`):
            (undocumented)

        m (`~.int`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        AP (`~.float2`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        strideA (`~.int`):
            (undocumented)

        x (`~.float2`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        stridex (`~.int`):
            (undocumented)

        CP (`~.float2`/`~.object`):
            (undocumented)

        ldc (`~.int`):
            (undocumented)

        strideC (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    if not isinstance(side,_hipblasSideMode_t__Base):
        raise TypeError("argument 'side' must be of type '_hipblasSideMode_t__Base'")
    _hipblasCdgmmStridedBatched_v2__retval = hipblasStatus_t(chipblas.hipblasCdgmmStridedBatched_v2(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,side.value,m,n,
        float2.fromPyobj(AP).getElementPtr(),lda,strideA,
        float2.fromPyobj(x).getElementPtr(),incx,stridex,
        float2.fromPyobj(CP).getElementPtr(),ldc,strideC,batchCount))
    return (_hipblasCdgmmStridedBatched_v2__retval,)


@cython.embedsignature(True)
def hipblasZdgmmStridedBatched_v2(object handle, object side, int m, int n, object AP, int lda, long strideA, object x, int incx, long stridex, object CP, int ldc, long strideC, int batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        side (`~.hipblasSideMode_t`):
            (undocumented)

        m (`~.int`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        AP (`~.double2`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        strideA (`~.int`):
            (undocumented)

        x (`~.double2`/`~.object`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        stridex (`~.int`):
            (undocumented)

        CP (`~.double2`/`~.object`):
            (undocumented)

        ldc (`~.int`):
            (undocumented)

        strideC (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    if not isinstance(side,_hipblasSideMode_t__Base):
        raise TypeError("argument 'side' must be of type '_hipblasSideMode_t__Base'")
    _hipblasZdgmmStridedBatched_v2__retval = hipblasStatus_t(chipblas.hipblasZdgmmStridedBatched_v2(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,side.value,m,n,
        double2.fromPyobj(AP).getElementPtr(),lda,strideA,
        double2.fromPyobj(x).getElementPtr(),incx,stridex,
        double2.fromPyobj(CP).getElementPtr(),ldc,strideC,batchCount))
    return (_hipblasZdgmmStridedBatched_v2__retval,)


@cython.embedsignature(True)
def hipblasSgetrf(object handle, const int n, object A, const int lda, object ipiv, object info):
    r"""SOLVER API

    @{

    getrf computes the LU factorization of a general n-by-n matrix A
    using partial pivoting with row interchanges. The LU factorization can
    be done without pivoting if ipiv is passed as a nullptr.

    In the case that ipiv is not null, the factorization has the form:

    .. math::

       A = PLU

    where P is a permutation matrix, L is lower triangular with unit
    diagonal elements, and U is upper triangular.

    In the case that ipiv is null, the factorization is done without pivoting:

    .. math::

       A = LU

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`) -- *IN*:
            hipblasHandle_t.

        n (`~.int`) -- *IN*:
            int. n >= 0.

            The number of columns and rows of the matrix A.

        A (`~.hip._util.types.Pointer`/`~.object`) -- *INOUT*:
            pointer to type. Array on the GPU of dimension lda*n.

            On entry, the n-by-n matrix A to be factored.
            On exit, the factors L and U from the factorization.
            The unit diagonal elements of L are not stored.

        lda (`~.int`) -- *IN*:
            int. lda >= n.

            Specifies the leading dimension of A.

        ipiv (`~.hip._util.types.ListOfInt`/`~.object`) -- *OUT*:
            pointer to int. Array on the GPU of dimension n.

            The vector of pivot indices. Elements of ipiv are 1-based indices.
            For 1 <= i <= n, the row i of the
            matrix was interchanged with row ipiv[i].
            Matrix P of the factorization can be derived from ipiv.
            The factorization here can be done without pivoting if ipiv is passed
            in as a nullptr.

        info (`~.hip._util.types.ListOfInt`/`~.object`) -- *OUT*:
            pointer to a int on the GPU.

            If info = 0, successful exit.
            If info = j > 0, U is singular. U[j,j] is the first zero pivot.
    """
    _hipblasSgetrf__retval = hipblasStatus_t(chipblas.hipblasSgetrf(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,n,
        <float *>hip._util.types.Pointer.fromPyobj(A)._ptr,lda,
        <int *>hip._util.types.ListOfInt.fromPyobj(ipiv)._ptr,
        <int *>hip._util.types.ListOfInt.fromPyobj(info)._ptr))
    return (_hipblasSgetrf__retval,)


@cython.embedsignature(True)
def hipblasDgetrf(object handle, const int n, object A, const int lda, object ipiv, object info):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        A (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        ipiv (`~.hip._util.types.ListOfInt`/`~.object`):
            (undocumented)

        info (`~.hip._util.types.ListOfInt`/`~.object`):
            (undocumented)
    """
    _hipblasDgetrf__retval = hipblasStatus_t(chipblas.hipblasDgetrf(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,n,
        <double *>hip._util.types.Pointer.fromPyobj(A)._ptr,lda,
        <int *>hip._util.types.ListOfInt.fromPyobj(ipiv)._ptr,
        <int *>hip._util.types.ListOfInt.fromPyobj(info)._ptr))
    return (_hipblasDgetrf__retval,)


@cython.embedsignature(True)
def hipblasCgetrf(object handle, const int n, object A, const int lda, object ipiv, object info):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        A (`~.hipblasComplex`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        ipiv (`~.hip._util.types.ListOfInt`/`~.object`):
            (undocumented)

        info (`~.hip._util.types.ListOfInt`/`~.object`):
            (undocumented)
    """
    _hipblasCgetrf__retval = hipblasStatus_t(chipblas.hipblasCgetrf(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,n,
        hipblasComplex.fromPyobj(A).getElementPtr(),lda,
        <int *>hip._util.types.ListOfInt.fromPyobj(ipiv)._ptr,
        <int *>hip._util.types.ListOfInt.fromPyobj(info)._ptr))
    return (_hipblasCgetrf__retval,)


@cython.embedsignature(True)
def hipblasZgetrf(object handle, const int n, object A, const int lda, object ipiv, object info):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        A (`~.hipblasDoubleComplex`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        ipiv (`~.hip._util.types.ListOfInt`/`~.object`):
            (undocumented)

        info (`~.hip._util.types.ListOfInt`/`~.object`):
            (undocumented)
    """
    _hipblasZgetrf__retval = hipblasStatus_t(chipblas.hipblasZgetrf(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,n,
        hipblasDoubleComplex.fromPyobj(A).getElementPtr(),lda,
        <int *>hip._util.types.ListOfInt.fromPyobj(ipiv)._ptr,
        <int *>hip._util.types.ListOfInt.fromPyobj(info)._ptr))
    return (_hipblasZgetrf__retval,)


@cython.embedsignature(True)
def hipblasCgetrf_v2(object handle, const int n, object A, const int lda, object ipiv, object info):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        A (`~.float2`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        ipiv (`~.hip._util.types.ListOfInt`/`~.object`):
            (undocumented)

        info (`~.hip._util.types.ListOfInt`/`~.object`):
            (undocumented)
    """
    _hipblasCgetrf_v2__retval = hipblasStatus_t(chipblas.hipblasCgetrf_v2(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,n,
        float2.fromPyobj(A).getElementPtr(),lda,
        <int *>hip._util.types.ListOfInt.fromPyobj(ipiv)._ptr,
        <int *>hip._util.types.ListOfInt.fromPyobj(info)._ptr))
    return (_hipblasCgetrf_v2__retval,)


@cython.embedsignature(True)
def hipblasZgetrf_v2(object handle, const int n, object A, const int lda, object ipiv, object info):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        A (`~.double2`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        ipiv (`~.hip._util.types.ListOfInt`/`~.object`):
            (undocumented)

        info (`~.hip._util.types.ListOfInt`/`~.object`):
            (undocumented)
    """
    _hipblasZgetrf_v2__retval = hipblasStatus_t(chipblas.hipblasZgetrf_v2(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,n,
        double2.fromPyobj(A).getElementPtr(),lda,
        <int *>hip._util.types.ListOfInt.fromPyobj(ipiv)._ptr,
        <int *>hip._util.types.ListOfInt.fromPyobj(info)._ptr))
    return (_hipblasZgetrf_v2__retval,)


@cython.embedsignature(True)
def hipblasSgetrfBatched(object handle, const int n, object A, const int lda, object ipiv, object info, const int batchCount):
    r"""SOLVER API

    @{

    getrfBatched computes the LU factorization of a batch of general
    n-by-n matrices using partial pivoting with row interchanges. The LU factorization can
    be done without pivoting if ipiv is passed as a nullptr.

    In the case that ipiv is not null, the factorization of matrix :math:`A_i` in the batch has the form:

    .. math::

       A_i = P_iL_iU_i

    where :math:`P_i` is a permutation matrix, :math:`L_i` is lower triangular with unit
    diagonal elements, and :math:`U_i` is upper triangular.

    In the case that ipiv is null, the factorization is done without pivoting:

    .. math::

       A_i = L_iU_i

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`) -- *IN*:
            hipblasHandle_t.

        n (`~.int`) -- *IN*:
            int. n >= 0.

            The number of columns and rows of all matrices A_i in the batch.

        A (`~.hip._util.types.ListOfPointer`/`~.object`) -- *INOUT*:
            array of pointers to type. Each pointer points to an array on the GPU of dimension lda*n.

            On entry, the n-by-n matrices A_i to be factored.
            On exit, the factors L_i and U_i from the factorizations.
            The unit diagonal elements of L_i are not stored.

        lda (`~.int`) -- *IN*:
            int. lda >= n.

            Specifies the leading dimension of matrices A_i.

        ipiv (`~.hip._util.types.ListOfInt`/`~.object`) -- *OUT*:
            pointer to int. Array on the GPU.

            Contains the vectors of pivot indices ipiv_i (corresponding to A_i).
            Dimension of ipiv_i is n.
            Elements of ipiv_i are 1-based indices.
            For each instance A_i in the batch and for 1 <= j <= n, the row j of the
            matrix A_i was interchanged with row ipiv_i[j].
            Matrix P_i of the factorization can be derived from ipiv_i.
            The factorization here can be done without pivoting if ipiv is passed
            in as a nullptr.

        info (`~.hip._util.types.ListOfInt`/`~.object`) -- *OUT*:
            pointer to int. Array of batchCount integers on the GPU.

            If info[i] = 0, successful exit for factorization of A_i.
            If info[i] = j > 0, U_i is singular. U_i[j,j] is the first zero pivot.

        batchCount (`~.int`) -- *IN*:
            int. batchCount >= 0.

            Number of matrices in the batch.
    """
    _hipblasSgetrfBatched__retval = hipblasStatus_t(chipblas.hipblasSgetrfBatched(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,n,
        <float *const*>hip._util.types.ListOfPointer.fromPyobj(A)._ptr,lda,
        <int *>hip._util.types.ListOfInt.fromPyobj(ipiv)._ptr,
        <int *>hip._util.types.ListOfInt.fromPyobj(info)._ptr,batchCount))
    return (_hipblasSgetrfBatched__retval,)


@cython.embedsignature(True)
def hipblasDgetrfBatched(object handle, const int n, object A, const int lda, object ipiv, object info, const int batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        A (`~.hip._util.types.ListOfPointer`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        ipiv (`~.hip._util.types.ListOfInt`/`~.object`):
            (undocumented)

        info (`~.hip._util.types.ListOfInt`/`~.object`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    _hipblasDgetrfBatched__retval = hipblasStatus_t(chipblas.hipblasDgetrfBatched(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,n,
        <double *const*>hip._util.types.ListOfPointer.fromPyobj(A)._ptr,lda,
        <int *>hip._util.types.ListOfInt.fromPyobj(ipiv)._ptr,
        <int *>hip._util.types.ListOfInt.fromPyobj(info)._ptr,batchCount))
    return (_hipblasDgetrfBatched__retval,)


@cython.embedsignature(True)
def hipblasCgetrfBatched(object handle, const int n, object A, const int lda, object ipiv, object info, const int batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        A (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        ipiv (`~.hip._util.types.ListOfInt`/`~.object`):
            (undocumented)

        info (`~.hip._util.types.ListOfInt`/`~.object`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    _hipblasCgetrfBatched__retval = hipblasStatus_t(chipblas.hipblasCgetrfBatched(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,n,
        <chipblas.hipblasComplex *const*>hip._util.types.Pointer.fromPyobj(A)._ptr,lda,
        <int *>hip._util.types.ListOfInt.fromPyobj(ipiv)._ptr,
        <int *>hip._util.types.ListOfInt.fromPyobj(info)._ptr,batchCount))
    return (_hipblasCgetrfBatched__retval,)


@cython.embedsignature(True)
def hipblasZgetrfBatched(object handle, const int n, object A, const int lda, object ipiv, object info, const int batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        A (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        ipiv (`~.hip._util.types.ListOfInt`/`~.object`):
            (undocumented)

        info (`~.hip._util.types.ListOfInt`/`~.object`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    _hipblasZgetrfBatched__retval = hipblasStatus_t(chipblas.hipblasZgetrfBatched(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,n,
        <chipblas.hipblasDoubleComplex *const*>hip._util.types.Pointer.fromPyobj(A)._ptr,lda,
        <int *>hip._util.types.ListOfInt.fromPyobj(ipiv)._ptr,
        <int *>hip._util.types.ListOfInt.fromPyobj(info)._ptr,batchCount))
    return (_hipblasZgetrfBatched__retval,)


@cython.embedsignature(True)
def hipblasCgetrfBatched_v2(object handle, const int n, object A, const int lda, object ipiv, object info, const int batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        A (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        ipiv (`~.hip._util.types.ListOfInt`/`~.object`):
            (undocumented)

        info (`~.hip._util.types.ListOfInt`/`~.object`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    _hipblasCgetrfBatched_v2__retval = hipblasStatus_t(chipblas.hipblasCgetrfBatched_v2(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,n,
        <chipblas.float2 *const*>hip._util.types.Pointer.fromPyobj(A)._ptr,lda,
        <int *>hip._util.types.ListOfInt.fromPyobj(ipiv)._ptr,
        <int *>hip._util.types.ListOfInt.fromPyobj(info)._ptr,batchCount))
    return (_hipblasCgetrfBatched_v2__retval,)


@cython.embedsignature(True)
def hipblasZgetrfBatched_v2(object handle, const int n, object A, const int lda, object ipiv, object info, const int batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        A (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        ipiv (`~.hip._util.types.ListOfInt`/`~.object`):
            (undocumented)

        info (`~.hip._util.types.ListOfInt`/`~.object`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    _hipblasZgetrfBatched_v2__retval = hipblasStatus_t(chipblas.hipblasZgetrfBatched_v2(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,n,
        <chipblas.double2 *const*>hip._util.types.Pointer.fromPyobj(A)._ptr,lda,
        <int *>hip._util.types.ListOfInt.fromPyobj(ipiv)._ptr,
        <int *>hip._util.types.ListOfInt.fromPyobj(info)._ptr,batchCount))
    return (_hipblasZgetrfBatched_v2__retval,)


@cython.embedsignature(True)
def hipblasSgetrfStridedBatched(object handle, const int n, object A, const int lda, const long strideA, object ipiv, const long strideP, object info, const int batchCount):
    r"""SOLVER API

    @{

    getrfStridedBatched computes the LU factorization of a batch of
    general n-by-n matrices using partial pivoting with row interchanges. The LU factorization can
    be done without pivoting if ipiv is passed as a nullptr.

    In the case that ipiv is not null, the factorization of matrix :math:`A_i` in the batch has the form:

    .. math::

       A_i = P_iL_iU_i

    where :math:`P_i` is a permutation matrix, :math:`L_i` is lower triangular with unit
    diagonal elements, and :math:`U_i` is upper triangular.

    In the case that ipiv is null, the factorization is done without pivoting:

    .. math::

       A_i = L_iU_i

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`) -- *IN*:
            hipblasHandle_t.

        n (`~.int`) -- *IN*:
            int. n >= 0.

            The number of columns and rows of all matrices A_i in the batch.

        A (`~.hip._util.types.Pointer`/`~.object`) -- *INOUT*:
            pointer to type. Array on the GPU (the size depends on the value of strideA).

            On entry, the n-by-n matrices A_i to be factored.
            On exit, the factors L_i and U_i from the factorization.
            The unit diagonal elements of L_i are not stored.

        lda (`~.int`) -- *IN*:
            int. lda >= n.

            Specifies the leading dimension of matrices A_i.

        strideA (`~.int`) -- *IN*:
            hipblasStride.

            Stride from the start of one matrix A_i to the next one A_(i+1).
            There is no restriction for the value of strideA. Normal use case is strideA >= lda*n

        ipiv (`~.hip._util.types.ListOfInt`/`~.object`) -- *OUT*:
            pointer to int. Array on the GPU (the size depends on the value of strideP).

            Contains the vectors of pivots indices ipiv_i (corresponding to A_i).
            Dimension of ipiv_i is n.
            Elements of ipiv_i are 1-based indices.
            For each instance A_i in the batch and for 1 <= j <= n, the row j of the
            matrix A_i was interchanged with row ipiv_i[j].
            Matrix P_i of the factorization can be derived from ipiv_i.
            The factorization here can be done without pivoting if ipiv is passed
            in as a nullptr.

        strideP (`~.int`) -- *IN*:
            hipblasStride.

            Stride from the start of one vector ipiv_i to the next one ipiv_(i+1).
            There is no restriction for the value of strideP. Normal use case is strideP >= n.

        info (`~.hip._util.types.ListOfInt`/`~.object`) -- *OUT*:
            pointer to int. Array of batchCount integers on the GPU.

            If info[i] = 0, successful exit for factorization of A_i.
            If info[i] = j > 0, U_i is singular. U_i[j,j] is the first zero pivot.

        batchCount (`~.int`) -- *IN*:
            int. batchCount >= 0.

            Number of matrices in the batch.
    """
    _hipblasSgetrfStridedBatched__retval = hipblasStatus_t(chipblas.hipblasSgetrfStridedBatched(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,n,
        <float *>hip._util.types.Pointer.fromPyobj(A)._ptr,lda,strideA,
        <int *>hip._util.types.ListOfInt.fromPyobj(ipiv)._ptr,strideP,
        <int *>hip._util.types.ListOfInt.fromPyobj(info)._ptr,batchCount))
    return (_hipblasSgetrfStridedBatched__retval,)


@cython.embedsignature(True)
def hipblasDgetrfStridedBatched(object handle, const int n, object A, const int lda, const long strideA, object ipiv, const long strideP, object info, const int batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        A (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        strideA (`~.int`):
            (undocumented)

        ipiv (`~.hip._util.types.ListOfInt`/`~.object`):
            (undocumented)

        strideP (`~.int`):
            (undocumented)

        info (`~.hip._util.types.ListOfInt`/`~.object`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    _hipblasDgetrfStridedBatched__retval = hipblasStatus_t(chipblas.hipblasDgetrfStridedBatched(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,n,
        <double *>hip._util.types.Pointer.fromPyobj(A)._ptr,lda,strideA,
        <int *>hip._util.types.ListOfInt.fromPyobj(ipiv)._ptr,strideP,
        <int *>hip._util.types.ListOfInt.fromPyobj(info)._ptr,batchCount))
    return (_hipblasDgetrfStridedBatched__retval,)


@cython.embedsignature(True)
def hipblasCgetrfStridedBatched(object handle, const int n, object A, const int lda, const long strideA, object ipiv, const long strideP, object info, const int batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        A (`~.hipblasComplex`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        strideA (`~.int`):
            (undocumented)

        ipiv (`~.hip._util.types.ListOfInt`/`~.object`):
            (undocumented)

        strideP (`~.int`):
            (undocumented)

        info (`~.hip._util.types.ListOfInt`/`~.object`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    _hipblasCgetrfStridedBatched__retval = hipblasStatus_t(chipblas.hipblasCgetrfStridedBatched(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,n,
        hipblasComplex.fromPyobj(A).getElementPtr(),lda,strideA,
        <int *>hip._util.types.ListOfInt.fromPyobj(ipiv)._ptr,strideP,
        <int *>hip._util.types.ListOfInt.fromPyobj(info)._ptr,batchCount))
    return (_hipblasCgetrfStridedBatched__retval,)


@cython.embedsignature(True)
def hipblasZgetrfStridedBatched(object handle, const int n, object A, const int lda, const long strideA, object ipiv, const long strideP, object info, const int batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        A (`~.hipblasDoubleComplex`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        strideA (`~.int`):
            (undocumented)

        ipiv (`~.hip._util.types.ListOfInt`/`~.object`):
            (undocumented)

        strideP (`~.int`):
            (undocumented)

        info (`~.hip._util.types.ListOfInt`/`~.object`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    _hipblasZgetrfStridedBatched__retval = hipblasStatus_t(chipblas.hipblasZgetrfStridedBatched(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,n,
        hipblasDoubleComplex.fromPyobj(A).getElementPtr(),lda,strideA,
        <int *>hip._util.types.ListOfInt.fromPyobj(ipiv)._ptr,strideP,
        <int *>hip._util.types.ListOfInt.fromPyobj(info)._ptr,batchCount))
    return (_hipblasZgetrfStridedBatched__retval,)


@cython.embedsignature(True)
def hipblasCgetrfStridedBatched_v2(object handle, const int n, object A, const int lda, const long strideA, object ipiv, const long strideP, object info, const int batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        A (`~.float2`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        strideA (`~.int`):
            (undocumented)

        ipiv (`~.hip._util.types.ListOfInt`/`~.object`):
            (undocumented)

        strideP (`~.int`):
            (undocumented)

        info (`~.hip._util.types.ListOfInt`/`~.object`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    _hipblasCgetrfStridedBatched_v2__retval = hipblasStatus_t(chipblas.hipblasCgetrfStridedBatched_v2(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,n,
        float2.fromPyobj(A).getElementPtr(),lda,strideA,
        <int *>hip._util.types.ListOfInt.fromPyobj(ipiv)._ptr,strideP,
        <int *>hip._util.types.ListOfInt.fromPyobj(info)._ptr,batchCount))
    return (_hipblasCgetrfStridedBatched_v2__retval,)


@cython.embedsignature(True)
def hipblasZgetrfStridedBatched_v2(object handle, const int n, object A, const int lda, const long strideA, object ipiv, const long strideP, object info, const int batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        A (`~.double2`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        strideA (`~.int`):
            (undocumented)

        ipiv (`~.hip._util.types.ListOfInt`/`~.object`):
            (undocumented)

        strideP (`~.int`):
            (undocumented)

        info (`~.hip._util.types.ListOfInt`/`~.object`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    _hipblasZgetrfStridedBatched_v2__retval = hipblasStatus_t(chipblas.hipblasZgetrfStridedBatched_v2(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,n,
        double2.fromPyobj(A).getElementPtr(),lda,strideA,
        <int *>hip._util.types.ListOfInt.fromPyobj(ipiv)._ptr,strideP,
        <int *>hip._util.types.ListOfInt.fromPyobj(info)._ptr,batchCount))
    return (_hipblasZgetrfStridedBatched_v2__retval,)


@cython.embedsignature(True)
def hipblasSgetrs(object handle, object trans, const int n, const int nrhs, object A, const int lda, object ipiv, object B, const int ldb, object info):
    r"""SOLVER API

    @{

    getrs solves a system of n linear equations on n variables in its factorized form.

    It solves one of the following systems, depending on the value of trans:

    .. math::

       \begin{array}{cl}
       A X = B & \: \text{not transposed,}\\
       A^T X = B & \: \text{transposed, or}\\
       A^H X = B & \: \text{conjugate transposed.}
       \end{array}

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`) -- *IN*:
            hipblasHandle_t.

        trans (`~.hipblasOperation_t`) -- *IN*:
            hipblasOperation_t.

            Specifies the form of the system of equations.

        n (`~.int`) -- *IN*:
            int. n >= 0.

            The order of the system, i.e. the number of columns and rows of A.

        nrhs (`~.int`) -- *IN*:
            int. nrhs >= 0.

            The number of right hand sides, i.e., the number of columns
            of the matrix B.

        A (`~.hip._util.types.Pointer`/`~.object`) -- *IN*:
            pointer to type. Array on the GPU of dimension lda*n.

            The factors L and U of the factorization A = P*L*U returned by ``hipblasSgetrf`` .

        lda (`~.int`) -- *IN*:
            int. lda >= n.

            The leading dimension of A.

        ipiv (`~.hip._util.types.ListOfInt`/`~.object`) -- *IN*:
            pointer to int. Array on the GPU of dimension n.

            The pivot indices returned by ``hipblasSgetrf`` .

        B (`~.hip._util.types.Pointer`/`~.object`) -- *IN,OUT*:
            pointer to type. Array on the GPU of dimension ldb*nrhs.

            On entry, the right hand side matrix B.
            On exit, the solution matrix X.

        ldb (`~.int`) -- *IN*:
            int. ldb >= n.

            The leading dimension of B.

        info (`~.hip._util.types.ListOfInt`/`~.object`) -- *OUT*:
            pointer to a int on the host.

            If info = 0, successful exit.
            If info = j < 0, the argument at position -j is invalid.
    """
    if not isinstance(trans,_hipblasOperation_t__Base):
        raise TypeError("argument 'trans' must be of type '_hipblasOperation_t__Base'")
    _hipblasSgetrs__retval = hipblasStatus_t(chipblas.hipblasSgetrs(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,trans.value,n,nrhs,
        <float *>hip._util.types.Pointer.fromPyobj(A)._ptr,lda,
        <const int *>hip._util.types.ListOfInt.fromPyobj(ipiv)._ptr,
        <float *>hip._util.types.Pointer.fromPyobj(B)._ptr,ldb,
        <int *>hip._util.types.ListOfInt.fromPyobj(info)._ptr))
    return (_hipblasSgetrs__retval,)


@cython.embedsignature(True)
def hipblasDgetrs(object handle, object trans, const int n, const int nrhs, object A, const int lda, object ipiv, object B, const int ldb, object info):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        trans (`~.hipblasOperation_t`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        nrhs (`~.int`):
            (undocumented)

        A (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        ipiv (`~.hip._util.types.ListOfInt`/`~.object`):
            (undocumented)

        B (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        ldb (`~.int`):
            (undocumented)

        info (`~.hip._util.types.ListOfInt`/`~.object`):
            (undocumented)
    """
    if not isinstance(trans,_hipblasOperation_t__Base):
        raise TypeError("argument 'trans' must be of type '_hipblasOperation_t__Base'")
    _hipblasDgetrs__retval = hipblasStatus_t(chipblas.hipblasDgetrs(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,trans.value,n,nrhs,
        <double *>hip._util.types.Pointer.fromPyobj(A)._ptr,lda,
        <const int *>hip._util.types.ListOfInt.fromPyobj(ipiv)._ptr,
        <double *>hip._util.types.Pointer.fromPyobj(B)._ptr,ldb,
        <int *>hip._util.types.ListOfInt.fromPyobj(info)._ptr))
    return (_hipblasDgetrs__retval,)


@cython.embedsignature(True)
def hipblasCgetrs(object handle, object trans, const int n, const int nrhs, object A, const int lda, object ipiv, object B, const int ldb, object info):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        trans (`~.hipblasOperation_t`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        nrhs (`~.int`):
            (undocumented)

        A (`~.hipblasComplex`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        ipiv (`~.hip._util.types.ListOfInt`/`~.object`):
            (undocumented)

        B (`~.hipblasComplex`/`~.object`):
            (undocumented)

        ldb (`~.int`):
            (undocumented)

        info (`~.hip._util.types.ListOfInt`/`~.object`):
            (undocumented)
    """
    if not isinstance(trans,_hipblasOperation_t__Base):
        raise TypeError("argument 'trans' must be of type '_hipblasOperation_t__Base'")
    _hipblasCgetrs__retval = hipblasStatus_t(chipblas.hipblasCgetrs(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,trans.value,n,nrhs,
        hipblasComplex.fromPyobj(A).getElementPtr(),lda,
        <const int *>hip._util.types.ListOfInt.fromPyobj(ipiv)._ptr,
        hipblasComplex.fromPyobj(B).getElementPtr(),ldb,
        <int *>hip._util.types.ListOfInt.fromPyobj(info)._ptr))
    return (_hipblasCgetrs__retval,)


@cython.embedsignature(True)
def hipblasZgetrs(object handle, object trans, const int n, const int nrhs, object A, const int lda, object ipiv, object B, const int ldb, object info):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        trans (`~.hipblasOperation_t`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        nrhs (`~.int`):
            (undocumented)

        A (`~.hipblasDoubleComplex`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        ipiv (`~.hip._util.types.ListOfInt`/`~.object`):
            (undocumented)

        B (`~.hipblasDoubleComplex`/`~.object`):
            (undocumented)

        ldb (`~.int`):
            (undocumented)

        info (`~.hip._util.types.ListOfInt`/`~.object`):
            (undocumented)
    """
    if not isinstance(trans,_hipblasOperation_t__Base):
        raise TypeError("argument 'trans' must be of type '_hipblasOperation_t__Base'")
    _hipblasZgetrs__retval = hipblasStatus_t(chipblas.hipblasZgetrs(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,trans.value,n,nrhs,
        hipblasDoubleComplex.fromPyobj(A).getElementPtr(),lda,
        <const int *>hip._util.types.ListOfInt.fromPyobj(ipiv)._ptr,
        hipblasDoubleComplex.fromPyobj(B).getElementPtr(),ldb,
        <int *>hip._util.types.ListOfInt.fromPyobj(info)._ptr))
    return (_hipblasZgetrs__retval,)


@cython.embedsignature(True)
def hipblasCgetrs_v2(object handle, object trans, const int n, const int nrhs, object A, const int lda, object ipiv, object B, const int ldb, object info):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        trans (`~.hipblasOperation_t`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        nrhs (`~.int`):
            (undocumented)

        A (`~.float2`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        ipiv (`~.hip._util.types.ListOfInt`/`~.object`):
            (undocumented)

        B (`~.float2`/`~.object`):
            (undocumented)

        ldb (`~.int`):
            (undocumented)

        info (`~.hip._util.types.ListOfInt`/`~.object`):
            (undocumented)
    """
    if not isinstance(trans,_hipblasOperation_t__Base):
        raise TypeError("argument 'trans' must be of type '_hipblasOperation_t__Base'")
    _hipblasCgetrs_v2__retval = hipblasStatus_t(chipblas.hipblasCgetrs_v2(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,trans.value,n,nrhs,
        float2.fromPyobj(A).getElementPtr(),lda,
        <const int *>hip._util.types.ListOfInt.fromPyobj(ipiv)._ptr,
        float2.fromPyobj(B).getElementPtr(),ldb,
        <int *>hip._util.types.ListOfInt.fromPyobj(info)._ptr))
    return (_hipblasCgetrs_v2__retval,)


@cython.embedsignature(True)
def hipblasZgetrs_v2(object handle, object trans, const int n, const int nrhs, object A, const int lda, object ipiv, object B, const int ldb, object info):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        trans (`~.hipblasOperation_t`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        nrhs (`~.int`):
            (undocumented)

        A (`~.double2`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        ipiv (`~.hip._util.types.ListOfInt`/`~.object`):
            (undocumented)

        B (`~.double2`/`~.object`):
            (undocumented)

        ldb (`~.int`):
            (undocumented)

        info (`~.hip._util.types.ListOfInt`/`~.object`):
            (undocumented)
    """
    if not isinstance(trans,_hipblasOperation_t__Base):
        raise TypeError("argument 'trans' must be of type '_hipblasOperation_t__Base'")
    _hipblasZgetrs_v2__retval = hipblasStatus_t(chipblas.hipblasZgetrs_v2(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,trans.value,n,nrhs,
        double2.fromPyobj(A).getElementPtr(),lda,
        <const int *>hip._util.types.ListOfInt.fromPyobj(ipiv)._ptr,
        double2.fromPyobj(B).getElementPtr(),ldb,
        <int *>hip._util.types.ListOfInt.fromPyobj(info)._ptr))
    return (_hipblasZgetrs_v2__retval,)


@cython.embedsignature(True)
def hipblasSgetrsBatched(object handle, object trans, const int n, const int nrhs, object A, const int lda, object ipiv, object B, const int ldb, object info, const int batchCount):
    r"""SOLVER API

    @{

    getrsBatched solves a batch of systems of n linear equations on n
    variables in its factorized forms.

    For each instance i in the batch, it solves one of the following systems, depending on the value of trans:

    .. math::

       \begin{array}{cl}
       A_i X_i = B_i & \: \text{not transposed,}\\
       A_i^T X_i = B_i & \: \text{transposed, or}\\
       A_i^H X_i = B_i & \: \text{conjugate transposed.}
       \end{array}

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`) -- *IN*:
            hipblasHandle_t.

        trans (`~.hipblasOperation_t`) -- *IN*:
            hipblasOperation_t.

            Specifies the form of the system of equations of each instance in the batch.

        n (`~.int`) -- *IN*:
            int. n >= 0.

            The order of the system, i.e. the number of columns and rows of all A_i matrices.

        nrhs (`~.int`) -- *IN*:
            int. nrhs >= 0.

            The number of right hand sides, i.e., the number of columns
            of all the matrices B_i.

        A (`~.hip._util.types.ListOfPointer`/`~.object`) -- *IN*:
            Array of pointers to type. Each pointer points to an array on the GPU of dimension lda*n.

            The factors L_i and U_i of the factorization A_i = P_i*L_i*U_i returned by ``hipblasSgetrfBatched`` .

        lda (`~.int`) -- *IN*:
            int. lda >= n.

            The leading dimension of matrices A_i.

        ipiv (`~.hip._util.types.ListOfInt`/`~.object`) -- *IN*:
            pointer to int. Array on the GPU.

            Contains the vectors ipiv_i of pivot indices returned by ``hipblasSgetrfBatched`` .

        B (`~.hip._util.types.ListOfPointer`/`~.object`) -- *IN,OUT*:
            Array of pointers to type. Each pointer points to an array on the GPU of dimension ldb*nrhs.

            On entry, the right hand side matrices B_i.
            On exit, the solution matrix X_i of each system in the batch.

        ldb (`~.int`) -- *IN*:
            int. ldb >= n.

            The leading dimension of matrices B_i.

        info (`~.hip._util.types.ListOfInt`/`~.object`) -- *OUT*:
            pointer to a int on the host.

            If info = 0, successful exit.
            If info = j < 0, the argument at position -j is invalid.

        batchCount (`~.int`) -- *IN*:
            int. batchCount >= 0.

            Number of instances (systems) in the batch.
    """
    if not isinstance(trans,_hipblasOperation_t__Base):
        raise TypeError("argument 'trans' must be of type '_hipblasOperation_t__Base'")
    _hipblasSgetrsBatched__retval = hipblasStatus_t(chipblas.hipblasSgetrsBatched(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,trans.value,n,nrhs,
        <float *const*>hip._util.types.ListOfPointer.fromPyobj(A)._ptr,lda,
        <const int *>hip._util.types.ListOfInt.fromPyobj(ipiv)._ptr,
        <float *const*>hip._util.types.ListOfPointer.fromPyobj(B)._ptr,ldb,
        <int *>hip._util.types.ListOfInt.fromPyobj(info)._ptr,batchCount))
    return (_hipblasSgetrsBatched__retval,)


@cython.embedsignature(True)
def hipblasDgetrsBatched(object handle, object trans, const int n, const int nrhs, object A, const int lda, object ipiv, object B, const int ldb, object info, const int batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        trans (`~.hipblasOperation_t`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        nrhs (`~.int`):
            (undocumented)

        A (`~.hip._util.types.ListOfPointer`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        ipiv (`~.hip._util.types.ListOfInt`/`~.object`):
            (undocumented)

        B (`~.hip._util.types.ListOfPointer`/`~.object`):
            (undocumented)

        ldb (`~.int`):
            (undocumented)

        info (`~.hip._util.types.ListOfInt`/`~.object`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    if not isinstance(trans,_hipblasOperation_t__Base):
        raise TypeError("argument 'trans' must be of type '_hipblasOperation_t__Base'")
    _hipblasDgetrsBatched__retval = hipblasStatus_t(chipblas.hipblasDgetrsBatched(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,trans.value,n,nrhs,
        <double *const*>hip._util.types.ListOfPointer.fromPyobj(A)._ptr,lda,
        <const int *>hip._util.types.ListOfInt.fromPyobj(ipiv)._ptr,
        <double *const*>hip._util.types.ListOfPointer.fromPyobj(B)._ptr,ldb,
        <int *>hip._util.types.ListOfInt.fromPyobj(info)._ptr,batchCount))
    return (_hipblasDgetrsBatched__retval,)


@cython.embedsignature(True)
def hipblasCgetrsBatched(object handle, object trans, const int n, const int nrhs, object A, const int lda, object ipiv, object B, const int ldb, object info, const int batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        trans (`~.hipblasOperation_t`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        nrhs (`~.int`):
            (undocumented)

        A (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        ipiv (`~.hip._util.types.ListOfInt`/`~.object`):
            (undocumented)

        B (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        ldb (`~.int`):
            (undocumented)

        info (`~.hip._util.types.ListOfInt`/`~.object`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    if not isinstance(trans,_hipblasOperation_t__Base):
        raise TypeError("argument 'trans' must be of type '_hipblasOperation_t__Base'")
    _hipblasCgetrsBatched__retval = hipblasStatus_t(chipblas.hipblasCgetrsBatched(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,trans.value,n,nrhs,
        <chipblas.hipblasComplex *const*>hip._util.types.Pointer.fromPyobj(A)._ptr,lda,
        <const int *>hip._util.types.ListOfInt.fromPyobj(ipiv)._ptr,
        <chipblas.hipblasComplex *const*>hip._util.types.Pointer.fromPyobj(B)._ptr,ldb,
        <int *>hip._util.types.ListOfInt.fromPyobj(info)._ptr,batchCount))
    return (_hipblasCgetrsBatched__retval,)


@cython.embedsignature(True)
def hipblasZgetrsBatched(object handle, object trans, const int n, const int nrhs, object A, const int lda, object ipiv, object B, const int ldb, object info, const int batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        trans (`~.hipblasOperation_t`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        nrhs (`~.int`):
            (undocumented)

        A (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        ipiv (`~.hip._util.types.ListOfInt`/`~.object`):
            (undocumented)

        B (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        ldb (`~.int`):
            (undocumented)

        info (`~.hip._util.types.ListOfInt`/`~.object`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    if not isinstance(trans,_hipblasOperation_t__Base):
        raise TypeError("argument 'trans' must be of type '_hipblasOperation_t__Base'")
    _hipblasZgetrsBatched__retval = hipblasStatus_t(chipblas.hipblasZgetrsBatched(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,trans.value,n,nrhs,
        <chipblas.hipblasDoubleComplex *const*>hip._util.types.Pointer.fromPyobj(A)._ptr,lda,
        <const int *>hip._util.types.ListOfInt.fromPyobj(ipiv)._ptr,
        <chipblas.hipblasDoubleComplex *const*>hip._util.types.Pointer.fromPyobj(B)._ptr,ldb,
        <int *>hip._util.types.ListOfInt.fromPyobj(info)._ptr,batchCount))
    return (_hipblasZgetrsBatched__retval,)


@cython.embedsignature(True)
def hipblasCgetrsBatched_v2(object handle, object trans, const int n, const int nrhs, object A, const int lda, object ipiv, object B, const int ldb, object info, const int batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        trans (`~.hipblasOperation_t`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        nrhs (`~.int`):
            (undocumented)

        A (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        ipiv (`~.hip._util.types.ListOfInt`/`~.object`):
            (undocumented)

        B (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        ldb (`~.int`):
            (undocumented)

        info (`~.hip._util.types.ListOfInt`/`~.object`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    if not isinstance(trans,_hipblasOperation_t__Base):
        raise TypeError("argument 'trans' must be of type '_hipblasOperation_t__Base'")
    _hipblasCgetrsBatched_v2__retval = hipblasStatus_t(chipblas.hipblasCgetrsBatched_v2(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,trans.value,n,nrhs,
        <chipblas.float2 *const*>hip._util.types.Pointer.fromPyobj(A)._ptr,lda,
        <const int *>hip._util.types.ListOfInt.fromPyobj(ipiv)._ptr,
        <chipblas.float2 *const*>hip._util.types.Pointer.fromPyobj(B)._ptr,ldb,
        <int *>hip._util.types.ListOfInt.fromPyobj(info)._ptr,batchCount))
    return (_hipblasCgetrsBatched_v2__retval,)


@cython.embedsignature(True)
def hipblasZgetrsBatched_v2(object handle, object trans, const int n, const int nrhs, object A, const int lda, object ipiv, object B, const int ldb, object info, const int batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        trans (`~.hipblasOperation_t`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        nrhs (`~.int`):
            (undocumented)

        A (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        ipiv (`~.hip._util.types.ListOfInt`/`~.object`):
            (undocumented)

        B (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        ldb (`~.int`):
            (undocumented)

        info (`~.hip._util.types.ListOfInt`/`~.object`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    if not isinstance(trans,_hipblasOperation_t__Base):
        raise TypeError("argument 'trans' must be of type '_hipblasOperation_t__Base'")
    _hipblasZgetrsBatched_v2__retval = hipblasStatus_t(chipblas.hipblasZgetrsBatched_v2(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,trans.value,n,nrhs,
        <chipblas.double2 *const*>hip._util.types.Pointer.fromPyobj(A)._ptr,lda,
        <const int *>hip._util.types.ListOfInt.fromPyobj(ipiv)._ptr,
        <chipblas.double2 *const*>hip._util.types.Pointer.fromPyobj(B)._ptr,ldb,
        <int *>hip._util.types.ListOfInt.fromPyobj(info)._ptr,batchCount))
    return (_hipblasZgetrsBatched_v2__retval,)


@cython.embedsignature(True)
def hipblasSgetrsStridedBatched(object handle, object trans, const int n, const int nrhs, object A, const int lda, const long strideA, object ipiv, const long strideP, object B, const int ldb, const long strideB, object info, const int batchCount):
    r"""SOLVER API

    @{

    getrsStridedBatched solves a batch of systems of n linear equations
    on n variables in its factorized forms.

    For each instance i in the batch, it solves one of the following systems, depending on the value of trans:

    .. math::

       \begin{array}{cl}
       A_i X_i = B_i & \: \text{not transposed,}\\
       A_i^T X_i = B_i & \: \text{transposed, or}\\
       A_i^H X_i = B_i & \: \text{conjugate transposed.}
       \end{array}

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`) -- *IN*:
            hipblasHandle_t.

        trans (`~.hipblasOperation_t`) -- *IN*:
            hipblasOperation_t.

            Specifies the form of the system of equations of each instance in the batch.

        n (`~.int`) -- *IN*:
            int. n >= 0.

            The order of the system, i.e. the number of columns and rows of all A_i matrices.

        nrhs (`~.int`) -- *IN*:
            int. nrhs >= 0.

            The number of right hand sides, i.e., the number of columns
            of all the matrices B_i.

        A (`~.hip._util.types.Pointer`/`~.object`) -- *IN*:
            pointer to type. Array on the GPU (the size depends on the value of strideA).

            The factors L_i and U_i of the factorization A_i = P_i*L_i*U_i returned by ``hipblasSgetrfStridedBatched`` .

        lda (`~.int`) -- *IN*:
            int. lda >= n.

            The leading dimension of matrices A_i.

        strideA (`~.int`) -- *IN*:
            hipblasStride.

            Stride from the start of one matrix A_i to the next one A_(i+1).
            There is no restriction for the value of strideA. Normal use case is strideA >= lda*n.

        ipiv (`~.hip._util.types.ListOfInt`/`~.object`) -- *IN*:
            pointer to int. Array on the GPU (the size depends on the value of strideP).

            Contains the vectors ipiv_i of pivot indices returned by ``hipblasSgetrfStridedBatched`` .

        strideP (`~.int`) -- *IN*:
            hipblasStride.

            Stride from the start of one vector ipiv_i to the next one ipiv_(i+1).
            There is no restriction for the value of strideP. Normal use case is strideP >= n.

        B (`~.hip._util.types.Pointer`/`~.object`) -- *IN,OUT*:
            pointer to type. Array on the GPU (size depends on the value of strideB).

            On entry, the right hand side matrices B_i.
            On exit, the solution matrix X_i of each system in the batch.

        ldb (`~.int`) -- *IN*:
            int. ldb >= n.

            The leading dimension of matrices B_i.

        strideB (`~.int`) -- *IN*:
            hipblasStride.

            Stride from the start of one matrix B_i to the next one B_(i+1).
            There is no restriction for the value of strideB. Normal use case is strideB >= ldb*nrhs.

        info (`~.hip._util.types.ListOfInt`/`~.object`) -- *OUT*:
            pointer to a int on the host.

            If info = 0, successful exit.
            If info = j < 0, the argument at position -j is invalid.

        batchCount (`~.int`) -- *IN*:
            int. batchCount >= 0.

            Number of instances (systems) in the batch.
    """
    if not isinstance(trans,_hipblasOperation_t__Base):
        raise TypeError("argument 'trans' must be of type '_hipblasOperation_t__Base'")
    _hipblasSgetrsStridedBatched__retval = hipblasStatus_t(chipblas.hipblasSgetrsStridedBatched(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,trans.value,n,nrhs,
        <float *>hip._util.types.Pointer.fromPyobj(A)._ptr,lda,strideA,
        <const int *>hip._util.types.ListOfInt.fromPyobj(ipiv)._ptr,strideP,
        <float *>hip._util.types.Pointer.fromPyobj(B)._ptr,ldb,strideB,
        <int *>hip._util.types.ListOfInt.fromPyobj(info)._ptr,batchCount))
    return (_hipblasSgetrsStridedBatched__retval,)


@cython.embedsignature(True)
def hipblasDgetrsStridedBatched(object handle, object trans, const int n, const int nrhs, object A, const int lda, const long strideA, object ipiv, const long strideP, object B, const int ldb, const long strideB, object info, const int batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        trans (`~.hipblasOperation_t`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        nrhs (`~.int`):
            (undocumented)

        A (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        strideA (`~.int`):
            (undocumented)

        ipiv (`~.hip._util.types.ListOfInt`/`~.object`):
            (undocumented)

        strideP (`~.int`):
            (undocumented)

        B (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        ldb (`~.int`):
            (undocumented)

        strideB (`~.int`):
            (undocumented)

        info (`~.hip._util.types.ListOfInt`/`~.object`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    if not isinstance(trans,_hipblasOperation_t__Base):
        raise TypeError("argument 'trans' must be of type '_hipblasOperation_t__Base'")
    _hipblasDgetrsStridedBatched__retval = hipblasStatus_t(chipblas.hipblasDgetrsStridedBatched(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,trans.value,n,nrhs,
        <double *>hip._util.types.Pointer.fromPyobj(A)._ptr,lda,strideA,
        <const int *>hip._util.types.ListOfInt.fromPyobj(ipiv)._ptr,strideP,
        <double *>hip._util.types.Pointer.fromPyobj(B)._ptr,ldb,strideB,
        <int *>hip._util.types.ListOfInt.fromPyobj(info)._ptr,batchCount))
    return (_hipblasDgetrsStridedBatched__retval,)


@cython.embedsignature(True)
def hipblasCgetrsStridedBatched(object handle, object trans, const int n, const int nrhs, object A, const int lda, const long strideA, object ipiv, const long strideP, object B, const int ldb, const long strideB, object info, const int batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        trans (`~.hipblasOperation_t`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        nrhs (`~.int`):
            (undocumented)

        A (`~.hipblasComplex`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        strideA (`~.int`):
            (undocumented)

        ipiv (`~.hip._util.types.ListOfInt`/`~.object`):
            (undocumented)

        strideP (`~.int`):
            (undocumented)

        B (`~.hipblasComplex`/`~.object`):
            (undocumented)

        ldb (`~.int`):
            (undocumented)

        strideB (`~.int`):
            (undocumented)

        info (`~.hip._util.types.ListOfInt`/`~.object`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    if not isinstance(trans,_hipblasOperation_t__Base):
        raise TypeError("argument 'trans' must be of type '_hipblasOperation_t__Base'")
    _hipblasCgetrsStridedBatched__retval = hipblasStatus_t(chipblas.hipblasCgetrsStridedBatched(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,trans.value,n,nrhs,
        hipblasComplex.fromPyobj(A).getElementPtr(),lda,strideA,
        <const int *>hip._util.types.ListOfInt.fromPyobj(ipiv)._ptr,strideP,
        hipblasComplex.fromPyobj(B).getElementPtr(),ldb,strideB,
        <int *>hip._util.types.ListOfInt.fromPyobj(info)._ptr,batchCount))
    return (_hipblasCgetrsStridedBatched__retval,)


@cython.embedsignature(True)
def hipblasZgetrsStridedBatched(object handle, object trans, const int n, const int nrhs, object A, const int lda, const long strideA, object ipiv, const long strideP, object B, const int ldb, const long strideB, object info, const int batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        trans (`~.hipblasOperation_t`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        nrhs (`~.int`):
            (undocumented)

        A (`~.hipblasDoubleComplex`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        strideA (`~.int`):
            (undocumented)

        ipiv (`~.hip._util.types.ListOfInt`/`~.object`):
            (undocumented)

        strideP (`~.int`):
            (undocumented)

        B (`~.hipblasDoubleComplex`/`~.object`):
            (undocumented)

        ldb (`~.int`):
            (undocumented)

        strideB (`~.int`):
            (undocumented)

        info (`~.hip._util.types.ListOfInt`/`~.object`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    if not isinstance(trans,_hipblasOperation_t__Base):
        raise TypeError("argument 'trans' must be of type '_hipblasOperation_t__Base'")
    _hipblasZgetrsStridedBatched__retval = hipblasStatus_t(chipblas.hipblasZgetrsStridedBatched(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,trans.value,n,nrhs,
        hipblasDoubleComplex.fromPyobj(A).getElementPtr(),lda,strideA,
        <const int *>hip._util.types.ListOfInt.fromPyobj(ipiv)._ptr,strideP,
        hipblasDoubleComplex.fromPyobj(B).getElementPtr(),ldb,strideB,
        <int *>hip._util.types.ListOfInt.fromPyobj(info)._ptr,batchCount))
    return (_hipblasZgetrsStridedBatched__retval,)


@cython.embedsignature(True)
def hipblasCgetrsStridedBatched_v2(object handle, object trans, const int n, const int nrhs, object A, const int lda, const long strideA, object ipiv, const long strideP, object B, const int ldb, const long strideB, object info, const int batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        trans (`~.hipblasOperation_t`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        nrhs (`~.int`):
            (undocumented)

        A (`~.float2`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        strideA (`~.int`):
            (undocumented)

        ipiv (`~.hip._util.types.ListOfInt`/`~.object`):
            (undocumented)

        strideP (`~.int`):
            (undocumented)

        B (`~.float2`/`~.object`):
            (undocumented)

        ldb (`~.int`):
            (undocumented)

        strideB (`~.int`):
            (undocumented)

        info (`~.hip._util.types.ListOfInt`/`~.object`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    if not isinstance(trans,_hipblasOperation_t__Base):
        raise TypeError("argument 'trans' must be of type '_hipblasOperation_t__Base'")
    _hipblasCgetrsStridedBatched_v2__retval = hipblasStatus_t(chipblas.hipblasCgetrsStridedBatched_v2(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,trans.value,n,nrhs,
        float2.fromPyobj(A).getElementPtr(),lda,strideA,
        <const int *>hip._util.types.ListOfInt.fromPyobj(ipiv)._ptr,strideP,
        float2.fromPyobj(B).getElementPtr(),ldb,strideB,
        <int *>hip._util.types.ListOfInt.fromPyobj(info)._ptr,batchCount))
    return (_hipblasCgetrsStridedBatched_v2__retval,)


@cython.embedsignature(True)
def hipblasZgetrsStridedBatched_v2(object handle, object trans, const int n, const int nrhs, object A, const int lda, const long strideA, object ipiv, const long strideP, object B, const int ldb, const long strideB, object info, const int batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        trans (`~.hipblasOperation_t`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        nrhs (`~.int`):
            (undocumented)

        A (`~.double2`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        strideA (`~.int`):
            (undocumented)

        ipiv (`~.hip._util.types.ListOfInt`/`~.object`):
            (undocumented)

        strideP (`~.int`):
            (undocumented)

        B (`~.double2`/`~.object`):
            (undocumented)

        ldb (`~.int`):
            (undocumented)

        strideB (`~.int`):
            (undocumented)

        info (`~.hip._util.types.ListOfInt`/`~.object`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    if not isinstance(trans,_hipblasOperation_t__Base):
        raise TypeError("argument 'trans' must be of type '_hipblasOperation_t__Base'")
    _hipblasZgetrsStridedBatched_v2__retval = hipblasStatus_t(chipblas.hipblasZgetrsStridedBatched_v2(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,trans.value,n,nrhs,
        double2.fromPyobj(A).getElementPtr(),lda,strideA,
        <const int *>hip._util.types.ListOfInt.fromPyobj(ipiv)._ptr,strideP,
        double2.fromPyobj(B).getElementPtr(),ldb,strideB,
        <int *>hip._util.types.ListOfInt.fromPyobj(info)._ptr,batchCount))
    return (_hipblasZgetrsStridedBatched_v2__retval,)


@cython.embedsignature(True)
def hipblasSgetriBatched(object handle, const int n, object A, const int lda, object ipiv, object C, const int ldc, object info, const int batchCount):
    r"""SOLVER API

    @{

    getriBatched computes the inverse :math:`C_i = A_i^{-1}` of a batch of general n-by-n matrices :math:`A_i`.

    The inverse is computed by solving the linear system

    .. math::

       A_i C_i = I

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`) -- *IN*:
            hipblasHandle_t.

        n (`~.int`) -- *IN*:
            int. n >= 0.

            The number of rows and columns of all matrices A_i in the batch.

        A (`~.hip._util.types.ListOfPointer`/`~.object`) -- *IN*:
            array of pointers to type. Each pointer points to an array on the GPU of dimension lda*n.

            The factors L_i and U_i of the factorization A_i = P_i*L_i*U_i returned by ``hipblasSgetrfBatched`` .

        lda (`~.int`) -- *IN*:
            int. lda >= n.

            Specifies the leading dimension of matrices A_i.

        ipiv (`~.hip._util.types.ListOfInt`/`~.object`) -- *IN*:
            pointer to int. Array on the GPU (the size depends on the value of strideP).

            The pivot indices returned by ``hipblasSgetrfBatched`` .
            ipiv can be passed in as a nullptr, this will assume that getrfBatched was called without partial pivoting.

        C (`~.hip._util.types.ListOfPointer`/`~.object`) -- *OUT*:
            array of pointers to type. Each pointer points to an array on the GPU of dimension ldc*n.

            If info[i] = 0, the inverse of matrices A_i. Otherwise, undefined.

        ldc (`~.int`) -- *IN*:
            int. ldc >= n.

            Specifies the leading dimension of C_i.

        info (`~.hip._util.types.ListOfInt`/`~.object`) -- *OUT*:
            pointer to int. Array of batchCount integers on the GPU.

            If info[i] = 0, successful exit for inversion of A_i.
            If info[i] = j > 0, U_i is singular. U_i[j,j] is the first zero pivot.

        batchCount (`~.int`) -- *IN*:
            int. batchCount >= 0.

            Number of matrices in the batch.
    """
    _hipblasSgetriBatched__retval = hipblasStatus_t(chipblas.hipblasSgetriBatched(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,n,
        <float *const*>hip._util.types.ListOfPointer.fromPyobj(A)._ptr,lda,
        <int *>hip._util.types.ListOfInt.fromPyobj(ipiv)._ptr,
        <float *const*>hip._util.types.ListOfPointer.fromPyobj(C)._ptr,ldc,
        <int *>hip._util.types.ListOfInt.fromPyobj(info)._ptr,batchCount))
    return (_hipblasSgetriBatched__retval,)


@cython.embedsignature(True)
def hipblasDgetriBatched(object handle, const int n, object A, const int lda, object ipiv, object C, const int ldc, object info, const int batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        A (`~.hip._util.types.ListOfPointer`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        ipiv (`~.hip._util.types.ListOfInt`/`~.object`):
            (undocumented)

        C (`~.hip._util.types.ListOfPointer`/`~.object`):
            (undocumented)

        ldc (`~.int`):
            (undocumented)

        info (`~.hip._util.types.ListOfInt`/`~.object`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    _hipblasDgetriBatched__retval = hipblasStatus_t(chipblas.hipblasDgetriBatched(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,n,
        <double *const*>hip._util.types.ListOfPointer.fromPyobj(A)._ptr,lda,
        <int *>hip._util.types.ListOfInt.fromPyobj(ipiv)._ptr,
        <double *const*>hip._util.types.ListOfPointer.fromPyobj(C)._ptr,ldc,
        <int *>hip._util.types.ListOfInt.fromPyobj(info)._ptr,batchCount))
    return (_hipblasDgetriBatched__retval,)


@cython.embedsignature(True)
def hipblasCgetriBatched(object handle, const int n, object A, const int lda, object ipiv, object C, const int ldc, object info, const int batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        A (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        ipiv (`~.hip._util.types.ListOfInt`/`~.object`):
            (undocumented)

        C (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        ldc (`~.int`):
            (undocumented)

        info (`~.hip._util.types.ListOfInt`/`~.object`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    _hipblasCgetriBatched__retval = hipblasStatus_t(chipblas.hipblasCgetriBatched(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,n,
        <chipblas.hipblasComplex *const*>hip._util.types.Pointer.fromPyobj(A)._ptr,lda,
        <int *>hip._util.types.ListOfInt.fromPyobj(ipiv)._ptr,
        <chipblas.hipblasComplex *const*>hip._util.types.Pointer.fromPyobj(C)._ptr,ldc,
        <int *>hip._util.types.ListOfInt.fromPyobj(info)._ptr,batchCount))
    return (_hipblasCgetriBatched__retval,)


@cython.embedsignature(True)
def hipblasZgetriBatched(object handle, const int n, object A, const int lda, object ipiv, object C, const int ldc, object info, const int batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        A (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        ipiv (`~.hip._util.types.ListOfInt`/`~.object`):
            (undocumented)

        C (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        ldc (`~.int`):
            (undocumented)

        info (`~.hip._util.types.ListOfInt`/`~.object`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    _hipblasZgetriBatched__retval = hipblasStatus_t(chipblas.hipblasZgetriBatched(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,n,
        <chipblas.hipblasDoubleComplex *const*>hip._util.types.Pointer.fromPyobj(A)._ptr,lda,
        <int *>hip._util.types.ListOfInt.fromPyobj(ipiv)._ptr,
        <chipblas.hipblasDoubleComplex *const*>hip._util.types.Pointer.fromPyobj(C)._ptr,ldc,
        <int *>hip._util.types.ListOfInt.fromPyobj(info)._ptr,batchCount))
    return (_hipblasZgetriBatched__retval,)


@cython.embedsignature(True)
def hipblasCgetriBatched_v2(object handle, const int n, object A, const int lda, object ipiv, object C, const int ldc, object info, const int batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        A (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        ipiv (`~.hip._util.types.ListOfInt`/`~.object`):
            (undocumented)

        C (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        ldc (`~.int`):
            (undocumented)

        info (`~.hip._util.types.ListOfInt`/`~.object`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    _hipblasCgetriBatched_v2__retval = hipblasStatus_t(chipblas.hipblasCgetriBatched_v2(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,n,
        <chipblas.float2 *const*>hip._util.types.Pointer.fromPyobj(A)._ptr,lda,
        <int *>hip._util.types.ListOfInt.fromPyobj(ipiv)._ptr,
        <chipblas.float2 *const*>hip._util.types.Pointer.fromPyobj(C)._ptr,ldc,
        <int *>hip._util.types.ListOfInt.fromPyobj(info)._ptr,batchCount))
    return (_hipblasCgetriBatched_v2__retval,)


@cython.embedsignature(True)
def hipblasZgetriBatched_v2(object handle, const int n, object A, const int lda, object ipiv, object C, const int ldc, object info, const int batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        A (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        ipiv (`~.hip._util.types.ListOfInt`/`~.object`):
            (undocumented)

        C (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        ldc (`~.int`):
            (undocumented)

        info (`~.hip._util.types.ListOfInt`/`~.object`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    _hipblasZgetriBatched_v2__retval = hipblasStatus_t(chipblas.hipblasZgetriBatched_v2(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,n,
        <chipblas.double2 *const*>hip._util.types.Pointer.fromPyobj(A)._ptr,lda,
        <int *>hip._util.types.ListOfInt.fromPyobj(ipiv)._ptr,
        <chipblas.double2 *const*>hip._util.types.Pointer.fromPyobj(C)._ptr,ldc,
        <int *>hip._util.types.ListOfInt.fromPyobj(info)._ptr,batchCount))
    return (_hipblasZgetriBatched_v2__retval,)


@cython.embedsignature(True)
def hipblasSgels(object handle, object trans, const int m, const int n, const int nrhs, object A, const int lda, object B, const int ldb, object info, object deviceInfo):
    r"""GELS solves an overdetermined (or underdetermined) linear system defined by an m-by-n
    matrix A, and a corresponding matrix B, using the QR factorization computed by ``hipblasSgeqrf``  (or the LQ
    factorization computed by "GELQF").

    @{

    Depending on the value of trans, the problem solved by this function is either of the form

    .. math::

       \begin{array}{cl}
       A X = B & \: \text{not transposed, or}\\
       A' X = B & \: \text{transposed if real, or conjugate transposed if complex}
       \end{array}

    If m >= n (or m < n in the case of transpose/conjugate transpose), the system is overdetermined
    and a least-squares solution approximating X is found by minimizing

    .. math::

       || B - A  X || \quad \text{(or} \: || B - A' X ||\text{)}

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`) -- *IN*:
            hipblasHandle_t.

        trans (`~.hipblasOperation_t`) -- *IN*:
            hipblasOperation_t.

            Specifies the form of the system of equations.

        m (`~.int`) -- *IN*:
            int. m >= 0.

            The number of rows of matrix A.

        n (`~.int`) -- *IN*:
            int. n >= 0.

            The number of columns of matrix A.

        nrhs (`~.int`) -- *IN*:
            int. nrhs >= 0.

            The number of columns of matrices B and X;
            i.e., the columns on the right hand side.

        A (`~.hip._util.types.Pointer`/`~.object`) -- *INOUT*:
            pointer to type. Array on the GPU of dimension lda*n.

            On entry, the matrix A.
            On exit, the QR (or LQ) factorization of A as returned by "GEQRF" (or "GELQF").

        lda (`~.int`) -- *IN*:
            int. lda >= m.

            Specifies the leading dimension of matrix A.

        B (`~.hip._util.types.Pointer`/`~.object`) -- *INOUT*:
            pointer to type. Array on the GPU of dimension ldb*nrhs.

            On entry, the matrix B.
            On exit, when info = 0, B is overwritten by the solution vectors (and the residuals in
            the overdetermined cases) stored as columns.

        ldb (`~.int`) -- *IN*:
            int. ldb >= max(m,n).

            Specifies the leading dimension of matrix B.

        info (`~.hip._util.types.ListOfInt`/`~.object`) -- *OUT*:
            pointer to an int on the host.

            If info = 0, successful exit.
            If info = j < 0, the argument at position -j is invalid.

        deviceInfo (`~.hip._util.types.ListOfInt`/`~.object`) -- *OUT*:
            pointer to int on the GPU.

            If info = 0, successful exit.
            If info = i > 0, the solution could not be computed because input matrix A is
            rank deficient; the i-th diagonal element of its triangular factor is zero.
    """
    if not isinstance(trans,_hipblasOperation_t__Base):
        raise TypeError("argument 'trans' must be of type '_hipblasOperation_t__Base'")
    _hipblasSgels__retval = hipblasStatus_t(chipblas.hipblasSgels(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,trans.value,m,n,nrhs,
        <float *>hip._util.types.Pointer.fromPyobj(A)._ptr,lda,
        <float *>hip._util.types.Pointer.fromPyobj(B)._ptr,ldb,
        <int *>hip._util.types.ListOfInt.fromPyobj(info)._ptr,
        <int *>hip._util.types.ListOfInt.fromPyobj(deviceInfo)._ptr))
    return (_hipblasSgels__retval,)


@cython.embedsignature(True)
def hipblasDgels(object handle, object trans, const int m, const int n, const int nrhs, object A, const int lda, object B, const int ldb, object info, object deviceInfo):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        trans (`~.hipblasOperation_t`):
            (undocumented)

        m (`~.int`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        nrhs (`~.int`):
            (undocumented)

        A (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        B (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        ldb (`~.int`):
            (undocumented)

        info (`~.hip._util.types.ListOfInt`/`~.object`):
            (undocumented)

        deviceInfo (`~.hip._util.types.ListOfInt`/`~.object`):
            (undocumented)
    """
    if not isinstance(trans,_hipblasOperation_t__Base):
        raise TypeError("argument 'trans' must be of type '_hipblasOperation_t__Base'")
    _hipblasDgels__retval = hipblasStatus_t(chipblas.hipblasDgels(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,trans.value,m,n,nrhs,
        <double *>hip._util.types.Pointer.fromPyobj(A)._ptr,lda,
        <double *>hip._util.types.Pointer.fromPyobj(B)._ptr,ldb,
        <int *>hip._util.types.ListOfInt.fromPyobj(info)._ptr,
        <int *>hip._util.types.ListOfInt.fromPyobj(deviceInfo)._ptr))
    return (_hipblasDgels__retval,)


@cython.embedsignature(True)
def hipblasCgels(object handle, object trans, const int m, const int n, const int nrhs, object A, const int lda, object B, const int ldb, object info, object deviceInfo):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        trans (`~.hipblasOperation_t`):
            (undocumented)

        m (`~.int`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        nrhs (`~.int`):
            (undocumented)

        A (`~.hipblasComplex`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        B (`~.hipblasComplex`/`~.object`):
            (undocumented)

        ldb (`~.int`):
            (undocumented)

        info (`~.hip._util.types.ListOfInt`/`~.object`):
            (undocumented)

        deviceInfo (`~.hip._util.types.ListOfInt`/`~.object`):
            (undocumented)
    """
    if not isinstance(trans,_hipblasOperation_t__Base):
        raise TypeError("argument 'trans' must be of type '_hipblasOperation_t__Base'")
    _hipblasCgels__retval = hipblasStatus_t(chipblas.hipblasCgels(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,trans.value,m,n,nrhs,
        hipblasComplex.fromPyobj(A).getElementPtr(),lda,
        hipblasComplex.fromPyobj(B).getElementPtr(),ldb,
        <int *>hip._util.types.ListOfInt.fromPyobj(info)._ptr,
        <int *>hip._util.types.ListOfInt.fromPyobj(deviceInfo)._ptr))
    return (_hipblasCgels__retval,)


@cython.embedsignature(True)
def hipblasZgels(object handle, object trans, const int m, const int n, const int nrhs, object A, const int lda, object B, const int ldb, object info, object deviceInfo):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        trans (`~.hipblasOperation_t`):
            (undocumented)

        m (`~.int`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        nrhs (`~.int`):
            (undocumented)

        A (`~.hipblasDoubleComplex`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        B (`~.hipblasDoubleComplex`/`~.object`):
            (undocumented)

        ldb (`~.int`):
            (undocumented)

        info (`~.hip._util.types.ListOfInt`/`~.object`):
            (undocumented)

        deviceInfo (`~.hip._util.types.ListOfInt`/`~.object`):
            (undocumented)
    """
    if not isinstance(trans,_hipblasOperation_t__Base):
        raise TypeError("argument 'trans' must be of type '_hipblasOperation_t__Base'")
    _hipblasZgels__retval = hipblasStatus_t(chipblas.hipblasZgels(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,trans.value,m,n,nrhs,
        hipblasDoubleComplex.fromPyobj(A).getElementPtr(),lda,
        hipblasDoubleComplex.fromPyobj(B).getElementPtr(),ldb,
        <int *>hip._util.types.ListOfInt.fromPyobj(info)._ptr,
        <int *>hip._util.types.ListOfInt.fromPyobj(deviceInfo)._ptr))
    return (_hipblasZgels__retval,)


@cython.embedsignature(True)
def hipblasCgels_v2(object handle, object trans, const int m, const int n, const int nrhs, object A, const int lda, object B, const int ldb, object info, object deviceInfo):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        trans (`~.hipblasOperation_t`):
            (undocumented)

        m (`~.int`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        nrhs (`~.int`):
            (undocumented)

        A (`~.float2`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        B (`~.float2`/`~.object`):
            (undocumented)

        ldb (`~.int`):
            (undocumented)

        info (`~.hip._util.types.ListOfInt`/`~.object`):
            (undocumented)

        deviceInfo (`~.hip._util.types.ListOfInt`/`~.object`):
            (undocumented)
    """
    if not isinstance(trans,_hipblasOperation_t__Base):
        raise TypeError("argument 'trans' must be of type '_hipblasOperation_t__Base'")
    _hipblasCgels_v2__retval = hipblasStatus_t(chipblas.hipblasCgels_v2(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,trans.value,m,n,nrhs,
        float2.fromPyobj(A).getElementPtr(),lda,
        float2.fromPyobj(B).getElementPtr(),ldb,
        <int *>hip._util.types.ListOfInt.fromPyobj(info)._ptr,
        <int *>hip._util.types.ListOfInt.fromPyobj(deviceInfo)._ptr))
    return (_hipblasCgels_v2__retval,)


@cython.embedsignature(True)
def hipblasZgels_v2(object handle, object trans, const int m, const int n, const int nrhs, object A, const int lda, object B, const int ldb, object info, object deviceInfo):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        trans (`~.hipblasOperation_t`):
            (undocumented)

        m (`~.int`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        nrhs (`~.int`):
            (undocumented)

        A (`~.double2`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        B (`~.double2`/`~.object`):
            (undocumented)

        ldb (`~.int`):
            (undocumented)

        info (`~.hip._util.types.ListOfInt`/`~.object`):
            (undocumented)

        deviceInfo (`~.hip._util.types.ListOfInt`/`~.object`):
            (undocumented)
    """
    if not isinstance(trans,_hipblasOperation_t__Base):
        raise TypeError("argument 'trans' must be of type '_hipblasOperation_t__Base'")
    _hipblasZgels_v2__retval = hipblasStatus_t(chipblas.hipblasZgels_v2(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,trans.value,m,n,nrhs,
        double2.fromPyobj(A).getElementPtr(),lda,
        double2.fromPyobj(B).getElementPtr(),ldb,
        <int *>hip._util.types.ListOfInt.fromPyobj(info)._ptr,
        <int *>hip._util.types.ListOfInt.fromPyobj(deviceInfo)._ptr))
    return (_hipblasZgels_v2__retval,)


@cython.embedsignature(True)
def hipblasSgelsBatched(object handle, object trans, const int m, const int n, const int nrhs, object A, const int lda, object B, const int ldb, object info, object deviceInfo, const int batchCount):
    r"""gelsBatched solves a batch of overdetermined (or underdetermined) linear systems
    defined by a set of m-by-n matrices :math:`A_j`, and corresponding matrices :math:`B_j`, using the
    QR factorizations computed by "GEQRF_BATCHED" (or the LQ factorizations computed by "GELQF_BATCHED").

    @{

    For each instance in the batch, depending on the value of trans, the problem solved by this function is either of the form

    .. math::

       \begin{array}{cl}
       A_j X_j = B_j & \: \text{not transposed, or}\\
       A_j' X_j = B_j & \: \text{transposed if real, or conjugate transposed if complex}
       \end{array}

    If m >= n (or m < n in the case of transpose/conjugate transpose), the system is overdetermined
    and a least-squares solution approximating X_j is found by minimizing

    .. math::

       || B_j - A_j  X_j || \quad \text{(or} \: || B_j - A_j' X_j ||\text{)}

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`) -- *IN*:
            hipblasHandle_t.

        trans (`~.hipblasOperation_t`) -- *IN*:
            hipblasOperation_t.

            Specifies the form of the system of equations.

        m (`~.int`) -- *IN*:
            int. m >= 0.

            The number of rows of all matrices A_j in the batch.

        n (`~.int`) -- *IN*:
            int. n >= 0.

            The number of columns of all matrices A_j in the batch.

        nrhs (`~.int`) -- *IN*:
            int. nrhs >= 0.

            The number of columns of all matrices B_j and X_j in the batch;
            i.e., the columns on the right hand side.

        A (`~.hip._util.types.ListOfPointer`/`~.object`) -- *INOUT*:
            array of pointer to type. Each pointer points to an array on the GPU of dimension lda*n.

            On entry, the matrices A_j.
            On exit, the QR (or LQ) factorizations of A_j as returned by "GEQRF_BATCHED"
            (or "GELQF_BATCHED").

        lda (`~.int`) -- *IN*:
            int. lda >= m.

            Specifies the leading dimension of matrices A_j.

        B (`~.hip._util.types.ListOfPointer`/`~.object`) -- *INOUT*:
            array of pointer to type. Each pointer points to an array on the GPU of dimension ldb*nrhs.

            On entry, the matrices B_j.
            On exit, when info[j] = 0, B_j is overwritten by the solution vectors (and the residuals in
            the overdetermined cases) stored as columns.

        ldb (`~.int`) -- *IN*:
            int. ldb >= max(m,n).

            Specifies the leading dimension of matrices B_j.

        info (`~.hip._util.types.ListOfInt`/`~.object`) -- *OUT*:
            pointer to an int on the host.

            If info = 0, successful exit.
            If info = j < 0, the argument at position -j is invalid.

        deviceInfo (`~.hip._util.types.ListOfInt`/`~.object`) -- *OUT*:
            pointer to int. Array of batchCount integers on the GPU.

            If deviceInfo[j] = 0, successful exit for solution of A_j.
            If deviceInfo[j] = i > 0, the solution of A_j could not be computed because input
            matrix A_j is rank deficient; the i-th diagonal element of its triangular factor is zero.

        batchCount (`~.int`) -- *IN*:
            int. batchCount >= 0.

            Number of matrices in the batch.
    """
    if not isinstance(trans,_hipblasOperation_t__Base):
        raise TypeError("argument 'trans' must be of type '_hipblasOperation_t__Base'")
    _hipblasSgelsBatched__retval = hipblasStatus_t(chipblas.hipblasSgelsBatched(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,trans.value,m,n,nrhs,
        <float *const*>hip._util.types.ListOfPointer.fromPyobj(A)._ptr,lda,
        <float *const*>hip._util.types.ListOfPointer.fromPyobj(B)._ptr,ldb,
        <int *>hip._util.types.ListOfInt.fromPyobj(info)._ptr,
        <int *>hip._util.types.ListOfInt.fromPyobj(deviceInfo)._ptr,batchCount))
    return (_hipblasSgelsBatched__retval,)


@cython.embedsignature(True)
def hipblasDgelsBatched(object handle, object trans, const int m, const int n, const int nrhs, object A, const int lda, object B, const int ldb, object info, object deviceInfo, const int batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        trans (`~.hipblasOperation_t`):
            (undocumented)

        m (`~.int`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        nrhs (`~.int`):
            (undocumented)

        A (`~.hip._util.types.ListOfPointer`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        B (`~.hip._util.types.ListOfPointer`/`~.object`):
            (undocumented)

        ldb (`~.int`):
            (undocumented)

        info (`~.hip._util.types.ListOfInt`/`~.object`):
            (undocumented)

        deviceInfo (`~.hip._util.types.ListOfInt`/`~.object`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    if not isinstance(trans,_hipblasOperation_t__Base):
        raise TypeError("argument 'trans' must be of type '_hipblasOperation_t__Base'")
    _hipblasDgelsBatched__retval = hipblasStatus_t(chipblas.hipblasDgelsBatched(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,trans.value,m,n,nrhs,
        <double *const*>hip._util.types.ListOfPointer.fromPyobj(A)._ptr,lda,
        <double *const*>hip._util.types.ListOfPointer.fromPyobj(B)._ptr,ldb,
        <int *>hip._util.types.ListOfInt.fromPyobj(info)._ptr,
        <int *>hip._util.types.ListOfInt.fromPyobj(deviceInfo)._ptr,batchCount))
    return (_hipblasDgelsBatched__retval,)


@cython.embedsignature(True)
def hipblasCgelsBatched(object handle, object trans, const int m, const int n, const int nrhs, object A, const int lda, object B, const int ldb, object info, object deviceInfo, const int batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        trans (`~.hipblasOperation_t`):
            (undocumented)

        m (`~.int`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        nrhs (`~.int`):
            (undocumented)

        A (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        B (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        ldb (`~.int`):
            (undocumented)

        info (`~.hip._util.types.ListOfInt`/`~.object`):
            (undocumented)

        deviceInfo (`~.hip._util.types.ListOfInt`/`~.object`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    if not isinstance(trans,_hipblasOperation_t__Base):
        raise TypeError("argument 'trans' must be of type '_hipblasOperation_t__Base'")
    _hipblasCgelsBatched__retval = hipblasStatus_t(chipblas.hipblasCgelsBatched(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,trans.value,m,n,nrhs,
        <chipblas.hipblasComplex *const*>hip._util.types.Pointer.fromPyobj(A)._ptr,lda,
        <chipblas.hipblasComplex *const*>hip._util.types.Pointer.fromPyobj(B)._ptr,ldb,
        <int *>hip._util.types.ListOfInt.fromPyobj(info)._ptr,
        <int *>hip._util.types.ListOfInt.fromPyobj(deviceInfo)._ptr,batchCount))
    return (_hipblasCgelsBatched__retval,)


@cython.embedsignature(True)
def hipblasZgelsBatched(object handle, object trans, const int m, const int n, const int nrhs, object A, const int lda, object B, const int ldb, object info, object deviceInfo, const int batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        trans (`~.hipblasOperation_t`):
            (undocumented)

        m (`~.int`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        nrhs (`~.int`):
            (undocumented)

        A (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        B (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        ldb (`~.int`):
            (undocumented)

        info (`~.hip._util.types.ListOfInt`/`~.object`):
            (undocumented)

        deviceInfo (`~.hip._util.types.ListOfInt`/`~.object`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    if not isinstance(trans,_hipblasOperation_t__Base):
        raise TypeError("argument 'trans' must be of type '_hipblasOperation_t__Base'")
    _hipblasZgelsBatched__retval = hipblasStatus_t(chipblas.hipblasZgelsBatched(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,trans.value,m,n,nrhs,
        <chipblas.hipblasDoubleComplex *const*>hip._util.types.Pointer.fromPyobj(A)._ptr,lda,
        <chipblas.hipblasDoubleComplex *const*>hip._util.types.Pointer.fromPyobj(B)._ptr,ldb,
        <int *>hip._util.types.ListOfInt.fromPyobj(info)._ptr,
        <int *>hip._util.types.ListOfInt.fromPyobj(deviceInfo)._ptr,batchCount))
    return (_hipblasZgelsBatched__retval,)


@cython.embedsignature(True)
def hipblasCgelsBatched_v2(object handle, object trans, const int m, const int n, const int nrhs, object A, const int lda, object B, const int ldb, object info, object deviceInfo, const int batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        trans (`~.hipblasOperation_t`):
            (undocumented)

        m (`~.int`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        nrhs (`~.int`):
            (undocumented)

        A (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        B (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        ldb (`~.int`):
            (undocumented)

        info (`~.hip._util.types.ListOfInt`/`~.object`):
            (undocumented)

        deviceInfo (`~.hip._util.types.ListOfInt`/`~.object`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    if not isinstance(trans,_hipblasOperation_t__Base):
        raise TypeError("argument 'trans' must be of type '_hipblasOperation_t__Base'")
    _hipblasCgelsBatched_v2__retval = hipblasStatus_t(chipblas.hipblasCgelsBatched_v2(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,trans.value,m,n,nrhs,
        <chipblas.float2 *const*>hip._util.types.Pointer.fromPyobj(A)._ptr,lda,
        <chipblas.float2 *const*>hip._util.types.Pointer.fromPyobj(B)._ptr,ldb,
        <int *>hip._util.types.ListOfInt.fromPyobj(info)._ptr,
        <int *>hip._util.types.ListOfInt.fromPyobj(deviceInfo)._ptr,batchCount))
    return (_hipblasCgelsBatched_v2__retval,)


@cython.embedsignature(True)
def hipblasZgelsBatched_v2(object handle, object trans, const int m, const int n, const int nrhs, object A, const int lda, object B, const int ldb, object info, object deviceInfo, const int batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        trans (`~.hipblasOperation_t`):
            (undocumented)

        m (`~.int`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        nrhs (`~.int`):
            (undocumented)

        A (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        B (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        ldb (`~.int`):
            (undocumented)

        info (`~.hip._util.types.ListOfInt`/`~.object`):
            (undocumented)

        deviceInfo (`~.hip._util.types.ListOfInt`/`~.object`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    if not isinstance(trans,_hipblasOperation_t__Base):
        raise TypeError("argument 'trans' must be of type '_hipblasOperation_t__Base'")
    _hipblasZgelsBatched_v2__retval = hipblasStatus_t(chipblas.hipblasZgelsBatched_v2(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,trans.value,m,n,nrhs,
        <chipblas.double2 *const*>hip._util.types.Pointer.fromPyobj(A)._ptr,lda,
        <chipblas.double2 *const*>hip._util.types.Pointer.fromPyobj(B)._ptr,ldb,
        <int *>hip._util.types.ListOfInt.fromPyobj(info)._ptr,
        <int *>hip._util.types.ListOfInt.fromPyobj(deviceInfo)._ptr,batchCount))
    return (_hipblasZgelsBatched_v2__retval,)


@cython.embedsignature(True)
def hipblasSgelsStridedBatched(object handle, object trans, const int m, const int n, const int nrhs, object A, const int lda, const long strideA, object B, const int ldb, const long strideB, object info, object deviceInfo, const int batchCount):
    r"""gelsStridedBatched solves a batch of overdetermined (or underdetermined) linear
    systems defined by a set of m-by-n matrices :math:`A_j`, and corresponding matrices :math:`B_j`,
    using the QR factorizations computed by "GEQRF_STRIDED_BATCHED"
    (or the LQ factorizations computed by "GELQF_STRIDED_BATCHED").

    @{

    For each instance in the batch, depending on the value of trans, the problem solved by this function is either of the form

    .. math::

       \begin{array}{cl}
       A_j X_j = B_j & \: \text{not transposed, or}\\
       A_j' X_j = B_j & \: \text{transposed if real, or conjugate transposed if complex}
       \end{array}

    If m >= n (or m < n in the case of transpose/conjugate transpose), the system is overdetermined
    and a least-squares solution approximating X_j is found by minimizing

    .. math::

       || B_j - A_j  X_j || \quad \text{(or} \: || B_j - A_j' X_j ||\text{)}

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`) -- *IN*:
            hipblasHandle_t.

        trans (`~.hipblasOperation_t`) -- *IN*:
            hipblasOperation_t.

            Specifies the form of the system of equations.

        m (`~.int`) -- *IN*:
            int. m >= 0.

            The number of rows of all matrices A_j in the batch.

        n (`~.int`) -- *IN*:
            int. n >= 0.

            The number of columns of all matrices A_j in the batch.

        nrhs (`~.int`) -- *IN*:
            int. nrhs >= 0.

            The number of columns of all matrices B_j and X_j in the batch;
            i.e., the columns on the right hand side.

        A (`~.hip._util.types.Pointer`/`~.object`) -- *INOUT*:
            pointer to type. Array on the GPU (the size depends on the value of strideA).

            On entry, the matrices A_j.
            On exit, the QR (or LQ) factorizations of A_j as returned by "GEQRF_STRIDED_BATCHED"
            (or "GELQF_STRIDED_BATCHED").

        lda (`~.int`) -- *IN*:
            int. lda >= m.

            Specifies the leading dimension of matrices A_j.

        strideA (`~.int`) -- *IN*:
            hipblasStride.

            Stride from the start of one matrix A_j to the next one A_(j+1).
            There is no restriction for the value of strideA. Normal use case is strideA >= lda*n

        B (`~.hip._util.types.Pointer`/`~.object`) -- *INOUT*:
            pointer to type. Array on the GPU (the size depends on the value of strideB).

            On entry, the matrices B_j.
            On exit, when info[j] = 0, each B_j is overwritten by the solution vectors (and the residuals in
            the overdetermined cases) stored as columns.

        ldb (`~.int`) -- *IN*:
            int. ldb >= max(m,n).

            Specifies the leading dimension of matrices B_j.

        strideB (`~.int`) -- *IN*:
            hipblasStride.

            Stride from the start of one matrix B_j to the next one B_(j+1).
            There is no restriction for the value of strideB. Normal use case is strideB >= ldb*nrhs

        info (`~.hip._util.types.ListOfInt`/`~.object`) -- *OUT*:
            pointer to an int on the host.

            If info = 0, successful exit.
            If info = j < 0, the argument at position -j is invalid.

        deviceInfo (`~.hip._util.types.ListOfInt`/`~.object`) -- *OUT*:
            pointer to int. Array of batchCount integers on the GPU.

            If deviceInfo[j] = 0, successful exit for solution of A_j.
            If deviceInfo[j] = i > 0, the solution of A_j could not be computed because input
            matrix A_j is rank deficient; the i-th diagonal element of its triangular factor is zero.

        batchCount (`~.int`) -- *IN*:
            int. batchCount >= 0.

            Number of matrices in the batch.
    """
    if not isinstance(trans,_hipblasOperation_t__Base):
        raise TypeError("argument 'trans' must be of type '_hipblasOperation_t__Base'")
    _hipblasSgelsStridedBatched__retval = hipblasStatus_t(chipblas.hipblasSgelsStridedBatched(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,trans.value,m,n,nrhs,
        <float *>hip._util.types.Pointer.fromPyobj(A)._ptr,lda,strideA,
        <float *>hip._util.types.Pointer.fromPyobj(B)._ptr,ldb,strideB,
        <int *>hip._util.types.ListOfInt.fromPyobj(info)._ptr,
        <int *>hip._util.types.ListOfInt.fromPyobj(deviceInfo)._ptr,batchCount))
    return (_hipblasSgelsStridedBatched__retval,)


@cython.embedsignature(True)
def hipblasDgelsStridedBatched(object handle, object trans, const int m, const int n, const int nrhs, object A, const int lda, const long strideA, object B, const int ldb, const long strideB, object info, object deviceInfo, const int batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        trans (`~.hipblasOperation_t`):
            (undocumented)

        m (`~.int`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        nrhs (`~.int`):
            (undocumented)

        A (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        strideA (`~.int`):
            (undocumented)

        B (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        ldb (`~.int`):
            (undocumented)

        strideB (`~.int`):
            (undocumented)

        info (`~.hip._util.types.ListOfInt`/`~.object`):
            (undocumented)

        deviceInfo (`~.hip._util.types.ListOfInt`/`~.object`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    if not isinstance(trans,_hipblasOperation_t__Base):
        raise TypeError("argument 'trans' must be of type '_hipblasOperation_t__Base'")
    _hipblasDgelsStridedBatched__retval = hipblasStatus_t(chipblas.hipblasDgelsStridedBatched(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,trans.value,m,n,nrhs,
        <double *>hip._util.types.Pointer.fromPyobj(A)._ptr,lda,strideA,
        <double *>hip._util.types.Pointer.fromPyobj(B)._ptr,ldb,strideB,
        <int *>hip._util.types.ListOfInt.fromPyobj(info)._ptr,
        <int *>hip._util.types.ListOfInt.fromPyobj(deviceInfo)._ptr,batchCount))
    return (_hipblasDgelsStridedBatched__retval,)


@cython.embedsignature(True)
def hipblasCgelsStridedBatched(object handle, object trans, const int m, const int n, const int nrhs, object A, const int lda, const long strideA, object B, const int ldb, const long strideB, object info, object deviceInfo, const int batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        trans (`~.hipblasOperation_t`):
            (undocumented)

        m (`~.int`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        nrhs (`~.int`):
            (undocumented)

        A (`~.hipblasComplex`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        strideA (`~.int`):
            (undocumented)

        B (`~.hipblasComplex`/`~.object`):
            (undocumented)

        ldb (`~.int`):
            (undocumented)

        strideB (`~.int`):
            (undocumented)

        info (`~.hip._util.types.ListOfInt`/`~.object`):
            (undocumented)

        deviceInfo (`~.hip._util.types.ListOfInt`/`~.object`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    if not isinstance(trans,_hipblasOperation_t__Base):
        raise TypeError("argument 'trans' must be of type '_hipblasOperation_t__Base'")
    _hipblasCgelsStridedBatched__retval = hipblasStatus_t(chipblas.hipblasCgelsStridedBatched(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,trans.value,m,n,nrhs,
        hipblasComplex.fromPyobj(A).getElementPtr(),lda,strideA,
        hipblasComplex.fromPyobj(B).getElementPtr(),ldb,strideB,
        <int *>hip._util.types.ListOfInt.fromPyobj(info)._ptr,
        <int *>hip._util.types.ListOfInt.fromPyobj(deviceInfo)._ptr,batchCount))
    return (_hipblasCgelsStridedBatched__retval,)


@cython.embedsignature(True)
def hipblasZgelsStridedBatched(object handle, object trans, const int m, const int n, const int nrhs, object A, const int lda, const long strideA, object B, const int ldb, const long strideB, object info, object deviceInfo, const int batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        trans (`~.hipblasOperation_t`):
            (undocumented)

        m (`~.int`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        nrhs (`~.int`):
            (undocumented)

        A (`~.hipblasDoubleComplex`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        strideA (`~.int`):
            (undocumented)

        B (`~.hipblasDoubleComplex`/`~.object`):
            (undocumented)

        ldb (`~.int`):
            (undocumented)

        strideB (`~.int`):
            (undocumented)

        info (`~.hip._util.types.ListOfInt`/`~.object`):
            (undocumented)

        deviceInfo (`~.hip._util.types.ListOfInt`/`~.object`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    if not isinstance(trans,_hipblasOperation_t__Base):
        raise TypeError("argument 'trans' must be of type '_hipblasOperation_t__Base'")
    _hipblasZgelsStridedBatched__retval = hipblasStatus_t(chipblas.hipblasZgelsStridedBatched(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,trans.value,m,n,nrhs,
        hipblasDoubleComplex.fromPyobj(A).getElementPtr(),lda,strideA,
        hipblasDoubleComplex.fromPyobj(B).getElementPtr(),ldb,strideB,
        <int *>hip._util.types.ListOfInt.fromPyobj(info)._ptr,
        <int *>hip._util.types.ListOfInt.fromPyobj(deviceInfo)._ptr,batchCount))
    return (_hipblasZgelsStridedBatched__retval,)


@cython.embedsignature(True)
def hipblasCgelsStridedBatched_v2(object handle, object trans, const int m, const int n, const int nrhs, object A, const int lda, const long strideA, object B, const int ldb, const long strideB, object info, object deviceInfo, const int batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        trans (`~.hipblasOperation_t`):
            (undocumented)

        m (`~.int`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        nrhs (`~.int`):
            (undocumented)

        A (`~.float2`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        strideA (`~.int`):
            (undocumented)

        B (`~.float2`/`~.object`):
            (undocumented)

        ldb (`~.int`):
            (undocumented)

        strideB (`~.int`):
            (undocumented)

        info (`~.hip._util.types.ListOfInt`/`~.object`):
            (undocumented)

        deviceInfo (`~.hip._util.types.ListOfInt`/`~.object`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    if not isinstance(trans,_hipblasOperation_t__Base):
        raise TypeError("argument 'trans' must be of type '_hipblasOperation_t__Base'")
    _hipblasCgelsStridedBatched_v2__retval = hipblasStatus_t(chipblas.hipblasCgelsStridedBatched_v2(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,trans.value,m,n,nrhs,
        float2.fromPyobj(A).getElementPtr(),lda,strideA,
        float2.fromPyobj(B).getElementPtr(),ldb,strideB,
        <int *>hip._util.types.ListOfInt.fromPyobj(info)._ptr,
        <int *>hip._util.types.ListOfInt.fromPyobj(deviceInfo)._ptr,batchCount))
    return (_hipblasCgelsStridedBatched_v2__retval,)


@cython.embedsignature(True)
def hipblasZgelsStridedBatched_v2(object handle, object trans, const int m, const int n, const int nrhs, object A, const int lda, const long strideA, object B, const int ldb, const long strideB, object info, object deviceInfo, const int batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        trans (`~.hipblasOperation_t`):
            (undocumented)

        m (`~.int`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        nrhs (`~.int`):
            (undocumented)

        A (`~.double2`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        strideA (`~.int`):
            (undocumented)

        B (`~.double2`/`~.object`):
            (undocumented)

        ldb (`~.int`):
            (undocumented)

        strideB (`~.int`):
            (undocumented)

        info (`~.hip._util.types.ListOfInt`/`~.object`):
            (undocumented)

        deviceInfo (`~.hip._util.types.ListOfInt`/`~.object`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    if not isinstance(trans,_hipblasOperation_t__Base):
        raise TypeError("argument 'trans' must be of type '_hipblasOperation_t__Base'")
    _hipblasZgelsStridedBatched_v2__retval = hipblasStatus_t(chipblas.hipblasZgelsStridedBatched_v2(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,trans.value,m,n,nrhs,
        double2.fromPyobj(A).getElementPtr(),lda,strideA,
        double2.fromPyobj(B).getElementPtr(),ldb,strideB,
        <int *>hip._util.types.ListOfInt.fromPyobj(info)._ptr,
        <int *>hip._util.types.ListOfInt.fromPyobj(deviceInfo)._ptr,batchCount))
    return (_hipblasZgelsStridedBatched_v2__retval,)


@cython.embedsignature(True)
def hipblasSgeqrf(object handle, const int m, const int n, object A, const int lda, object ipiv, object info):
    r"""SOLVER API

    @{

    geqrf computes a QR factorization of a general m-by-n matrix A.

    The factorization has the form

    .. math::

       A = Q\left[\begin{array}{c}
       R\\
       0
       \end{array}\right]

    where R is upper triangular (upper trapezoidal if m < n), and Q is
    a m-by-m orthogonal/unitary matrix represented as the product of Householder matrices

    .. math::

       Q = H_1H_2\cdots H_k, \quad \text{with} \: k = \text{min}(m,n)

    Each Householder matrix :math:`H_i` is given by

    .. math::

       H_i = I - \text{ipiv}[i] \cdot v_i v_i'

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`) -- *IN*:
            hipblasHandle_t.

        m (`~.int`) -- *IN*:
            int. m >= 0.

            The number of rows of the matrix A.

        n (`~.int`) -- *IN*:
            int. n >= 0.

            The number of columns of the matrix A.

        A (`~.hip._util.types.Pointer`/`~.object`) -- *INOUT*:
            pointer to type. Array on the GPU of dimension lda*n.

            On entry, the m-by-n matrix to be factored.
            On exit, the elements on and above the diagonal contain the
            factor R; the elements below the diagonal are the last m - i elements
            of Householder vector v_i.

        lda (`~.int`) -- *IN*:
            int. lda >= m.

            Specifies the leading dimension of A.

        ipiv (`~.hip._util.types.Pointer`/`~.object`) -- *OUT*:
            pointer to type. Array on the GPU of dimension min(m,n).

            The Householder scalars.

        info (`~.hip._util.types.ListOfInt`/`~.object`) -- *OUT*:
            pointer to a int on the host.

            If info = 0, successful exit.
            If info = j < 0, the argument at position -j is invalid.
    """
    _hipblasSgeqrf__retval = hipblasStatus_t(chipblas.hipblasSgeqrf(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,m,n,
        <float *>hip._util.types.Pointer.fromPyobj(A)._ptr,lda,
        <float *>hip._util.types.Pointer.fromPyobj(ipiv)._ptr,
        <int *>hip._util.types.ListOfInt.fromPyobj(info)._ptr))
    return (_hipblasSgeqrf__retval,)


@cython.embedsignature(True)
def hipblasDgeqrf(object handle, const int m, const int n, object A, const int lda, object ipiv, object info):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        m (`~.int`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        A (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        ipiv (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        info (`~.hip._util.types.ListOfInt`/`~.object`):
            (undocumented)
    """
    _hipblasDgeqrf__retval = hipblasStatus_t(chipblas.hipblasDgeqrf(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,m,n,
        <double *>hip._util.types.Pointer.fromPyobj(A)._ptr,lda,
        <double *>hip._util.types.Pointer.fromPyobj(ipiv)._ptr,
        <int *>hip._util.types.ListOfInt.fromPyobj(info)._ptr))
    return (_hipblasDgeqrf__retval,)


@cython.embedsignature(True)
def hipblasCgeqrf(object handle, const int m, const int n, object A, const int lda, object ipiv, object info):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        m (`~.int`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        A (`~.hipblasComplex`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        ipiv (`~.hipblasComplex`/`~.object`):
            (undocumented)

        info (`~.hip._util.types.ListOfInt`/`~.object`):
            (undocumented)
    """
    _hipblasCgeqrf__retval = hipblasStatus_t(chipblas.hipblasCgeqrf(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,m,n,
        hipblasComplex.fromPyobj(A).getElementPtr(),lda,
        hipblasComplex.fromPyobj(ipiv).getElementPtr(),
        <int *>hip._util.types.ListOfInt.fromPyobj(info)._ptr))
    return (_hipblasCgeqrf__retval,)


@cython.embedsignature(True)
def hipblasZgeqrf(object handle, const int m, const int n, object A, const int lda, object ipiv, object info):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        m (`~.int`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        A (`~.hipblasDoubleComplex`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        ipiv (`~.hipblasDoubleComplex`/`~.object`):
            (undocumented)

        info (`~.hip._util.types.ListOfInt`/`~.object`):
            (undocumented)
    """
    _hipblasZgeqrf__retval = hipblasStatus_t(chipblas.hipblasZgeqrf(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,m,n,
        hipblasDoubleComplex.fromPyobj(A).getElementPtr(),lda,
        hipblasDoubleComplex.fromPyobj(ipiv).getElementPtr(),
        <int *>hip._util.types.ListOfInt.fromPyobj(info)._ptr))
    return (_hipblasZgeqrf__retval,)


@cython.embedsignature(True)
def hipblasCgeqrf_v2(object handle, const int m, const int n, object A, const int lda, object ipiv, object info):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        m (`~.int`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        A (`~.float2`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        ipiv (`~.float2`/`~.object`):
            (undocumented)

        info (`~.hip._util.types.ListOfInt`/`~.object`):
            (undocumented)
    """
    _hipblasCgeqrf_v2__retval = hipblasStatus_t(chipblas.hipblasCgeqrf_v2(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,m,n,
        float2.fromPyobj(A).getElementPtr(),lda,
        float2.fromPyobj(ipiv).getElementPtr(),
        <int *>hip._util.types.ListOfInt.fromPyobj(info)._ptr))
    return (_hipblasCgeqrf_v2__retval,)


@cython.embedsignature(True)
def hipblasZgeqrf_v2(object handle, const int m, const int n, object A, const int lda, object ipiv, object info):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        m (`~.int`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        A (`~.double2`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        ipiv (`~.double2`/`~.object`):
            (undocumented)

        info (`~.hip._util.types.ListOfInt`/`~.object`):
            (undocumented)
    """
    _hipblasZgeqrf_v2__retval = hipblasStatus_t(chipblas.hipblasZgeqrf_v2(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,m,n,
        double2.fromPyobj(A).getElementPtr(),lda,
        double2.fromPyobj(ipiv).getElementPtr(),
        <int *>hip._util.types.ListOfInt.fromPyobj(info)._ptr))
    return (_hipblasZgeqrf_v2__retval,)


@cython.embedsignature(True)
def hipblasSgeqrfBatched(object handle, const int m, const int n, object A, const int lda, object ipiv, object info, const int batchCount):
    r"""SOLVER API

    @{

    geqrfBatched computes the QR factorization of a batch of general
    m-by-n matrices.

    The factorization of matrix :math:`A_i` in the batch has the form

    .. math::

       A_i = Q_i\left[\begin{array}{c}
       R_i\\
       0
       \end{array}\right]

    where :math:`R_i` is upper triangular (upper trapezoidal if m < n), and :math:`Q_i` is
    a m-by-m orthogonal/unitary matrix represented as the product of Householder matrices

    .. math::

       Q_i = H_{i_1}H_{i_2}\cdots H_{i_k}, \quad \text{with} \: k = \text{min}(m,n)

    Each Householder matrix :math:`H_{i_j}` is given by

    .. math::

       H_{i_j} = I - \text{ipiv}_i[j] \cdot v_{i_j} v_{i_j}'

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`) -- *IN*:
            hipblasHandle_t.

        m (`~.int`) -- *IN*:
            int. m >= 0.

            The number of rows of all the matrices A_i in the batch.

        n (`~.int`) -- *IN*:
            int. n >= 0.

            The number of columns of all the matrices A_i in the batch.

        A (`~.hip._util.types.ListOfPointer`/`~.object`) -- *INOUT*:
            Array of pointers to type. Each pointer points to an array on the GPU of dimension lda*n.

            On entry, the m-by-n matrices A_i to be factored.
            On exit, the elements on and above the diagonal contain the
            factor R_i. The elements below the diagonal are the last m - j elements
            of Householder vector v_(i_j).

        lda (`~.int`) -- *IN*:
            int. lda >= m.

            Specifies the leading dimension of matrices A_i.

        ipiv (`~.hip._util.types.Pointer`/`~.object`) -- *OUT*:
            array of pointers to type. Each pointer points to an array on the GPU
            of dimension min(m, n).

            Contains the vectors ipiv_i of corresponding Householder scalars.

        info (`~.hip._util.types.ListOfInt`/`~.object`) -- *OUT*:
            pointer to a int on the host.

            If info = 0, successful exit.
            If info = j < 0, the argument at position -j is invalid.

        batchCount (`~.int`) -- *IN*:
            int. batchCount >= 0.

            Number of matrices in the batch.
    """
    _hipblasSgeqrfBatched__retval = hipblasStatus_t(chipblas.hipblasSgeqrfBatched(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,m,n,
        <float *const*>hip._util.types.ListOfPointer.fromPyobj(A)._ptr,lda,
        <float *const*>hip._util.types.Pointer.fromPyobj(ipiv)._ptr,
        <int *>hip._util.types.ListOfInt.fromPyobj(info)._ptr,batchCount))
    return (_hipblasSgeqrfBatched__retval,)


@cython.embedsignature(True)
def hipblasDgeqrfBatched(object handle, const int m, const int n, object A, const int lda, object ipiv, object info, const int batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        m (`~.int`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        A (`~.hip._util.types.ListOfPointer`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        ipiv (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        info (`~.hip._util.types.ListOfInt`/`~.object`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    _hipblasDgeqrfBatched__retval = hipblasStatus_t(chipblas.hipblasDgeqrfBatched(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,m,n,
        <double *const*>hip._util.types.ListOfPointer.fromPyobj(A)._ptr,lda,
        <double *const*>hip._util.types.Pointer.fromPyobj(ipiv)._ptr,
        <int *>hip._util.types.ListOfInt.fromPyobj(info)._ptr,batchCount))
    return (_hipblasDgeqrfBatched__retval,)


@cython.embedsignature(True)
def hipblasCgeqrfBatched(object handle, const int m, const int n, object A, const int lda, object ipiv, object info, const int batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        m (`~.int`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        A (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        ipiv (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        info (`~.hip._util.types.ListOfInt`/`~.object`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    _hipblasCgeqrfBatched__retval = hipblasStatus_t(chipblas.hipblasCgeqrfBatched(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,m,n,
        <chipblas.hipblasComplex *const*>hip._util.types.Pointer.fromPyobj(A)._ptr,lda,
        <chipblas.hipblasComplex *const*>hip._util.types.Pointer.fromPyobj(ipiv)._ptr,
        <int *>hip._util.types.ListOfInt.fromPyobj(info)._ptr,batchCount))
    return (_hipblasCgeqrfBatched__retval,)


@cython.embedsignature(True)
def hipblasZgeqrfBatched(object handle, const int m, const int n, object A, const int lda, object ipiv, object info, const int batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        m (`~.int`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        A (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        ipiv (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        info (`~.hip._util.types.ListOfInt`/`~.object`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    _hipblasZgeqrfBatched__retval = hipblasStatus_t(chipblas.hipblasZgeqrfBatched(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,m,n,
        <chipblas.hipblasDoubleComplex *const*>hip._util.types.Pointer.fromPyobj(A)._ptr,lda,
        <chipblas.hipblasDoubleComplex *const*>hip._util.types.Pointer.fromPyobj(ipiv)._ptr,
        <int *>hip._util.types.ListOfInt.fromPyobj(info)._ptr,batchCount))
    return (_hipblasZgeqrfBatched__retval,)


@cython.embedsignature(True)
def hipblasCgeqrfBatched_v2(object handle, const int m, const int n, object A, const int lda, object ipiv, object info, const int batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        m (`~.int`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        A (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        ipiv (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        info (`~.hip._util.types.ListOfInt`/`~.object`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    _hipblasCgeqrfBatched_v2__retval = hipblasStatus_t(chipblas.hipblasCgeqrfBatched_v2(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,m,n,
        <chipblas.float2 *const*>hip._util.types.Pointer.fromPyobj(A)._ptr,lda,
        <chipblas.float2 *const*>hip._util.types.Pointer.fromPyobj(ipiv)._ptr,
        <int *>hip._util.types.ListOfInt.fromPyobj(info)._ptr,batchCount))
    return (_hipblasCgeqrfBatched_v2__retval,)


@cython.embedsignature(True)
def hipblasZgeqrfBatched_v2(object handle, const int m, const int n, object A, const int lda, object ipiv, object info, const int batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        m (`~.int`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        A (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        ipiv (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        info (`~.hip._util.types.ListOfInt`/`~.object`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    _hipblasZgeqrfBatched_v2__retval = hipblasStatus_t(chipblas.hipblasZgeqrfBatched_v2(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,m,n,
        <chipblas.double2 *const*>hip._util.types.Pointer.fromPyobj(A)._ptr,lda,
        <chipblas.double2 *const*>hip._util.types.Pointer.fromPyobj(ipiv)._ptr,
        <int *>hip._util.types.ListOfInt.fromPyobj(info)._ptr,batchCount))
    return (_hipblasZgeqrfBatched_v2__retval,)


@cython.embedsignature(True)
def hipblasSgeqrfStridedBatched(object handle, const int m, const int n, object A, const int lda, const long strideA, object ipiv, const long strideP, object info, const int batchCount):
    r"""SOLVER API

    @{

    geqrfStridedBatched computes the QR factorization of a batch of
    general m-by-n matrices.

    The factorization of matrix :math:`A_i` in the batch has the form

    .. math::

       A_i = Q_i\left[\begin{array}{c}
       R_i\\
       0
       \end{array}\right]

    where :math:`R_i` is upper triangular (upper trapezoidal if m < n), and :math:`Q_i` is
    a m-by-m orthogonal/unitary matrix represented as the product of Householder matrices

    .. math::

       Q_i = H_{i_1}H_{i_2}\cdots H_{i_k}, \quad \text{with} \: k = \text{min}(m,n)

    Each Householder matrix :math:`H_{i_j}` is given by

    .. math::

       H_{i_j} = I - \text{ipiv}_j[j] \cdot v_{i_j} v_{i_j}'

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`) -- *IN*:
            hipblasHandle_t.

        m (`~.int`) -- *IN*:
            int. m >= 0.

            The number of rows of all the matrices A_i in the batch.

        n (`~.int`) -- *IN*:
            int. n >= 0.

            The number of columns of all the matrices A_i in the batch.

        A (`~.hip._util.types.Pointer`/`~.object`) -- *INOUT*:
            pointer to type. Array on the GPU (the size depends on the value of strideA).

            On entry, the m-by-n matrices A_i to be factored.
            On exit, the elements on and above the diagonal contain the
            factor R_i. The elements below the diagonal are the last m - j elements
            of Householder vector v_(i_j).

        lda (`~.int`) -- *IN*:
            int. lda >= m.

            Specifies the leading dimension of matrices A_i.

        strideA (`~.int`) -- *IN*:
            hipblasStride.

            Stride from the start of one matrix A_i to the next one A_(i+1).
            There is no restriction for the value of strideA. Normal use case is strideA >= lda*n.

        ipiv (`~.hip._util.types.Pointer`/`~.object`) -- *OUT*:
            pointer to type. Array on the GPU (the size depends on the value of strideP).

            Contains the vectors ipiv_i of corresponding Householder scalars.

        strideP (`~.int`) -- *IN*:
            hipblasStride.

            Stride from the start of one vector ipiv_i to the next one ipiv_(i+1).
            There is no restriction for the value
            of strideP. Normal use is strideP >= min(m,n).

        info (`~.hip._util.types.ListOfInt`/`~.object`) -- *OUT*:
            pointer to a int on the host.

            If info = 0, successful exit.
            If info = j < 0, the argument at position -j is invalid.

        batchCount (`~.int`) -- *IN*:
            int. batchCount >= 0.

            Number of matrices in the batch.
    """
    _hipblasSgeqrfStridedBatched__retval = hipblasStatus_t(chipblas.hipblasSgeqrfStridedBatched(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,m,n,
        <float *>hip._util.types.Pointer.fromPyobj(A)._ptr,lda,strideA,
        <float *>hip._util.types.Pointer.fromPyobj(ipiv)._ptr,strideP,
        <int *>hip._util.types.ListOfInt.fromPyobj(info)._ptr,batchCount))
    return (_hipblasSgeqrfStridedBatched__retval,)


@cython.embedsignature(True)
def hipblasDgeqrfStridedBatched(object handle, const int m, const int n, object A, const int lda, const long strideA, object ipiv, const long strideP, object info, const int batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        m (`~.int`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        A (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        strideA (`~.int`):
            (undocumented)

        ipiv (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        strideP (`~.int`):
            (undocumented)

        info (`~.hip._util.types.ListOfInt`/`~.object`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    _hipblasDgeqrfStridedBatched__retval = hipblasStatus_t(chipblas.hipblasDgeqrfStridedBatched(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,m,n,
        <double *>hip._util.types.Pointer.fromPyobj(A)._ptr,lda,strideA,
        <double *>hip._util.types.Pointer.fromPyobj(ipiv)._ptr,strideP,
        <int *>hip._util.types.ListOfInt.fromPyobj(info)._ptr,batchCount))
    return (_hipblasDgeqrfStridedBatched__retval,)


@cython.embedsignature(True)
def hipblasCgeqrfStridedBatched(object handle, const int m, const int n, object A, const int lda, const long strideA, object ipiv, const long strideP, object info, const int batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        m (`~.int`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        A (`~.hipblasComplex`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        strideA (`~.int`):
            (undocumented)

        ipiv (`~.hipblasComplex`/`~.object`):
            (undocumented)

        strideP (`~.int`):
            (undocumented)

        info (`~.hip._util.types.ListOfInt`/`~.object`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    _hipblasCgeqrfStridedBatched__retval = hipblasStatus_t(chipblas.hipblasCgeqrfStridedBatched(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,m,n,
        hipblasComplex.fromPyobj(A).getElementPtr(),lda,strideA,
        hipblasComplex.fromPyobj(ipiv).getElementPtr(),strideP,
        <int *>hip._util.types.ListOfInt.fromPyobj(info)._ptr,batchCount))
    return (_hipblasCgeqrfStridedBatched__retval,)


@cython.embedsignature(True)
def hipblasZgeqrfStridedBatched(object handle, const int m, const int n, object A, const int lda, const long strideA, object ipiv, const long strideP, object info, const int batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        m (`~.int`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        A (`~.hipblasDoubleComplex`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        strideA (`~.int`):
            (undocumented)

        ipiv (`~.hipblasDoubleComplex`/`~.object`):
            (undocumented)

        strideP (`~.int`):
            (undocumented)

        info (`~.hip._util.types.ListOfInt`/`~.object`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    _hipblasZgeqrfStridedBatched__retval = hipblasStatus_t(chipblas.hipblasZgeqrfStridedBatched(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,m,n,
        hipblasDoubleComplex.fromPyobj(A).getElementPtr(),lda,strideA,
        hipblasDoubleComplex.fromPyobj(ipiv).getElementPtr(),strideP,
        <int *>hip._util.types.ListOfInt.fromPyobj(info)._ptr,batchCount))
    return (_hipblasZgeqrfStridedBatched__retval,)


@cython.embedsignature(True)
def hipblasCgeqrfStridedBatched_v2(object handle, const int m, const int n, object A, const int lda, const long strideA, object ipiv, const long strideP, object info, const int batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        m (`~.int`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        A (`~.float2`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        strideA (`~.int`):
            (undocumented)

        ipiv (`~.float2`/`~.object`):
            (undocumented)

        strideP (`~.int`):
            (undocumented)

        info (`~.hip._util.types.ListOfInt`/`~.object`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    _hipblasCgeqrfStridedBatched_v2__retval = hipblasStatus_t(chipblas.hipblasCgeqrfStridedBatched_v2(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,m,n,
        float2.fromPyobj(A).getElementPtr(),lda,strideA,
        float2.fromPyobj(ipiv).getElementPtr(),strideP,
        <int *>hip._util.types.ListOfInt.fromPyobj(info)._ptr,batchCount))
    return (_hipblasCgeqrfStridedBatched_v2__retval,)


@cython.embedsignature(True)
def hipblasZgeqrfStridedBatched_v2(object handle, const int m, const int n, object A, const int lda, const long strideA, object ipiv, const long strideP, object info, const int batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        m (`~.int`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        A (`~.double2`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        strideA (`~.int`):
            (undocumented)

        ipiv (`~.double2`/`~.object`):
            (undocumented)

        strideP (`~.int`):
            (undocumented)

        info (`~.hip._util.types.ListOfInt`/`~.object`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    _hipblasZgeqrfStridedBatched_v2__retval = hipblasStatus_t(chipblas.hipblasZgeqrfStridedBatched_v2(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,m,n,
        double2.fromPyobj(A).getElementPtr(),lda,strideA,
        double2.fromPyobj(ipiv).getElementPtr(),strideP,
        <int *>hip._util.types.ListOfInt.fromPyobj(info)._ptr,batchCount))
    return (_hipblasZgeqrfStridedBatched_v2__retval,)


@cython.embedsignature(True)
def hipblasGemmEx(object handle, object transA, object transB, int m, int n, int k, object alpha, object A, object aType, int lda, object B, object bType, int ldb, object beta, object C, object cType, int ldc, object computeType, object algo):
    r"""BLAS EX API

    gemmEx performs one of the matrix-matrix operations

    C = alpha*op( A )*op( B ) + beta*C,

    where op( X ) is one of

        op( X ) = X      or
        op( X ) = X**T   or
        op( X ) = X**H,

    alpha and beta are scalars, and A, B, and C are matrices, with
    op( A ) an m by k matrix, op( B ) a k by n matrix and C is a m by n matrix.

    - Supported types are determined by the backend. See cuBLAS documentation for cuBLAS backend.
      For rocBLAS backend, conversion from hipblasComputeType_t to rocblas_datatype_t happens within hipBLAS.
      Supported types are as follows:

      |   aType    |   bType    |   cType    |     computeType     |
      | ---------- | ---------- | ---------- | ------------------- |
      | HIP_R_16F  | HIP_R_16F  | HIP_R_16F  | HIPBLAS_COMPUTE_16F |
      | HIP_R_16F  | HIP_R_16F  | HIP_R_16F  | HIPBLAS_COMPUTE_32F |
      | HIP_R_16F  | HIP_R_16F  | HIP_R_32F  | HIPBLAS_COMPUTE_32F |
      | HIP_R_16BF | HIP_R_16BF | HIP_R_16BF | HIPBLAS_COMPUTE_32F |
      | HIP_R_16BF | HIP_R_16BF | HIP_R_32F  | HIPBLAS_COMPUTE_32F |
      | HIP_R_32F  | HIP_R_32F  | HIP_R_32F  | HIPBLAS_COMPUTE_32F |
      | HIP_R_64F  | HIP_R_64F  | HIP_R_64F  | HIPBLAS_COMPUTE_64F |
      | HIP_R_8I   | HIP_R_8I   | HIP_R_32I  | HIPBLAS_COMPUTE_32I |
      | HIP_C_32F  | HIP_C_32F  | HIP_C_32F  | HIPBLAS_COMPUTE_32F |
      | HIP_C_64F  | HIP_C_64F  | HIP_C_64F  | HIPBLAS_COMPUTE_64F |

    hipblasGemmExWithFlags is also available which is identical to hipblasGemmEx
    with the addition of a "flags" parameter which controls flags used in Tensile to control gemm algorithms with the
    rocBLAS backend. When using a cuBLAS backend this parameter is ignored.

    With HIPBLAS_V2 define, hipblasGemmEx accepts hipDataType for aType, bType, and cType.
    It also accepts hipblasComputeType_t for computeType. hipblasGemmEx will no
    longer support hipblasDataType_t for these parameters in a future release. hipblasGemmEx follows
    the same convention.

        `~.ifdef` HIPBLAS_V2 // available in hipBLAS version 2.0.0 and later with -DHIPBLAS_V2

            hipblasStatus_t hipblasGemmEx(hipblasHandle_t      handle,
                                          hipblasOperation_t   transA,
                                          hipblasOperation_t   transB,
                                          int                  m,
                                          int                  n,
                                          int                  k,
                                          const void*          alpha,
                                          const void*          A,
                                          hipDataType          aType,
                                          int                  lda,
                                          const void*          B,
                                          hipDataType          bType,
                                          int                  ldb,
                                          const void*          beta,
                                          void*                C,
                                          hipDataType          cType,
                                          int                  ldc,
                                          hipblasComputeType_t computeType,
                                          hipblasGemmAlgo_t    algo)

            hipblasStatus_t hipblasGemmExWithFlags(hipblasHandle_t      handle,
                                                   hipblasOperation_t   transA,
                                                   hipblasOperation_t   transB,
                                                   int                  m,
                                                   int                  n,
                                                   int                  k,
                                                   const void*          alpha,
                                                   const void*          A,
                                                   hipDataType          aType,
                                                   int                  lda,
                                                   const void*          B,
                                                   hipDataType          bType,
                                                   int                  ldb,
                                                   const void*          beta,
                                                   void*                C,
                                                   hipDataType          cType,
                                                   int                  ldc,
                                                   hipblasComputeType_t computeType,
                                                   hipblasGemmAlgo_t    algo,
                                                   hipblasGemmFlags_t   flags)

        `~.else` // [DEPRECATED]

            hipblasStatus_t hipblasGemmEx(hipblasHandle_t    handle,
                                          hipblasOperation_t transA,
                                          hipblasOperation_t transB,
                                          int                m,
                                          int                n,
                                          int                k,
                                          const void*        alpha,
                                          const void*        A,
                                          hipblasDatatype_t  aType,
                                          int                lda,
                                          const void*        B,
                                          hipblasDatatype_t  bType,
                                          int                ldb,
                                          const void*        beta,
                                          void*              C,
                                          hipblasDatatype_t  cType,
                                          int                ldc,
                                          hipblasDatatype_t  computeType,
                                          hipblasGemmAlgo_t  algo)

            hipblasStatus_t hipblasGemmExWithFlags(hipblasHandle_t      handle,
                                                   hipblasOperation_t   transA,
                                                   hipblasOperation_t   transB,
                                                   int                  m,
                                                   int                  n,
                                                   int                  k,
                                                   const void*          alpha,
                                                   const void*          A,
                                                   hipblasDatatype_t    aType,
                                                   int                  lda,
                                                   const void*          B,
                                                   hipblasDatatype_t    bType,
                                                   int                  ldb,
                                                   const void*          beta,
                                                   void*                C,
                                                   hipblasDatatype_t    cType,
                                                   int                  ldc,
                                                   hipblasDatatype_t    computeType,
                                                   hipblasGemmAlgo_t    algo,
                                                   hipblasGemmFlags_t   flags)

        `~.endif`

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`) -- *IN*:
            [hipblasHandle_t]
            handle to the hipblas library context queue.

        transA (`~.hipblasOperation_t`) -- *IN*:
            [hipblasOperation_t]
            specifies the form of op( A ).

        transB (`~.hipblasOperation_t`) -- *IN*:
            [hipblasOperation_t]
            specifies the form of op( B ).

        m (`~.int`) -- *IN*:
            [int]
            matrix dimension m.

        n (`~.int`) -- *IN*:
            [int]
            matrix dimension n.

        k (`~.int`) -- *IN*:
            [int]
            matrix dimension k.

        alpha (`~.hip._util.types.Pointer`/`~.object`) -- *IN*:
            [const void *]
            device pointer or host pointer specifying the scalar alpha. Same datatype as computeType.

        A (`~.hip._util.types.Pointer`/`~.object`) -- *IN*:
            [void *]
            device pointer storing matrix A.

        aType (`~.hipblasDatatype_t`) -- *IN*:
            [hipblasDatatype_t] [DEPRECATED]
                      specifies the datatype of matrix A.

            [hipDataType]
                      specifies the datatype of matrix A.

        lda (`~.int`) -- *IN*:
            [int]
            specifies the leading dimension of A.

        B (`~.hip._util.types.Pointer`/`~.object`) -- *IN*:
            [void *]
            device pointer storing matrix B.

        bType (`~.hipblasDatatype_t`) -- *IN*:
            [hipblasDatatype_t] [DEPRECATED]
                      specifies the datatype of matrix B.

            [hipDataType]
                      specifies the datatype of matrix B.

        ldb (`~.int`) -- *IN*:
            [int]
            specifies the leading dimension of B.

        beta (`~.hip._util.types.Pointer`/`~.object`) -- *IN*:
            [const void *]
            device pointer or host pointer specifying the scalar beta. Same datatype as computeType.

        C (`~.hip._util.types.Pointer`/`~.object`) -- *IN*:
            [void *]
            device pointer storing matrix C.

        cType (`~.hipblasDatatype_t`) -- *IN*:
            [hipblasDatatype_t] [DEPRECATED]
                      specifies the datatype of matrix C.

            [hipDataType]
                      specifies the datatype of matrix C.

        ldc (`~.int`) -- *IN*:
            [int]
            specifies the leading dimension of C.

        computeType (`~.hipblasDatatype_t`) -- *IN*:
            [hipblasDatatype_t] [DEPRECATED]
                      specifies the datatype of computation.

            [hipblasComputeType_t]
                      specifies the datatype of computation.

        algo (`~.hipblasGemmAlgo_t`) -- *IN*:
            [hipblasGemmAlgo_t]
            enumerant specifying the algorithm type.
    """
    if not isinstance(transA,_hipblasOperation_t__Base):
        raise TypeError("argument 'transA' must be of type '_hipblasOperation_t__Base'")                    
    if not isinstance(transB,_hipblasOperation_t__Base):
        raise TypeError("argument 'transB' must be of type '_hipblasOperation_t__Base'")                    
    if not isinstance(aType,_hipblasDatatype_t__Base):
        raise TypeError("argument 'aType' must be of type '_hipblasDatatype_t__Base'")                    
    if not isinstance(bType,_hipblasDatatype_t__Base):
        raise TypeError("argument 'bType' must be of type '_hipblasDatatype_t__Base'")                    
    if not isinstance(cType,_hipblasDatatype_t__Base):
        raise TypeError("argument 'cType' must be of type '_hipblasDatatype_t__Base'")                    
    if not isinstance(computeType,_hipblasDatatype_t__Base):
        raise TypeError("argument 'computeType' must be of type '_hipblasDatatype_t__Base'")                    
    if not isinstance(algo,_hipblasGemmAlgo_t__Base):
        raise TypeError("argument 'algo' must be of type '_hipblasGemmAlgo_t__Base'")
    _hipblasGemmEx__retval = hipblasStatus_t(chipblas.hipblasGemmEx(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,transA.value,transB.value,m,n,k,
        <const void *>hip._util.types.Pointer.fromPyobj(alpha)._ptr,
        <const void *>hip._util.types.Pointer.fromPyobj(A)._ptr,aType.value,lda,
        <const void *>hip._util.types.Pointer.fromPyobj(B)._ptr,bType.value,ldb,
        <const void *>hip._util.types.Pointer.fromPyobj(beta)._ptr,
        <void *>hip._util.types.Pointer.fromPyobj(C)._ptr,cType.value,ldc,computeType.value,algo.value))
    return (_hipblasGemmEx__retval,)


@cython.embedsignature(True)
def hipblasGemmEx_v2(object handle, object transA, object transB, int m, int n, int k, object alpha, object A, object aType, int lda, object B, object bType, int ldb, object beta, object C, object cType, int ldc, object computeType, object algo):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        transA (`~.hipblasOperation_t`):
            (undocumented)

        transB (`~.hipblasOperation_t`):
            (undocumented)

        m (`~.int`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        k (`~.int`):
            (undocumented)

        alpha (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        A (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        aType (`~.hipDataType`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        B (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        bType (`~.hipDataType`):
            (undocumented)

        ldb (`~.int`):
            (undocumented)

        beta (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        C (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        cType (`~.hipDataType`):
            (undocumented)

        ldc (`~.int`):
            (undocumented)

        computeType (`~.hipblasComputeType_t`):
            (undocumented)

        algo (`~.hipblasGemmAlgo_t`):
            (undocumented)
    """
    if not isinstance(transA,_hipblasOperation_t__Base):
        raise TypeError("argument 'transA' must be of type '_hipblasOperation_t__Base'")                    
    if not isinstance(transB,_hipblasOperation_t__Base):
        raise TypeError("argument 'transB' must be of type '_hipblasOperation_t__Base'")                    
    if not isinstance(aType,_hipDataType__Base):
        raise TypeError("argument 'aType' must be of type '_hipDataType__Base'")                    
    if not isinstance(bType,_hipDataType__Base):
        raise TypeError("argument 'bType' must be of type '_hipDataType__Base'")                    
    if not isinstance(cType,_hipDataType__Base):
        raise TypeError("argument 'cType' must be of type '_hipDataType__Base'")                    
    if not isinstance(computeType,_hipblasComputeType_t__Base):
        raise TypeError("argument 'computeType' must be of type '_hipblasComputeType_t__Base'")                    
    if not isinstance(algo,_hipblasGemmAlgo_t__Base):
        raise TypeError("argument 'algo' must be of type '_hipblasGemmAlgo_t__Base'")
    _hipblasGemmEx_v2__retval = hipblasStatus_t(chipblas.hipblasGemmEx_v2(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,transA.value,transB.value,m,n,k,
        <const void *>hip._util.types.Pointer.fromPyobj(alpha)._ptr,
        <const void *>hip._util.types.Pointer.fromPyobj(A)._ptr,aType.value,lda,
        <const void *>hip._util.types.Pointer.fromPyobj(B)._ptr,bType.value,ldb,
        <const void *>hip._util.types.Pointer.fromPyobj(beta)._ptr,
        <void *>hip._util.types.Pointer.fromPyobj(C)._ptr,cType.value,ldc,computeType.value,algo.value))
    return (_hipblasGemmEx_v2__retval,)


@cython.embedsignature(True)
def hipblasGemmExWithFlags(object handle, object transA, object transB, int m, int n, int k, object alpha, object A, object aType, int lda, object B, object bType, int ldb, object beta, object C, object cType, int ldc, object computeType, object algo, object flags):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        transA (`~.hipblasOperation_t`):
            (undocumented)

        transB (`~.hipblasOperation_t`):
            (undocumented)

        m (`~.int`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        k (`~.int`):
            (undocumented)

        alpha (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        A (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        aType (`~.hipblasDatatype_t`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        B (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        bType (`~.hipblasDatatype_t`):
            (undocumented)

        ldb (`~.int`):
            (undocumented)

        beta (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        C (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        cType (`~.hipblasDatatype_t`):
            (undocumented)

        ldc (`~.int`):
            (undocumented)

        computeType (`~.hipblasDatatype_t`):
            (undocumented)

        algo (`~.hipblasGemmAlgo_t`):
            (undocumented)

        flags (`~.hipblasGemmFlags_t`):
            (undocumented)
    """
    if not isinstance(transA,_hipblasOperation_t__Base):
        raise TypeError("argument 'transA' must be of type '_hipblasOperation_t__Base'")                    
    if not isinstance(transB,_hipblasOperation_t__Base):
        raise TypeError("argument 'transB' must be of type '_hipblasOperation_t__Base'")                    
    if not isinstance(aType,_hipblasDatatype_t__Base):
        raise TypeError("argument 'aType' must be of type '_hipblasDatatype_t__Base'")                    
    if not isinstance(bType,_hipblasDatatype_t__Base):
        raise TypeError("argument 'bType' must be of type '_hipblasDatatype_t__Base'")                    
    if not isinstance(cType,_hipblasDatatype_t__Base):
        raise TypeError("argument 'cType' must be of type '_hipblasDatatype_t__Base'")                    
    if not isinstance(computeType,_hipblasDatatype_t__Base):
        raise TypeError("argument 'computeType' must be of type '_hipblasDatatype_t__Base'")                    
    if not isinstance(algo,_hipblasGemmAlgo_t__Base):
        raise TypeError("argument 'algo' must be of type '_hipblasGemmAlgo_t__Base'")                    
    if not isinstance(flags,_hipblasGemmFlags_t__Base):
        raise TypeError("argument 'flags' must be of type '_hipblasGemmFlags_t__Base'")
    _hipblasGemmExWithFlags__retval = hipblasStatus_t(chipblas.hipblasGemmExWithFlags(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,transA.value,transB.value,m,n,k,
        <const void *>hip._util.types.Pointer.fromPyobj(alpha)._ptr,
        <const void *>hip._util.types.Pointer.fromPyobj(A)._ptr,aType.value,lda,
        <const void *>hip._util.types.Pointer.fromPyobj(B)._ptr,bType.value,ldb,
        <const void *>hip._util.types.Pointer.fromPyobj(beta)._ptr,
        <void *>hip._util.types.Pointer.fromPyobj(C)._ptr,cType.value,ldc,computeType.value,algo.value,flags.value))
    return (_hipblasGemmExWithFlags__retval,)


@cython.embedsignature(True)
def hipblasGemmExWithFlags_v2(object handle, object transA, object transB, int m, int n, int k, object alpha, object A, object aType, int lda, object B, object bType, int ldb, object beta, object C, object cType, int ldc, object computeType, object algo, object flags):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        transA (`~.hipblasOperation_t`):
            (undocumented)

        transB (`~.hipblasOperation_t`):
            (undocumented)

        m (`~.int`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        k (`~.int`):
            (undocumented)

        alpha (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        A (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        aType (`~.hipDataType`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        B (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        bType (`~.hipDataType`):
            (undocumented)

        ldb (`~.int`):
            (undocumented)

        beta (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        C (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        cType (`~.hipDataType`):
            (undocumented)

        ldc (`~.int`):
            (undocumented)

        computeType (`~.hipblasComputeType_t`):
            (undocumented)

        algo (`~.hipblasGemmAlgo_t`):
            (undocumented)

        flags (`~.hipblasGemmFlags_t`):
            (undocumented)
    """
    if not isinstance(transA,_hipblasOperation_t__Base):
        raise TypeError("argument 'transA' must be of type '_hipblasOperation_t__Base'")                    
    if not isinstance(transB,_hipblasOperation_t__Base):
        raise TypeError("argument 'transB' must be of type '_hipblasOperation_t__Base'")                    
    if not isinstance(aType,_hipDataType__Base):
        raise TypeError("argument 'aType' must be of type '_hipDataType__Base'")                    
    if not isinstance(bType,_hipDataType__Base):
        raise TypeError("argument 'bType' must be of type '_hipDataType__Base'")                    
    if not isinstance(cType,_hipDataType__Base):
        raise TypeError("argument 'cType' must be of type '_hipDataType__Base'")                    
    if not isinstance(computeType,_hipblasComputeType_t__Base):
        raise TypeError("argument 'computeType' must be of type '_hipblasComputeType_t__Base'")                    
    if not isinstance(algo,_hipblasGemmAlgo_t__Base):
        raise TypeError("argument 'algo' must be of type '_hipblasGemmAlgo_t__Base'")                    
    if not isinstance(flags,_hipblasGemmFlags_t__Base):
        raise TypeError("argument 'flags' must be of type '_hipblasGemmFlags_t__Base'")
    _hipblasGemmExWithFlags_v2__retval = hipblasStatus_t(chipblas.hipblasGemmExWithFlags_v2(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,transA.value,transB.value,m,n,k,
        <const void *>hip._util.types.Pointer.fromPyobj(alpha)._ptr,
        <const void *>hip._util.types.Pointer.fromPyobj(A)._ptr,aType.value,lda,
        <const void *>hip._util.types.Pointer.fromPyobj(B)._ptr,bType.value,ldb,
        <const void *>hip._util.types.Pointer.fromPyobj(beta)._ptr,
        <void *>hip._util.types.Pointer.fromPyobj(C)._ptr,cType.value,ldc,computeType.value,algo.value,flags.value))
    return (_hipblasGemmExWithFlags_v2__retval,)


@cython.embedsignature(True)
def hipblasGemmBatchedEx(object handle, object transA, object transB, int m, int n, int k, object alpha, object A, object aType, int lda, object B, object bType, int ldb, object beta, object C, object cType, int ldc, int batchCount, object computeType, object algo):
    r"""BLAS EX API

    gemmBatchedEx performs one of the batched matrix-matrix operations
        C_i = alpha*op(A_i)*op(B_i) + beta*C_i, for i = 1, ..., batchCount.
    where op( X ) is one of
        op( X ) = X      or
        op( X ) = X**T   or
        op( X ) = X**H,
    alpha and beta are scalars, and A, B, and C are batched pointers to matrices, with
    op( A ) an m by k by batchCount batched matrix,
    op( B ) a k by n by batchCount batched matrix and
    C a m by n by batchCount batched matrix.
    The batched matrices are an array of pointers to matrices.
    The number of pointers to matrices is batchCount.

    - Supported types are determined by the backend. See rocBLAS/cuBLAS documentation.

    hipblasGemmBatchedExWithFlags is also available which is identical to hipblasGemmBatchedEx
    with the addition of a "flags" parameter which controls flags used in Tensile to control gemm algorithms with the
    rocBLAS backend. When using a cuBLAS backend this parameter is ignored.

    With HIPBLAS_V2 define, hipblasGemmBatchedEx accepts hipDataType for aType, bType, and cType.
    It also accepts hipblasComputeType_t for computeType. hipblasGemmBatchedEx will no
    longer support hipblasDataType_t for these parameters in a future release. hipblasGemmBatchedExWithFlags
    follows the same convention.

        `~.ifdef` HIPBLAS_V2 // available in hipBLAS version 2.0.0 and later with -DHIPBLAS_V2

            hipblasStatus_t hipblasGemmBatchedEx(hipblasHandle_t      handle,
                                                 hipblasOperation_t   transA,
                                                 hipblasOperation_t   transB,
                                                 int                  m,
                                                 int                  n,
                                                 int                  k,
                                                 const void*          alpha,
                                                 const void*          A[],
                                                 hipDataType          aType,
                                                 int                  lda,
                                                 const void*          B[],
                                                 hipDataType          bType,
                                                 int                  ldb,
                                                 const void*          beta,
                                                 void*                C[],
                                                 hipDataType          cType,
                                                 int                  ldc,
                                                 int                  batchCount,
                                                 hipblasComputeType_t computeType,
                                                 hipblasGemmAlgo_t    algo)

            hipblasStatus_t hipblasGemmBatchedExWithFlags(hipblasHandle_t      handle,
                                                          hipblasOperation_t   transA,
                                                          hipblasOperation_t   transB,
                                                          int                  m,
                                                          int                  n,
                                                          int                  k,
                                                          const void*          alpha,
                                                          const void*          A[],
                                                          hipDataType          aType,
                                                          int                  lda,
                                                          const void*          B[],
                                                          hipDataType          bType,
                                                          int                  ldb,
                                                          const void*          beta,
                                                          void*                C[],
                                                          hipDataType          cType,
                                                          int                  ldc,
                                                          int                  batchCount,
                                                          hipblasComputeType_t computeType,
                                                          hipblasGemmAlgo_t    algo,
                                                          hipblasGemmFlags_t   flags)

        `~.else` // [DEPRECATED]

            hipblasStatus_t hipblasGemmBatchedEx(hipblasHandle_t    handle,
                                                 hipblasOperation_t transA,
                                                 hipblasOperation_t transB,
                                                 int                m,
                                                 int                n,
                                                 int                k,
                                                 const void*        alpha,
                                                 const void*        A[],
                                                 hipblasDatatype_t  aType,
                                                 int                lda,
                                                 const void*        B[],
                                                 hipblasDatatype_t  bType,
                                                 int                ldb,
                                                 const void*        beta,
                                                 void*              C[],
                                                 hipblasDatatype_t  cType,
                                                 int                ldc,
                                                 int                batchCount,
                                                 hipblasDatatype_t  computeType,
                                                 hipblasGemmAlgo_t  algo)

            hipblasStatus_t hipblasGemmBatchedExWithFlags(hipblasHandle_t      handle,
                                                          hipblasOperation_t   transA,
                                                          hipblasOperation_t   transB,
                                                          int                  m,
                                                          int                  n,
                                                          int                  k,
                                                          const void*          alpha,
                                                          const void*          A[],
                                                          hipblasDatatype_t    aType,
                                                          int                  lda,
                                                          const void*          B[],
                                                          hipblasDatatype_t    bType,
                                                          int                  ldb,
                                                          const void*          beta,
                                                          void*                C[],
                                                          hipblasDatatype_t    cType,
                                                          int                  ldc,
                                                          int                  batchCount,
                                                          hipblasDatatype_t    computeType,
                                                          hipblasGemmAlgo_t    algo,
                                                          hipblasGemmFlags_t   flags)

        `~.endif`

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`) -- *IN*:
            [hipblasHandle_t]
            handle to the hipblas library context queue.

        transA (`~.hipblasOperation_t`) -- *IN*:
            [hipblasOperation_t]
            specifies the form of op( A ).

        transB (`~.hipblasOperation_t`) -- *IN*:
            [hipblasOperation_t]
            specifies the form of op( B ).

        m (`~.int`) -- *IN*:
            [int]
            matrix dimension m.

        n (`~.int`) -- *IN*:
            [int]
            matrix dimension n.

        k (`~.int`) -- *IN*:
            [int]
            matrix dimension k.

        alpha (`~.hip._util.types.Pointer`/`~.object`) -- *IN*:
            [const void *]
            device pointer or host pointer specifying the scalar alpha. Same datatype as computeType.

        A (`~.hip._util.types.ListOfPointer`/`~.object`) -- *IN*:
            [void *]
            device pointer storing array of pointers to each matrix A_i.

        aType (`~.hipblasDatatype_t`) -- *IN*:
            [hipblasDatatype_t] [DEPRECATED]
                      specifies the datatype of each matrix A_i.

            [hipDataType]
                      specifies the datatype of each matrix A_i.

        lda (`~.int`) -- *IN*:
            [int]
            specifies the leading dimension of each A_i.

        B (`~.hip._util.types.ListOfPointer`/`~.object`) -- *IN*:
            [void *]
            device pointer storing array of pointers to each matrix B_i.

        bType (`~.hipblasDatatype_t`) -- *IN*:
            [hipblasDatatype_t] [DEPRECATED]
                      specifies the datatype of each matrix B_i.

            [hipDataType]
                      specifies the datatype of each matrix B_i.

        ldb (`~.int`) -- *IN*:
            [int]
            specifies the leading dimension of each B_i.

        beta (`~.hip._util.types.Pointer`/`~.object`) -- *IN*:
            [const void *]
            device pointer or host pointer specifying the scalar beta. Same datatype as computeType.

        C (`~.hip._util.types.ListOfPointer`/`~.object`) -- *IN*:
            [void *]
            device array of device pointers to each matrix C_i.

        cType (`~.hipblasDatatype_t`) -- *IN*:
            [hipblasDatatype_t] [DEPRECATED]
                      specifies the datatype of each matrix C_i.

            [hipDataType]
                      specifies the datatype of each matrix C_i.

        ldc (`~.int`) -- *IN*:
            [int]
            specifies the leading dimension of each C_i.

        batchCount (`~.int`) -- *IN*:
            [int]
            number of gemm operations in the batch.

        computeType (`~.hipblasDatatype_t`) -- *IN*:
            [hipblasDatatype_t] [DEPRECATED]
                      specifies the datatype of computation.

            [hipblasComputeType_t]
                      specifies the datatype of computation.

        algo (`~.hipblasGemmAlgo_t`) -- *IN*:
            [hipblasGemmAlgo_t]
            enumerant specifying the algorithm type.
    """
    if not isinstance(transA,_hipblasOperation_t__Base):
        raise TypeError("argument 'transA' must be of type '_hipblasOperation_t__Base'")                    
    if not isinstance(transB,_hipblasOperation_t__Base):
        raise TypeError("argument 'transB' must be of type '_hipblasOperation_t__Base'")                    
    if not isinstance(aType,_hipblasDatatype_t__Base):
        raise TypeError("argument 'aType' must be of type '_hipblasDatatype_t__Base'")                    
    if not isinstance(bType,_hipblasDatatype_t__Base):
        raise TypeError("argument 'bType' must be of type '_hipblasDatatype_t__Base'")                    
    if not isinstance(cType,_hipblasDatatype_t__Base):
        raise TypeError("argument 'cType' must be of type '_hipblasDatatype_t__Base'")                    
    if not isinstance(computeType,_hipblasDatatype_t__Base):
        raise TypeError("argument 'computeType' must be of type '_hipblasDatatype_t__Base'")                    
    if not isinstance(algo,_hipblasGemmAlgo_t__Base):
        raise TypeError("argument 'algo' must be of type '_hipblasGemmAlgo_t__Base'")
    _hipblasGemmBatchedEx__retval = hipblasStatus_t(chipblas.hipblasGemmBatchedEx(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,transA.value,transB.value,m,n,k,
        <const void *>hip._util.types.Pointer.fromPyobj(alpha)._ptr,
        <const void **>hip._util.types.ListOfPointer.fromPyobj(A)._ptr,aType.value,lda,
        <const void **>hip._util.types.ListOfPointer.fromPyobj(B)._ptr,bType.value,ldb,
        <const void *>hip._util.types.Pointer.fromPyobj(beta)._ptr,
        <void **>hip._util.types.ListOfPointer.fromPyobj(C)._ptr,cType.value,ldc,batchCount,computeType.value,algo.value))
    return (_hipblasGemmBatchedEx__retval,)


@cython.embedsignature(True)
def hipblasGemmBatchedEx_v2(object handle, object transA, object transB, int m, int n, int k, object alpha, object A, object aType, int lda, object B, object bType, int ldb, object beta, object C, object cType, int ldc, int batchCount, object computeType, object algo):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        transA (`~.hipblasOperation_t`):
            (undocumented)

        transB (`~.hipblasOperation_t`):
            (undocumented)

        m (`~.int`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        k (`~.int`):
            (undocumented)

        alpha (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        A (`~.hip._util.types.ListOfPointer`/`~.object`):
            (undocumented)

        aType (`~.hipDataType`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        B (`~.hip._util.types.ListOfPointer`/`~.object`):
            (undocumented)

        bType (`~.hipDataType`):
            (undocumented)

        ldb (`~.int`):
            (undocumented)

        beta (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        C (`~.hip._util.types.ListOfPointer`/`~.object`):
            (undocumented)

        cType (`~.hipDataType`):
            (undocumented)

        ldc (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)

        computeType (`~.hipblasComputeType_t`):
            (undocumented)

        algo (`~.hipblasGemmAlgo_t`):
            (undocumented)
    """
    if not isinstance(transA,_hipblasOperation_t__Base):
        raise TypeError("argument 'transA' must be of type '_hipblasOperation_t__Base'")                    
    if not isinstance(transB,_hipblasOperation_t__Base):
        raise TypeError("argument 'transB' must be of type '_hipblasOperation_t__Base'")                    
    if not isinstance(aType,_hipDataType__Base):
        raise TypeError("argument 'aType' must be of type '_hipDataType__Base'")                    
    if not isinstance(bType,_hipDataType__Base):
        raise TypeError("argument 'bType' must be of type '_hipDataType__Base'")                    
    if not isinstance(cType,_hipDataType__Base):
        raise TypeError("argument 'cType' must be of type '_hipDataType__Base'")                    
    if not isinstance(computeType,_hipblasComputeType_t__Base):
        raise TypeError("argument 'computeType' must be of type '_hipblasComputeType_t__Base'")                    
    if not isinstance(algo,_hipblasGemmAlgo_t__Base):
        raise TypeError("argument 'algo' must be of type '_hipblasGemmAlgo_t__Base'")
    _hipblasGemmBatchedEx_v2__retval = hipblasStatus_t(chipblas.hipblasGemmBatchedEx_v2(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,transA.value,transB.value,m,n,k,
        <const void *>hip._util.types.Pointer.fromPyobj(alpha)._ptr,
        <const void **>hip._util.types.ListOfPointer.fromPyobj(A)._ptr,aType.value,lda,
        <const void **>hip._util.types.ListOfPointer.fromPyobj(B)._ptr,bType.value,ldb,
        <const void *>hip._util.types.Pointer.fromPyobj(beta)._ptr,
        <void **>hip._util.types.ListOfPointer.fromPyobj(C)._ptr,cType.value,ldc,batchCount,computeType.value,algo.value))
    return (_hipblasGemmBatchedEx_v2__retval,)


@cython.embedsignature(True)
def hipblasGemmBatchedExWithFlags(object handle, object transA, object transB, int m, int n, int k, object alpha, object A, object aType, int lda, object B, object bType, int ldb, object beta, object C, object cType, int ldc, int batchCount, object computeType, object algo, object flags):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        transA (`~.hipblasOperation_t`):
            (undocumented)

        transB (`~.hipblasOperation_t`):
            (undocumented)

        m (`~.int`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        k (`~.int`):
            (undocumented)

        alpha (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        A (`~.hip._util.types.ListOfPointer`/`~.object`):
            (undocumented)

        aType (`~.hipblasDatatype_t`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        B (`~.hip._util.types.ListOfPointer`/`~.object`):
            (undocumented)

        bType (`~.hipblasDatatype_t`):
            (undocumented)

        ldb (`~.int`):
            (undocumented)

        beta (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        C (`~.hip._util.types.ListOfPointer`/`~.object`):
            (undocumented)

        cType (`~.hipblasDatatype_t`):
            (undocumented)

        ldc (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)

        computeType (`~.hipblasDatatype_t`):
            (undocumented)

        algo (`~.hipblasGemmAlgo_t`):
            (undocumented)

        flags (`~.hipblasGemmFlags_t`):
            (undocumented)
    """
    if not isinstance(transA,_hipblasOperation_t__Base):
        raise TypeError("argument 'transA' must be of type '_hipblasOperation_t__Base'")                    
    if not isinstance(transB,_hipblasOperation_t__Base):
        raise TypeError("argument 'transB' must be of type '_hipblasOperation_t__Base'")                    
    if not isinstance(aType,_hipblasDatatype_t__Base):
        raise TypeError("argument 'aType' must be of type '_hipblasDatatype_t__Base'")                    
    if not isinstance(bType,_hipblasDatatype_t__Base):
        raise TypeError("argument 'bType' must be of type '_hipblasDatatype_t__Base'")                    
    if not isinstance(cType,_hipblasDatatype_t__Base):
        raise TypeError("argument 'cType' must be of type '_hipblasDatatype_t__Base'")                    
    if not isinstance(computeType,_hipblasDatatype_t__Base):
        raise TypeError("argument 'computeType' must be of type '_hipblasDatatype_t__Base'")                    
    if not isinstance(algo,_hipblasGemmAlgo_t__Base):
        raise TypeError("argument 'algo' must be of type '_hipblasGemmAlgo_t__Base'")                    
    if not isinstance(flags,_hipblasGemmFlags_t__Base):
        raise TypeError("argument 'flags' must be of type '_hipblasGemmFlags_t__Base'")
    _hipblasGemmBatchedExWithFlags__retval = hipblasStatus_t(chipblas.hipblasGemmBatchedExWithFlags(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,transA.value,transB.value,m,n,k,
        <const void *>hip._util.types.Pointer.fromPyobj(alpha)._ptr,
        <const void **>hip._util.types.ListOfPointer.fromPyobj(A)._ptr,aType.value,lda,
        <const void **>hip._util.types.ListOfPointer.fromPyobj(B)._ptr,bType.value,ldb,
        <const void *>hip._util.types.Pointer.fromPyobj(beta)._ptr,
        <void **>hip._util.types.ListOfPointer.fromPyobj(C)._ptr,cType.value,ldc,batchCount,computeType.value,algo.value,flags.value))
    return (_hipblasGemmBatchedExWithFlags__retval,)


@cython.embedsignature(True)
def hipblasGemmBatchedExWithFlags_v2(object handle, object transA, object transB, int m, int n, int k, object alpha, object A, object aType, int lda, object B, object bType, int ldb, object beta, object C, object cType, int ldc, int batchCount, object computeType, object algo, object flags):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        transA (`~.hipblasOperation_t`):
            (undocumented)

        transB (`~.hipblasOperation_t`):
            (undocumented)

        m (`~.int`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        k (`~.int`):
            (undocumented)

        alpha (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        A (`~.hip._util.types.ListOfPointer`/`~.object`):
            (undocumented)

        aType (`~.hipDataType`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        B (`~.hip._util.types.ListOfPointer`/`~.object`):
            (undocumented)

        bType (`~.hipDataType`):
            (undocumented)

        ldb (`~.int`):
            (undocumented)

        beta (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        C (`~.hip._util.types.ListOfPointer`/`~.object`):
            (undocumented)

        cType (`~.hipDataType`):
            (undocumented)

        ldc (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)

        computeType (`~.hipblasComputeType_t`):
            (undocumented)

        algo (`~.hipblasGemmAlgo_t`):
            (undocumented)

        flags (`~.hipblasGemmFlags_t`):
            (undocumented)
    """
    if not isinstance(transA,_hipblasOperation_t__Base):
        raise TypeError("argument 'transA' must be of type '_hipblasOperation_t__Base'")                    
    if not isinstance(transB,_hipblasOperation_t__Base):
        raise TypeError("argument 'transB' must be of type '_hipblasOperation_t__Base'")                    
    if not isinstance(aType,_hipDataType__Base):
        raise TypeError("argument 'aType' must be of type '_hipDataType__Base'")                    
    if not isinstance(bType,_hipDataType__Base):
        raise TypeError("argument 'bType' must be of type '_hipDataType__Base'")                    
    if not isinstance(cType,_hipDataType__Base):
        raise TypeError("argument 'cType' must be of type '_hipDataType__Base'")                    
    if not isinstance(computeType,_hipblasComputeType_t__Base):
        raise TypeError("argument 'computeType' must be of type '_hipblasComputeType_t__Base'")                    
    if not isinstance(algo,_hipblasGemmAlgo_t__Base):
        raise TypeError("argument 'algo' must be of type '_hipblasGemmAlgo_t__Base'")                    
    if not isinstance(flags,_hipblasGemmFlags_t__Base):
        raise TypeError("argument 'flags' must be of type '_hipblasGemmFlags_t__Base'")
    _hipblasGemmBatchedExWithFlags_v2__retval = hipblasStatus_t(chipblas.hipblasGemmBatchedExWithFlags_v2(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,transA.value,transB.value,m,n,k,
        <const void *>hip._util.types.Pointer.fromPyobj(alpha)._ptr,
        <const void **>hip._util.types.ListOfPointer.fromPyobj(A)._ptr,aType.value,lda,
        <const void **>hip._util.types.ListOfPointer.fromPyobj(B)._ptr,bType.value,ldb,
        <const void *>hip._util.types.Pointer.fromPyobj(beta)._ptr,
        <void **>hip._util.types.ListOfPointer.fromPyobj(C)._ptr,cType.value,ldc,batchCount,computeType.value,algo.value,flags.value))
    return (_hipblasGemmBatchedExWithFlags_v2__retval,)


@cython.embedsignature(True)
def hipblasGemmStridedBatchedEx(object handle, object transA, object transB, int m, int n, int k, object alpha, object A, object aType, int lda, long strideA, object B, object bType, int ldb, long strideB, object beta, object C, object cType, int ldc, long strideC, int batchCount, object computeType, object algo):
    r"""BLAS EX API

    gemmStridedBatchedEx performs one of the strided_batched matrix-matrix operations

    C_i = alpha*op(A_i)*op(B_i) + beta*C_i, for i = 1, ..., batchCount

    where op( X ) is one of

        op( X ) = X      or
        op( X ) = X**T   or
        op( X ) = X**H,

    alpha and beta are scalars, and A, B, and C are strided_batched matrices, with
    op( A ) an m by k by batchCount strided_batched matrix,
    op( B ) a k by n by batchCount strided_batched matrix and
    C a m by n by batchCount strided_batched matrix.

    The strided_batched matrices are multiple matrices separated by a constant stride.
    The number of matrices is batchCount.

    - Supported types are determined by the backend. See rocBLAS/cuBLAS documentation.

    hipblasGemmStridedBatchedExWithFlags is also available which is identical to hipblasStridedBatchedGemmEx
    with the addition of a "flags" parameter which controls flags used in Tensile to control gemm algorithms with the
    rocBLAS backend. When using a cuBLAS backend this parameter is ignored.

    With HIPBLAS_V2 define, hipblasGemmStridedBatchedEx accepts hipDataType for aType, bType, and cType.
    It also accepts hipblasComputeType_t for computeType. hipblasGemmStridedBatchedEx will no
    longer support hipblasDataType_t for these parameters in a future release. hipblasGemmStridedBatchedExWithFlags
    follows the same convention.

        `~.ifdef` HIPBLAS_V2 // available in hipBLAS version 2.0.0 and later with -DHIPBLAS_V2

            hipblasStatus_t hipblasGemmStridedBatchedEx(hipblasHandle_t      handle,
                                                        hipblasOperation_t   transA,
                                                        hipblasOperation_t   transB,
                                                        int                  m,
                                                        int                  n,
                                                        int                  k,
                                                        const void*          alpha,
                                                        const void*          A,
                                                        hipDataType          aType,
                                                        int                  lda,
                                                        hipblasStride        strideA,
                                                        const void*          B,
                                                        hipDataType          bType,
                                                        int                  ldb,
                                                        hipblasStride        strideB,
                                                        const void*          beta,
                                                        void*                C,
                                                        hipDataType          cType,
                                                        int                  ldc,
                                                        hipblasStride        strideC,
                                                        int                  batchCount,
                                                        hipblasComputeType_t computeType,
                                                        hipblasGemmAlgo_t    algo)

            hipblasStatus_t hipblasGemmStridedBatchedExWithFlags(hipblasHandle_t      handle,
                                                                 hipblasOperation_t   transA,
                                                                 hipblasOperation_t   transB,
                                                                 int                  m,
                                                                 int                  n,
                                                                 int                  k,
                                                                 const void*          alpha,
                                                                 const void*          A,
                                                                 hipDataType          aType,
                                                                 int                  lda,
                                                                 hipblasStride        strideA,
                                                                 const void*          B,
                                                                 hipDataType          bType,
                                                                 int                  ldb,
                                                                 hipblasStride        strideB,
                                                                 const void*          beta,
                                                                 void*                C,
                                                                 hipDataType          cType,
                                                                 int                  ldc,
                                                                 hipblasStride        strideC,
                                                                 int                  batchCount,
                                                                 hipblasComputeType_t computeType,
                                                                 hipblasGemmAlgo_t    algo,
                                                                 hipblasGemmFlags_t   flags)

        `~.else` // [DEPRECATED]

            hipblasStatus_t hipblasGemmStridedBatchedEx(hipblasHandle_t    handle,
                                                        hipblasOperation_t transA,
                                                        hipblasOperation_t transB,
                                                        int                m,
                                                        int                n,
                                                        int                k,
                                                        const void*        alpha,
                                                        const void*        A,
                                                        hipblasDatatype_t  aType,
                                                        int                lda,
                                                        hipblasStride      strideA,
                                                        const void*        B,
                                                        hipblasDatatype_t  bType,
                                                        int                ldb,
                                                        hipblasStride      strideB,
                                                        const void*        beta,
                                                        void*              C,
                                                        hipblasDatatype_t  cType,
                                                        int                ldc,
                                                        hipblasStride      strideC,
                                                        int                batchCount,
                                                        hipblasDatatype_t  computeType,
                                                        hipblasGemmAlgo_t  algo)

            hipblasStatus_t hipblasGemmStridedBatchedExWithFlags(hipblasHandle_t      handle,
                                                                 hipblasOperation_t   transA,
                                                                 hipblasOperation_t   transB,
                                                                 int                  m,
                                                                 int                  n,
                                                                 int                  k,
                                                                 const void*          alpha,
                                                                 const void*          A,
                                                                 hipblasDatatype_t    aType,
                                                                 int                  lda,
                                                                 hipblasStride        strideA,
                                                                 const void*          B,
                                                                 hipblasDatatype_t    bType,
                                                                 int                  ldb,
                                                                 hipblasStride        strideB,
                                                                 const void*          beta,
                                                                 void*                C,
                                                                 hipblasDatatype_t    cType,
                                                                 int                  ldc,
                                                                 hipblasStride        strideC,
                                                                 int                  batchCount,
                                                                 hipblasDatatype_t    computeType,
                                                                 hipblasGemmAlgo_t    algo,
                                                                 hipblasGemmFlags_t   flags)

        `~.endif`

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`) -- *IN*:
            [hipblasHandle_t]
            handle to the hipblas library context queue.

        transA (`~.hipblasOperation_t`) -- *IN*:
            [hipblasOperation_t]
            specifies the form of op( A ).

        transB (`~.hipblasOperation_t`) -- *IN*:
            [hipblasOperation_t]
            specifies the form of op( B ).

        m (`~.int`) -- *IN*:
            [int]
            matrix dimension m.

        n (`~.int`) -- *IN*:
            [int]
            matrix dimension n.

        k (`~.int`) -- *IN*:
            [int]
            matrix dimension k.

        alpha (`~.hip._util.types.Pointer`/`~.object`) -- *IN*:
            [const void *]
            device pointer or host pointer specifying the scalar alpha. Same datatype as computeType.

        A (`~.hip._util.types.Pointer`/`~.object`) -- *IN*:
            [void *]
            device pointer pointing to first matrix A_1.

        aType (`~.hipblasDatatype_t`) -- *IN*:
            [hipblasDatatype_t] [DEPRECATED]
                      specifies the datatype of each matrix A_i.

            [hipDataType]
                      specifies the datatype of each matrix A_i.

        lda (`~.int`) -- *IN*:
            [int]
            specifies the leading dimension of each A_i.

        strideA (`~.int`) -- *IN*:
            [hipblasStride]
            specifies stride from start of one A_i matrix to the next A_(i + 1).

        B (`~.hip._util.types.Pointer`/`~.object`) -- *IN*:
            [void *]
            device pointer pointing to first matrix B_1.

        bType (`~.hipblasDatatype_t`) -- *IN*:
            [hipblasDatatype_t] [DEPRECATED]
                      specifies the datatype of each matrix B_i.

            [hipDataType]
                      specifies the datatype of each matrix B_i.

        ldb (`~.int`) -- *IN*:
            [int]
            specifies the leading dimension of each B_i.

        strideB (`~.int`) -- *IN*:
            [hipblasStride]
            specifies stride from start of one B_i matrix to the next B_(i + 1).

        beta (`~.hip._util.types.Pointer`/`~.object`) -- *IN*:
            [const void *]
            device pointer or host pointer specifying the scalar beta. Same datatype as computeType.

        C (`~.hip._util.types.Pointer`/`~.object`) -- *IN*:
            [void *]
            device pointer pointing to first matrix C_1.

        cType (`~.hipblasDatatype_t`) -- *IN*:
            [hipblasDatatype_t] [DEPRECATED]
                      specifies the datatype of each matrix C_i.

            [hipDataType]
                      specifies the datatype of each matrix C_i.

        ldc (`~.int`) -- *IN*:
            [int]
            specifies the leading dimension of each C_i.

        strideC (`~.int`) -- *IN*:
            [hipblasStride]
            specifies stride from start of one C_i matrix to the next C_(i + 1).

        batchCount (`~.int`) -- *IN*:
            [int]
            number of gemm operations in the batch.

        computeType (`~.hipblasDatatype_t`) -- *IN*:
            [hipblasDatatype_t] [DEPRECATED]
                      specifies the datatype of computation.

            [hipblasComputeType_t]
                      specifies the datatype of computation.

        algo (`~.hipblasGemmAlgo_t`) -- *IN*:
            [hipblasGemmAlgo_t]
            enumerant specifying the algorithm type.
    """
    if not isinstance(transA,_hipblasOperation_t__Base):
        raise TypeError("argument 'transA' must be of type '_hipblasOperation_t__Base'")                    
    if not isinstance(transB,_hipblasOperation_t__Base):
        raise TypeError("argument 'transB' must be of type '_hipblasOperation_t__Base'")                    
    if not isinstance(aType,_hipblasDatatype_t__Base):
        raise TypeError("argument 'aType' must be of type '_hipblasDatatype_t__Base'")                    
    if not isinstance(bType,_hipblasDatatype_t__Base):
        raise TypeError("argument 'bType' must be of type '_hipblasDatatype_t__Base'")                    
    if not isinstance(cType,_hipblasDatatype_t__Base):
        raise TypeError("argument 'cType' must be of type '_hipblasDatatype_t__Base'")                    
    if not isinstance(computeType,_hipblasDatatype_t__Base):
        raise TypeError("argument 'computeType' must be of type '_hipblasDatatype_t__Base'")                    
    if not isinstance(algo,_hipblasGemmAlgo_t__Base):
        raise TypeError("argument 'algo' must be of type '_hipblasGemmAlgo_t__Base'")
    _hipblasGemmStridedBatchedEx__retval = hipblasStatus_t(chipblas.hipblasGemmStridedBatchedEx(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,transA.value,transB.value,m,n,k,
        <const void *>hip._util.types.Pointer.fromPyobj(alpha)._ptr,
        <const void *>hip._util.types.Pointer.fromPyobj(A)._ptr,aType.value,lda,strideA,
        <const void *>hip._util.types.Pointer.fromPyobj(B)._ptr,bType.value,ldb,strideB,
        <const void *>hip._util.types.Pointer.fromPyobj(beta)._ptr,
        <void *>hip._util.types.Pointer.fromPyobj(C)._ptr,cType.value,ldc,strideC,batchCount,computeType.value,algo.value))
    return (_hipblasGemmStridedBatchedEx__retval,)


@cython.embedsignature(True)
def hipblasGemmStridedBatchedEx_v2(object handle, object transA, object transB, int m, int n, int k, object alpha, object A, object aType, int lda, long strideA, object B, object bType, int ldb, long strideB, object beta, object C, object cType, int ldc, long strideC, int batchCount, object computeType, object algo):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        transA (`~.hipblasOperation_t`):
            (undocumented)

        transB (`~.hipblasOperation_t`):
            (undocumented)

        m (`~.int`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        k (`~.int`):
            (undocumented)

        alpha (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        A (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        aType (`~.hipDataType`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        strideA (`~.int`):
            (undocumented)

        B (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        bType (`~.hipDataType`):
            (undocumented)

        ldb (`~.int`):
            (undocumented)

        strideB (`~.int`):
            (undocumented)

        beta (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        C (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        cType (`~.hipDataType`):
            (undocumented)

        ldc (`~.int`):
            (undocumented)

        strideC (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)

        computeType (`~.hipblasComputeType_t`):
            (undocumented)

        algo (`~.hipblasGemmAlgo_t`):
            (undocumented)
    """
    if not isinstance(transA,_hipblasOperation_t__Base):
        raise TypeError("argument 'transA' must be of type '_hipblasOperation_t__Base'")                    
    if not isinstance(transB,_hipblasOperation_t__Base):
        raise TypeError("argument 'transB' must be of type '_hipblasOperation_t__Base'")                    
    if not isinstance(aType,_hipDataType__Base):
        raise TypeError("argument 'aType' must be of type '_hipDataType__Base'")                    
    if not isinstance(bType,_hipDataType__Base):
        raise TypeError("argument 'bType' must be of type '_hipDataType__Base'")                    
    if not isinstance(cType,_hipDataType__Base):
        raise TypeError("argument 'cType' must be of type '_hipDataType__Base'")                    
    if not isinstance(computeType,_hipblasComputeType_t__Base):
        raise TypeError("argument 'computeType' must be of type '_hipblasComputeType_t__Base'")                    
    if not isinstance(algo,_hipblasGemmAlgo_t__Base):
        raise TypeError("argument 'algo' must be of type '_hipblasGemmAlgo_t__Base'")
    _hipblasGemmStridedBatchedEx_v2__retval = hipblasStatus_t(chipblas.hipblasGemmStridedBatchedEx_v2(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,transA.value,transB.value,m,n,k,
        <const void *>hip._util.types.Pointer.fromPyobj(alpha)._ptr,
        <const void *>hip._util.types.Pointer.fromPyobj(A)._ptr,aType.value,lda,strideA,
        <const void *>hip._util.types.Pointer.fromPyobj(B)._ptr,bType.value,ldb,strideB,
        <const void *>hip._util.types.Pointer.fromPyobj(beta)._ptr,
        <void *>hip._util.types.Pointer.fromPyobj(C)._ptr,cType.value,ldc,strideC,batchCount,computeType.value,algo.value))
    return (_hipblasGemmStridedBatchedEx_v2__retval,)


@cython.embedsignature(True)
def hipblasGemmStridedBatchedExWithFlags(object handle, object transA, object transB, int m, int n, int k, object alpha, object A, object aType, int lda, long strideA, object B, object bType, int ldb, long strideB, object beta, object C, object cType, int ldc, long strideC, int batchCount, object computeType, object algo, object flags):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        transA (`~.hipblasOperation_t`):
            (undocumented)

        transB (`~.hipblasOperation_t`):
            (undocumented)

        m (`~.int`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        k (`~.int`):
            (undocumented)

        alpha (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        A (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        aType (`~.hipblasDatatype_t`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        strideA (`~.int`):
            (undocumented)

        B (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        bType (`~.hipblasDatatype_t`):
            (undocumented)

        ldb (`~.int`):
            (undocumented)

        strideB (`~.int`):
            (undocumented)

        beta (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        C (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        cType (`~.hipblasDatatype_t`):
            (undocumented)

        ldc (`~.int`):
            (undocumented)

        strideC (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)

        computeType (`~.hipblasDatatype_t`):
            (undocumented)

        algo (`~.hipblasGemmAlgo_t`):
            (undocumented)

        flags (`~.hipblasGemmFlags_t`):
            (undocumented)
    """
    if not isinstance(transA,_hipblasOperation_t__Base):
        raise TypeError("argument 'transA' must be of type '_hipblasOperation_t__Base'")                    
    if not isinstance(transB,_hipblasOperation_t__Base):
        raise TypeError("argument 'transB' must be of type '_hipblasOperation_t__Base'")                    
    if not isinstance(aType,_hipblasDatatype_t__Base):
        raise TypeError("argument 'aType' must be of type '_hipblasDatatype_t__Base'")                    
    if not isinstance(bType,_hipblasDatatype_t__Base):
        raise TypeError("argument 'bType' must be of type '_hipblasDatatype_t__Base'")                    
    if not isinstance(cType,_hipblasDatatype_t__Base):
        raise TypeError("argument 'cType' must be of type '_hipblasDatatype_t__Base'")                    
    if not isinstance(computeType,_hipblasDatatype_t__Base):
        raise TypeError("argument 'computeType' must be of type '_hipblasDatatype_t__Base'")                    
    if not isinstance(algo,_hipblasGemmAlgo_t__Base):
        raise TypeError("argument 'algo' must be of type '_hipblasGemmAlgo_t__Base'")                    
    if not isinstance(flags,_hipblasGemmFlags_t__Base):
        raise TypeError("argument 'flags' must be of type '_hipblasGemmFlags_t__Base'")
    _hipblasGemmStridedBatchedExWithFlags__retval = hipblasStatus_t(chipblas.hipblasGemmStridedBatchedExWithFlags(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,transA.value,transB.value,m,n,k,
        <const void *>hip._util.types.Pointer.fromPyobj(alpha)._ptr,
        <const void *>hip._util.types.Pointer.fromPyobj(A)._ptr,aType.value,lda,strideA,
        <const void *>hip._util.types.Pointer.fromPyobj(B)._ptr,bType.value,ldb,strideB,
        <const void *>hip._util.types.Pointer.fromPyobj(beta)._ptr,
        <void *>hip._util.types.Pointer.fromPyobj(C)._ptr,cType.value,ldc,strideC,batchCount,computeType.value,algo.value,flags.value))
    return (_hipblasGemmStridedBatchedExWithFlags__retval,)


@cython.embedsignature(True)
def hipblasGemmStridedBatchedExWithFlags_v2(object handle, object transA, object transB, int m, int n, int k, object alpha, object A, object aType, int lda, long strideA, object B, object bType, int ldb, long strideB, object beta, object C, object cType, int ldc, long strideC, int batchCount, object computeType, object algo, object flags):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        transA (`~.hipblasOperation_t`):
            (undocumented)

        transB (`~.hipblasOperation_t`):
            (undocumented)

        m (`~.int`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        k (`~.int`):
            (undocumented)

        alpha (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        A (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        aType (`~.hipDataType`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        strideA (`~.int`):
            (undocumented)

        B (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        bType (`~.hipDataType`):
            (undocumented)

        ldb (`~.int`):
            (undocumented)

        strideB (`~.int`):
            (undocumented)

        beta (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        C (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        cType (`~.hipDataType`):
            (undocumented)

        ldc (`~.int`):
            (undocumented)

        strideC (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)

        computeType (`~.hipblasComputeType_t`):
            (undocumented)

        algo (`~.hipblasGemmAlgo_t`):
            (undocumented)

        flags (`~.hipblasGemmFlags_t`):
            (undocumented)
    """
    if not isinstance(transA,_hipblasOperation_t__Base):
        raise TypeError("argument 'transA' must be of type '_hipblasOperation_t__Base'")                    
    if not isinstance(transB,_hipblasOperation_t__Base):
        raise TypeError("argument 'transB' must be of type '_hipblasOperation_t__Base'")                    
    if not isinstance(aType,_hipDataType__Base):
        raise TypeError("argument 'aType' must be of type '_hipDataType__Base'")                    
    if not isinstance(bType,_hipDataType__Base):
        raise TypeError("argument 'bType' must be of type '_hipDataType__Base'")                    
    if not isinstance(cType,_hipDataType__Base):
        raise TypeError("argument 'cType' must be of type '_hipDataType__Base'")                    
    if not isinstance(computeType,_hipblasComputeType_t__Base):
        raise TypeError("argument 'computeType' must be of type '_hipblasComputeType_t__Base'")                    
    if not isinstance(algo,_hipblasGemmAlgo_t__Base):
        raise TypeError("argument 'algo' must be of type '_hipblasGemmAlgo_t__Base'")                    
    if not isinstance(flags,_hipblasGemmFlags_t__Base):
        raise TypeError("argument 'flags' must be of type '_hipblasGemmFlags_t__Base'")
    _hipblasGemmStridedBatchedExWithFlags_v2__retval = hipblasStatus_t(chipblas.hipblasGemmStridedBatchedExWithFlags_v2(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,transA.value,transB.value,m,n,k,
        <const void *>hip._util.types.Pointer.fromPyobj(alpha)._ptr,
        <const void *>hip._util.types.Pointer.fromPyobj(A)._ptr,aType.value,lda,strideA,
        <const void *>hip._util.types.Pointer.fromPyobj(B)._ptr,bType.value,ldb,strideB,
        <const void *>hip._util.types.Pointer.fromPyobj(beta)._ptr,
        <void *>hip._util.types.Pointer.fromPyobj(C)._ptr,cType.value,ldc,strideC,batchCount,computeType.value,algo.value,flags.value))
    return (_hipblasGemmStridedBatchedExWithFlags_v2__retval,)


@cython.embedsignature(True)
def hipblasTrsmEx(object handle, object side, object uplo, object transA, object diag, int m, int n, object alpha, object A, int lda, object B, int ldb, object invA, int invAsize, object computeType):
    r"""(No short description, might be part of a group.)

    BLAS EX API

    trsmEx solves

    op(A)*X = alpha*B or X*op(A) = alpha*B,

    where alpha is a scalar, X and B are m by n matrices,
    A is triangular matrix and op(A) is one of

        op( A ) = A   or   op( A ) = A^T   or   op( A ) = A^H.

    The matrix X is overwritten on B.

    This function gives the user the ability to reuse the invA matrix between runs.
    If invA == NULL, hipblasTrsmEx will automatically calculate invA on every run.

    Setting up invA:
    The accepted invA matrix consists of the packed 128x128 inverses of the diagonal blocks of
    matrix A, followed by any smaller diagonal block that remains.
    To set up invA it is recommended that hipblasTrtriBatched be used with matrix A as the input.

    Device memory of size 128 x k should be allocated for invA ahead of time, where k is m when
    HIPBLAS_SIDE_LEFT and is n when HIPBLAS_SIDE_RIGHT. The actual number of elements in invA
    should be passed as invAsize.

    To begin, hipblasTrtriBatched must be called on the full 128x128 sized diagonal blocks of
    matrix A. Below are the restricted parameters:
      - n = 128
      - ldinvA = 128
      - stride_invA = 128x128
      - batchCount = k / 128,

    Then any remaining block may be added:
      - n = k % 128
      - invA = invA + stride_invA * previousBatchCount
      - ldinvA = 128
      - batchCount = 1

    With HIPBLAS_V2 define, hipblasTrsmEx accepts hipDataType for computeType rather than
    hipblasDatatype_t. hipblasTrsmEx will only accept hipDataType in a future release.

        `~.ifdef` HIPBLAS_V2 // available in hipBLAS version 2.0.0 and later with -DHIPBLAS_V2

            hipblasStatus_t hipblasTrsmEx(hipblasHandle_t    handle,
                                          hipblasSideMode_t  side,
                                          hipblasFillMode_t  uplo,
                                          hipblasOperation_t transA,
                                          hipblasDiagType_t  diag,
                                          int                m,
                                          int                n,
                                          const void*        alpha,
                                          void*              A,
                                          int                lda,
                                          void*              B,
                                          int                ldb,
                                          const void*        invA,
                                          int                invAsize,
                                          hipDataType        computeType)

        `~.else` // [DEPRECATED]

            hipblasStatus_t hipblasTrsmEx(hipblasHandle_t    handle,
                                          hipblasSideMode_t  side,
                                          hipblasFillMode_t  uplo,
                                          hipblasOperation_t transA,
                                          hipblasDiagType_t  diag,
                                          int                m,
                                          int                n,
                                          const void*        alpha,
                                          void*              A,
                                          int                lda,
                                          void*              B,
                                          int                ldb,
                                          const void*        invA,
                                          int                invAsize,
                                          hipblasDatatype_t  computeType)

        `~.endif`

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`) -- *IN*:
            [hipblasHandle_t]
            handle to the hipblas library context queue.

        side (`~.hipblasSideMode_t`) -- *IN*:
            [hipblasSideMode_t]
            HIPBLAS_SIDE_LEFT:       op(A)*X = alpha*B.
            HIPBLAS_SIDE_RIGHT:      X*op(A) = alpha*B.

        uplo (`~.hipblasFillMode_t`) -- *IN*:
            [hipblasFillMode_t]
            HIPBLAS_FILL_MODE_UPPER:  A is an upper triangular matrix.
            HIPBLAS_FILL_MODE_LOWER:  A is a lower triangular matrix.

        transA (`~.hipblasOperation_t`) -- *IN*:
            [hipblasOperation_t]
            HIPBLAS_OP_N: op(A) = A.
            HIPBLAS_OP_T: op(A) = A^T.
            HIPBLAS_ON_C: op(A) = A^H.

        diag (`~.hipblasDiagType_t`) -- *IN*:
            [hipblasDiagType_t]
            HIPBLAS_DIAG_UNIT:     A is assumed to be unit triangular.
            HIPBLAS_DIAG_NON_UNIT:  A is not assumed to be unit triangular.

        m (`~.int`) -- *IN*:
            [int]
            m specifies the number of rows of B. m >= 0.

        n (`~.int`) -- *IN*:
            [int]
            n specifies the number of columns of B. n >= 0.

        alpha (`~.hip._util.types.Pointer`/`~.object`) -- *IN*:
            [void *]
            device pointer or host pointer specifying the scalar alpha. When alpha is
            &zero then A is not referenced, and B need not be set before
            entry.

        A (`~.hip._util.types.Pointer`/`~.object`) -- *IN*:
            [void *]
            device pointer storing matrix A.
            of dimension ( lda, k ), where k is m
            when HIPBLAS_SIDE_LEFT and
            is n when HIPBLAS_SIDE_RIGHT
            only the upper/lower triangular part is accessed.

        lda (`~.int`) -- *IN*:
            [int]
            lda specifies the first dimension of A.
            if side = HIPBLAS_SIDE_LEFT,  lda >= max( 1, m ),
            if side = HIPBLAS_SIDE_RIGHT, lda >= max( 1, n ).

        B (`~.hip._util.types.Pointer`/`~.object`) -- *IN,OUT*:
            [void *]
            device pointer storing matrix B.
            B is of dimension ( ldb, n ).
            Before entry, the leading m by n part of the array B must
            contain the right-hand side matrix B, and on exit is
            overwritten by the solution matrix X.

        ldb (`~.int`) -- *IN*:
            [int]
            ldb specifies the first dimension of B. ldb >= max( 1, m ).

        invA (`~.hip._util.types.Pointer`/`~.object`) -- *IN*:
            [void *]
            device pointer storing the inverse diagonal blocks of A.
            invA is of dimension ( ld_invA, k ), where k is m
            when HIPBLAS_SIDE_LEFT and
            is n when HIPBLAS_SIDE_RIGHT.
            ld_invA must be equal to 128.

        invAsize (`~.int`) -- *IN*:
            [int]
            invAsize specifies the number of elements of device memory in invA.

        computeType (`~.hipblasDatatype_t`) -- *IN*:
            [hipblasDatatype_t] [DEPRECATED]
                    specifies the datatype of computation.

            [hipDataType]
                    specifies the datatype of computation.
    """
    if not isinstance(side,_hipblasSideMode_t__Base):
        raise TypeError("argument 'side' must be of type '_hipblasSideMode_t__Base'")                    
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")                    
    if not isinstance(transA,_hipblasOperation_t__Base):
        raise TypeError("argument 'transA' must be of type '_hipblasOperation_t__Base'")                    
    if not isinstance(diag,_hipblasDiagType_t__Base):
        raise TypeError("argument 'diag' must be of type '_hipblasDiagType_t__Base'")                    
    if not isinstance(computeType,_hipblasDatatype_t__Base):
        raise TypeError("argument 'computeType' must be of type '_hipblasDatatype_t__Base'")
    _hipblasTrsmEx__retval = hipblasStatus_t(chipblas.hipblasTrsmEx(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,side.value,uplo.value,transA.value,diag.value,m,n,
        <const void *>hip._util.types.Pointer.fromPyobj(alpha)._ptr,
        <void *>hip._util.types.Pointer.fromPyobj(A)._ptr,lda,
        <void *>hip._util.types.Pointer.fromPyobj(B)._ptr,ldb,
        <const void *>hip._util.types.Pointer.fromPyobj(invA)._ptr,invAsize,computeType.value))
    return (_hipblasTrsmEx__retval,)


@cython.embedsignature(True)
def hipblasTrsmEx_v2(object handle, object side, object uplo, object transA, object diag, int m, int n, object alpha, object A, int lda, object B, int ldb, object invA, int invAsize, object computeType):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        side (`~.hipblasSideMode_t`):
            (undocumented)

        uplo (`~.hipblasFillMode_t`):
            (undocumented)

        transA (`~.hipblasOperation_t`):
            (undocumented)

        diag (`~.hipblasDiagType_t`):
            (undocumented)

        m (`~.int`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        alpha (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        A (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        B (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        ldb (`~.int`):
            (undocumented)

        invA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        invAsize (`~.int`):
            (undocumented)

        computeType (`~.hipDataType`):
            (undocumented)
    """
    if not isinstance(side,_hipblasSideMode_t__Base):
        raise TypeError("argument 'side' must be of type '_hipblasSideMode_t__Base'")                    
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")                    
    if not isinstance(transA,_hipblasOperation_t__Base):
        raise TypeError("argument 'transA' must be of type '_hipblasOperation_t__Base'")                    
    if not isinstance(diag,_hipblasDiagType_t__Base):
        raise TypeError("argument 'diag' must be of type '_hipblasDiagType_t__Base'")                    
    if not isinstance(computeType,_hipDataType__Base):
        raise TypeError("argument 'computeType' must be of type '_hipDataType__Base'")
    _hipblasTrsmEx_v2__retval = hipblasStatus_t(chipblas.hipblasTrsmEx_v2(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,side.value,uplo.value,transA.value,diag.value,m,n,
        <const void *>hip._util.types.Pointer.fromPyobj(alpha)._ptr,
        <void *>hip._util.types.Pointer.fromPyobj(A)._ptr,lda,
        <void *>hip._util.types.Pointer.fromPyobj(B)._ptr,ldb,
        <const void *>hip._util.types.Pointer.fromPyobj(invA)._ptr,invAsize,computeType.value))
    return (_hipblasTrsmEx_v2__retval,)


@cython.embedsignature(True)
def hipblasTrsmBatchedEx(object handle, object side, object uplo, object transA, object diag, int m, int n, object alpha, object A, int lda, object B, int ldb, int batchCount, object invA, int invAsize, object computeType):
    r"""(No short description, might be part of a group.)

    BLAS EX API

    trsmBatchedEx solves

    op(A_i)*X_i = alpha*B_i or X_i*op(A_i) = alpha*B_i,

    for i = 1, ..., batchCount; and where alpha is a scalar, X and B are arrays of m by n matrices,
    A is an array of triangular matrix and each op(A_i) is one of

        op( A_i ) = A_i   or   op( A_i ) = A_i^T   or   op( A_i ) = A_i^H.

    Each matrix X_i is overwritten on B_i.

    This function gives the user the ability to reuse the invA matrix between runs.
    If invA == NULL, hipblasTrsmBatchedEx will automatically calculate each invA_i on every run.

    Setting up invA:
    Each accepted invA_i matrix consists of the packed 128x128 inverses of the diagonal blocks of
    matrix A_i, followed by any smaller diagonal block that remains.
    To set up each invA_i it is recommended that hipblasTrtriBatched be used with matrix A_i as the input.
    invA is an array of pointers of batchCount length holding each invA_i.

    Device memory of size 128 x k should be allocated for each invA_i ahead of time, where k is m when
    HIPBLAS_SIDE_LEFT and is n when HIPBLAS_SIDE_RIGHT. The actual number of elements in each invA_i
    should be passed as invAsize.

    To begin, hipblasTrtriBatched must be called on the full 128x128 sized diagonal blocks of each
    matrix A_i. Below are the restricted parameters:
      - n = 128
      - ldinvA = 128
      - stride_invA = 128x128
      - batchCount = k / 128,

    Then any remaining block may be added:
      - n = k % 128
      - invA = invA + stride_invA * previousBatchCount
      - ldinvA = 128
      - batchCount = 1

    With HIPBLAS_V2 define, hipblasTrsmBatchedEx accepts hipDataType for computeType rather than
    hipblasDatatype_t. hipblasTrsmBatchedEx will only accept hipDataType in a future release.

        `~.ifdef` HIPBLAS_V2 // available in hipBLAS version 2.0.0 and later with -DHIPBLAS_V2

            hipblasStatus_t hipblasTrsmBatchedEx(hipblasHandle_t    handle,
                                                 hipblasSideMode_t  side,
                                                 hipblasFillMode_t  uplo,
                                                 hipblasOperation_t transA,
                                                 hipblasDiagType_t  diag,
                                                 int                m,
                                                 int                n,
                                                 const void*        alpha,
                                                 void*              A,
                                                 int                lda,
                                                 void*              B,
                                                 int                ldb,
                                                 int                batchCount,
                                                 const void*        invA,
                                                 int                invAsize,
                                                 hipDataType        computeType)

        `~.else` // [DEPRECATED]

            hipblasStatus_t hipblasTrsmBatchedEx(hipblasHandle_t    handle,
                                                 hipblasSideMode_t  side,
                                                 hipblasFillMode_t  uplo,
                                                 hipblasOperation_t transA,
                                                 hipblasDiagType_t  diag,
                                                 int                m,
                                                 int                n,
                                                 const void*        alpha,
                                                 void*              A,
                                                 int                lda,
                                                 void*              B,
                                                 int                ldb,
                                                 int                batchCount,
                                                 const void*        invA,
                                                 int                invAsize,
                                                 hipblasDatatype_t  computeType)

        `~.endif`

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`) -- *IN*:
            [hipblasHandle_t]
            handle to the hipblas library context queue.

        side (`~.hipblasSideMode_t`) -- *IN*:
            [hipblasSideMode_t]
            HIPBLAS_SIDE_LEFT:       op(A)*X = alpha*B.
            HIPBLAS_SIDE_RIGHT:      X*op(A) = alpha*B.

        uplo (`~.hipblasFillMode_t`) -- *IN*:
            [hipblasFillMode_t]
            HIPBLAS_FILL_MODE_UPPER:  each A_i is an upper triangular matrix.
            HIPBLAS_FILL_MODE_LOWER:  each A_i is a lower triangular matrix.

        transA (`~.hipblasOperation_t`) -- *IN*:
            [hipblasOperation_t]
            HIPBLAS_OP_N: op(A) = A.
            HIPBLAS_OP_T: op(A) = A^T.
            HIPBLAS_OP_C: op(A) = A^H.

        diag (`~.hipblasDiagType_t`) -- *IN*:
            [hipblasDiagType_t]
            HIPBLAS_DIAG_UNIT:     each A_i is assumed to be unit triangular.
            HIPBLAS_DIAG_NON_UNIT:  each A_i is not assumed to be unit triangular.

        m (`~.int`) -- *IN*:
            [int]
            m specifies the number of rows of each B_i. m >= 0.

        n (`~.int`) -- *IN*:
            [int]
            n specifies the number of columns of each B_i. n >= 0.

        alpha (`~.hip._util.types.Pointer`/`~.object`) -- *IN*:
            [void *]
            device pointer or host pointer alpha specifying the scalar alpha. When alpha is
            &zero then A is not referenced, and B need not be set before
            entry.

        A (`~.hip._util.types.Pointer`/`~.object`) -- *IN*:
            [void *]
            device array of device pointers storing each matrix A_i.
            each A_i is of dimension ( lda, k ), where k is m
            when HIPBLAS_SIDE_LEFT and
            is n when HIPBLAS_SIDE_RIGHT
            only the upper/lower triangular part is accessed.

        lda (`~.int`) -- *IN*:
            [int]
            lda specifies the first dimension of each A_i.
            if side = HIPBLAS_SIDE_LEFT,  lda >= max( 1, m ),
            if side = HIPBLAS_SIDE_RIGHT, lda >= max( 1, n ).

        B (`~.hip._util.types.Pointer`/`~.object`) -- *IN,OUT*:
            [void *]
            device array of device pointers storing each matrix B_i.
            each B_i is of dimension ( ldb, n ).
            Before entry, the leading m by n part of the array B_i must
            contain the right-hand side matrix B_i, and on exit is
            overwritten by the solution matrix X_i

        ldb (`~.int`) -- *IN*:
            [int]
            ldb specifies the first dimension of each B_i. ldb >= max( 1, m ).

        batchCount (`~.int`) -- *IN*:
            [int]
            specifies how many batches.

        invA (`~.hip._util.types.Pointer`/`~.object`) -- *IN*:
            [void *]
            device array of device pointers storing the inverse diagonal blocks of each A_i.
            each invA_i is of dimension ( ld_invA, k ), where k is m
            when HIPBLAS_SIDE_LEFT and
            is n when HIPBLAS_SIDE_RIGHT.
            ld_invA must be equal to 128.

        invAsize (`~.int`) -- *IN*:
            [int]
            invAsize specifies the number of elements of device memory in each invA_i.

        computeType (`~.hipblasDatatype_t`) -- *IN*:
            [hipblasDatatype_t] [DEPRECATED]
                    specifies the datatype of computation.

            [hipDataType]
                    specifies the datatype of computation.
    """
    if not isinstance(side,_hipblasSideMode_t__Base):
        raise TypeError("argument 'side' must be of type '_hipblasSideMode_t__Base'")                    
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")                    
    if not isinstance(transA,_hipblasOperation_t__Base):
        raise TypeError("argument 'transA' must be of type '_hipblasOperation_t__Base'")                    
    if not isinstance(diag,_hipblasDiagType_t__Base):
        raise TypeError("argument 'diag' must be of type '_hipblasDiagType_t__Base'")                    
    if not isinstance(computeType,_hipblasDatatype_t__Base):
        raise TypeError("argument 'computeType' must be of type '_hipblasDatatype_t__Base'")
    _hipblasTrsmBatchedEx__retval = hipblasStatus_t(chipblas.hipblasTrsmBatchedEx(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,side.value,uplo.value,transA.value,diag.value,m,n,
        <const void *>hip._util.types.Pointer.fromPyobj(alpha)._ptr,
        <void *>hip._util.types.Pointer.fromPyobj(A)._ptr,lda,
        <void *>hip._util.types.Pointer.fromPyobj(B)._ptr,ldb,batchCount,
        <const void *>hip._util.types.Pointer.fromPyobj(invA)._ptr,invAsize,computeType.value))
    return (_hipblasTrsmBatchedEx__retval,)


@cython.embedsignature(True)
def hipblasTrsmBatchedEx_v2(object handle, object side, object uplo, object transA, object diag, int m, int n, object alpha, object A, int lda, object B, int ldb, int batchCount, object invA, int invAsize, object computeType):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        side (`~.hipblasSideMode_t`):
            (undocumented)

        uplo (`~.hipblasFillMode_t`):
            (undocumented)

        transA (`~.hipblasOperation_t`):
            (undocumented)

        diag (`~.hipblasDiagType_t`):
            (undocumented)

        m (`~.int`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        alpha (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        A (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        B (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        ldb (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)

        invA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        invAsize (`~.int`):
            (undocumented)

        computeType (`~.hipDataType`):
            (undocumented)
    """
    if not isinstance(side,_hipblasSideMode_t__Base):
        raise TypeError("argument 'side' must be of type '_hipblasSideMode_t__Base'")                    
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")                    
    if not isinstance(transA,_hipblasOperation_t__Base):
        raise TypeError("argument 'transA' must be of type '_hipblasOperation_t__Base'")                    
    if not isinstance(diag,_hipblasDiagType_t__Base):
        raise TypeError("argument 'diag' must be of type '_hipblasDiagType_t__Base'")                    
    if not isinstance(computeType,_hipDataType__Base):
        raise TypeError("argument 'computeType' must be of type '_hipDataType__Base'")
    _hipblasTrsmBatchedEx_v2__retval = hipblasStatus_t(chipblas.hipblasTrsmBatchedEx_v2(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,side.value,uplo.value,transA.value,diag.value,m,n,
        <const void *>hip._util.types.Pointer.fromPyobj(alpha)._ptr,
        <void *>hip._util.types.Pointer.fromPyobj(A)._ptr,lda,
        <void *>hip._util.types.Pointer.fromPyobj(B)._ptr,ldb,batchCount,
        <const void *>hip._util.types.Pointer.fromPyobj(invA)._ptr,invAsize,computeType.value))
    return (_hipblasTrsmBatchedEx_v2__retval,)


@cython.embedsignature(True)
def hipblasTrsmStridedBatchedEx(object handle, object side, object uplo, object transA, object diag, int m, int n, object alpha, object A, int lda, long strideA, object B, int ldb, long strideB, int batchCount, object invA, int invAsize, long strideInvA, object computeType):
    r"""(No short description, might be part of a group.)

    BLAS EX API

    trsmStridedBatchedEx solves

    op(A_i)*X_i = alpha*B_i or X_i*op(A_i) = alpha*B_i,

    for i = 1, ..., batchCount; and where alpha is a scalar, X and B are strided batched m by n matrices,
    A is a strided batched triangular matrix and op(A_i) is one of

        op( A_i ) = A_i   or   op( A_i ) = A_i^T   or   op( A_i ) = A_i^H.

    Each matrix X_i is overwritten on B_i.

    This function gives the user the ability to reuse each invA_i matrix between runs.
    If invA == NULL, hipblasTrsmStridedBatchedEx will automatically calculate each invA_i on every run.

    Setting up invA:
    Each accepted invA_i matrix consists of the packed 128x128 inverses of the diagonal blocks of
    matrix A_i, followed by any smaller diagonal block that remains.
    To set up invA_i it is recommended that hipblasTrtriBatched be used with matrix A_i as the input.
    invA is a contiguous piece of memory holding each invA_i.

    Device memory of size 128 x k should be allocated for each invA_i ahead of time, where k is m when
    HIPBLAS_SIDE_LEFT and is n when HIPBLAS_SIDE_RIGHT. The actual number of elements in each invA_i
    should be passed as invAsize.

    To begin, hipblasTrtriBatched must be called on the full 128x128 sized diagonal blocks of each
    matrix A_i. Below are the restricted parameters:
      - n = 128
      - ldinvA = 128
      - stride_invA = 128x128
      - batchCount = k / 128,

    Then any remaining block may be added:
      - n = k % 128
      - invA = invA + stride_invA * previousBatchCount
      - ldinvA = 128
      - batchCount = 1

    With HIPBLAS_V2 define, hipblasStridedBatchedTrsmEx accepts hipDataType for computeType rather than
    hipblasDatatype_t. hipblasTrsmStridedBatchedEx will only accept hipDataType in a future release.

        `~.ifdef` HIPBLAS_V2 // available in hipBLAS version 2.0.0 and later with -DHIPBLAS_V2

            hipblasStatus_t hipblasTrsmStridedBatchedEx(hipblasHandle_t    handle,
                                                        hipblasSideMode_t  side,
                                                        hipblasFillMode_t  uplo,
                                                        hipblasOperation_t transA,
                                                        hipblasDiagType_t  diag,
                                                        int                m,
                                                        int                n,
                                                        const void*        alpha,
                                                        void*              A,
                                                        int                lda,
                                                        hipblasStride      strideA,
                                                        void*              B,
                                                        int                ldb,
                                                        hipblasStride      strideB,
                                                        int                batchCount,
                                                        const void*        invA,
                                                        int                invAsize,
                                                        hipblasStride      strideInvA,
                                                        hipDataType        computeType);

        `~.else` // [DEPRECATED]

            hipblasStatus_t hipblasTrsmStridedBatchedEx(hipblasHandle_t    handle,
                                                        hipblasSideMode_t  side,
                                                        hipblasFillMode_t  uplo,
                                                        hipblasOperation_t transA,
                                                        hipblasDiagType_t  diag,
                                                        int                m,
                                                        int                n,
                                                        const void*        alpha,
                                                        void*              A,
                                                        int                lda,
                                                        hipblasStride      strideA,
                                                        void*              B,
                                                        int                ldb,
                                                        hipblasStride      strideB,
                                                        int                batchCount,
                                                        const void*        invA,
                                                        int                invAsize,
                                                        hipblasStride      strideInvA,
                                                        hipblasDatatype_t  computeType)

        `~.endif`

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`) -- *IN*:
            [hipblasHandle_t]
            handle to the hipblas library context queue.

        side (`~.hipblasSideMode_t`) -- *IN*:
            [hipblasSideMode_t]
            HIPBLAS_SIDE_LEFT:       op(A)*X = alpha*B.
            HIPBLAS_SIDE_RIGHT:      X*op(A) = alpha*B.

        uplo (`~.hipblasFillMode_t`) -- *IN*:
            [hipblasFillMode_t]
            HIPBLAS_FILL_MODE_UPPER:  each A_i is an upper triangular matrix.
            HIPBLAS_FILL_MODE_LOWER:  each A_i is a lower triangular matrix.

        transA (`~.hipblasOperation_t`) -- *IN*:
            [hipblasOperation_t]
            HIPBLAS_OP_N: op(A) = A.
            HIPBLAS_OP_T: op(A) = A^T.
            HIPBLAS_OP_C: op(A) = A^H.

        diag (`~.hipblasDiagType_t`) -- *IN*:
            [hipblasDiagType_t]
            HIPBLAS_DIAG_UNIT:     each A_i is assumed to be unit triangular.
            HIPBLAS_DIAG_NON_UNIT:  each A_i is not assumed to be unit triangular.

        m (`~.int`) -- *IN*:
            [int]
            m specifies the number of rows of each B_i. m >= 0.

        n (`~.int`) -- *IN*:
            [int]
            n specifies the number of columns of each B_i. n >= 0.

        alpha (`~.hip._util.types.Pointer`/`~.object`) -- *IN*:
            [void *]
            device pointer or host pointer specifying the scalar alpha. When alpha is
            &zero then A is not referenced, and B need not be set before
            entry.

        A (`~.hip._util.types.Pointer`/`~.object`) -- *IN*:
            [void *]
            device pointer storing matrix A.
            of dimension ( lda, k ), where k is m
            when HIPBLAS_SIDE_LEFT and
            is n when HIPBLAS_SIDE_RIGHT
            only the upper/lower triangular part is accessed.

        lda (`~.int`) -- *IN*:
            [int]
            lda specifies the first dimension of A.
            if side = HIPBLAS_SIDE_LEFT,  lda >= max( 1, m ),
            if side = HIPBLAS_SIDE_RIGHT, lda >= max( 1, n ).

        strideA (`~.int`) -- *IN*:
            [hipblasStride]
            The stride between each A matrix.

        B (`~.hip._util.types.Pointer`/`~.object`) -- *IN,OUT*:
            [void *]
            device pointer pointing to first matrix B_i.
            each B_i is of dimension ( ldb, n ).
            Before entry, the leading m by n part of each array B_i must
            contain the right-hand side of matrix B_i, and on exit is
            overwritten by the solution matrix X_i.

        ldb (`~.int`) -- *IN*:
            [int]
            ldb specifies the first dimension of each B_i. ldb >= max( 1, m ).

        strideB (`~.int`) -- *IN*:
            [hipblasStride]
            The stride between each B_i matrix.

        batchCount (`~.int`) -- *IN*:
            [int]
            specifies how many batches.

        invA (`~.hip._util.types.Pointer`/`~.object`) -- *IN*:
            [void *]
            device pointer storing the inverse diagonal blocks of each A_i.
            invA points to the first invA_1.
            each invA_i is of dimension ( ld_invA, k ), where k is m
            when HIPBLAS_SIDE_LEFT and
            is n when HIPBLAS_SIDE_RIGHT.
            ld_invA must be equal to 128.

        invAsize (`~.int`) -- *IN*:
            [int]
            invAsize specifies the number of elements of device memory in each invA_i.

        strideInvA (`~.int`) -- *IN*:
            [hipblasStride]
            The stride between each invA matrix.

        computeType (`~.hipblasDatatype_t`) -- *IN*:
            [hipblasDatatype_t] [DEPRECATED]
                    specifies the datatype of computation.

            [hipDataType]
                    specifies the datatype of computation.
    """
    if not isinstance(side,_hipblasSideMode_t__Base):
        raise TypeError("argument 'side' must be of type '_hipblasSideMode_t__Base'")                    
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")                    
    if not isinstance(transA,_hipblasOperation_t__Base):
        raise TypeError("argument 'transA' must be of type '_hipblasOperation_t__Base'")                    
    if not isinstance(diag,_hipblasDiagType_t__Base):
        raise TypeError("argument 'diag' must be of type '_hipblasDiagType_t__Base'")                    
    if not isinstance(computeType,_hipblasDatatype_t__Base):
        raise TypeError("argument 'computeType' must be of type '_hipblasDatatype_t__Base'")
    _hipblasTrsmStridedBatchedEx__retval = hipblasStatus_t(chipblas.hipblasTrsmStridedBatchedEx(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,side.value,uplo.value,transA.value,diag.value,m,n,
        <const void *>hip._util.types.Pointer.fromPyobj(alpha)._ptr,
        <void *>hip._util.types.Pointer.fromPyobj(A)._ptr,lda,strideA,
        <void *>hip._util.types.Pointer.fromPyobj(B)._ptr,ldb,strideB,batchCount,
        <const void *>hip._util.types.Pointer.fromPyobj(invA)._ptr,invAsize,strideInvA,computeType.value))
    return (_hipblasTrsmStridedBatchedEx__retval,)


@cython.embedsignature(True)
def hipblasTrsmStridedBatchedEx_v2(object handle, object side, object uplo, object transA, object diag, int m, int n, object alpha, object A, int lda, long strideA, object B, int ldb, long strideB, int batchCount, object invA, int invAsize, long strideInvA, object computeType):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        side (`~.hipblasSideMode_t`):
            (undocumented)

        uplo (`~.hipblasFillMode_t`):
            (undocumented)

        transA (`~.hipblasOperation_t`):
            (undocumented)

        diag (`~.hipblasDiagType_t`):
            (undocumented)

        m (`~.int`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        alpha (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        A (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        strideA (`~.int`):
            (undocumented)

        B (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        ldb (`~.int`):
            (undocumented)

        strideB (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)

        invA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        invAsize (`~.int`):
            (undocumented)

        strideInvA (`~.int`):
            (undocumented)

        computeType (`~.hipDataType`):
            (undocumented)
    """
    if not isinstance(side,_hipblasSideMode_t__Base):
        raise TypeError("argument 'side' must be of type '_hipblasSideMode_t__Base'")                    
    if not isinstance(uplo,_hipblasFillMode_t__Base):
        raise TypeError("argument 'uplo' must be of type '_hipblasFillMode_t__Base'")                    
    if not isinstance(transA,_hipblasOperation_t__Base):
        raise TypeError("argument 'transA' must be of type '_hipblasOperation_t__Base'")                    
    if not isinstance(diag,_hipblasDiagType_t__Base):
        raise TypeError("argument 'diag' must be of type '_hipblasDiagType_t__Base'")                    
    if not isinstance(computeType,_hipDataType__Base):
        raise TypeError("argument 'computeType' must be of type '_hipDataType__Base'")
    _hipblasTrsmStridedBatchedEx_v2__retval = hipblasStatus_t(chipblas.hipblasTrsmStridedBatchedEx_v2(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,side.value,uplo.value,transA.value,diag.value,m,n,
        <const void *>hip._util.types.Pointer.fromPyobj(alpha)._ptr,
        <void *>hip._util.types.Pointer.fromPyobj(A)._ptr,lda,strideA,
        <void *>hip._util.types.Pointer.fromPyobj(B)._ptr,ldb,strideB,batchCount,
        <const void *>hip._util.types.Pointer.fromPyobj(invA)._ptr,invAsize,strideInvA,computeType.value))
    return (_hipblasTrsmStridedBatchedEx_v2__retval,)


@cython.embedsignature(True)
def hipblasAxpyEx(object handle, int n, object alpha, object alphaType, object x, object xType, int incx, object y, object yType, int incy, object executionType):
    r"""BLAS EX API

    axpyEx computes constant alpha multiplied by vector x, plus vector y

    y := alpha * x + y

        - Supported types are determined by the backend. See rocBLAS/cuBLAS documentation.

    With HIPBLAS_V2 define, hipblasAxpyEx accepts hipDataType for alphaType, xType, yType,
    and executionType rather than hipblasDatatype_t. hipblasAxpyEx will only accept hipDataType
    in a future release.

        `~.ifdef` HIPBLAS_V2 // available in hipBLAS version 2.0.0 and later with -DHIPBLAS_V2

            hipblasStatus_t hipblasAxpyEx(hipblasHandle_t handle,
                                          int             n,
                                          const void*     alpha,
                                          hipDataType     alphaType,
                                          const void*     x,
                                          hipDataType     xType,
                                          int             incx,
                                          void*           y,
                                          hipDataType     yType,
                                          int             incy,
                                          hipDataType     executionType)

        `~.else` // [DEPRECATED]

            hipblasStatus_t hipblasAxpyEx(hipblasHandle_t   handle,
                                          int               n,
                                          const void*       alpha,
                                          hipblasDatatype_t alphaType,
                                          const void*       x,
                                          hipblasDatatype_t xType,
                                          int               incx,
                                          void*             y,
                                          hipblasDatatype_t yType,
                                          int               incy,
                                          hipblasDatatype_t executionType)

        `~.endif`

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`) -- *IN*:
            [hipblasHandle_t]
            handle to the hipblas library context queue.

        n (`~.int`) -- *IN*:
            [int]
            the number of elements in x and y.

        alpha (`~.hip._util.types.Pointer`/`~.object`) -- *IN*:
            device pointer or host pointer to specify the scalar alpha.

        alphaType (`~.hipblasDatatype_t`) -- *IN*:
            [hipblasDatatype_t] [DEPRECATED]
                      specifies the datatype of alpha.

            [hipDataType]
                      specifies the datatype of alpha.

        x (`~.hip._util.types.Pointer`/`~.object`) -- *IN*:
            device pointer storing vector x.

        xType (`~.hipblasDatatype_t`) -- *IN*:
            [hipblasDatatype_t] [DEPRECATED]
                      specifies the datatype of vector x.

            [hipDataType]
                      specifies the datatype of vector x.

        incx (`~.int`) -- *IN*:
            [int]
            specifies the increment for the elements of x.

        y (`~.hip._util.types.Pointer`/`~.object`) -- *INOUT*:
            device pointer storing vector y.

        yType (`~.hipblasDatatype_t`) -- *IN*:
            [hipblasDatatype_t] [DEPRECATED]
                      specifies the datatype of vector y.

            [hipDataType]
                      specifies the datatype of vector y.

        incy (`~.int`) -- *IN*:
            [int]
            specifies the increment for the elements of y.

        executionType (`~.hipblasDatatype_t`) -- *IN*:
            [hipblasDatatype_t] [DEPRECATED]
                      specifies the datatype of computation.

            [hipDataType]
                      specifies the datatype of computation.
    """
    if not isinstance(alphaType,_hipblasDatatype_t__Base):
        raise TypeError("argument 'alphaType' must be of type '_hipblasDatatype_t__Base'")                    
    if not isinstance(xType,_hipblasDatatype_t__Base):
        raise TypeError("argument 'xType' must be of type '_hipblasDatatype_t__Base'")                    
    if not isinstance(yType,_hipblasDatatype_t__Base):
        raise TypeError("argument 'yType' must be of type '_hipblasDatatype_t__Base'")                    
    if not isinstance(executionType,_hipblasDatatype_t__Base):
        raise TypeError("argument 'executionType' must be of type '_hipblasDatatype_t__Base'")
    _hipblasAxpyEx__retval = hipblasStatus_t(chipblas.hipblasAxpyEx(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,n,
        <const void *>hip._util.types.Pointer.fromPyobj(alpha)._ptr,alphaType.value,
        <const void *>hip._util.types.Pointer.fromPyobj(x)._ptr,xType.value,incx,
        <void *>hip._util.types.Pointer.fromPyobj(y)._ptr,yType.value,incy,executionType.value))
    return (_hipblasAxpyEx__retval,)


@cython.embedsignature(True)
def hipblasAxpyEx_v2(object handle, int n, object alpha, object alphaType, object x, object xType, int incx, object y, object yType, int incy, object executionType):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        alpha (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        alphaType (`~.hipDataType`):
            (undocumented)

        x (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        xType (`~.hipDataType`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        y (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        yType (`~.hipDataType`):
            (undocumented)

        incy (`~.int`):
            (undocumented)

        executionType (`~.hipDataType`):
            (undocumented)
    """
    if not isinstance(alphaType,_hipDataType__Base):
        raise TypeError("argument 'alphaType' must be of type '_hipDataType__Base'")                    
    if not isinstance(xType,_hipDataType__Base):
        raise TypeError("argument 'xType' must be of type '_hipDataType__Base'")                    
    if not isinstance(yType,_hipDataType__Base):
        raise TypeError("argument 'yType' must be of type '_hipDataType__Base'")                    
    if not isinstance(executionType,_hipDataType__Base):
        raise TypeError("argument 'executionType' must be of type '_hipDataType__Base'")
    _hipblasAxpyEx_v2__retval = hipblasStatus_t(chipblas.hipblasAxpyEx_v2(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,n,
        <const void *>hip._util.types.Pointer.fromPyobj(alpha)._ptr,alphaType.value,
        <const void *>hip._util.types.Pointer.fromPyobj(x)._ptr,xType.value,incx,
        <void *>hip._util.types.Pointer.fromPyobj(y)._ptr,yType.value,incy,executionType.value))
    return (_hipblasAxpyEx_v2__retval,)


@cython.embedsignature(True)
def hipblasAxpyEx_64(object handle, long n, object alpha, object alphaType, object x, object xType, long incx, object y, object yType, long incy, object executionType):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        alpha (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        alphaType (`~.hipblasDatatype_t`):
            (undocumented)

        x (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        xType (`~.hipblasDatatype_t`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        y (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        yType (`~.hipblasDatatype_t`):
            (undocumented)

        incy (`~.int`):
            (undocumented)

        executionType (`~.hipblasDatatype_t`):
            (undocumented)
    """
    if not isinstance(alphaType,_hipblasDatatype_t__Base):
        raise TypeError("argument 'alphaType' must be of type '_hipblasDatatype_t__Base'")                    
    if not isinstance(xType,_hipblasDatatype_t__Base):
        raise TypeError("argument 'xType' must be of type '_hipblasDatatype_t__Base'")                    
    if not isinstance(yType,_hipblasDatatype_t__Base):
        raise TypeError("argument 'yType' must be of type '_hipblasDatatype_t__Base'")                    
    if not isinstance(executionType,_hipblasDatatype_t__Base):
        raise TypeError("argument 'executionType' must be of type '_hipblasDatatype_t__Base'")
    _hipblasAxpyEx_64__retval = hipblasStatus_t(chipblas.hipblasAxpyEx_64(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,n,
        <const void *>hip._util.types.Pointer.fromPyobj(alpha)._ptr,alphaType.value,
        <const void *>hip._util.types.Pointer.fromPyobj(x)._ptr,xType.value,incx,
        <void *>hip._util.types.Pointer.fromPyobj(y)._ptr,yType.value,incy,executionType.value))
    return (_hipblasAxpyEx_64__retval,)


@cython.embedsignature(True)
def hipblasAxpyEx_v2_64(object handle, long n, object alpha, object alphaType, object x, object xType, long incx, object y, object yType, long incy, object executionType):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        alpha (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        alphaType (`~.hipDataType`):
            (undocumented)

        x (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        xType (`~.hipDataType`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        y (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        yType (`~.hipDataType`):
            (undocumented)

        incy (`~.int`):
            (undocumented)

        executionType (`~.hipDataType`):
            (undocumented)
    """
    if not isinstance(alphaType,_hipDataType__Base):
        raise TypeError("argument 'alphaType' must be of type '_hipDataType__Base'")                    
    if not isinstance(xType,_hipDataType__Base):
        raise TypeError("argument 'xType' must be of type '_hipDataType__Base'")                    
    if not isinstance(yType,_hipDataType__Base):
        raise TypeError("argument 'yType' must be of type '_hipDataType__Base'")                    
    if not isinstance(executionType,_hipDataType__Base):
        raise TypeError("argument 'executionType' must be of type '_hipDataType__Base'")
    _hipblasAxpyEx_v2_64__retval = hipblasStatus_t(chipblas.hipblasAxpyEx_v2_64(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,n,
        <const void *>hip._util.types.Pointer.fromPyobj(alpha)._ptr,alphaType.value,
        <const void *>hip._util.types.Pointer.fromPyobj(x)._ptr,xType.value,incx,
        <void *>hip._util.types.Pointer.fromPyobj(y)._ptr,yType.value,incy,executionType.value))
    return (_hipblasAxpyEx_v2_64__retval,)


@cython.embedsignature(True)
def hipblasAxpyBatchedEx(object handle, int n, object alpha, object alphaType, object x, object xType, int incx, object y, object yType, int incy, int batchCount, object executionType):
    r"""BLAS EX API

    axpyBatchedEx computes constant alpha multiplied by vector x, plus vector y over
    a set of batched vectors.

    y := alpha * x + y

        - Supported types are determined by the backend. See rocBLAS/cuBLAS documentation.

    With HIPBLAS_V2 define, hipblasAxpyBatchedEx accepts hipDataType for alphaType, xType, yType,
    and executionType rather than hipblasDatatype_t. hipblasAxpyBatchedEx will only accept hipDataType
    in a future release.

        `~.ifdef` HIPBLAS_V2 // available in hipBLAS version 2.0.0 and later with -DHIPBLAS_V2

            hipblasStatus_t hipblasAxpyBatchedEx(hipblasHandle_t handle,
                                                 int             n,
                                                 const void*     alpha,
                                                 hipDataType     alphaType,
                                                 const void*     x,
                                                 hipDataType     xType,
                                                 int             incx,
                                                 void*           y,
                                                 hipDataType     yType,
                                                 int             incy,
                                                 int             batchCount,
                                                 hipDataType     executionType)

        `~.else` // [DEPRECATED]

            hipblasStatus_t hipblasAxpyBatchedEx(hipblasHandle_t   handle,
                                                 int               n,
                                                 const void*       alpha,
                                                 hipblasDatatype_t alphaType,
                                                 const void*       x,
                                                 hipblasDatatype_t xType,
                                                 int               incx,
                                                 void*             y,
                                                 hipblasDatatype_t yType,
                                                 int               incy,
                                                 int               batchCount,
                                                 hipblasDatatype_t executionType)

        `~.endif`

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`) -- *IN*:
            [hipblasHandle_t]
            handle to the hipblas library context queue.

        n (`~.int`) -- *IN*:
            [int]
            the number of elements in each x_i and y_i.

        alpha (`~.hip._util.types.Pointer`/`~.object`) -- *IN*:
            device pointer or host pointer to specify the scalar alpha.

        alphaType (`~.hipblasDatatype_t`) -- *IN*:
            [hipblasDatatype_t] [DEPRECATED]
                      specifies the datatype of alpha.

            [hipDataType]
                      specifies the datatype of alpha.

        x (`~.hip._util.types.Pointer`/`~.object`) -- *IN*:
            device array of device pointers storing each vector x_i.

        xType (`~.hipblasDatatype_t`) -- *IN*:
            [hipblasDatatype_t] [DEPRECATED]
                      specifies the datatype of each vector x_i.

            [hipDataType]
                      specifies the datatype of each vector x_i.

        incx (`~.int`) -- *IN*:
            [int]
            specifies the increment for the elements of each x_i.

        y (`~.hip._util.types.Pointer`/`~.object`) -- *INOUT*:
            device array of device pointers storing each vector y_i.

        yType (`~.hipblasDatatype_t`) -- *IN*:
            [hipblasDatatype_t] [DEPRECATED]
                      specifies the datatype of each vector y_i.

            [hipDataType]
                      specifies the datatype of each vector y_i.

        incy (`~.int`) -- *IN*:
            [int]
            specifies the increment for the elements of each y_i.

        batchCount (`~.int`) -- *IN*:
            [int]
            number of instances in the batch.

        executionType (`~.hipblasDatatype_t`) -- *IN*:
            [hipblasDatatype_t] [DEPRECATED]
                      specifies the datatype of computation.

            [hipDataType]
                      specifies the datatype of computation.
    """
    if not isinstance(alphaType,_hipblasDatatype_t__Base):
        raise TypeError("argument 'alphaType' must be of type '_hipblasDatatype_t__Base'")                    
    if not isinstance(xType,_hipblasDatatype_t__Base):
        raise TypeError("argument 'xType' must be of type '_hipblasDatatype_t__Base'")                    
    if not isinstance(yType,_hipblasDatatype_t__Base):
        raise TypeError("argument 'yType' must be of type '_hipblasDatatype_t__Base'")                    
    if not isinstance(executionType,_hipblasDatatype_t__Base):
        raise TypeError("argument 'executionType' must be of type '_hipblasDatatype_t__Base'")
    _hipblasAxpyBatchedEx__retval = hipblasStatus_t(chipblas.hipblasAxpyBatchedEx(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,n,
        <const void *>hip._util.types.Pointer.fromPyobj(alpha)._ptr,alphaType.value,
        <const void *>hip._util.types.Pointer.fromPyobj(x)._ptr,xType.value,incx,
        <void *>hip._util.types.Pointer.fromPyobj(y)._ptr,yType.value,incy,batchCount,executionType.value))
    return (_hipblasAxpyBatchedEx__retval,)


@cython.embedsignature(True)
def hipblasAxpyBatchedEx_v2(object handle, int n, object alpha, object alphaType, object x, object xType, int incx, object y, object yType, int incy, int batchCount, object executionType):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        alpha (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        alphaType (`~.hipDataType`):
            (undocumented)

        x (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        xType (`~.hipDataType`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        y (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        yType (`~.hipDataType`):
            (undocumented)

        incy (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)

        executionType (`~.hipDataType`):
            (undocumented)
    """
    if not isinstance(alphaType,_hipDataType__Base):
        raise TypeError("argument 'alphaType' must be of type '_hipDataType__Base'")                    
    if not isinstance(xType,_hipDataType__Base):
        raise TypeError("argument 'xType' must be of type '_hipDataType__Base'")                    
    if not isinstance(yType,_hipDataType__Base):
        raise TypeError("argument 'yType' must be of type '_hipDataType__Base'")                    
    if not isinstance(executionType,_hipDataType__Base):
        raise TypeError("argument 'executionType' must be of type '_hipDataType__Base'")
    _hipblasAxpyBatchedEx_v2__retval = hipblasStatus_t(chipblas.hipblasAxpyBatchedEx_v2(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,n,
        <const void *>hip._util.types.Pointer.fromPyobj(alpha)._ptr,alphaType.value,
        <const void *>hip._util.types.Pointer.fromPyobj(x)._ptr,xType.value,incx,
        <void *>hip._util.types.Pointer.fromPyobj(y)._ptr,yType.value,incy,batchCount,executionType.value))
    return (_hipblasAxpyBatchedEx_v2__retval,)


@cython.embedsignature(True)
def hipblasAxpyBatchedEx_64(object handle, long n, object alpha, object alphaType, object x, object xType, long incx, object y, object yType, long incy, long batchCount, object executionType):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        alpha (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        alphaType (`~.hipblasDatatype_t`):
            (undocumented)

        x (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        xType (`~.hipblasDatatype_t`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        y (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        yType (`~.hipblasDatatype_t`):
            (undocumented)

        incy (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)

        executionType (`~.hipblasDatatype_t`):
            (undocumented)
    """
    if not isinstance(alphaType,_hipblasDatatype_t__Base):
        raise TypeError("argument 'alphaType' must be of type '_hipblasDatatype_t__Base'")                    
    if not isinstance(xType,_hipblasDatatype_t__Base):
        raise TypeError("argument 'xType' must be of type '_hipblasDatatype_t__Base'")                    
    if not isinstance(yType,_hipblasDatatype_t__Base):
        raise TypeError("argument 'yType' must be of type '_hipblasDatatype_t__Base'")                    
    if not isinstance(executionType,_hipblasDatatype_t__Base):
        raise TypeError("argument 'executionType' must be of type '_hipblasDatatype_t__Base'")
    _hipblasAxpyBatchedEx_64__retval = hipblasStatus_t(chipblas.hipblasAxpyBatchedEx_64(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,n,
        <const void *>hip._util.types.Pointer.fromPyobj(alpha)._ptr,alphaType.value,
        <const void *>hip._util.types.Pointer.fromPyobj(x)._ptr,xType.value,incx,
        <void *>hip._util.types.Pointer.fromPyobj(y)._ptr,yType.value,incy,batchCount,executionType.value))
    return (_hipblasAxpyBatchedEx_64__retval,)


@cython.embedsignature(True)
def hipblasAxpyBatchedEx_v2_64(object handle, long n, object alpha, object alphaType, object x, object xType, long incx, object y, object yType, long incy, long batchCount, object executionType):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        alpha (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        alphaType (`~.hipDataType`):
            (undocumented)

        x (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        xType (`~.hipDataType`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        y (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        yType (`~.hipDataType`):
            (undocumented)

        incy (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)

        executionType (`~.hipDataType`):
            (undocumented)
    """
    if not isinstance(alphaType,_hipDataType__Base):
        raise TypeError("argument 'alphaType' must be of type '_hipDataType__Base'")                    
    if not isinstance(xType,_hipDataType__Base):
        raise TypeError("argument 'xType' must be of type '_hipDataType__Base'")                    
    if not isinstance(yType,_hipDataType__Base):
        raise TypeError("argument 'yType' must be of type '_hipDataType__Base'")                    
    if not isinstance(executionType,_hipDataType__Base):
        raise TypeError("argument 'executionType' must be of type '_hipDataType__Base'")
    _hipblasAxpyBatchedEx_v2_64__retval = hipblasStatus_t(chipblas.hipblasAxpyBatchedEx_v2_64(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,n,
        <const void *>hip._util.types.Pointer.fromPyobj(alpha)._ptr,alphaType.value,
        <const void *>hip._util.types.Pointer.fromPyobj(x)._ptr,xType.value,incx,
        <void *>hip._util.types.Pointer.fromPyobj(y)._ptr,yType.value,incy,batchCount,executionType.value))
    return (_hipblasAxpyBatchedEx_v2_64__retval,)


@cython.embedsignature(True)
def hipblasAxpyStridedBatchedEx(object handle, int n, object alpha, object alphaType, object x, object xType, int incx, long stridex, object y, object yType, int incy, long stridey, int batchCount, object executionType):
    r"""BLAS EX API

    axpyStridedBatchedEx computes constant alpha multiplied by vector x, plus vector y over
    a set of strided batched vectors.

    y := alpha * x + y

        - Supported types are determined by the backend. See rocBLAS/cuBLAS documentation.

    With HIPBLAS_V2 define, hipblasAxpyStridedBatchedEx accepts hipDataType for alphaType, xType, yType,
    and executionType rather than hipblasDatatype_t. hipblasAxpyStridedBatchedEx will only accept hipDataType
    in a future release.

        `~.ifdef` HIPBLAS_V2 // available in hipBLAS version 2.0.0 and later with -DHIPBLAS_V2

            hipblasStatus_t hipblasAxpyStridedBatchedEx(hipblasHandle_t handle,
                                                        int             n,
                                                        const void*     alpha,
                                                        hipDataType     alphaType,
                                                        const void*     x,
                                                        hipDataType     xType,
                                                        int             incx,
                                                        hipblasStride   stridex,
                                                        void*           y,
                                                        hipDataType     yType,
                                                        int             incy,
                                                        hipblasStride   stridey,
                                                        int             batchCount,
                                                        hipDataType     executionType)

        `~.else` // [DEPRECATED]

            hipblasStatus_t hipblasAxpyStridedBatchedEx(hipblasHandle_t   handle,
                                                        int               n,
                                                        const void*       alpha,
                                                        hipblasDatatype_t alphaType,
                                                        const void*       x,
                                                        hipblasDatatype_t xType,
                                                        int               incx,
                                                        hipblasStride     stridex,
                                                        void*             y,
                                                        hipblasDatatype_t yType,
                                                        int               incy,
                                                        hipblasStride     stridey,
                                                        int               batchCount,
                                                        hipblasDatatype_t executionType)

        `~.endif`

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`) -- *IN*:
            [hipblasHandle_t]
            handle to the hipblas library context queue.

        n (`~.int`) -- *IN*:
            [int]
            the number of elements in each x_i and y_i.

        alpha (`~.hip._util.types.Pointer`/`~.object`) -- *IN*:
            device pointer or host pointer to specify the scalar alpha.

        alphaType (`~.hipblasDatatype_t`) -- *IN*:
            [hipblasDatatype_t] [DEPRECATED]
                      specifies the datatype of alpha.

            [hipDataType]
                      specifies the datatype of alpha.

        x (`~.hip._util.types.Pointer`/`~.object`) -- *IN*:
            device pointer to the first vector x_1.

        xType (`~.hipblasDatatype_t`) -- *IN*:
            [hipblasDatatype_t] [DEPRECATED]
                      specifies the datatype of each vector x_i.

            [hipDataType]
                      specifies the datatype of each vector x_i.

        incx (`~.int`) -- *IN*:
            [int]
            specifies the increment for the elements of each x_i.

        stridex (`~.int`) -- *IN*:
            [hipblasStride]
            stride from the start of one vector (x_i) to the next one (x_i+1).
            There are no restrictions placed on stridex, however the user should
            take care to ensure that stridex is of appropriate size, for a typical
            case this means stridex >= n * incx.

        y (`~.hip._util.types.Pointer`/`~.object`) -- *INOUT*:
            device pointer to the first vector y_1.

        yType (`~.hipblasDatatype_t`) -- *IN*:
            [hipblasDatatype_t] [DEPRECATED]
                      specifies the datatype of each vector y_i.

            [hipDataType]
                      specifies the datatype of each vector y_i.

        incy (`~.int`) -- *IN*:
            [int]
            specifies the increment for the elements of each y_i.

        stridey (`~.int`) -- *IN*:
            [hipblasStride]
            stride from the start of one vector (y_i) to the next one (y_i+1).
            There are no restrictions placed on stridey, however the user should
            take care to ensure that stridey is of appropriate size, for a typical
            case this means stridey >= n * incy.

        batchCount (`~.int`) -- *IN*:
            [int]
            number of instances in the batch.

        executionType (`~.hipblasDatatype_t`) -- *IN*:
            [hipblasDatatype_t] [DEPRECATED]
                      specifies the datatype of computation.

            [hipDataType]
                      specifies the datatype of computation.
    """
    if not isinstance(alphaType,_hipblasDatatype_t__Base):
        raise TypeError("argument 'alphaType' must be of type '_hipblasDatatype_t__Base'")                    
    if not isinstance(xType,_hipblasDatatype_t__Base):
        raise TypeError("argument 'xType' must be of type '_hipblasDatatype_t__Base'")                    
    if not isinstance(yType,_hipblasDatatype_t__Base):
        raise TypeError("argument 'yType' must be of type '_hipblasDatatype_t__Base'")                    
    if not isinstance(executionType,_hipblasDatatype_t__Base):
        raise TypeError("argument 'executionType' must be of type '_hipblasDatatype_t__Base'")
    _hipblasAxpyStridedBatchedEx__retval = hipblasStatus_t(chipblas.hipblasAxpyStridedBatchedEx(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,n,
        <const void *>hip._util.types.Pointer.fromPyobj(alpha)._ptr,alphaType.value,
        <const void *>hip._util.types.Pointer.fromPyobj(x)._ptr,xType.value,incx,stridex,
        <void *>hip._util.types.Pointer.fromPyobj(y)._ptr,yType.value,incy,stridey,batchCount,executionType.value))
    return (_hipblasAxpyStridedBatchedEx__retval,)


@cython.embedsignature(True)
def hipblasAxpyStridedBatchedEx_v2(object handle, int n, object alpha, object alphaType, object x, object xType, int incx, long stridex, object y, object yType, int incy, long stridey, int batchCount, object executionType):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        alpha (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        alphaType (`~.hipDataType`):
            (undocumented)

        x (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        xType (`~.hipDataType`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        stridex (`~.int`):
            (undocumented)

        y (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        yType (`~.hipDataType`):
            (undocumented)

        incy (`~.int`):
            (undocumented)

        stridey (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)

        executionType (`~.hipDataType`):
            (undocumented)
    """
    if not isinstance(alphaType,_hipDataType__Base):
        raise TypeError("argument 'alphaType' must be of type '_hipDataType__Base'")                    
    if not isinstance(xType,_hipDataType__Base):
        raise TypeError("argument 'xType' must be of type '_hipDataType__Base'")                    
    if not isinstance(yType,_hipDataType__Base):
        raise TypeError("argument 'yType' must be of type '_hipDataType__Base'")                    
    if not isinstance(executionType,_hipDataType__Base):
        raise TypeError("argument 'executionType' must be of type '_hipDataType__Base'")
    _hipblasAxpyStridedBatchedEx_v2__retval = hipblasStatus_t(chipblas.hipblasAxpyStridedBatchedEx_v2(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,n,
        <const void *>hip._util.types.Pointer.fromPyobj(alpha)._ptr,alphaType.value,
        <const void *>hip._util.types.Pointer.fromPyobj(x)._ptr,xType.value,incx,stridex,
        <void *>hip._util.types.Pointer.fromPyobj(y)._ptr,yType.value,incy,stridey,batchCount,executionType.value))
    return (_hipblasAxpyStridedBatchedEx_v2__retval,)


@cython.embedsignature(True)
def hipblasAxpyStridedBatchedEx_64(object handle, long n, object alpha, object alphaType, object x, object xType, long incx, long stridex, object y, object yType, long incy, long stridey, long batchCount, object executionType):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        alpha (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        alphaType (`~.hipblasDatatype_t`):
            (undocumented)

        x (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        xType (`~.hipblasDatatype_t`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        stridex (`~.int`):
            (undocumented)

        y (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        yType (`~.hipblasDatatype_t`):
            (undocumented)

        incy (`~.int`):
            (undocumented)

        stridey (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)

        executionType (`~.hipblasDatatype_t`):
            (undocumented)
    """
    if not isinstance(alphaType,_hipblasDatatype_t__Base):
        raise TypeError("argument 'alphaType' must be of type '_hipblasDatatype_t__Base'")                    
    if not isinstance(xType,_hipblasDatatype_t__Base):
        raise TypeError("argument 'xType' must be of type '_hipblasDatatype_t__Base'")                    
    if not isinstance(yType,_hipblasDatatype_t__Base):
        raise TypeError("argument 'yType' must be of type '_hipblasDatatype_t__Base'")                    
    if not isinstance(executionType,_hipblasDatatype_t__Base):
        raise TypeError("argument 'executionType' must be of type '_hipblasDatatype_t__Base'")
    _hipblasAxpyStridedBatchedEx_64__retval = hipblasStatus_t(chipblas.hipblasAxpyStridedBatchedEx_64(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,n,
        <const void *>hip._util.types.Pointer.fromPyobj(alpha)._ptr,alphaType.value,
        <const void *>hip._util.types.Pointer.fromPyobj(x)._ptr,xType.value,incx,stridex,
        <void *>hip._util.types.Pointer.fromPyobj(y)._ptr,yType.value,incy,stridey,batchCount,executionType.value))
    return (_hipblasAxpyStridedBatchedEx_64__retval,)


@cython.embedsignature(True)
def hipblasAxpyStridedBatchedEx_v2_64(object handle, long n, object alpha, object alphaType, object x, object xType, long incx, long stridex, object y, object yType, long incy, long stridey, long batchCount, object executionType):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        alpha (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        alphaType (`~.hipDataType`):
            (undocumented)

        x (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        xType (`~.hipDataType`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        stridex (`~.int`):
            (undocumented)

        y (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        yType (`~.hipDataType`):
            (undocumented)

        incy (`~.int`):
            (undocumented)

        stridey (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)

        executionType (`~.hipDataType`):
            (undocumented)
    """
    if not isinstance(alphaType,_hipDataType__Base):
        raise TypeError("argument 'alphaType' must be of type '_hipDataType__Base'")                    
    if not isinstance(xType,_hipDataType__Base):
        raise TypeError("argument 'xType' must be of type '_hipDataType__Base'")                    
    if not isinstance(yType,_hipDataType__Base):
        raise TypeError("argument 'yType' must be of type '_hipDataType__Base'")                    
    if not isinstance(executionType,_hipDataType__Base):
        raise TypeError("argument 'executionType' must be of type '_hipDataType__Base'")
    _hipblasAxpyStridedBatchedEx_v2_64__retval = hipblasStatus_t(chipblas.hipblasAxpyStridedBatchedEx_v2_64(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,n,
        <const void *>hip._util.types.Pointer.fromPyobj(alpha)._ptr,alphaType.value,
        <const void *>hip._util.types.Pointer.fromPyobj(x)._ptr,xType.value,incx,stridex,
        <void *>hip._util.types.Pointer.fromPyobj(y)._ptr,yType.value,incy,stridey,batchCount,executionType.value))
    return (_hipblasAxpyStridedBatchedEx_v2_64__retval,)


@cython.embedsignature(True)
def hipblasDotEx(object handle, int n, object x, object xType, int incx, object y, object yType, int incy, object result, object resultType, object executionType):
    r"""BLAS EX API

    @{

    dotEx  performs the dot product of vectors x and y

    result = x * y;

    dotcEx  performs the dot product of the conjugate of complex vector x and complex vector y

        result = conjugate (x) * y;

        - Supported types are determined by the backend. See rocBLAS/cuBLAS documentation.

    With HIPBLAS_V2 define, hipblasDot(c)Ex accepts hipDataType for xType, yType,
    resultType, and executionType rather than hipblasDatatype_t. hipblasDot(c)Ex will only
    accept hipDataType in a future release.

        `~.ifdef` HIPBLAS_V2 // available in hipBLAS version 2.0.0 and later with -DHIPBLAS_V2

            hipblasStatus_t hipblasDotEx(hipblasHandle_t handle,
                                         int             n,
                                         const void*     x,
                                         hipDataType     xType,
                                         int             incx,
                                         const void*     y,
                                         hipDataType     yType,
                                         int             incy,
                                         void*           result,
                                         hipDataType     resultType,
                                         hipDataType     executionType)

        `~.else` // [DEPRECATED]

            hipblasStatus_t hipblasDotEx(hipblasHandle_t   handle,
                                         int               n,
                                         const void*       x,
                                         hipblasDatatype_t xType,
                                         int               incx,
                                         const void*       y,
                                         hipblasDatatype_t yType,
                                         int               incy,
                                         void*             result,
                                         hipblasDatatype_t resultType,
                                         hipblasDatatype_t executionType)

        `~.endif`

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`) -- *IN*:
            [hipblasHandle_t]
            handle to the hipblas library context queue.

        n (`~.int`) -- *IN*:
            [int]
            the number of elements in x and y.

        x (`~.hip._util.types.Pointer`/`~.object`) -- *IN*:
            device pointer storing vector x.

        xType (`~.hipblasDatatype_t`) -- *IN*:
            [hipblasDatatype_t] [DEPRECATED]
                      specifies the datatype of vector x.

            [hipDataType]
                      specifies the datatype of vector x.

        incx (`~.int`) -- *IN*:
            [int]
            specifies the increment for the elements of y.

        y (`~.hip._util.types.Pointer`/`~.object`) -- *IN*:
            device pointer storing vector y.

        yType (`~.hipblasDatatype_t`) -- *IN*:
            [hipblasDatatype_t] [DEPRECATED]
                      specifies the datatype of vector y.

            [hipDataType]
                      specifies the datatype of vector y.

        incy (`~.int`) -- *IN*:
            [int]
            specifies the increment for the elements of y.

        result (`~.hip._util.types.Pointer`/`~.object`) -- *INOUT*:
            device pointer or host pointer to store the dot product.
            return is 0.0 if n <= 0.

        resultType (`~.hipblasDatatype_t`) -- *IN*:
            [hipblasDatatype_t] [DEPRECATED]
                      specifies the datatype of the result.

            [hipDataType]
                      specifies the datatype of the result.

        executionType (`~.hipblasDatatype_t`) -- *IN*:
            [hipblasDatatype_t] [DEPRECATED]
                      specifies the datatype of computation.

            [hipDataType]
                      specifies the datatype of computation.
    """
    if not isinstance(xType,_hipblasDatatype_t__Base):
        raise TypeError("argument 'xType' must be of type '_hipblasDatatype_t__Base'")                    
    if not isinstance(yType,_hipblasDatatype_t__Base):
        raise TypeError("argument 'yType' must be of type '_hipblasDatatype_t__Base'")                    
    if not isinstance(resultType,_hipblasDatatype_t__Base):
        raise TypeError("argument 'resultType' must be of type '_hipblasDatatype_t__Base'")                    
    if not isinstance(executionType,_hipblasDatatype_t__Base):
        raise TypeError("argument 'executionType' must be of type '_hipblasDatatype_t__Base'")
    _hipblasDotEx__retval = hipblasStatus_t(chipblas.hipblasDotEx(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,n,
        <const void *>hip._util.types.Pointer.fromPyobj(x)._ptr,xType.value,incx,
        <const void *>hip._util.types.Pointer.fromPyobj(y)._ptr,yType.value,incy,
        <void *>hip._util.types.Pointer.fromPyobj(result)._ptr,resultType.value,executionType.value))
    return (_hipblasDotEx__retval,)


@cython.embedsignature(True)
def hipblasDotcEx(object handle, int n, object x, object xType, int incx, object y, object yType, int incy, object result, object resultType, object executionType):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        x (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        xType (`~.hipblasDatatype_t`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        y (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        yType (`~.hipblasDatatype_t`):
            (undocumented)

        incy (`~.int`):
            (undocumented)

        result (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        resultType (`~.hipblasDatatype_t`):
            (undocumented)

        executionType (`~.hipblasDatatype_t`):
            (undocumented)
    """
    if not isinstance(xType,_hipblasDatatype_t__Base):
        raise TypeError("argument 'xType' must be of type '_hipblasDatatype_t__Base'")                    
    if not isinstance(yType,_hipblasDatatype_t__Base):
        raise TypeError("argument 'yType' must be of type '_hipblasDatatype_t__Base'")                    
    if not isinstance(resultType,_hipblasDatatype_t__Base):
        raise TypeError("argument 'resultType' must be of type '_hipblasDatatype_t__Base'")                    
    if not isinstance(executionType,_hipblasDatatype_t__Base):
        raise TypeError("argument 'executionType' must be of type '_hipblasDatatype_t__Base'")
    _hipblasDotcEx__retval = hipblasStatus_t(chipblas.hipblasDotcEx(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,n,
        <const void *>hip._util.types.Pointer.fromPyobj(x)._ptr,xType.value,incx,
        <const void *>hip._util.types.Pointer.fromPyobj(y)._ptr,yType.value,incy,
        <void *>hip._util.types.Pointer.fromPyobj(result)._ptr,resultType.value,executionType.value))
    return (_hipblasDotcEx__retval,)


@cython.embedsignature(True)
def hipblasDotEx_v2(object handle, int n, object x, object xType, int incx, object y, object yType, int incy, object result, object resultType, object executionType):
    r"""(No short description, might be part of a group.)

    @}

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        x (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        xType (`~.hipDataType`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        y (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        yType (`~.hipDataType`):
            (undocumented)

        incy (`~.int`):
            (undocumented)

        result (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        resultType (`~.hipDataType`):
            (undocumented)

        executionType (`~.hipDataType`):
            (undocumented)
    """
    if not isinstance(xType,_hipDataType__Base):
        raise TypeError("argument 'xType' must be of type '_hipDataType__Base'")                    
    if not isinstance(yType,_hipDataType__Base):
        raise TypeError("argument 'yType' must be of type '_hipDataType__Base'")                    
    if not isinstance(resultType,_hipDataType__Base):
        raise TypeError("argument 'resultType' must be of type '_hipDataType__Base'")                    
    if not isinstance(executionType,_hipDataType__Base):
        raise TypeError("argument 'executionType' must be of type '_hipDataType__Base'")
    _hipblasDotEx_v2__retval = hipblasStatus_t(chipblas.hipblasDotEx_v2(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,n,
        <const void *>hip._util.types.Pointer.fromPyobj(x)._ptr,xType.value,incx,
        <const void *>hip._util.types.Pointer.fromPyobj(y)._ptr,yType.value,incy,
        <void *>hip._util.types.Pointer.fromPyobj(result)._ptr,resultType.value,executionType.value))
    return (_hipblasDotEx_v2__retval,)


@cython.embedsignature(True)
def hipblasDotcEx_v2(object handle, int n, object x, object xType, int incx, object y, object yType, int incy, object result, object resultType, object executionType):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        x (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        xType (`~.hipDataType`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        y (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        yType (`~.hipDataType`):
            (undocumented)

        incy (`~.int`):
            (undocumented)

        result (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        resultType (`~.hipDataType`):
            (undocumented)

        executionType (`~.hipDataType`):
            (undocumented)
    """
    if not isinstance(xType,_hipDataType__Base):
        raise TypeError("argument 'xType' must be of type '_hipDataType__Base'")                    
    if not isinstance(yType,_hipDataType__Base):
        raise TypeError("argument 'yType' must be of type '_hipDataType__Base'")                    
    if not isinstance(resultType,_hipDataType__Base):
        raise TypeError("argument 'resultType' must be of type '_hipDataType__Base'")                    
    if not isinstance(executionType,_hipDataType__Base):
        raise TypeError("argument 'executionType' must be of type '_hipDataType__Base'")
    _hipblasDotcEx_v2__retval = hipblasStatus_t(chipblas.hipblasDotcEx_v2(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,n,
        <const void *>hip._util.types.Pointer.fromPyobj(x)._ptr,xType.value,incx,
        <const void *>hip._util.types.Pointer.fromPyobj(y)._ptr,yType.value,incy,
        <void *>hip._util.types.Pointer.fromPyobj(result)._ptr,resultType.value,executionType.value))
    return (_hipblasDotcEx_v2__retval,)


@cython.embedsignature(True)
def hipblasDotEx_64(object handle, long n, object x, object xType, long incx, object y, object yType, long incy, object result, object resultType, object executionType):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        x (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        xType (`~.hipblasDatatype_t`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        y (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        yType (`~.hipblasDatatype_t`):
            (undocumented)

        incy (`~.int`):
            (undocumented)

        result (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        resultType (`~.hipblasDatatype_t`):
            (undocumented)

        executionType (`~.hipblasDatatype_t`):
            (undocumented)
    """
    if not isinstance(xType,_hipblasDatatype_t__Base):
        raise TypeError("argument 'xType' must be of type '_hipblasDatatype_t__Base'")                    
    if not isinstance(yType,_hipblasDatatype_t__Base):
        raise TypeError("argument 'yType' must be of type '_hipblasDatatype_t__Base'")                    
    if not isinstance(resultType,_hipblasDatatype_t__Base):
        raise TypeError("argument 'resultType' must be of type '_hipblasDatatype_t__Base'")                    
    if not isinstance(executionType,_hipblasDatatype_t__Base):
        raise TypeError("argument 'executionType' must be of type '_hipblasDatatype_t__Base'")
    _hipblasDotEx_64__retval = hipblasStatus_t(chipblas.hipblasDotEx_64(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,n,
        <const void *>hip._util.types.Pointer.fromPyobj(x)._ptr,xType.value,incx,
        <const void *>hip._util.types.Pointer.fromPyobj(y)._ptr,yType.value,incy,
        <void *>hip._util.types.Pointer.fromPyobj(result)._ptr,resultType.value,executionType.value))
    return (_hipblasDotEx_64__retval,)


@cython.embedsignature(True)
def hipblasDotcEx_64(object handle, long n, object x, object xType, long incx, object y, object yType, long incy, object result, object resultType, object executionType):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        x (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        xType (`~.hipblasDatatype_t`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        y (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        yType (`~.hipblasDatatype_t`):
            (undocumented)

        incy (`~.int`):
            (undocumented)

        result (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        resultType (`~.hipblasDatatype_t`):
            (undocumented)

        executionType (`~.hipblasDatatype_t`):
            (undocumented)
    """
    if not isinstance(xType,_hipblasDatatype_t__Base):
        raise TypeError("argument 'xType' must be of type '_hipblasDatatype_t__Base'")                    
    if not isinstance(yType,_hipblasDatatype_t__Base):
        raise TypeError("argument 'yType' must be of type '_hipblasDatatype_t__Base'")                    
    if not isinstance(resultType,_hipblasDatatype_t__Base):
        raise TypeError("argument 'resultType' must be of type '_hipblasDatatype_t__Base'")                    
    if not isinstance(executionType,_hipblasDatatype_t__Base):
        raise TypeError("argument 'executionType' must be of type '_hipblasDatatype_t__Base'")
    _hipblasDotcEx_64__retval = hipblasStatus_t(chipblas.hipblasDotcEx_64(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,n,
        <const void *>hip._util.types.Pointer.fromPyobj(x)._ptr,xType.value,incx,
        <const void *>hip._util.types.Pointer.fromPyobj(y)._ptr,yType.value,incy,
        <void *>hip._util.types.Pointer.fromPyobj(result)._ptr,resultType.value,executionType.value))
    return (_hipblasDotcEx_64__retval,)


@cython.embedsignature(True)
def hipblasDotEx_v2_64(object handle, long n, object x, object xType, long incx, object y, object yType, long incy, object result, object resultType, object executionType):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        x (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        xType (`~.hipDataType`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        y (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        yType (`~.hipDataType`):
            (undocumented)

        incy (`~.int`):
            (undocumented)

        result (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        resultType (`~.hipDataType`):
            (undocumented)

        executionType (`~.hipDataType`):
            (undocumented)
    """
    if not isinstance(xType,_hipDataType__Base):
        raise TypeError("argument 'xType' must be of type '_hipDataType__Base'")                    
    if not isinstance(yType,_hipDataType__Base):
        raise TypeError("argument 'yType' must be of type '_hipDataType__Base'")                    
    if not isinstance(resultType,_hipDataType__Base):
        raise TypeError("argument 'resultType' must be of type '_hipDataType__Base'")                    
    if not isinstance(executionType,_hipDataType__Base):
        raise TypeError("argument 'executionType' must be of type '_hipDataType__Base'")
    _hipblasDotEx_v2_64__retval = hipblasStatus_t(chipblas.hipblasDotEx_v2_64(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,n,
        <const void *>hip._util.types.Pointer.fromPyobj(x)._ptr,xType.value,incx,
        <const void *>hip._util.types.Pointer.fromPyobj(y)._ptr,yType.value,incy,
        <void *>hip._util.types.Pointer.fromPyobj(result)._ptr,resultType.value,executionType.value))
    return (_hipblasDotEx_v2_64__retval,)


@cython.embedsignature(True)
def hipblasDotcEx_v2_64(object handle, long n, object x, object xType, long incx, object y, object yType, long incy, object result, object resultType, object executionType):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        x (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        xType (`~.hipDataType`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        y (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        yType (`~.hipDataType`):
            (undocumented)

        incy (`~.int`):
            (undocumented)

        result (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        resultType (`~.hipDataType`):
            (undocumented)

        executionType (`~.hipDataType`):
            (undocumented)
    """
    if not isinstance(xType,_hipDataType__Base):
        raise TypeError("argument 'xType' must be of type '_hipDataType__Base'")                    
    if not isinstance(yType,_hipDataType__Base):
        raise TypeError("argument 'yType' must be of type '_hipDataType__Base'")                    
    if not isinstance(resultType,_hipDataType__Base):
        raise TypeError("argument 'resultType' must be of type '_hipDataType__Base'")                    
    if not isinstance(executionType,_hipDataType__Base):
        raise TypeError("argument 'executionType' must be of type '_hipDataType__Base'")
    _hipblasDotcEx_v2_64__retval = hipblasStatus_t(chipblas.hipblasDotcEx_v2_64(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,n,
        <const void *>hip._util.types.Pointer.fromPyobj(x)._ptr,xType.value,incx,
        <const void *>hip._util.types.Pointer.fromPyobj(y)._ptr,yType.value,incy,
        <void *>hip._util.types.Pointer.fromPyobj(result)._ptr,resultType.value,executionType.value))
    return (_hipblasDotcEx_v2_64__retval,)


@cython.embedsignature(True)
def hipblasDotBatchedEx(object handle, int n, object x, object xType, int incx, object y, object yType, int incy, int batchCount, object result, object resultType, object executionType):
    r"""BLAS EX API

    @{

    dotBatchedEx performs a batch of dot products of vectors x and y

    result_i = x_i * y_i;

    dotcBatchedEx  performs a batch of dot products of the conjugate of complex vector x and complex vector y

        result_i = conjugate (x_i) * y_i;

    where (x_i, y_i) is the i-th instance of the batch.
    x_i and y_i are vectors, for i = 1, ..., batchCount

        - Supported types are determined by the backend. See rocBLAS/cuBLAS documentation.

    With HIPBLAS_V2 define, hipblasDot(c)BatchedEx accepts hipDataType for xType, yType,
    resultType, and executionType rather than hipblasDatatype_t. hipblasDot(c)BatchedEx will only
    accept hipDataType in a future release.

        `~.ifdef` HIPBLAS_V2 // available in hipBLAS version 2.0.0 and later with -DHIPBLAS_V2

            hipblasStatus_t hipblasDotBatchedEx(hipblasHandle_t handle,
                                                int             n,
                                                const void*     x,
                                                hipDataType     xType,
                                                int             incx,
                                                const void*     y,
                                                hipDataType     yType,
                                                int             incy,
                                                int             batchCount,
                                                void*           result,
                                                hipDataType     resultType,
                                                hipDataType     executionType)

        `~.else` // [DEPRECATED]

            hipblasStatus_t hipblasDotBatchedEx(hipblasHandle_t   handle,
                                                int               n,
                                                const void*       x,
                                                hipblasDatatype_t xType,
                                                int               incx,
                                                const void*       y,
                                                hipblasDatatype_t yType,
                                                int               incy,
                                                int               batchCount,
                                                void*             result,
                                                hipblasDatatype_t resultType,
                                                hipblasDatatype_t executionType)

        `~.endif`

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`) -- *IN*:
            [hipblasHandle_t]
            handle to the hipblas library context queue.

        n (`~.int`) -- *IN*:
            [int]
            the number of elements in each x_i and y_i.

        x (`~.hip._util.types.Pointer`/`~.object`) -- *IN*:
            device array of device pointers storing each vector x_i.

        xType (`~.hipblasDatatype_t`) -- *IN*:
            [hipblasDatatype_t] [DEPRECATED]
                      specifies the datatype of each vector x_i.

            [hipDataType]
                      specifies the datatype of each vector x_i.

        incx (`~.int`) -- *IN*:
            [int]
            specifies the increment for the elements of each x_i.

        y (`~.hip._util.types.Pointer`/`~.object`) -- *IN*:
            device array of device pointers storing each vector y_i.

        yType (`~.hipblasDatatype_t`) -- *IN*:
            [hipblasDatatype_t] [DEPRECATED]
                      specifies the datatype of each vector y_i.

            [hipDataType]
                      specifies the datatype of each vector y_i.

        incy (`~.int`) -- *IN*:
            [int]
            specifies the increment for the elements of each y_i.

        batchCount (`~.int`) -- *IN*:
            [int]
            number of instances in the batch

        result (`~.hip._util.types.Pointer`/`~.object`) -- *INOUT*:
            device array or host array of batchCount size to store the dot products of each batch.
            return 0.0 for each element if n <= 0.

        resultType (`~.hipblasDatatype_t`) -- *IN*:
            [hipblasDatatype_t] [DEPRECATED]
                      specifies the datatype of the result.

            [hipDataType]
                      specifies the datatype of the result.

        executionType (`~.hipblasDatatype_t`) -- *IN*:
            [hipblasDatatype_t] [DEPRECATED]
                      specifies the datatype of computation.

            [hipDataType]
                      specifies the datatype of computation.
    """
    if not isinstance(xType,_hipblasDatatype_t__Base):
        raise TypeError("argument 'xType' must be of type '_hipblasDatatype_t__Base'")                    
    if not isinstance(yType,_hipblasDatatype_t__Base):
        raise TypeError("argument 'yType' must be of type '_hipblasDatatype_t__Base'")                    
    if not isinstance(resultType,_hipblasDatatype_t__Base):
        raise TypeError("argument 'resultType' must be of type '_hipblasDatatype_t__Base'")                    
    if not isinstance(executionType,_hipblasDatatype_t__Base):
        raise TypeError("argument 'executionType' must be of type '_hipblasDatatype_t__Base'")
    _hipblasDotBatchedEx__retval = hipblasStatus_t(chipblas.hipblasDotBatchedEx(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,n,
        <const void *>hip._util.types.Pointer.fromPyobj(x)._ptr,xType.value,incx,
        <const void *>hip._util.types.Pointer.fromPyobj(y)._ptr,yType.value,incy,batchCount,
        <void *>hip._util.types.Pointer.fromPyobj(result)._ptr,resultType.value,executionType.value))
    return (_hipblasDotBatchedEx__retval,)


@cython.embedsignature(True)
def hipblasDotcBatchedEx(object handle, int n, object x, object xType, int incx, object y, object yType, int incy, int batchCount, object result, object resultType, object executionType):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        x (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        xType (`~.hipblasDatatype_t`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        y (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        yType (`~.hipblasDatatype_t`):
            (undocumented)

        incy (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)

        result (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        resultType (`~.hipblasDatatype_t`):
            (undocumented)

        executionType (`~.hipblasDatatype_t`):
            (undocumented)
    """
    if not isinstance(xType,_hipblasDatatype_t__Base):
        raise TypeError("argument 'xType' must be of type '_hipblasDatatype_t__Base'")                    
    if not isinstance(yType,_hipblasDatatype_t__Base):
        raise TypeError("argument 'yType' must be of type '_hipblasDatatype_t__Base'")                    
    if not isinstance(resultType,_hipblasDatatype_t__Base):
        raise TypeError("argument 'resultType' must be of type '_hipblasDatatype_t__Base'")                    
    if not isinstance(executionType,_hipblasDatatype_t__Base):
        raise TypeError("argument 'executionType' must be of type '_hipblasDatatype_t__Base'")
    _hipblasDotcBatchedEx__retval = hipblasStatus_t(chipblas.hipblasDotcBatchedEx(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,n,
        <const void *>hip._util.types.Pointer.fromPyobj(x)._ptr,xType.value,incx,
        <const void *>hip._util.types.Pointer.fromPyobj(y)._ptr,yType.value,incy,batchCount,
        <void *>hip._util.types.Pointer.fromPyobj(result)._ptr,resultType.value,executionType.value))
    return (_hipblasDotcBatchedEx__retval,)


@cython.embedsignature(True)
def hipblasDotBatchedEx_v2(object handle, int n, object x, object xType, int incx, object y, object yType, int incy, int batchCount, object result, object resultType, object executionType):
    r"""(No short description, might be part of a group.)

    @}

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        x (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        xType (`~.hipDataType`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        y (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        yType (`~.hipDataType`):
            (undocumented)

        incy (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)

        result (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        resultType (`~.hipDataType`):
            (undocumented)

        executionType (`~.hipDataType`):
            (undocumented)
    """
    if not isinstance(xType,_hipDataType__Base):
        raise TypeError("argument 'xType' must be of type '_hipDataType__Base'")                    
    if not isinstance(yType,_hipDataType__Base):
        raise TypeError("argument 'yType' must be of type '_hipDataType__Base'")                    
    if not isinstance(resultType,_hipDataType__Base):
        raise TypeError("argument 'resultType' must be of type '_hipDataType__Base'")                    
    if not isinstance(executionType,_hipDataType__Base):
        raise TypeError("argument 'executionType' must be of type '_hipDataType__Base'")
    _hipblasDotBatchedEx_v2__retval = hipblasStatus_t(chipblas.hipblasDotBatchedEx_v2(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,n,
        <const void *>hip._util.types.Pointer.fromPyobj(x)._ptr,xType.value,incx,
        <const void *>hip._util.types.Pointer.fromPyobj(y)._ptr,yType.value,incy,batchCount,
        <void *>hip._util.types.Pointer.fromPyobj(result)._ptr,resultType.value,executionType.value))
    return (_hipblasDotBatchedEx_v2__retval,)


@cython.embedsignature(True)
def hipblasDotcBatchedEx_v2(object handle, int n, object x, object xType, int incx, object y, object yType, int incy, int batchCount, object result, object resultType, object executionType):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        x (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        xType (`~.hipDataType`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        y (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        yType (`~.hipDataType`):
            (undocumented)

        incy (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)

        result (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        resultType (`~.hipDataType`):
            (undocumented)

        executionType (`~.hipDataType`):
            (undocumented)
    """
    if not isinstance(xType,_hipDataType__Base):
        raise TypeError("argument 'xType' must be of type '_hipDataType__Base'")                    
    if not isinstance(yType,_hipDataType__Base):
        raise TypeError("argument 'yType' must be of type '_hipDataType__Base'")                    
    if not isinstance(resultType,_hipDataType__Base):
        raise TypeError("argument 'resultType' must be of type '_hipDataType__Base'")                    
    if not isinstance(executionType,_hipDataType__Base):
        raise TypeError("argument 'executionType' must be of type '_hipDataType__Base'")
    _hipblasDotcBatchedEx_v2__retval = hipblasStatus_t(chipblas.hipblasDotcBatchedEx_v2(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,n,
        <const void *>hip._util.types.Pointer.fromPyobj(x)._ptr,xType.value,incx,
        <const void *>hip._util.types.Pointer.fromPyobj(y)._ptr,yType.value,incy,batchCount,
        <void *>hip._util.types.Pointer.fromPyobj(result)._ptr,resultType.value,executionType.value))
    return (_hipblasDotcBatchedEx_v2__retval,)


@cython.embedsignature(True)
def hipblasDotBatchedEx_64(object handle, long n, object x, object xType, long incx, object y, object yType, long incy, long batchCount, object result, object resultType, object executionType):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        x (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        xType (`~.hipblasDatatype_t`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        y (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        yType (`~.hipblasDatatype_t`):
            (undocumented)

        incy (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)

        result (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        resultType (`~.hipblasDatatype_t`):
            (undocumented)

        executionType (`~.hipblasDatatype_t`):
            (undocumented)
    """
    if not isinstance(xType,_hipblasDatatype_t__Base):
        raise TypeError("argument 'xType' must be of type '_hipblasDatatype_t__Base'")                    
    if not isinstance(yType,_hipblasDatatype_t__Base):
        raise TypeError("argument 'yType' must be of type '_hipblasDatatype_t__Base'")                    
    if not isinstance(resultType,_hipblasDatatype_t__Base):
        raise TypeError("argument 'resultType' must be of type '_hipblasDatatype_t__Base'")                    
    if not isinstance(executionType,_hipblasDatatype_t__Base):
        raise TypeError("argument 'executionType' must be of type '_hipblasDatatype_t__Base'")
    _hipblasDotBatchedEx_64__retval = hipblasStatus_t(chipblas.hipblasDotBatchedEx_64(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,n,
        <const void *>hip._util.types.Pointer.fromPyobj(x)._ptr,xType.value,incx,
        <const void *>hip._util.types.Pointer.fromPyobj(y)._ptr,yType.value,incy,batchCount,
        <void *>hip._util.types.Pointer.fromPyobj(result)._ptr,resultType.value,executionType.value))
    return (_hipblasDotBatchedEx_64__retval,)


@cython.embedsignature(True)
def hipblasDotcBatchedEx_64(object handle, long n, object x, object xType, long incx, object y, object yType, long incy, long batchCount, object result, object resultType, object executionType):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        x (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        xType (`~.hipblasDatatype_t`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        y (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        yType (`~.hipblasDatatype_t`):
            (undocumented)

        incy (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)

        result (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        resultType (`~.hipblasDatatype_t`):
            (undocumented)

        executionType (`~.hipblasDatatype_t`):
            (undocumented)
    """
    if not isinstance(xType,_hipblasDatatype_t__Base):
        raise TypeError("argument 'xType' must be of type '_hipblasDatatype_t__Base'")                    
    if not isinstance(yType,_hipblasDatatype_t__Base):
        raise TypeError("argument 'yType' must be of type '_hipblasDatatype_t__Base'")                    
    if not isinstance(resultType,_hipblasDatatype_t__Base):
        raise TypeError("argument 'resultType' must be of type '_hipblasDatatype_t__Base'")                    
    if not isinstance(executionType,_hipblasDatatype_t__Base):
        raise TypeError("argument 'executionType' must be of type '_hipblasDatatype_t__Base'")
    _hipblasDotcBatchedEx_64__retval = hipblasStatus_t(chipblas.hipblasDotcBatchedEx_64(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,n,
        <const void *>hip._util.types.Pointer.fromPyobj(x)._ptr,xType.value,incx,
        <const void *>hip._util.types.Pointer.fromPyobj(y)._ptr,yType.value,incy,batchCount,
        <void *>hip._util.types.Pointer.fromPyobj(result)._ptr,resultType.value,executionType.value))
    return (_hipblasDotcBatchedEx_64__retval,)


@cython.embedsignature(True)
def hipblasDotBatchedEx_v2_64(object handle, long n, object x, object xType, long incx, object y, object yType, long incy, long batchCount, object result, object resultType, object executionType):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        x (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        xType (`~.hipDataType`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        y (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        yType (`~.hipDataType`):
            (undocumented)

        incy (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)

        result (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        resultType (`~.hipDataType`):
            (undocumented)

        executionType (`~.hipDataType`):
            (undocumented)
    """
    if not isinstance(xType,_hipDataType__Base):
        raise TypeError("argument 'xType' must be of type '_hipDataType__Base'")                    
    if not isinstance(yType,_hipDataType__Base):
        raise TypeError("argument 'yType' must be of type '_hipDataType__Base'")                    
    if not isinstance(resultType,_hipDataType__Base):
        raise TypeError("argument 'resultType' must be of type '_hipDataType__Base'")                    
    if not isinstance(executionType,_hipDataType__Base):
        raise TypeError("argument 'executionType' must be of type '_hipDataType__Base'")
    _hipblasDotBatchedEx_v2_64__retval = hipblasStatus_t(chipblas.hipblasDotBatchedEx_v2_64(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,n,
        <const void *>hip._util.types.Pointer.fromPyobj(x)._ptr,xType.value,incx,
        <const void *>hip._util.types.Pointer.fromPyobj(y)._ptr,yType.value,incy,batchCount,
        <void *>hip._util.types.Pointer.fromPyobj(result)._ptr,resultType.value,executionType.value))
    return (_hipblasDotBatchedEx_v2_64__retval,)


@cython.embedsignature(True)
def hipblasDotcBatchedEx_v2_64(object handle, long n, object x, object xType, long incx, object y, object yType, long incy, long batchCount, object result, object resultType, object executionType):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        x (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        xType (`~.hipDataType`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        y (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        yType (`~.hipDataType`):
            (undocumented)

        incy (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)

        result (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        resultType (`~.hipDataType`):
            (undocumented)

        executionType (`~.hipDataType`):
            (undocumented)
    """
    if not isinstance(xType,_hipDataType__Base):
        raise TypeError("argument 'xType' must be of type '_hipDataType__Base'")                    
    if not isinstance(yType,_hipDataType__Base):
        raise TypeError("argument 'yType' must be of type '_hipDataType__Base'")                    
    if not isinstance(resultType,_hipDataType__Base):
        raise TypeError("argument 'resultType' must be of type '_hipDataType__Base'")                    
    if not isinstance(executionType,_hipDataType__Base):
        raise TypeError("argument 'executionType' must be of type '_hipDataType__Base'")
    _hipblasDotcBatchedEx_v2_64__retval = hipblasStatus_t(chipblas.hipblasDotcBatchedEx_v2_64(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,n,
        <const void *>hip._util.types.Pointer.fromPyobj(x)._ptr,xType.value,incx,
        <const void *>hip._util.types.Pointer.fromPyobj(y)._ptr,yType.value,incy,batchCount,
        <void *>hip._util.types.Pointer.fromPyobj(result)._ptr,resultType.value,executionType.value))
    return (_hipblasDotcBatchedEx_v2_64__retval,)


@cython.embedsignature(True)
def hipblasDotStridedBatchedEx(object handle, int n, object x, object xType, int incx, long stridex, object y, object yType, int incy, long stridey, int batchCount, object result, object resultType, object executionType):
    r"""BLAS EX API

    @{

    dotStridedBatchedEx  performs a batch of dot products of vectors x and y

    result_i = x_i * y_i;

    dotc_strided_batched_ex  performs a batch of dot products of the conjugate of complex vector x and complex vector y

        result_i = conjugate (x_i) * y_i;

    where (x_i, y_i) is the i-th instance of the batch.
    x_i and y_i are vectors, for i = 1, ..., batchCount

        - Supported types are determined by the backend. See rocBLAS/cuBLAS documentation.

    With HIPBLAS_V2 define, hipblasDot(c)StridedBatchedEx accepts hipDataType for xType, yType,
    resultType, and executionType rather than hipblasDatatype_t. hipblasDot(c)StridedBatchedEx will only
    accept hipDataType in a future release.

        `~.ifdef` HIPBLAS_V2 // available in hipBLAS version 2.0.0 and later with -DHIPBLAS_V2

            hipblasStatus_t hipblasDotStridedBatchedEx(hipblasHandle_t handle,
                                                       int             n,
                                                       const void*     x,
                                                       hipDataType     xType,
                                                       int             incx,
                                                       hipblasStride   stridex,
                                                       const void*     y,
                                                       hipDataType     yType,
                                                       int             incy,
                                                       hipblasStride   stridey,
                                                       int             batchCount,
                                                       void*           result,
                                                       hipDataType     resultType,
                                                       hipDataType     executionType)

        `~.else` // [DEPRECATED]

            hipblasStatus_t hipblasDotStridedBatchedEx(hipblasHandle_t   handle,
                                                       int               n,
                                                       const void*       x,
                                                       hipblasDatatype_t xType,
                                                       int               incx,
                                                       hipblasStride     stridex,
                                                       const void*       y,
                                                       hipblasDatatype_t yType,
                                                       int               incy,
                                                       hipblasStride     stridey,
                                                       int               batchCount,
                                                       void*             result,
                                                       hipblasDatatype_t resultType,
                                                       hipblasDatatype_t executionType)

        `~.endif`

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`) -- *IN*:
            [hipblasHandle_t]
            handle to the hipblas library context queue.

        n (`~.int`) -- *IN*:
            [int]
            the number of elements in each x_i and y_i.

        x (`~.hip._util.types.Pointer`/`~.object`) -- *IN*:
            device pointer to the first vector (x_1) in the batch.

        xType (`~.hipblasDatatype_t`) -- *IN*:
            [hipblasDatatype_t] [DEPRECATED]
                      specifies the datatype of each vector x_i.

            [hipDataType]
                      specifies the datatype of each vector x_i.

        incx (`~.int`) -- *IN*:
            [int]
            specifies the increment for the elements of each x_i.

        stridex (`~.int`) -- *IN*:
            [hipblasStride]
            stride from the start of one vector (x_i) and the next one (x_i+1)

        y (`~.hip._util.types.Pointer`/`~.object`) -- *IN*:
            device pointer to the first vector (y_1) in the batch.

        yType (`~.hipblasDatatype_t`) -- *IN*:
            [hipblasDatatype_t] [DEPRECATED]
                      specifies the datatype of each vector y_i.

            [hipDataType]
                      specifies the datatype of each vector y_i.

        incy (`~.int`) -- *IN*:
            [int]
            specifies the increment for the elements of each y_i.

        stridey (`~.int`) -- *IN*:
            [hipblasStride]
            stride from the start of one vector (y_i) and the next one (y_i+1)

        batchCount (`~.int`) -- *IN*:
            [int]
            number of instances in the batch

        result (`~.hip._util.types.Pointer`/`~.object`) -- *INOUT*:
            device array or host array of batchCount size to store the dot products of each batch.
            return 0.0 for each element if n <= 0.

        resultType (`~.hipblasDatatype_t`) -- *IN*:
            [hipblasDatatype_t] [DEPRECATED]
                      specifies the datatype of the result.

            [hipDataType]
                      specifies the datatype of the result.

        executionType (`~.hipblasDatatype_t`) -- *IN*:
            [hipblasDatatype_t] [DEPRECATED]
                      specifies the datatype of computation.

            [hipDataType]
                      specifies the datatype of computation.
    """
    if not isinstance(xType,_hipblasDatatype_t__Base):
        raise TypeError("argument 'xType' must be of type '_hipblasDatatype_t__Base'")                    
    if not isinstance(yType,_hipblasDatatype_t__Base):
        raise TypeError("argument 'yType' must be of type '_hipblasDatatype_t__Base'")                    
    if not isinstance(resultType,_hipblasDatatype_t__Base):
        raise TypeError("argument 'resultType' must be of type '_hipblasDatatype_t__Base'")                    
    if not isinstance(executionType,_hipblasDatatype_t__Base):
        raise TypeError("argument 'executionType' must be of type '_hipblasDatatype_t__Base'")
    _hipblasDotStridedBatchedEx__retval = hipblasStatus_t(chipblas.hipblasDotStridedBatchedEx(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,n,
        <const void *>hip._util.types.Pointer.fromPyobj(x)._ptr,xType.value,incx,stridex,
        <const void *>hip._util.types.Pointer.fromPyobj(y)._ptr,yType.value,incy,stridey,batchCount,
        <void *>hip._util.types.Pointer.fromPyobj(result)._ptr,resultType.value,executionType.value))
    return (_hipblasDotStridedBatchedEx__retval,)


@cython.embedsignature(True)
def hipblasDotcStridedBatchedEx(object handle, int n, object x, object xType, int incx, long stridex, object y, object yType, int incy, long stridey, int batchCount, object result, object resultType, object executionType):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        x (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        xType (`~.hipblasDatatype_t`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        stridex (`~.int`):
            (undocumented)

        y (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        yType (`~.hipblasDatatype_t`):
            (undocumented)

        incy (`~.int`):
            (undocumented)

        stridey (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)

        result (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        resultType (`~.hipblasDatatype_t`):
            (undocumented)

        executionType (`~.hipblasDatatype_t`):
            (undocumented)
    """
    if not isinstance(xType,_hipblasDatatype_t__Base):
        raise TypeError("argument 'xType' must be of type '_hipblasDatatype_t__Base'")                    
    if not isinstance(yType,_hipblasDatatype_t__Base):
        raise TypeError("argument 'yType' must be of type '_hipblasDatatype_t__Base'")                    
    if not isinstance(resultType,_hipblasDatatype_t__Base):
        raise TypeError("argument 'resultType' must be of type '_hipblasDatatype_t__Base'")                    
    if not isinstance(executionType,_hipblasDatatype_t__Base):
        raise TypeError("argument 'executionType' must be of type '_hipblasDatatype_t__Base'")
    _hipblasDotcStridedBatchedEx__retval = hipblasStatus_t(chipblas.hipblasDotcStridedBatchedEx(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,n,
        <const void *>hip._util.types.Pointer.fromPyobj(x)._ptr,xType.value,incx,stridex,
        <const void *>hip._util.types.Pointer.fromPyobj(y)._ptr,yType.value,incy,stridey,batchCount,
        <void *>hip._util.types.Pointer.fromPyobj(result)._ptr,resultType.value,executionType.value))
    return (_hipblasDotcStridedBatchedEx__retval,)


@cython.embedsignature(True)
def hipblasDotStridedBatchedEx_v2(object handle, int n, object x, object xType, int incx, long stridex, object y, object yType, int incy, long stridey, int batchCount, object result, object resultType, object executionType):
    r"""(No short description, might be part of a group.)

    @}

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        x (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        xType (`~.hipDataType`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        stridex (`~.int`):
            (undocumented)

        y (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        yType (`~.hipDataType`):
            (undocumented)

        incy (`~.int`):
            (undocumented)

        stridey (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)

        result (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        resultType (`~.hipDataType`):
            (undocumented)

        executionType (`~.hipDataType`):
            (undocumented)
    """
    if not isinstance(xType,_hipDataType__Base):
        raise TypeError("argument 'xType' must be of type '_hipDataType__Base'")                    
    if not isinstance(yType,_hipDataType__Base):
        raise TypeError("argument 'yType' must be of type '_hipDataType__Base'")                    
    if not isinstance(resultType,_hipDataType__Base):
        raise TypeError("argument 'resultType' must be of type '_hipDataType__Base'")                    
    if not isinstance(executionType,_hipDataType__Base):
        raise TypeError("argument 'executionType' must be of type '_hipDataType__Base'")
    _hipblasDotStridedBatchedEx_v2__retval = hipblasStatus_t(chipblas.hipblasDotStridedBatchedEx_v2(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,n,
        <const void *>hip._util.types.Pointer.fromPyobj(x)._ptr,xType.value,incx,stridex,
        <const void *>hip._util.types.Pointer.fromPyobj(y)._ptr,yType.value,incy,stridey,batchCount,
        <void *>hip._util.types.Pointer.fromPyobj(result)._ptr,resultType.value,executionType.value))
    return (_hipblasDotStridedBatchedEx_v2__retval,)


@cython.embedsignature(True)
def hipblasDotcStridedBatchedEx_v2(object handle, int n, object x, object xType, int incx, long stridex, object y, object yType, int incy, long stridey, int batchCount, object result, object resultType, object executionType):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        x (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        xType (`~.hipDataType`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        stridex (`~.int`):
            (undocumented)

        y (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        yType (`~.hipDataType`):
            (undocumented)

        incy (`~.int`):
            (undocumented)

        stridey (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)

        result (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        resultType (`~.hipDataType`):
            (undocumented)

        executionType (`~.hipDataType`):
            (undocumented)
    """
    if not isinstance(xType,_hipDataType__Base):
        raise TypeError("argument 'xType' must be of type '_hipDataType__Base'")                    
    if not isinstance(yType,_hipDataType__Base):
        raise TypeError("argument 'yType' must be of type '_hipDataType__Base'")                    
    if not isinstance(resultType,_hipDataType__Base):
        raise TypeError("argument 'resultType' must be of type '_hipDataType__Base'")                    
    if not isinstance(executionType,_hipDataType__Base):
        raise TypeError("argument 'executionType' must be of type '_hipDataType__Base'")
    _hipblasDotcStridedBatchedEx_v2__retval = hipblasStatus_t(chipblas.hipblasDotcStridedBatchedEx_v2(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,n,
        <const void *>hip._util.types.Pointer.fromPyobj(x)._ptr,xType.value,incx,stridex,
        <const void *>hip._util.types.Pointer.fromPyobj(y)._ptr,yType.value,incy,stridey,batchCount,
        <void *>hip._util.types.Pointer.fromPyobj(result)._ptr,resultType.value,executionType.value))
    return (_hipblasDotcStridedBatchedEx_v2__retval,)


@cython.embedsignature(True)
def hipblasDotStridedBatchedEx_64(object handle, long n, object x, object xType, long incx, long stridex, object y, object yType, long incy, long stridey, long batchCount, object result, object resultType, object executionType):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        x (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        xType (`~.hipblasDatatype_t`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        stridex (`~.int`):
            (undocumented)

        y (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        yType (`~.hipblasDatatype_t`):
            (undocumented)

        incy (`~.int`):
            (undocumented)

        stridey (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)

        result (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        resultType (`~.hipblasDatatype_t`):
            (undocumented)

        executionType (`~.hipblasDatatype_t`):
            (undocumented)
    """
    if not isinstance(xType,_hipblasDatatype_t__Base):
        raise TypeError("argument 'xType' must be of type '_hipblasDatatype_t__Base'")                    
    if not isinstance(yType,_hipblasDatatype_t__Base):
        raise TypeError("argument 'yType' must be of type '_hipblasDatatype_t__Base'")                    
    if not isinstance(resultType,_hipblasDatatype_t__Base):
        raise TypeError("argument 'resultType' must be of type '_hipblasDatatype_t__Base'")                    
    if not isinstance(executionType,_hipblasDatatype_t__Base):
        raise TypeError("argument 'executionType' must be of type '_hipblasDatatype_t__Base'")
    _hipblasDotStridedBatchedEx_64__retval = hipblasStatus_t(chipblas.hipblasDotStridedBatchedEx_64(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,n,
        <const void *>hip._util.types.Pointer.fromPyobj(x)._ptr,xType.value,incx,stridex,
        <const void *>hip._util.types.Pointer.fromPyobj(y)._ptr,yType.value,incy,stridey,batchCount,
        <void *>hip._util.types.Pointer.fromPyobj(result)._ptr,resultType.value,executionType.value))
    return (_hipblasDotStridedBatchedEx_64__retval,)


@cython.embedsignature(True)
def hipblasDotcStridedBatchedEx_64(object handle, long n, object x, object xType, long incx, long stridex, object y, object yType, long incy, long stridey, long batchCount, object result, object resultType, object executionType):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        x (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        xType (`~.hipblasDatatype_t`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        stridex (`~.int`):
            (undocumented)

        y (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        yType (`~.hipblasDatatype_t`):
            (undocumented)

        incy (`~.int`):
            (undocumented)

        stridey (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)

        result (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        resultType (`~.hipblasDatatype_t`):
            (undocumented)

        executionType (`~.hipblasDatatype_t`):
            (undocumented)
    """
    if not isinstance(xType,_hipblasDatatype_t__Base):
        raise TypeError("argument 'xType' must be of type '_hipblasDatatype_t__Base'")                    
    if not isinstance(yType,_hipblasDatatype_t__Base):
        raise TypeError("argument 'yType' must be of type '_hipblasDatatype_t__Base'")                    
    if not isinstance(resultType,_hipblasDatatype_t__Base):
        raise TypeError("argument 'resultType' must be of type '_hipblasDatatype_t__Base'")                    
    if not isinstance(executionType,_hipblasDatatype_t__Base):
        raise TypeError("argument 'executionType' must be of type '_hipblasDatatype_t__Base'")
    _hipblasDotcStridedBatchedEx_64__retval = hipblasStatus_t(chipblas.hipblasDotcStridedBatchedEx_64(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,n,
        <const void *>hip._util.types.Pointer.fromPyobj(x)._ptr,xType.value,incx,stridex,
        <const void *>hip._util.types.Pointer.fromPyobj(y)._ptr,yType.value,incy,stridey,batchCount,
        <void *>hip._util.types.Pointer.fromPyobj(result)._ptr,resultType.value,executionType.value))
    return (_hipblasDotcStridedBatchedEx_64__retval,)


@cython.embedsignature(True)
def hipblasDotStridedBatchedEx_v2_64(object handle, long n, object x, object xType, long incx, long stridex, object y, object yType, long incy, long stridey, long batchCount, object result, object resultType, object executionType):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        x (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        xType (`~.hipDataType`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        stridex (`~.int`):
            (undocumented)

        y (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        yType (`~.hipDataType`):
            (undocumented)

        incy (`~.int`):
            (undocumented)

        stridey (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)

        result (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        resultType (`~.hipDataType`):
            (undocumented)

        executionType (`~.hipDataType`):
            (undocumented)
    """
    if not isinstance(xType,_hipDataType__Base):
        raise TypeError("argument 'xType' must be of type '_hipDataType__Base'")                    
    if not isinstance(yType,_hipDataType__Base):
        raise TypeError("argument 'yType' must be of type '_hipDataType__Base'")                    
    if not isinstance(resultType,_hipDataType__Base):
        raise TypeError("argument 'resultType' must be of type '_hipDataType__Base'")                    
    if not isinstance(executionType,_hipDataType__Base):
        raise TypeError("argument 'executionType' must be of type '_hipDataType__Base'")
    _hipblasDotStridedBatchedEx_v2_64__retval = hipblasStatus_t(chipblas.hipblasDotStridedBatchedEx_v2_64(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,n,
        <const void *>hip._util.types.Pointer.fromPyobj(x)._ptr,xType.value,incx,stridex,
        <const void *>hip._util.types.Pointer.fromPyobj(y)._ptr,yType.value,incy,stridey,batchCount,
        <void *>hip._util.types.Pointer.fromPyobj(result)._ptr,resultType.value,executionType.value))
    return (_hipblasDotStridedBatchedEx_v2_64__retval,)


@cython.embedsignature(True)
def hipblasDotcStridedBatchedEx_v2_64(object handle, long n, object x, object xType, long incx, long stridex, object y, object yType, long incy, long stridey, long batchCount, object result, object resultType, object executionType):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        x (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        xType (`~.hipDataType`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        stridex (`~.int`):
            (undocumented)

        y (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        yType (`~.hipDataType`):
            (undocumented)

        incy (`~.int`):
            (undocumented)

        stridey (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)

        result (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        resultType (`~.hipDataType`):
            (undocumented)

        executionType (`~.hipDataType`):
            (undocumented)
    """
    if not isinstance(xType,_hipDataType__Base):
        raise TypeError("argument 'xType' must be of type '_hipDataType__Base'")                    
    if not isinstance(yType,_hipDataType__Base):
        raise TypeError("argument 'yType' must be of type '_hipDataType__Base'")                    
    if not isinstance(resultType,_hipDataType__Base):
        raise TypeError("argument 'resultType' must be of type '_hipDataType__Base'")                    
    if not isinstance(executionType,_hipDataType__Base):
        raise TypeError("argument 'executionType' must be of type '_hipDataType__Base'")
    _hipblasDotcStridedBatchedEx_v2_64__retval = hipblasStatus_t(chipblas.hipblasDotcStridedBatchedEx_v2_64(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,n,
        <const void *>hip._util.types.Pointer.fromPyobj(x)._ptr,xType.value,incx,stridex,
        <const void *>hip._util.types.Pointer.fromPyobj(y)._ptr,yType.value,incy,stridey,batchCount,
        <void *>hip._util.types.Pointer.fromPyobj(result)._ptr,resultType.value,executionType.value))
    return (_hipblasDotcStridedBatchedEx_v2_64__retval,)


@cython.embedsignature(True)
def hipblasNrm2Ex(object handle, int n, object x, object xType, int incx, object result, object resultType, object executionType):
    r"""BLAS_EX API

    nrm2Ex computes the euclidean norm of a real or complex vector

    result := sqrt( x'*x ) for real vectors
              result := sqrt( x**H*x ) for complex vectors

    - Supported types are determined by the backend. See rocBLAS/cuBLAS documentation.

    With HIPBLAS_V2 define, hipblasNrm2Ex accepts hipDataType for xType, resultType,
    and executionType rather than hipblasDatatype_t. hipblasNrm2Ex will only accept
    hipDataType in a future release.

        `~.ifdef` HIPBLAS_V2 // available in hipBLAS version 2.0.0 and later with -DHIPBLAS_V2

            hipblasStatus_t hipblasNrm2Ex(hipblasHandle_t handle,
                                          int             n,
                                          const void*     x,
                                          hipDataType     xType,
                                          int             incx,
                                          void*           result,
                                          hipDataType     resultType,
                                          hipDataType     executionType)

        `~.else` // [DEPRECATED]

            hipblasStatus_t hipblasNrm2Ex(hipblasHandle_t   handle,
                                          int               n,
                                          const void*       x,
                                          hipblasDatatype_t xType,
                                          int               incx,
                                          void*             result,
                                          hipblasDatatype_t resultType,
                                          hipblasDatatype_t executionType)

        `~.endif`

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`) -- *IN*:
            [hipblasHandle_t]
            handle to the hipblas library context queue.

        n (`~.int`) -- *IN*:
            [int]
            the number of elements in x.

        x (`~.hip._util.types.Pointer`/`~.object`) -- *IN*:
            device pointer storing vector x.

        xType (`~.hipblasDatatype_t`) -- *IN*:
            [hipblasDatatype_t] [DEPRECATED]
                      specifies the datatype of the vector x.

            [hipDataType]
                      specifies the datatype of the vector x.

        incx (`~.int`) -- *IN*:
            [int]
            specifies the increment for the elements of y.

        result (`~.hip._util.types.Pointer`/`~.object`) -- *INOUT*:
            device pointer or host pointer to store the nrm2 product.
            return is 0.0 if n, incx<=0.

        resultType (`~.hipblasDatatype_t`) -- *IN*:
            [hipblasDatatype_t] [DEPRECATED]
                      specifies the datatype of the result.

            [hipDataType]
                      specifies the datatype of the result.

        executionType (`~.hipblasDatatype_t`) -- *IN*:
            [hipblasDatatype_t] [DEPRECATED]
                      specifies the datatype of computation.

            [hipDataType]
                      specifies the datatype of computation.
    """
    if not isinstance(xType,_hipblasDatatype_t__Base):
        raise TypeError("argument 'xType' must be of type '_hipblasDatatype_t__Base'")                    
    if not isinstance(resultType,_hipblasDatatype_t__Base):
        raise TypeError("argument 'resultType' must be of type '_hipblasDatatype_t__Base'")                    
    if not isinstance(executionType,_hipblasDatatype_t__Base):
        raise TypeError("argument 'executionType' must be of type '_hipblasDatatype_t__Base'")
    _hipblasNrm2Ex__retval = hipblasStatus_t(chipblas.hipblasNrm2Ex(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,n,
        <const void *>hip._util.types.Pointer.fromPyobj(x)._ptr,xType.value,incx,
        <void *>hip._util.types.Pointer.fromPyobj(result)._ptr,resultType.value,executionType.value))
    return (_hipblasNrm2Ex__retval,)


@cython.embedsignature(True)
def hipblasNrm2Ex_v2(object handle, int n, object x, object xType, int incx, object result, object resultType, object executionType):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        x (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        xType (`~.hipDataType`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        result (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        resultType (`~.hipDataType`):
            (undocumented)

        executionType (`~.hipDataType`):
            (undocumented)
    """
    if not isinstance(xType,_hipDataType__Base):
        raise TypeError("argument 'xType' must be of type '_hipDataType__Base'")                    
    if not isinstance(resultType,_hipDataType__Base):
        raise TypeError("argument 'resultType' must be of type '_hipDataType__Base'")                    
    if not isinstance(executionType,_hipDataType__Base):
        raise TypeError("argument 'executionType' must be of type '_hipDataType__Base'")
    _hipblasNrm2Ex_v2__retval = hipblasStatus_t(chipblas.hipblasNrm2Ex_v2(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,n,
        <const void *>hip._util.types.Pointer.fromPyobj(x)._ptr,xType.value,incx,
        <void *>hip._util.types.Pointer.fromPyobj(result)._ptr,resultType.value,executionType.value))
    return (_hipblasNrm2Ex_v2__retval,)


@cython.embedsignature(True)
def hipblasNrm2Ex_64(object handle, long n, object x, object xType, long incx, object result, object resultType, object executionType):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        x (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        xType (`~.hipblasDatatype_t`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        result (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        resultType (`~.hipblasDatatype_t`):
            (undocumented)

        executionType (`~.hipblasDatatype_t`):
            (undocumented)
    """
    if not isinstance(xType,_hipblasDatatype_t__Base):
        raise TypeError("argument 'xType' must be of type '_hipblasDatatype_t__Base'")                    
    if not isinstance(resultType,_hipblasDatatype_t__Base):
        raise TypeError("argument 'resultType' must be of type '_hipblasDatatype_t__Base'")                    
    if not isinstance(executionType,_hipblasDatatype_t__Base):
        raise TypeError("argument 'executionType' must be of type '_hipblasDatatype_t__Base'")
    _hipblasNrm2Ex_64__retval = hipblasStatus_t(chipblas.hipblasNrm2Ex_64(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,n,
        <const void *>hip._util.types.Pointer.fromPyobj(x)._ptr,xType.value,incx,
        <void *>hip._util.types.Pointer.fromPyobj(result)._ptr,resultType.value,executionType.value))
    return (_hipblasNrm2Ex_64__retval,)


@cython.embedsignature(True)
def hipblasNrm2Ex_v2_64(object handle, long n, object x, object xType, long incx, object result, object resultType, object executionType):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        x (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        xType (`~.hipDataType`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        result (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        resultType (`~.hipDataType`):
            (undocumented)

        executionType (`~.hipDataType`):
            (undocumented)
    """
    if not isinstance(xType,_hipDataType__Base):
        raise TypeError("argument 'xType' must be of type '_hipDataType__Base'")                    
    if not isinstance(resultType,_hipDataType__Base):
        raise TypeError("argument 'resultType' must be of type '_hipDataType__Base'")                    
    if not isinstance(executionType,_hipDataType__Base):
        raise TypeError("argument 'executionType' must be of type '_hipDataType__Base'")
    _hipblasNrm2Ex_v2_64__retval = hipblasStatus_t(chipblas.hipblasNrm2Ex_v2_64(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,n,
        <const void *>hip._util.types.Pointer.fromPyobj(x)._ptr,xType.value,incx,
        <void *>hip._util.types.Pointer.fromPyobj(result)._ptr,resultType.value,executionType.value))
    return (_hipblasNrm2Ex_v2_64__retval,)


@cython.embedsignature(True)
def hipblasNrm2BatchedEx(object handle, int n, object x, object xType, int incx, int batchCount, object result, object resultType, object executionType):
    r"""BLAS_EX API

    nrm2BatchedEx computes the euclidean norm over a batch of real or complex vectors

    result := sqrt( x_i'*x_i ) for real vectors x, for i = 1, ..., batchCount
              result := sqrt( x_i**H*x_i ) for complex vectors x, for i = 1, ..., batchCount

    - Supported types are determined by the backend. See rocBLAS/cuBLAS documentation.

    With HIPBLAS_V2 define, hipblasNrm2BatchedEx accepts hipDataType for xType, resultType,
    and executionType rather than hipblasDatatype_t. hipblasNrm2BatchedEx will only accept
    hipDataType in a future release.

        `~.ifdef` HIPBLAS_V2 // available in hipBLAS version 2.0.0 and later with -DHIPBLAS_V2

            hipblasStatus_t hipblasNrm2BatchedEx(hipblasHandle_t handle,
                                                 int             n,
                                                 const void*     x,
                                                 hipDataType     xType,
                                                 int             incx,
                                                 int             batchCount,
                                                 void*           result,
                                                 hipDataType     resultType,
                                                 hipDataType     executionType)

        `~.else` // [DEPRECATED]

            hipblasStatus_t hipblasNrm2BatchedEx(hipblasHandle_t   handle,
                                                 int               n,
                                                 const void*       x,
                                                 hipblasDatatype_t xType,
                                                 int               incx,
                                                 int               batchCount,
                                                 void*             result,
                                                 hipblasDatatype_t resultType,
                                                 hipblasDatatype_t executionType)

        `~.endif`

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`) -- *IN*:
            [hipblasHandle_t]
            handle to the hipblas library context queue.

        n (`~.int`) -- *IN*:
            [int]
            number of elements in each x_i.

        x (`~.hip._util.types.Pointer`/`~.object`) -- *IN*:
            device array of device pointers storing each vector x_i.

        xType (`~.hipblasDatatype_t`) -- *IN*:
            [hipblasDatatype_t] [DEPRECATED]
                      specifies the datatype of each vector x_i.

            [hipDataType]
                      specifies the datatype of each vector x_i.

        incx (`~.int`) -- *IN*:
            [int]
            specifies the increment for the elements of each x_i. incx must be > 0.

        batchCount (`~.int`) -- *IN*:
            [int]
            number of instances in the batch

        result (`~.hip._util.types.Pointer`/`~.object`) -- *OUT*:
            device pointer or host pointer to array of batchCount size for nrm2 results.
            return is 0.0 for each element if n <= 0, incx<=0.

        resultType (`~.hipblasDatatype_t`) -- *IN*:
            [hipblasDatatype_t] [DEPRECATED]
                      specifies the datatype of the result.

            [hipDataType]
                      specifies the datatype of the result.

        executionType (`~.hipblasDatatype_t`) -- *IN*:
            [hipblasDatatype_t] [DEPRECATED]
                      specifies the datatype of computation.

            [hipDataType]
                      specifies the datatype of computation.
    """
    if not isinstance(xType,_hipblasDatatype_t__Base):
        raise TypeError("argument 'xType' must be of type '_hipblasDatatype_t__Base'")                    
    if not isinstance(resultType,_hipblasDatatype_t__Base):
        raise TypeError("argument 'resultType' must be of type '_hipblasDatatype_t__Base'")                    
    if not isinstance(executionType,_hipblasDatatype_t__Base):
        raise TypeError("argument 'executionType' must be of type '_hipblasDatatype_t__Base'")
    _hipblasNrm2BatchedEx__retval = hipblasStatus_t(chipblas.hipblasNrm2BatchedEx(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,n,
        <const void *>hip._util.types.Pointer.fromPyobj(x)._ptr,xType.value,incx,batchCount,
        <void *>hip._util.types.Pointer.fromPyobj(result)._ptr,resultType.value,executionType.value))
    return (_hipblasNrm2BatchedEx__retval,)


@cython.embedsignature(True)
def hipblasNrm2BatchedEx_v2(object handle, int n, object x, object xType, int incx, int batchCount, object result, object resultType, object executionType):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        x (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        xType (`~.hipDataType`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)

        result (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        resultType (`~.hipDataType`):
            (undocumented)

        executionType (`~.hipDataType`):
            (undocumented)
    """
    if not isinstance(xType,_hipDataType__Base):
        raise TypeError("argument 'xType' must be of type '_hipDataType__Base'")                    
    if not isinstance(resultType,_hipDataType__Base):
        raise TypeError("argument 'resultType' must be of type '_hipDataType__Base'")                    
    if not isinstance(executionType,_hipDataType__Base):
        raise TypeError("argument 'executionType' must be of type '_hipDataType__Base'")
    _hipblasNrm2BatchedEx_v2__retval = hipblasStatus_t(chipblas.hipblasNrm2BatchedEx_v2(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,n,
        <const void *>hip._util.types.Pointer.fromPyobj(x)._ptr,xType.value,incx,batchCount,
        <void *>hip._util.types.Pointer.fromPyobj(result)._ptr,resultType.value,executionType.value))
    return (_hipblasNrm2BatchedEx_v2__retval,)


@cython.embedsignature(True)
def hipblasNrm2BatchedEx_64(object handle, long n, object x, object xType, long incx, long batchCount, object result, object resultType, object executionType):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        x (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        xType (`~.hipblasDatatype_t`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)

        result (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        resultType (`~.hipblasDatatype_t`):
            (undocumented)

        executionType (`~.hipblasDatatype_t`):
            (undocumented)
    """
    if not isinstance(xType,_hipblasDatatype_t__Base):
        raise TypeError("argument 'xType' must be of type '_hipblasDatatype_t__Base'")                    
    if not isinstance(resultType,_hipblasDatatype_t__Base):
        raise TypeError("argument 'resultType' must be of type '_hipblasDatatype_t__Base'")                    
    if not isinstance(executionType,_hipblasDatatype_t__Base):
        raise TypeError("argument 'executionType' must be of type '_hipblasDatatype_t__Base'")
    _hipblasNrm2BatchedEx_64__retval = hipblasStatus_t(chipblas.hipblasNrm2BatchedEx_64(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,n,
        <const void *>hip._util.types.Pointer.fromPyobj(x)._ptr,xType.value,incx,batchCount,
        <void *>hip._util.types.Pointer.fromPyobj(result)._ptr,resultType.value,executionType.value))
    return (_hipblasNrm2BatchedEx_64__retval,)


@cython.embedsignature(True)
def hipblasNrm2BatchedEx_v2_64(object handle, long n, object x, object xType, long incx, long batchCount, object result, object resultType, object executionType):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        x (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        xType (`~.hipDataType`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)

        result (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        resultType (`~.hipDataType`):
            (undocumented)

        executionType (`~.hipDataType`):
            (undocumented)
    """
    if not isinstance(xType,_hipDataType__Base):
        raise TypeError("argument 'xType' must be of type '_hipDataType__Base'")                    
    if not isinstance(resultType,_hipDataType__Base):
        raise TypeError("argument 'resultType' must be of type '_hipDataType__Base'")                    
    if not isinstance(executionType,_hipDataType__Base):
        raise TypeError("argument 'executionType' must be of type '_hipDataType__Base'")
    _hipblasNrm2BatchedEx_v2_64__retval = hipblasStatus_t(chipblas.hipblasNrm2BatchedEx_v2_64(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,n,
        <const void *>hip._util.types.Pointer.fromPyobj(x)._ptr,xType.value,incx,batchCount,
        <void *>hip._util.types.Pointer.fromPyobj(result)._ptr,resultType.value,executionType.value))
    return (_hipblasNrm2BatchedEx_v2_64__retval,)


@cython.embedsignature(True)
def hipblasNrm2StridedBatchedEx(object handle, int n, object x, object xType, int incx, long stridex, int batchCount, object result, object resultType, object executionType):
    r"""BLAS_EX API

    nrm2StridedBatchedEx computes the euclidean norm over a batch of real or complex vectors

    = sqrt( x_i'*x_i ) for real vectors x, for i = 1, ..., batchCount
              := sqrt( x_i**H*x_i ) for complex vectors, for i = 1, ..., batchCount

    - Supported types are determined by the backend. See rocBLAS/cuBLAS documentation.

    With HIPBLAS_V2 define, hipblasNrm2StridedBatchedEx accepts hipDataType for xType, resultType,
    and executionType rather than hipblasDatatype_t. hipblasNrm2StridedBatchedEx will only accept
    hipDataType in a future release.

        `~.ifdef` HIPBLAS_V2 // available in hipBLAS version 2.0.0 and later with -DHIPBLAS_V2

            hipblasStatus_t hipblasNrm2StridedBatchedEx(hipblasHandle_t handle,
                                                        int             n,
                                                        const void*     x,
                                                        hipDataType     xType,
                                                        int             incx,
                                                        hipblasStride   stridex,
                                                        int             batchCount,
                                                        void*           result,
                                                        hipDataType     resultType,
                                                        hipDataType     executionType)

        `~.else` // [DEPRECATED]

            hipblasStatus_t hipblasNrm2StridedBatchedEx(hipblasHandle_t   handle,
                                                        int               n,
                                                        const void*       x,
                                                        hipblasDatatype_t xType,
                                                        int               incx,
                                                        hipblasStride     stridex,
                                                        int               batchCount,
                                                        void*             result,
                                                        hipblasDatatype_t resultType,
                                                        hipblasDatatype_t executionType)

        `~.endif`

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`) -- *IN*:
            [hipblasHandle_t]
            handle to the hipblas library context queue.

        n (`~.int`) -- *IN*:
            [int]
            number of elements in each x_i.

        x (`~.hip._util.types.Pointer`/`~.object`) -- *IN*:
            device pointer to the first vector x_1.

        xType (`~.hipblasDatatype_t`) -- *IN*:
            [hipblasDatatype_t] [DEPRECATED]
                      specifies the datatype of each vector x_i.

            [hipDataType]
                      specifies the datatype of each vector x_i.

        incx (`~.int`) -- *IN*:
            [int]
            specifies the increment for the elements of each x_i. incx must be > 0.

        stridex (`~.int`) -- *IN*:
            [hipblasStride]
            stride from the start of one vector (x_i) and the next one (x_i+1).
            There are no restrictions placed on stride_x, however the user should
            take care to ensure that stride_x is of appropriate size, for a typical
            case this means stride_x >= n * incx.

        batchCount (`~.int`) -- *IN*:
            [int]
            number of instances in the batch

        result (`~.hip._util.types.Pointer`/`~.object`) -- *OUT*:
            device pointer or host pointer to array for storing contiguous batchCount results.
            return is 0.0 for each element if n <= 0, incx<=0.

        resultType (`~.hipblasDatatype_t`) -- *IN*:
            [hipblasDatatype_t] [DEPRECATED]
                      specifies the datatype of the result.

            [hipDataType]
                      specifies the datatype of the result.

        executionType (`~.hipblasDatatype_t`) -- *IN*:
            [hipblasDatatype_t] [DEPRECATED]
                      specifies the datatype of computation.

            [hipDataType]
                      specifies the datatype of computation.
    """
    if not isinstance(xType,_hipblasDatatype_t__Base):
        raise TypeError("argument 'xType' must be of type '_hipblasDatatype_t__Base'")                    
    if not isinstance(resultType,_hipblasDatatype_t__Base):
        raise TypeError("argument 'resultType' must be of type '_hipblasDatatype_t__Base'")                    
    if not isinstance(executionType,_hipblasDatatype_t__Base):
        raise TypeError("argument 'executionType' must be of type '_hipblasDatatype_t__Base'")
    _hipblasNrm2StridedBatchedEx__retval = hipblasStatus_t(chipblas.hipblasNrm2StridedBatchedEx(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,n,
        <const void *>hip._util.types.Pointer.fromPyobj(x)._ptr,xType.value,incx,stridex,batchCount,
        <void *>hip._util.types.Pointer.fromPyobj(result)._ptr,resultType.value,executionType.value))
    return (_hipblasNrm2StridedBatchedEx__retval,)


@cython.embedsignature(True)
def hipblasNrm2StridedBatchedEx_v2(object handle, int n, object x, object xType, int incx, long stridex, int batchCount, object result, object resultType, object executionType):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        x (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        xType (`~.hipDataType`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        stridex (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)

        result (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        resultType (`~.hipDataType`):
            (undocumented)

        executionType (`~.hipDataType`):
            (undocumented)
    """
    if not isinstance(xType,_hipDataType__Base):
        raise TypeError("argument 'xType' must be of type '_hipDataType__Base'")                    
    if not isinstance(resultType,_hipDataType__Base):
        raise TypeError("argument 'resultType' must be of type '_hipDataType__Base'")                    
    if not isinstance(executionType,_hipDataType__Base):
        raise TypeError("argument 'executionType' must be of type '_hipDataType__Base'")
    _hipblasNrm2StridedBatchedEx_v2__retval = hipblasStatus_t(chipblas.hipblasNrm2StridedBatchedEx_v2(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,n,
        <const void *>hip._util.types.Pointer.fromPyobj(x)._ptr,xType.value,incx,stridex,batchCount,
        <void *>hip._util.types.Pointer.fromPyobj(result)._ptr,resultType.value,executionType.value))
    return (_hipblasNrm2StridedBatchedEx_v2__retval,)


@cython.embedsignature(True)
def hipblasNrm2StridedBatchedEx_64(object handle, long n, object x, object xType, long incx, long stridex, long batchCount, object result, object resultType, object executionType):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        x (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        xType (`~.hipblasDatatype_t`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        stridex (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)

        result (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        resultType (`~.hipblasDatatype_t`):
            (undocumented)

        executionType (`~.hipblasDatatype_t`):
            (undocumented)
    """
    if not isinstance(xType,_hipblasDatatype_t__Base):
        raise TypeError("argument 'xType' must be of type '_hipblasDatatype_t__Base'")                    
    if not isinstance(resultType,_hipblasDatatype_t__Base):
        raise TypeError("argument 'resultType' must be of type '_hipblasDatatype_t__Base'")                    
    if not isinstance(executionType,_hipblasDatatype_t__Base):
        raise TypeError("argument 'executionType' must be of type '_hipblasDatatype_t__Base'")
    _hipblasNrm2StridedBatchedEx_64__retval = hipblasStatus_t(chipblas.hipblasNrm2StridedBatchedEx_64(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,n,
        <const void *>hip._util.types.Pointer.fromPyobj(x)._ptr,xType.value,incx,stridex,batchCount,
        <void *>hip._util.types.Pointer.fromPyobj(result)._ptr,resultType.value,executionType.value))
    return (_hipblasNrm2StridedBatchedEx_64__retval,)


@cython.embedsignature(True)
def hipblasNrm2StridedBatchedEx_v2_64(object handle, long n, object x, object xType, long incx, long stridex, long batchCount, object result, object resultType, object executionType):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        x (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        xType (`~.hipDataType`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        stridex (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)

        result (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        resultType (`~.hipDataType`):
            (undocumented)

        executionType (`~.hipDataType`):
            (undocumented)
    """
    if not isinstance(xType,_hipDataType__Base):
        raise TypeError("argument 'xType' must be of type '_hipDataType__Base'")                    
    if not isinstance(resultType,_hipDataType__Base):
        raise TypeError("argument 'resultType' must be of type '_hipDataType__Base'")                    
    if not isinstance(executionType,_hipDataType__Base):
        raise TypeError("argument 'executionType' must be of type '_hipDataType__Base'")
    _hipblasNrm2StridedBatchedEx_v2_64__retval = hipblasStatus_t(chipblas.hipblasNrm2StridedBatchedEx_v2_64(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,n,
        <const void *>hip._util.types.Pointer.fromPyobj(x)._ptr,xType.value,incx,stridex,batchCount,
        <void *>hip._util.types.Pointer.fromPyobj(result)._ptr,resultType.value,executionType.value))
    return (_hipblasNrm2StridedBatchedEx_v2_64__retval,)


@cython.embedsignature(True)
def hipblasRotEx(object handle, int n, object x, object xType, int incx, object y, object yType, int incy, object c, object s, object csType, object executionType):
    r"""BLAS EX API

    rotEx applies the Givens rotation matrix defined by c=cos(alpha) and s=sin(alpha) to vectors x and y.
    Scalars c and s may be stored in either host or device memory, location is specified by calling hipblasSetPointerMode.

    In the case where cs_type is real:
        x := c * x + s * y
            y := c * y - s * x

    In the case where cs_type is complex, the imaginary part of c is ignored:
        x := real(c) * x + s * y
            y := real(c) * y - conj(s) * x

    - Supported types are determined by the backend. See rocBLAS/cuBLAS documentation.

    With HIPBLAS_V2 define, hipblasRotEx accepts hipDataType for xType, yType, csType,
    and executionType rather than hipblasDatatype_t. hipblasRotEx will only accept
    hipDataType in a future release.

        `~.ifdef` HIPBLAS_V2 // available in hipBLAS version 2.0.0 and later with -DHIPBLAS_V2

            hipblasStatus_t hipblasRotEx(hipblasHandle_t handle,
                                         int             n,
                                         void*           x,
                                         hipDataType     xType,
                                         int             incx,
                                         void*           y,
                                         hipDataType     yType,
                                         int             incy,
                                         const void*     c,
                                         const void*     s,
                                         hipDataType     csType,
                                         hipDataType     executionType)

        `~.else` // [DEPRECATED]

            hipblasStatus_t hipblasRotEx(hipblasHandle_t   handle,
                                         int               n,
                                         void*             x,
                                         hipblasDatatype_t xType,
                                         int               incx,
                                         void*             y,
                                         hipblasDatatype_t yType,
                                         int               incy,
                                         const void*       c,
                                         const void*       s,
                                         hipblasDatatype_t csType,
                                         hipblasDatatype_t executionType)

        `~.endif`

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`) -- *IN*:
            [hipblasHandle_t]
            handle to the hipblas library context queue.

        n (`~.int`) -- *IN*:
            [int]
            number of elements in the x and y vectors.

        x (`~.hip._util.types.Pointer`/`~.object`) -- *INOUT*:
            device pointer storing vector x.

        xType (`~.hipblasDatatype_t`) -- *IN*:
            [hipblasDatatype_t] [DEPRECATED]
                    specifies the datatype of vector x.

            [hipDataType]
                    specifies the datatype of vector x.

        incx (`~.int`) -- *IN*:
            [int]
            specifies the increment between elements of x.

        y (`~.hip._util.types.Pointer`/`~.object`) -- *INOUT*:
            device pointer storing vector y.

        yType (`~.hipblasDatatype_t`) -- *IN*:
            [hipblasDatatype_t] [DEPRECATED]
                    specifies the datatype of vector y.

            [hipDataType]
                    specifies the datatype of vector y.

        incy (`~.int`) -- *IN*:
            [int]
            specifies the increment between elements of y.

        c (`~.hip._util.types.Pointer`/`~.object`) -- *IN*:
            device pointer or host pointer storing scalar cosine component of the rotation matrix.

        s (`~.hip._util.types.Pointer`/`~.object`) -- *IN*:
            device pointer or host pointer storing scalar sine component of the rotation matrix.

        csType (`~.hipblasDatatype_t`) -- *IN*:
            [hipblasDatatype_t] [DEPRECATED]
                    specifies the datatype of c and s.

            [hipDataType]
                    specifies the datatype of c and s.

        executionType (`~.hipblasDatatype_t`) -- *IN*:
            [hipblasDatatype_t] [DEPRECATED]
                    specifies the datatype of computation.

            [hipDataType]
                    specifies the datatype of computation.
    """
    if not isinstance(xType,_hipblasDatatype_t__Base):
        raise TypeError("argument 'xType' must be of type '_hipblasDatatype_t__Base'")                    
    if not isinstance(yType,_hipblasDatatype_t__Base):
        raise TypeError("argument 'yType' must be of type '_hipblasDatatype_t__Base'")                    
    if not isinstance(csType,_hipblasDatatype_t__Base):
        raise TypeError("argument 'csType' must be of type '_hipblasDatatype_t__Base'")                    
    if not isinstance(executionType,_hipblasDatatype_t__Base):
        raise TypeError("argument 'executionType' must be of type '_hipblasDatatype_t__Base'")
    _hipblasRotEx__retval = hipblasStatus_t(chipblas.hipblasRotEx(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,n,
        <void *>hip._util.types.Pointer.fromPyobj(x)._ptr,xType.value,incx,
        <void *>hip._util.types.Pointer.fromPyobj(y)._ptr,yType.value,incy,
        <const void *>hip._util.types.Pointer.fromPyobj(c)._ptr,
        <const void *>hip._util.types.Pointer.fromPyobj(s)._ptr,csType.value,executionType.value))
    return (_hipblasRotEx__retval,)


@cython.embedsignature(True)
def hipblasRotEx_v2(object handle, int n, object x, object xType, int incx, object y, object yType, int incy, object c, object s, object csType, object executionType):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        x (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        xType (`~.hipDataType`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        y (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        yType (`~.hipDataType`):
            (undocumented)

        incy (`~.int`):
            (undocumented)

        c (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        s (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        csType (`~.hipDataType`):
            (undocumented)

        executionType (`~.hipDataType`):
            (undocumented)
    """
    if not isinstance(xType,_hipDataType__Base):
        raise TypeError("argument 'xType' must be of type '_hipDataType__Base'")                    
    if not isinstance(yType,_hipDataType__Base):
        raise TypeError("argument 'yType' must be of type '_hipDataType__Base'")                    
    if not isinstance(csType,_hipDataType__Base):
        raise TypeError("argument 'csType' must be of type '_hipDataType__Base'")                    
    if not isinstance(executionType,_hipDataType__Base):
        raise TypeError("argument 'executionType' must be of type '_hipDataType__Base'")
    _hipblasRotEx_v2__retval = hipblasStatus_t(chipblas.hipblasRotEx_v2(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,n,
        <void *>hip._util.types.Pointer.fromPyobj(x)._ptr,xType.value,incx,
        <void *>hip._util.types.Pointer.fromPyobj(y)._ptr,yType.value,incy,
        <const void *>hip._util.types.Pointer.fromPyobj(c)._ptr,
        <const void *>hip._util.types.Pointer.fromPyobj(s)._ptr,csType.value,executionType.value))
    return (_hipblasRotEx_v2__retval,)


@cython.embedsignature(True)
def hipblasRotEx_64(object handle, long n, object x, object xType, long incx, object y, object yType, long incy, object c, object s, object csType, object executionType):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        x (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        xType (`~.hipblasDatatype_t`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        y (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        yType (`~.hipblasDatatype_t`):
            (undocumented)

        incy (`~.int`):
            (undocumented)

        c (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        s (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        csType (`~.hipblasDatatype_t`):
            (undocumented)

        executionType (`~.hipblasDatatype_t`):
            (undocumented)
    """
    if not isinstance(xType,_hipblasDatatype_t__Base):
        raise TypeError("argument 'xType' must be of type '_hipblasDatatype_t__Base'")                    
    if not isinstance(yType,_hipblasDatatype_t__Base):
        raise TypeError("argument 'yType' must be of type '_hipblasDatatype_t__Base'")                    
    if not isinstance(csType,_hipblasDatatype_t__Base):
        raise TypeError("argument 'csType' must be of type '_hipblasDatatype_t__Base'")                    
    if not isinstance(executionType,_hipblasDatatype_t__Base):
        raise TypeError("argument 'executionType' must be of type '_hipblasDatatype_t__Base'")
    _hipblasRotEx_64__retval = hipblasStatus_t(chipblas.hipblasRotEx_64(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,n,
        <void *>hip._util.types.Pointer.fromPyobj(x)._ptr,xType.value,incx,
        <void *>hip._util.types.Pointer.fromPyobj(y)._ptr,yType.value,incy,
        <const void *>hip._util.types.Pointer.fromPyobj(c)._ptr,
        <const void *>hip._util.types.Pointer.fromPyobj(s)._ptr,csType.value,executionType.value))
    return (_hipblasRotEx_64__retval,)


@cython.embedsignature(True)
def hipblasRotEx_v2_64(object handle, long n, object x, object xType, long incx, object y, object yType, long incy, object c, object s, object csType, object executionType):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        x (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        xType (`~.hipDataType`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        y (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        yType (`~.hipDataType`):
            (undocumented)

        incy (`~.int`):
            (undocumented)

        c (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        s (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        csType (`~.hipDataType`):
            (undocumented)

        executionType (`~.hipDataType`):
            (undocumented)
    """
    if not isinstance(xType,_hipDataType__Base):
        raise TypeError("argument 'xType' must be of type '_hipDataType__Base'")                    
    if not isinstance(yType,_hipDataType__Base):
        raise TypeError("argument 'yType' must be of type '_hipDataType__Base'")                    
    if not isinstance(csType,_hipDataType__Base):
        raise TypeError("argument 'csType' must be of type '_hipDataType__Base'")                    
    if not isinstance(executionType,_hipDataType__Base):
        raise TypeError("argument 'executionType' must be of type '_hipDataType__Base'")
    _hipblasRotEx_v2_64__retval = hipblasStatus_t(chipblas.hipblasRotEx_v2_64(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,n,
        <void *>hip._util.types.Pointer.fromPyobj(x)._ptr,xType.value,incx,
        <void *>hip._util.types.Pointer.fromPyobj(y)._ptr,yType.value,incy,
        <const void *>hip._util.types.Pointer.fromPyobj(c)._ptr,
        <const void *>hip._util.types.Pointer.fromPyobj(s)._ptr,csType.value,executionType.value))
    return (_hipblasRotEx_v2_64__retval,)


@cython.embedsignature(True)
def hipblasRotBatchedEx(object handle, int n, object x, object xType, int incx, object y, object yType, int incy, object c, object s, object csType, int batchCount, object executionType):
    r"""BLAS EX API

    rotBatchedEx applies the Givens rotation matrix defined by c=cos(alpha) and s=sin(alpha) to batched vectors x_i and y_i, for i = 1, ..., batchCount.
    Scalars c and s may be stored in either host or device memory, location is specified by calling hipblasSetPointerMode.

    In the case where cs_type is real:
            x := c * x + s * y
            y := c * y - s * x

        In the case where cs_type is complex, the imaginary part of c is ignored:
            x := real(c) * x + s * y
            y := real(c) * y - conj(s) * x

    - Supported types are determined by the backend. See rocBLAS/cuBLAS documentation.

    With HIPBLAS_V2 define, hipblasRotBatchedEx accepts hipDataType for xType, yType, csType,
    and executionType rather than hipblasDatatype_t. hipblasRotBatchedEx will only accept
    hipDataType in a future release.

        `~.ifdef` HIPBLAS_V2 // available in hipBLAS version 2.0.0 and later with -DHIPBLAS_V2

            hipblasStatus_t hipblasRotBatchedEx(hipblasHandle_t handle,
                                                int             n,
                                                void*           x,
                                                hipDataType     xType,
                                                int             incx,
                                                void*           y,
                                                hipDataType     yType,
                                                int             incy,
                                                const void*     c,
                                                const void*     s,
                                                hipDataType     csType,
                                                int             batchCount,
                                                hipDataType     executionType)

        `~.else` // [DEPRECATED]

            hipblasStatus_t hipblasRotBatchedEx(hipblasHandle_t   handle,
                                                int               n,
                                                void*             x,
                                                hipblasDatatype_t xType,
                                                int               incx,
                                                void*             y,
                                                hipblasDatatype_t yType,
                                                int               incy,
                                                const void*       c,
                                                const void*       s,
                                                hipblasDatatype_t csType,
                                                int               batchCount,
                                                hipblasDatatype_t executionType)

        `~.endif`

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`) -- *IN*:
            [hipblasHandle_t]
            handle to the hipblas library context queue.

        n (`~.int`) -- *IN*:
            [int]
            number of elements in each x_i and y_i vectors.

        x (`~.hip._util.types.Pointer`/`~.object`) -- *INOUT*:
            device array of device pointers storing each vector x_i.

        xType (`~.hipblasDatatype_t`) -- *IN*:
            [hipblasDatatype_t] [DEPRECATED]
                    specifies the datatype of each vector x_i.

            [hipDataType]
                    specifies the datatype of each vector x_i.

        incx (`~.int`) -- *IN*:
            [int]
            specifies the increment between elements of each x_i.

        y (`~.hip._util.types.Pointer`/`~.object`) -- *INOUT*:
            device array of device pointers storing each vector y_i.

        yType (`~.hipblasDatatype_t`) -- *IN*:
            [hipblasDatatype_t] [DEPRECATED]
                    specifies the datatype of each vector y_i.

            [hipDataType]
                    specifies the datatype of each vector y_i.

        incy (`~.int`) -- *IN*:
            [int]
            specifies the increment between elements of each y_i.

        c (`~.hip._util.types.Pointer`/`~.object`) -- *IN*:
            device pointer or host pointer to scalar cosine component of the rotation matrix.

        s (`~.hip._util.types.Pointer`/`~.object`) -- *IN*:
            device pointer or host pointer to scalar sine component of the rotation matrix.

        csType (`~.hipblasDatatype_t`) -- *IN*:
            [hipblasDatatype_t] [DEPRECATED]
                    specifies the datatype of c and s.

            [hipDataType]
                    specifies the datatype of c and s.

        batchCount (`~.int`) -- *IN*:
            [int]
            the number of x and y arrays, i.e. the number of batches.

        executionType (`~.hipblasDatatype_t`) -- *IN*:
            [hipblasDatatype_t] [DEPRECATED]
                    specifies the datatype of computation.

            [hipDataType]
                    specifies the datatype of computation.
    """
    if not isinstance(xType,_hipblasDatatype_t__Base):
        raise TypeError("argument 'xType' must be of type '_hipblasDatatype_t__Base'")                    
    if not isinstance(yType,_hipblasDatatype_t__Base):
        raise TypeError("argument 'yType' must be of type '_hipblasDatatype_t__Base'")                    
    if not isinstance(csType,_hipblasDatatype_t__Base):
        raise TypeError("argument 'csType' must be of type '_hipblasDatatype_t__Base'")                    
    if not isinstance(executionType,_hipblasDatatype_t__Base):
        raise TypeError("argument 'executionType' must be of type '_hipblasDatatype_t__Base'")
    _hipblasRotBatchedEx__retval = hipblasStatus_t(chipblas.hipblasRotBatchedEx(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,n,
        <void *>hip._util.types.Pointer.fromPyobj(x)._ptr,xType.value,incx,
        <void *>hip._util.types.Pointer.fromPyobj(y)._ptr,yType.value,incy,
        <const void *>hip._util.types.Pointer.fromPyobj(c)._ptr,
        <const void *>hip._util.types.Pointer.fromPyobj(s)._ptr,csType.value,batchCount,executionType.value))
    return (_hipblasRotBatchedEx__retval,)


@cython.embedsignature(True)
def hipblasRotBatchedEx_v2(object handle, int n, object x, object xType, int incx, object y, object yType, int incy, object c, object s, object csType, int batchCount, object executionType):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        x (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        xType (`~.hipDataType`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        y (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        yType (`~.hipDataType`):
            (undocumented)

        incy (`~.int`):
            (undocumented)

        c (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        s (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        csType (`~.hipDataType`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)

        executionType (`~.hipDataType`):
            (undocumented)
    """
    if not isinstance(xType,_hipDataType__Base):
        raise TypeError("argument 'xType' must be of type '_hipDataType__Base'")                    
    if not isinstance(yType,_hipDataType__Base):
        raise TypeError("argument 'yType' must be of type '_hipDataType__Base'")                    
    if not isinstance(csType,_hipDataType__Base):
        raise TypeError("argument 'csType' must be of type '_hipDataType__Base'")                    
    if not isinstance(executionType,_hipDataType__Base):
        raise TypeError("argument 'executionType' must be of type '_hipDataType__Base'")
    _hipblasRotBatchedEx_v2__retval = hipblasStatus_t(chipblas.hipblasRotBatchedEx_v2(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,n,
        <void *>hip._util.types.Pointer.fromPyobj(x)._ptr,xType.value,incx,
        <void *>hip._util.types.Pointer.fromPyobj(y)._ptr,yType.value,incy,
        <const void *>hip._util.types.Pointer.fromPyobj(c)._ptr,
        <const void *>hip._util.types.Pointer.fromPyobj(s)._ptr,csType.value,batchCount,executionType.value))
    return (_hipblasRotBatchedEx_v2__retval,)


@cython.embedsignature(True)
def hipblasRotBatchedEx_64(object handle, long n, object x, object xType, long incx, object y, object yType, long incy, object c, object s, object csType, long batchCount, object executionType):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        x (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        xType (`~.hipblasDatatype_t`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        y (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        yType (`~.hipblasDatatype_t`):
            (undocumented)

        incy (`~.int`):
            (undocumented)

        c (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        s (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        csType (`~.hipblasDatatype_t`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)

        executionType (`~.hipblasDatatype_t`):
            (undocumented)
    """
    if not isinstance(xType,_hipblasDatatype_t__Base):
        raise TypeError("argument 'xType' must be of type '_hipblasDatatype_t__Base'")                    
    if not isinstance(yType,_hipblasDatatype_t__Base):
        raise TypeError("argument 'yType' must be of type '_hipblasDatatype_t__Base'")                    
    if not isinstance(csType,_hipblasDatatype_t__Base):
        raise TypeError("argument 'csType' must be of type '_hipblasDatatype_t__Base'")                    
    if not isinstance(executionType,_hipblasDatatype_t__Base):
        raise TypeError("argument 'executionType' must be of type '_hipblasDatatype_t__Base'")
    _hipblasRotBatchedEx_64__retval = hipblasStatus_t(chipblas.hipblasRotBatchedEx_64(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,n,
        <void *>hip._util.types.Pointer.fromPyobj(x)._ptr,xType.value,incx,
        <void *>hip._util.types.Pointer.fromPyobj(y)._ptr,yType.value,incy,
        <const void *>hip._util.types.Pointer.fromPyobj(c)._ptr,
        <const void *>hip._util.types.Pointer.fromPyobj(s)._ptr,csType.value,batchCount,executionType.value))
    return (_hipblasRotBatchedEx_64__retval,)


@cython.embedsignature(True)
def hipblasRotBatchedEx_v2_64(object handle, long n, object x, object xType, long incx, object y, object yType, long incy, object c, object s, object csType, long batchCount, object executionType):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        x (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        xType (`~.hipDataType`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        y (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        yType (`~.hipDataType`):
            (undocumented)

        incy (`~.int`):
            (undocumented)

        c (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        s (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        csType (`~.hipDataType`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)

        executionType (`~.hipDataType`):
            (undocumented)
    """
    if not isinstance(xType,_hipDataType__Base):
        raise TypeError("argument 'xType' must be of type '_hipDataType__Base'")                    
    if not isinstance(yType,_hipDataType__Base):
        raise TypeError("argument 'yType' must be of type '_hipDataType__Base'")                    
    if not isinstance(csType,_hipDataType__Base):
        raise TypeError("argument 'csType' must be of type '_hipDataType__Base'")                    
    if not isinstance(executionType,_hipDataType__Base):
        raise TypeError("argument 'executionType' must be of type '_hipDataType__Base'")
    _hipblasRotBatchedEx_v2_64__retval = hipblasStatus_t(chipblas.hipblasRotBatchedEx_v2_64(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,n,
        <void *>hip._util.types.Pointer.fromPyobj(x)._ptr,xType.value,incx,
        <void *>hip._util.types.Pointer.fromPyobj(y)._ptr,yType.value,incy,
        <const void *>hip._util.types.Pointer.fromPyobj(c)._ptr,
        <const void *>hip._util.types.Pointer.fromPyobj(s)._ptr,csType.value,batchCount,executionType.value))
    return (_hipblasRotBatchedEx_v2_64__retval,)


@cython.embedsignature(True)
def hipblasRotStridedBatchedEx(object handle, int n, object x, object xType, int incx, long stridex, object y, object yType, int incy, long stridey, object c, object s, object csType, int batchCount, object executionType):
    r"""BLAS Level 1 API

    rotStridedBatchedEx applies the Givens rotation matrix defined by c=cos(alpha) and s=sin(alpha) to strided batched vectors x_i and y_i, for i = 1, ..., batchCount.
    Scalars c and s may be stored in either host or device memory, location is specified by calling hipblasSetPointerMode.

    In the case where cs_type is real:
            x := c * x + s * y
            y := c * y - s * x

        In the case where cs_type is complex, the imaginary part of c is ignored:
            x := real(c) * x + s * y
            y := real(c) * y - conj(s) * x

    - Supported types are determined by the backend. See rocBLAS/cuBLAS documentation.

    With HIPBLAS_V2 define, hipblasRotStridedBatchedEx accepts hipDataType for xType, yType, csType,
    and executionType rather than hipblasDatatype_t. hipblasRotStridedBatchedEx will only accept
    hipDataType in a future release.

         `~.ifdef` HIPBLAS_V2 // available in hipBLAS version 2.0.0 and later with -DHIPBLAS_V2

            hipblasStatus_t hipblasRotStridedBatchedEx(hipblasHandle_t handle,
                                                       int             n,
                                                       void*           x,
                                                       hipDataType     xType,
                                                       int             incx,
                                                       hipblasStride   stridex,
                                                       void*           y,
                                                       hipDataType     yType,
                                                       int             incy,
                                                       hipblasStride   stridey,
                                                       const void*     c,
                                                       const void*     s,
                                                       hipDataType     csType,
                                                       int             batchCount,
                                                       hipDataType     executionType)

        `~.else` // [DEPRECATED]

            hipblasStatus_t hipblasRotStridedBatchedEx(hipblasHandle_t   handle,
                                                       int               n,
                                                       void*             x,
                                                       hipblasDatatype_t xType,
                                                       int               incx,
                                                       hipblasStride     stridex,
                                                       void*             y,
                                                       hipblasDatatype_t yType,
                                                       int               incy,
                                                       hipblasStride     stridey,
                                                       const void*       c,
                                                       const void*       s,
                                                       hipblasDatatype_t csType,
                                                       int               batchCount,
                                                       hipblasDatatype_t executionType)

        `~.endif`

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`) -- *IN*:
            [hipblasHandle_t]
            handle to the hipblas library context queue.

        n (`~.int`) -- *IN*:
            [int]
            number of elements in each x_i and y_i vectors.

        x (`~.hip._util.types.Pointer`/`~.object`) -- *INOUT*:
            device pointer to the first vector x_1.

        xType (`~.hipblasDatatype_t`) -- *IN*:
            [hipblasDatatype_t] [DEPRECATED]
                    specifies the datatype of each vector x_i.

            [hipDataType]
                    specifies the datatype of each vector x_i.

        incx (`~.int`) -- *IN*:
            [int]
            specifies the increment between elements of each x_i.

        stridex (`~.int`) -- *IN*:
            [hipblasStride]
            specifies the increment from the beginning of x_i to the beginning of x_(i+1)

        y (`~.hip._util.types.Pointer`/`~.object`) -- *INOUT*:
            device pointer to the first vector y_1.

        yType (`~.hipblasDatatype_t`) -- *IN*:
            [hipblasDatatype_t] [DEPRECATED]
                    specifies the datatype of each vector y_i.

            [hipDataType]
                    specifies the datatype of each vector y_i.

        incy (`~.int`) -- *IN*:
            [int]
            specifies the increment between elements of each y_i.

        stridey (`~.int`) -- *IN*:
            [hipblasStride]
            specifies the increment from the beginning of y_i to the beginning of y_(i+1)

        c (`~.hip._util.types.Pointer`/`~.object`) -- *IN*:
            device pointer or host pointer to scalar cosine component of the rotation matrix.

        s (`~.hip._util.types.Pointer`/`~.object`) -- *IN*:
            device pointer or host pointer to scalar sine component of the rotation matrix.

        csType (`~.hipblasDatatype_t`) -- *IN*:
            [hipblasDatatype_t] [DEPRECATED]
                    specifies the datatype of c and s.

            [hipDataType]
                    specifies the datatype of c and s.

        batchCount (`~.int`) -- *IN*:
            [int]
            the number of x and y arrays, i.e. the number of batches.

        executionType (`~.hipblasDatatype_t`) -- *IN*:
            [hipblasDatatype_t] [DEPRECATED]
                    specifies the datatype of computation.

            [hipDataType]
                    specifies the datatype of computation.
    """
    if not isinstance(xType,_hipblasDatatype_t__Base):
        raise TypeError("argument 'xType' must be of type '_hipblasDatatype_t__Base'")                    
    if not isinstance(yType,_hipblasDatatype_t__Base):
        raise TypeError("argument 'yType' must be of type '_hipblasDatatype_t__Base'")                    
    if not isinstance(csType,_hipblasDatatype_t__Base):
        raise TypeError("argument 'csType' must be of type '_hipblasDatatype_t__Base'")                    
    if not isinstance(executionType,_hipblasDatatype_t__Base):
        raise TypeError("argument 'executionType' must be of type '_hipblasDatatype_t__Base'")
    _hipblasRotStridedBatchedEx__retval = hipblasStatus_t(chipblas.hipblasRotStridedBatchedEx(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,n,
        <void *>hip._util.types.Pointer.fromPyobj(x)._ptr,xType.value,incx,stridex,
        <void *>hip._util.types.Pointer.fromPyobj(y)._ptr,yType.value,incy,stridey,
        <const void *>hip._util.types.Pointer.fromPyobj(c)._ptr,
        <const void *>hip._util.types.Pointer.fromPyobj(s)._ptr,csType.value,batchCount,executionType.value))
    return (_hipblasRotStridedBatchedEx__retval,)


@cython.embedsignature(True)
def hipblasRotStridedBatchedEx_v2(object handle, int n, object x, object xType, int incx, long stridex, object y, object yType, int incy, long stridey, object c, object s, object csType, int batchCount, object executionType):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        x (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        xType (`~.hipDataType`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        stridex (`~.int`):
            (undocumented)

        y (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        yType (`~.hipDataType`):
            (undocumented)

        incy (`~.int`):
            (undocumented)

        stridey (`~.int`):
            (undocumented)

        c (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        s (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        csType (`~.hipDataType`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)

        executionType (`~.hipDataType`):
            (undocumented)
    """
    if not isinstance(xType,_hipDataType__Base):
        raise TypeError("argument 'xType' must be of type '_hipDataType__Base'")                    
    if not isinstance(yType,_hipDataType__Base):
        raise TypeError("argument 'yType' must be of type '_hipDataType__Base'")                    
    if not isinstance(csType,_hipDataType__Base):
        raise TypeError("argument 'csType' must be of type '_hipDataType__Base'")                    
    if not isinstance(executionType,_hipDataType__Base):
        raise TypeError("argument 'executionType' must be of type '_hipDataType__Base'")
    _hipblasRotStridedBatchedEx_v2__retval = hipblasStatus_t(chipblas.hipblasRotStridedBatchedEx_v2(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,n,
        <void *>hip._util.types.Pointer.fromPyobj(x)._ptr,xType.value,incx,stridex,
        <void *>hip._util.types.Pointer.fromPyobj(y)._ptr,yType.value,incy,stridey,
        <const void *>hip._util.types.Pointer.fromPyobj(c)._ptr,
        <const void *>hip._util.types.Pointer.fromPyobj(s)._ptr,csType.value,batchCount,executionType.value))
    return (_hipblasRotStridedBatchedEx_v2__retval,)


@cython.embedsignature(True)
def hipblasRotStridedBatchedEx_64(object handle, long n, object x, object xType, long incx, long stridex, object y, object yType, long incy, long stridey, object c, object s, object csType, long batchCount, object executionType):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        x (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        xType (`~.hipblasDatatype_t`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        stridex (`~.int`):
            (undocumented)

        y (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        yType (`~.hipblasDatatype_t`):
            (undocumented)

        incy (`~.int`):
            (undocumented)

        stridey (`~.int`):
            (undocumented)

        c (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        s (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        csType (`~.hipblasDatatype_t`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)

        executionType (`~.hipblasDatatype_t`):
            (undocumented)
    """
    if not isinstance(xType,_hipblasDatatype_t__Base):
        raise TypeError("argument 'xType' must be of type '_hipblasDatatype_t__Base'")                    
    if not isinstance(yType,_hipblasDatatype_t__Base):
        raise TypeError("argument 'yType' must be of type '_hipblasDatatype_t__Base'")                    
    if not isinstance(csType,_hipblasDatatype_t__Base):
        raise TypeError("argument 'csType' must be of type '_hipblasDatatype_t__Base'")                    
    if not isinstance(executionType,_hipblasDatatype_t__Base):
        raise TypeError("argument 'executionType' must be of type '_hipblasDatatype_t__Base'")
    _hipblasRotStridedBatchedEx_64__retval = hipblasStatus_t(chipblas.hipblasRotStridedBatchedEx_64(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,n,
        <void *>hip._util.types.Pointer.fromPyobj(x)._ptr,xType.value,incx,stridex,
        <void *>hip._util.types.Pointer.fromPyobj(y)._ptr,yType.value,incy,stridey,
        <const void *>hip._util.types.Pointer.fromPyobj(c)._ptr,
        <const void *>hip._util.types.Pointer.fromPyobj(s)._ptr,csType.value,batchCount,executionType.value))
    return (_hipblasRotStridedBatchedEx_64__retval,)


@cython.embedsignature(True)
def hipblasRotStridedBatchedEx_v2_64(object handle, long n, object x, object xType, long incx, long stridex, object y, object yType, long incy, long stridey, object c, object s, object csType, long batchCount, object executionType):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        x (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        xType (`~.hipDataType`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        stridex (`~.int`):
            (undocumented)

        y (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        yType (`~.hipDataType`):
            (undocumented)

        incy (`~.int`):
            (undocumented)

        stridey (`~.int`):
            (undocumented)

        c (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        s (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        csType (`~.hipDataType`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)

        executionType (`~.hipDataType`):
            (undocumented)
    """
    if not isinstance(xType,_hipDataType__Base):
        raise TypeError("argument 'xType' must be of type '_hipDataType__Base'")                    
    if not isinstance(yType,_hipDataType__Base):
        raise TypeError("argument 'yType' must be of type '_hipDataType__Base'")                    
    if not isinstance(csType,_hipDataType__Base):
        raise TypeError("argument 'csType' must be of type '_hipDataType__Base'")                    
    if not isinstance(executionType,_hipDataType__Base):
        raise TypeError("argument 'executionType' must be of type '_hipDataType__Base'")
    _hipblasRotStridedBatchedEx_v2_64__retval = hipblasStatus_t(chipblas.hipblasRotStridedBatchedEx_v2_64(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,n,
        <void *>hip._util.types.Pointer.fromPyobj(x)._ptr,xType.value,incx,stridex,
        <void *>hip._util.types.Pointer.fromPyobj(y)._ptr,yType.value,incy,stridey,
        <const void *>hip._util.types.Pointer.fromPyobj(c)._ptr,
        <const void *>hip._util.types.Pointer.fromPyobj(s)._ptr,csType.value,batchCount,executionType.value))
    return (_hipblasRotStridedBatchedEx_v2_64__retval,)


@cython.embedsignature(True)
def hipblasScalEx(object handle, int n, object alpha, object alphaType, object x, object xType, int incx, object executionType):
    r"""BLAS EX API

    scalEx  scales each element of vector x with scalar alpha.

    x := alpha * x

    - Supported types are determined by the backend. See rocBLAS/cuBLAS documentation.

    With HIPBLAS_V2 define, hipblasScalEx accepts hipDataType for alphaType,
    xType, and executionType rather than hipblasDatatype_t. hipblasScalEx will only
    accept hipDataType in a future release.

        `~.ifdef` HIPBLAS_V2 // available in hipBLAS version 2.0.0 and later with -DHIPBLAS_V2

            hipblasStatus_t hipblasScalEx(hipblasHandle_t handle,a
                                          int             n,
                                          const void*     alpha,
                                          hipDataType     alphaType,
                                          void*           x,
                                          hipDataType     xType,
                                          int             incx,
                                          hipDataType     executionType)

        `~.else` // [DEPRECATED]

            hipblasStatus_t hipblasScalEx(hipblasHandle_t   handle,
                                          int               n,
                                          const void*       alpha,
                                          hipblasDatatype_t alphaType,
                                          void*             x,
                                          hipblasDatatype_t xType,
                                          int               incx,
                                          hipblasDatatype_t executionType)

        `~.endif`

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`) -- *IN*:
            [hipblasHandle_t]
            handle to the hipblas library context queue.

        n (`~.int`) -- *IN*:
            [int]
            the number of elements in x.

        alpha (`~.hip._util.types.Pointer`/`~.object`) -- *IN*:
            device pointer or host pointer for the scalar alpha.

        alphaType (`~.hipblasDatatype_t`) -- *IN*:
            [hipblasDatatype_t] [DEPRECATED]
                       specifies the datatype of alpha.

            [hipDataType]
                       specifies the datatype of alpha.

        x (`~.hip._util.types.Pointer`/`~.object`) -- *INOUT*:
            device pointer storing vector x.

        xType (`~.hipblasDatatype_t`) -- *IN*:
            [hipblasDatatype_t] [DEPRECATED]
                   specifies the datatype of vector x.

            [hipDataType]
                   specifies the datatype of vector x.

        incx (`~.int`) -- *IN*:
            [int]
            specifies the increment for the elements of x.

        executionType (`~.hipblasDatatype_t`) -- *IN*:
            [hipblasDatatype_t] [DEPRECATED]
                           specifies the datatype of computation.

            [hipDataType]
                           specifies the datatype of computation.
    """
    if not isinstance(alphaType,_hipblasDatatype_t__Base):
        raise TypeError("argument 'alphaType' must be of type '_hipblasDatatype_t__Base'")                    
    if not isinstance(xType,_hipblasDatatype_t__Base):
        raise TypeError("argument 'xType' must be of type '_hipblasDatatype_t__Base'")                    
    if not isinstance(executionType,_hipblasDatatype_t__Base):
        raise TypeError("argument 'executionType' must be of type '_hipblasDatatype_t__Base'")
    _hipblasScalEx__retval = hipblasStatus_t(chipblas.hipblasScalEx(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,n,
        <const void *>hip._util.types.Pointer.fromPyobj(alpha)._ptr,alphaType.value,
        <void *>hip._util.types.Pointer.fromPyobj(x)._ptr,xType.value,incx,executionType.value))
    return (_hipblasScalEx__retval,)


@cython.embedsignature(True)
def hipblasScalEx_v2(object handle, int n, object alpha, object alphaType, object x, object xType, int incx, object executionType):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        alpha (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        alphaType (`~.hipDataType`):
            (undocumented)

        x (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        xType (`~.hipDataType`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        executionType (`~.hipDataType`):
            (undocumented)
    """
    if not isinstance(alphaType,_hipDataType__Base):
        raise TypeError("argument 'alphaType' must be of type '_hipDataType__Base'")                    
    if not isinstance(xType,_hipDataType__Base):
        raise TypeError("argument 'xType' must be of type '_hipDataType__Base'")                    
    if not isinstance(executionType,_hipDataType__Base):
        raise TypeError("argument 'executionType' must be of type '_hipDataType__Base'")
    _hipblasScalEx_v2__retval = hipblasStatus_t(chipblas.hipblasScalEx_v2(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,n,
        <const void *>hip._util.types.Pointer.fromPyobj(alpha)._ptr,alphaType.value,
        <void *>hip._util.types.Pointer.fromPyobj(x)._ptr,xType.value,incx,executionType.value))
    return (_hipblasScalEx_v2__retval,)


@cython.embedsignature(True)
def hipblasScalEx_64(object handle, long n, object alpha, object alphaType, object x, object xType, long incx, object executionType):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        alpha (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        alphaType (`~.hipblasDatatype_t`):
            (undocumented)

        x (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        xType (`~.hipblasDatatype_t`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        executionType (`~.hipblasDatatype_t`):
            (undocumented)
    """
    if not isinstance(alphaType,_hipblasDatatype_t__Base):
        raise TypeError("argument 'alphaType' must be of type '_hipblasDatatype_t__Base'")                    
    if not isinstance(xType,_hipblasDatatype_t__Base):
        raise TypeError("argument 'xType' must be of type '_hipblasDatatype_t__Base'")                    
    if not isinstance(executionType,_hipblasDatatype_t__Base):
        raise TypeError("argument 'executionType' must be of type '_hipblasDatatype_t__Base'")
    _hipblasScalEx_64__retval = hipblasStatus_t(chipblas.hipblasScalEx_64(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,n,
        <const void *>hip._util.types.Pointer.fromPyobj(alpha)._ptr,alphaType.value,
        <void *>hip._util.types.Pointer.fromPyobj(x)._ptr,xType.value,incx,executionType.value))
    return (_hipblasScalEx_64__retval,)


@cython.embedsignature(True)
def hipblasScalEx_v2_64(object handle, long n, object alpha, object alphaType, object x, object xType, long incx, object executionType):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        alpha (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        alphaType (`~.hipDataType`):
            (undocumented)

        x (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        xType (`~.hipDataType`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        executionType (`~.hipDataType`):
            (undocumented)
    """
    if not isinstance(alphaType,_hipDataType__Base):
        raise TypeError("argument 'alphaType' must be of type '_hipDataType__Base'")                    
    if not isinstance(xType,_hipDataType__Base):
        raise TypeError("argument 'xType' must be of type '_hipDataType__Base'")                    
    if not isinstance(executionType,_hipDataType__Base):
        raise TypeError("argument 'executionType' must be of type '_hipDataType__Base'")
    _hipblasScalEx_v2_64__retval = hipblasStatus_t(chipblas.hipblasScalEx_v2_64(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,n,
        <const void *>hip._util.types.Pointer.fromPyobj(alpha)._ptr,alphaType.value,
        <void *>hip._util.types.Pointer.fromPyobj(x)._ptr,xType.value,incx,executionType.value))
    return (_hipblasScalEx_v2_64__retval,)


@cython.embedsignature(True)
def hipblasScalBatchedEx(object handle, int n, object alpha, object alphaType, object x, object xType, int incx, int batchCount, object executionType):
    r"""BLAS EX API

    scalBatchedEx  scales each element of each vector x_i with scalar alpha.

    x_i := alpha * x_i

    - Supported types are determined by the backend. See rocBLAS/cuBLAS documentation.

    With HIPBLAS_V2 define, hipblasScalBatchedEx accepts hipDataType for alphaType,
    xType, and executionType rather than hipblasDatatype_t. hipblasScalBatchedEx will only
    accept hipDataType in a future release.

    .. code-block::

       #ifdef HIPBLAS_V2 // available in hipBLAS version 2.0.0 and later with -DHIPBLAS_V2

               hipblasStatus_t hipblasScalBatchedEx(hipblasHandle_t handle,
                                                   int             n,
                                                   const void*     alpha,
                                                   hipDataType     alphaType,
                                                   void*           x,
                                                   hipDataType     xType,
                                                   int             incx,
                                                   int             batchCount,
                                                   hipDataType     executionType)

           #else // [DEPRECATED]

               hipblasStatus_t hipblasScalBatchedEx(hipblasHandle_t   handle,
                                                   int               n,
                                                   const void*       alpha,
                                                   hipblasDatatype_t alphaType,
                                                   void*             x,
                                                   hipblasDatatype_t xType,
                                                   int               incx,
                                                   int               batchCount,
                                                   hipblasDatatype_t executionType)

           #endif

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`) -- *IN*:
            [hipblasHandle_t]
            handle to the hipblas library context queue.

        n (`~.int`) -- *IN*:
            [int]
            the number of elements in x.

        alpha (`~.hip._util.types.Pointer`/`~.object`) -- *IN*:
            device pointer or host pointer for the scalar alpha.

        alphaType (`~.hipblasDatatype_t`) -- *IN*:
            [hipblasDatatype_t] [DEPRECATED]
                       specifies the datatype of alpha.

            [hipDataType]
                       specifies the datatype of alpha.

        x (`~.hip._util.types.Pointer`/`~.object`) -- *INOUT*:
            device array of device pointers storing each vector x_i.

        xType (`~.hipblasDatatype_t`) -- *IN*:
            [hipblasDatatype_t] [DEPRECATED]
                   specifies the datatype of each vector x_i.

            [hipDataType]
                   specifies the datatype of each vector x_i.

        incx (`~.int`) -- *IN*:
            [int]
            specifies the increment for the elements of each x_i.

        batchCount (`~.int`) -- *IN*:
            [int]
            number of instances in the batch.

        executionType (`~.hipblasDatatype_t`) -- *IN*:
            [hipblasDatatype_t] [DEPRECATED]
                           specifies the datatype of computation.

            [hipDataType]
                           specifies the datatype of computation.
    """
    if not isinstance(alphaType,_hipblasDatatype_t__Base):
        raise TypeError("argument 'alphaType' must be of type '_hipblasDatatype_t__Base'")                    
    if not isinstance(xType,_hipblasDatatype_t__Base):
        raise TypeError("argument 'xType' must be of type '_hipblasDatatype_t__Base'")                    
    if not isinstance(executionType,_hipblasDatatype_t__Base):
        raise TypeError("argument 'executionType' must be of type '_hipblasDatatype_t__Base'")
    _hipblasScalBatchedEx__retval = hipblasStatus_t(chipblas.hipblasScalBatchedEx(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,n,
        <const void *>hip._util.types.Pointer.fromPyobj(alpha)._ptr,alphaType.value,
        <void *>hip._util.types.Pointer.fromPyobj(x)._ptr,xType.value,incx,batchCount,executionType.value))
    return (_hipblasScalBatchedEx__retval,)


@cython.embedsignature(True)
def hipblasScalBatchedEx_v2(object handle, int n, object alpha, object alphaType, object x, object xType, int incx, int batchCount, object executionType):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        alpha (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        alphaType (`~.hipDataType`):
            (undocumented)

        x (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        xType (`~.hipDataType`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)

        executionType (`~.hipDataType`):
            (undocumented)
    """
    if not isinstance(alphaType,_hipDataType__Base):
        raise TypeError("argument 'alphaType' must be of type '_hipDataType__Base'")                    
    if not isinstance(xType,_hipDataType__Base):
        raise TypeError("argument 'xType' must be of type '_hipDataType__Base'")                    
    if not isinstance(executionType,_hipDataType__Base):
        raise TypeError("argument 'executionType' must be of type '_hipDataType__Base'")
    _hipblasScalBatchedEx_v2__retval = hipblasStatus_t(chipblas.hipblasScalBatchedEx_v2(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,n,
        <const void *>hip._util.types.Pointer.fromPyobj(alpha)._ptr,alphaType.value,
        <void *>hip._util.types.Pointer.fromPyobj(x)._ptr,xType.value,incx,batchCount,executionType.value))
    return (_hipblasScalBatchedEx_v2__retval,)


@cython.embedsignature(True)
def hipblasScalBatchedEx_64(object handle, long n, object alpha, object alphaType, object x, object xType, long incx, long batchCount, object executionType):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        alpha (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        alphaType (`~.hipblasDatatype_t`):
            (undocumented)

        x (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        xType (`~.hipblasDatatype_t`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)

        executionType (`~.hipblasDatatype_t`):
            (undocumented)
    """
    if not isinstance(alphaType,_hipblasDatatype_t__Base):
        raise TypeError("argument 'alphaType' must be of type '_hipblasDatatype_t__Base'")                    
    if not isinstance(xType,_hipblasDatatype_t__Base):
        raise TypeError("argument 'xType' must be of type '_hipblasDatatype_t__Base'")                    
    if not isinstance(executionType,_hipblasDatatype_t__Base):
        raise TypeError("argument 'executionType' must be of type '_hipblasDatatype_t__Base'")
    _hipblasScalBatchedEx_64__retval = hipblasStatus_t(chipblas.hipblasScalBatchedEx_64(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,n,
        <const void *>hip._util.types.Pointer.fromPyobj(alpha)._ptr,alphaType.value,
        <void *>hip._util.types.Pointer.fromPyobj(x)._ptr,xType.value,incx,batchCount,executionType.value))
    return (_hipblasScalBatchedEx_64__retval,)


@cython.embedsignature(True)
def hipblasScalBatchedEx_v2_64(object handle, long n, object alpha, object alphaType, object x, object xType, long incx, long batchCount, object executionType):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        alpha (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        alphaType (`~.hipDataType`):
            (undocumented)

        x (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        xType (`~.hipDataType`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)

        executionType (`~.hipDataType`):
            (undocumented)
    """
    if not isinstance(alphaType,_hipDataType__Base):
        raise TypeError("argument 'alphaType' must be of type '_hipDataType__Base'")                    
    if not isinstance(xType,_hipDataType__Base):
        raise TypeError("argument 'xType' must be of type '_hipDataType__Base'")                    
    if not isinstance(executionType,_hipDataType__Base):
        raise TypeError("argument 'executionType' must be of type '_hipDataType__Base'")
    _hipblasScalBatchedEx_v2_64__retval = hipblasStatus_t(chipblas.hipblasScalBatchedEx_v2_64(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,n,
        <const void *>hip._util.types.Pointer.fromPyobj(alpha)._ptr,alphaType.value,
        <void *>hip._util.types.Pointer.fromPyobj(x)._ptr,xType.value,incx,batchCount,executionType.value))
    return (_hipblasScalBatchedEx_v2_64__retval,)


@cython.embedsignature(True)
def hipblasScalStridedBatchedEx(object handle, int n, object alpha, object alphaType, object x, object xType, int incx, long stridex, int batchCount, object executionType):
    r"""BLAS EX API

    scalStridedBatchedEx  scales each element of vector x with scalar alpha over a set
    of strided batched vectors.

    x := alpha * x

    - Supported types are determined by the backend. See rocBLAS/cuBLAS documentation.

    With HIPBLAS_V2 define, hipblasScalStridedBatchedEx accepts hipDataType for alphaType,
    xType, and executionType rather than hipblasDatatype_t. hipblasScalStridedBatchedEx will only
    accept hipDataType in a future release.

    .. code-block::

       #ifdef HIPBLAS_V2 // available in hipBLAS version 2.0.0 and later with -DHIPBLAS_V2

               hipblasStatus_t hipblasScalStridedBatchedEx(hipblasHandle_t handle,
                                                           int             n,
                                                           const void*     alpha,
                                                           hipDataType     alphaType,
                                                           void*           x,
                                                           hipDataType     xType,
                                                           int             incx,
                                                           hipblasStride   stridex,
                                                           int             batchCount,
                                                           hipDataType     executionType)

           #else // [DEPRECATED]

               hipblasStatus_t hipblasScalStridedBatchedEx(hipblasHandle_t   handle,
                                                           int               n,
                                                           const void*       alpha,
                                                           hipblasDatatype_t alphaType,
                                                           void*             x,
                                                           hipblasDatatype_t xType,
                                                           int               incx,
                                                           hipblasStride     stridex,
                                                           int               batchCount,
                                                           hipblasDatatype_t executionType)

           #endif

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`) -- *IN*:
            [hipblasHandle_t]
            handle to the hipblas library context queue.

        n (`~.int`) -- *IN*:
            [int]
            the number of elements in x.

        alpha (`~.hip._util.types.Pointer`/`~.object`) -- *IN*:
            device pointer or host pointer for the scalar alpha.

        alphaType (`~.hipblasDatatype_t`) -- *IN*:
            [hipblasDatatype_t] [DEPRECATED]
                       specifies the datatype of alpha.

            [hipDataType]
                       specifies the datatype of alpha.

        x (`~.hip._util.types.Pointer`/`~.object`) -- *INOUT*:
            device pointer to the first vector x_1.

        xType (`~.hipblasDatatype_t`) -- *IN*:
            [hipblasDatatype_t] [DEPRECATED]
                   specifies the datatype of each vector x_i.

            [hipDataType]
                   specifies the datatype of each vector x_i.

        incx (`~.int`) -- *IN*:
            [int]
            specifies the increment for the elements of each x_i.

        stridex (`~.int`) -- *IN*:
            [hipblasStride]
            stride from the start of one vector (x_i) to the next one (x_i+1).
            There are no restrictions placed on stridex, however the user should
            take care to ensure that stridex is of appropriate size, for a typical
            case this means stridex >= n * incx.

        batchCount (`~.int`) -- *IN*:
            [int]
            number of instances in the batch.

        executionType (`~.hipblasDatatype_t`) -- *IN*:
            [hipblasDatatype_t] [DEPRECATED]
                           specifies the datatype of computation.

            [hipDataType]
                           specifies the datatype of computation.
    """
    if not isinstance(alphaType,_hipblasDatatype_t__Base):
        raise TypeError("argument 'alphaType' must be of type '_hipblasDatatype_t__Base'")                    
    if not isinstance(xType,_hipblasDatatype_t__Base):
        raise TypeError("argument 'xType' must be of type '_hipblasDatatype_t__Base'")                    
    if not isinstance(executionType,_hipblasDatatype_t__Base):
        raise TypeError("argument 'executionType' must be of type '_hipblasDatatype_t__Base'")
    _hipblasScalStridedBatchedEx__retval = hipblasStatus_t(chipblas.hipblasScalStridedBatchedEx(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,n,
        <const void *>hip._util.types.Pointer.fromPyobj(alpha)._ptr,alphaType.value,
        <void *>hip._util.types.Pointer.fromPyobj(x)._ptr,xType.value,incx,stridex,batchCount,executionType.value))
    return (_hipblasScalStridedBatchedEx__retval,)


@cython.embedsignature(True)
def hipblasScalStridedBatchedEx_v2(object handle, int n, object alpha, object alphaType, object x, object xType, int incx, long stridex, int batchCount, object executionType):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        alpha (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        alphaType (`~.hipDataType`):
            (undocumented)

        x (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        xType (`~.hipDataType`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        stridex (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)

        executionType (`~.hipDataType`):
            (undocumented)
    """
    if not isinstance(alphaType,_hipDataType__Base):
        raise TypeError("argument 'alphaType' must be of type '_hipDataType__Base'")                    
    if not isinstance(xType,_hipDataType__Base):
        raise TypeError("argument 'xType' must be of type '_hipDataType__Base'")                    
    if not isinstance(executionType,_hipDataType__Base):
        raise TypeError("argument 'executionType' must be of type '_hipDataType__Base'")
    _hipblasScalStridedBatchedEx_v2__retval = hipblasStatus_t(chipblas.hipblasScalStridedBatchedEx_v2(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,n,
        <const void *>hip._util.types.Pointer.fromPyobj(alpha)._ptr,alphaType.value,
        <void *>hip._util.types.Pointer.fromPyobj(x)._ptr,xType.value,incx,stridex,batchCount,executionType.value))
    return (_hipblasScalStridedBatchedEx_v2__retval,)


@cython.embedsignature(True)
def hipblasScalStridedBatchedEx_64(object handle, long n, object alpha, object alphaType, object x, object xType, long incx, long stridex, long batchCount, object executionType):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        alpha (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        alphaType (`~.hipblasDatatype_t`):
            (undocumented)

        x (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        xType (`~.hipblasDatatype_t`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        stridex (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)

        executionType (`~.hipblasDatatype_t`):
            (undocumented)
    """
    if not isinstance(alphaType,_hipblasDatatype_t__Base):
        raise TypeError("argument 'alphaType' must be of type '_hipblasDatatype_t__Base'")                    
    if not isinstance(xType,_hipblasDatatype_t__Base):
        raise TypeError("argument 'xType' must be of type '_hipblasDatatype_t__Base'")                    
    if not isinstance(executionType,_hipblasDatatype_t__Base):
        raise TypeError("argument 'executionType' must be of type '_hipblasDatatype_t__Base'")
    _hipblasScalStridedBatchedEx_64__retval = hipblasStatus_t(chipblas.hipblasScalStridedBatchedEx_64(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,n,
        <const void *>hip._util.types.Pointer.fromPyobj(alpha)._ptr,alphaType.value,
        <void *>hip._util.types.Pointer.fromPyobj(x)._ptr,xType.value,incx,stridex,batchCount,executionType.value))
    return (_hipblasScalStridedBatchedEx_64__retval,)


@cython.embedsignature(True)
def hipblasScalStridedBatchedEx_v2_64(object handle, long n, object alpha, object alphaType, object x, object xType, long incx, long stridex, long batchCount, object executionType):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        alpha (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        alphaType (`~.hipDataType`):
            (undocumented)

        x (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        xType (`~.hipDataType`):
            (undocumented)

        incx (`~.int`):
            (undocumented)

        stridex (`~.int`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)

        executionType (`~.hipDataType`):
            (undocumented)
    """
    if not isinstance(alphaType,_hipDataType__Base):
        raise TypeError("argument 'alphaType' must be of type '_hipDataType__Base'")                    
    if not isinstance(xType,_hipDataType__Base):
        raise TypeError("argument 'xType' must be of type '_hipDataType__Base'")                    
    if not isinstance(executionType,_hipDataType__Base):
        raise TypeError("argument 'executionType' must be of type '_hipDataType__Base'")
    _hipblasScalStridedBatchedEx_v2_64__retval = hipblasStatus_t(chipblas.hipblasScalStridedBatchedEx_v2_64(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,n,
        <const void *>hip._util.types.Pointer.fromPyobj(alpha)._ptr,alphaType.value,
        <void *>hip._util.types.Pointer.fromPyobj(x)._ptr,xType.value,incx,stridex,batchCount,executionType.value))
    return (_hipblasScalStridedBatchedEx_v2_64__retval,)


@cython.embedsignature(True)
def hipblasStatusToString(object status):
    r"""(No short description, might be part of a group.)

    HIPBLAS Auxiliary API

    hipblasStatusToString

    Returns string representing hipblasStatus_t value

    Args:
        status (`~.hipblasStatus_t`) -- *IN*:
            [hipblasStatus_t]
            hipBLAS status to convert to string
    """
    if not isinstance(status,_hipblasStatus_t__Base):
        raise TypeError("argument 'status' must be of type '_hipblasStatus_t__Base'")
    _hipblasStatusToString__retval = hip._util.types.CStr.fromPtr(<void*>chipblas.hipblasStatusToString(status.value))
    return (None if _hipblasStatusToString__retval._ptr == NULL else _hipblasStatusToString__retval,)

__all__ = [
    "hipblasVersionMajor",
    "hipblaseVersionMinor",
    "hipblasVersionMinor",
    "hipblasVersionPatch",
    "hipblasBfloat16",
    "hipblasComplex",
    "hipblasDoubleComplex",
    "_hipblasStatus_t__Base",
    "hipblasStatus_t",
    "_hipblasPointerMode_t__Base",
    "hipblasPointerMode_t",
    "_hipblasOperation_t__Base",
    "hipblasOperation_t",
    "_hipblasFillMode_t__Base",
    "hipblasFillMode_t",
    "_hipblasDiagType_t__Base",
    "hipblasDiagType_t",
    "_hipblasSideMode_t__Base",
    "hipblasSideMode_t",
    "_hipblasMath_t__Base",
    "hipblasMath_t",
    "_hipblasDatatype_t__Base",
    "hipblasDatatype_t",
    "_hipblasComputeType_t__Base",
    "hipblasComputeType_t",
    "_hipblasGemmAlgo_t__Base",
    "hipblasGemmAlgo_t",
    "_hipblasAtomicsMode_t__Base",
    "hipblasAtomicsMode_t",
    "_hipblasGemmFlags_t__Base",
    "hipblasGemmFlags_t",
    "hipblasCreate",
    "hipblasDestroy",
    "hipblasSetStream",
    "hipblasGetStream",
    "hipblasSetPointerMode",
    "hipblasGetPointerMode",
    "hipblasSetMathMode",
    "hipblasGetMathMode",
    "hipblasSetVector",
    "hipblasGetVector",
    "hipblasSetMatrix",
    "hipblasGetMatrix",
    "hipblasSetVectorAsync",
    "hipblasGetVectorAsync",
    "hipblasSetMatrixAsync",
    "hipblasGetMatrixAsync",
    "hipblasSetAtomicsMode",
    "hipblasGetAtomicsMode",
    "hipblasIsamax",
    "hipblasIdamax",
    "hipblasIcamax",
    "hipblasIzamax",
    "hipblasIcamax_v2",
    "hipblasIzamax_v2",
    "hipblasIsamax_64",
    "hipblasIdamax_64",
    "hipblasIcamax_64",
    "hipblasIzamax_64",
    "hipblasIcamax_v2_64",
    "hipblasIzamax_v2_64",
    "hipblasIsamaxBatched",
    "hipblasIdamaxBatched",
    "hipblasIcamaxBatched",
    "hipblasIzamaxBatched",
    "hipblasIcamaxBatched_v2",
    "hipblasIzamaxBatched_v2",
    "hipblasIsamaxBatched_64",
    "hipblasIdamaxBatched_64",
    "hipblasIcamaxBatched_64",
    "hipblasIzamaxBatched_64",
    "hipblasIcamaxBatched_v2_64",
    "hipblasIzamaxBatched_v2_64",
    "hipblasIsamaxStridedBatched",
    "hipblasIdamaxStridedBatched",
    "hipblasIcamaxStridedBatched",
    "hipblasIzamaxStridedBatched",
    "hipblasIcamaxStridedBatched_v2",
    "hipblasIzamaxStridedBatched_v2",
    "hipblasIsamaxStridedBatched_64",
    "hipblasIdamaxStridedBatched_64",
    "hipblasIcamaxStridedBatched_64",
    "hipblasIzamaxStridedBatched_64",
    "hipblasIcamaxStridedBatched_v2_64",
    "hipblasIzamaxStridedBatched_v2_64",
    "hipblasIsamin",
    "hipblasIdamin",
    "hipblasIcamin",
    "hipblasIzamin",
    "hipblasIcamin_v2",
    "hipblasIzamin_v2",
    "hipblasIsamin_64",
    "hipblasIdamin_64",
    "hipblasIcamin_64",
    "hipblasIzamin_64",
    "hipblasIcamin_v2_64",
    "hipblasIzamin_v2_64",
    "hipblasIsaminBatched",
    "hipblasIdaminBatched",
    "hipblasIcaminBatched",
    "hipblasIzaminBatched",
    "hipblasIcaminBatched_v2",
    "hipblasIzaminBatched_v2",
    "hipblasIsaminBatched_64",
    "hipblasIdaminBatched_64",
    "hipblasIcaminBatched_64",
    "hipblasIzaminBatched_64",
    "hipblasIcaminBatched_v2_64",
    "hipblasIzaminBatched_v2_64",
    "hipblasIsaminStridedBatched",
    "hipblasIdaminStridedBatched",
    "hipblasIcaminStridedBatched",
    "hipblasIzaminStridedBatched",
    "hipblasIcaminStridedBatched_v2",
    "hipblasIzaminStridedBatched_v2",
    "hipblasIsaminStridedBatched_64",
    "hipblasIdaminStridedBatched_64",
    "hipblasIcaminStridedBatched_64",
    "hipblasIzaminStridedBatched_64",
    "hipblasIcaminStridedBatched_v2_64",
    "hipblasIzaminStridedBatched_v2_64",
    "hipblasSasum",
    "hipblasDasum",
    "hipblasScasum",
    "hipblasDzasum",
    "hipblasScasum_v2",
    "hipblasDzasum_v2",
    "hipblasSasum_64",
    "hipblasDasum_64",
    "hipblasScasum_64",
    "hipblasDzasum_64",
    "hipblasScasum_v2_64",
    "hipblasDzasum_v2_64",
    "hipblasSasumBatched",
    "hipblasDasumBatched",
    "hipblasScasumBatched",
    "hipblasDzasumBatched",
    "hipblasScasumBatched_v2",
    "hipblasDzasumBatched_v2",
    "hipblasSasumBatched_64",
    "hipblasDasumBatched_64",
    "hipblasScasumBatched_64",
    "hipblasDzasumBatched_64",
    "hipblasScasumBatched_v2_64",
    "hipblasDzasumBatched_v2_64",
    "hipblasSasumStridedBatched",
    "hipblasDasumStridedBatched",
    "hipblasScasumStridedBatched",
    "hipblasDzasumStridedBatched",
    "hipblasScasumStridedBatched_v2",
    "hipblasDzasumStridedBatched_v2",
    "hipblasSasumStridedBatched_64",
    "hipblasDasumStridedBatched_64",
    "hipblasScasumStridedBatched_64",
    "hipblasDzasumStridedBatched_64",
    "hipblasScasumStridedBatched_v2_64",
    "hipblasDzasumStridedBatched_v2_64",
    "hipblasHaxpy",
    "hipblasSaxpy",
    "hipblasDaxpy",
    "hipblasCaxpy",
    "hipblasZaxpy",
    "hipblasCaxpy_v2",
    "hipblasZaxpy_v2",
    "hipblasHaxpy_64",
    "hipblasSaxpy_64",
    "hipblasDaxpy_64",
    "hipblasCaxpy_64",
    "hipblasZaxpy_64",
    "hipblasCaxpy_v2_64",
    "hipblasZaxpy_v2_64",
    "hipblasHaxpyBatched",
    "hipblasSaxpyBatched",
    "hipblasDaxpyBatched",
    "hipblasCaxpyBatched",
    "hipblasZaxpyBatched",
    "hipblasCaxpyBatched_v2",
    "hipblasZaxpyBatched_v2",
    "hipblasHaxpyBatched_64",
    "hipblasSaxpyBatched_64",
    "hipblasDaxpyBatched_64",
    "hipblasCaxpyBatched_64",
    "hipblasZaxpyBatched_64",
    "hipblasCaxpyBatched_v2_64",
    "hipblasZaxpyBatched_v2_64",
    "hipblasHaxpyStridedBatched",
    "hipblasSaxpyStridedBatched",
    "hipblasDaxpyStridedBatched",
    "hipblasCaxpyStridedBatched",
    "hipblasZaxpyStridedBatched",
    "hipblasCaxpyStridedBatched_v2",
    "hipblasZaxpyStridedBatched_v2",
    "hipblasHaxpyStridedBatched_64",
    "hipblasSaxpyStridedBatched_64",
    "hipblasDaxpyStridedBatched_64",
    "hipblasCaxpyStridedBatched_64",
    "hipblasZaxpyStridedBatched_64",
    "hipblasCaxpyStridedBatched_v2_64",
    "hipblasZaxpyStridedBatched_v2_64",
    "hipblasScopy",
    "hipblasDcopy",
    "hipblasCcopy",
    "hipblasZcopy",
    "hipblasCcopy_v2",
    "hipblasZcopy_v2",
    "hipblasScopy_64",
    "hipblasDcopy_64",
    "hipblasCcopy_64",
    "hipblasZcopy_64",
    "hipblasCcopy_v2_64",
    "hipblasZcopy_v2_64",
    "hipblasScopyBatched",
    "hipblasDcopyBatched",
    "hipblasCcopyBatched",
    "hipblasZcopyBatched",
    "hipblasCcopyBatched_v2",
    "hipblasZcopyBatched_v2",
    "hipblasScopyBatched_64",
    "hipblasDcopyBatched_64",
    "hipblasCcopyBatched_64",
    "hipblasZcopyBatched_64",
    "hipblasCcopyBatched_v2_64",
    "hipblasZcopyBatched_v2_64",
    "hipblasScopyStridedBatched",
    "hipblasDcopyStridedBatched",
    "hipblasCcopyStridedBatched",
    "hipblasZcopyStridedBatched",
    "hipblasCcopyStridedBatched_v2",
    "hipblasZcopyStridedBatched_v2",
    "hipblasScopyStridedBatched_64",
    "hipblasDcopyStridedBatched_64",
    "hipblasCcopyStridedBatched_64",
    "hipblasZcopyStridedBatched_64",
    "hipblasCcopyStridedBatched_v2_64",
    "hipblasZcopyStridedBatched_v2_64",
    "hipblasHdot",
    "hipblasBfdot",
    "hipblasSdot",
    "hipblasDdot",
    "hipblasCdotc",
    "hipblasCdotu",
    "hipblasZdotc",
    "hipblasZdotu",
    "hipblasCdotc_v2",
    "hipblasCdotu_v2",
    "hipblasZdotc_v2",
    "hipblasZdotu_v2",
    "hipblasHdot_64",
    "hipblasBfdot_64",
    "hipblasSdot_64",
    "hipblasDdot_64",
    "hipblasCdotc_64",
    "hipblasCdotu_64",
    "hipblasZdotc_64",
    "hipblasZdotu_64",
    "hipblasCdotc_v2_64",
    "hipblasCdotu_v2_64",
    "hipblasZdotc_v2_64",
    "hipblasZdotu_v2_64",
    "hipblasHdotBatched",
    "hipblasBfdotBatched",
    "hipblasSdotBatched",
    "hipblasDdotBatched",
    "hipblasCdotcBatched",
    "hipblasCdotuBatched",
    "hipblasZdotcBatched",
    "hipblasZdotuBatched",
    "hipblasCdotcBatched_v2",
    "hipblasCdotuBatched_v2",
    "hipblasZdotcBatched_v2",
    "hipblasZdotuBatched_v2",
    "hipblasHdotBatched_64",
    "hipblasBfdotBatched_64",
    "hipblasSdotBatched_64",
    "hipblasDdotBatched_64",
    "hipblasCdotcBatched_64",
    "hipblasCdotuBatched_64",
    "hipblasZdotcBatched_64",
    "hipblasZdotuBatched_64",
    "hipblasCdotcBatched_v2_64",
    "hipblasCdotuBatched_v2_64",
    "hipblasZdotcBatched_v2_64",
    "hipblasZdotuBatched_v2_64",
    "hipblasHdotStridedBatched",
    "hipblasBfdotStridedBatched",
    "hipblasSdotStridedBatched",
    "hipblasDdotStridedBatched",
    "hipblasCdotcStridedBatched",
    "hipblasCdotuStridedBatched",
    "hipblasZdotcStridedBatched",
    "hipblasZdotuStridedBatched",
    "hipblasCdotcStridedBatched_v2",
    "hipblasCdotuStridedBatched_v2",
    "hipblasZdotcStridedBatched_v2",
    "hipblasZdotuStridedBatched_v2",
    "hipblasHdotStridedBatched_64",
    "hipblasBfdotStridedBatched_64",
    "hipblasSdotStridedBatched_64",
    "hipblasDdotStridedBatched_64",
    "hipblasCdotcStridedBatched_64",
    "hipblasCdotuStridedBatched_64",
    "hipblasZdotcStridedBatched_64",
    "hipblasZdotuStridedBatched_64",
    "hipblasCdotcStridedBatched_v2_64",
    "hipblasCdotuStridedBatched_v2_64",
    "hipblasZdotcStridedBatched_v2_64",
    "hipblasZdotuStridedBatched_v2_64",
    "hipblasSnrm2",
    "hipblasDnrm2",
    "hipblasScnrm2",
    "hipblasDznrm2",
    "hipblasScnrm2_v2",
    "hipblasDznrm2_v2",
    "hipblasSnrm2_64",
    "hipblasDnrm2_64",
    "hipblasScnrm2_64",
    "hipblasDznrm2_64",
    "hipblasScnrm2_v2_64",
    "hipblasDznrm2_v2_64",
    "hipblasSnrm2Batched",
    "hipblasDnrm2Batched",
    "hipblasScnrm2Batched",
    "hipblasDznrm2Batched",
    "hipblasScnrm2Batched_v2",
    "hipblasDznrm2Batched_v2",
    "hipblasSnrm2Batched_64",
    "hipblasDnrm2Batched_64",
    "hipblasScnrm2Batched_64",
    "hipblasDznrm2Batched_64",
    "hipblasScnrm2Batched_v2_64",
    "hipblasDznrm2Batched_v2_64",
    "hipblasSnrm2StridedBatched",
    "hipblasDnrm2StridedBatched",
    "hipblasScnrm2StridedBatched",
    "hipblasDznrm2StridedBatched",
    "hipblasScnrm2StridedBatched_v2",
    "hipblasDznrm2StridedBatched_v2",
    "hipblasSnrm2StridedBatched_64",
    "hipblasDnrm2StridedBatched_64",
    "hipblasScnrm2StridedBatched_64",
    "hipblasDznrm2StridedBatched_64",
    "hipblasScnrm2StridedBatched_v2_64",
    "hipblasDznrm2StridedBatched_v2_64",
    "hipblasSrot",
    "hipblasDrot",
    "hipblasCrot",
    "hipblasCsrot",
    "hipblasZrot",
    "hipblasZdrot",
    "hipblasCrot_v2",
    "hipblasCsrot_v2",
    "hipblasZrot_v2",
    "hipblasZdrot_v2",
    "hipblasSrot_64",
    "hipblasDrot_64",
    "hipblasCrot_64",
    "hipblasCsrot_64",
    "hipblasZrot_64",
    "hipblasZdrot_64",
    "hipblasCrot_v2_64",
    "hipblasCsrot_v2_64",
    "hipblasZrot_v2_64",
    "hipblasZdrot_v2_64",
    "hipblasSrotBatched",
    "hipblasDrotBatched",
    "hipblasCrotBatched",
    "hipblasCsrotBatched",
    "hipblasZrotBatched",
    "hipblasZdrotBatched",
    "hipblasCrotBatched_v2",
    "hipblasCsrotBatched_v2",
    "hipblasZrotBatched_v2",
    "hipblasZdrotBatched_v2",
    "hipblasSrotBatched_64",
    "hipblasDrotBatched_64",
    "hipblasCrotBatched_64",
    "hipblasCsrotBatched_64",
    "hipblasZrotBatched_64",
    "hipblasZdrotBatched_64",
    "hipblasCrotBatched_v2_64",
    "hipblasCsrotBatched_v2_64",
    "hipblasZrotBatched_v2_64",
    "hipblasZdrotBatched_v2_64",
    "hipblasSrotStridedBatched",
    "hipblasDrotStridedBatched",
    "hipblasCrotStridedBatched",
    "hipblasCsrotStridedBatched",
    "hipblasZrotStridedBatched",
    "hipblasZdrotStridedBatched",
    "hipblasCrotStridedBatched_v2",
    "hipblasCsrotStridedBatched_v2",
    "hipblasZrotStridedBatched_v2",
    "hipblasZdrotStridedBatched_v2",
    "hipblasSrotStridedBatched_64",
    "hipblasDrotStridedBatched_64",
    "hipblasCrotStridedBatched_64",
    "hipblasCsrotStridedBatched_64",
    "hipblasZrotStridedBatched_64",
    "hipblasZdrotStridedBatched_64",
    "hipblasCrotStridedBatched_v2_64",
    "hipblasCsrotStridedBatched_v2_64",
    "hipblasZrotStridedBatched_v2_64",
    "hipblasZdrotStridedBatched_v2_64",
    "hipblasSrotg",
    "hipblasDrotg",
    "hipblasCrotg",
    "hipblasZrotg",
    "hipblasCrotg_v2",
    "hipblasZrotg_v2",
    "hipblasSrotg_64",
    "hipblasDrotg_64",
    "hipblasCrotg_64",
    "hipblasZrotg_64",
    "hipblasCrotg_v2_64",
    "hipblasZrotg_v2_64",
    "hipblasSrotgBatched",
    "hipblasDrotgBatched",
    "hipblasCrotgBatched",
    "hipblasZrotgBatched",
    "hipblasCrotgBatched_v2",
    "hipblasZrotgBatched_v2",
    "hipblasSrotgBatched_64",
    "hipblasDrotgBatched_64",
    "hipblasCrotgBatched_64",
    "hipblasZrotgBatched_64",
    "hipblasCrotgBatched_v2_64",
    "hipblasZrotgBatched_v2_64",
    "hipblasSrotgStridedBatched",
    "hipblasDrotgStridedBatched",
    "hipblasCrotgStridedBatched",
    "hipblasZrotgStridedBatched",
    "hipblasCrotgStridedBatched_v2",
    "hipblasZrotgStridedBatched_v2",
    "hipblasSrotgStridedBatched_64",
    "hipblasDrotgStridedBatched_64",
    "hipblasCrotgStridedBatched_64",
    "hipblasZrotgStridedBatched_64",
    "hipblasCrotgStridedBatched_v2_64",
    "hipblasZrotgStridedBatched_v2_64",
    "hipblasSrotm",
    "hipblasDrotm",
    "hipblasSrotm_64",
    "hipblasDrotm_64",
    "hipblasSrotmBatched",
    "hipblasDrotmBatched",
    "hipblasSrotmBatched_64",
    "hipblasDrotmBatched_64",
    "hipblasSrotmStridedBatched",
    "hipblasDrotmStridedBatched",
    "hipblasSrotmStridedBatched_64",
    "hipblasDrotmStridedBatched_64",
    "hipblasSrotmg",
    "hipblasDrotmg",
    "hipblasSrotmg_64",
    "hipblasDrotmg_64",
    "hipblasSrotmgBatched",
    "hipblasDrotmgBatched",
    "hipblasSrotmgBatched_64",
    "hipblasDrotmgBatched_64",
    "hipblasSrotmgStridedBatched",
    "hipblasDrotmgStridedBatched",
    "hipblasSrotmgStridedBatched_64",
    "hipblasDrotmgStridedBatched_64",
    "hipblasSscal",
    "hipblasDscal",
    "hipblasCscal",
    "hipblasCsscal",
    "hipblasZscal",
    "hipblasZdscal",
    "hipblasCscal_v2",
    "hipblasCsscal_v2",
    "hipblasZscal_v2",
    "hipblasZdscal_v2",
    "hipblasSscal_64",
    "hipblasDscal_64",
    "hipblasCscal_64",
    "hipblasCsscal_64",
    "hipblasZscal_64",
    "hipblasZdscal_64",
    "hipblasCscal_v2_64",
    "hipblasCsscal_v2_64",
    "hipblasZscal_v2_64",
    "hipblasZdscal_v2_64",
    "hipblasSscalBatched",
    "hipblasDscalBatched",
    "hipblasCscalBatched",
    "hipblasZscalBatched",
    "hipblasCsscalBatched",
    "hipblasZdscalBatched",
    "hipblasCscalBatched_v2",
    "hipblasZscalBatched_v2",
    "hipblasCsscalBatched_v2",
    "hipblasZdscalBatched_v2",
    "hipblasSscalBatched_64",
    "hipblasDscalBatched_64",
    "hipblasCscalBatched_64",
    "hipblasZscalBatched_64",
    "hipblasCsscalBatched_64",
    "hipblasZdscalBatched_64",
    "hipblasCscalBatched_v2_64",
    "hipblasZscalBatched_v2_64",
    "hipblasCsscalBatched_v2_64",
    "hipblasZdscalBatched_v2_64",
    "hipblasSscalStridedBatched",
    "hipblasDscalStridedBatched",
    "hipblasCscalStridedBatched",
    "hipblasZscalStridedBatched",
    "hipblasCsscalStridedBatched",
    "hipblasZdscalStridedBatched",
    "hipblasCscalStridedBatched_v2",
    "hipblasZscalStridedBatched_v2",
    "hipblasCsscalStridedBatched_v2",
    "hipblasZdscalStridedBatched_v2",
    "hipblasSscalStridedBatched_64",
    "hipblasDscalStridedBatched_64",
    "hipblasCscalStridedBatched_64",
    "hipblasZscalStridedBatched_64",
    "hipblasCsscalStridedBatched_64",
    "hipblasZdscalStridedBatched_64",
    "hipblasCscalStridedBatched_v2_64",
    "hipblasZscalStridedBatched_v2_64",
    "hipblasCsscalStridedBatched_v2_64",
    "hipblasZdscalStridedBatched_v2_64",
    "hipblasSswap",
    "hipblasDswap",
    "hipblasCswap",
    "hipblasZswap",
    "hipblasCswap_v2",
    "hipblasZswap_v2",
    "hipblasSswap_64",
    "hipblasDswap_64",
    "hipblasCswap_64",
    "hipblasZswap_64",
    "hipblasCswap_v2_64",
    "hipblasZswap_v2_64",
    "hipblasSswapBatched",
    "hipblasDswapBatched",
    "hipblasCswapBatched",
    "hipblasZswapBatched",
    "hipblasCswapBatched_v2",
    "hipblasZswapBatched_v2",
    "hipblasSswapBatched_64",
    "hipblasDswapBatched_64",
    "hipblasCswapBatched_64",
    "hipblasZswapBatched_64",
    "hipblasCswapBatched_v2_64",
    "hipblasZswapBatched_v2_64",
    "hipblasSswapStridedBatched",
    "hipblasDswapStridedBatched",
    "hipblasCswapStridedBatched",
    "hipblasZswapStridedBatched",
    "hipblasCswapStridedBatched_v2",
    "hipblasZswapStridedBatched_v2",
    "hipblasSswapStridedBatched_64",
    "hipblasDswapStridedBatched_64",
    "hipblasCswapStridedBatched_64",
    "hipblasZswapStridedBatched_64",
    "hipblasCswapStridedBatched_v2_64",
    "hipblasZswapStridedBatched_v2_64",
    "hipblasSgbmv",
    "hipblasDgbmv",
    "hipblasCgbmv",
    "hipblasZgbmv",
    "hipblasCgbmv_v2",
    "hipblasZgbmv_v2",
    "hipblasSgbmv_64",
    "hipblasDgbmv_64",
    "hipblasCgbmv_64",
    "hipblasZgbmv_64",
    "hipblasCgbmv_v2_64",
    "hipblasZgbmv_v2_64",
    "hipblasSgbmvBatched",
    "hipblasDgbmvBatched",
    "hipblasCgbmvBatched",
    "hipblasZgbmvBatched",
    "hipblasCgbmvBatched_v2",
    "hipblasZgbmvBatched_v2",
    "hipblasSgbmvBatched_64",
    "hipblasDgbmvBatched_64",
    "hipblasCgbmvBatched_64",
    "hipblasZgbmvBatched_64",
    "hipblasCgbmvBatched_v2_64",
    "hipblasZgbmvBatched_v2_64",
    "hipblasSgbmvStridedBatched",
    "hipblasDgbmvStridedBatched",
    "hipblasCgbmvStridedBatched",
    "hipblasZgbmvStridedBatched",
    "hipblasCgbmvStridedBatched_v2",
    "hipblasZgbmvStridedBatched_v2",
    "hipblasSgbmvStridedBatched_64",
    "hipblasDgbmvStridedBatched_64",
    "hipblasCgbmvStridedBatched_64",
    "hipblasZgbmvStridedBatched_64",
    "hipblasCgbmvStridedBatched_v2_64",
    "hipblasZgbmvStridedBatched_v2_64",
    "hipblasSgemv",
    "hipblasDgemv",
    "hipblasCgemv",
    "hipblasZgemv",
    "hipblasCgemv_v2",
    "hipblasZgemv_v2",
    "hipblasSgemv_64",
    "hipblasDgemv_64",
    "hipblasCgemv_64",
    "hipblasZgemv_64",
    "hipblasCgemv_v2_64",
    "hipblasZgemv_v2_64",
    "hipblasSgemvBatched",
    "hipblasDgemvBatched",
    "hipblasCgemvBatched",
    "hipblasZgemvBatched",
    "hipblasCgemvBatched_v2",
    "hipblasZgemvBatched_v2",
    "hipblasSgemvBatched_64",
    "hipblasDgemvBatched_64",
    "hipblasCgemvBatched_64",
    "hipblasZgemvBatched_64",
    "hipblasCgemvBatched_v2_64",
    "hipblasZgemvBatched_v2_64",
    "hipblasSgemvStridedBatched",
    "hipblasDgemvStridedBatched",
    "hipblasCgemvStridedBatched",
    "hipblasZgemvStridedBatched",
    "hipblasCgemvStridedBatched_v2",
    "hipblasZgemvStridedBatched_v2",
    "hipblasSgemvStridedBatched_64",
    "hipblasDgemvStridedBatched_64",
    "hipblasCgemvStridedBatched_64",
    "hipblasZgemvStridedBatched_64",
    "hipblasCgemvStridedBatched_v2_64",
    "hipblasZgemvStridedBatched_v2_64",
    "hipblasSger",
    "hipblasDger",
    "hipblasCgeru",
    "hipblasCgerc",
    "hipblasZgeru",
    "hipblasZgerc",
    "hipblasCgeru_v2",
    "hipblasCgerc_v2",
    "hipblasZgeru_v2",
    "hipblasZgerc_v2",
    "hipblasSger_64",
    "hipblasDger_64",
    "hipblasCgeru_64",
    "hipblasCgerc_64",
    "hipblasZgeru_64",
    "hipblasZgerc_64",
    "hipblasCgeru_v2_64",
    "hipblasCgerc_v2_64",
    "hipblasZgeru_v2_64",
    "hipblasZgerc_v2_64",
    "hipblasSgerBatched",
    "hipblasDgerBatched",
    "hipblasCgeruBatched",
    "hipblasCgercBatched",
    "hipblasZgeruBatched",
    "hipblasZgercBatched",
    "hipblasCgeruBatched_v2",
    "hipblasCgercBatched_v2",
    "hipblasZgeruBatched_v2",
    "hipblasZgercBatched_v2",
    "hipblasSgerBatched_64",
    "hipblasDgerBatched_64",
    "hipblasCgeruBatched_64",
    "hipblasCgercBatched_64",
    "hipblasZgeruBatched_64",
    "hipblasZgercBatched_64",
    "hipblasCgeruBatched_v2_64",
    "hipblasCgercBatched_v2_64",
    "hipblasZgeruBatched_v2_64",
    "hipblasZgercBatched_v2_64",
    "hipblasSgerStridedBatched",
    "hipblasDgerStridedBatched",
    "hipblasCgeruStridedBatched",
    "hipblasCgercStridedBatched",
    "hipblasZgeruStridedBatched",
    "hipblasZgercStridedBatched",
    "hipblasCgeruStridedBatched_v2",
    "hipblasCgercStridedBatched_v2",
    "hipblasZgeruStridedBatched_v2",
    "hipblasZgercStridedBatched_v2",
    "hipblasSgerStridedBatched_64",
    "hipblasDgerStridedBatched_64",
    "hipblasCgeruStridedBatched_64",
    "hipblasCgercStridedBatched_64",
    "hipblasZgeruStridedBatched_64",
    "hipblasZgercStridedBatched_64",
    "hipblasCgeruStridedBatched_v2_64",
    "hipblasCgercStridedBatched_v2_64",
    "hipblasZgeruStridedBatched_v2_64",
    "hipblasZgercStridedBatched_v2_64",
    "hipblasChbmv",
    "hipblasZhbmv",
    "hipblasChbmv_v2",
    "hipblasZhbmv_v2",
    "hipblasChbmv_64",
    "hipblasZhbmv_64",
    "hipblasChbmv_v2_64",
    "hipblasZhbmv_v2_64",
    "hipblasChbmvBatched",
    "hipblasZhbmvBatched",
    "hipblasChbmvBatched_v2",
    "hipblasZhbmvBatched_v2",
    "hipblasChbmvBatched_64",
    "hipblasZhbmvBatched_64",
    "hipblasChbmvBatched_v2_64",
    "hipblasZhbmvBatched_v2_64",
    "hipblasChbmvStridedBatched",
    "hipblasZhbmvStridedBatched",
    "hipblasChbmvStridedBatched_v2",
    "hipblasZhbmvStridedBatched_v2",
    "hipblasChbmvStridedBatched_64",
    "hipblasZhbmvStridedBatched_64",
    "hipblasChbmvStridedBatched_v2_64",
    "hipblasZhbmvStridedBatched_v2_64",
    "hipblasChemv",
    "hipblasZhemv",
    "hipblasChemv_v2",
    "hipblasZhemv_v2",
    "hipblasChemv_64",
    "hipblasZhemv_64",
    "hipblasChemv_v2_64",
    "hipblasZhemv_v2_64",
    "hipblasChemvBatched",
    "hipblasZhemvBatched",
    "hipblasChemvBatched_v2",
    "hipblasZhemvBatched_v2",
    "hipblasChemvBatched_64",
    "hipblasZhemvBatched_64",
    "hipblasChemvBatched_v2_64",
    "hipblasZhemvBatched_v2_64",
    "hipblasChemvStridedBatched",
    "hipblasZhemvStridedBatched",
    "hipblasChemvStridedBatched_v2",
    "hipblasZhemvStridedBatched_v2",
    "hipblasChemvStridedBatched_64",
    "hipblasZhemvStridedBatched_64",
    "hipblasChemvStridedBatched_v2_64",
    "hipblasZhemvStridedBatched_v2_64",
    "hipblasCher",
    "hipblasZher",
    "hipblasCher_v2",
    "hipblasZher_v2",
    "hipblasCher_64",
    "hipblasZher_64",
    "hipblasCher_v2_64",
    "hipblasZher_v2_64",
    "hipblasCherBatched",
    "hipblasZherBatched",
    "hipblasCherBatched_v2",
    "hipblasZherBatched_v2",
    "hipblasCherBatched_64",
    "hipblasZherBatched_64",
    "hipblasCherBatched_v2_64",
    "hipblasZherBatched_v2_64",
    "hipblasCherStridedBatched",
    "hipblasZherStridedBatched",
    "hipblasCherStridedBatched_v2",
    "hipblasZherStridedBatched_v2",
    "hipblasCherStridedBatched_64",
    "hipblasZherStridedBatched_64",
    "hipblasCherStridedBatched_v2_64",
    "hipblasZherStridedBatched_v2_64",
    "hipblasCher2",
    "hipblasZher2",
    "hipblasCher2_v2",
    "hipblasZher2_v2",
    "hipblasCher2_64",
    "hipblasZher2_64",
    "hipblasCher2_v2_64",
    "hipblasZher2_v2_64",
    "hipblasCher2Batched",
    "hipblasZher2Batched",
    "hipblasCher2Batched_v2",
    "hipblasZher2Batched_v2",
    "hipblasCher2Batched_64",
    "hipblasZher2Batched_64",
    "hipblasCher2Batched_v2_64",
    "hipblasZher2Batched_v2_64",
    "hipblasCher2StridedBatched",
    "hipblasZher2StridedBatched",
    "hipblasCher2StridedBatched_v2",
    "hipblasZher2StridedBatched_v2",
    "hipblasCher2StridedBatched_64",
    "hipblasZher2StridedBatched_64",
    "hipblasCher2StridedBatched_v2_64",
    "hipblasZher2StridedBatched_v2_64",
    "hipblasChpmv",
    "hipblasZhpmv",
    "hipblasChpmv_v2",
    "hipblasZhpmv_v2",
    "hipblasChpmv_64",
    "hipblasZhpmv_64",
    "hipblasChpmv_v2_64",
    "hipblasZhpmv_v2_64",
    "hipblasChpmvBatched",
    "hipblasZhpmvBatched",
    "hipblasChpmvBatched_v2",
    "hipblasZhpmvBatched_v2",
    "hipblasChpmvBatched_64",
    "hipblasZhpmvBatched_64",
    "hipblasChpmvBatched_v2_64",
    "hipblasZhpmvBatched_v2_64",
    "hipblasChpmvStridedBatched",
    "hipblasZhpmvStridedBatched",
    "hipblasChpmvStridedBatched_v2",
    "hipblasZhpmvStridedBatched_v2",
    "hipblasChpmvStridedBatched_64",
    "hipblasZhpmvStridedBatched_64",
    "hipblasChpmvStridedBatched_v2_64",
    "hipblasZhpmvStridedBatched_v2_64",
    "hipblasChpr",
    "hipblasZhpr",
    "hipblasChpr_v2",
    "hipblasZhpr_v2",
    "hipblasChpr_64",
    "hipblasZhpr_64",
    "hipblasChpr_v2_64",
    "hipblasZhpr_v2_64",
    "hipblasChprBatched",
    "hipblasZhprBatched",
    "hipblasChprBatched_v2",
    "hipblasZhprBatched_v2",
    "hipblasChprBatched_64",
    "hipblasZhprBatched_64",
    "hipblasChprBatched_v2_64",
    "hipblasZhprBatched_v2_64",
    "hipblasChprStridedBatched",
    "hipblasZhprStridedBatched",
    "hipblasChprStridedBatched_v2",
    "hipblasZhprStridedBatched_v2",
    "hipblasChprStridedBatched_64",
    "hipblasZhprStridedBatched_64",
    "hipblasChprStridedBatched_v2_64",
    "hipblasZhprStridedBatched_v2_64",
    "hipblasChpr2",
    "hipblasZhpr2",
    "hipblasChpr2_v2",
    "hipblasZhpr2_v2",
    "hipblasChpr2_64",
    "hipblasZhpr2_64",
    "hipblasChpr2_v2_64",
    "hipblasZhpr2_v2_64",
    "hipblasChpr2Batched",
    "hipblasZhpr2Batched",
    "hipblasChpr2Batched_v2",
    "hipblasZhpr2Batched_v2",
    "hipblasChpr2Batched_64",
    "hipblasZhpr2Batched_64",
    "hipblasChpr2Batched_v2_64",
    "hipblasZhpr2Batched_v2_64",
    "hipblasChpr2StridedBatched",
    "hipblasZhpr2StridedBatched",
    "hipblasChpr2StridedBatched_v2",
    "hipblasZhpr2StridedBatched_v2",
    "hipblasChpr2StridedBatched_64",
    "hipblasZhpr2StridedBatched_64",
    "hipblasChpr2StridedBatched_v2_64",
    "hipblasZhpr2StridedBatched_v2_64",
    "hipblasSsbmv",
    "hipblasDsbmv",
    "hipblasSsbmv_64",
    "hipblasDsbmv_64",
    "hipblasSsbmvBatched",
    "hipblasDsbmvBatched",
    "hipblasSsbmvBatched_64",
    "hipblasDsbmvBatched_64",
    "hipblasSsbmvStridedBatched",
    "hipblasDsbmvStridedBatched",
    "hipblasSsbmvStridedBatched_64",
    "hipblasDsbmvStridedBatched_64",
    "hipblasSspmv",
    "hipblasDspmv",
    "hipblasSspmv_64",
    "hipblasDspmv_64",
    "hipblasSspmvBatched",
    "hipblasDspmvBatched",
    "hipblasSspmvBatched_64",
    "hipblasDspmvBatched_64",
    "hipblasSspmvStridedBatched",
    "hipblasDspmvStridedBatched",
    "hipblasSspmvStridedBatched_64",
    "hipblasDspmvStridedBatched_64",
    "hipblasSspr",
    "hipblasDspr",
    "hipblasCspr",
    "hipblasZspr",
    "hipblasCspr_v2",
    "hipblasZspr_v2",
    "hipblasSspr_64",
    "hipblasDspr_64",
    "hipblasCspr_64",
    "hipblasZspr_64",
    "hipblasCspr_v2_64",
    "hipblasZspr_v2_64",
    "hipblasSsprBatched",
    "hipblasDsprBatched",
    "hipblasCsprBatched",
    "hipblasZsprBatched",
    "hipblasCsprBatched_v2",
    "hipblasZsprBatched_v2",
    "hipblasSsprBatched_64",
    "hipblasDsprBatched_64",
    "hipblasCsprBatched_64",
    "hipblasZsprBatched_64",
    "hipblasCsprBatched_v2_64",
    "hipblasZsprBatched_v2_64",
    "hipblasSsprStridedBatched",
    "hipblasDsprStridedBatched",
    "hipblasCsprStridedBatched",
    "hipblasZsprStridedBatched",
    "hipblasCsprStridedBatched_v2",
    "hipblasZsprStridedBatched_v2",
    "hipblasSsprStridedBatched_64",
    "hipblasDsprStridedBatched_64",
    "hipblasCsprStridedBatched_64",
    "hipblasZsprStridedBatched_64",
    "hipblasCsprStridedBatched_v2_64",
    "hipblasZsprStridedBatched_v2_64",
    "hipblasSspr2",
    "hipblasDspr2",
    "hipblasSspr2_64",
    "hipblasDspr2_64",
    "hipblasSspr2Batched",
    "hipblasDspr2Batched",
    "hipblasSspr2Batched_64",
    "hipblasDspr2Batched_64",
    "hipblasSspr2StridedBatched",
    "hipblasDspr2StridedBatched",
    "hipblasSspr2StridedBatched_64",
    "hipblasDspr2StridedBatched_64",
    "hipblasSsymv",
    "hipblasDsymv",
    "hipblasCsymv",
    "hipblasZsymv",
    "hipblasCsymv_v2",
    "hipblasZsymv_v2",
    "hipblasSsymv_64",
    "hipblasDsymv_64",
    "hipblasCsymv_64",
    "hipblasZsymv_64",
    "hipblasCsymv_v2_64",
    "hipblasZsymv_v2_64",
    "hipblasSsymvBatched",
    "hipblasDsymvBatched",
    "hipblasCsymvBatched",
    "hipblasZsymvBatched",
    "hipblasCsymvBatched_v2",
    "hipblasZsymvBatched_v2",
    "hipblasSsymvBatched_64",
    "hipblasDsymvBatched_64",
    "hipblasCsymvBatched_64",
    "hipblasZsymvBatched_64",
    "hipblasCsymvBatched_v2_64",
    "hipblasZsymvBatched_v2_64",
    "hipblasSsymvStridedBatched",
    "hipblasDsymvStridedBatched",
    "hipblasCsymvStridedBatched",
    "hipblasZsymvStridedBatched",
    "hipblasCsymvStridedBatched_v2",
    "hipblasZsymvStridedBatched_v2",
    "hipblasSsymvStridedBatched_64",
    "hipblasDsymvStridedBatched_64",
    "hipblasCsymvStridedBatched_64",
    "hipblasZsymvStridedBatched_64",
    "hipblasCsymvStridedBatched_v2_64",
    "hipblasZsymvStridedBatched_v2_64",
    "hipblasSsyr",
    "hipblasDsyr",
    "hipblasCsyr",
    "hipblasZsyr",
    "hipblasCsyr_v2",
    "hipblasZsyr_v2",
    "hipblasSsyr_64",
    "hipblasDsyr_64",
    "hipblasCsyr_64",
    "hipblasZsyr_64",
    "hipblasCsyr_v2_64",
    "hipblasZsyr_v2_64",
    "hipblasSsyrBatched",
    "hipblasDsyrBatched",
    "hipblasCsyrBatched",
    "hipblasZsyrBatched",
    "hipblasCsyrBatched_v2",
    "hipblasZsyrBatched_v2",
    "hipblasSsyrBatched_64",
    "hipblasDsyrBatched_64",
    "hipblasCsyrBatched_64",
    "hipblasZsyrBatched_64",
    "hipblasCsyrBatched_v2_64",
    "hipblasZsyrBatched_v2_64",
    "hipblasSsyrStridedBatched",
    "hipblasDsyrStridedBatched",
    "hipblasCsyrStridedBatched",
    "hipblasZsyrStridedBatched",
    "hipblasCsyrStridedBatched_v2",
    "hipblasZsyrStridedBatched_v2",
    "hipblasSsyrStridedBatched_64",
    "hipblasDsyrStridedBatched_64",
    "hipblasCsyrStridedBatched_64",
    "hipblasZsyrStridedBatched_64",
    "hipblasCsyrStridedBatched_v2_64",
    "hipblasZsyrStridedBatched_v2_64",
    "hipblasSsyr2",
    "hipblasDsyr2",
    "hipblasCsyr2",
    "hipblasZsyr2",
    "hipblasCsyr2_v2",
    "hipblasZsyr2_v2",
    "hipblasSsyr2_64",
    "hipblasDsyr2_64",
    "hipblasCsyr2_64",
    "hipblasZsyr2_64",
    "hipblasCsyr2_v2_64",
    "hipblasZsyr2_v2_64",
    "hipblasSsyr2Batched",
    "hipblasDsyr2Batched",
    "hipblasCsyr2Batched",
    "hipblasZsyr2Batched",
    "hipblasCsyr2Batched_v2",
    "hipblasZsyr2Batched_v2",
    "hipblasSsyr2Batched_64",
    "hipblasDsyr2Batched_64",
    "hipblasCsyr2Batched_64",
    "hipblasZsyr2Batched_64",
    "hipblasCsyr2Batched_v2_64",
    "hipblasZsyr2Batched_v2_64",
    "hipblasSsyr2StridedBatched",
    "hipblasDsyr2StridedBatched",
    "hipblasCsyr2StridedBatched",
    "hipblasZsyr2StridedBatched",
    "hipblasCsyr2StridedBatched_v2",
    "hipblasZsyr2StridedBatched_v2",
    "hipblasSsyr2StridedBatched_64",
    "hipblasDsyr2StridedBatched_64",
    "hipblasCsyr2StridedBatched_64",
    "hipblasZsyr2StridedBatched_64",
    "hipblasCsyr2StridedBatched_v2_64",
    "hipblasZsyr2StridedBatched_v2_64",
    "hipblasStbmv",
    "hipblasDtbmv",
    "hipblasCtbmv",
    "hipblasZtbmv",
    "hipblasCtbmv_v2",
    "hipblasZtbmv_v2",
    "hipblasStbmv_64",
    "hipblasDtbmv_64",
    "hipblasCtbmv_64",
    "hipblasZtbmv_64",
    "hipblasCtbmv_v2_64",
    "hipblasZtbmv_v2_64",
    "hipblasStbmvBatched",
    "hipblasDtbmvBatched",
    "hipblasCtbmvBatched",
    "hipblasZtbmvBatched",
    "hipblasCtbmvBatched_v2",
    "hipblasZtbmvBatched_v2",
    "hipblasStbmvBatched_64",
    "hipblasDtbmvBatched_64",
    "hipblasCtbmvBatched_64",
    "hipblasZtbmvBatched_64",
    "hipblasCtbmvBatched_v2_64",
    "hipblasZtbmvBatched_v2_64",
    "hipblasStbmvStridedBatched",
    "hipblasDtbmvStridedBatched",
    "hipblasCtbmvStridedBatched",
    "hipblasZtbmvStridedBatched",
    "hipblasCtbmvStridedBatched_v2",
    "hipblasZtbmvStridedBatched_v2",
    "hipblasStbmvStridedBatched_64",
    "hipblasDtbmvStridedBatched_64",
    "hipblasCtbmvStridedBatched_64",
    "hipblasZtbmvStridedBatched_64",
    "hipblasCtbmvStridedBatched_v2_64",
    "hipblasZtbmvStridedBatched_v2_64",
    "hipblasStbsv",
    "hipblasDtbsv",
    "hipblasCtbsv",
    "hipblasZtbsv",
    "hipblasCtbsv_v2",
    "hipblasZtbsv_v2",
    "hipblasStbsv_64",
    "hipblasDtbsv_64",
    "hipblasCtbsv_64",
    "hipblasZtbsv_64",
    "hipblasCtbsv_v2_64",
    "hipblasZtbsv_v2_64",
    "hipblasStbsvBatched",
    "hipblasDtbsvBatched",
    "hipblasCtbsvBatched",
    "hipblasZtbsvBatched",
    "hipblasCtbsvBatched_v2",
    "hipblasZtbsvBatched_v2",
    "hipblasStbsvBatched_64",
    "hipblasDtbsvBatched_64",
    "hipblasCtbsvBatched_64",
    "hipblasZtbsvBatched_64",
    "hipblasCtbsvBatched_v2_64",
    "hipblasZtbsvBatched_v2_64",
    "hipblasStbsvStridedBatched",
    "hipblasDtbsvStridedBatched",
    "hipblasCtbsvStridedBatched",
    "hipblasZtbsvStridedBatched",
    "hipblasCtbsvStridedBatched_v2",
    "hipblasZtbsvStridedBatched_v2",
    "hipblasStbsvStridedBatched_64",
    "hipblasDtbsvStridedBatched_64",
    "hipblasCtbsvStridedBatched_64",
    "hipblasZtbsvStridedBatched_64",
    "hipblasCtbsvStridedBatched_v2_64",
    "hipblasZtbsvStridedBatched_v2_64",
    "hipblasStpmv",
    "hipblasDtpmv",
    "hipblasCtpmv",
    "hipblasZtpmv",
    "hipblasCtpmv_v2",
    "hipblasZtpmv_v2",
    "hipblasStpmv_64",
    "hipblasDtpmv_64",
    "hipblasCtpmv_64",
    "hipblasZtpmv_64",
    "hipblasCtpmv_v2_64",
    "hipblasZtpmv_v2_64",
    "hipblasStpmvBatched",
    "hipblasDtpmvBatched",
    "hipblasCtpmvBatched",
    "hipblasZtpmvBatched",
    "hipblasCtpmvBatched_v2",
    "hipblasZtpmvBatched_v2",
    "hipblasStpmvBatched_64",
    "hipblasDtpmvBatched_64",
    "hipblasCtpmvBatched_64",
    "hipblasZtpmvBatched_64",
    "hipblasCtpmvBatched_v2_64",
    "hipblasZtpmvBatched_v2_64",
    "hipblasStpmvStridedBatched",
    "hipblasDtpmvStridedBatched",
    "hipblasCtpmvStridedBatched",
    "hipblasZtpmvStridedBatched",
    "hipblasCtpmvStridedBatched_v2",
    "hipblasZtpmvStridedBatched_v2",
    "hipblasStpmvStridedBatched_64",
    "hipblasDtpmvStridedBatched_64",
    "hipblasCtpmvStridedBatched_64",
    "hipblasZtpmvStridedBatched_64",
    "hipblasCtpmvStridedBatched_v2_64",
    "hipblasZtpmvStridedBatched_v2_64",
    "hipblasStpsv",
    "hipblasDtpsv",
    "hipblasCtpsv",
    "hipblasZtpsv",
    "hipblasCtpsv_v2",
    "hipblasZtpsv_v2",
    "hipblasStpsv_64",
    "hipblasDtpsv_64",
    "hipblasCtpsv_64",
    "hipblasZtpsv_64",
    "hipblasCtpsv_v2_64",
    "hipblasZtpsv_v2_64",
    "hipblasStpsvBatched",
    "hipblasDtpsvBatched",
    "hipblasCtpsvBatched",
    "hipblasZtpsvBatched",
    "hipblasCtpsvBatched_v2",
    "hipblasZtpsvBatched_v2",
    "hipblasStpsvBatched_64",
    "hipblasDtpsvBatched_64",
    "hipblasCtpsvBatched_64",
    "hipblasZtpsvBatched_64",
    "hipblasCtpsvBatched_v2_64",
    "hipblasZtpsvBatched_v2_64",
    "hipblasStpsvStridedBatched",
    "hipblasDtpsvStridedBatched",
    "hipblasCtpsvStridedBatched",
    "hipblasZtpsvStridedBatched",
    "hipblasCtpsvStridedBatched_v2",
    "hipblasZtpsvStridedBatched_v2",
    "hipblasStpsvStridedBatched_64",
    "hipblasDtpsvStridedBatched_64",
    "hipblasCtpsvStridedBatched_64",
    "hipblasZtpsvStridedBatched_64",
    "hipblasCtpsvStridedBatched_v2_64",
    "hipblasZtpsvStridedBatched_v2_64",
    "hipblasStrmv",
    "hipblasDtrmv",
    "hipblasCtrmv",
    "hipblasZtrmv",
    "hipblasCtrmv_v2",
    "hipblasZtrmv_v2",
    "hipblasStrmv_64",
    "hipblasDtrmv_64",
    "hipblasCtrmv_64",
    "hipblasZtrmv_64",
    "hipblasCtrmv_v2_64",
    "hipblasZtrmv_v2_64",
    "hipblasStrmvBatched",
    "hipblasDtrmvBatched",
    "hipblasCtrmvBatched",
    "hipblasZtrmvBatched",
    "hipblasCtrmvBatched_v2",
    "hipblasZtrmvBatched_v2",
    "hipblasStrmvBatched_64",
    "hipblasDtrmvBatched_64",
    "hipblasCtrmvBatched_64",
    "hipblasZtrmvBatched_64",
    "hipblasCtrmvBatched_v2_64",
    "hipblasZtrmvBatched_v2_64",
    "hipblasStrmvStridedBatched",
    "hipblasDtrmvStridedBatched",
    "hipblasCtrmvStridedBatched",
    "hipblasZtrmvStridedBatched",
    "hipblasCtrmvStridedBatched_v2",
    "hipblasZtrmvStridedBatched_v2",
    "hipblasStrmvStridedBatched_64",
    "hipblasDtrmvStridedBatched_64",
    "hipblasCtrmvStridedBatched_64",
    "hipblasZtrmvStridedBatched_64",
    "hipblasCtrmvStridedBatched_v2_64",
    "hipblasZtrmvStridedBatched_v2_64",
    "hipblasStrsv",
    "hipblasDtrsv",
    "hipblasCtrsv",
    "hipblasZtrsv",
    "hipblasCtrsv_v2",
    "hipblasZtrsv_v2",
    "hipblasStrsv_64",
    "hipblasDtrsv_64",
    "hipblasCtrsv_64",
    "hipblasZtrsv_64",
    "hipblasCtrsv_v2_64",
    "hipblasZtrsv_v2_64",
    "hipblasStrsvBatched",
    "hipblasDtrsvBatched",
    "hipblasCtrsvBatched",
    "hipblasZtrsvBatched",
    "hipblasCtrsvBatched_v2",
    "hipblasZtrsvBatched_v2",
    "hipblasStrsvBatched_64",
    "hipblasDtrsvBatched_64",
    "hipblasCtrsvBatched_64",
    "hipblasZtrsvBatched_64",
    "hipblasCtrsvBatched_v2_64",
    "hipblasZtrsvBatched_v2_64",
    "hipblasStrsvStridedBatched",
    "hipblasDtrsvStridedBatched",
    "hipblasCtrsvStridedBatched",
    "hipblasZtrsvStridedBatched",
    "hipblasCtrsvStridedBatched_v2",
    "hipblasZtrsvStridedBatched_v2",
    "hipblasStrsvStridedBatched_64",
    "hipblasDtrsvStridedBatched_64",
    "hipblasCtrsvStridedBatched_64",
    "hipblasZtrsvStridedBatched_64",
    "hipblasCtrsvStridedBatched_v2_64",
    "hipblasZtrsvStridedBatched_v2_64",
    "hipblasHgemm",
    "hipblasSgemm",
    "hipblasDgemm",
    "hipblasCgemm",
    "hipblasZgemm",
    "hipblasCgemm_v2",
    "hipblasZgemm_v2",
    "hipblasHgemmBatched",
    "hipblasSgemmBatched",
    "hipblasDgemmBatched",
    "hipblasCgemmBatched",
    "hipblasZgemmBatched",
    "hipblasCgemmBatched_v2",
    "hipblasZgemmBatched_v2",
    "hipblasHgemmStridedBatched",
    "hipblasSgemmStridedBatched",
    "hipblasDgemmStridedBatched",
    "hipblasCgemmStridedBatched",
    "hipblasZgemmStridedBatched",
    "hipblasCgemmStridedBatched_v2",
    "hipblasZgemmStridedBatched_v2",
    "hipblasCherk",
    "hipblasZherk",
    "hipblasCherk_v2",
    "hipblasZherk_v2",
    "hipblasCherkBatched",
    "hipblasZherkBatched",
    "hipblasCherkBatched_v2",
    "hipblasZherkBatched_v2",
    "hipblasCherkStridedBatched",
    "hipblasZherkStridedBatched",
    "hipblasCherkStridedBatched_v2",
    "hipblasZherkStridedBatched_v2",
    "hipblasCherkx",
    "hipblasZherkx",
    "hipblasCherkx_v2",
    "hipblasZherkx_v2",
    "hipblasCherkxBatched",
    "hipblasZherkxBatched",
    "hipblasCherkxBatched_v2",
    "hipblasZherkxBatched_v2",
    "hipblasCherkxStridedBatched",
    "hipblasZherkxStridedBatched",
    "hipblasCherkxStridedBatched_v2",
    "hipblasZherkxStridedBatched_v2",
    "hipblasCher2k",
    "hipblasZher2k",
    "hipblasCher2k_v2",
    "hipblasZher2k_v2",
    "hipblasCher2kBatched",
    "hipblasZher2kBatched",
    "hipblasCher2kBatched_v2",
    "hipblasZher2kBatched_v2",
    "hipblasCher2kStridedBatched",
    "hipblasZher2kStridedBatched",
    "hipblasCher2kStridedBatched_v2",
    "hipblasZher2kStridedBatched_v2",
    "hipblasSsymm",
    "hipblasDsymm",
    "hipblasCsymm",
    "hipblasZsymm",
    "hipblasCsymm_v2",
    "hipblasZsymm_v2",
    "hipblasSsymmBatched",
    "hipblasDsymmBatched",
    "hipblasCsymmBatched",
    "hipblasZsymmBatched",
    "hipblasCsymmBatched_v2",
    "hipblasZsymmBatched_v2",
    "hipblasSsymmStridedBatched",
    "hipblasDsymmStridedBatched",
    "hipblasCsymmStridedBatched",
    "hipblasZsymmStridedBatched",
    "hipblasCsymmStridedBatched_v2",
    "hipblasZsymmStridedBatched_v2",
    "hipblasSsyrk",
    "hipblasDsyrk",
    "hipblasCsyrk",
    "hipblasZsyrk",
    "hipblasCsyrk_v2",
    "hipblasZsyrk_v2",
    "hipblasSsyrkBatched",
    "hipblasDsyrkBatched",
    "hipblasCsyrkBatched",
    "hipblasZsyrkBatched",
    "hipblasCsyrkBatched_v2",
    "hipblasZsyrkBatched_v2",
    "hipblasSsyrkStridedBatched",
    "hipblasDsyrkStridedBatched",
    "hipblasCsyrkStridedBatched",
    "hipblasZsyrkStridedBatched",
    "hipblasCsyrkStridedBatched_v2",
    "hipblasZsyrkStridedBatched_v2",
    "hipblasSsyr2k",
    "hipblasDsyr2k",
    "hipblasCsyr2k",
    "hipblasZsyr2k",
    "hipblasCsyr2k_v2",
    "hipblasZsyr2k_v2",
    "hipblasSsyr2kBatched",
    "hipblasDsyr2kBatched",
    "hipblasCsyr2kBatched",
    "hipblasZsyr2kBatched",
    "hipblasCsyr2kBatched_v2",
    "hipblasZsyr2kBatched_v2",
    "hipblasSsyr2kStridedBatched",
    "hipblasDsyr2kStridedBatched",
    "hipblasCsyr2kStridedBatched",
    "hipblasZsyr2kStridedBatched",
    "hipblasCsyr2kStridedBatched_v2",
    "hipblasZsyr2kStridedBatched_v2",
    "hipblasSsyrkx",
    "hipblasDsyrkx",
    "hipblasCsyrkx",
    "hipblasZsyrkx",
    "hipblasCsyrkx_v2",
    "hipblasZsyrkx_v2",
    "hipblasSsyrkxBatched",
    "hipblasDsyrkxBatched",
    "hipblasCsyrkxBatched",
    "hipblasZsyrkxBatched",
    "hipblasCsyrkxBatched_v2",
    "hipblasZsyrkxBatched_v2",
    "hipblasSsyrkxStridedBatched",
    "hipblasDsyrkxStridedBatched",
    "hipblasCsyrkxStridedBatched",
    "hipblasZsyrkxStridedBatched",
    "hipblasCsyrkxStridedBatched_v2",
    "hipblasZsyrkxStridedBatched_v2",
    "hipblasSgeam",
    "hipblasDgeam",
    "hipblasCgeam",
    "hipblasZgeam",
    "hipblasCgeam_v2",
    "hipblasZgeam_v2",
    "hipblasSgeamBatched",
    "hipblasDgeamBatched",
    "hipblasCgeamBatched",
    "hipblasZgeamBatched",
    "hipblasCgeamBatched_v2",
    "hipblasZgeamBatched_v2",
    "hipblasSgeamStridedBatched",
    "hipblasDgeamStridedBatched",
    "hipblasCgeamStridedBatched",
    "hipblasZgeamStridedBatched",
    "hipblasCgeamStridedBatched_v2",
    "hipblasZgeamStridedBatched_v2",
    "hipblasChemm",
    "hipblasZhemm",
    "hipblasChemm_v2",
    "hipblasZhemm_v2",
    "hipblasChemmBatched",
    "hipblasZhemmBatched",
    "hipblasChemmBatched_v2",
    "hipblasZhemmBatched_v2",
    "hipblasChemmStridedBatched",
    "hipblasZhemmStridedBatched",
    "hipblasChemmStridedBatched_v2",
    "hipblasZhemmStridedBatched_v2",
    "hipblasStrmm",
    "hipblasDtrmm",
    "hipblasCtrmm",
    "hipblasZtrmm",
    "hipblasCtrmm_v2",
    "hipblasZtrmm_v2",
    "hipblasStrmmBatched",
    "hipblasDtrmmBatched",
    "hipblasCtrmmBatched",
    "hipblasZtrmmBatched",
    "hipblasCtrmmBatched_v2",
    "hipblasZtrmmBatched_v2",
    "hipblasStrmmStridedBatched",
    "hipblasDtrmmStridedBatched",
    "hipblasCtrmmStridedBatched",
    "hipblasZtrmmStridedBatched",
    "hipblasCtrmmStridedBatched_v2",
    "hipblasZtrmmStridedBatched_v2",
    "hipblasStrsm",
    "hipblasDtrsm",
    "hipblasCtrsm",
    "hipblasZtrsm",
    "hipblasCtrsm_v2",
    "hipblasZtrsm_v2",
    "hipblasStrsmBatched",
    "hipblasDtrsmBatched",
    "hipblasCtrsmBatched",
    "hipblasZtrsmBatched",
    "hipblasCtrsmBatched_v2",
    "hipblasZtrsmBatched_v2",
    "hipblasStrsmStridedBatched",
    "hipblasDtrsmStridedBatched",
    "hipblasCtrsmStridedBatched",
    "hipblasZtrsmStridedBatched",
    "hipblasCtrsmStridedBatched_v2",
    "hipblasZtrsmStridedBatched_v2",
    "hipblasStrtri",
    "hipblasDtrtri",
    "hipblasCtrtri",
    "hipblasZtrtri",
    "hipblasCtrtri_v2",
    "hipblasZtrtri_v2",
    "hipblasStrtriBatched",
    "hipblasDtrtriBatched",
    "hipblasCtrtriBatched",
    "hipblasZtrtriBatched",
    "hipblasCtrtriBatched_v2",
    "hipblasZtrtriBatched_v2",
    "hipblasStrtriStridedBatched",
    "hipblasDtrtriStridedBatched",
    "hipblasCtrtriStridedBatched",
    "hipblasZtrtriStridedBatched",
    "hipblasCtrtriStridedBatched_v2",
    "hipblasZtrtriStridedBatched_v2",
    "hipblasSdgmm",
    "hipblasDdgmm",
    "hipblasCdgmm",
    "hipblasZdgmm",
    "hipblasCdgmm_v2",
    "hipblasZdgmm_v2",
    "hipblasSdgmmBatched",
    "hipblasDdgmmBatched",
    "hipblasCdgmmBatched",
    "hipblasZdgmmBatched",
    "hipblasCdgmmBatched_v2",
    "hipblasZdgmmBatched_v2",
    "hipblasSdgmmStridedBatched",
    "hipblasDdgmmStridedBatched",
    "hipblasCdgmmStridedBatched",
    "hipblasZdgmmStridedBatched",
    "hipblasCdgmmStridedBatched_v2",
    "hipblasZdgmmStridedBatched_v2",
    "hipblasSgetrf",
    "hipblasDgetrf",
    "hipblasCgetrf",
    "hipblasZgetrf",
    "hipblasCgetrf_v2",
    "hipblasZgetrf_v2",
    "hipblasSgetrfBatched",
    "hipblasDgetrfBatched",
    "hipblasCgetrfBatched",
    "hipblasZgetrfBatched",
    "hipblasCgetrfBatched_v2",
    "hipblasZgetrfBatched_v2",
    "hipblasSgetrfStridedBatched",
    "hipblasDgetrfStridedBatched",
    "hipblasCgetrfStridedBatched",
    "hipblasZgetrfStridedBatched",
    "hipblasCgetrfStridedBatched_v2",
    "hipblasZgetrfStridedBatched_v2",
    "hipblasSgetrs",
    "hipblasDgetrs",
    "hipblasCgetrs",
    "hipblasZgetrs",
    "hipblasCgetrs_v2",
    "hipblasZgetrs_v2",
    "hipblasSgetrsBatched",
    "hipblasDgetrsBatched",
    "hipblasCgetrsBatched",
    "hipblasZgetrsBatched",
    "hipblasCgetrsBatched_v2",
    "hipblasZgetrsBatched_v2",
    "hipblasSgetrsStridedBatched",
    "hipblasDgetrsStridedBatched",
    "hipblasCgetrsStridedBatched",
    "hipblasZgetrsStridedBatched",
    "hipblasCgetrsStridedBatched_v2",
    "hipblasZgetrsStridedBatched_v2",
    "hipblasSgetriBatched",
    "hipblasDgetriBatched",
    "hipblasCgetriBatched",
    "hipblasZgetriBatched",
    "hipblasCgetriBatched_v2",
    "hipblasZgetriBatched_v2",
    "hipblasSgels",
    "hipblasDgels",
    "hipblasCgels",
    "hipblasZgels",
    "hipblasCgels_v2",
    "hipblasZgels_v2",
    "hipblasSgelsBatched",
    "hipblasDgelsBatched",
    "hipblasCgelsBatched",
    "hipblasZgelsBatched",
    "hipblasCgelsBatched_v2",
    "hipblasZgelsBatched_v2",
    "hipblasSgelsStridedBatched",
    "hipblasDgelsStridedBatched",
    "hipblasCgelsStridedBatched",
    "hipblasZgelsStridedBatched",
    "hipblasCgelsStridedBatched_v2",
    "hipblasZgelsStridedBatched_v2",
    "hipblasSgeqrf",
    "hipblasDgeqrf",
    "hipblasCgeqrf",
    "hipblasZgeqrf",
    "hipblasCgeqrf_v2",
    "hipblasZgeqrf_v2",
    "hipblasSgeqrfBatched",
    "hipblasDgeqrfBatched",
    "hipblasCgeqrfBatched",
    "hipblasZgeqrfBatched",
    "hipblasCgeqrfBatched_v2",
    "hipblasZgeqrfBatched_v2",
    "hipblasSgeqrfStridedBatched",
    "hipblasDgeqrfStridedBatched",
    "hipblasCgeqrfStridedBatched",
    "hipblasZgeqrfStridedBatched",
    "hipblasCgeqrfStridedBatched_v2",
    "hipblasZgeqrfStridedBatched_v2",
    "hipblasGemmEx",
    "hipblasGemmEx_v2",
    "hipblasGemmExWithFlags",
    "hipblasGemmExWithFlags_v2",
    "hipblasGemmBatchedEx",
    "hipblasGemmBatchedEx_v2",
    "hipblasGemmBatchedExWithFlags",
    "hipblasGemmBatchedExWithFlags_v2",
    "hipblasGemmStridedBatchedEx",
    "hipblasGemmStridedBatchedEx_v2",
    "hipblasGemmStridedBatchedExWithFlags",
    "hipblasGemmStridedBatchedExWithFlags_v2",
    "hipblasTrsmEx",
    "hipblasTrsmEx_v2",
    "hipblasTrsmBatchedEx",
    "hipblasTrsmBatchedEx_v2",
    "hipblasTrsmStridedBatchedEx",
    "hipblasTrsmStridedBatchedEx_v2",
    "hipblasAxpyEx",
    "hipblasAxpyEx_v2",
    "hipblasAxpyEx_64",
    "hipblasAxpyEx_v2_64",
    "hipblasAxpyBatchedEx",
    "hipblasAxpyBatchedEx_v2",
    "hipblasAxpyBatchedEx_64",
    "hipblasAxpyBatchedEx_v2_64",
    "hipblasAxpyStridedBatchedEx",
    "hipblasAxpyStridedBatchedEx_v2",
    "hipblasAxpyStridedBatchedEx_64",
    "hipblasAxpyStridedBatchedEx_v2_64",
    "hipblasDotEx",
    "hipblasDotcEx",
    "hipblasDotEx_v2",
    "hipblasDotcEx_v2",
    "hipblasDotEx_64",
    "hipblasDotcEx_64",
    "hipblasDotEx_v2_64",
    "hipblasDotcEx_v2_64",
    "hipblasDotBatchedEx",
    "hipblasDotcBatchedEx",
    "hipblasDotBatchedEx_v2",
    "hipblasDotcBatchedEx_v2",
    "hipblasDotBatchedEx_64",
    "hipblasDotcBatchedEx_64",
    "hipblasDotBatchedEx_v2_64",
    "hipblasDotcBatchedEx_v2_64",
    "hipblasDotStridedBatchedEx",
    "hipblasDotcStridedBatchedEx",
    "hipblasDotStridedBatchedEx_v2",
    "hipblasDotcStridedBatchedEx_v2",
    "hipblasDotStridedBatchedEx_64",
    "hipblasDotcStridedBatchedEx_64",
    "hipblasDotStridedBatchedEx_v2_64",
    "hipblasDotcStridedBatchedEx_v2_64",
    "hipblasNrm2Ex",
    "hipblasNrm2Ex_v2",
    "hipblasNrm2Ex_64",
    "hipblasNrm2Ex_v2_64",
    "hipblasNrm2BatchedEx",
    "hipblasNrm2BatchedEx_v2",
    "hipblasNrm2BatchedEx_64",
    "hipblasNrm2BatchedEx_v2_64",
    "hipblasNrm2StridedBatchedEx",
    "hipblasNrm2StridedBatchedEx_v2",
    "hipblasNrm2StridedBatchedEx_64",
    "hipblasNrm2StridedBatchedEx_v2_64",
    "hipblasRotEx",
    "hipblasRotEx_v2",
    "hipblasRotEx_64",
    "hipblasRotEx_v2_64",
    "hipblasRotBatchedEx",
    "hipblasRotBatchedEx_v2",
    "hipblasRotBatchedEx_64",
    "hipblasRotBatchedEx_v2_64",
    "hipblasRotStridedBatchedEx",
    "hipblasRotStridedBatchedEx_v2",
    "hipblasRotStridedBatchedEx_64",
    "hipblasRotStridedBatchedEx_v2_64",
    "hipblasScalEx",
    "hipblasScalEx_v2",
    "hipblasScalEx_64",
    "hipblasScalEx_v2_64",
    "hipblasScalBatchedEx",
    "hipblasScalBatchedEx_v2",
    "hipblasScalBatchedEx_64",
    "hipblasScalBatchedEx_v2_64",
    "hipblasScalStridedBatchedEx",
    "hipblasScalStridedBatchedEx_v2",
    "hipblasScalStridedBatchedEx_64",
    "hipblasScalStridedBatchedEx_v2_64",
    "hipblasStatusToString",
]