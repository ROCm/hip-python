# MIT License
#
# Copyright (c) 2023-2024 Advanced Micro Devices, Inc.
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in all
# copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
# SOFTWARE.

# This file has been autogenerated, do not modify.

cimport hip._util.posixloader as loader
cdef void* _lib_handle = NULL

DLL = b"librccl.so"

cdef int __init() except 1 nogil:
    global DLL
    global _lib_handle
    cdef char* dll = NULL
    if _lib_handle == NULL:
        with gil:
            dll = DLL
        return loader.open_library(&_lib_handle,dll)
    return 0

cdef int __init_symbol(void** result, const char* name) except 1 nogil:
    global _lib_handle
    cdef int init_result = 0
    if _lib_handle == NULL:
        init_result = __init()
        if init_result > 0:
            return init_result
    if result[0] == NULL:
        return loader.load_symbol(result,_lib_handle, name)
    return 0


cdef void* _ncclGetVersion__funptr = NULL
#  @brief Return the NCCL_VERSION_CODE of the NCCL library in the supplied integer.
# 
# @details This integer is coded with the MAJOR, MINOR and PATCH level of the
# NCCL library
cdef ncclResult_t ncclGetVersion(int * version):
    global _ncclGetVersion__funptr
    if __init_symbol(&_ncclGetVersion__funptr,"ncclGetVersion") > 0:
        pass
    return (<ncclResult_t (*)(int *) noexcept nogil> _ncclGetVersion__funptr)(version)


cdef void* _pncclGetVersion__funptr = NULL
# @cond include_hidden
cdef ncclResult_t pncclGetVersion(int * version):
    global _pncclGetVersion__funptr
    if __init_symbol(&_pncclGetVersion__funptr,"pncclGetVersion") > 0:
        pass
    return (<ncclResult_t (*)(int *) noexcept nogil> _pncclGetVersion__funptr)(version)


cdef void* _ncclGetUniqueId__funptr = NULL
# @brief Generates an ID for ncclCommInitRank
# 
# @details
# Generates an ID to be used in ncclCommInitRank. ncclGetUniqueId should be
# called once and the Id should be distributed to all ranks in the
# communicator before calling ncclCommInitRank.
# 
# @param[in]
# uniqueId     ncclUniqueId*
#              pointer to uniqueId
#
cdef ncclResult_t ncclGetUniqueId(ncclUniqueId * uniqueId):
    global _ncclGetUniqueId__funptr
    if __init_symbol(&_ncclGetUniqueId__funptr,"ncclGetUniqueId") > 0:
        pass
    return (<ncclResult_t (*)(ncclUniqueId *) noexcept nogil> _ncclGetUniqueId__funptr)(uniqueId)


cdef void* _pncclGetUniqueId__funptr = NULL
# @cond include_hidden
cdef ncclResult_t pncclGetUniqueId(ncclUniqueId * uniqueId):
    global _pncclGetUniqueId__funptr
    if __init_symbol(&_pncclGetUniqueId__funptr,"pncclGetUniqueId") > 0:
        pass
    return (<ncclResult_t (*)(ncclUniqueId *) noexcept nogil> _pncclGetUniqueId__funptr)(uniqueId)


cdef void* _ncclCommInitRankConfig__funptr = NULL
#  @brief Create a new communicator (multi thread/process version) with a configuration
# set by users.
cdef ncclResult_t ncclCommInitRankConfig(ncclComm_t* comm,int nranks,ncclUniqueId commId,int rank,ncclConfig_v21700 * config):
    global _ncclCommInitRankConfig__funptr
    if __init_symbol(&_ncclCommInitRankConfig__funptr,"ncclCommInitRankConfig") > 0:
        pass
    return (<ncclResult_t (*)(ncclComm_t*,int,ncclUniqueId,int,ncclConfig_v21700 *) noexcept nogil> _ncclCommInitRankConfig__funptr)(comm,nranks,commId,rank,config)


cdef void* _pncclCommInitRankConfig__funptr = NULL
# @cond include_hidden
cdef ncclResult_t pncclCommInitRankConfig(ncclComm_t* comm,int nranks,ncclUniqueId commId,int rank,ncclConfig_v21700 * config):
    global _pncclCommInitRankConfig__funptr
    if __init_symbol(&_pncclCommInitRankConfig__funptr,"pncclCommInitRankConfig") > 0:
        pass
    return (<ncclResult_t (*)(ncclComm_t*,int,ncclUniqueId,int,ncclConfig_v21700 *) noexcept nogil> _pncclCommInitRankConfig__funptr)(comm,nranks,commId,rank,config)


cdef void* _ncclCommInitRank__funptr = NULL
# @brief Creates a new communicator (multi thread/process version).
# 
# @details
# rank must be between 0 and nranks-1 and unique within a communicator clique.
# Each rank is associated to a CUDA device, which has to be set before calling
# ncclCommInitRank.
# ncclCommInitRank implicitly syncronizes with other ranks, so it must be
# called by different threads/processes or use ncclGroupStart/ncclGroupEnd.
# 
# @param[in]
# comm        ncclComm_t*
#             communicator struct pointer
cdef ncclResult_t ncclCommInitRank(ncclComm_t* comm,int nranks,ncclUniqueId commId,int rank):
    global _ncclCommInitRank__funptr
    if __init_symbol(&_ncclCommInitRank__funptr,"ncclCommInitRank") > 0:
        pass
    return (<ncclResult_t (*)(ncclComm_t*,int,ncclUniqueId,int) noexcept nogil> _ncclCommInitRank__funptr)(comm,nranks,commId,rank)


cdef void* _pncclCommInitRank__funptr = NULL
# @cond include_hidden
cdef ncclResult_t pncclCommInitRank(ncclComm_t* comm,int nranks,ncclUniqueId commId,int rank):
    global _pncclCommInitRank__funptr
    if __init_symbol(&_pncclCommInitRank__funptr,"pncclCommInitRank") > 0:
        pass
    return (<ncclResult_t (*)(ncclComm_t*,int,ncclUniqueId,int) noexcept nogil> _pncclCommInitRank__funptr)(comm,nranks,commId,rank)


cdef void* _ncclCommInitRankMulti__funptr = NULL
# @brief Creates a new communicator (multi thread/process version) allowing multiple ranks per device.
# 
# @details
# rank must be between 0 and nranks-1 and unique within a communicator clique.
# Each rank is associated to a HIP device, which has to be set before calling
# ncclCommInitRankMulti.
# Since this version of the function allows multiple ranks to utilize the same
# HIP device, a unique virtualId per device has to be provided by each calling
# rank.
# ncclCommInitRankMulti implicitly syncronizes with other ranks, so it must be
# called by different threads/processes or use ncclGroupStart/ncclGroupEnd.
# 
# @param[in]
# comm        ncclComm_t*
#             communicator struct pointer
cdef ncclResult_t ncclCommInitRankMulti(ncclComm_t* comm,int nranks,ncclUniqueId commId,int rank,int virtualId):
    global _ncclCommInitRankMulti__funptr
    if __init_symbol(&_ncclCommInitRankMulti__funptr,"ncclCommInitRankMulti") > 0:
        pass
    return (<ncclResult_t (*)(ncclComm_t*,int,ncclUniqueId,int,int) noexcept nogil> _ncclCommInitRankMulti__funptr)(comm,nranks,commId,rank,virtualId)


cdef void* _pncclCommInitRankMulti__funptr = NULL
# @cond include_hidden
cdef ncclResult_t pncclCommInitRankMulti(ncclComm_t* comm,int nranks,ncclUniqueId commId,int rank,int virtualId):
    global _pncclCommInitRankMulti__funptr
    if __init_symbol(&_pncclCommInitRankMulti__funptr,"pncclCommInitRankMulti") > 0:
        pass
    return (<ncclResult_t (*)(ncclComm_t*,int,ncclUniqueId,int,int) noexcept nogil> _pncclCommInitRankMulti__funptr)(comm,nranks,commId,rank,virtualId)


cdef void* _ncclCommInitAll__funptr = NULL
#  @brief Creates a clique of communicators (single process version).
# 
# @details This is a convenience function to create a single-process communicator clique.
# Returns an array of ndev newly initialized communicators in comm.
# comm should be pre-allocated with size at least ndev*sizeof(ncclComm_t).
# If devlist is NULL, the first ndev HIP devices are used.
# Order of devlist defines user-order of processors within the communicator.
cdef ncclResult_t ncclCommInitAll(ncclComm_t* comm,int ndev,const int * devlist):
    global _ncclCommInitAll__funptr
    if __init_symbol(&_ncclCommInitAll__funptr,"ncclCommInitAll") > 0:
        pass
    return (<ncclResult_t (*)(ncclComm_t*,int,const int *) noexcept nogil> _ncclCommInitAll__funptr)(comm,ndev,devlist)


cdef void* _pncclCommInitAll__funptr = NULL
# @cond include_hidden
cdef ncclResult_t pncclCommInitAll(ncclComm_t* comm,int ndev,const int * devlist):
    global _pncclCommInitAll__funptr
    if __init_symbol(&_pncclCommInitAll__funptr,"pncclCommInitAll") > 0:
        pass
    return (<ncclResult_t (*)(ncclComm_t*,int,const int *) noexcept nogil> _pncclCommInitAll__funptr)(comm,ndev,devlist)


cdef void* _ncclCommFinalize__funptr = NULL
#  @brief Finalize a communicator.
# @details ncclCommFinalize flushes all issued communications,
# and marks communicator state as ncclInProgress. The state will change to ncclSuccess
# when the communicator is globally quiescent and related resources are freed; then,
# calling ncclCommDestroy can locally free the rest of the resources (e.g. communicator
# itself) without blocking.
cdef ncclResult_t ncclCommFinalize(ncclComm_t comm):
    global _ncclCommFinalize__funptr
    if __init_symbol(&_ncclCommFinalize__funptr,"ncclCommFinalize") > 0:
        pass
    return (<ncclResult_t (*)(ncclComm_t) noexcept nogil> _ncclCommFinalize__funptr)(comm)


cdef void* _pncclCommFinalize__funptr = NULL
# @cond include_hidden
cdef ncclResult_t pncclCommFinalize(ncclComm_t comm):
    global _pncclCommFinalize__funptr
    if __init_symbol(&_pncclCommFinalize__funptr,"pncclCommFinalize") > 0:
        pass
    return (<ncclResult_t (*)(ncclComm_t) noexcept nogil> _pncclCommFinalize__funptr)(comm)


cdef void* _ncclCommDestroy__funptr = NULL
# @brief Frees local resources associated with communicator object. */
cdef ncclResult_t ncclCommDestroy(ncclComm_t comm):
    global _ncclCommDestroy__funptr
    if __init_symbol(&_ncclCommDestroy__funptr,"ncclCommDestroy") > 0:
        pass
    return (<ncclResult_t (*)(ncclComm_t) noexcept nogil> _ncclCommDestroy__funptr)(comm)


cdef void* _pncclCommDestroy__funptr = NULL
# @cond include_hidden
cdef ncclResult_t pncclCommDestroy(ncclComm_t comm):
    global _pncclCommDestroy__funptr
    if __init_symbol(&_pncclCommDestroy__funptr,"pncclCommDestroy") > 0:
        pass
    return (<ncclResult_t (*)(ncclComm_t) noexcept nogil> _pncclCommDestroy__funptr)(comm)


cdef void* _ncclCommAbort__funptr = NULL
#  @brief Frees resources associated with communicator object and aborts any operations
# that might still be running on the device.
cdef ncclResult_t ncclCommAbort(ncclComm_t comm):
    global _ncclCommAbort__funptr
    if __init_symbol(&_ncclCommAbort__funptr,"ncclCommAbort") > 0:
        pass
    return (<ncclResult_t (*)(ncclComm_t) noexcept nogil> _ncclCommAbort__funptr)(comm)


cdef void* _pncclCommAbort__funptr = NULL
# @cond include_hidden
cdef ncclResult_t pncclCommAbort(ncclComm_t comm):
    global _pncclCommAbort__funptr
    if __init_symbol(&_pncclCommAbort__funptr,"pncclCommAbort") > 0:
        pass
    return (<ncclResult_t (*)(ncclComm_t) noexcept nogil> _pncclCommAbort__funptr)(comm)


cdef void* _ncclGetErrorString__funptr = NULL
# @brief Returns a string for each error code. */
cdef const char * ncclGetErrorString(ncclResult_t result):
    global _ncclGetErrorString__funptr
    if __init_symbol(&_ncclGetErrorString__funptr,"ncclGetErrorString") > 0:
        pass
    return (<const char * (*)(ncclResult_t) noexcept nogil> _ncclGetErrorString__funptr)(result)


cdef void* _pncclGetErrorString__funptr = NULL
# @cond include_hidden
cdef const char * pncclGetErrorString(ncclResult_t result):
    global _pncclGetErrorString__funptr
    if __init_symbol(&_pncclGetErrorString__funptr,"pncclGetErrorString") > 0:
        pass
    return (<const char * (*)(ncclResult_t) noexcept nogil> _pncclGetErrorString__funptr)(result)


cdef void* _ncclGetLastError__funptr = NULL
#  @brief Returns a human-readable message of the last error that occurred.
# comm is currently unused and can be set to NULL
cdef const char * ncclGetLastError(ncclComm_t comm):
    global _ncclGetLastError__funptr
    if __init_symbol(&_ncclGetLastError__funptr,"ncclGetLastError") > 0:
        pass
    return (<const char * (*)(ncclComm_t) noexcept nogil> _ncclGetLastError__funptr)(comm)


cdef void* _pncclGetLastError__funptr = NULL
# @cond include_hidden
cdef const char * pncclGetLastError(ncclComm_t comm):
    global _pncclGetLastError__funptr
    if __init_symbol(&_pncclGetLastError__funptr,"pncclGetLastError") > 0:
        pass
    return (<const char * (*)(ncclComm_t) noexcept nogil> _pncclGetLastError__funptr)(comm)


cdef void* _ncclCommGetAsyncError__funptr = NULL
# @endcond
cdef ncclResult_t ncclCommGetAsyncError(ncclComm_t comm,ncclResult_t * asyncError):
    global _ncclCommGetAsyncError__funptr
    if __init_symbol(&_ncclCommGetAsyncError__funptr,"ncclCommGetAsyncError") > 0:
        pass
    return (<ncclResult_t (*)(ncclComm_t,ncclResult_t *) noexcept nogil> _ncclCommGetAsyncError__funptr)(comm,asyncError)


cdef void* _pncclCommGetAsyncError__funptr = NULL
# @cond include_hidden
cdef ncclResult_t pncclCommGetAsyncError(ncclComm_t comm,ncclResult_t * asyncError):
    global _pncclCommGetAsyncError__funptr
    if __init_symbol(&_pncclCommGetAsyncError__funptr,"pncclCommGetAsyncError") > 0:
        pass
    return (<ncclResult_t (*)(ncclComm_t,ncclResult_t *) noexcept nogil> _pncclCommGetAsyncError__funptr)(comm,asyncError)


cdef void* _ncclCommCount__funptr = NULL
# @brief Gets the number of ranks in the communicator clique. */
cdef ncclResult_t ncclCommCount(ncclComm_t comm,int * count):
    global _ncclCommCount__funptr
    if __init_symbol(&_ncclCommCount__funptr,"ncclCommCount") > 0:
        pass
    return (<ncclResult_t (*)(ncclComm_t,int *) noexcept nogil> _ncclCommCount__funptr)(comm,count)


cdef void* _pncclCommCount__funptr = NULL
# @cond include_hidden
cdef ncclResult_t pncclCommCount(ncclComm_t comm,int * count):
    global _pncclCommCount__funptr
    if __init_symbol(&_pncclCommCount__funptr,"pncclCommCount") > 0:
        pass
    return (<ncclResult_t (*)(ncclComm_t,int *) noexcept nogil> _pncclCommCount__funptr)(comm,count)


cdef void* _ncclCommCuDevice__funptr = NULL
# @brief Returns the rocm device number associated with the communicator. */
cdef ncclResult_t ncclCommCuDevice(ncclComm_t comm,int * device):
    global _ncclCommCuDevice__funptr
    if __init_symbol(&_ncclCommCuDevice__funptr,"ncclCommCuDevice") > 0:
        pass
    return (<ncclResult_t (*)(ncclComm_t,int *) noexcept nogil> _ncclCommCuDevice__funptr)(comm,device)


cdef void* _pncclCommCuDevice__funptr = NULL
# @cond include_hidden
cdef ncclResult_t pncclCommCuDevice(ncclComm_t comm,int * device):
    global _pncclCommCuDevice__funptr
    if __init_symbol(&_pncclCommCuDevice__funptr,"pncclCommCuDevice") > 0:
        pass
    return (<ncclResult_t (*)(ncclComm_t,int *) noexcept nogil> _pncclCommCuDevice__funptr)(comm,device)


cdef void* _ncclCommUserRank__funptr = NULL
# @brief Returns the user-ordered "rank" associated with the communicator. */
cdef ncclResult_t ncclCommUserRank(ncclComm_t comm,int * rank):
    global _ncclCommUserRank__funptr
    if __init_symbol(&_ncclCommUserRank__funptr,"ncclCommUserRank") > 0:
        pass
    return (<ncclResult_t (*)(ncclComm_t,int *) noexcept nogil> _ncclCommUserRank__funptr)(comm,rank)


cdef void* _pncclCommUserRank__funptr = NULL
# @cond include_hidden
cdef ncclResult_t pncclCommUserRank(ncclComm_t comm,int * rank):
    global _pncclCommUserRank__funptr
    if __init_symbol(&_pncclCommUserRank__funptr,"pncclCommUserRank") > 0:
        pass
    return (<ncclResult_t (*)(ncclComm_t,int *) noexcept nogil> _pncclCommUserRank__funptr)(comm,rank)


cdef void* _ncclRedOpCreatePreMulSum__funptr = NULL
#  @brief ncclRedOpCreatePreMulSum
# Creates a new reduction operator which pre-multiplies input values by a given
# scalar locally before reducing them with peer values via summation. For use
# only with collectives launched against *comm* and *datatype*. The
# *residence* argument indicates how/when the memory pointed to by *scalar*
# will be dereferenced. Upon return, the newly created operator's handle
# is stored in *op*.
cdef ncclResult_t ncclRedOpCreatePreMulSum(ncclRedOp_t * op,void * scalar,ncclDataType_t datatype,ncclScalarResidence_t residence,ncclComm_t comm):
    global _ncclRedOpCreatePreMulSum__funptr
    if __init_symbol(&_ncclRedOpCreatePreMulSum__funptr,"ncclRedOpCreatePreMulSum") > 0:
        pass
    return (<ncclResult_t (*)(ncclRedOp_t *,void *,ncclDataType_t,ncclScalarResidence_t,ncclComm_t) noexcept nogil> _ncclRedOpCreatePreMulSum__funptr)(op,scalar,datatype,residence,comm)


cdef void* _pncclRedOpCreatePreMulSum__funptr = NULL
# @cond include_hidden
cdef ncclResult_t pncclRedOpCreatePreMulSum(ncclRedOp_t * op,void * scalar,ncclDataType_t datatype,ncclScalarResidence_t residence,ncclComm_t comm):
    global _pncclRedOpCreatePreMulSum__funptr
    if __init_symbol(&_pncclRedOpCreatePreMulSum__funptr,"pncclRedOpCreatePreMulSum") > 0:
        pass
    return (<ncclResult_t (*)(ncclRedOp_t *,void *,ncclDataType_t,ncclScalarResidence_t,ncclComm_t) noexcept nogil> _pncclRedOpCreatePreMulSum__funptr)(op,scalar,datatype,residence,comm)


cdef void* _ncclRedOpDestroy__funptr = NULL
#  @brief ncclRedOpDestroy
# @details Destroys the reduction operator *op*. The operator must have been created by
# ncclRedOpCreatePreMul with the matching communicator *comm*. An operator may be
# destroyed as soon as the last NCCL function which is given that operator returns.
cdef ncclResult_t ncclRedOpDestroy(ncclRedOp_t op,ncclComm_t comm):
    global _ncclRedOpDestroy__funptr
    if __init_symbol(&_ncclRedOpDestroy__funptr,"ncclRedOpDestroy") > 0:
        pass
    return (<ncclResult_t (*)(ncclRedOp_t,ncclComm_t) noexcept nogil> _ncclRedOpDestroy__funptr)(op,comm)


cdef void* _pncclRedOpDestroy__funptr = NULL
# @cond include_hidden
cdef ncclResult_t pncclRedOpDestroy(ncclRedOp_t op,ncclComm_t comm):
    global _pncclRedOpDestroy__funptr
    if __init_symbol(&_pncclRedOpDestroy__funptr,"pncclRedOpDestroy") > 0:
        pass
    return (<ncclResult_t (*)(ncclRedOp_t,ncclComm_t) noexcept nogil> _pncclRedOpDestroy__funptr)(op,comm)


cdef void* _ncclReduce__funptr = NULL
# 
# @brief Reduce
# 
# @details Reduces data arrays of length count in sendbuff into recvbuff using op
# operation.
# recvbuff may be NULL on all calls except for root device.
# root is the rank (not the CUDA device) where data will reside after the
# operation is complete.
# 
# In-place operation will happen if sendbuff == recvbuff.
cdef ncclResult_t ncclReduce(const void * sendbuff,void * recvbuff,unsigned long count,ncclDataType_t datatype,ncclRedOp_t op,int root,ncclComm_t comm,hipStream_t stream):
    global _ncclReduce__funptr
    if __init_symbol(&_ncclReduce__funptr,"ncclReduce") > 0:
        pass
    return (<ncclResult_t (*)(const void *,void *,unsigned long,ncclDataType_t,ncclRedOp_t,int,ncclComm_t,hipStream_t) noexcept nogil> _ncclReduce__funptr)(sendbuff,recvbuff,count,datatype,op,root,comm,stream)


cdef void* _pncclReduce__funptr = NULL
# @cond include_hidden
cdef ncclResult_t pncclReduce(const void * sendbuff,void * recvbuff,unsigned long count,ncclDataType_t datatype,ncclRedOp_t op,int root,ncclComm_t comm,hipStream_t stream):
    global _pncclReduce__funptr
    if __init_symbol(&_pncclReduce__funptr,"pncclReduce") > 0:
        pass
    return (<ncclResult_t (*)(const void *,void *,unsigned long,ncclDataType_t,ncclRedOp_t,int,ncclComm_t,hipStream_t) noexcept nogil> _pncclReduce__funptr)(sendbuff,recvbuff,count,datatype,op,root,comm,stream)


cdef void* _ncclBcast__funptr = NULL
#  @brief (deprecated) Broadcast (in-place)
# 
# @details Copies count values from root to all other devices.
# root is the rank (not the CUDA device) where data resides before the
# operation is started.
# 
# This operation is implicitely in place.
cdef ncclResult_t ncclBcast(void * buff,unsigned long count,ncclDataType_t datatype,int root,ncclComm_t comm,hipStream_t stream):
    global _ncclBcast__funptr
    if __init_symbol(&_ncclBcast__funptr,"ncclBcast") > 0:
        pass
    return (<ncclResult_t (*)(void *,unsigned long,ncclDataType_t,int,ncclComm_t,hipStream_t) noexcept nogil> _ncclBcast__funptr)(buff,count,datatype,root,comm,stream)


cdef void* _pncclBcast__funptr = NULL
# @cond include_hidden
cdef ncclResult_t pncclBcast(void * buff,unsigned long count,ncclDataType_t datatype,int root,ncclComm_t comm,hipStream_t stream):
    global _pncclBcast__funptr
    if __init_symbol(&_pncclBcast__funptr,"pncclBcast") > 0:
        pass
    return (<ncclResult_t (*)(void *,unsigned long,ncclDataType_t,int,ncclComm_t,hipStream_t) noexcept nogil> _pncclBcast__funptr)(buff,count,datatype,root,comm,stream)


cdef void* _ncclBroadcast__funptr = NULL
#  @brief Broadcast
# 
# @details Copies count values from root to all other devices.
# root is the rank (not the HIP device) where data resides before the
# operation is started.
# 
# In-place operation will happen if sendbuff == recvbuff.
cdef ncclResult_t ncclBroadcast(const void * sendbuff,void * recvbuff,unsigned long count,ncclDataType_t datatype,int root,ncclComm_t comm,hipStream_t stream):
    global _ncclBroadcast__funptr
    if __init_symbol(&_ncclBroadcast__funptr,"ncclBroadcast") > 0:
        pass
    return (<ncclResult_t (*)(const void *,void *,unsigned long,ncclDataType_t,int,ncclComm_t,hipStream_t) noexcept nogil> _ncclBroadcast__funptr)(sendbuff,recvbuff,count,datatype,root,comm,stream)


cdef void* _pncclBroadcast__funptr = NULL
# @cond include_hidden
cdef ncclResult_t pncclBroadcast(const void * sendbuff,void * recvbuff,unsigned long count,ncclDataType_t datatype,int root,ncclComm_t comm,hipStream_t stream):
    global _pncclBroadcast__funptr
    if __init_symbol(&_pncclBroadcast__funptr,"pncclBroadcast") > 0:
        pass
    return (<ncclResult_t (*)(const void *,void *,unsigned long,ncclDataType_t,int,ncclComm_t,hipStream_t) noexcept nogil> _pncclBroadcast__funptr)(sendbuff,recvbuff,count,datatype,root,comm,stream)


cdef void* _ncclAllReduce__funptr = NULL
#  @brief All-Reduce
# 
# @details Reduces data arrays of length count in sendbuff using op operation, and
# leaves identical copies of result on each recvbuff.
# 
# In-place operation will happen if sendbuff == recvbuff.
cdef ncclResult_t ncclAllReduce(const void * sendbuff,void * recvbuff,unsigned long count,ncclDataType_t datatype,ncclRedOp_t op,ncclComm_t comm,hipStream_t stream):
    global _ncclAllReduce__funptr
    if __init_symbol(&_ncclAllReduce__funptr,"ncclAllReduce") > 0:
        pass
    return (<ncclResult_t (*)(const void *,void *,unsigned long,ncclDataType_t,ncclRedOp_t,ncclComm_t,hipStream_t) noexcept nogil> _ncclAllReduce__funptr)(sendbuff,recvbuff,count,datatype,op,comm,stream)


cdef void* _pncclAllReduce__funptr = NULL
# @cond include_hidden
cdef ncclResult_t pncclAllReduce(const void * sendbuff,void * recvbuff,unsigned long count,ncclDataType_t datatype,ncclRedOp_t op,ncclComm_t comm,hipStream_t stream):
    global _pncclAllReduce__funptr
    if __init_symbol(&_pncclAllReduce__funptr,"pncclAllReduce") > 0:
        pass
    return (<ncclResult_t (*)(const void *,void *,unsigned long,ncclDataType_t,ncclRedOp_t,ncclComm_t,hipStream_t) noexcept nogil> _pncclAllReduce__funptr)(sendbuff,recvbuff,count,datatype,op,comm,stream)


cdef void* _ncclReduceScatter__funptr = NULL
# 
# @brief Reduce-Scatter
# 
# @details Reduces data in sendbuff using op operation and leaves reduced result
# scattered over the devices so that recvbuff on rank i will contain the i-th
# block of the result.
# Assumes sendcount is equal to nranks*recvcount, which means that sendbuff
# should have a size of at least nranks*recvcount elements.
# 
# In-place operations will happen if recvbuff == sendbuff + rank * recvcount.
cdef ncclResult_t ncclReduceScatter(const void * sendbuff,void * recvbuff,unsigned long recvcount,ncclDataType_t datatype,ncclRedOp_t op,ncclComm_t comm,hipStream_t stream):
    global _ncclReduceScatter__funptr
    if __init_symbol(&_ncclReduceScatter__funptr,"ncclReduceScatter") > 0:
        pass
    return (<ncclResult_t (*)(const void *,void *,unsigned long,ncclDataType_t,ncclRedOp_t,ncclComm_t,hipStream_t) noexcept nogil> _ncclReduceScatter__funptr)(sendbuff,recvbuff,recvcount,datatype,op,comm,stream)


cdef void* _pncclReduceScatter__funptr = NULL
# @cond include_hidden
cdef ncclResult_t pncclReduceScatter(const void * sendbuff,void * recvbuff,unsigned long recvcount,ncclDataType_t datatype,ncclRedOp_t op,ncclComm_t comm,hipStream_t stream):
    global _pncclReduceScatter__funptr
    if __init_symbol(&_pncclReduceScatter__funptr,"pncclReduceScatter") > 0:
        pass
    return (<ncclResult_t (*)(const void *,void *,unsigned long,ncclDataType_t,ncclRedOp_t,ncclComm_t,hipStream_t) noexcept nogil> _pncclReduceScatter__funptr)(sendbuff,recvbuff,recvcount,datatype,op,comm,stream)


cdef void* _ncclAllGather__funptr = NULL
#  @brief All-Gather
# 
# @details Each device gathers sendcount values from other GPUs into recvbuff,
# receiving data from rank i at offset i*sendcount.
# Assumes recvcount is equal to nranks*sendcount, which means that recvbuff
# should have a size of at least nranks*sendcount elements.
# 
# In-place operations will happen if sendbuff == recvbuff + rank * sendcount.
cdef ncclResult_t ncclAllGather(const void * sendbuff,void * recvbuff,unsigned long sendcount,ncclDataType_t datatype,ncclComm_t comm,hipStream_t stream):
    global _ncclAllGather__funptr
    if __init_symbol(&_ncclAllGather__funptr,"ncclAllGather") > 0:
        pass
    return (<ncclResult_t (*)(const void *,void *,unsigned long,ncclDataType_t,ncclComm_t,hipStream_t) noexcept nogil> _ncclAllGather__funptr)(sendbuff,recvbuff,sendcount,datatype,comm,stream)


cdef void* _pncclAllGather__funptr = NULL
# @cond include_hidden
cdef ncclResult_t pncclAllGather(const void * sendbuff,void * recvbuff,unsigned long sendcount,ncclDataType_t datatype,ncclComm_t comm,hipStream_t stream):
    global _pncclAllGather__funptr
    if __init_symbol(&_pncclAllGather__funptr,"pncclAllGather") > 0:
        pass
    return (<ncclResult_t (*)(const void *,void *,unsigned long,ncclDataType_t,ncclComm_t,hipStream_t) noexcept nogil> _pncclAllGather__funptr)(sendbuff,recvbuff,sendcount,datatype,comm,stream)


cdef void* _ncclSend__funptr = NULL
#  @brief Send
# 
# @details Send data from sendbuff to rank peer.
# Rank peer needs to call ncclRecv with the same datatype and the same count from this
# rank.
# 
# This operation is blocking for the GPU. If multiple ncclSend and ncclRecv operations
# need to progress concurrently to complete, they must be fused within a ncclGroupStart/
# ncclGroupEnd section.
cdef ncclResult_t ncclSend(const void * sendbuff,unsigned long count,ncclDataType_t datatype,int peer,ncclComm_t comm,hipStream_t stream):
    global _ncclSend__funptr
    if __init_symbol(&_ncclSend__funptr,"ncclSend") > 0:
        pass
    return (<ncclResult_t (*)(const void *,unsigned long,ncclDataType_t,int,ncclComm_t,hipStream_t) noexcept nogil> _ncclSend__funptr)(sendbuff,count,datatype,peer,comm,stream)


cdef void* _pncclSend__funptr = NULL
# @cond include_hidden
cdef ncclResult_t pncclSend(const void * sendbuff,unsigned long count,ncclDataType_t datatype,int peer,ncclComm_t comm,hipStream_t stream):
    global _pncclSend__funptr
    if __init_symbol(&_pncclSend__funptr,"pncclSend") > 0:
        pass
    return (<ncclResult_t (*)(const void *,unsigned long,ncclDataType_t,int,ncclComm_t,hipStream_t) noexcept nogil> _pncclSend__funptr)(sendbuff,count,datatype,peer,comm,stream)


cdef void* _ncclRecv__funptr = NULL
#  @brief Receive
# 
# @details Receive data from rank peer into recvbuff.
# Rank peer needs to call ncclSend with the same datatype and the same count to this
# rank.
# 
# This operation is blocking for the GPU. If multiple ncclSend and ncclRecv operations
# need to progress concurrently to complete, they must be fused within a ncclGroupStart/
# ncclGroupEnd section.
cdef ncclResult_t ncclRecv(void * recvbuff,unsigned long count,ncclDataType_t datatype,int peer,ncclComm_t comm,hipStream_t stream):
    global _ncclRecv__funptr
    if __init_symbol(&_ncclRecv__funptr,"ncclRecv") > 0:
        pass
    return (<ncclResult_t (*)(void *,unsigned long,ncclDataType_t,int,ncclComm_t,hipStream_t) noexcept nogil> _ncclRecv__funptr)(recvbuff,count,datatype,peer,comm,stream)


cdef void* _pncclRecv__funptr = NULL
# @cond include_hidden
cdef ncclResult_t pncclRecv(void * recvbuff,unsigned long count,ncclDataType_t datatype,int peer,ncclComm_t comm,hipStream_t stream):
    global _pncclRecv__funptr
    if __init_symbol(&_pncclRecv__funptr,"pncclRecv") > 0:
        pass
    return (<ncclResult_t (*)(void *,unsigned long,ncclDataType_t,int,ncclComm_t,hipStream_t) noexcept nogil> _pncclRecv__funptr)(recvbuff,count,datatype,peer,comm,stream)


cdef void* _ncclGather__funptr = NULL
#  @brief Gather
# 
# @details Root device gathers sendcount values from other GPUs into recvbuff,
# receiving data from rank i at offset i*sendcount.
# 
# Assumes recvcount is equal to nranks*sendcount, which means that recvbuff
# should have a size of at least nranks*sendcount elements.
# 
# In-place operations will happen if sendbuff == recvbuff + rank * sendcount.
cdef ncclResult_t ncclGather(const void * sendbuff,void * recvbuff,unsigned long sendcount,ncclDataType_t datatype,int root,ncclComm_t comm,hipStream_t stream):
    global _ncclGather__funptr
    if __init_symbol(&_ncclGather__funptr,"ncclGather") > 0:
        pass
    return (<ncclResult_t (*)(const void *,void *,unsigned long,ncclDataType_t,int,ncclComm_t,hipStream_t) noexcept nogil> _ncclGather__funptr)(sendbuff,recvbuff,sendcount,datatype,root,comm,stream)


cdef void* _pncclGather__funptr = NULL
# @cond include_hidden
cdef ncclResult_t pncclGather(const void * sendbuff,void * recvbuff,unsigned long sendcount,ncclDataType_t datatype,int root,ncclComm_t comm,hipStream_t stream):
    global _pncclGather__funptr
    if __init_symbol(&_pncclGather__funptr,"pncclGather") > 0:
        pass
    return (<ncclResult_t (*)(const void *,void *,unsigned long,ncclDataType_t,int,ncclComm_t,hipStream_t) noexcept nogil> _pncclGather__funptr)(sendbuff,recvbuff,sendcount,datatype,root,comm,stream)


cdef void* _ncclScatter__funptr = NULL
#  @brief Scatter
# 
# @details Scattered over the devices so that recvbuff on rank i will contain the i-th
# block of the data on root.
# 
# Assumes sendcount is equal to nranks*recvcount, which means that sendbuff
# should have a size of at least nranks*recvcount elements.
# 
# In-place operations will happen if recvbuff == sendbuff + rank * recvcount.
cdef ncclResult_t ncclScatter(const void * sendbuff,void * recvbuff,unsigned long recvcount,ncclDataType_t datatype,int root,ncclComm_t comm,hipStream_t stream):
    global _ncclScatter__funptr
    if __init_symbol(&_ncclScatter__funptr,"ncclScatter") > 0:
        pass
    return (<ncclResult_t (*)(const void *,void *,unsigned long,ncclDataType_t,int,ncclComm_t,hipStream_t) noexcept nogil> _ncclScatter__funptr)(sendbuff,recvbuff,recvcount,datatype,root,comm,stream)


cdef void* _pncclScatter__funptr = NULL
# @cond include_hidden
cdef ncclResult_t pncclScatter(const void * sendbuff,void * recvbuff,unsigned long recvcount,ncclDataType_t datatype,int root,ncclComm_t comm,hipStream_t stream):
    global _pncclScatter__funptr
    if __init_symbol(&_pncclScatter__funptr,"pncclScatter") > 0:
        pass
    return (<ncclResult_t (*)(const void *,void *,unsigned long,ncclDataType_t,int,ncclComm_t,hipStream_t) noexcept nogil> _pncclScatter__funptr)(sendbuff,recvbuff,recvcount,datatype,root,comm,stream)


cdef void* _ncclAllToAll__funptr = NULL
#  @brief All-To-All
# 
# @details Device (i) send (j)th block of data to device (j) and be placed as (i)th
# block. Each block for sending/receiving has count elements, which means
# that recvbuff and sendbuff should have a size of nranks*count elements.
# 
# In-place operation will happen if sendbuff == recvbuff.
cdef ncclResult_t ncclAllToAll(const void * sendbuff,void * recvbuff,unsigned long count,ncclDataType_t datatype,ncclComm_t comm,hipStream_t stream):
    global _ncclAllToAll__funptr
    if __init_symbol(&_ncclAllToAll__funptr,"ncclAllToAll") > 0:
        pass
    return (<ncclResult_t (*)(const void *,void *,unsigned long,ncclDataType_t,ncclComm_t,hipStream_t) noexcept nogil> _ncclAllToAll__funptr)(sendbuff,recvbuff,count,datatype,comm,stream)


cdef void* _pncclAllToAll__funptr = NULL
# @cond include_hidden
cdef ncclResult_t pncclAllToAll(const void * sendbuff,void * recvbuff,unsigned long count,ncclDataType_t datatype,ncclComm_t comm,hipStream_t stream):
    global _pncclAllToAll__funptr
    if __init_symbol(&_pncclAllToAll__funptr,"pncclAllToAll") > 0:
        pass
    return (<ncclResult_t (*)(const void *,void *,unsigned long,ncclDataType_t,ncclComm_t,hipStream_t) noexcept nogil> _pncclAllToAll__funptr)(sendbuff,recvbuff,count,datatype,comm,stream)


cdef void* _ncclAllToAllv__funptr = NULL
#  @brief All-To-Allv
# 
# @details Device (i) sends sendcounts[j] of data from offset sdispls[j]
# to device (j). In the same time, device (i) receives recvcounts[j] of data
# from device (j) to be placed at rdispls[j].
# 
# sendcounts, sdispls, recvcounts and rdispls are all measured in the units
# of datatype, not bytes.
# 
# In-place operation will happen if sendbuff == recvbuff.
cdef ncclResult_t ncclAllToAllv(const void * sendbuff,const unsigned long* sendcounts,const unsigned long* sdispls,void * recvbuff,const unsigned long* recvcounts,const unsigned long* rdispls,ncclDataType_t datatype,ncclComm_t comm,hipStream_t stream):
    global _ncclAllToAllv__funptr
    if __init_symbol(&_ncclAllToAllv__funptr,"ncclAllToAllv") > 0:
        pass
    return (<ncclResult_t (*)(const void *,const unsigned long*,const unsigned long*,void *,const unsigned long*,const unsigned long*,ncclDataType_t,ncclComm_t,hipStream_t) noexcept nogil> _ncclAllToAllv__funptr)(sendbuff,sendcounts,sdispls,recvbuff,recvcounts,rdispls,datatype,comm,stream)


cdef void* _pncclAllToAllv__funptr = NULL
# @cond include_hidden
cdef ncclResult_t pncclAllToAllv(const void * sendbuff,const unsigned long* sendcounts,const unsigned long* sdispls,void * recvbuff,const unsigned long* recvcounts,const unsigned long* rdispls,ncclDataType_t datatype,ncclComm_t comm,hipStream_t stream):
    global _pncclAllToAllv__funptr
    if __init_symbol(&_pncclAllToAllv__funptr,"pncclAllToAllv") > 0:
        pass
    return (<ncclResult_t (*)(const void *,const unsigned long*,const unsigned long*,void *,const unsigned long*,const unsigned long*,ncclDataType_t,ncclComm_t,hipStream_t) noexcept nogil> _pncclAllToAllv__funptr)(sendbuff,sendcounts,sdispls,recvbuff,recvcounts,rdispls,datatype,comm,stream)


cdef void* _ncclGroupStart__funptr = NULL
#  @brief Group Start
# 
# Start a group call. All calls to NCCL until ncclGroupEnd will be fused into
# a single NCCL operation. Nothing will be started on the CUDA stream until
# ncclGroupEnd.
cdef ncclResult_t ncclGroupStart():
    global _ncclGroupStart__funptr
    if __init_symbol(&_ncclGroupStart__funptr,"ncclGroupStart") > 0:
        pass
    return (<ncclResult_t (*)() noexcept nogil> _ncclGroupStart__funptr)()


cdef void* _pncclGroupStart__funptr = NULL
# @cond include_hidden
cdef ncclResult_t pncclGroupStart():
    global _pncclGroupStart__funptr
    if __init_symbol(&_pncclGroupStart__funptr,"pncclGroupStart") > 0:
        pass
    return (<ncclResult_t (*)() noexcept nogil> _pncclGroupStart__funptr)()


cdef void* _ncclGroupEnd__funptr = NULL
#  @brief Group End
# 
# End a group call. Start a fused NCCL operation consisting of all calls since
# ncclGroupStart. Operations on the CUDA stream depending on the NCCL operations
# need to be called after ncclGroupEnd.
cdef ncclResult_t ncclGroupEnd():
    global _ncclGroupEnd__funptr
    if __init_symbol(&_ncclGroupEnd__funptr,"ncclGroupEnd") > 0:
        pass
    return (<ncclResult_t (*)() noexcept nogil> _ncclGroupEnd__funptr)()


cdef void* _pncclGroupEnd__funptr = NULL
# @cond include_hidden
cdef ncclResult_t pncclGroupEnd():
    global _pncclGroupEnd__funptr
    if __init_symbol(&_pncclGroupEnd__funptr,"pncclGroupEnd") > 0:
        pass
    return (<ncclResult_t (*)() noexcept nogil> _pncclGroupEnd__funptr)()
