# MIT License
#
# Copyright (c) 2023-2024 Advanced Micro Devices, Inc.
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in all
# copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
# SOFTWARE.

# This file has been autogenerated, do not modify.


"""
(No short description)

Attributes:
    HIP_VERSION_MAJOR (`~.int`):
        Macro constant.

    HIP_VERSION_MINOR (`~.int`):
        Macro constant.

    HIP_VERSION_PATCH (`~.int`):
        Macro constant.

    HIP_VERSION_GITHASH (`~.bytes`):
        Macro constant.

    HIP_VERSION_BUILD_ID (`~.int`):
        Macro constant.

    HIP_VERSION_BUILD_NAME (`~.bytes`):
        Macro constant.

    HIP_VERSION (`~.int`):
        Macro constant.

    HIP_TRSA_OVERRIDE_FORMAT (`~.int`):
        Macro constant.

    HIP_TRSF_READ_AS_INTEGER (`~.int`):
        Macro constant.

    HIP_TRSF_NORMALIZED_COORDINATES (`~.int`):
        Macro constant.

    HIP_TRSF_SRGB (`~.int`):
        Macro constant.

    hipTextureType1D (`~.int`):
        Macro constant.

    hipTextureType2D (`~.int`):
        Macro constant.

    hipTextureType3D (`~.int`):
        Macro constant.

    hipTextureTypeCubemap (`~.int`):
        Macro constant.

    hipTextureType1DLayered (`~.int`):
        Macro constant.

    hipTextureType2DLayered (`~.int`):
        Macro constant.

    hipTextureTypeCubemapLayered (`~.int`):
        Macro constant.

    HIP_IMAGE_OBJECT_SIZE_DWORD (`~.int`):
        Macro constant.

    HIP_SAMPLER_OBJECT_SIZE_DWORD (`~.int`):
        Macro constant.

    HIP_SAMPLER_OBJECT_OFFSET_DWORD (`~.int`):
        Macro constant.

    HIP_TEXTURE_OBJECT_SIZE_DWORD (`~.int`):
        Macro constant.

    HIP_LAUNCH_PARAM_BUFFER_POINTER (`~.int`):
        Macro constant.

    HIP_LAUNCH_PARAM_BUFFER_SIZE (`~.int`):
        Macro constant.

    HIP_LAUNCH_PARAM_END (`~.int`):
        Macro constant.

    hipIpcMemLazyEnablePeerAccess (`~.int`):
        Macro constant.

    HIP_IPC_HANDLE_SIZE (`~.int`):
        Macro constant.

    hipStreamDefault (`~.int`):
        Macro constant.

    hipStreamNonBlocking (`~.int`):
        Macro constant.

    hipEventDefault (`~.int`):
        Macro constant.

    hipEventBlockingSync (`~.int`):
        Macro constant.

    hipEventDisableTiming (`~.int`):
        Macro constant.

    hipEventInterprocess (`~.int`):
        Macro constant.

    hipEventReleaseToDevice (`~.int`):
        Macro constant.

    hipEventReleaseToSystem (`~.int`):
        Macro constant.

    hipHostMallocDefault (`~.int`):
        Macro constant.

    hipHostMallocPortable (`~.int`):
        Macro constant.

    hipHostMallocMapped (`~.int`):
        Macro constant.

    hipHostMallocWriteCombined (`~.int`):
        Macro constant.

    hipHostMallocNumaUser (`~.int`):
        Macro constant.

    hipHostMallocCoherent (`~.int`):
        Macro constant.

    hipHostMallocNonCoherent (`~.int`):
        Macro constant.

    hipMemAttachGlobal (`~.int`):
        Macro constant.

    hipMemAttachHost (`~.int`):
        Macro constant.

    hipMemAttachSingle (`~.int`):
        Macro constant.

    hipDeviceMallocDefault (`~.int`):
        Macro constant.

    hipDeviceMallocFinegrained (`~.int`):
        Macro constant.

    hipMallocSignalMemory (`~.int`):
        Macro constant.

    hipHostRegisterDefault (`~.int`):
        Macro constant.

    hipHostRegisterPortable (`~.int`):
        Macro constant.

    hipHostRegisterMapped (`~.int`):
        Macro constant.

    hipHostRegisterIoMemory (`~.int`):
        Macro constant.

    hipExtHostRegisterCoarseGrained (`~.int`):
        Macro constant.

    hipDeviceScheduleAuto (`~.int`):
        Macro constant.

    hipDeviceScheduleSpin (`~.int`):
        Macro constant.

    hipDeviceScheduleYield (`~.int`):
        Macro constant.

    hipDeviceScheduleBlockingSync (`~.int`):
        Macro constant.

    hipDeviceScheduleMask (`~.int`):
        Macro constant.

    hipDeviceMapHost (`~.int`):
        Macro constant.

    hipDeviceLmemResizeToMax (`~.int`):
        Macro constant.

    hipArrayDefault (`~.int`):
        Macro constant.

    hipArrayLayered (`~.int`):
        Macro constant.

    hipArraySurfaceLoadStore (`~.int`):
        Macro constant.

    hipArrayCubemap (`~.int`):
        Macro constant.

    hipArrayTextureGather (`~.int`):
        Macro constant.

    hipOccupancyDefault (`~.int`):
        Macro constant.

    hipCooperativeLaunchMultiDeviceNoPreSync (`~.int`):
        Macro constant.

    hipCooperativeLaunchMultiDeviceNoPostSync (`~.int`):
        Macro constant.

    hipCpuDeviceId (`~.int`):
        Macro constant.

    hipInvalidDeviceId (`~.int`):
        Macro constant.

    hipExtAnyOrderLaunch (`~.int`):
        Macro constant.

    hipStreamWaitValueGte (`~.int`):
        Macro constant.

    hipStreamWaitValueEq (`~.int`):
        Macro constant.

    hipStreamWaitValueAnd (`~.int`):
        Macro constant.

    hipStreamWaitValueNor (`~.int`):
        Macro constant.

    HIP_SUCCESS:
        (undocumented)
    HIP_ERROR_INVALID_VALUE:
        (undocumented)
    HIP_ERROR_NOT_INITIALIZED:
        (undocumented)
    HIP_ERROR_LAUNCH_OUT_OF_RESOURCES:
        (undocumented)
    HIP_SUCCESS:
        (undocumented)
    HIP_ERROR_INVALID_VALUE:
        (undocumented)
    HIP_ERROR_NOT_INITIALIZED:
        (undocumented)
    HIP_ERROR_LAUNCH_OUT_OF_RESOURCES:
        (undocumented)
    HIP_SUCCESS:
        (undocumented)
    HIP_ERROR_INVALID_VALUE:
        (undocumented)
    HIP_ERROR_NOT_INITIALIZED:
        (undocumented)
    HIP_ERROR_LAUNCH_OUT_OF_RESOURCES:
        (undocumented)
    HIP_SUCCESS:
        (undocumented)
    HIP_ERROR_INVALID_VALUE:
        (undocumented)
    HIP_ERROR_NOT_INITIALIZED:
        (undocumented)
    HIP_ERROR_LAUNCH_OUT_OF_RESOURCES:
        (undocumented)
    hipUUID:
        alias of `~.hipUUID_t`

    hipArray_t:
        alias of `~.hipArray`

    hipArray_const_t:
        alias of `~.hipArray`

    hipMipmappedArray_t:
        alias of `~.hipMipmappedArray`

    hipMipmappedArray_const_t:
        alias of `~.hipMipmappedArray`

    HIPresourcetype:
        alias of `~.HIPresourcetype_enum`

    hipResourcetype:
        alias of `~.HIPresourcetype_enum`

    HIPaddress_mode:
        alias of `~.HIPaddress_mode_enum`

    HIPfilter_mode:
        alias of `~.HIPfilter_mode_enum`

    HIP_TEXTURE_DESC:
        alias of `~.HIP_TEXTURE_DESC_st`

    HIPresourceViewFormat:
        alias of `~.HIPresourceViewFormat_enum`

    HIP_RESOURCE_DESC:
        alias of `~.HIP_RESOURCE_DESC_st`

    HIP_RESOURCE_VIEW_DESC:
        alias of `~.HIP_RESOURCE_VIEW_DESC_st`

    hipTextureObject_t:
        alias of `~.__hip_texture`

    hipSurfaceObject_t:
        alias of `~.__hip_surface`

    hipCtx_t:
        alias of `~.ihipCtx_t`

    hipStream_t:
        alias of `~.ihipStream_t`

    hipIpcMemHandle_t:
        alias of `~.hipIpcMemHandle_st`

    hipIpcEventHandle_t:
        alias of `~.hipIpcEventHandle_st`

    hipModule_t:
        alias of `~.ihipModule_t`

    hipFunction_t:
        alias of `~.ihipModuleSymbol_t`

    hipMemPool_t:
        alias of `~.ihipMemPoolHandle_t`

    hipEvent_t:
        alias of `~.ihipEvent_t`

    hipLaunchParams:
        alias of `~.hipLaunchParams_t`

    hipFunctionLaunchParams:
        alias of `~.hipFunctionLaunchParams_t`

    hipExternalMemoryHandleType:
        alias of `~.hipExternalMemoryHandleType_enum`

    hipExternalMemoryHandleDesc:
        alias of `~.hipExternalMemoryHandleDesc_st`

    hipExternalMemoryBufferDesc:
        alias of `~.hipExternalMemoryBufferDesc_st`

    hipExternalMemoryMipmappedArrayDesc:
        alias of `~.hipExternalMemoryMipmappedArrayDesc_st`

    hipExternalSemaphoreHandleType:
        alias of `~.hipExternalSemaphoreHandleType_enum`

    hipExternalSemaphoreHandleDesc:
        alias of `~.hipExternalSemaphoreHandleDesc_st`

    hipExternalSemaphoreSignalParams:
        alias of `~.hipExternalSemaphoreSignalParams_st`

    hipExternalSemaphoreWaitParams:
        alias of `~.hipExternalSemaphoreWaitParams_st`

    hipGraphicsResource:
        alias of `~._hipGraphicsResource`

    hipGraphicsResource_t:
        alias of `~._hipGraphicsResource`

    hipGraph_t:
        alias of `~.ihipGraph`

    hipGraphNode_t:
        alias of `~.hipGraphNode`

    hipGraphExec_t:
        alias of `~.hipGraphExec`

    hipUserObject_t:
        alias of `~.hipUserObject`

    hipMemGenericAllocationHandle_t:
        alias of `~.ihipMemGenericAllocationHandle`

"""

import cython
import ctypes
import enum
cimport hip._hip_helpers
HIP_VERSION_MAJOR = chip.HIP_VERSION_MAJOR

HIP_VERSION_MINOR = chip.HIP_VERSION_MINOR

HIP_VERSION_PATCH = chip.HIP_VERSION_PATCH

HIP_VERSION_GITHASH = chip.HIP_VERSION_GITHASH

HIP_VERSION_BUILD_ID = chip.HIP_VERSION_BUILD_ID

HIP_VERSION_BUILD_NAME = chip.HIP_VERSION_BUILD_NAME

HIP_VERSION = chip.HIP_VERSION

HIP_TRSA_OVERRIDE_FORMAT = chip.HIP_TRSA_OVERRIDE_FORMAT

HIP_TRSF_READ_AS_INTEGER = chip.HIP_TRSF_READ_AS_INTEGER

HIP_TRSF_NORMALIZED_COORDINATES = chip.HIP_TRSF_NORMALIZED_COORDINATES

HIP_TRSF_SRGB = chip.HIP_TRSF_SRGB

hipTextureType1D = chip.hipTextureType1D

hipTextureType2D = chip.hipTextureType2D

hipTextureType3D = chip.hipTextureType3D

hipTextureTypeCubemap = chip.hipTextureTypeCubemap

hipTextureType1DLayered = chip.hipTextureType1DLayered

hipTextureType2DLayered = chip.hipTextureType2DLayered

hipTextureTypeCubemapLayered = chip.hipTextureTypeCubemapLayered

HIP_IMAGE_OBJECT_SIZE_DWORD = chip.HIP_IMAGE_OBJECT_SIZE_DWORD

HIP_SAMPLER_OBJECT_SIZE_DWORD = chip.HIP_SAMPLER_OBJECT_SIZE_DWORD

HIP_SAMPLER_OBJECT_OFFSET_DWORD = chip.HIP_SAMPLER_OBJECT_OFFSET_DWORD

HIP_TEXTURE_OBJECT_SIZE_DWORD = chip.HIP_TEXTURE_OBJECT_SIZE_DWORD

HIP_LAUNCH_PARAM_BUFFER_POINTER = chip.HIP_LAUNCH_PARAM_BUFFER_POINTER

HIP_LAUNCH_PARAM_BUFFER_SIZE = chip.HIP_LAUNCH_PARAM_BUFFER_SIZE

HIP_LAUNCH_PARAM_END = chip.HIP_LAUNCH_PARAM_END

hipIpcMemLazyEnablePeerAccess = chip.hipIpcMemLazyEnablePeerAccess

HIP_IPC_HANDLE_SIZE = chip.HIP_IPC_HANDLE_SIZE

hipStreamDefault = chip.hipStreamDefault

hipStreamNonBlocking = chip.hipStreamNonBlocking

hipEventDefault = chip.hipEventDefault

hipEventBlockingSync = chip.hipEventBlockingSync

hipEventDisableTiming = chip.hipEventDisableTiming

hipEventInterprocess = chip.hipEventInterprocess

hipEventReleaseToDevice = chip.hipEventReleaseToDevice

hipEventReleaseToSystem = chip.hipEventReleaseToSystem

hipHostMallocDefault = chip.hipHostMallocDefault

hipHostMallocPortable = chip.hipHostMallocPortable

hipHostMallocMapped = chip.hipHostMallocMapped

hipHostMallocWriteCombined = chip.hipHostMallocWriteCombined

hipHostMallocNumaUser = chip.hipHostMallocNumaUser

hipHostMallocCoherent = chip.hipHostMallocCoherent

hipHostMallocNonCoherent = chip.hipHostMallocNonCoherent

hipMemAttachGlobal = chip.hipMemAttachGlobal

hipMemAttachHost = chip.hipMemAttachHost

hipMemAttachSingle = chip.hipMemAttachSingle

hipDeviceMallocDefault = chip.hipDeviceMallocDefault

hipDeviceMallocFinegrained = chip.hipDeviceMallocFinegrained

hipMallocSignalMemory = chip.hipMallocSignalMemory

hipHostRegisterDefault = chip.hipHostRegisterDefault

hipHostRegisterPortable = chip.hipHostRegisterPortable

hipHostRegisterMapped = chip.hipHostRegisterMapped

hipHostRegisterIoMemory = chip.hipHostRegisterIoMemory

hipExtHostRegisterCoarseGrained = chip.hipExtHostRegisterCoarseGrained

hipDeviceScheduleAuto = chip.hipDeviceScheduleAuto

hipDeviceScheduleSpin = chip.hipDeviceScheduleSpin

hipDeviceScheduleYield = chip.hipDeviceScheduleYield

hipDeviceScheduleBlockingSync = chip.hipDeviceScheduleBlockingSync

hipDeviceScheduleMask = chip.hipDeviceScheduleMask

hipDeviceMapHost = chip.hipDeviceMapHost

hipDeviceLmemResizeToMax = chip.hipDeviceLmemResizeToMax

hipArrayDefault = chip.hipArrayDefault

hipArrayLayered = chip.hipArrayLayered

hipArraySurfaceLoadStore = chip.hipArraySurfaceLoadStore

hipArrayCubemap = chip.hipArrayCubemap

hipArrayTextureGather = chip.hipArrayTextureGather

hipOccupancyDefault = chip.hipOccupancyDefault

hipCooperativeLaunchMultiDeviceNoPreSync = chip.hipCooperativeLaunchMultiDeviceNoPreSync

hipCooperativeLaunchMultiDeviceNoPostSync = chip.hipCooperativeLaunchMultiDeviceNoPostSync

hipCpuDeviceId = chip.hipCpuDeviceId

hipInvalidDeviceId = chip.hipInvalidDeviceId

hipExtAnyOrderLaunch = chip.hipExtAnyOrderLaunch

hipStreamWaitValueGte = chip.hipStreamWaitValueGte

hipStreamWaitValueEq = chip.hipStreamWaitValueEq

hipStreamWaitValueAnd = chip.hipStreamWaitValueAnd

hipStreamWaitValueNor = chip.hipStreamWaitValueNor

HIP_SUCCESS = chip.HIP_SUCCESS
HIP_ERROR_INVALID_VALUE = chip.HIP_ERROR_INVALID_VALUE
HIP_ERROR_NOT_INITIALIZED = chip.HIP_ERROR_NOT_INITIALIZED
HIP_ERROR_LAUNCH_OUT_OF_RESOURCES = chip.HIP_ERROR_LAUNCH_OUT_OF_RESOURCES

cdef class hipDeviceArch_t(hip._util.types.Pointer):
    """Python wrapper for cdef class chip.hipDeviceArch_t.

    Python wrapper for cdef class chip.hipDeviceArch_t.

    If this type is initialized via its `__init__` method, it allocates a
    member of the underlying C type and destroys it again if the wrapper
    type is deallocated.

    This type also serves as adapter when appearing as argument type in a
    function signature. In this case, the type can further be initialized
    from a number of Python objects:

    * `None`:

      This will set the ``self._ptr`` attribute to ``NULL``.

    * `int`:

      Interprets the integer value as pointer address and writes it to ``self._ptr``.
      No ownership is transferred.

    * `ctypes.c_void_p`:

      Takes the pointer address ``pyobj.value`` and writes it to ``self._ptr``.
      No ownership is transferred.

    * `object` that implements the `CUDA Array Interface <https://numba.readthedocs.io/en/stable/cuda/cuda_array_interface.html>`_ protocol:

      Takes the integer-valued pointer address, i.e. the first entry of the `data` tuple
      from `pyobj`'s member ``__cuda_array_interface__``  and writes it to ``self._ptr``.

    * `object` that implements the Python buffer protocol:

      If the object represents a simple contiguous array,
      writes the `Py_buffer` associated with ``pyobj`` to `self._py_buffer`,
      sets the `self._py_buffer_acquired` flag to `True`, and
      writes `self._py_buffer.buf` to the data pointer `self._ptr`.

    * `hip._util.types.Pointer`:

      Takes the pointer address ``pyobj._ptr`` and writes it to ``self._ptr``.
      No ownership is transferred.

    Type checks are performed in the above order.

    C Attributes:
        _ptr (C type ``void *``, protected):
            Stores a pointer to the data of the original Python object.
        _is_ptr_owner (C type ``bint``, protected):
            If this wrapper is the owner of the underlying data.
        _py_buffer (C type ``Py_buffer`, protected):
            Stores a pointer to the data of the original Python object.
        _py_buffer_acquired (C type ``bint``, protected):
            Stores a pointer to the data of the original Python object.
    """
    # C members declared in pxd file

    def __cinit__(self):
        self._ptr = NULL
        self._is_ptr_owner = False
        self._py_buffer_acquired = False

    cdef chip.hipDeviceArch_t* getElementPtr(self):
        return <chip.hipDeviceArch_t*>self._ptr

    @staticmethod
    cdef hipDeviceArch_t fromPtr(void* ptr, bint owner=False):
        """Factory function to create ``hipDeviceArch_t`` objects from
        given ``chip.hipDeviceArch_t`` pointer.

        Setting ``owner`` flag to ``True`` causes
        the extension type to free the structure pointed to by ``ptr``
        when the wrapper object is deallocated.
        """
        # Fast call to __new__() that bypasses the __init__() constructor.
        cdef hipDeviceArch_t wrapper = hipDeviceArch_t.__new__(hipDeviceArch_t)
        wrapper._ptr = ptr
        wrapper._is_ptr_owner = owner
        return wrapper

    @staticmethod
    def fromObj(pyobj):
        """Creates a hipDeviceArch_t from a Python object.

        Derives a hipDeviceArch_t from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``hipDeviceArch_t`` reference, this method
        returns it directly. No new ``hipDeviceArch_t`` is created in this case.
        """
        return hipDeviceArch_t.fromPyobj(pyobj)

    @staticmethod
    cdef hipDeviceArch_t fromPyobj(object pyobj):
        """Creates a hipDeviceArch_t from a Python object.

        Derives a hipDeviceArch_t from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``hipDeviceArch_t`` reference, this method
        returns it directly. No new ``hipDeviceArch_t`` is created in this case.

        Args:
            pyobj (object): Must be either `None`; a `hip._util.types.Pointer`; a simple, contiguous buffer according to the buffer protocol;
                            or of type `hipDeviceArch_t`; `int`; or `ctypes.c_void_p`.

        Note:
            This routine does not perform a copy but returns the original ``pyobj``
            if ``pyobj`` is an instance of hipDeviceArch_t!
        """
        cdef hipDeviceArch_t wrapper

        if isinstance(pyobj,hipDeviceArch_t):
            return pyobj
        else:
            wrapper = hipDeviceArch_t.__new__(hipDeviceArch_t)
            wrapper.init_from_pyobj(pyobj)
            return wrapper

    def __dealloc__(self):
        # Release the buffer handle
        if self._py_buffer_acquired is True:
            cpython.buffer.PyBuffer_Release(&self._py_buffer)
        # De-allocate if not null and flag is set
        if self._ptr is not NULL and self._is_ptr_owner is True:
            stdlib.free(self._ptr)
            self._ptr = NULL

    @staticmethod
    cdef __allocate(void** ptr):
        ptr[0] = stdlib.malloc(sizeof(chip.hipDeviceArch_t))
        string.memset(<void*>ptr[0], 0, sizeof(chip.hipDeviceArch_t))

        if ptr[0] is NULL:
            raise MemoryError

    @staticmethod
    cdef hipDeviceArch_t new():
        """Factory function to create hipDeviceArch_t objects with
        newly allocated chip.hipDeviceArch_t"""
        cdef void* ptr
        hipDeviceArch_t.__allocate(&ptr)
        return hipDeviceArch_t.fromPtr(ptr, owner=True)

    @staticmethod
    cdef hipDeviceArch_t fromValue(chip.hipDeviceArch_t other):
        """Allocate new C type and copy from ``other``.
        """
        wrapper = hipDeviceArch_t.new()
        string.memcpy(wrapper._ptr, &other, sizeof(chip.hipDeviceArch_t))
        return wrapper

    def c_sizeof(self):
        """Returns the size of the underlying C type in bytes.
        Note:
            Implemented as function to not collide with
            autogenerated property names.
        """
        return sizeof(chip.hipDeviceArch_t)

    def __int__(self):
        """Returns the data's address as long integer.
        """
        return cpython.long.PyLong_FromVoidPtr(self._ptr)

    def __repr__(self):
        return f"<hipDeviceArch_t object, ptr: {int(self)}>"

    def as_c_void_p(self):
        """Returns the data's address as `ctypes.c_void_p`
        Note:
            Implemented as function to not collide with
            autogenerated property names.
        """
        return ctypes.c_void_p(int(self))

    def __init__(self,*args,**kwargs):
        """Constructor type hipDeviceArch_t.

        Constructor for type hipDeviceArch_t.

        Args:
            *args:
                Positional arguments. Initialize all or a subset of the member variables
                according to their order of declaration.
            **kwargs:
                Can be used to initialize member variables at construction,
                Just pass an argument expression of the form <member>=<value>
                per member that you want to initialize.
        """
        hipDeviceArch_t.__allocate(&self._ptr)
        self._is_ptr_owner = True
        attribs = self.PROPERTIES()
        used_attribs = set()
        if len(args) > len(attribs):
            raise ValueError("More positional arguments specified than this type has properties.")
        for i,v in enumerate(args):
            setattr(self,attribs[i],v)
            used_attribs.add(attribs[i])
        valid_names = ", ".join(["'"+p+"'" for p in attribs])
        for k,v in kwargs.items():
            if k in used_attribs:
                raise KeyError(f"argument '{k}' has already been specified as positional argument.")
            elif k not in attribs:
                raise KeyError(f"'{k}' is no valid property name. Valid names: {valid_names}")
            setattr(self,k,v)
    def get_hasGlobalInt32Atomics(self, i):
        """Get value ``hasGlobalInt32Atomics`` of ``(<chip.hipDeviceArch_t*>self._ptr)[i]``.
        """
        return (<chip.hipDeviceArch_t*>self._ptr)[i].hasGlobalInt32Atomics
    def set_hasGlobalInt32Atomics(self, i, unsigned int value):
        """Set value ``hasGlobalInt32Atomics`` of ``(<chip.hipDeviceArch_t*>self._ptr)[i]``.
        """
        (<chip.hipDeviceArch_t*>self._ptr)[i].hasGlobalInt32Atomics = value
    @property
    def hasGlobalInt32Atomics(self):
        """32-bit integer atomics for global memory."""
        return self.get_hasGlobalInt32Atomics(0)
    @hasGlobalInt32Atomics.setter
    def hasGlobalInt32Atomics(self, unsigned int value):
        self.set_hasGlobalInt32Atomics(0,value)

    def get_hasGlobalFloatAtomicExch(self, i):
        """Get value ``hasGlobalFloatAtomicExch`` of ``(<chip.hipDeviceArch_t*>self._ptr)[i]``.
        """
        return (<chip.hipDeviceArch_t*>self._ptr)[i].hasGlobalFloatAtomicExch
    def set_hasGlobalFloatAtomicExch(self, i, unsigned int value):
        """Set value ``hasGlobalFloatAtomicExch`` of ``(<chip.hipDeviceArch_t*>self._ptr)[i]``.
        """
        (<chip.hipDeviceArch_t*>self._ptr)[i].hasGlobalFloatAtomicExch = value
    @property
    def hasGlobalFloatAtomicExch(self):
        """32-bit float atomic exch for global memory."""
        return self.get_hasGlobalFloatAtomicExch(0)
    @hasGlobalFloatAtomicExch.setter
    def hasGlobalFloatAtomicExch(self, unsigned int value):
        self.set_hasGlobalFloatAtomicExch(0,value)

    def get_hasSharedInt32Atomics(self, i):
        """Get value ``hasSharedInt32Atomics`` of ``(<chip.hipDeviceArch_t*>self._ptr)[i]``.
        """
        return (<chip.hipDeviceArch_t*>self._ptr)[i].hasSharedInt32Atomics
    def set_hasSharedInt32Atomics(self, i, unsigned int value):
        """Set value ``hasSharedInt32Atomics`` of ``(<chip.hipDeviceArch_t*>self._ptr)[i]``.
        """
        (<chip.hipDeviceArch_t*>self._ptr)[i].hasSharedInt32Atomics = value
    @property
    def hasSharedInt32Atomics(self):
        """32-bit integer atomics for shared memory."""
        return self.get_hasSharedInt32Atomics(0)
    @hasSharedInt32Atomics.setter
    def hasSharedInt32Atomics(self, unsigned int value):
        self.set_hasSharedInt32Atomics(0,value)

    def get_hasSharedFloatAtomicExch(self, i):
        """Get value ``hasSharedFloatAtomicExch`` of ``(<chip.hipDeviceArch_t*>self._ptr)[i]``.
        """
        return (<chip.hipDeviceArch_t*>self._ptr)[i].hasSharedFloatAtomicExch
    def set_hasSharedFloatAtomicExch(self, i, unsigned int value):
        """Set value ``hasSharedFloatAtomicExch`` of ``(<chip.hipDeviceArch_t*>self._ptr)[i]``.
        """
        (<chip.hipDeviceArch_t*>self._ptr)[i].hasSharedFloatAtomicExch = value
    @property
    def hasSharedFloatAtomicExch(self):
        """32-bit float atomic exch for shared memory."""
        return self.get_hasSharedFloatAtomicExch(0)
    @hasSharedFloatAtomicExch.setter
    def hasSharedFloatAtomicExch(self, unsigned int value):
        self.set_hasSharedFloatAtomicExch(0,value)

    def get_hasFloatAtomicAdd(self, i):
        """Get value ``hasFloatAtomicAdd`` of ``(<chip.hipDeviceArch_t*>self._ptr)[i]``.
        """
        return (<chip.hipDeviceArch_t*>self._ptr)[i].hasFloatAtomicAdd
    def set_hasFloatAtomicAdd(self, i, unsigned int value):
        """Set value ``hasFloatAtomicAdd`` of ``(<chip.hipDeviceArch_t*>self._ptr)[i]``.
        """
        (<chip.hipDeviceArch_t*>self._ptr)[i].hasFloatAtomicAdd = value
    @property
    def hasFloatAtomicAdd(self):
        """32-bit float atomic add in global and shared memory."""
        return self.get_hasFloatAtomicAdd(0)
    @hasFloatAtomicAdd.setter
    def hasFloatAtomicAdd(self, unsigned int value):
        self.set_hasFloatAtomicAdd(0,value)

    def get_hasGlobalInt64Atomics(self, i):
        """Get value ``hasGlobalInt64Atomics`` of ``(<chip.hipDeviceArch_t*>self._ptr)[i]``.
        """
        return (<chip.hipDeviceArch_t*>self._ptr)[i].hasGlobalInt64Atomics
    def set_hasGlobalInt64Atomics(self, i, unsigned int value):
        """Set value ``hasGlobalInt64Atomics`` of ``(<chip.hipDeviceArch_t*>self._ptr)[i]``.
        """
        (<chip.hipDeviceArch_t*>self._ptr)[i].hasGlobalInt64Atomics = value
    @property
    def hasGlobalInt64Atomics(self):
        """64-bit integer atomics for global memory."""
        return self.get_hasGlobalInt64Atomics(0)
    @hasGlobalInt64Atomics.setter
    def hasGlobalInt64Atomics(self, unsigned int value):
        self.set_hasGlobalInt64Atomics(0,value)

    def get_hasSharedInt64Atomics(self, i):
        """Get value ``hasSharedInt64Atomics`` of ``(<chip.hipDeviceArch_t*>self._ptr)[i]``.
        """
        return (<chip.hipDeviceArch_t*>self._ptr)[i].hasSharedInt64Atomics
    def set_hasSharedInt64Atomics(self, i, unsigned int value):
        """Set value ``hasSharedInt64Atomics`` of ``(<chip.hipDeviceArch_t*>self._ptr)[i]``.
        """
        (<chip.hipDeviceArch_t*>self._ptr)[i].hasSharedInt64Atomics = value
    @property
    def hasSharedInt64Atomics(self):
        """64-bit integer atomics for shared memory."""
        return self.get_hasSharedInt64Atomics(0)
    @hasSharedInt64Atomics.setter
    def hasSharedInt64Atomics(self, unsigned int value):
        self.set_hasSharedInt64Atomics(0,value)

    def get_hasDoubles(self, i):
        """Get value ``hasDoubles`` of ``(<chip.hipDeviceArch_t*>self._ptr)[i]``.
        """
        return (<chip.hipDeviceArch_t*>self._ptr)[i].hasDoubles
    def set_hasDoubles(self, i, unsigned int value):
        """Set value ``hasDoubles`` of ``(<chip.hipDeviceArch_t*>self._ptr)[i]``.
        """
        (<chip.hipDeviceArch_t*>self._ptr)[i].hasDoubles = value
    @property
    def hasDoubles(self):
        """Double-precision floating point."""
        return self.get_hasDoubles(0)
    @hasDoubles.setter
    def hasDoubles(self, unsigned int value):
        self.set_hasDoubles(0,value)

    def get_hasWarpVote(self, i):
        """Get value ``hasWarpVote`` of ``(<chip.hipDeviceArch_t*>self._ptr)[i]``.
        """
        return (<chip.hipDeviceArch_t*>self._ptr)[i].hasWarpVote
    def set_hasWarpVote(self, i, unsigned int value):
        """Set value ``hasWarpVote`` of ``(<chip.hipDeviceArch_t*>self._ptr)[i]``.
        """
        (<chip.hipDeviceArch_t*>self._ptr)[i].hasWarpVote = value
    @property
    def hasWarpVote(self):
        """Warp vote instructions (__any, __all)."""
        return self.get_hasWarpVote(0)
    @hasWarpVote.setter
    def hasWarpVote(self, unsigned int value):
        self.set_hasWarpVote(0,value)

    def get_hasWarpBallot(self, i):
        """Get value ``hasWarpBallot`` of ``(<chip.hipDeviceArch_t*>self._ptr)[i]``.
        """
        return (<chip.hipDeviceArch_t*>self._ptr)[i].hasWarpBallot
    def set_hasWarpBallot(self, i, unsigned int value):
        """Set value ``hasWarpBallot`` of ``(<chip.hipDeviceArch_t*>self._ptr)[i]``.
        """
        (<chip.hipDeviceArch_t*>self._ptr)[i].hasWarpBallot = value
    @property
    def hasWarpBallot(self):
        """Warp ballot instructions (__ballot)."""
        return self.get_hasWarpBallot(0)
    @hasWarpBallot.setter
    def hasWarpBallot(self, unsigned int value):
        self.set_hasWarpBallot(0,value)

    def get_hasWarpShuffle(self, i):
        """Get value ``hasWarpShuffle`` of ``(<chip.hipDeviceArch_t*>self._ptr)[i]``.
        """
        return (<chip.hipDeviceArch_t*>self._ptr)[i].hasWarpShuffle
    def set_hasWarpShuffle(self, i, unsigned int value):
        """Set value ``hasWarpShuffle`` of ``(<chip.hipDeviceArch_t*>self._ptr)[i]``.
        """
        (<chip.hipDeviceArch_t*>self._ptr)[i].hasWarpShuffle = value
    @property
    def hasWarpShuffle(self):
        """Warp shuffle operations. (__shfl_*)."""
        return self.get_hasWarpShuffle(0)
    @hasWarpShuffle.setter
    def hasWarpShuffle(self, unsigned int value):
        self.set_hasWarpShuffle(0,value)

    def get_hasFunnelShift(self, i):
        """Get value ``hasFunnelShift`` of ``(<chip.hipDeviceArch_t*>self._ptr)[i]``.
        """
        return (<chip.hipDeviceArch_t*>self._ptr)[i].hasFunnelShift
    def set_hasFunnelShift(self, i, unsigned int value):
        """Set value ``hasFunnelShift`` of ``(<chip.hipDeviceArch_t*>self._ptr)[i]``.
        """
        (<chip.hipDeviceArch_t*>self._ptr)[i].hasFunnelShift = value
    @property
    def hasFunnelShift(self):
        """Funnel two words into one with shift&mask caps."""
        return self.get_hasFunnelShift(0)
    @hasFunnelShift.setter
    def hasFunnelShift(self, unsigned int value):
        self.set_hasFunnelShift(0,value)

    def get_hasThreadFenceSystem(self, i):
        """Get value ``hasThreadFenceSystem`` of ``(<chip.hipDeviceArch_t*>self._ptr)[i]``.
        """
        return (<chip.hipDeviceArch_t*>self._ptr)[i].hasThreadFenceSystem
    def set_hasThreadFenceSystem(self, i, unsigned int value):
        """Set value ``hasThreadFenceSystem`` of ``(<chip.hipDeviceArch_t*>self._ptr)[i]``.
        """
        (<chip.hipDeviceArch_t*>self._ptr)[i].hasThreadFenceSystem = value
    @property
    def hasThreadFenceSystem(self):
        """__threadfence_system."""
        return self.get_hasThreadFenceSystem(0)
    @hasThreadFenceSystem.setter
    def hasThreadFenceSystem(self, unsigned int value):
        self.set_hasThreadFenceSystem(0,value)

    def get_hasSyncThreadsExt(self, i):
        """Get value ``hasSyncThreadsExt`` of ``(<chip.hipDeviceArch_t*>self._ptr)[i]``.
        """
        return (<chip.hipDeviceArch_t*>self._ptr)[i].hasSyncThreadsExt
    def set_hasSyncThreadsExt(self, i, unsigned int value):
        """Set value ``hasSyncThreadsExt`` of ``(<chip.hipDeviceArch_t*>self._ptr)[i]``.
        """
        (<chip.hipDeviceArch_t*>self._ptr)[i].hasSyncThreadsExt = value
    @property
    def hasSyncThreadsExt(self):
        """__syncthreads_count, syncthreads_and, syncthreads_or."""
        return self.get_hasSyncThreadsExt(0)
    @hasSyncThreadsExt.setter
    def hasSyncThreadsExt(self, unsigned int value):
        self.set_hasSyncThreadsExt(0,value)

    def get_hasSurfaceFuncs(self, i):
        """Get value ``hasSurfaceFuncs`` of ``(<chip.hipDeviceArch_t*>self._ptr)[i]``.
        """
        return (<chip.hipDeviceArch_t*>self._ptr)[i].hasSurfaceFuncs
    def set_hasSurfaceFuncs(self, i, unsigned int value):
        """Set value ``hasSurfaceFuncs`` of ``(<chip.hipDeviceArch_t*>self._ptr)[i]``.
        """
        (<chip.hipDeviceArch_t*>self._ptr)[i].hasSurfaceFuncs = value
    @property
    def hasSurfaceFuncs(self):
        """Surface functions."""
        return self.get_hasSurfaceFuncs(0)
    @hasSurfaceFuncs.setter
    def hasSurfaceFuncs(self, unsigned int value):
        self.set_hasSurfaceFuncs(0,value)

    def get_has3dGrid(self, i):
        """Get value ``has3dGrid`` of ``(<chip.hipDeviceArch_t*>self._ptr)[i]``.
        """
        return (<chip.hipDeviceArch_t*>self._ptr)[i].has3dGrid
    def set_has3dGrid(self, i, unsigned int value):
        """Set value ``has3dGrid`` of ``(<chip.hipDeviceArch_t*>self._ptr)[i]``.
        """
        (<chip.hipDeviceArch_t*>self._ptr)[i].has3dGrid = value
    @property
    def has3dGrid(self):
        """Grid and group dims are 3D (rather than 2D)."""
        return self.get_has3dGrid(0)
    @has3dGrid.setter
    def has3dGrid(self, unsigned int value):
        self.set_has3dGrid(0,value)

    def get_hasDynamicParallelism(self, i):
        """Get value ``hasDynamicParallelism`` of ``(<chip.hipDeviceArch_t*>self._ptr)[i]``.
        """
        return (<chip.hipDeviceArch_t*>self._ptr)[i].hasDynamicParallelism
    def set_hasDynamicParallelism(self, i, unsigned int value):
        """Set value ``hasDynamicParallelism`` of ``(<chip.hipDeviceArch_t*>self._ptr)[i]``.
        """
        (<chip.hipDeviceArch_t*>self._ptr)[i].hasDynamicParallelism = value
    @property
    def hasDynamicParallelism(self):
        """Dynamic parallelism."""
        return self.get_hasDynamicParallelism(0)
    @hasDynamicParallelism.setter
    def hasDynamicParallelism(self, unsigned int value):
        self.set_hasDynamicParallelism(0,value)

    @staticmethod
    def PROPERTIES():
        return ["hasGlobalInt32Atomics","hasGlobalFloatAtomicExch","hasSharedInt32Atomics","hasSharedFloatAtomicExch","hasFloatAtomicAdd","hasGlobalInt64Atomics","hasSharedInt64Atomics","hasDoubles","hasWarpVote","hasWarpBallot","hasWarpShuffle","hasFunnelShift","hasThreadFenceSystem","hasSyncThreadsExt","hasSurfaceFuncs","has3dGrid","hasDynamicParallelism"]

    def __contains__(self,item):
        properties = self.PROPERTIES()
        return item in properties

    def __getitem__(self,item):
        properties = self.PROPERTIES()
        if isinstance(item,int):
            if item < 0 or item >= len(properties):
                raise IndexError()
            return getattr(self,properties[item])
        raise ValueError("'item' type must be 'int'")


cdef class hipUUID_t(hip._util.types.Pointer):
    """Python wrapper for cdef class chip.hipUUID_t.

    Python wrapper for cdef class chip.hipUUID_t.

    If this type is initialized via its `__init__` method, it allocates a
    member of the underlying C type and destroys it again if the wrapper
    type is deallocated.

    This type also serves as adapter when appearing as argument type in a
    function signature. In this case, the type can further be initialized
    from a number of Python objects:

    * `None`:

      This will set the ``self._ptr`` attribute to ``NULL``.

    * `int`:

      Interprets the integer value as pointer address and writes it to ``self._ptr``.
      No ownership is transferred.

    * `ctypes.c_void_p`:

      Takes the pointer address ``pyobj.value`` and writes it to ``self._ptr``.
      No ownership is transferred.

    * `object` that implements the `CUDA Array Interface <https://numba.readthedocs.io/en/stable/cuda/cuda_array_interface.html>`_ protocol:

      Takes the integer-valued pointer address, i.e. the first entry of the `data` tuple
      from `pyobj`'s member ``__cuda_array_interface__``  and writes it to ``self._ptr``.

    * `object` that implements the Python buffer protocol:

      If the object represents a simple contiguous array,
      writes the `Py_buffer` associated with ``pyobj`` to `self._py_buffer`,
      sets the `self._py_buffer_acquired` flag to `True`, and
      writes `self._py_buffer.buf` to the data pointer `self._ptr`.

    * `hip._util.types.Pointer`:

      Takes the pointer address ``pyobj._ptr`` and writes it to ``self._ptr``.
      No ownership is transferred.

    Type checks are performed in the above order.

    C Attributes:
        _ptr (C type ``void *``, protected):
            Stores a pointer to the data of the original Python object.
        _is_ptr_owner (C type ``bint``, protected):
            If this wrapper is the owner of the underlying data.
        _py_buffer (C type ``Py_buffer`, protected):
            Stores a pointer to the data of the original Python object.
        _py_buffer_acquired (C type ``bint``, protected):
            Stores a pointer to the data of the original Python object.
    """
    # C members declared in pxd file

    def __cinit__(self):
        self._ptr = NULL
        self._is_ptr_owner = False
        self._py_buffer_acquired = False

    cdef chip.hipUUID_t* getElementPtr(self):
        return <chip.hipUUID_t*>self._ptr

    @staticmethod
    cdef hipUUID_t fromPtr(void* ptr, bint owner=False):
        """Factory function to create ``hipUUID_t`` objects from
        given ``chip.hipUUID_t`` pointer.

        Setting ``owner`` flag to ``True`` causes
        the extension type to free the structure pointed to by ``ptr``
        when the wrapper object is deallocated.
        """
        # Fast call to __new__() that bypasses the __init__() constructor.
        cdef hipUUID_t wrapper = hipUUID_t.__new__(hipUUID_t)
        wrapper._ptr = ptr
        wrapper._is_ptr_owner = owner
        return wrapper

    @staticmethod
    def fromObj(pyobj):
        """Creates a hipUUID_t from a Python object.

        Derives a hipUUID_t from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``hipUUID_t`` reference, this method
        returns it directly. No new ``hipUUID_t`` is created in this case.
        """
        return hipUUID_t.fromPyobj(pyobj)

    @staticmethod
    cdef hipUUID_t fromPyobj(object pyobj):
        """Creates a hipUUID_t from a Python object.

        Derives a hipUUID_t from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``hipUUID_t`` reference, this method
        returns it directly. No new ``hipUUID_t`` is created in this case.

        Args:
            pyobj (object): Must be either `None`; a `hip._util.types.Pointer`; a simple, contiguous buffer according to the buffer protocol;
                            or of type `hipUUID_t`; `int`; or `ctypes.c_void_p`.

        Note:
            This routine does not perform a copy but returns the original ``pyobj``
            if ``pyobj`` is an instance of hipUUID_t!
        """
        cdef hipUUID_t wrapper

        if isinstance(pyobj,hipUUID_t):
            return pyobj
        else:
            wrapper = hipUUID_t.__new__(hipUUID_t)
            wrapper.init_from_pyobj(pyobj)
            return wrapper

    def __dealloc__(self):
        # Release the buffer handle
        if self._py_buffer_acquired is True:
            cpython.buffer.PyBuffer_Release(&self._py_buffer)
        # De-allocate if not null and flag is set
        if self._ptr is not NULL and self._is_ptr_owner is True:
            stdlib.free(self._ptr)
            self._ptr = NULL

    @staticmethod
    cdef __allocate(void** ptr):
        ptr[0] = stdlib.malloc(sizeof(chip.hipUUID_t))
        string.memset(<void*>ptr[0], 0, sizeof(chip.hipUUID_t))

        if ptr[0] is NULL:
            raise MemoryError

    @staticmethod
    cdef hipUUID_t new():
        """Factory function to create hipUUID_t objects with
        newly allocated chip.hipUUID_t"""
        cdef void* ptr
        hipUUID_t.__allocate(&ptr)
        return hipUUID_t.fromPtr(ptr, owner=True)

    @staticmethod
    cdef hipUUID_t fromValue(chip.hipUUID_t other):
        """Allocate new C type and copy from ``other``.
        """
        wrapper = hipUUID_t.new()
        string.memcpy(wrapper._ptr, &other, sizeof(chip.hipUUID_t))
        return wrapper

    def c_sizeof(self):
        """Returns the size of the underlying C type in bytes.
        Note:
            Implemented as function to not collide with
            autogenerated property names.
        """
        return sizeof(chip.hipUUID_t)

    def __int__(self):
        """Returns the data's address as long integer.
        """
        return cpython.long.PyLong_FromVoidPtr(self._ptr)

    def __repr__(self):
        return f"<hipUUID_t object, ptr: {int(self)}>"

    def as_c_void_p(self):
        """Returns the data's address as `ctypes.c_void_p`
        Note:
            Implemented as function to not collide with
            autogenerated property names.
        """
        return ctypes.c_void_p(int(self))

    def __init__(self,*args,**kwargs):
        """Constructor type hipUUID_t.

        Constructor for type hipUUID_t.

        Args:
            *args:
                Positional arguments. Initialize all or a subset of the member variables
                according to their order of declaration.
            **kwargs:
                Can be used to initialize member variables at construction,
                Just pass an argument expression of the form <member>=<value>
                per member that you want to initialize.
        """
        hipUUID_t.__allocate(&self._ptr)
        self._is_ptr_owner = True
        attribs = self.PROPERTIES()
        used_attribs = set()
        if len(args) > len(attribs):
            raise ValueError("More positional arguments specified than this type has properties.")
        for i,v in enumerate(args):
            setattr(self,attribs[i],v)
            used_attribs.add(attribs[i])
        valid_names = ", ".join(["'"+p+"'" for p in attribs])
        for k,v in kwargs.items():
            if k in used_attribs:
                raise KeyError(f"argument '{k}' has already been specified as positional argument.")
            elif k not in attribs:
                raise KeyError(f"'{k}' is no valid property name. Valid names: {valid_names}")
            setattr(self,k,v)
    def get_bytes(self, i):
        """Get value of ``bytes`` of ``(<chip.hipUUID_t*>self._ptr)[i]``.
        """
        return (<chip.hipUUID_t*>self._ptr)[i].bytes
    # TODO add setters
    #def set_bytes(self, i, char[16] value):
    #    """Set value ``bytes`` of ``(<chip.hipUUID_t*>self._ptr)[i]``.
    #    """
    #    (<chip.hipUUID_t*>self._ptr)[i].bytes = value
    @property
    def bytes(self):
        """(undocumented)"""
        return self.get_bytes(0)
    # TODO add setters
    #@bytes.setter
    #def bytes(self, char[16] value):
    #    self.set_bytes(0,value)

    @staticmethod
    def PROPERTIES():
        return ["bytes"]

    def __contains__(self,item):
        properties = self.PROPERTIES()
        return item in properties

    def __getitem__(self,item):
        properties = self.PROPERTIES()
        if isinstance(item,int):
            if item < 0 or item >= len(properties):
                raise IndexError()
            return getattr(self,properties[item])
        raise ValueError("'item' type must be 'int'")


hipUUID = hipUUID_t

cdef class hipDeviceProp_t(hip._util.types.Pointer):
    """Python wrapper for cdef class chip.hipDeviceProp_t.

    Python wrapper for cdef class chip.hipDeviceProp_t.

    If this type is initialized via its `__init__` method, it allocates a
    member of the underlying C type and destroys it again if the wrapper
    type is deallocated.

    This type also serves as adapter when appearing as argument type in a
    function signature. In this case, the type can further be initialized
    from a number of Python objects:

    * `None`:

      This will set the ``self._ptr`` attribute to ``NULL``.

    * `int`:

      Interprets the integer value as pointer address and writes it to ``self._ptr``.
      No ownership is transferred.

    * `ctypes.c_void_p`:

      Takes the pointer address ``pyobj.value`` and writes it to ``self._ptr``.
      No ownership is transferred.

    * `object` that implements the `CUDA Array Interface <https://numba.readthedocs.io/en/stable/cuda/cuda_array_interface.html>`_ protocol:

      Takes the integer-valued pointer address, i.e. the first entry of the `data` tuple
      from `pyobj`'s member ``__cuda_array_interface__``  and writes it to ``self._ptr``.

    * `object` that implements the Python buffer protocol:

      If the object represents a simple contiguous array,
      writes the `Py_buffer` associated with ``pyobj`` to `self._py_buffer`,
      sets the `self._py_buffer_acquired` flag to `True`, and
      writes `self._py_buffer.buf` to the data pointer `self._ptr`.

    * `hip._util.types.Pointer`:

      Takes the pointer address ``pyobj._ptr`` and writes it to ``self._ptr``.
      No ownership is transferred.

    Type checks are performed in the above order.

    C Attributes:
        _ptr (C type ``void *``, protected):
            Stores a pointer to the data of the original Python object.
        _is_ptr_owner (C type ``bint``, protected):
            If this wrapper is the owner of the underlying data.
        _py_buffer (C type ``Py_buffer`, protected):
            Stores a pointer to the data of the original Python object.
        _py_buffer_acquired (C type ``bint``, protected):
            Stores a pointer to the data of the original Python object.
    """
    # C members declared in pxd file

    def __cinit__(self):
        self._ptr = NULL
        self._is_ptr_owner = False
        self._py_buffer_acquired = False

    cdef chip.hipDeviceProp_t* getElementPtr(self):
        return <chip.hipDeviceProp_t*>self._ptr

    @staticmethod
    cdef hipDeviceProp_t fromPtr(void* ptr, bint owner=False):
        """Factory function to create ``hipDeviceProp_t`` objects from
        given ``chip.hipDeviceProp_t`` pointer.

        Setting ``owner`` flag to ``True`` causes
        the extension type to free the structure pointed to by ``ptr``
        when the wrapper object is deallocated.
        """
        # Fast call to __new__() that bypasses the __init__() constructor.
        cdef hipDeviceProp_t wrapper = hipDeviceProp_t.__new__(hipDeviceProp_t)
        wrapper._ptr = ptr
        wrapper._is_ptr_owner = owner
        return wrapper

    @staticmethod
    def fromObj(pyobj):
        """Creates a hipDeviceProp_t from a Python object.

        Derives a hipDeviceProp_t from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``hipDeviceProp_t`` reference, this method
        returns it directly. No new ``hipDeviceProp_t`` is created in this case.
        """
        return hipDeviceProp_t.fromPyobj(pyobj)

    @staticmethod
    cdef hipDeviceProp_t fromPyobj(object pyobj):
        """Creates a hipDeviceProp_t from a Python object.

        Derives a hipDeviceProp_t from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``hipDeviceProp_t`` reference, this method
        returns it directly. No new ``hipDeviceProp_t`` is created in this case.

        Args:
            pyobj (object): Must be either `None`; a `hip._util.types.Pointer`; a simple, contiguous buffer according to the buffer protocol;
                            or of type `hipDeviceProp_t`; `int`; or `ctypes.c_void_p`.

        Note:
            This routine does not perform a copy but returns the original ``pyobj``
            if ``pyobj`` is an instance of hipDeviceProp_t!
        """
        cdef hipDeviceProp_t wrapper

        if isinstance(pyobj,hipDeviceProp_t):
            return pyobj
        else:
            wrapper = hipDeviceProp_t.__new__(hipDeviceProp_t)
            wrapper.init_from_pyobj(pyobj)
            return wrapper

    def __dealloc__(self):
        # Release the buffer handle
        if self._py_buffer_acquired is True:
            cpython.buffer.PyBuffer_Release(&self._py_buffer)
        # De-allocate if not null and flag is set
        if self._ptr is not NULL and self._is_ptr_owner is True:
            stdlib.free(self._ptr)
            self._ptr = NULL

    @staticmethod
    cdef __allocate(void** ptr):
        ptr[0] = stdlib.malloc(sizeof(chip.hipDeviceProp_t))
        string.memset(<void*>ptr[0], 0, sizeof(chip.hipDeviceProp_t))

        if ptr[0] is NULL:
            raise MemoryError

    @staticmethod
    cdef hipDeviceProp_t new():
        """Factory function to create hipDeviceProp_t objects with
        newly allocated chip.hipDeviceProp_t"""
        cdef void* ptr
        hipDeviceProp_t.__allocate(&ptr)
        return hipDeviceProp_t.fromPtr(ptr, owner=True)

    @staticmethod
    cdef hipDeviceProp_t fromValue(chip.hipDeviceProp_t other):
        """Allocate new C type and copy from ``other``.
        """
        wrapper = hipDeviceProp_t.new()
        string.memcpy(wrapper._ptr, &other, sizeof(chip.hipDeviceProp_t))
        return wrapper

    def c_sizeof(self):
        """Returns the size of the underlying C type in bytes.
        Note:
            Implemented as function to not collide with
            autogenerated property names.
        """
        return sizeof(chip.hipDeviceProp_t)

    def __int__(self):
        """Returns the data's address as long integer.
        """
        return cpython.long.PyLong_FromVoidPtr(self._ptr)

    def __repr__(self):
        return f"<hipDeviceProp_t object, ptr: {int(self)}>"

    def as_c_void_p(self):
        """Returns the data's address as `ctypes.c_void_p`
        Note:
            Implemented as function to not collide with
            autogenerated property names.
        """
        return ctypes.c_void_p(int(self))

    def __init__(self,*args,**kwargs):
        """Constructor type hipDeviceProp_t.

        Constructor for type hipDeviceProp_t.

        Args:
            *args:
                Positional arguments. Initialize all or a subset of the member variables
                according to their order of declaration.
            **kwargs:
                Can be used to initialize member variables at construction,
                Just pass an argument expression of the form <member>=<value>
                per member that you want to initialize.
        """
        hipDeviceProp_t.__allocate(&self._ptr)
        self._is_ptr_owner = True
        attribs = self.PROPERTIES()
        used_attribs = set()
        if len(args) > len(attribs):
            raise ValueError("More positional arguments specified than this type has properties.")
        for i,v in enumerate(args):
            setattr(self,attribs[i],v)
            used_attribs.add(attribs[i])
        valid_names = ", ".join(["'"+p+"'" for p in attribs])
        for k,v in kwargs.items():
            if k in used_attribs:
                raise KeyError(f"argument '{k}' has already been specified as positional argument.")
            elif k not in attribs:
                raise KeyError(f"'{k}' is no valid property name. Valid names: {valid_names}")
            setattr(self,k,v)
    def get_name(self, i):
        """Get value of ``name`` of ``(<chip.hipDeviceProp_t*>self._ptr)[i]``.
        """
        return (<chip.hipDeviceProp_t*>self._ptr)[i].name
    # TODO add setters
    #def set_name(self, i, char[256] value):
    #    """Set value ``name`` of ``(<chip.hipDeviceProp_t*>self._ptr)[i]``.
    #    """
    #    (<chip.hipDeviceProp_t*>self._ptr)[i].name = value
    @property
    def name(self):
        """Device name."""
        return self.get_name(0)
    # TODO add setters
    #@name.setter
    #def name(self, char[256] value):
    #    self.set_name(0,value)

    def get_uuid(self, i):
        """Get value of ``uuid`` of ``(<chip.hipDeviceProp_t*>self._ptr)[i]``.
        """
        return hipUUID_t.fromPtr(&(<chip.hipDeviceProp_t*>self._ptr)[i].uuid)
    @property
    def uuid(self):
        """UUID of a device"""
        return self.get_uuid(0)

    def get_luid(self, i):
        """Get value of ``luid`` of ``(<chip.hipDeviceProp_t*>self._ptr)[i]``.
        """
        return (<chip.hipDeviceProp_t*>self._ptr)[i].luid
    # TODO add setters
    #def set_luid(self, i, char[8] value):
    #    """Set value ``luid`` of ``(<chip.hipDeviceProp_t*>self._ptr)[i]``.
    #    """
    #    (<chip.hipDeviceProp_t*>self._ptr)[i].luid = value
    @property
    def luid(self):
        """8-byte unique identifier. Only valid on windows"""
        return self.get_luid(0)
    # TODO add setters
    #@luid.setter
    #def luid(self, char[8] value):
    #    self.set_luid(0,value)

    def get_luidDeviceNodeMask(self, i):
        """Get value ``luidDeviceNodeMask`` of ``(<chip.hipDeviceProp_t*>self._ptr)[i]``.
        """
        return (<chip.hipDeviceProp_t*>self._ptr)[i].luidDeviceNodeMask
    def set_luidDeviceNodeMask(self, i, unsigned int value):
        """Set value ``luidDeviceNodeMask`` of ``(<chip.hipDeviceProp_t*>self._ptr)[i]``.
        """
        (<chip.hipDeviceProp_t*>self._ptr)[i].luidDeviceNodeMask = value
    @property
    def luidDeviceNodeMask(self):
        """LUID node mask"""
        return self.get_luidDeviceNodeMask(0)
    @luidDeviceNodeMask.setter
    def luidDeviceNodeMask(self, unsigned int value):
        self.set_luidDeviceNodeMask(0,value)

    def get_totalGlobalMem(self, i):
        """Get value ``totalGlobalMem`` of ``(<chip.hipDeviceProp_t*>self._ptr)[i]``.
        """
        return (<chip.hipDeviceProp_t*>self._ptr)[i].totalGlobalMem
    def set_totalGlobalMem(self, i, unsigned long value):
        """Set value ``totalGlobalMem`` of ``(<chip.hipDeviceProp_t*>self._ptr)[i]``.
        """
        (<chip.hipDeviceProp_t*>self._ptr)[i].totalGlobalMem = value
    @property
    def totalGlobalMem(self):
        """Size of global memory region (in bytes)."""
        return self.get_totalGlobalMem(0)
    @totalGlobalMem.setter
    def totalGlobalMem(self, unsigned long value):
        self.set_totalGlobalMem(0,value)

    def get_sharedMemPerBlock(self, i):
        """Get value ``sharedMemPerBlock`` of ``(<chip.hipDeviceProp_t*>self._ptr)[i]``.
        """
        return (<chip.hipDeviceProp_t*>self._ptr)[i].sharedMemPerBlock
    def set_sharedMemPerBlock(self, i, unsigned long value):
        """Set value ``sharedMemPerBlock`` of ``(<chip.hipDeviceProp_t*>self._ptr)[i]``.
        """
        (<chip.hipDeviceProp_t*>self._ptr)[i].sharedMemPerBlock = value
    @property
    def sharedMemPerBlock(self):
        """Size of shared memory per block (in bytes)."""
        return self.get_sharedMemPerBlock(0)
    @sharedMemPerBlock.setter
    def sharedMemPerBlock(self, unsigned long value):
        self.set_sharedMemPerBlock(0,value)

    def get_regsPerBlock(self, i):
        """Get value ``regsPerBlock`` of ``(<chip.hipDeviceProp_t*>self._ptr)[i]``.
        """
        return (<chip.hipDeviceProp_t*>self._ptr)[i].regsPerBlock
    def set_regsPerBlock(self, i, int value):
        """Set value ``regsPerBlock`` of ``(<chip.hipDeviceProp_t*>self._ptr)[i]``.
        """
        (<chip.hipDeviceProp_t*>self._ptr)[i].regsPerBlock = value
    @property
    def regsPerBlock(self):
        """Registers per block."""
        return self.get_regsPerBlock(0)
    @regsPerBlock.setter
    def regsPerBlock(self, int value):
        self.set_regsPerBlock(0,value)

    def get_warpSize(self, i):
        """Get value ``warpSize`` of ``(<chip.hipDeviceProp_t*>self._ptr)[i]``.
        """
        return (<chip.hipDeviceProp_t*>self._ptr)[i].warpSize
    def set_warpSize(self, i, int value):
        """Set value ``warpSize`` of ``(<chip.hipDeviceProp_t*>self._ptr)[i]``.
        """
        (<chip.hipDeviceProp_t*>self._ptr)[i].warpSize = value
    @property
    def warpSize(self):
        """Warp size."""
        return self.get_warpSize(0)
    @warpSize.setter
    def warpSize(self, int value):
        self.set_warpSize(0,value)

    def get_memPitch(self, i):
        """Get value ``memPitch`` of ``(<chip.hipDeviceProp_t*>self._ptr)[i]``.
        """
        return (<chip.hipDeviceProp_t*>self._ptr)[i].memPitch
    def set_memPitch(self, i, unsigned long value):
        """Set value ``memPitch`` of ``(<chip.hipDeviceProp_t*>self._ptr)[i]``.
        """
        (<chip.hipDeviceProp_t*>self._ptr)[i].memPitch = value
    @property
    def memPitch(self):
        """Maximum pitch in bytes allowed by memory copies pitched memory"""
        return self.get_memPitch(0)
    @memPitch.setter
    def memPitch(self, unsigned long value):
        self.set_memPitch(0,value)

    def get_maxThreadsPerBlock(self, i):
        """Get value ``maxThreadsPerBlock`` of ``(<chip.hipDeviceProp_t*>self._ptr)[i]``.
        """
        return (<chip.hipDeviceProp_t*>self._ptr)[i].maxThreadsPerBlock
    def set_maxThreadsPerBlock(self, i, int value):
        """Set value ``maxThreadsPerBlock`` of ``(<chip.hipDeviceProp_t*>self._ptr)[i]``.
        """
        (<chip.hipDeviceProp_t*>self._ptr)[i].maxThreadsPerBlock = value
    @property
    def maxThreadsPerBlock(self):
        """Max work items per work group or workgroup max size."""
        return self.get_maxThreadsPerBlock(0)
    @maxThreadsPerBlock.setter
    def maxThreadsPerBlock(self, int value):
        self.set_maxThreadsPerBlock(0,value)

    def get_maxThreadsDim(self, i):
        """Get value of ``maxThreadsDim`` of ``(<chip.hipDeviceProp_t*>self._ptr)[i]``.
        """
        return (<chip.hipDeviceProp_t*>self._ptr)[i].maxThreadsDim
    # TODO add setters
    #def set_maxThreadsDim(self, i, int[3] value):
    #    """Set value ``maxThreadsDim`` of ``(<chip.hipDeviceProp_t*>self._ptr)[i]``.
    #    """
    #    (<chip.hipDeviceProp_t*>self._ptr)[i].maxThreadsDim = value
    @property
    def maxThreadsDim(self):
        """Max number of threads in each dimension (XYZ) of a block."""
        return self.get_maxThreadsDim(0)
    # TODO add setters
    #@maxThreadsDim.setter
    #def maxThreadsDim(self, int[3] value):
    #    self.set_maxThreadsDim(0,value)

    def get_maxGridSize(self, i):
        """Get value of ``maxGridSize`` of ``(<chip.hipDeviceProp_t*>self._ptr)[i]``.
        """
        return (<chip.hipDeviceProp_t*>self._ptr)[i].maxGridSize
    # TODO add setters
    #def set_maxGridSize(self, i, int[3] value):
    #    """Set value ``maxGridSize`` of ``(<chip.hipDeviceProp_t*>self._ptr)[i]``.
    #    """
    #    (<chip.hipDeviceProp_t*>self._ptr)[i].maxGridSize = value
    @property
    def maxGridSize(self):
        """Max grid dimensions (XYZ)."""
        return self.get_maxGridSize(0)
    # TODO add setters
    #@maxGridSize.setter
    #def maxGridSize(self, int[3] value):
    #    self.set_maxGridSize(0,value)

    def get_clockRate(self, i):
        """Get value ``clockRate`` of ``(<chip.hipDeviceProp_t*>self._ptr)[i]``.
        """
        return (<chip.hipDeviceProp_t*>self._ptr)[i].clockRate
    def set_clockRate(self, i, int value):
        """Set value ``clockRate`` of ``(<chip.hipDeviceProp_t*>self._ptr)[i]``.
        """
        (<chip.hipDeviceProp_t*>self._ptr)[i].clockRate = value
    @property
    def clockRate(self):
        """Max clock frequency of the multiProcessors in khz."""
        return self.get_clockRate(0)
    @clockRate.setter
    def clockRate(self, int value):
        self.set_clockRate(0,value)

    def get_totalConstMem(self, i):
        """Get value ``totalConstMem`` of ``(<chip.hipDeviceProp_t*>self._ptr)[i]``.
        """
        return (<chip.hipDeviceProp_t*>self._ptr)[i].totalConstMem
    def set_totalConstMem(self, i, unsigned long value):
        """Set value ``totalConstMem`` of ``(<chip.hipDeviceProp_t*>self._ptr)[i]``.
        """
        (<chip.hipDeviceProp_t*>self._ptr)[i].totalConstMem = value
    @property
    def totalConstMem(self):
        """Size of shared constant memory region on the device (in bytes)."""
        return self.get_totalConstMem(0)
    @totalConstMem.setter
    def totalConstMem(self, unsigned long value):
        self.set_totalConstMem(0,value)

    def get_major(self, i):
        """Get value ``major`` of ``(<chip.hipDeviceProp_t*>self._ptr)[i]``.
        """
        return (<chip.hipDeviceProp_t*>self._ptr)[i].major
    def set_major(self, i, int value):
        """Set value ``major`` of ``(<chip.hipDeviceProp_t*>self._ptr)[i]``.
        """
        (<chip.hipDeviceProp_t*>self._ptr)[i].major = value
    @property
    def major(self):
        """Major compute capability. On HCC, this is an approximation and features may differ from CUDA CC. See the arch feature flags for portable ways to query feature caps."""
        return self.get_major(0)
    @major.setter
    def major(self, int value):
        self.set_major(0,value)

    def get_minor(self, i):
        """Get value ``minor`` of ``(<chip.hipDeviceProp_t*>self._ptr)[i]``.
        """
        return (<chip.hipDeviceProp_t*>self._ptr)[i].minor
    def set_minor(self, i, int value):
        """Set value ``minor`` of ``(<chip.hipDeviceProp_t*>self._ptr)[i]``.
        """
        (<chip.hipDeviceProp_t*>self._ptr)[i].minor = value
    @property
    def minor(self):
        """Minor compute capability. On HCC, this is an approximation and features may differ from CUDA CC. See the arch feature flags for portable ways to query feature caps."""
        return self.get_minor(0)
    @minor.setter
    def minor(self, int value):
        self.set_minor(0,value)

    def get_textureAlignment(self, i):
        """Get value ``textureAlignment`` of ``(<chip.hipDeviceProp_t*>self._ptr)[i]``.
        """
        return (<chip.hipDeviceProp_t*>self._ptr)[i].textureAlignment
    def set_textureAlignment(self, i, unsigned long value):
        """Set value ``textureAlignment`` of ``(<chip.hipDeviceProp_t*>self._ptr)[i]``.
        """
        (<chip.hipDeviceProp_t*>self._ptr)[i].textureAlignment = value
    @property
    def textureAlignment(self):
        """Alignment requirement for textures"""
        return self.get_textureAlignment(0)
    @textureAlignment.setter
    def textureAlignment(self, unsigned long value):
        self.set_textureAlignment(0,value)

    def get_texturePitchAlignment(self, i):
        """Get value ``texturePitchAlignment`` of ``(<chip.hipDeviceProp_t*>self._ptr)[i]``.
        """
        return (<chip.hipDeviceProp_t*>self._ptr)[i].texturePitchAlignment
    def set_texturePitchAlignment(self, i, unsigned long value):
        """Set value ``texturePitchAlignment`` of ``(<chip.hipDeviceProp_t*>self._ptr)[i]``.
        """
        (<chip.hipDeviceProp_t*>self._ptr)[i].texturePitchAlignment = value
    @property
    def texturePitchAlignment(self):
        """Pitch alignment requirement for texture references bound to"""
        return self.get_texturePitchAlignment(0)
    @texturePitchAlignment.setter
    def texturePitchAlignment(self, unsigned long value):
        self.set_texturePitchAlignment(0,value)

    def get_deviceOverlap(self, i):
        """Get value ``deviceOverlap`` of ``(<chip.hipDeviceProp_t*>self._ptr)[i]``.
        """
        return (<chip.hipDeviceProp_t*>self._ptr)[i].deviceOverlap
    def set_deviceOverlap(self, i, int value):
        """Set value ``deviceOverlap`` of ``(<chip.hipDeviceProp_t*>self._ptr)[i]``.
        """
        (<chip.hipDeviceProp_t*>self._ptr)[i].deviceOverlap = value
    @property
    def deviceOverlap(self):
        """Deprecated. Use asyncEngineCount instead"""
        return self.get_deviceOverlap(0)
    @deviceOverlap.setter
    def deviceOverlap(self, int value):
        self.set_deviceOverlap(0,value)

    def get_multiProcessorCount(self, i):
        """Get value ``multiProcessorCount`` of ``(<chip.hipDeviceProp_t*>self._ptr)[i]``.
        """
        return (<chip.hipDeviceProp_t*>self._ptr)[i].multiProcessorCount
    def set_multiProcessorCount(self, i, int value):
        """Set value ``multiProcessorCount`` of ``(<chip.hipDeviceProp_t*>self._ptr)[i]``.
        """
        (<chip.hipDeviceProp_t*>self._ptr)[i].multiProcessorCount = value
    @property
    def multiProcessorCount(self):
        """Number of multi-processors (compute units)."""
        return self.get_multiProcessorCount(0)
    @multiProcessorCount.setter
    def multiProcessorCount(self, int value):
        self.set_multiProcessorCount(0,value)

    def get_kernelExecTimeoutEnabled(self, i):
        """Get value ``kernelExecTimeoutEnabled`` of ``(<chip.hipDeviceProp_t*>self._ptr)[i]``.
        """
        return (<chip.hipDeviceProp_t*>self._ptr)[i].kernelExecTimeoutEnabled
    def set_kernelExecTimeoutEnabled(self, i, int value):
        """Set value ``kernelExecTimeoutEnabled`` of ``(<chip.hipDeviceProp_t*>self._ptr)[i]``.
        """
        (<chip.hipDeviceProp_t*>self._ptr)[i].kernelExecTimeoutEnabled = value
    @property
    def kernelExecTimeoutEnabled(self):
        """Run time limit for kernels executed on the device"""
        return self.get_kernelExecTimeoutEnabled(0)
    @kernelExecTimeoutEnabled.setter
    def kernelExecTimeoutEnabled(self, int value):
        self.set_kernelExecTimeoutEnabled(0,value)

    def get_integrated(self, i):
        """Get value ``integrated`` of ``(<chip.hipDeviceProp_t*>self._ptr)[i]``.
        """
        return (<chip.hipDeviceProp_t*>self._ptr)[i].integrated
    def set_integrated(self, i, int value):
        """Set value ``integrated`` of ``(<chip.hipDeviceProp_t*>self._ptr)[i]``.
        """
        (<chip.hipDeviceProp_t*>self._ptr)[i].integrated = value
    @property
    def integrated(self):
        """APU vs dGPU"""
        return self.get_integrated(0)
    @integrated.setter
    def integrated(self, int value):
        self.set_integrated(0,value)

    def get_canMapHostMemory(self, i):
        """Get value ``canMapHostMemory`` of ``(<chip.hipDeviceProp_t*>self._ptr)[i]``.
        """
        return (<chip.hipDeviceProp_t*>self._ptr)[i].canMapHostMemory
    def set_canMapHostMemory(self, i, int value):
        """Set value ``canMapHostMemory`` of ``(<chip.hipDeviceProp_t*>self._ptr)[i]``.
        """
        (<chip.hipDeviceProp_t*>self._ptr)[i].canMapHostMemory = value
    @property
    def canMapHostMemory(self):
        """Check whether HIP can map host memory"""
        return self.get_canMapHostMemory(0)
    @canMapHostMemory.setter
    def canMapHostMemory(self, int value):
        self.set_canMapHostMemory(0,value)

    def get_computeMode(self, i):
        """Get value ``computeMode`` of ``(<chip.hipDeviceProp_t*>self._ptr)[i]``.
        """
        return (<chip.hipDeviceProp_t*>self._ptr)[i].computeMode
    def set_computeMode(self, i, int value):
        """Set value ``computeMode`` of ``(<chip.hipDeviceProp_t*>self._ptr)[i]``.
        """
        (<chip.hipDeviceProp_t*>self._ptr)[i].computeMode = value
    @property
    def computeMode(self):
        """Compute mode."""
        return self.get_computeMode(0)
    @computeMode.setter
    def computeMode(self, int value):
        self.set_computeMode(0,value)

    def get_maxTexture1D(self, i):
        """Get value ``maxTexture1D`` of ``(<chip.hipDeviceProp_t*>self._ptr)[i]``.
        """
        return (<chip.hipDeviceProp_t*>self._ptr)[i].maxTexture1D
    def set_maxTexture1D(self, i, int value):
        """Set value ``maxTexture1D`` of ``(<chip.hipDeviceProp_t*>self._ptr)[i]``.
        """
        (<chip.hipDeviceProp_t*>self._ptr)[i].maxTexture1D = value
    @property
    def maxTexture1D(self):
        """Maximum number of elements in 1D images"""
        return self.get_maxTexture1D(0)
    @maxTexture1D.setter
    def maxTexture1D(self, int value):
        self.set_maxTexture1D(0,value)

    def get_maxTexture1DMipmap(self, i):
        """Get value ``maxTexture1DMipmap`` of ``(<chip.hipDeviceProp_t*>self._ptr)[i]``.
        """
        return (<chip.hipDeviceProp_t*>self._ptr)[i].maxTexture1DMipmap
    def set_maxTexture1DMipmap(self, i, int value):
        """Set value ``maxTexture1DMipmap`` of ``(<chip.hipDeviceProp_t*>self._ptr)[i]``.
        """
        (<chip.hipDeviceProp_t*>self._ptr)[i].maxTexture1DMipmap = value
    @property
    def maxTexture1DMipmap(self):
        """Maximum 1D mipmap texture size"""
        return self.get_maxTexture1DMipmap(0)
    @maxTexture1DMipmap.setter
    def maxTexture1DMipmap(self, int value):
        self.set_maxTexture1DMipmap(0,value)

    def get_maxTexture1DLinear(self, i):
        """Get value ``maxTexture1DLinear`` of ``(<chip.hipDeviceProp_t*>self._ptr)[i]``.
        """
        return (<chip.hipDeviceProp_t*>self._ptr)[i].maxTexture1DLinear
    def set_maxTexture1DLinear(self, i, int value):
        """Set value ``maxTexture1DLinear`` of ``(<chip.hipDeviceProp_t*>self._ptr)[i]``.
        """
        (<chip.hipDeviceProp_t*>self._ptr)[i].maxTexture1DLinear = value
    @property
    def maxTexture1DLinear(self):
        """Maximum size for 1D textures bound to linear memory"""
        return self.get_maxTexture1DLinear(0)
    @maxTexture1DLinear.setter
    def maxTexture1DLinear(self, int value):
        self.set_maxTexture1DLinear(0,value)

    def get_maxTexture2D(self, i):
        """Get value of ``maxTexture2D`` of ``(<chip.hipDeviceProp_t*>self._ptr)[i]``.
        """
        return (<chip.hipDeviceProp_t*>self._ptr)[i].maxTexture2D
    # TODO add setters
    #def set_maxTexture2D(self, i, int[2] value):
    #    """Set value ``maxTexture2D`` of ``(<chip.hipDeviceProp_t*>self._ptr)[i]``.
    #    """
    #    (<chip.hipDeviceProp_t*>self._ptr)[i].maxTexture2D = value
    @property
    def maxTexture2D(self):
        """Maximum dimensions (width, height) of 2D images, in image elements"""
        return self.get_maxTexture2D(0)
    # TODO add setters
    #@maxTexture2D.setter
    #def maxTexture2D(self, int[2] value):
    #    self.set_maxTexture2D(0,value)

    def get_maxTexture2DMipmap(self, i):
        """Get value of ``maxTexture2DMipmap`` of ``(<chip.hipDeviceProp_t*>self._ptr)[i]``.
        """
        return (<chip.hipDeviceProp_t*>self._ptr)[i].maxTexture2DMipmap
    # TODO add setters
    #def set_maxTexture2DMipmap(self, i, int[2] value):
    #    """Set value ``maxTexture2DMipmap`` of ``(<chip.hipDeviceProp_t*>self._ptr)[i]``.
    #    """
    #    (<chip.hipDeviceProp_t*>self._ptr)[i].maxTexture2DMipmap = value
    @property
    def maxTexture2DMipmap(self):
        """Maximum number of elements in 2D array mipmap of images"""
        return self.get_maxTexture2DMipmap(0)
    # TODO add setters
    #@maxTexture2DMipmap.setter
    #def maxTexture2DMipmap(self, int[2] value):
    #    self.set_maxTexture2DMipmap(0,value)

    def get_maxTexture2DLinear(self, i):
        """Get value of ``maxTexture2DLinear`` of ``(<chip.hipDeviceProp_t*>self._ptr)[i]``.
        """
        return (<chip.hipDeviceProp_t*>self._ptr)[i].maxTexture2DLinear
    # TODO add setters
    #def set_maxTexture2DLinear(self, i, int[3] value):
    #    """Set value ``maxTexture2DLinear`` of ``(<chip.hipDeviceProp_t*>self._ptr)[i]``.
    #    """
    #    (<chip.hipDeviceProp_t*>self._ptr)[i].maxTexture2DLinear = value
    @property
    def maxTexture2DLinear(self):
        """Maximum 2D tex dimensions if tex are bound to pitched memory"""
        return self.get_maxTexture2DLinear(0)
    # TODO add setters
    #@maxTexture2DLinear.setter
    #def maxTexture2DLinear(self, int[3] value):
    #    self.set_maxTexture2DLinear(0,value)

    def get_maxTexture2DGather(self, i):
        """Get value of ``maxTexture2DGather`` of ``(<chip.hipDeviceProp_t*>self._ptr)[i]``.
        """
        return (<chip.hipDeviceProp_t*>self._ptr)[i].maxTexture2DGather
    # TODO add setters
    #def set_maxTexture2DGather(self, i, int[2] value):
    #    """Set value ``maxTexture2DGather`` of ``(<chip.hipDeviceProp_t*>self._ptr)[i]``.
    #    """
    #    (<chip.hipDeviceProp_t*>self._ptr)[i].maxTexture2DGather = value
    @property
    def maxTexture2DGather(self):
        """Maximum 2D tex dimensions if gather has to be performed"""
        return self.get_maxTexture2DGather(0)
    # TODO add setters
    #@maxTexture2DGather.setter
    #def maxTexture2DGather(self, int[2] value):
    #    self.set_maxTexture2DGather(0,value)

    def get_maxTexture3D(self, i):
        """Get value of ``maxTexture3D`` of ``(<chip.hipDeviceProp_t*>self._ptr)[i]``.
        """
        return (<chip.hipDeviceProp_t*>self._ptr)[i].maxTexture3D
    # TODO add setters
    #def set_maxTexture3D(self, i, int[3] value):
    #    """Set value ``maxTexture3D`` of ``(<chip.hipDeviceProp_t*>self._ptr)[i]``.
    #    """
    #    (<chip.hipDeviceProp_t*>self._ptr)[i].maxTexture3D = value
    @property
    def maxTexture3D(self):
        """Maximum dimensions (width, height, depth) of 3D images, in image elements"""
        return self.get_maxTexture3D(0)
    # TODO add setters
    #@maxTexture3D.setter
    #def maxTexture3D(self, int[3] value):
    #    self.set_maxTexture3D(0,value)

    def get_maxTexture3DAlt(self, i):
        """Get value of ``maxTexture3DAlt`` of ``(<chip.hipDeviceProp_t*>self._ptr)[i]``.
        """
        return (<chip.hipDeviceProp_t*>self._ptr)[i].maxTexture3DAlt
    # TODO add setters
    #def set_maxTexture3DAlt(self, i, int[3] value):
    #    """Set value ``maxTexture3DAlt`` of ``(<chip.hipDeviceProp_t*>self._ptr)[i]``.
    #    """
    #    (<chip.hipDeviceProp_t*>self._ptr)[i].maxTexture3DAlt = value
    @property
    def maxTexture3DAlt(self):
        """Maximum alternate 3D texture dims"""
        return self.get_maxTexture3DAlt(0)
    # TODO add setters
    #@maxTexture3DAlt.setter
    #def maxTexture3DAlt(self, int[3] value):
    #    self.set_maxTexture3DAlt(0,value)

    def get_maxTextureCubemap(self, i):
        """Get value ``maxTextureCubemap`` of ``(<chip.hipDeviceProp_t*>self._ptr)[i]``.
        """
        return (<chip.hipDeviceProp_t*>self._ptr)[i].maxTextureCubemap
    def set_maxTextureCubemap(self, i, int value):
        """Set value ``maxTextureCubemap`` of ``(<chip.hipDeviceProp_t*>self._ptr)[i]``.
        """
        (<chip.hipDeviceProp_t*>self._ptr)[i].maxTextureCubemap = value
    @property
    def maxTextureCubemap(self):
        """Maximum cubemap texture dims"""
        return self.get_maxTextureCubemap(0)
    @maxTextureCubemap.setter
    def maxTextureCubemap(self, int value):
        self.set_maxTextureCubemap(0,value)

    def get_maxTexture1DLayered(self, i):
        """Get value of ``maxTexture1DLayered`` of ``(<chip.hipDeviceProp_t*>self._ptr)[i]``.
        """
        return (<chip.hipDeviceProp_t*>self._ptr)[i].maxTexture1DLayered
    # TODO add setters
    #def set_maxTexture1DLayered(self, i, int[2] value):
    #    """Set value ``maxTexture1DLayered`` of ``(<chip.hipDeviceProp_t*>self._ptr)[i]``.
    #    """
    #    (<chip.hipDeviceProp_t*>self._ptr)[i].maxTexture1DLayered = value
    @property
    def maxTexture1DLayered(self):
        """Maximum number of elements in 1D array images"""
        return self.get_maxTexture1DLayered(0)
    # TODO add setters
    #@maxTexture1DLayered.setter
    #def maxTexture1DLayered(self, int[2] value):
    #    self.set_maxTexture1DLayered(0,value)

    def get_maxTexture2DLayered(self, i):
        """Get value of ``maxTexture2DLayered`` of ``(<chip.hipDeviceProp_t*>self._ptr)[i]``.
        """
        return (<chip.hipDeviceProp_t*>self._ptr)[i].maxTexture2DLayered
    # TODO add setters
    #def set_maxTexture2DLayered(self, i, int[3] value):
    #    """Set value ``maxTexture2DLayered`` of ``(<chip.hipDeviceProp_t*>self._ptr)[i]``.
    #    """
    #    (<chip.hipDeviceProp_t*>self._ptr)[i].maxTexture2DLayered = value
    @property
    def maxTexture2DLayered(self):
        """Maximum number of elements in 2D array images"""
        return self.get_maxTexture2DLayered(0)
    # TODO add setters
    #@maxTexture2DLayered.setter
    #def maxTexture2DLayered(self, int[3] value):
    #    self.set_maxTexture2DLayered(0,value)

    def get_maxTextureCubemapLayered(self, i):
        """Get value of ``maxTextureCubemapLayered`` of ``(<chip.hipDeviceProp_t*>self._ptr)[i]``.
        """
        return (<chip.hipDeviceProp_t*>self._ptr)[i].maxTextureCubemapLayered
    # TODO add setters
    #def set_maxTextureCubemapLayered(self, i, int[2] value):
    #    """Set value ``maxTextureCubemapLayered`` of ``(<chip.hipDeviceProp_t*>self._ptr)[i]``.
    #    """
    #    (<chip.hipDeviceProp_t*>self._ptr)[i].maxTextureCubemapLayered = value
    @property
    def maxTextureCubemapLayered(self):
        """Maximum cubemaps layered texture dims"""
        return self.get_maxTextureCubemapLayered(0)
    # TODO add setters
    #@maxTextureCubemapLayered.setter
    #def maxTextureCubemapLayered(self, int[2] value):
    #    self.set_maxTextureCubemapLayered(0,value)

    def get_maxSurface1D(self, i):
        """Get value ``maxSurface1D`` of ``(<chip.hipDeviceProp_t*>self._ptr)[i]``.
        """
        return (<chip.hipDeviceProp_t*>self._ptr)[i].maxSurface1D
    def set_maxSurface1D(self, i, int value):
        """Set value ``maxSurface1D`` of ``(<chip.hipDeviceProp_t*>self._ptr)[i]``.
        """
        (<chip.hipDeviceProp_t*>self._ptr)[i].maxSurface1D = value
    @property
    def maxSurface1D(self):
        """Maximum 1D surface size"""
        return self.get_maxSurface1D(0)
    @maxSurface1D.setter
    def maxSurface1D(self, int value):
        self.set_maxSurface1D(0,value)

    def get_maxSurface2D(self, i):
        """Get value of ``maxSurface2D`` of ``(<chip.hipDeviceProp_t*>self._ptr)[i]``.
        """
        return (<chip.hipDeviceProp_t*>self._ptr)[i].maxSurface2D
    # TODO add setters
    #def set_maxSurface2D(self, i, int[2] value):
    #    """Set value ``maxSurface2D`` of ``(<chip.hipDeviceProp_t*>self._ptr)[i]``.
    #    """
    #    (<chip.hipDeviceProp_t*>self._ptr)[i].maxSurface2D = value
    @property
    def maxSurface2D(self):
        """Maximum 2D surface size"""
        return self.get_maxSurface2D(0)
    # TODO add setters
    #@maxSurface2D.setter
    #def maxSurface2D(self, int[2] value):
    #    self.set_maxSurface2D(0,value)

    def get_maxSurface3D(self, i):
        """Get value of ``maxSurface3D`` of ``(<chip.hipDeviceProp_t*>self._ptr)[i]``.
        """
        return (<chip.hipDeviceProp_t*>self._ptr)[i].maxSurface3D
    # TODO add setters
    #def set_maxSurface3D(self, i, int[3] value):
    #    """Set value ``maxSurface3D`` of ``(<chip.hipDeviceProp_t*>self._ptr)[i]``.
    #    """
    #    (<chip.hipDeviceProp_t*>self._ptr)[i].maxSurface3D = value
    @property
    def maxSurface3D(self):
        """Maximum 3D surface size"""
        return self.get_maxSurface3D(0)
    # TODO add setters
    #@maxSurface3D.setter
    #def maxSurface3D(self, int[3] value):
    #    self.set_maxSurface3D(0,value)

    def get_maxSurface1DLayered(self, i):
        """Get value of ``maxSurface1DLayered`` of ``(<chip.hipDeviceProp_t*>self._ptr)[i]``.
        """
        return (<chip.hipDeviceProp_t*>self._ptr)[i].maxSurface1DLayered
    # TODO add setters
    #def set_maxSurface1DLayered(self, i, int[2] value):
    #    """Set value ``maxSurface1DLayered`` of ``(<chip.hipDeviceProp_t*>self._ptr)[i]``.
    #    """
    #    (<chip.hipDeviceProp_t*>self._ptr)[i].maxSurface1DLayered = value
    @property
    def maxSurface1DLayered(self):
        """Maximum 1D layered surface size"""
        return self.get_maxSurface1DLayered(0)
    # TODO add setters
    #@maxSurface1DLayered.setter
    #def maxSurface1DLayered(self, int[2] value):
    #    self.set_maxSurface1DLayered(0,value)

    def get_maxSurface2DLayered(self, i):
        """Get value of ``maxSurface2DLayered`` of ``(<chip.hipDeviceProp_t*>self._ptr)[i]``.
        """
        return (<chip.hipDeviceProp_t*>self._ptr)[i].maxSurface2DLayered
    # TODO add setters
    #def set_maxSurface2DLayered(self, i, int[3] value):
    #    """Set value ``maxSurface2DLayered`` of ``(<chip.hipDeviceProp_t*>self._ptr)[i]``.
    #    """
    #    (<chip.hipDeviceProp_t*>self._ptr)[i].maxSurface2DLayered = value
    @property
    def maxSurface2DLayered(self):
        """Maximum 2D layared surface size"""
        return self.get_maxSurface2DLayered(0)
    # TODO add setters
    #@maxSurface2DLayered.setter
    #def maxSurface2DLayered(self, int[3] value):
    #    self.set_maxSurface2DLayered(0,value)

    def get_maxSurfaceCubemap(self, i):
        """Get value ``maxSurfaceCubemap`` of ``(<chip.hipDeviceProp_t*>self._ptr)[i]``.
        """
        return (<chip.hipDeviceProp_t*>self._ptr)[i].maxSurfaceCubemap
    def set_maxSurfaceCubemap(self, i, int value):
        """Set value ``maxSurfaceCubemap`` of ``(<chip.hipDeviceProp_t*>self._ptr)[i]``.
        """
        (<chip.hipDeviceProp_t*>self._ptr)[i].maxSurfaceCubemap = value
    @property
    def maxSurfaceCubemap(self):
        """Maximum cubemap surface size"""
        return self.get_maxSurfaceCubemap(0)
    @maxSurfaceCubemap.setter
    def maxSurfaceCubemap(self, int value):
        self.set_maxSurfaceCubemap(0,value)

    def get_maxSurfaceCubemapLayered(self, i):
        """Get value of ``maxSurfaceCubemapLayered`` of ``(<chip.hipDeviceProp_t*>self._ptr)[i]``.
        """
        return (<chip.hipDeviceProp_t*>self._ptr)[i].maxSurfaceCubemapLayered
    # TODO add setters
    #def set_maxSurfaceCubemapLayered(self, i, int[2] value):
    #    """Set value ``maxSurfaceCubemapLayered`` of ``(<chip.hipDeviceProp_t*>self._ptr)[i]``.
    #    """
    #    (<chip.hipDeviceProp_t*>self._ptr)[i].maxSurfaceCubemapLayered = value
    @property
    def maxSurfaceCubemapLayered(self):
        """Maximum cubemap layered surface size"""
        return self.get_maxSurfaceCubemapLayered(0)
    # TODO add setters
    #@maxSurfaceCubemapLayered.setter
    #def maxSurfaceCubemapLayered(self, int[2] value):
    #    self.set_maxSurfaceCubemapLayered(0,value)

    def get_surfaceAlignment(self, i):
        """Get value ``surfaceAlignment`` of ``(<chip.hipDeviceProp_t*>self._ptr)[i]``.
        """
        return (<chip.hipDeviceProp_t*>self._ptr)[i].surfaceAlignment
    def set_surfaceAlignment(self, i, unsigned long value):
        """Set value ``surfaceAlignment`` of ``(<chip.hipDeviceProp_t*>self._ptr)[i]``.
        """
        (<chip.hipDeviceProp_t*>self._ptr)[i].surfaceAlignment = value
    @property
    def surfaceAlignment(self):
        """Alignment requirement for surface"""
        return self.get_surfaceAlignment(0)
    @surfaceAlignment.setter
    def surfaceAlignment(self, unsigned long value):
        self.set_surfaceAlignment(0,value)

    def get_concurrentKernels(self, i):
        """Get value ``concurrentKernels`` of ``(<chip.hipDeviceProp_t*>self._ptr)[i]``.
        """
        return (<chip.hipDeviceProp_t*>self._ptr)[i].concurrentKernels
    def set_concurrentKernels(self, i, int value):
        """Set value ``concurrentKernels`` of ``(<chip.hipDeviceProp_t*>self._ptr)[i]``.
        """
        (<chip.hipDeviceProp_t*>self._ptr)[i].concurrentKernels = value
    @property
    def concurrentKernels(self):
        """Device can possibly execute multiple kernels concurrently."""
        return self.get_concurrentKernels(0)
    @concurrentKernels.setter
    def concurrentKernels(self, int value):
        self.set_concurrentKernels(0,value)

    def get_ECCEnabled(self, i):
        """Get value ``ECCEnabled`` of ``(<chip.hipDeviceProp_t*>self._ptr)[i]``.
        """
        return (<chip.hipDeviceProp_t*>self._ptr)[i].ECCEnabled
    def set_ECCEnabled(self, i, int value):
        """Set value ``ECCEnabled`` of ``(<chip.hipDeviceProp_t*>self._ptr)[i]``.
        """
        (<chip.hipDeviceProp_t*>self._ptr)[i].ECCEnabled = value
    @property
    def ECCEnabled(self):
        """Device has ECC support enabled"""
        return self.get_ECCEnabled(0)
    @ECCEnabled.setter
    def ECCEnabled(self, int value):
        self.set_ECCEnabled(0,value)

    def get_pciBusID(self, i):
        """Get value ``pciBusID`` of ``(<chip.hipDeviceProp_t*>self._ptr)[i]``.
        """
        return (<chip.hipDeviceProp_t*>self._ptr)[i].pciBusID
    def set_pciBusID(self, i, int value):
        """Set value ``pciBusID`` of ``(<chip.hipDeviceProp_t*>self._ptr)[i]``.
        """
        (<chip.hipDeviceProp_t*>self._ptr)[i].pciBusID = value
    @property
    def pciBusID(self):
        """PCI Bus ID."""
        return self.get_pciBusID(0)
    @pciBusID.setter
    def pciBusID(self, int value):
        self.set_pciBusID(0,value)

    def get_pciDeviceID(self, i):
        """Get value ``pciDeviceID`` of ``(<chip.hipDeviceProp_t*>self._ptr)[i]``.
        """
        return (<chip.hipDeviceProp_t*>self._ptr)[i].pciDeviceID
    def set_pciDeviceID(self, i, int value):
        """Set value ``pciDeviceID`` of ``(<chip.hipDeviceProp_t*>self._ptr)[i]``.
        """
        (<chip.hipDeviceProp_t*>self._ptr)[i].pciDeviceID = value
    @property
    def pciDeviceID(self):
        """PCI Device ID."""
        return self.get_pciDeviceID(0)
    @pciDeviceID.setter
    def pciDeviceID(self, int value):
        self.set_pciDeviceID(0,value)

    def get_pciDomainID(self, i):
        """Get value ``pciDomainID`` of ``(<chip.hipDeviceProp_t*>self._ptr)[i]``.
        """
        return (<chip.hipDeviceProp_t*>self._ptr)[i].pciDomainID
    def set_pciDomainID(self, i, int value):
        """Set value ``pciDomainID`` of ``(<chip.hipDeviceProp_t*>self._ptr)[i]``.
        """
        (<chip.hipDeviceProp_t*>self._ptr)[i].pciDomainID = value
    @property
    def pciDomainID(self):
        """PCI Domain ID"""
        return self.get_pciDomainID(0)
    @pciDomainID.setter
    def pciDomainID(self, int value):
        self.set_pciDomainID(0,value)

    def get_tccDriver(self, i):
        """Get value ``tccDriver`` of ``(<chip.hipDeviceProp_t*>self._ptr)[i]``.
        """
        return (<chip.hipDeviceProp_t*>self._ptr)[i].tccDriver
    def set_tccDriver(self, i, int value):
        """Set value ``tccDriver`` of ``(<chip.hipDeviceProp_t*>self._ptr)[i]``.
        """
        (<chip.hipDeviceProp_t*>self._ptr)[i].tccDriver = value
    @property
    def tccDriver(self):
        """1:If device is Tesla device using TCC driver, else 0"""
        return self.get_tccDriver(0)
    @tccDriver.setter
    def tccDriver(self, int value):
        self.set_tccDriver(0,value)

    def get_asyncEngineCount(self, i):
        """Get value ``asyncEngineCount`` of ``(<chip.hipDeviceProp_t*>self._ptr)[i]``.
        """
        return (<chip.hipDeviceProp_t*>self._ptr)[i].asyncEngineCount
    def set_asyncEngineCount(self, i, int value):
        """Set value ``asyncEngineCount`` of ``(<chip.hipDeviceProp_t*>self._ptr)[i]``.
        """
        (<chip.hipDeviceProp_t*>self._ptr)[i].asyncEngineCount = value
    @property
    def asyncEngineCount(self):
        """Number of async engines"""
        return self.get_asyncEngineCount(0)
    @asyncEngineCount.setter
    def asyncEngineCount(self, int value):
        self.set_asyncEngineCount(0,value)

    def get_unifiedAddressing(self, i):
        """Get value ``unifiedAddressing`` of ``(<chip.hipDeviceProp_t*>self._ptr)[i]``.
        """
        return (<chip.hipDeviceProp_t*>self._ptr)[i].unifiedAddressing
    def set_unifiedAddressing(self, i, int value):
        """Set value ``unifiedAddressing`` of ``(<chip.hipDeviceProp_t*>self._ptr)[i]``.
        """
        (<chip.hipDeviceProp_t*>self._ptr)[i].unifiedAddressing = value
    @property
    def unifiedAddressing(self):
        """Does device and host share unified address space"""
        return self.get_unifiedAddressing(0)
    @unifiedAddressing.setter
    def unifiedAddressing(self, int value):
        self.set_unifiedAddressing(0,value)

    def get_memoryClockRate(self, i):
        """Get value ``memoryClockRate`` of ``(<chip.hipDeviceProp_t*>self._ptr)[i]``.
        """
        return (<chip.hipDeviceProp_t*>self._ptr)[i].memoryClockRate
    def set_memoryClockRate(self, i, int value):
        """Set value ``memoryClockRate`` of ``(<chip.hipDeviceProp_t*>self._ptr)[i]``.
        """
        (<chip.hipDeviceProp_t*>self._ptr)[i].memoryClockRate = value
    @property
    def memoryClockRate(self):
        """Max global memory clock frequency in khz."""
        return self.get_memoryClockRate(0)
    @memoryClockRate.setter
    def memoryClockRate(self, int value):
        self.set_memoryClockRate(0,value)

    def get_memoryBusWidth(self, i):
        """Get value ``memoryBusWidth`` of ``(<chip.hipDeviceProp_t*>self._ptr)[i]``.
        """
        return (<chip.hipDeviceProp_t*>self._ptr)[i].memoryBusWidth
    def set_memoryBusWidth(self, i, int value):
        """Set value ``memoryBusWidth`` of ``(<chip.hipDeviceProp_t*>self._ptr)[i]``.
        """
        (<chip.hipDeviceProp_t*>self._ptr)[i].memoryBusWidth = value
    @property
    def memoryBusWidth(self):
        """Global memory bus width in bits."""
        return self.get_memoryBusWidth(0)
    @memoryBusWidth.setter
    def memoryBusWidth(self, int value):
        self.set_memoryBusWidth(0,value)

    def get_l2CacheSize(self, i):
        """Get value ``l2CacheSize`` of ``(<chip.hipDeviceProp_t*>self._ptr)[i]``.
        """
        return (<chip.hipDeviceProp_t*>self._ptr)[i].l2CacheSize
    def set_l2CacheSize(self, i, int value):
        """Set value ``l2CacheSize`` of ``(<chip.hipDeviceProp_t*>self._ptr)[i]``.
        """
        (<chip.hipDeviceProp_t*>self._ptr)[i].l2CacheSize = value
    @property
    def l2CacheSize(self):
        """L2 cache size."""
        return self.get_l2CacheSize(0)
    @l2CacheSize.setter
    def l2CacheSize(self, int value):
        self.set_l2CacheSize(0,value)

    def get_persistingL2CacheMaxSize(self, i):
        """Get value ``persistingL2CacheMaxSize`` of ``(<chip.hipDeviceProp_t*>self._ptr)[i]``.
        """
        return (<chip.hipDeviceProp_t*>self._ptr)[i].persistingL2CacheMaxSize
    def set_persistingL2CacheMaxSize(self, i, int value):
        """Set value ``persistingL2CacheMaxSize`` of ``(<chip.hipDeviceProp_t*>self._ptr)[i]``.
        """
        (<chip.hipDeviceProp_t*>self._ptr)[i].persistingL2CacheMaxSize = value
    @property
    def persistingL2CacheMaxSize(self):
        """Device's max L2 persisting lines in bytes"""
        return self.get_persistingL2CacheMaxSize(0)
    @persistingL2CacheMaxSize.setter
    def persistingL2CacheMaxSize(self, int value):
        self.set_persistingL2CacheMaxSize(0,value)

    def get_maxThreadsPerMultiProcessor(self, i):
        """Get value ``maxThreadsPerMultiProcessor`` of ``(<chip.hipDeviceProp_t*>self._ptr)[i]``.
        """
        return (<chip.hipDeviceProp_t*>self._ptr)[i].maxThreadsPerMultiProcessor
    def set_maxThreadsPerMultiProcessor(self, i, int value):
        """Set value ``maxThreadsPerMultiProcessor`` of ``(<chip.hipDeviceProp_t*>self._ptr)[i]``.
        """
        (<chip.hipDeviceProp_t*>self._ptr)[i].maxThreadsPerMultiProcessor = value
    @property
    def maxThreadsPerMultiProcessor(self):
        """Maximum resident threads per multi-processor."""
        return self.get_maxThreadsPerMultiProcessor(0)
    @maxThreadsPerMultiProcessor.setter
    def maxThreadsPerMultiProcessor(self, int value):
        self.set_maxThreadsPerMultiProcessor(0,value)

    def get_streamPrioritiesSupported(self, i):
        """Get value ``streamPrioritiesSupported`` of ``(<chip.hipDeviceProp_t*>self._ptr)[i]``.
        """
        return (<chip.hipDeviceProp_t*>self._ptr)[i].streamPrioritiesSupported
    def set_streamPrioritiesSupported(self, i, int value):
        """Set value ``streamPrioritiesSupported`` of ``(<chip.hipDeviceProp_t*>self._ptr)[i]``.
        """
        (<chip.hipDeviceProp_t*>self._ptr)[i].streamPrioritiesSupported = value
    @property
    def streamPrioritiesSupported(self):
        """Device supports stream priority"""
        return self.get_streamPrioritiesSupported(0)
    @streamPrioritiesSupported.setter
    def streamPrioritiesSupported(self, int value):
        self.set_streamPrioritiesSupported(0,value)

    def get_globalL1CacheSupported(self, i):
        """Get value ``globalL1CacheSupported`` of ``(<chip.hipDeviceProp_t*>self._ptr)[i]``.
        """
        return (<chip.hipDeviceProp_t*>self._ptr)[i].globalL1CacheSupported
    def set_globalL1CacheSupported(self, i, int value):
        """Set value ``globalL1CacheSupported`` of ``(<chip.hipDeviceProp_t*>self._ptr)[i]``.
        """
        (<chip.hipDeviceProp_t*>self._ptr)[i].globalL1CacheSupported = value
    @property
    def globalL1CacheSupported(self):
        """Indicates globals are cached in L1"""
        return self.get_globalL1CacheSupported(0)
    @globalL1CacheSupported.setter
    def globalL1CacheSupported(self, int value):
        self.set_globalL1CacheSupported(0,value)

    def get_localL1CacheSupported(self, i):
        """Get value ``localL1CacheSupported`` of ``(<chip.hipDeviceProp_t*>self._ptr)[i]``.
        """
        return (<chip.hipDeviceProp_t*>self._ptr)[i].localL1CacheSupported
    def set_localL1CacheSupported(self, i, int value):
        """Set value ``localL1CacheSupported`` of ``(<chip.hipDeviceProp_t*>self._ptr)[i]``.
        """
        (<chip.hipDeviceProp_t*>self._ptr)[i].localL1CacheSupported = value
    @property
    def localL1CacheSupported(self):
        """Locals are cahced in L1"""
        return self.get_localL1CacheSupported(0)
    @localL1CacheSupported.setter
    def localL1CacheSupported(self, int value):
        self.set_localL1CacheSupported(0,value)

    def get_sharedMemPerMultiprocessor(self, i):
        """Get value ``sharedMemPerMultiprocessor`` of ``(<chip.hipDeviceProp_t*>self._ptr)[i]``.
        """
        return (<chip.hipDeviceProp_t*>self._ptr)[i].sharedMemPerMultiprocessor
    def set_sharedMemPerMultiprocessor(self, i, unsigned long value):
        """Set value ``sharedMemPerMultiprocessor`` of ``(<chip.hipDeviceProp_t*>self._ptr)[i]``.
        """
        (<chip.hipDeviceProp_t*>self._ptr)[i].sharedMemPerMultiprocessor = value
    @property
    def sharedMemPerMultiprocessor(self):
        """Amount of shared memory available per multiprocessor."""
        return self.get_sharedMemPerMultiprocessor(0)
    @sharedMemPerMultiprocessor.setter
    def sharedMemPerMultiprocessor(self, unsigned long value):
        self.set_sharedMemPerMultiprocessor(0,value)

    def get_regsPerMultiprocessor(self, i):
        """Get value ``regsPerMultiprocessor`` of ``(<chip.hipDeviceProp_t*>self._ptr)[i]``.
        """
        return (<chip.hipDeviceProp_t*>self._ptr)[i].regsPerMultiprocessor
    def set_regsPerMultiprocessor(self, i, int value):
        """Set value ``regsPerMultiprocessor`` of ``(<chip.hipDeviceProp_t*>self._ptr)[i]``.
        """
        (<chip.hipDeviceProp_t*>self._ptr)[i].regsPerMultiprocessor = value
    @property
    def regsPerMultiprocessor(self):
        """registers available per multiprocessor"""
        return self.get_regsPerMultiprocessor(0)
    @regsPerMultiprocessor.setter
    def regsPerMultiprocessor(self, int value):
        self.set_regsPerMultiprocessor(0,value)

    def get_managedMemory(self, i):
        """Get value ``managedMemory`` of ``(<chip.hipDeviceProp_t*>self._ptr)[i]``.
        """
        return (<chip.hipDeviceProp_t*>self._ptr)[i].managedMemory
    def set_managedMemory(self, i, int value):
        """Set value ``managedMemory`` of ``(<chip.hipDeviceProp_t*>self._ptr)[i]``.
        """
        (<chip.hipDeviceProp_t*>self._ptr)[i].managedMemory = value
    @property
    def managedMemory(self):
        """Device supports allocating managed memory on this system"""
        return self.get_managedMemory(0)
    @managedMemory.setter
    def managedMemory(self, int value):
        self.set_managedMemory(0,value)

    def get_isMultiGpuBoard(self, i):
        """Get value ``isMultiGpuBoard`` of ``(<chip.hipDeviceProp_t*>self._ptr)[i]``.
        """
        return (<chip.hipDeviceProp_t*>self._ptr)[i].isMultiGpuBoard
    def set_isMultiGpuBoard(self, i, int value):
        """Set value ``isMultiGpuBoard`` of ``(<chip.hipDeviceProp_t*>self._ptr)[i]``.
        """
        (<chip.hipDeviceProp_t*>self._ptr)[i].isMultiGpuBoard = value
    @property
    def isMultiGpuBoard(self):
        """1 if device is on a multi-GPU board, 0 if not."""
        return self.get_isMultiGpuBoard(0)
    @isMultiGpuBoard.setter
    def isMultiGpuBoard(self, int value):
        self.set_isMultiGpuBoard(0,value)

    def get_multiGpuBoardGroupID(self, i):
        """Get value ``multiGpuBoardGroupID`` of ``(<chip.hipDeviceProp_t*>self._ptr)[i]``.
        """
        return (<chip.hipDeviceProp_t*>self._ptr)[i].multiGpuBoardGroupID
    def set_multiGpuBoardGroupID(self, i, int value):
        """Set value ``multiGpuBoardGroupID`` of ``(<chip.hipDeviceProp_t*>self._ptr)[i]``.
        """
        (<chip.hipDeviceProp_t*>self._ptr)[i].multiGpuBoardGroupID = value
    @property
    def multiGpuBoardGroupID(self):
        """Unique identifier for a group of devices on same multiboard GPU"""
        return self.get_multiGpuBoardGroupID(0)
    @multiGpuBoardGroupID.setter
    def multiGpuBoardGroupID(self, int value):
        self.set_multiGpuBoardGroupID(0,value)

    def get_hostNativeAtomicSupported(self, i):
        """Get value ``hostNativeAtomicSupported`` of ``(<chip.hipDeviceProp_t*>self._ptr)[i]``.
        """
        return (<chip.hipDeviceProp_t*>self._ptr)[i].hostNativeAtomicSupported
    def set_hostNativeAtomicSupported(self, i, int value):
        """Set value ``hostNativeAtomicSupported`` of ``(<chip.hipDeviceProp_t*>self._ptr)[i]``.
        """
        (<chip.hipDeviceProp_t*>self._ptr)[i].hostNativeAtomicSupported = value
    @property
    def hostNativeAtomicSupported(self):
        """Link between host and device supports native atomics"""
        return self.get_hostNativeAtomicSupported(0)
    @hostNativeAtomicSupported.setter
    def hostNativeAtomicSupported(self, int value):
        self.set_hostNativeAtomicSupported(0,value)

    def get_singleToDoublePrecisionPerfRatio(self, i):
        """Get value ``singleToDoublePrecisionPerfRatio`` of ``(<chip.hipDeviceProp_t*>self._ptr)[i]``.
        """
        return (<chip.hipDeviceProp_t*>self._ptr)[i].singleToDoublePrecisionPerfRatio
    def set_singleToDoublePrecisionPerfRatio(self, i, int value):
        """Set value ``singleToDoublePrecisionPerfRatio`` of ``(<chip.hipDeviceProp_t*>self._ptr)[i]``.
        """
        (<chip.hipDeviceProp_t*>self._ptr)[i].singleToDoublePrecisionPerfRatio = value
    @property
    def singleToDoublePrecisionPerfRatio(self):
        """Deprecated. CUDA only."""
        return self.get_singleToDoublePrecisionPerfRatio(0)
    @singleToDoublePrecisionPerfRatio.setter
    def singleToDoublePrecisionPerfRatio(self, int value):
        self.set_singleToDoublePrecisionPerfRatio(0,value)

    def get_pageableMemoryAccess(self, i):
        """Get value ``pageableMemoryAccess`` of ``(<chip.hipDeviceProp_t*>self._ptr)[i]``.
        """
        return (<chip.hipDeviceProp_t*>self._ptr)[i].pageableMemoryAccess
    def set_pageableMemoryAccess(self, i, int value):
        """Set value ``pageableMemoryAccess`` of ``(<chip.hipDeviceProp_t*>self._ptr)[i]``.
        """
        (<chip.hipDeviceProp_t*>self._ptr)[i].pageableMemoryAccess = value
    @property
    def pageableMemoryAccess(self):
        """Device supports coherently accessing pageable memory without calling hipHostRegister on it"""
        return self.get_pageableMemoryAccess(0)
    @pageableMemoryAccess.setter
    def pageableMemoryAccess(self, int value):
        self.set_pageableMemoryAccess(0,value)

    def get_concurrentManagedAccess(self, i):
        """Get value ``concurrentManagedAccess`` of ``(<chip.hipDeviceProp_t*>self._ptr)[i]``.
        """
        return (<chip.hipDeviceProp_t*>self._ptr)[i].concurrentManagedAccess
    def set_concurrentManagedAccess(self, i, int value):
        """Set value ``concurrentManagedAccess`` of ``(<chip.hipDeviceProp_t*>self._ptr)[i]``.
        """
        (<chip.hipDeviceProp_t*>self._ptr)[i].concurrentManagedAccess = value
    @property
    def concurrentManagedAccess(self):
        """Device can coherently access managed memory concurrently with the CPU"""
        return self.get_concurrentManagedAccess(0)
    @concurrentManagedAccess.setter
    def concurrentManagedAccess(self, int value):
        self.set_concurrentManagedAccess(0,value)

    def get_computePreemptionSupported(self, i):
        """Get value ``computePreemptionSupported`` of ``(<chip.hipDeviceProp_t*>self._ptr)[i]``.
        """
        return (<chip.hipDeviceProp_t*>self._ptr)[i].computePreemptionSupported
    def set_computePreemptionSupported(self, i, int value):
        """Set value ``computePreemptionSupported`` of ``(<chip.hipDeviceProp_t*>self._ptr)[i]``.
        """
        (<chip.hipDeviceProp_t*>self._ptr)[i].computePreemptionSupported = value
    @property
    def computePreemptionSupported(self):
        """Is compute preemption supported on the device"""
        return self.get_computePreemptionSupported(0)
    @computePreemptionSupported.setter
    def computePreemptionSupported(self, int value):
        self.set_computePreemptionSupported(0,value)

    def get_canUseHostPointerForRegisteredMem(self, i):
        """Get value ``canUseHostPointerForRegisteredMem`` of ``(<chip.hipDeviceProp_t*>self._ptr)[i]``.
        """
        return (<chip.hipDeviceProp_t*>self._ptr)[i].canUseHostPointerForRegisteredMem
    def set_canUseHostPointerForRegisteredMem(self, i, int value):
        """Set value ``canUseHostPointerForRegisteredMem`` of ``(<chip.hipDeviceProp_t*>self._ptr)[i]``.
        """
        (<chip.hipDeviceProp_t*>self._ptr)[i].canUseHostPointerForRegisteredMem = value
    @property
    def canUseHostPointerForRegisteredMem(self):
        """Device can access host registered memory with same address as the host"""
        return self.get_canUseHostPointerForRegisteredMem(0)
    @canUseHostPointerForRegisteredMem.setter
    def canUseHostPointerForRegisteredMem(self, int value):
        self.set_canUseHostPointerForRegisteredMem(0,value)

    def get_cooperativeLaunch(self, i):
        """Get value ``cooperativeLaunch`` of ``(<chip.hipDeviceProp_t*>self._ptr)[i]``.
        """
        return (<chip.hipDeviceProp_t*>self._ptr)[i].cooperativeLaunch
    def set_cooperativeLaunch(self, i, int value):
        """Set value ``cooperativeLaunch`` of ``(<chip.hipDeviceProp_t*>self._ptr)[i]``.
        """
        (<chip.hipDeviceProp_t*>self._ptr)[i].cooperativeLaunch = value
    @property
    def cooperativeLaunch(self):
        """HIP device supports cooperative launch"""
        return self.get_cooperativeLaunch(0)
    @cooperativeLaunch.setter
    def cooperativeLaunch(self, int value):
        self.set_cooperativeLaunch(0,value)

    def get_cooperativeMultiDeviceLaunch(self, i):
        """Get value ``cooperativeMultiDeviceLaunch`` of ``(<chip.hipDeviceProp_t*>self._ptr)[i]``.
        """
        return (<chip.hipDeviceProp_t*>self._ptr)[i].cooperativeMultiDeviceLaunch
    def set_cooperativeMultiDeviceLaunch(self, i, int value):
        """Set value ``cooperativeMultiDeviceLaunch`` of ``(<chip.hipDeviceProp_t*>self._ptr)[i]``.
        """
        (<chip.hipDeviceProp_t*>self._ptr)[i].cooperativeMultiDeviceLaunch = value
    @property
    def cooperativeMultiDeviceLaunch(self):
        """HIP device supports cooperative launch on multiple devices"""
        return self.get_cooperativeMultiDeviceLaunch(0)
    @cooperativeMultiDeviceLaunch.setter
    def cooperativeMultiDeviceLaunch(self, int value):
        self.set_cooperativeMultiDeviceLaunch(0,value)

    def get_sharedMemPerBlockOptin(self, i):
        """Get value ``sharedMemPerBlockOptin`` of ``(<chip.hipDeviceProp_t*>self._ptr)[i]``.
        """
        return (<chip.hipDeviceProp_t*>self._ptr)[i].sharedMemPerBlockOptin
    def set_sharedMemPerBlockOptin(self, i, unsigned long value):
        """Set value ``sharedMemPerBlockOptin`` of ``(<chip.hipDeviceProp_t*>self._ptr)[i]``.
        """
        (<chip.hipDeviceProp_t*>self._ptr)[i].sharedMemPerBlockOptin = value
    @property
    def sharedMemPerBlockOptin(self):
        """Per device m ax shared mem per block usable by special opt in"""
        return self.get_sharedMemPerBlockOptin(0)
    @sharedMemPerBlockOptin.setter
    def sharedMemPerBlockOptin(self, unsigned long value):
        self.set_sharedMemPerBlockOptin(0,value)

    def get_pageableMemoryAccessUsesHostPageTables(self, i):
        """Get value ``pageableMemoryAccessUsesHostPageTables`` of ``(<chip.hipDeviceProp_t*>self._ptr)[i]``.
        """
        return (<chip.hipDeviceProp_t*>self._ptr)[i].pageableMemoryAccessUsesHostPageTables
    def set_pageableMemoryAccessUsesHostPageTables(self, i, int value):
        """Set value ``pageableMemoryAccessUsesHostPageTables`` of ``(<chip.hipDeviceProp_t*>self._ptr)[i]``.
        """
        (<chip.hipDeviceProp_t*>self._ptr)[i].pageableMemoryAccessUsesHostPageTables = value
    @property
    def pageableMemoryAccessUsesHostPageTables(self):
        """Device accesses pageable memory via the host's page tables"""
        return self.get_pageableMemoryAccessUsesHostPageTables(0)
    @pageableMemoryAccessUsesHostPageTables.setter
    def pageableMemoryAccessUsesHostPageTables(self, int value):
        self.set_pageableMemoryAccessUsesHostPageTables(0,value)

    def get_directManagedMemAccessFromHost(self, i):
        """Get value ``directManagedMemAccessFromHost`` of ``(<chip.hipDeviceProp_t*>self._ptr)[i]``.
        """
        return (<chip.hipDeviceProp_t*>self._ptr)[i].directManagedMemAccessFromHost
    def set_directManagedMemAccessFromHost(self, i, int value):
        """Set value ``directManagedMemAccessFromHost`` of ``(<chip.hipDeviceProp_t*>self._ptr)[i]``.
        """
        (<chip.hipDeviceProp_t*>self._ptr)[i].directManagedMemAccessFromHost = value
    @property
    def directManagedMemAccessFromHost(self):
        """Host can directly access managed memory on the device without migration"""
        return self.get_directManagedMemAccessFromHost(0)
    @directManagedMemAccessFromHost.setter
    def directManagedMemAccessFromHost(self, int value):
        self.set_directManagedMemAccessFromHost(0,value)

    def get_maxBlocksPerMultiProcessor(self, i):
        """Get value ``maxBlocksPerMultiProcessor`` of ``(<chip.hipDeviceProp_t*>self._ptr)[i]``.
        """
        return (<chip.hipDeviceProp_t*>self._ptr)[i].maxBlocksPerMultiProcessor
    def set_maxBlocksPerMultiProcessor(self, i, int value):
        """Set value ``maxBlocksPerMultiProcessor`` of ``(<chip.hipDeviceProp_t*>self._ptr)[i]``.
        """
        (<chip.hipDeviceProp_t*>self._ptr)[i].maxBlocksPerMultiProcessor = value
    @property
    def maxBlocksPerMultiProcessor(self):
        """Max number of blocks on CU"""
        return self.get_maxBlocksPerMultiProcessor(0)
    @maxBlocksPerMultiProcessor.setter
    def maxBlocksPerMultiProcessor(self, int value):
        self.set_maxBlocksPerMultiProcessor(0,value)

    def get_accessPolicyMaxWindowSize(self, i):
        """Get value ``accessPolicyMaxWindowSize`` of ``(<chip.hipDeviceProp_t*>self._ptr)[i]``.
        """
        return (<chip.hipDeviceProp_t*>self._ptr)[i].accessPolicyMaxWindowSize
    def set_accessPolicyMaxWindowSize(self, i, int value):
        """Set value ``accessPolicyMaxWindowSize`` of ``(<chip.hipDeviceProp_t*>self._ptr)[i]``.
        """
        (<chip.hipDeviceProp_t*>self._ptr)[i].accessPolicyMaxWindowSize = value
    @property
    def accessPolicyMaxWindowSize(self):
        """Max value of access policy window"""
        return self.get_accessPolicyMaxWindowSize(0)
    @accessPolicyMaxWindowSize.setter
    def accessPolicyMaxWindowSize(self, int value):
        self.set_accessPolicyMaxWindowSize(0,value)

    def get_reservedSharedMemPerBlock(self, i):
        """Get value ``reservedSharedMemPerBlock`` of ``(<chip.hipDeviceProp_t*>self._ptr)[i]``.
        """
        return (<chip.hipDeviceProp_t*>self._ptr)[i].reservedSharedMemPerBlock
    def set_reservedSharedMemPerBlock(self, i, unsigned long value):
        """Set value ``reservedSharedMemPerBlock`` of ``(<chip.hipDeviceProp_t*>self._ptr)[i]``.
        """
        (<chip.hipDeviceProp_t*>self._ptr)[i].reservedSharedMemPerBlock = value
    @property
    def reservedSharedMemPerBlock(self):
        """Shared memory reserved by driver per block"""
        return self.get_reservedSharedMemPerBlock(0)
    @reservedSharedMemPerBlock.setter
    def reservedSharedMemPerBlock(self, unsigned long value):
        self.set_reservedSharedMemPerBlock(0,value)

    def get_hostRegisterSupported(self, i):
        """Get value ``hostRegisterSupported`` of ``(<chip.hipDeviceProp_t*>self._ptr)[i]``.
        """
        return (<chip.hipDeviceProp_t*>self._ptr)[i].hostRegisterSupported
    def set_hostRegisterSupported(self, i, int value):
        """Set value ``hostRegisterSupported`` of ``(<chip.hipDeviceProp_t*>self._ptr)[i]``.
        """
        (<chip.hipDeviceProp_t*>self._ptr)[i].hostRegisterSupported = value
    @property
    def hostRegisterSupported(self):
        """Device supports hipHostRegister"""
        return self.get_hostRegisterSupported(0)
    @hostRegisterSupported.setter
    def hostRegisterSupported(self, int value):
        self.set_hostRegisterSupported(0,value)

    def get_sparseHipArraySupported(self, i):
        """Get value ``sparseHipArraySupported`` of ``(<chip.hipDeviceProp_t*>self._ptr)[i]``.
        """
        return (<chip.hipDeviceProp_t*>self._ptr)[i].sparseHipArraySupported
    def set_sparseHipArraySupported(self, i, int value):
        """Set value ``sparseHipArraySupported`` of ``(<chip.hipDeviceProp_t*>self._ptr)[i]``.
        """
        (<chip.hipDeviceProp_t*>self._ptr)[i].sparseHipArraySupported = value
    @property
    def sparseHipArraySupported(self):
        """Indicates if device supports sparse hip arrays"""
        return self.get_sparseHipArraySupported(0)
    @sparseHipArraySupported.setter
    def sparseHipArraySupported(self, int value):
        self.set_sparseHipArraySupported(0,value)

    def get_hostRegisterReadOnlySupported(self, i):
        """Get value ``hostRegisterReadOnlySupported`` of ``(<chip.hipDeviceProp_t*>self._ptr)[i]``.
        """
        return (<chip.hipDeviceProp_t*>self._ptr)[i].hostRegisterReadOnlySupported
    def set_hostRegisterReadOnlySupported(self, i, int value):
        """Set value ``hostRegisterReadOnlySupported`` of ``(<chip.hipDeviceProp_t*>self._ptr)[i]``.
        """
        (<chip.hipDeviceProp_t*>self._ptr)[i].hostRegisterReadOnlySupported = value
    @property
    def hostRegisterReadOnlySupported(self):
        """Device supports using the hipHostRegisterReadOnly flag with hipHostRegistger"""
        return self.get_hostRegisterReadOnlySupported(0)
    @hostRegisterReadOnlySupported.setter
    def hostRegisterReadOnlySupported(self, int value):
        self.set_hostRegisterReadOnlySupported(0,value)

    def get_timelineSemaphoreInteropSupported(self, i):
        """Get value ``timelineSemaphoreInteropSupported`` of ``(<chip.hipDeviceProp_t*>self._ptr)[i]``.
        """
        return (<chip.hipDeviceProp_t*>self._ptr)[i].timelineSemaphoreInteropSupported
    def set_timelineSemaphoreInteropSupported(self, i, int value):
        """Set value ``timelineSemaphoreInteropSupported`` of ``(<chip.hipDeviceProp_t*>self._ptr)[i]``.
        """
        (<chip.hipDeviceProp_t*>self._ptr)[i].timelineSemaphoreInteropSupported = value
    @property
    def timelineSemaphoreInteropSupported(self):
        """Indicates external timeline semaphore support"""
        return self.get_timelineSemaphoreInteropSupported(0)
    @timelineSemaphoreInteropSupported.setter
    def timelineSemaphoreInteropSupported(self, int value):
        self.set_timelineSemaphoreInteropSupported(0,value)

    def get_memoryPoolsSupported(self, i):
        """Get value ``memoryPoolsSupported`` of ``(<chip.hipDeviceProp_t*>self._ptr)[i]``.
        """
        return (<chip.hipDeviceProp_t*>self._ptr)[i].memoryPoolsSupported
    def set_memoryPoolsSupported(self, i, int value):
        """Set value ``memoryPoolsSupported`` of ``(<chip.hipDeviceProp_t*>self._ptr)[i]``.
        """
        (<chip.hipDeviceProp_t*>self._ptr)[i].memoryPoolsSupported = value
    @property
    def memoryPoolsSupported(self):
        """Indicates if device supports hipMallocAsync and hipMemPool APIs"""
        return self.get_memoryPoolsSupported(0)
    @memoryPoolsSupported.setter
    def memoryPoolsSupported(self, int value):
        self.set_memoryPoolsSupported(0,value)

    def get_gpuDirectRDMASupported(self, i):
        """Get value ``gpuDirectRDMASupported`` of ``(<chip.hipDeviceProp_t*>self._ptr)[i]``.
        """
        return (<chip.hipDeviceProp_t*>self._ptr)[i].gpuDirectRDMASupported
    def set_gpuDirectRDMASupported(self, i, int value):
        """Set value ``gpuDirectRDMASupported`` of ``(<chip.hipDeviceProp_t*>self._ptr)[i]``.
        """
        (<chip.hipDeviceProp_t*>self._ptr)[i].gpuDirectRDMASupported = value
    @property
    def gpuDirectRDMASupported(self):
        """Indicates device support of RDMA APIs"""
        return self.get_gpuDirectRDMASupported(0)
    @gpuDirectRDMASupported.setter
    def gpuDirectRDMASupported(self, int value):
        self.set_gpuDirectRDMASupported(0,value)

    def get_gpuDirectRDMAFlushWritesOptions(self, i):
        """Get value ``gpuDirectRDMAFlushWritesOptions`` of ``(<chip.hipDeviceProp_t*>self._ptr)[i]``.
        """
        return (<chip.hipDeviceProp_t*>self._ptr)[i].gpuDirectRDMAFlushWritesOptions
    def set_gpuDirectRDMAFlushWritesOptions(self, i, unsigned int value):
        """Set value ``gpuDirectRDMAFlushWritesOptions`` of ``(<chip.hipDeviceProp_t*>self._ptr)[i]``.
        """
        (<chip.hipDeviceProp_t*>self._ptr)[i].gpuDirectRDMAFlushWritesOptions = value
    @property
    def gpuDirectRDMAFlushWritesOptions(self):
        """Bitmask to be interpreted according to hipFlushGPUDirectRDMAWritesOptions"""
        return self.get_gpuDirectRDMAFlushWritesOptions(0)
    @gpuDirectRDMAFlushWritesOptions.setter
    def gpuDirectRDMAFlushWritesOptions(self, unsigned int value):
        self.set_gpuDirectRDMAFlushWritesOptions(0,value)

    def get_gpuDirectRDMAWritesOrdering(self, i):
        """Get value ``gpuDirectRDMAWritesOrdering`` of ``(<chip.hipDeviceProp_t*>self._ptr)[i]``.
        """
        return (<chip.hipDeviceProp_t*>self._ptr)[i].gpuDirectRDMAWritesOrdering
    def set_gpuDirectRDMAWritesOrdering(self, i, int value):
        """Set value ``gpuDirectRDMAWritesOrdering`` of ``(<chip.hipDeviceProp_t*>self._ptr)[i]``.
        """
        (<chip.hipDeviceProp_t*>self._ptr)[i].gpuDirectRDMAWritesOrdering = value
    @property
    def gpuDirectRDMAWritesOrdering(self):
        """value of hipGPUDirectRDMAWritesOrdering"""
        return self.get_gpuDirectRDMAWritesOrdering(0)
    @gpuDirectRDMAWritesOrdering.setter
    def gpuDirectRDMAWritesOrdering(self, int value):
        self.set_gpuDirectRDMAWritesOrdering(0,value)

    def get_memoryPoolSupportedHandleTypes(self, i):
        """Get value ``memoryPoolSupportedHandleTypes`` of ``(<chip.hipDeviceProp_t*>self._ptr)[i]``.
        """
        return (<chip.hipDeviceProp_t*>self._ptr)[i].memoryPoolSupportedHandleTypes
    def set_memoryPoolSupportedHandleTypes(self, i, unsigned int value):
        """Set value ``memoryPoolSupportedHandleTypes`` of ``(<chip.hipDeviceProp_t*>self._ptr)[i]``.
        """
        (<chip.hipDeviceProp_t*>self._ptr)[i].memoryPoolSupportedHandleTypes = value
    @property
    def memoryPoolSupportedHandleTypes(self):
        """Bitmask of handle types support with mempool based IPC"""
        return self.get_memoryPoolSupportedHandleTypes(0)
    @memoryPoolSupportedHandleTypes.setter
    def memoryPoolSupportedHandleTypes(self, unsigned int value):
        self.set_memoryPoolSupportedHandleTypes(0,value)

    def get_deferredMappingHipArraySupported(self, i):
        """Get value ``deferredMappingHipArraySupported`` of ``(<chip.hipDeviceProp_t*>self._ptr)[i]``.
        """
        return (<chip.hipDeviceProp_t*>self._ptr)[i].deferredMappingHipArraySupported
    def set_deferredMappingHipArraySupported(self, i, int value):
        """Set value ``deferredMappingHipArraySupported`` of ``(<chip.hipDeviceProp_t*>self._ptr)[i]``.
        """
        (<chip.hipDeviceProp_t*>self._ptr)[i].deferredMappingHipArraySupported = value
    @property
    def deferredMappingHipArraySupported(self):
        """Device supports deferred mapping HIP arrays and HIP mipmapped arrays"""
        return self.get_deferredMappingHipArraySupported(0)
    @deferredMappingHipArraySupported.setter
    def deferredMappingHipArraySupported(self, int value):
        self.set_deferredMappingHipArraySupported(0,value)

    def get_ipcEventSupported(self, i):
        """Get value ``ipcEventSupported`` of ``(<chip.hipDeviceProp_t*>self._ptr)[i]``.
        """
        return (<chip.hipDeviceProp_t*>self._ptr)[i].ipcEventSupported
    def set_ipcEventSupported(self, i, int value):
        """Set value ``ipcEventSupported`` of ``(<chip.hipDeviceProp_t*>self._ptr)[i]``.
        """
        (<chip.hipDeviceProp_t*>self._ptr)[i].ipcEventSupported = value
    @property
    def ipcEventSupported(self):
        """Device supports IPC events"""
        return self.get_ipcEventSupported(0)
    @ipcEventSupported.setter
    def ipcEventSupported(self, int value):
        self.set_ipcEventSupported(0,value)

    def get_clusterLaunch(self, i):
        """Get value ``clusterLaunch`` of ``(<chip.hipDeviceProp_t*>self._ptr)[i]``.
        """
        return (<chip.hipDeviceProp_t*>self._ptr)[i].clusterLaunch
    def set_clusterLaunch(self, i, int value):
        """Set value ``clusterLaunch`` of ``(<chip.hipDeviceProp_t*>self._ptr)[i]``.
        """
        (<chip.hipDeviceProp_t*>self._ptr)[i].clusterLaunch = value
    @property
    def clusterLaunch(self):
        """Device supports cluster launch"""
        return self.get_clusterLaunch(0)
    @clusterLaunch.setter
    def clusterLaunch(self, int value):
        self.set_clusterLaunch(0,value)

    def get_unifiedFunctionPointers(self, i):
        """Get value ``unifiedFunctionPointers`` of ``(<chip.hipDeviceProp_t*>self._ptr)[i]``.
        """
        return (<chip.hipDeviceProp_t*>self._ptr)[i].unifiedFunctionPointers
    def set_unifiedFunctionPointers(self, i, int value):
        """Set value ``unifiedFunctionPointers`` of ``(<chip.hipDeviceProp_t*>self._ptr)[i]``.
        """
        (<chip.hipDeviceProp_t*>self._ptr)[i].unifiedFunctionPointers = value
    @property
    def unifiedFunctionPointers(self):
        """Indicates device supports unified function pointers"""
        return self.get_unifiedFunctionPointers(0)
    @unifiedFunctionPointers.setter
    def unifiedFunctionPointers(self, int value):
        self.set_unifiedFunctionPointers(0,value)

    def get_reserved(self, i):
        """Get value of ``reserved`` of ``(<chip.hipDeviceProp_t*>self._ptr)[i]``.
        """
        return (<chip.hipDeviceProp_t*>self._ptr)[i].reserved
    # TODO add setters
    #def set_reserved(self, i, int[63] value):
    #    """Set value ``reserved`` of ``(<chip.hipDeviceProp_t*>self._ptr)[i]``.
    #    """
    #    (<chip.hipDeviceProp_t*>self._ptr)[i].reserved = value
    @property
    def reserved(self):
        """CUDA Reserved."""
        return self.get_reserved(0)
    # TODO add setters
    #@reserved.setter
    #def reserved(self, int[63] value):
    #    self.set_reserved(0,value)

    def get_hipReserved(self, i):
        """Get value of ``hipReserved`` of ``(<chip.hipDeviceProp_t*>self._ptr)[i]``.
        """
        return (<chip.hipDeviceProp_t*>self._ptr)[i].hipReserved
    # TODO add setters
    #def set_hipReserved(self, i, int[32] value):
    #    """Set value ``hipReserved`` of ``(<chip.hipDeviceProp_t*>self._ptr)[i]``.
    #    """
    #    (<chip.hipDeviceProp_t*>self._ptr)[i].hipReserved = value
    @property
    def hipReserved(self):
        """Reserved for adding new entries for HIP/CUDA."""
        return self.get_hipReserved(0)
    # TODO add setters
    #@hipReserved.setter
    #def hipReserved(self, int[32] value):
    #    self.set_hipReserved(0,value)

    def get_gcnArchName(self, i):
        """Get value of ``gcnArchName`` of ``(<chip.hipDeviceProp_t*>self._ptr)[i]``.
        """
        return (<chip.hipDeviceProp_t*>self._ptr)[i].gcnArchName
    # TODO add setters
    #def set_gcnArchName(self, i, char[256] value):
    #    """Set value ``gcnArchName`` of ``(<chip.hipDeviceProp_t*>self._ptr)[i]``.
    #    """
    #    (<chip.hipDeviceProp_t*>self._ptr)[i].gcnArchName = value
    @property
    def gcnArchName(self):
        """AMD GCN Arch Name. HIP Only."""
        return self.get_gcnArchName(0)
    # TODO add setters
    #@gcnArchName.setter
    #def gcnArchName(self, char[256] value):
    #    self.set_gcnArchName(0,value)

    def get_maxSharedMemoryPerMultiProcessor(self, i):
        """Get value ``maxSharedMemoryPerMultiProcessor`` of ``(<chip.hipDeviceProp_t*>self._ptr)[i]``.
        """
        return (<chip.hipDeviceProp_t*>self._ptr)[i].maxSharedMemoryPerMultiProcessor
    def set_maxSharedMemoryPerMultiProcessor(self, i, unsigned long value):
        """Set value ``maxSharedMemoryPerMultiProcessor`` of ``(<chip.hipDeviceProp_t*>self._ptr)[i]``.
        """
        (<chip.hipDeviceProp_t*>self._ptr)[i].maxSharedMemoryPerMultiProcessor = value
    @property
    def maxSharedMemoryPerMultiProcessor(self):
        """Maximum Shared Memory Per CU. HIP Only."""
        return self.get_maxSharedMemoryPerMultiProcessor(0)
    @maxSharedMemoryPerMultiProcessor.setter
    def maxSharedMemoryPerMultiProcessor(self, unsigned long value):
        self.set_maxSharedMemoryPerMultiProcessor(0,value)

    def get_clockInstructionRate(self, i):
        """Get value ``clockInstructionRate`` of ``(<chip.hipDeviceProp_t*>self._ptr)[i]``.
        """
        return (<chip.hipDeviceProp_t*>self._ptr)[i].clockInstructionRate
    def set_clockInstructionRate(self, i, int value):
        """Set value ``clockInstructionRate`` of ``(<chip.hipDeviceProp_t*>self._ptr)[i]``.
        """
        (<chip.hipDeviceProp_t*>self._ptr)[i].clockInstructionRate = value
    @property
    def clockInstructionRate(self):
        """Frequency in khz of the timer used by the device-side "clock*" instructions. New for HIP."""
        return self.get_clockInstructionRate(0)
    @clockInstructionRate.setter
    def clockInstructionRate(self, int value):
        self.set_clockInstructionRate(0,value)

    def get_arch(self, i):
        """Get value of ``arch`` of ``(<chip.hipDeviceProp_t*>self._ptr)[i]``.
        """
        return hipDeviceArch_t.fromPtr(&(<chip.hipDeviceProp_t*>self._ptr)[i].arch)
    @property
    def arch(self):
        """Architectural feature flags. New for HIP."""
        return self.get_arch(0)

    def get_hdpMemFlushCntl(self, i):
        """Get value ``hdpMemFlushCntl`` of ``(<chip.hipDeviceProp_t*>self._ptr)[i]``.
        """
        return hip._util.types.ListOfUnsigned.fromPtr((<chip.hipDeviceProp_t*>self._ptr)[i].hdpMemFlushCntl)
    def set_hdpMemFlushCntl(self, i, object value):
        """Set value ``hdpMemFlushCntl`` of ``(<chip.hipDeviceProp_t*>self._ptr)[i]``.

        Note:
            This can be dangerous if the pointer is from a python object
            that is later on garbage collected.
        """
        (<chip.hipDeviceProp_t*>self._ptr)[i].hdpMemFlushCntl = <unsigned int *>cpython.long.PyLong_AsVoidPtr(int(hip._util.types.ListOfUnsigned.fromPyobj(value)))
    @property
    def hdpMemFlushCntl(self):
        """Addres of HDP_MEM_COHERENCY_FLUSH_CNTL register
        Note:
            Setting this hdpMemFlushCntl can be dangerous if the underlying pointer is from a python object that
            is later on garbage collected.
        """
        return self.get_hdpMemFlushCntl(0)
    @hdpMemFlushCntl.setter
    def hdpMemFlushCntl(self, object value):
        self.set_hdpMemFlushCntl(0,value)

    def get_hdpRegFlushCntl(self, i):
        """Get value ``hdpRegFlushCntl`` of ``(<chip.hipDeviceProp_t*>self._ptr)[i]``.
        """
        return hip._util.types.ListOfUnsigned.fromPtr((<chip.hipDeviceProp_t*>self._ptr)[i].hdpRegFlushCntl)
    def set_hdpRegFlushCntl(self, i, object value):
        """Set value ``hdpRegFlushCntl`` of ``(<chip.hipDeviceProp_t*>self._ptr)[i]``.

        Note:
            This can be dangerous if the pointer is from a python object
            that is later on garbage collected.
        """
        (<chip.hipDeviceProp_t*>self._ptr)[i].hdpRegFlushCntl = <unsigned int *>cpython.long.PyLong_AsVoidPtr(int(hip._util.types.ListOfUnsigned.fromPyobj(value)))
    @property
    def hdpRegFlushCntl(self):
        """Addres of HDP_REG_COHERENCY_FLUSH_CNTL register
        Note:
            Setting this hdpRegFlushCntl can be dangerous if the underlying pointer is from a python object that
            is later on garbage collected.
        """
        return self.get_hdpRegFlushCntl(0)
    @hdpRegFlushCntl.setter
    def hdpRegFlushCntl(self, object value):
        self.set_hdpRegFlushCntl(0,value)

    def get_cooperativeMultiDeviceUnmatchedFunc(self, i):
        """Get value ``cooperativeMultiDeviceUnmatchedFunc`` of ``(<chip.hipDeviceProp_t*>self._ptr)[i]``.
        """
        return (<chip.hipDeviceProp_t*>self._ptr)[i].cooperativeMultiDeviceUnmatchedFunc
    def set_cooperativeMultiDeviceUnmatchedFunc(self, i, int value):
        """Set value ``cooperativeMultiDeviceUnmatchedFunc`` of ``(<chip.hipDeviceProp_t*>self._ptr)[i]``.
        """
        (<chip.hipDeviceProp_t*>self._ptr)[i].cooperativeMultiDeviceUnmatchedFunc = value
    @property
    def cooperativeMultiDeviceUnmatchedFunc(self):
        """HIP device supports cooperative launch on multiple"""
        return self.get_cooperativeMultiDeviceUnmatchedFunc(0)
    @cooperativeMultiDeviceUnmatchedFunc.setter
    def cooperativeMultiDeviceUnmatchedFunc(self, int value):
        self.set_cooperativeMultiDeviceUnmatchedFunc(0,value)

    def get_cooperativeMultiDeviceUnmatchedGridDim(self, i):
        """Get value ``cooperativeMultiDeviceUnmatchedGridDim`` of ``(<chip.hipDeviceProp_t*>self._ptr)[i]``.
        """
        return (<chip.hipDeviceProp_t*>self._ptr)[i].cooperativeMultiDeviceUnmatchedGridDim
    def set_cooperativeMultiDeviceUnmatchedGridDim(self, i, int value):
        """Set value ``cooperativeMultiDeviceUnmatchedGridDim`` of ``(<chip.hipDeviceProp_t*>self._ptr)[i]``.
        """
        (<chip.hipDeviceProp_t*>self._ptr)[i].cooperativeMultiDeviceUnmatchedGridDim = value
    @property
    def cooperativeMultiDeviceUnmatchedGridDim(self):
        """HIP device supports cooperative launch on multiple"""
        return self.get_cooperativeMultiDeviceUnmatchedGridDim(0)
    @cooperativeMultiDeviceUnmatchedGridDim.setter
    def cooperativeMultiDeviceUnmatchedGridDim(self, int value):
        self.set_cooperativeMultiDeviceUnmatchedGridDim(0,value)

    def get_cooperativeMultiDeviceUnmatchedBlockDim(self, i):
        """Get value ``cooperativeMultiDeviceUnmatchedBlockDim`` of ``(<chip.hipDeviceProp_t*>self._ptr)[i]``.
        """
        return (<chip.hipDeviceProp_t*>self._ptr)[i].cooperativeMultiDeviceUnmatchedBlockDim
    def set_cooperativeMultiDeviceUnmatchedBlockDim(self, i, int value):
        """Set value ``cooperativeMultiDeviceUnmatchedBlockDim`` of ``(<chip.hipDeviceProp_t*>self._ptr)[i]``.
        """
        (<chip.hipDeviceProp_t*>self._ptr)[i].cooperativeMultiDeviceUnmatchedBlockDim = value
    @property
    def cooperativeMultiDeviceUnmatchedBlockDim(self):
        """HIP device supports cooperative launch on multiple"""
        return self.get_cooperativeMultiDeviceUnmatchedBlockDim(0)
    @cooperativeMultiDeviceUnmatchedBlockDim.setter
    def cooperativeMultiDeviceUnmatchedBlockDim(self, int value):
        self.set_cooperativeMultiDeviceUnmatchedBlockDim(0,value)

    def get_cooperativeMultiDeviceUnmatchedSharedMem(self, i):
        """Get value ``cooperativeMultiDeviceUnmatchedSharedMem`` of ``(<chip.hipDeviceProp_t*>self._ptr)[i]``.
        """
        return (<chip.hipDeviceProp_t*>self._ptr)[i].cooperativeMultiDeviceUnmatchedSharedMem
    def set_cooperativeMultiDeviceUnmatchedSharedMem(self, i, int value):
        """Set value ``cooperativeMultiDeviceUnmatchedSharedMem`` of ``(<chip.hipDeviceProp_t*>self._ptr)[i]``.
        """
        (<chip.hipDeviceProp_t*>self._ptr)[i].cooperativeMultiDeviceUnmatchedSharedMem = value
    @property
    def cooperativeMultiDeviceUnmatchedSharedMem(self):
        """HIP device supports cooperative launch on multiple"""
        return self.get_cooperativeMultiDeviceUnmatchedSharedMem(0)
    @cooperativeMultiDeviceUnmatchedSharedMem.setter
    def cooperativeMultiDeviceUnmatchedSharedMem(self, int value):
        self.set_cooperativeMultiDeviceUnmatchedSharedMem(0,value)

    def get_isLargeBar(self, i):
        """Get value ``isLargeBar`` of ``(<chip.hipDeviceProp_t*>self._ptr)[i]``.
        """
        return (<chip.hipDeviceProp_t*>self._ptr)[i].isLargeBar
    def set_isLargeBar(self, i, int value):
        """Set value ``isLargeBar`` of ``(<chip.hipDeviceProp_t*>self._ptr)[i]``.
        """
        (<chip.hipDeviceProp_t*>self._ptr)[i].isLargeBar = value
    @property
    def isLargeBar(self):
        """1: if it is a large PCI bar device, else 0"""
        return self.get_isLargeBar(0)
    @isLargeBar.setter
    def isLargeBar(self, int value):
        self.set_isLargeBar(0,value)

    def get_asicRevision(self, i):
        """Get value ``asicRevision`` of ``(<chip.hipDeviceProp_t*>self._ptr)[i]``.
        """
        return (<chip.hipDeviceProp_t*>self._ptr)[i].asicRevision
    def set_asicRevision(self, i, int value):
        """Set value ``asicRevision`` of ``(<chip.hipDeviceProp_t*>self._ptr)[i]``.
        """
        (<chip.hipDeviceProp_t*>self._ptr)[i].asicRevision = value
    @property
    def asicRevision(self):
        """Revision of the GPU in this device"""
        return self.get_asicRevision(0)
    @asicRevision.setter
    def asicRevision(self, int value):
        self.set_asicRevision(0,value)

    @staticmethod
    def PROPERTIES():
        return ["name","uuid","luid","luidDeviceNodeMask","totalGlobalMem","sharedMemPerBlock","regsPerBlock","warpSize","memPitch","maxThreadsPerBlock","maxThreadsDim","maxGridSize","clockRate","totalConstMem","major","minor","textureAlignment","texturePitchAlignment","deviceOverlap","multiProcessorCount","kernelExecTimeoutEnabled","integrated","canMapHostMemory","computeMode","maxTexture1D","maxTexture1DMipmap","maxTexture1DLinear","maxTexture2D","maxTexture2DMipmap","maxTexture2DLinear","maxTexture2DGather","maxTexture3D","maxTexture3DAlt","maxTextureCubemap","maxTexture1DLayered","maxTexture2DLayered","maxTextureCubemapLayered","maxSurface1D","maxSurface2D","maxSurface3D","maxSurface1DLayered","maxSurface2DLayered","maxSurfaceCubemap","maxSurfaceCubemapLayered","surfaceAlignment","concurrentKernels","ECCEnabled","pciBusID","pciDeviceID","pciDomainID","tccDriver","asyncEngineCount","unifiedAddressing","memoryClockRate","memoryBusWidth","l2CacheSize","persistingL2CacheMaxSize","maxThreadsPerMultiProcessor","streamPrioritiesSupported","globalL1CacheSupported","localL1CacheSupported","sharedMemPerMultiprocessor","regsPerMultiprocessor","managedMemory","isMultiGpuBoard","multiGpuBoardGroupID","hostNativeAtomicSupported","singleToDoublePrecisionPerfRatio","pageableMemoryAccess","concurrentManagedAccess","computePreemptionSupported","canUseHostPointerForRegisteredMem","cooperativeLaunch","cooperativeMultiDeviceLaunch","sharedMemPerBlockOptin","pageableMemoryAccessUsesHostPageTables","directManagedMemAccessFromHost","maxBlocksPerMultiProcessor","accessPolicyMaxWindowSize","reservedSharedMemPerBlock","hostRegisterSupported","sparseHipArraySupported","hostRegisterReadOnlySupported","timelineSemaphoreInteropSupported","memoryPoolsSupported","gpuDirectRDMASupported","gpuDirectRDMAFlushWritesOptions","gpuDirectRDMAWritesOrdering","memoryPoolSupportedHandleTypes","deferredMappingHipArraySupported","ipcEventSupported","clusterLaunch","unifiedFunctionPointers","reserved","hipReserved","gcnArchName","maxSharedMemoryPerMultiProcessor","clockInstructionRate","arch","hdpMemFlushCntl","hdpRegFlushCntl","cooperativeMultiDeviceUnmatchedFunc","cooperativeMultiDeviceUnmatchedGridDim","cooperativeMultiDeviceUnmatchedBlockDim","cooperativeMultiDeviceUnmatchedSharedMem","isLargeBar","asicRevision"]

    def __contains__(self,item):
        properties = self.PROPERTIES()
        return item in properties

    def __getitem__(self,item):
        properties = self.PROPERTIES()
        if isinstance(item,int):
            if item < 0 or item >= len(properties):
                raise IndexError()
            return getattr(self,properties[item])
        raise ValueError("'item' type must be 'int'")


class _hipMemoryType__Base(enum.IntEnum):
    """Empty enum base class that allows subclassing.
    """
    pass
class hipMemoryType(_hipMemoryType__Base):
    """hipMemoryType (for pointer attributes)

    Attributes:
        hipMemoryTypeUnregistered:
            Unregistered memory
        hipMemoryTypeHost:
            Memory is physically located on host
        hipMemoryTypeDevice:
            Memory is physically located on device. (see deviceId for specific device)
        hipMemoryTypeManaged:
            Managed memory, automaticallly managed by the unified memory system place holder for new values.
        hipMemoryTypeArray:
            Array memory, physically located on device. (see deviceId for specific device)
        hipMemoryTypeUnified:
            unified address space
    """
    hipMemoryTypeUnregistered = chip.hipMemoryTypeUnregistered
    hipMemoryTypeHost = chip.hipMemoryTypeHost
    hipMemoryTypeDevice = chip.hipMemoryTypeDevice
    hipMemoryTypeManaged = chip.hipMemoryTypeManaged
    hipMemoryTypeArray = chip.hipMemoryTypeArray
    hipMemoryTypeUnified = chip.hipMemoryTypeUnified
    @staticmethod
    def ctypes_type():
        """The type of the enum constants as ctypes type."""
        return ctypes.c_uint


cdef class hipPointerAttribute_t(hip._util.types.Pointer):
    """Python wrapper for cdef class chip.hipPointerAttribute_t.

    Python wrapper for cdef class chip.hipPointerAttribute_t.

    If this type is initialized via its `__init__` method, it allocates a
    member of the underlying C type and destroys it again if the wrapper
    type is deallocated.

    This type also serves as adapter when appearing as argument type in a
    function signature. In this case, the type can further be initialized
    from a number of Python objects:

    * `None`:

      This will set the ``self._ptr`` attribute to ``NULL``.

    * `int`:

      Interprets the integer value as pointer address and writes it to ``self._ptr``.
      No ownership is transferred.

    * `ctypes.c_void_p`:

      Takes the pointer address ``pyobj.value`` and writes it to ``self._ptr``.
      No ownership is transferred.

    * `object` that implements the `CUDA Array Interface <https://numba.readthedocs.io/en/stable/cuda/cuda_array_interface.html>`_ protocol:

      Takes the integer-valued pointer address, i.e. the first entry of the `data` tuple
      from `pyobj`'s member ``__cuda_array_interface__``  and writes it to ``self._ptr``.

    * `object` that implements the Python buffer protocol:

      If the object represents a simple contiguous array,
      writes the `Py_buffer` associated with ``pyobj`` to `self._py_buffer`,
      sets the `self._py_buffer_acquired` flag to `True`, and
      writes `self._py_buffer.buf` to the data pointer `self._ptr`.

    * `hip._util.types.Pointer`:

      Takes the pointer address ``pyobj._ptr`` and writes it to ``self._ptr``.
      No ownership is transferred.

    Type checks are performed in the above order.

    C Attributes:
        _ptr (C type ``void *``, protected):
            Stores a pointer to the data of the original Python object.
        _is_ptr_owner (C type ``bint``, protected):
            If this wrapper is the owner of the underlying data.
        _py_buffer (C type ``Py_buffer`, protected):
            Stores a pointer to the data of the original Python object.
        _py_buffer_acquired (C type ``bint``, protected):
            Stores a pointer to the data of the original Python object.
    """
    # C members declared in pxd file

    def __cinit__(self):
        self._ptr = NULL
        self._is_ptr_owner = False
        self._py_buffer_acquired = False

    cdef chip.hipPointerAttribute_t* getElementPtr(self):
        return <chip.hipPointerAttribute_t*>self._ptr

    @staticmethod
    cdef hipPointerAttribute_t fromPtr(void* ptr, bint owner=False):
        """Factory function to create ``hipPointerAttribute_t`` objects from
        given ``chip.hipPointerAttribute_t`` pointer.

        Setting ``owner`` flag to ``True`` causes
        the extension type to free the structure pointed to by ``ptr``
        when the wrapper object is deallocated.
        """
        # Fast call to __new__() that bypasses the __init__() constructor.
        cdef hipPointerAttribute_t wrapper = hipPointerAttribute_t.__new__(hipPointerAttribute_t)
        wrapper._ptr = ptr
        wrapper._is_ptr_owner = owner
        return wrapper

    @staticmethod
    def fromObj(pyobj):
        """Creates a hipPointerAttribute_t from a Python object.

        Derives a hipPointerAttribute_t from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``hipPointerAttribute_t`` reference, this method
        returns it directly. No new ``hipPointerAttribute_t`` is created in this case.
        """
        return hipPointerAttribute_t.fromPyobj(pyobj)

    @staticmethod
    cdef hipPointerAttribute_t fromPyobj(object pyobj):
        """Creates a hipPointerAttribute_t from a Python object.

        Derives a hipPointerAttribute_t from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``hipPointerAttribute_t`` reference, this method
        returns it directly. No new ``hipPointerAttribute_t`` is created in this case.

        Args:
            pyobj (object): Must be either `None`; a `hip._util.types.Pointer`; a simple, contiguous buffer according to the buffer protocol;
                            or of type `hipPointerAttribute_t`; `int`; or `ctypes.c_void_p`.

        Note:
            This routine does not perform a copy but returns the original ``pyobj``
            if ``pyobj`` is an instance of hipPointerAttribute_t!
        """
        cdef hipPointerAttribute_t wrapper

        if isinstance(pyobj,hipPointerAttribute_t):
            return pyobj
        else:
            wrapper = hipPointerAttribute_t.__new__(hipPointerAttribute_t)
            wrapper.init_from_pyobj(pyobj)
            return wrapper

    def __dealloc__(self):
        # Release the buffer handle
        if self._py_buffer_acquired is True:
            cpython.buffer.PyBuffer_Release(&self._py_buffer)
        # De-allocate if not null and flag is set
        if self._ptr is not NULL and self._is_ptr_owner is True:
            stdlib.free(self._ptr)
            self._ptr = NULL

    @staticmethod
    cdef __allocate(void** ptr):
        ptr[0] = stdlib.malloc(sizeof(chip.hipPointerAttribute_t))
        string.memset(<void*>ptr[0], 0, sizeof(chip.hipPointerAttribute_t))

        if ptr[0] is NULL:
            raise MemoryError

    @staticmethod
    cdef hipPointerAttribute_t new():
        """Factory function to create hipPointerAttribute_t objects with
        newly allocated chip.hipPointerAttribute_t"""
        cdef void* ptr
        hipPointerAttribute_t.__allocate(&ptr)
        return hipPointerAttribute_t.fromPtr(ptr, owner=True)

    @staticmethod
    cdef hipPointerAttribute_t fromValue(chip.hipPointerAttribute_t other):
        """Allocate new C type and copy from ``other``.
        """
        wrapper = hipPointerAttribute_t.new()
        string.memcpy(wrapper._ptr, &other, sizeof(chip.hipPointerAttribute_t))
        return wrapper

    def c_sizeof(self):
        """Returns the size of the underlying C type in bytes.
        Note:
            Implemented as function to not collide with
            autogenerated property names.
        """
        return sizeof(chip.hipPointerAttribute_t)

    def __int__(self):
        """Returns the data's address as long integer.
        """
        return cpython.long.PyLong_FromVoidPtr(self._ptr)

    def __repr__(self):
        return f"<hipPointerAttribute_t object, ptr: {int(self)}>"

    def as_c_void_p(self):
        """Returns the data's address as `ctypes.c_void_p`
        Note:
            Implemented as function to not collide with
            autogenerated property names.
        """
        return ctypes.c_void_p(int(self))

    def __init__(self,*args,**kwargs):
        """Constructor type hipPointerAttribute_t.

        Constructor for type hipPointerAttribute_t.

        Args:
            *args:
                Positional arguments. Initialize all or a subset of the member variables
                according to their order of declaration.
            **kwargs:
                Can be used to initialize member variables at construction,
                Just pass an argument expression of the form <member>=<value>
                per member that you want to initialize.
        """
        hipPointerAttribute_t.__allocate(&self._ptr)
        self._is_ptr_owner = True
        attribs = self.PROPERTIES()
        used_attribs = set()
        if len(args) > len(attribs):
            raise ValueError("More positional arguments specified than this type has properties.")
        for i,v in enumerate(args):
            setattr(self,attribs[i],v)
            used_attribs.add(attribs[i])
        valid_names = ", ".join(["'"+p+"'" for p in attribs])
        for k,v in kwargs.items():
            if k in used_attribs:
                raise KeyError(f"argument '{k}' has already been specified as positional argument.")
            elif k not in attribs:
                raise KeyError(f"'{k}' is no valid property name. Valid names: {valid_names}")
            setattr(self,k,v)
    def get_type(self, i):
        """Get value of ``type`` of ``(<chip.hipPointerAttribute_t*>self._ptr)[i]``.
        """
        return hipMemoryType((<chip.hipPointerAttribute_t*>self._ptr)[i].type)
    def set_type(self, i, value):
        """Set value ``type`` of ``(<chip.hipPointerAttribute_t*>self._ptr)[i]``.
        """
        if not isinstance(value, hipMemoryType):
            raise TypeError("'value' must be of type 'hipMemoryType'")
        (<chip.hipPointerAttribute_t*>self._ptr)[i].type = value.value
    @property
    def type(self):
        """(undocumented)"""
        return self.get_type(0)
    @type.setter
    def type(self, value):
        self.set_type(0,value)

    def get_device(self, i):
        """Get value ``device`` of ``(<chip.hipPointerAttribute_t*>self._ptr)[i]``.
        """
        return (<chip.hipPointerAttribute_t*>self._ptr)[i].device
    def set_device(self, i, int value):
        """Set value ``device`` of ``(<chip.hipPointerAttribute_t*>self._ptr)[i]``.
        """
        (<chip.hipPointerAttribute_t*>self._ptr)[i].device = value
    @property
    def device(self):
        """(undocumented)"""
        return self.get_device(0)
    @device.setter
    def device(self, int value):
        self.set_device(0,value)

    def get_devicePointer(self, i):
        """Get value ``devicePointer`` of ``(<chip.hipPointerAttribute_t*>self._ptr)[i]``.
        """
        return hip._util.types.Pointer.fromPtr((<chip.hipPointerAttribute_t*>self._ptr)[i].devicePointer)
    def set_devicePointer(self, i, object value):
        """Set value ``devicePointer`` of ``(<chip.hipPointerAttribute_t*>self._ptr)[i]``.

        Note:
            This can be dangerous if the pointer is from a python object
            that is later on garbage collected.
        """
        (<chip.hipPointerAttribute_t*>self._ptr)[i].devicePointer = <void *>cpython.long.PyLong_AsVoidPtr(int(hip._util.types.Pointer.fromPyobj(value)))
    @property
    def devicePointer(self):
        """(undocumented)
        Note:
            Setting this devicePointer can be dangerous if the underlying pointer is from a python object that
            is later on garbage collected.
        """
        return self.get_devicePointer(0)
    @devicePointer.setter
    def devicePointer(self, object value):
        self.set_devicePointer(0,value)

    def get_hostPointer(self, i):
        """Get value ``hostPointer`` of ``(<chip.hipPointerAttribute_t*>self._ptr)[i]``.
        """
        return hip._util.types.Pointer.fromPtr((<chip.hipPointerAttribute_t*>self._ptr)[i].hostPointer)
    def set_hostPointer(self, i, object value):
        """Set value ``hostPointer`` of ``(<chip.hipPointerAttribute_t*>self._ptr)[i]``.

        Note:
            This can be dangerous if the pointer is from a python object
            that is later on garbage collected.
        """
        (<chip.hipPointerAttribute_t*>self._ptr)[i].hostPointer = <void *>cpython.long.PyLong_AsVoidPtr(int(hip._util.types.Pointer.fromPyobj(value)))
    @property
    def hostPointer(self):
        """(undocumented)
        Note:
            Setting this hostPointer can be dangerous if the underlying pointer is from a python object that
            is later on garbage collected.
        """
        return self.get_hostPointer(0)
    @hostPointer.setter
    def hostPointer(self, object value):
        self.set_hostPointer(0,value)

    def get_isManaged(self, i):
        """Get value ``isManaged`` of ``(<chip.hipPointerAttribute_t*>self._ptr)[i]``.
        """
        return (<chip.hipPointerAttribute_t*>self._ptr)[i].isManaged
    def set_isManaged(self, i, int value):
        """Set value ``isManaged`` of ``(<chip.hipPointerAttribute_t*>self._ptr)[i]``.
        """
        (<chip.hipPointerAttribute_t*>self._ptr)[i].isManaged = value
    @property
    def isManaged(self):
        """(undocumented)"""
        return self.get_isManaged(0)
    @isManaged.setter
    def isManaged(self, int value):
        self.set_isManaged(0,value)

    def get_allocationFlags(self, i):
        """Get value ``allocationFlags`` of ``(<chip.hipPointerAttribute_t*>self._ptr)[i]``.
        """
        return (<chip.hipPointerAttribute_t*>self._ptr)[i].allocationFlags
    def set_allocationFlags(self, i, unsigned int value):
        """Set value ``allocationFlags`` of ``(<chip.hipPointerAttribute_t*>self._ptr)[i]``.
        """
        (<chip.hipPointerAttribute_t*>self._ptr)[i].allocationFlags = value
    @property
    def allocationFlags(self):
        """(undocumented)"""
        return self.get_allocationFlags(0)
    @allocationFlags.setter
    def allocationFlags(self, unsigned int value):
        self.set_allocationFlags(0,value)

    @staticmethod
    def PROPERTIES():
        return ["type","device","devicePointer","hostPointer","isManaged","allocationFlags"]

    def __contains__(self,item):
        properties = self.PROPERTIES()
        return item in properties

    def __getitem__(self,item):
        properties = self.PROPERTIES()
        if isinstance(item,int):
            if item < 0 or item >= len(properties):
                raise IndexError()
            return getattr(self,properties[item])
        raise ValueError("'item' type must be 'int'")


class _hipError_t__Base(enum.IntEnum):
    """Empty enum base class that allows subclassing.
    """
    pass
class hipError_t(_hipError_t__Base):
    """HIP error type

    Attributes:
        hipSuccess:
            Successful completion.
        hipErrorInvalidValue:
            One or more of the parameters passed to the API call is NULL or not in an acceptable range.
        hipErrorOutOfMemory:
            out of memory range.
        hipErrorMemoryAllocation:
            Memory allocation error.
        hipErrorNotInitialized:
            Invalid not initialized
        hipErrorInitializationError:
            (undocumented)
        hipErrorDeinitialized:
            Deinitialized
        hipErrorProfilerDisabled:
            (undocumented)
        hipErrorProfilerNotInitialized:
            (undocumented)
        hipErrorProfilerAlreadyStarted:
            (undocumented)
        hipErrorProfilerAlreadyStopped:
            (undocumented)
        hipErrorInvalidConfiguration:
            Invalide configuration
        hipErrorInvalidPitchValue:
            Invalid pitch value
        hipErrorInvalidSymbol:
            Invalid symbol
        hipErrorInvalidDevicePointer:
            Invalid Device Pointer
        hipErrorInvalidMemcpyDirection:
            Invalid memory copy direction
        hipErrorInsufficientDriver:
            (undocumented)
        hipErrorMissingConfiguration:
            (undocumented)
        hipErrorPriorLaunchFailure:
            (undocumented)
        hipErrorInvalidDeviceFunction:
            Invalid device function
        hipErrorNoDevice:
            Call to hipGetDeviceCount returned 0 devices
        hipErrorInvalidDevice:
            DeviceID must be in range from 0 to compute-devices.
        hipErrorInvalidImage:
            Invalid image
        hipErrorInvalidContext:
            Produced when input context is invalid.
        hipErrorContextAlreadyCurrent:
            (undocumented)
        hipErrorMapFailed:
            (undocumented)
        hipErrorMapBufferObjectFailed:
            Produced when the IPC memory attach failed from ROCr.
        hipErrorUnmapFailed:
            (undocumented)
        hipErrorArrayIsMapped:
            (undocumented)
        hipErrorAlreadyMapped:
            (undocumented)
        hipErrorNoBinaryForGpu:
            (undocumented)
        hipErrorAlreadyAcquired:
            (undocumented)
        hipErrorNotMapped:
            (undocumented)
        hipErrorNotMappedAsArray:
            (undocumented)
        hipErrorNotMappedAsPointer:
            (undocumented)
        hipErrorECCNotCorrectable:
            (undocumented)
        hipErrorUnsupportedLimit:
            Unsupported limit
        hipErrorContextAlreadyInUse:
            The context is already in use
        hipErrorPeerAccessUnsupported:
            (undocumented)
        hipErrorInvalidKernelFile:
            In CUDA DRV, it is CUDA_ERROR_INVALID_PTX
        hipErrorInvalidGraphicsContext:
            (undocumented)
        hipErrorInvalidSource:
            Invalid source.
        hipErrorFileNotFound:
            the file is not found.
        hipErrorSharedObjectSymbolNotFound:
            (undocumented)
        hipErrorSharedObjectInitFailed:
            Failed to initialize shared object.
        hipErrorOperatingSystem:
            Not the correct operating system
        hipErrorInvalidHandle:
            Invalide handle
        hipErrorInvalidResourceHandle:
            Resource handle (hipEvent_t or hipStream_t) invalid.
        hipErrorIllegalState:
            Resource required is not in a valid state to perform operation.
        hipErrorNotFound:
            Not found
        hipErrorNotReady:
            Indicates that asynchronous operations enqueued earlier are not ready. This is not actually an error, but is used to distinguish from hipSuccess (which indicates completion). APIs that return this error include hipEventQuery and hipStreamQuery.
        hipErrorIllegalAddress:
            (undocumented)
        hipErrorLaunchOutOfResources:
            Out of resources error.
        hipErrorLaunchTimeOut:
            Timeout for the launch.
        hipErrorPeerAccessAlreadyEnabled:
            Peer access was already enabled from the current device.
        hipErrorPeerAccessNotEnabled:
            Peer access was never enabled from the current device.
        hipErrorSetOnActiveProcess:
            The process is active.
        hipErrorContextIsDestroyed:
            The context is already destroyed
        hipErrorAssert:
            Produced when the kernel calls assert.
        hipErrorHostMemoryAlreadyRegistered:
            Produced when trying to lock a page-locked memory.
        hipErrorHostMemoryNotRegistered:
            Produced when trying to unlock a non-page-locked memory.
        hipErrorLaunchFailure:
            An exception occurred on the device while executing a kernel.
        hipErrorCooperativeLaunchTooLarge:
            This error indicates that the number of blocks launched per grid for a kernel that was launched via cooperative launch APIs exceeds the maximum number of allowed blocks for the current device.
        hipErrorNotSupported:
            Produced when the hip API is not supported/implemented
        hipErrorStreamCaptureUnsupported:
            The operation is not permitted when the stream is capturing.
        hipErrorStreamCaptureInvalidated:
            The current capture sequence on the stream has been invalidated due to a previous error.
        hipErrorStreamCaptureMerge:
            The operation would have resulted in a merge of two independent capture sequences.
        hipErrorStreamCaptureUnmatched:
            The capture was not initiated in this stream.
        hipErrorStreamCaptureUnjoined:
            The capture sequence contains a fork that was not joined to the primary stream.
        hipErrorStreamCaptureIsolation:
            A dependency would have been created which crosses the capture sequence boundary. Only implicit in-stream ordering dependencies are allowed to cross the boundary
        hipErrorStreamCaptureImplicit:
            The operation would have resulted in a disallowed implicit dependency on a current capture sequence from hipStreamLegacy.
        hipErrorCapturedEvent:
            The operation is not permitted on an event which was last recorded in a capturing stream.
        hipErrorStreamCaptureWrongThread:
            A stream capture sequence not initiated with the hipStreamCaptureModeRelaxed argument to hipStreamBeginCapture was passed to hipStreamEndCapture in a different thread.
        hipErrorGraphExecUpdateFailure:
            This error indicates that the graph update not performed because it included changes which violated constraintsspecific to instantiated graph update.
        hipErrorUnknown:
            Unknown error.
        hipErrorRuntimeMemory:
            HSA runtime memory call returned error. Typically not seen in production systems.
        hipErrorRuntimeOther:
            HSA runtime call other than memory returned error. Typically not seen in production systems.
        hipErrorTbd:
            Marker that more error codes are needed.
    """
    hipSuccess = chip.hipSuccess
    hipErrorInvalidValue = chip.hipErrorInvalidValue
    hipErrorOutOfMemory = chip.hipErrorOutOfMemory
    hipErrorMemoryAllocation = chip.hipErrorMemoryAllocation
    hipErrorNotInitialized = chip.hipErrorNotInitialized
    hipErrorInitializationError = chip.hipErrorInitializationError
    hipErrorDeinitialized = chip.hipErrorDeinitialized
    hipErrorProfilerDisabled = chip.hipErrorProfilerDisabled
    hipErrorProfilerNotInitialized = chip.hipErrorProfilerNotInitialized
    hipErrorProfilerAlreadyStarted = chip.hipErrorProfilerAlreadyStarted
    hipErrorProfilerAlreadyStopped = chip.hipErrorProfilerAlreadyStopped
    hipErrorInvalidConfiguration = chip.hipErrorInvalidConfiguration
    hipErrorInvalidPitchValue = chip.hipErrorInvalidPitchValue
    hipErrorInvalidSymbol = chip.hipErrorInvalidSymbol
    hipErrorInvalidDevicePointer = chip.hipErrorInvalidDevicePointer
    hipErrorInvalidMemcpyDirection = chip.hipErrorInvalidMemcpyDirection
    hipErrorInsufficientDriver = chip.hipErrorInsufficientDriver
    hipErrorMissingConfiguration = chip.hipErrorMissingConfiguration
    hipErrorPriorLaunchFailure = chip.hipErrorPriorLaunchFailure
    hipErrorInvalidDeviceFunction = chip.hipErrorInvalidDeviceFunction
    hipErrorNoDevice = chip.hipErrorNoDevice
    hipErrorInvalidDevice = chip.hipErrorInvalidDevice
    hipErrorInvalidImage = chip.hipErrorInvalidImage
    hipErrorInvalidContext = chip.hipErrorInvalidContext
    hipErrorContextAlreadyCurrent = chip.hipErrorContextAlreadyCurrent
    hipErrorMapFailed = chip.hipErrorMapFailed
    hipErrorMapBufferObjectFailed = chip.hipErrorMapBufferObjectFailed
    hipErrorUnmapFailed = chip.hipErrorUnmapFailed
    hipErrorArrayIsMapped = chip.hipErrorArrayIsMapped
    hipErrorAlreadyMapped = chip.hipErrorAlreadyMapped
    hipErrorNoBinaryForGpu = chip.hipErrorNoBinaryForGpu
    hipErrorAlreadyAcquired = chip.hipErrorAlreadyAcquired
    hipErrorNotMapped = chip.hipErrorNotMapped
    hipErrorNotMappedAsArray = chip.hipErrorNotMappedAsArray
    hipErrorNotMappedAsPointer = chip.hipErrorNotMappedAsPointer
    hipErrorECCNotCorrectable = chip.hipErrorECCNotCorrectable
    hipErrorUnsupportedLimit = chip.hipErrorUnsupportedLimit
    hipErrorContextAlreadyInUse = chip.hipErrorContextAlreadyInUse
    hipErrorPeerAccessUnsupported = chip.hipErrorPeerAccessUnsupported
    hipErrorInvalidKernelFile = chip.hipErrorInvalidKernelFile
    hipErrorInvalidGraphicsContext = chip.hipErrorInvalidGraphicsContext
    hipErrorInvalidSource = chip.hipErrorInvalidSource
    hipErrorFileNotFound = chip.hipErrorFileNotFound
    hipErrorSharedObjectSymbolNotFound = chip.hipErrorSharedObjectSymbolNotFound
    hipErrorSharedObjectInitFailed = chip.hipErrorSharedObjectInitFailed
    hipErrorOperatingSystem = chip.hipErrorOperatingSystem
    hipErrorInvalidHandle = chip.hipErrorInvalidHandle
    hipErrorInvalidResourceHandle = chip.hipErrorInvalidResourceHandle
    hipErrorIllegalState = chip.hipErrorIllegalState
    hipErrorNotFound = chip.hipErrorNotFound
    hipErrorNotReady = chip.hipErrorNotReady
    hipErrorIllegalAddress = chip.hipErrorIllegalAddress
    hipErrorLaunchOutOfResources = chip.hipErrorLaunchOutOfResources
    hipErrorLaunchTimeOut = chip.hipErrorLaunchTimeOut
    hipErrorPeerAccessAlreadyEnabled = chip.hipErrorPeerAccessAlreadyEnabled
    hipErrorPeerAccessNotEnabled = chip.hipErrorPeerAccessNotEnabled
    hipErrorSetOnActiveProcess = chip.hipErrorSetOnActiveProcess
    hipErrorContextIsDestroyed = chip.hipErrorContextIsDestroyed
    hipErrorAssert = chip.hipErrorAssert
    hipErrorHostMemoryAlreadyRegistered = chip.hipErrorHostMemoryAlreadyRegistered
    hipErrorHostMemoryNotRegistered = chip.hipErrorHostMemoryNotRegistered
    hipErrorLaunchFailure = chip.hipErrorLaunchFailure
    hipErrorCooperativeLaunchTooLarge = chip.hipErrorCooperativeLaunchTooLarge
    hipErrorNotSupported = chip.hipErrorNotSupported
    hipErrorStreamCaptureUnsupported = chip.hipErrorStreamCaptureUnsupported
    hipErrorStreamCaptureInvalidated = chip.hipErrorStreamCaptureInvalidated
    hipErrorStreamCaptureMerge = chip.hipErrorStreamCaptureMerge
    hipErrorStreamCaptureUnmatched = chip.hipErrorStreamCaptureUnmatched
    hipErrorStreamCaptureUnjoined = chip.hipErrorStreamCaptureUnjoined
    hipErrorStreamCaptureIsolation = chip.hipErrorStreamCaptureIsolation
    hipErrorStreamCaptureImplicit = chip.hipErrorStreamCaptureImplicit
    hipErrorCapturedEvent = chip.hipErrorCapturedEvent
    hipErrorStreamCaptureWrongThread = chip.hipErrorStreamCaptureWrongThread
    hipErrorGraphExecUpdateFailure = chip.hipErrorGraphExecUpdateFailure
    hipErrorUnknown = chip.hipErrorUnknown
    hipErrorRuntimeMemory = chip.hipErrorRuntimeMemory
    hipErrorRuntimeOther = chip.hipErrorRuntimeOther
    hipErrorTbd = chip.hipErrorTbd
    @staticmethod
    def ctypes_type():
        """The type of the enum constants as ctypes type."""
        return ctypes.c_uint


class _hipDeviceAttribute_t__Base(enum.IntEnum):
    """Empty enum base class that allows subclassing.
    """
    pass
class hipDeviceAttribute_t(_hipDeviceAttribute_t__Base):
    """hipDeviceAttribute_t hipDeviceAttributeUnused number: 5

    Attributes:
        hipDeviceAttributeCudaCompatibleBegin:
            (undocumented)
        hipDeviceAttributeEccEnabled:
            Whether ECC support is enabled.
        hipDeviceAttributeAccessPolicyMaxWindowSize:
            Cuda only. The maximum size of the window policy in bytes.
        hipDeviceAttributeAsyncEngineCount:
            Asynchronous engines number.
        hipDeviceAttributeCanMapHostMemory:
            Whether host memory can be mapped into device address space
        hipDeviceAttributeCanUseHostPointerForRegisteredMem:
            Device can access host registered memory at the same virtual address as the CPU
        hipDeviceAttributeClockRate:
            Peak clock frequency in kilohertz.
        hipDeviceAttributeComputeMode:
            Compute mode that device is currently in.
        hipDeviceAttributeComputePreemptionSupported:
            Device supports Compute Preemption.
        hipDeviceAttributeConcurrentKernels:
            Device can possibly execute multiple kernels concurrently.
        hipDeviceAttributeConcurrentManagedAccess:
            Device can coherently access managed memory concurrently with the CPU
        hipDeviceAttributeCooperativeLaunch:
            Support cooperative launch
        hipDeviceAttributeCooperativeMultiDeviceLaunch:
            Support cooperative launch on multiple devices
        hipDeviceAttributeDeviceOverlap:
            Device can concurrently copy memory and execute a kernel. Deprecated. Use instead asyncEngineCount.
        hipDeviceAttributeDirectManagedMemAccessFromHost:
            Host can directly access managed memory on the device without migration
        hipDeviceAttributeGlobalL1CacheSupported:
            Device supports caching globals in L1
        hipDeviceAttributeHostNativeAtomicSupported:
            Link between the device and the host supports native atomic operations
        hipDeviceAttributeIntegrated:
            Device is integrated GPU
        hipDeviceAttributeIsMultiGpuBoard:
            Multiple GPU devices.
        hipDeviceAttributeKernelExecTimeout:
            Run time limit for kernels executed on the device
        hipDeviceAttributeL2CacheSize:
            Size of L2 cache in bytes. 0 if the device doesn't have L2 cache.
        hipDeviceAttributeLocalL1CacheSupported:
            caching locals in L1 is supported
        hipDeviceAttributeLuid:
            8-byte locally unique identifier in 8 bytes. Undefined on TCC and non-Windows platforms
        hipDeviceAttributeLuidDeviceNodeMask:
            Luid device node mask. Undefined on TCC and non-Windows platforms
        hipDeviceAttributeComputeCapabilityMajor:
            Major compute capability version number.
        hipDeviceAttributeManagedMemory:
            Device supports allocating managed memory on this system
        hipDeviceAttributeMaxBlocksPerMultiProcessor:
            Max block size per multiprocessor
        hipDeviceAttributeMaxBlockDimX:
            Max block size in width.
        hipDeviceAttributeMaxBlockDimY:
            Max block size in height.
        hipDeviceAttributeMaxBlockDimZ:
            Max block size in depth.
        hipDeviceAttributeMaxGridDimX:
            Max grid size in width.
        hipDeviceAttributeMaxGridDimY:
            Max grid size in height.
        hipDeviceAttributeMaxGridDimZ:
            Max grid size in depth.
        hipDeviceAttributeMaxSurface1D:
            Maximum size of 1D surface.
        hipDeviceAttributeMaxSurface1DLayered:
            Cuda only. Maximum dimensions of 1D layered surface.
        hipDeviceAttributeMaxSurface2D:
            Maximum dimension (width, height) of 2D surface.
        hipDeviceAttributeMaxSurface2DLayered:
            Cuda only. Maximum dimensions of 2D layered surface.
        hipDeviceAttributeMaxSurface3D:
            Maximum dimension (width, height, depth) of 3D surface.
        hipDeviceAttributeMaxSurfaceCubemap:
            Cuda only. Maximum dimensions of Cubemap surface.
        hipDeviceAttributeMaxSurfaceCubemapLayered:
            Cuda only. Maximum dimension of Cubemap layered surface.
        hipDeviceAttributeMaxTexture1DWidth:
            Maximum size of 1D texture.
        hipDeviceAttributeMaxTexture1DLayered:
            Maximum dimensions of 1D layered texture.
        hipDeviceAttributeMaxTexture1DLinear:
            Maximum number of elements allocatable in a 1D linear texture. Use cudaDeviceGetTexture1DLinearMaxWidth() instead on Cuda.
        hipDeviceAttributeMaxTexture1DMipmap:
            Maximum size of 1D mipmapped texture.
        hipDeviceAttributeMaxTexture2DWidth:
            Maximum dimension width of 2D texture.
        hipDeviceAttributeMaxTexture2DHeight:
            Maximum dimension hight of 2D texture.
        hipDeviceAttributeMaxTexture2DGather:
            Maximum dimensions of 2D texture if gather operations performed.
        hipDeviceAttributeMaxTexture2DLayered:
            Maximum dimensions of 2D layered texture.
        hipDeviceAttributeMaxTexture2DLinear:
            Maximum dimensions (width, height, pitch) of 2D textures bound to pitched memory.
        hipDeviceAttributeMaxTexture2DMipmap:
            Maximum dimensions of 2D mipmapped texture.
        hipDeviceAttributeMaxTexture3DWidth:
            Maximum dimension width of 3D texture.
        hipDeviceAttributeMaxTexture3DHeight:
            Maximum dimension height of 3D texture.
        hipDeviceAttributeMaxTexture3DDepth:
            Maximum dimension depth of 3D texture.
        hipDeviceAttributeMaxTexture3DAlt:
            Maximum dimensions of alternate 3D texture.
        hipDeviceAttributeMaxTextureCubemap:
            Maximum dimensions of Cubemap texture
        hipDeviceAttributeMaxTextureCubemapLayered:
            Maximum dimensions of Cubemap layered texture.
        hipDeviceAttributeMaxThreadsDim:
            Maximum dimension of a block
        hipDeviceAttributeMaxThreadsPerBlock:
            Maximum number of threads per block.
        hipDeviceAttributeMaxThreadsPerMultiProcessor:
            Maximum resident threads per multiprocessor.
        hipDeviceAttributeMaxPitch:
            Maximum pitch in bytes allowed by memory copies
        hipDeviceAttributeMemoryBusWidth:
            Global memory bus width in bits.
        hipDeviceAttributeMemoryClockRate:
            Peak memory clock frequency in kilohertz.
        hipDeviceAttributeComputeCapabilityMinor:
            Minor compute capability version number.
        hipDeviceAttributeMultiGpuBoardGroupID:
            Unique ID of device group on the same multi-GPU board
        hipDeviceAttributeMultiprocessorCount:
            Number of multiprocessors on the device.
        hipDeviceAttributeUnused1:
            Previously hipDeviceAttributeName
        hipDeviceAttributePageableMemoryAccess:
            Device supports coherently accessing pageable memory without calling hipHostRegister on it
        hipDeviceAttributePageableMemoryAccessUsesHostPageTables:
            Device accesses pageable memory via the host's page tables
        hipDeviceAttributePciBusId:
            PCI Bus ID.
        hipDeviceAttributePciDeviceId:
            PCI Device ID.
        hipDeviceAttributePciDomainID:
            PCI Domain ID.
        hipDeviceAttributePersistingL2CacheMaxSize:
            Maximum l2 persisting lines capacity in bytes
        hipDeviceAttributeMaxRegistersPerBlock:
            32-bit registers available to a thread block. This number is shared by all thread blocks simultaneously resident on a multiprocessor.
        hipDeviceAttributeMaxRegistersPerMultiprocessor:
            32-bit registers available per block.
        hipDeviceAttributeReservedSharedMemPerBlock:
            Shared memory reserved by CUDA driver per block.
        hipDeviceAttributeMaxSharedMemoryPerBlock:
            Maximum shared memory available per block in bytes.
        hipDeviceAttributeSharedMemPerBlockOptin:
            Maximum shared memory per block usable by special opt in.
        hipDeviceAttributeSharedMemPerMultiprocessor:
            Shared memory available per multiprocessor.
        hipDeviceAttributeSingleToDoublePrecisionPerfRatio:
            Cuda only. Performance ratio of single precision to double precision.
        hipDeviceAttributeStreamPrioritiesSupported:
            Whether to support stream priorities.
        hipDeviceAttributeSurfaceAlignment:
            Alignment requirement for surfaces
        hipDeviceAttributeTccDriver:
            Cuda only. Whether device is a Tesla device using TCC driver
        hipDeviceAttributeTextureAlignment:
            Alignment requirement for textures
        hipDeviceAttributeTexturePitchAlignment:
            Pitch alignment requirement for 2D texture references bound to pitched memory;
        hipDeviceAttributeTotalConstantMemory:
            Constant memory size in bytes.
        hipDeviceAttributeTotalGlobalMem:
            Global memory available on devicice.
        hipDeviceAttributeUnifiedAddressing:
            Cuda only. An unified address space shared with the host.
        hipDeviceAttributeUnused2:
            Previously hipDeviceAttributeUuid
        hipDeviceAttributeWarpSize:
            Warp size in threads.
        hipDeviceAttributeMemoryPoolsSupported:
            Device supports HIP Stream Ordered Memory Allocator
        hipDeviceAttributeVirtualMemoryManagementSupported:
            Device supports HIP virtual memory management
        hipDeviceAttributeHostRegisterSupported:
            Can device support host memory registration via hipHostRegister
        hipDeviceAttributeMemoryPoolSupportedHandleTypes:
            Supported handle mask for HIP Stream Ordered Memory Allocator
        hipDeviceAttributeCudaCompatibleEnd:
            (undocumented)
        hipDeviceAttributeAmdSpecificBegin:
            (undocumented)
        hipDeviceAttributeClockInstructionRate:
            Frequency in khz of the timer used by the device-side "clock*"
        hipDeviceAttributeUnused3:
            Previously hipDeviceAttributeArch
        hipDeviceAttributeMaxSharedMemoryPerMultiprocessor:
            Maximum Shared Memory PerMultiprocessor.
        hipDeviceAttributeUnused4:
            Previously hipDeviceAttributeGcnArch
        hipDeviceAttributeUnused5:
            Previously hipDeviceAttributeGcnArchName
        hipDeviceAttributeHdpMemFlushCntl:
            Address of the HDP_MEM_COHERENCY_FLUSH_CNTL register
        hipDeviceAttributeHdpRegFlushCntl:
            Address of the HDP_REG_COHERENCY_FLUSH_CNTL register
        hipDeviceAttributeCooperativeMultiDeviceUnmatchedFunc:
            Supports cooperative launch on multiple devices with unmatched functions
        hipDeviceAttributeCooperativeMultiDeviceUnmatchedGridDim:
            Supports cooperative launch on multiple devices with unmatched grid dimensions
        hipDeviceAttributeCooperativeMultiDeviceUnmatchedBlockDim:
            Supports cooperative launch on multiple devices with unmatched block dimensions
        hipDeviceAttributeCooperativeMultiDeviceUnmatchedSharedMem:
            Supports cooperative launch on multiple devices with unmatched shared memories
        hipDeviceAttributeIsLargeBar:
            Whether it is LargeBar
        hipDeviceAttributeAsicRevision:
            Revision of the GPU in this device
        hipDeviceAttributeCanUseStreamWaitValue:
            '1' if Device supports hipStreamWaitValue32() and hipStreamWaitValue64(), '0' otherwise.
        hipDeviceAttributeImageSupport:
            '1' if Device supports image, '0' otherwise.
        hipDeviceAttributePhysicalMultiProcessorCount:
            All available physical compute units for the device
        hipDeviceAttributeFineGrainSupport:
            '1' if Device supports fine grain, '0' otherwise
        hipDeviceAttributeWallClockRate:
            Constant frequency of wall clock in kilohertz.
        hipDeviceAttributeAmdSpecificEnd:
            (undocumented)
        hipDeviceAttributeVendorSpecificBegin:
            (undocumented)
    """
    hipDeviceAttributeCudaCompatibleBegin = chip.hipDeviceAttributeCudaCompatibleBegin
    hipDeviceAttributeEccEnabled = chip.hipDeviceAttributeEccEnabled
    hipDeviceAttributeAccessPolicyMaxWindowSize = chip.hipDeviceAttributeAccessPolicyMaxWindowSize
    hipDeviceAttributeAsyncEngineCount = chip.hipDeviceAttributeAsyncEngineCount
    hipDeviceAttributeCanMapHostMemory = chip.hipDeviceAttributeCanMapHostMemory
    hipDeviceAttributeCanUseHostPointerForRegisteredMem = chip.hipDeviceAttributeCanUseHostPointerForRegisteredMem
    hipDeviceAttributeClockRate = chip.hipDeviceAttributeClockRate
    hipDeviceAttributeComputeMode = chip.hipDeviceAttributeComputeMode
    hipDeviceAttributeComputePreemptionSupported = chip.hipDeviceAttributeComputePreemptionSupported
    hipDeviceAttributeConcurrentKernels = chip.hipDeviceAttributeConcurrentKernels
    hipDeviceAttributeConcurrentManagedAccess = chip.hipDeviceAttributeConcurrentManagedAccess
    hipDeviceAttributeCooperativeLaunch = chip.hipDeviceAttributeCooperativeLaunch
    hipDeviceAttributeCooperativeMultiDeviceLaunch = chip.hipDeviceAttributeCooperativeMultiDeviceLaunch
    hipDeviceAttributeDeviceOverlap = chip.hipDeviceAttributeDeviceOverlap
    hipDeviceAttributeDirectManagedMemAccessFromHost = chip.hipDeviceAttributeDirectManagedMemAccessFromHost
    hipDeviceAttributeGlobalL1CacheSupported = chip.hipDeviceAttributeGlobalL1CacheSupported
    hipDeviceAttributeHostNativeAtomicSupported = chip.hipDeviceAttributeHostNativeAtomicSupported
    hipDeviceAttributeIntegrated = chip.hipDeviceAttributeIntegrated
    hipDeviceAttributeIsMultiGpuBoard = chip.hipDeviceAttributeIsMultiGpuBoard
    hipDeviceAttributeKernelExecTimeout = chip.hipDeviceAttributeKernelExecTimeout
    hipDeviceAttributeL2CacheSize = chip.hipDeviceAttributeL2CacheSize
    hipDeviceAttributeLocalL1CacheSupported = chip.hipDeviceAttributeLocalL1CacheSupported
    hipDeviceAttributeLuid = chip.hipDeviceAttributeLuid
    hipDeviceAttributeLuidDeviceNodeMask = chip.hipDeviceAttributeLuidDeviceNodeMask
    hipDeviceAttributeComputeCapabilityMajor = chip.hipDeviceAttributeComputeCapabilityMajor
    hipDeviceAttributeManagedMemory = chip.hipDeviceAttributeManagedMemory
    hipDeviceAttributeMaxBlocksPerMultiProcessor = chip.hipDeviceAttributeMaxBlocksPerMultiProcessor
    hipDeviceAttributeMaxBlockDimX = chip.hipDeviceAttributeMaxBlockDimX
    hipDeviceAttributeMaxBlockDimY = chip.hipDeviceAttributeMaxBlockDimY
    hipDeviceAttributeMaxBlockDimZ = chip.hipDeviceAttributeMaxBlockDimZ
    hipDeviceAttributeMaxGridDimX = chip.hipDeviceAttributeMaxGridDimX
    hipDeviceAttributeMaxGridDimY = chip.hipDeviceAttributeMaxGridDimY
    hipDeviceAttributeMaxGridDimZ = chip.hipDeviceAttributeMaxGridDimZ
    hipDeviceAttributeMaxSurface1D = chip.hipDeviceAttributeMaxSurface1D
    hipDeviceAttributeMaxSurface1DLayered = chip.hipDeviceAttributeMaxSurface1DLayered
    hipDeviceAttributeMaxSurface2D = chip.hipDeviceAttributeMaxSurface2D
    hipDeviceAttributeMaxSurface2DLayered = chip.hipDeviceAttributeMaxSurface2DLayered
    hipDeviceAttributeMaxSurface3D = chip.hipDeviceAttributeMaxSurface3D
    hipDeviceAttributeMaxSurfaceCubemap = chip.hipDeviceAttributeMaxSurfaceCubemap
    hipDeviceAttributeMaxSurfaceCubemapLayered = chip.hipDeviceAttributeMaxSurfaceCubemapLayered
    hipDeviceAttributeMaxTexture1DWidth = chip.hipDeviceAttributeMaxTexture1DWidth
    hipDeviceAttributeMaxTexture1DLayered = chip.hipDeviceAttributeMaxTexture1DLayered
    hipDeviceAttributeMaxTexture1DLinear = chip.hipDeviceAttributeMaxTexture1DLinear
    hipDeviceAttributeMaxTexture1DMipmap = chip.hipDeviceAttributeMaxTexture1DMipmap
    hipDeviceAttributeMaxTexture2DWidth = chip.hipDeviceAttributeMaxTexture2DWidth
    hipDeviceAttributeMaxTexture2DHeight = chip.hipDeviceAttributeMaxTexture2DHeight
    hipDeviceAttributeMaxTexture2DGather = chip.hipDeviceAttributeMaxTexture2DGather
    hipDeviceAttributeMaxTexture2DLayered = chip.hipDeviceAttributeMaxTexture2DLayered
    hipDeviceAttributeMaxTexture2DLinear = chip.hipDeviceAttributeMaxTexture2DLinear
    hipDeviceAttributeMaxTexture2DMipmap = chip.hipDeviceAttributeMaxTexture2DMipmap
    hipDeviceAttributeMaxTexture3DWidth = chip.hipDeviceAttributeMaxTexture3DWidth
    hipDeviceAttributeMaxTexture3DHeight = chip.hipDeviceAttributeMaxTexture3DHeight
    hipDeviceAttributeMaxTexture3DDepth = chip.hipDeviceAttributeMaxTexture3DDepth
    hipDeviceAttributeMaxTexture3DAlt = chip.hipDeviceAttributeMaxTexture3DAlt
    hipDeviceAttributeMaxTextureCubemap = chip.hipDeviceAttributeMaxTextureCubemap
    hipDeviceAttributeMaxTextureCubemapLayered = chip.hipDeviceAttributeMaxTextureCubemapLayered
    hipDeviceAttributeMaxThreadsDim = chip.hipDeviceAttributeMaxThreadsDim
    hipDeviceAttributeMaxThreadsPerBlock = chip.hipDeviceAttributeMaxThreadsPerBlock
    hipDeviceAttributeMaxThreadsPerMultiProcessor = chip.hipDeviceAttributeMaxThreadsPerMultiProcessor
    hipDeviceAttributeMaxPitch = chip.hipDeviceAttributeMaxPitch
    hipDeviceAttributeMemoryBusWidth = chip.hipDeviceAttributeMemoryBusWidth
    hipDeviceAttributeMemoryClockRate = chip.hipDeviceAttributeMemoryClockRate
    hipDeviceAttributeComputeCapabilityMinor = chip.hipDeviceAttributeComputeCapabilityMinor
    hipDeviceAttributeMultiGpuBoardGroupID = chip.hipDeviceAttributeMultiGpuBoardGroupID
    hipDeviceAttributeMultiprocessorCount = chip.hipDeviceAttributeMultiprocessorCount
    hipDeviceAttributeUnused1 = chip.hipDeviceAttributeUnused1
    hipDeviceAttributePageableMemoryAccess = chip.hipDeviceAttributePageableMemoryAccess
    hipDeviceAttributePageableMemoryAccessUsesHostPageTables = chip.hipDeviceAttributePageableMemoryAccessUsesHostPageTables
    hipDeviceAttributePciBusId = chip.hipDeviceAttributePciBusId
    hipDeviceAttributePciDeviceId = chip.hipDeviceAttributePciDeviceId
    hipDeviceAttributePciDomainID = chip.hipDeviceAttributePciDomainID
    hipDeviceAttributePersistingL2CacheMaxSize = chip.hipDeviceAttributePersistingL2CacheMaxSize
    hipDeviceAttributeMaxRegistersPerBlock = chip.hipDeviceAttributeMaxRegistersPerBlock
    hipDeviceAttributeMaxRegistersPerMultiprocessor = chip.hipDeviceAttributeMaxRegistersPerMultiprocessor
    hipDeviceAttributeReservedSharedMemPerBlock = chip.hipDeviceAttributeReservedSharedMemPerBlock
    hipDeviceAttributeMaxSharedMemoryPerBlock = chip.hipDeviceAttributeMaxSharedMemoryPerBlock
    hipDeviceAttributeSharedMemPerBlockOptin = chip.hipDeviceAttributeSharedMemPerBlockOptin
    hipDeviceAttributeSharedMemPerMultiprocessor = chip.hipDeviceAttributeSharedMemPerMultiprocessor
    hipDeviceAttributeSingleToDoublePrecisionPerfRatio = chip.hipDeviceAttributeSingleToDoublePrecisionPerfRatio
    hipDeviceAttributeStreamPrioritiesSupported = chip.hipDeviceAttributeStreamPrioritiesSupported
    hipDeviceAttributeSurfaceAlignment = chip.hipDeviceAttributeSurfaceAlignment
    hipDeviceAttributeTccDriver = chip.hipDeviceAttributeTccDriver
    hipDeviceAttributeTextureAlignment = chip.hipDeviceAttributeTextureAlignment
    hipDeviceAttributeTexturePitchAlignment = chip.hipDeviceAttributeTexturePitchAlignment
    hipDeviceAttributeTotalConstantMemory = chip.hipDeviceAttributeTotalConstantMemory
    hipDeviceAttributeTotalGlobalMem = chip.hipDeviceAttributeTotalGlobalMem
    hipDeviceAttributeUnifiedAddressing = chip.hipDeviceAttributeUnifiedAddressing
    hipDeviceAttributeUnused2 = chip.hipDeviceAttributeUnused2
    hipDeviceAttributeWarpSize = chip.hipDeviceAttributeWarpSize
    hipDeviceAttributeMemoryPoolsSupported = chip.hipDeviceAttributeMemoryPoolsSupported
    hipDeviceAttributeVirtualMemoryManagementSupported = chip.hipDeviceAttributeVirtualMemoryManagementSupported
    hipDeviceAttributeHostRegisterSupported = chip.hipDeviceAttributeHostRegisterSupported
    hipDeviceAttributeMemoryPoolSupportedHandleTypes = chip.hipDeviceAttributeMemoryPoolSupportedHandleTypes
    hipDeviceAttributeCudaCompatibleEnd = chip.hipDeviceAttributeCudaCompatibleEnd
    hipDeviceAttributeAmdSpecificBegin = chip.hipDeviceAttributeAmdSpecificBegin
    hipDeviceAttributeClockInstructionRate = chip.hipDeviceAttributeClockInstructionRate
    hipDeviceAttributeUnused3 = chip.hipDeviceAttributeUnused3
    hipDeviceAttributeMaxSharedMemoryPerMultiprocessor = chip.hipDeviceAttributeMaxSharedMemoryPerMultiprocessor
    hipDeviceAttributeUnused4 = chip.hipDeviceAttributeUnused4
    hipDeviceAttributeUnused5 = chip.hipDeviceAttributeUnused5
    hipDeviceAttributeHdpMemFlushCntl = chip.hipDeviceAttributeHdpMemFlushCntl
    hipDeviceAttributeHdpRegFlushCntl = chip.hipDeviceAttributeHdpRegFlushCntl
    hipDeviceAttributeCooperativeMultiDeviceUnmatchedFunc = chip.hipDeviceAttributeCooperativeMultiDeviceUnmatchedFunc
    hipDeviceAttributeCooperativeMultiDeviceUnmatchedGridDim = chip.hipDeviceAttributeCooperativeMultiDeviceUnmatchedGridDim
    hipDeviceAttributeCooperativeMultiDeviceUnmatchedBlockDim = chip.hipDeviceAttributeCooperativeMultiDeviceUnmatchedBlockDim
    hipDeviceAttributeCooperativeMultiDeviceUnmatchedSharedMem = chip.hipDeviceAttributeCooperativeMultiDeviceUnmatchedSharedMem
    hipDeviceAttributeIsLargeBar = chip.hipDeviceAttributeIsLargeBar
    hipDeviceAttributeAsicRevision = chip.hipDeviceAttributeAsicRevision
    hipDeviceAttributeCanUseStreamWaitValue = chip.hipDeviceAttributeCanUseStreamWaitValue
    hipDeviceAttributeImageSupport = chip.hipDeviceAttributeImageSupport
    hipDeviceAttributePhysicalMultiProcessorCount = chip.hipDeviceAttributePhysicalMultiProcessorCount
    hipDeviceAttributeFineGrainSupport = chip.hipDeviceAttributeFineGrainSupport
    hipDeviceAttributeWallClockRate = chip.hipDeviceAttributeWallClockRate
    hipDeviceAttributeAmdSpecificEnd = chip.hipDeviceAttributeAmdSpecificEnd
    hipDeviceAttributeVendorSpecificBegin = chip.hipDeviceAttributeVendorSpecificBegin
    @staticmethod
    def ctypes_type():
        """The type of the enum constants as ctypes type."""
        return ctypes.c_uint


class _hipDriverProcAddressQueryResult__Base(enum.IntEnum):
    """Empty enum base class that allows subclassing.
    """
    pass
class hipDriverProcAddressQueryResult(_hipDriverProcAddressQueryResult__Base):
    """hipDriverProcAddressQueryResult

    Attributes:
        HIP_GET_PROC_ADDRESS_SUCCESS:
            (undocumented)
        HIP_GET_PROC_ADDRESS_SYMBOL_NOT_FOUND:
            (undocumented)
        HIP_GET_PROC_ADDRESS_VERSION_NOT_SUFFICIENT:
            (undocumented)
    """
    HIP_GET_PROC_ADDRESS_SUCCESS = chip.HIP_GET_PROC_ADDRESS_SUCCESS
    HIP_GET_PROC_ADDRESS_SYMBOL_NOT_FOUND = chip.HIP_GET_PROC_ADDRESS_SYMBOL_NOT_FOUND
    HIP_GET_PROC_ADDRESS_VERSION_NOT_SUFFICIENT = chip.HIP_GET_PROC_ADDRESS_VERSION_NOT_SUFFICIENT
    @staticmethod
    def ctypes_type():
        """The type of the enum constants as ctypes type."""
        return ctypes.c_uint


class _hipComputeMode__Base(enum.IntEnum):
    """Empty enum base class that allows subclassing.
    """
    pass
class hipComputeMode(_hipComputeMode__Base):
    """hipComputeMode

    Attributes:
        hipComputeModeDefault:
            (undocumented)
        hipComputeModeExclusive:
            (undocumented)
        hipComputeModeProhibited:
            (undocumented)
        hipComputeModeExclusiveProcess:
            (undocumented)
    """
    hipComputeModeDefault = chip.hipComputeModeDefault
    hipComputeModeExclusive = chip.hipComputeModeExclusive
    hipComputeModeProhibited = chip.hipComputeModeProhibited
    hipComputeModeExclusiveProcess = chip.hipComputeModeExclusiveProcess
    @staticmethod
    def ctypes_type():
        """The type of the enum constants as ctypes type."""
        return ctypes.c_uint


class _hipFlushGPUDirectRDMAWritesOptions__Base(enum.IntEnum):
    """Empty enum base class that allows subclassing.
    """
    pass
class hipFlushGPUDirectRDMAWritesOptions(_hipFlushGPUDirectRDMAWritesOptions__Base):
    """hipFlushGPUDirectRDMAWritesOptions

    Attributes:
        hipFlushGPUDirectRDMAWritesOptionHost:
            (undocumented)
        hipFlushGPUDirectRDMAWritesOptionMemOps:
            (undocumented)
    """
    hipFlushGPUDirectRDMAWritesOptionHost = chip.hipFlushGPUDirectRDMAWritesOptionHost
    hipFlushGPUDirectRDMAWritesOptionMemOps = chip.hipFlushGPUDirectRDMAWritesOptionMemOps
    @staticmethod
    def ctypes_type():
        """The type of the enum constants as ctypes type."""
        return ctypes.c_uint


class _hipGPUDirectRDMAWritesOrdering__Base(enum.IntEnum):
    """Empty enum base class that allows subclassing.
    """
    pass
class hipGPUDirectRDMAWritesOrdering(_hipGPUDirectRDMAWritesOrdering__Base):
    """hipGPUDirectRDMAWritesOrdering

    Attributes:
        hipGPUDirectRDMAWritesOrderingNone:
            (undocumented)
        hipGPUDirectRDMAWritesOrderingOwner:
            (undocumented)
        hipGPUDirectRDMAWritesOrderingAllDevices:
            (undocumented)
    """
    hipGPUDirectRDMAWritesOrderingNone = chip.hipGPUDirectRDMAWritesOrderingNone
    hipGPUDirectRDMAWritesOrderingOwner = chip.hipGPUDirectRDMAWritesOrderingOwner
    hipGPUDirectRDMAWritesOrderingAllDevices = chip.hipGPUDirectRDMAWritesOrderingAllDevices
    @staticmethod
    def ctypes_type():
        """The type of the enum constants as ctypes type."""
        return ctypes.c_uint


class _hipChannelFormatKind__Base(enum.IntEnum):
    """Empty enum base class that allows subclassing.
    """
    pass
class hipChannelFormatKind(_hipChannelFormatKind__Base):
    """hipChannelFormatKind

    Attributes:
        hipChannelFormatKindSigned:
            (undocumented)
        hipChannelFormatKindUnsigned:
            (undocumented)
        hipChannelFormatKindFloat:
            (undocumented)
        hipChannelFormatKindNone:
            (undocumented)
    """
    hipChannelFormatKindSigned = chip.hipChannelFormatKindSigned
    hipChannelFormatKindUnsigned = chip.hipChannelFormatKindUnsigned
    hipChannelFormatKindFloat = chip.hipChannelFormatKindFloat
    hipChannelFormatKindNone = chip.hipChannelFormatKindNone
    @staticmethod
    def ctypes_type():
        """The type of the enum constants as ctypes type."""
        return ctypes.c_uint


cdef class hipChannelFormatDesc(hip._util.types.Pointer):
    """Python wrapper for cdef class chip.hipChannelFormatDesc.

    Python wrapper for cdef class chip.hipChannelFormatDesc.

    If this type is initialized via its `__init__` method, it allocates a
    member of the underlying C type and destroys it again if the wrapper
    type is deallocated.

    This type also serves as adapter when appearing as argument type in a
    function signature. In this case, the type can further be initialized
    from a number of Python objects:

    * `None`:

      This will set the ``self._ptr`` attribute to ``NULL``.

    * `int`:

      Interprets the integer value as pointer address and writes it to ``self._ptr``.
      No ownership is transferred.

    * `ctypes.c_void_p`:

      Takes the pointer address ``pyobj.value`` and writes it to ``self._ptr``.
      No ownership is transferred.

    * `object` that implements the `CUDA Array Interface <https://numba.readthedocs.io/en/stable/cuda/cuda_array_interface.html>`_ protocol:

      Takes the integer-valued pointer address, i.e. the first entry of the `data` tuple
      from `pyobj`'s member ``__cuda_array_interface__``  and writes it to ``self._ptr``.

    * `object` that implements the Python buffer protocol:

      If the object represents a simple contiguous array,
      writes the `Py_buffer` associated with ``pyobj`` to `self._py_buffer`,
      sets the `self._py_buffer_acquired` flag to `True`, and
      writes `self._py_buffer.buf` to the data pointer `self._ptr`.

    * `hip._util.types.Pointer`:

      Takes the pointer address ``pyobj._ptr`` and writes it to ``self._ptr``.
      No ownership is transferred.

    Type checks are performed in the above order.

    C Attributes:
        _ptr (C type ``void *``, protected):
            Stores a pointer to the data of the original Python object.
        _is_ptr_owner (C type ``bint``, protected):
            If this wrapper is the owner of the underlying data.
        _py_buffer (C type ``Py_buffer`, protected):
            Stores a pointer to the data of the original Python object.
        _py_buffer_acquired (C type ``bint``, protected):
            Stores a pointer to the data of the original Python object.
    """
    # C members declared in pxd file

    def __cinit__(self):
        self._ptr = NULL
        self._is_ptr_owner = False
        self._py_buffer_acquired = False

    cdef chip.hipChannelFormatDesc* getElementPtr(self):
        return <chip.hipChannelFormatDesc*>self._ptr

    @staticmethod
    cdef hipChannelFormatDesc fromPtr(void* ptr, bint owner=False):
        """Factory function to create ``hipChannelFormatDesc`` objects from
        given ``chip.hipChannelFormatDesc`` pointer.

        Setting ``owner`` flag to ``True`` causes
        the extension type to free the structure pointed to by ``ptr``
        when the wrapper object is deallocated.
        """
        # Fast call to __new__() that bypasses the __init__() constructor.
        cdef hipChannelFormatDesc wrapper = hipChannelFormatDesc.__new__(hipChannelFormatDesc)
        wrapper._ptr = ptr
        wrapper._is_ptr_owner = owner
        return wrapper

    @staticmethod
    def fromObj(pyobj):
        """Creates a hipChannelFormatDesc from a Python object.

        Derives a hipChannelFormatDesc from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``hipChannelFormatDesc`` reference, this method
        returns it directly. No new ``hipChannelFormatDesc`` is created in this case.
        """
        return hipChannelFormatDesc.fromPyobj(pyobj)

    @staticmethod
    cdef hipChannelFormatDesc fromPyobj(object pyobj):
        """Creates a hipChannelFormatDesc from a Python object.

        Derives a hipChannelFormatDesc from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``hipChannelFormatDesc`` reference, this method
        returns it directly. No new ``hipChannelFormatDesc`` is created in this case.

        Args:
            pyobj (object): Must be either `None`; a `hip._util.types.Pointer`; a simple, contiguous buffer according to the buffer protocol;
                            or of type `hipChannelFormatDesc`; `int`; or `ctypes.c_void_p`.

        Note:
            This routine does not perform a copy but returns the original ``pyobj``
            if ``pyobj`` is an instance of hipChannelFormatDesc!
        """
        cdef hipChannelFormatDesc wrapper

        if isinstance(pyobj,hipChannelFormatDesc):
            return pyobj
        else:
            wrapper = hipChannelFormatDesc.__new__(hipChannelFormatDesc)
            wrapper.init_from_pyobj(pyobj)
            return wrapper

    def __dealloc__(self):
        # Release the buffer handle
        if self._py_buffer_acquired is True:
            cpython.buffer.PyBuffer_Release(&self._py_buffer)
        # De-allocate if not null and flag is set
        if self._ptr is not NULL and self._is_ptr_owner is True:
            stdlib.free(self._ptr)
            self._ptr = NULL

    @staticmethod
    cdef __allocate(void** ptr):
        ptr[0] = stdlib.malloc(sizeof(chip.hipChannelFormatDesc))
        string.memset(<void*>ptr[0], 0, sizeof(chip.hipChannelFormatDesc))

        if ptr[0] is NULL:
            raise MemoryError

    @staticmethod
    cdef hipChannelFormatDesc new():
        """Factory function to create hipChannelFormatDesc objects with
        newly allocated chip.hipChannelFormatDesc"""
        cdef void* ptr
        hipChannelFormatDesc.__allocate(&ptr)
        return hipChannelFormatDesc.fromPtr(ptr, owner=True)

    @staticmethod
    cdef hipChannelFormatDesc fromValue(chip.hipChannelFormatDesc other):
        """Allocate new C type and copy from ``other``.
        """
        wrapper = hipChannelFormatDesc.new()
        string.memcpy(wrapper._ptr, &other, sizeof(chip.hipChannelFormatDesc))
        return wrapper

    def c_sizeof(self):
        """Returns the size of the underlying C type in bytes.
        Note:
            Implemented as function to not collide with
            autogenerated property names.
        """
        return sizeof(chip.hipChannelFormatDesc)

    def __int__(self):
        """Returns the data's address as long integer.
        """
        return cpython.long.PyLong_FromVoidPtr(self._ptr)

    def __repr__(self):
        return f"<hipChannelFormatDesc object, ptr: {int(self)}>"

    def as_c_void_p(self):
        """Returns the data's address as `ctypes.c_void_p`
        Note:
            Implemented as function to not collide with
            autogenerated property names.
        """
        return ctypes.c_void_p(int(self))

    def __init__(self,*args,**kwargs):
        """Constructor type hipChannelFormatDesc.

        Constructor for type hipChannelFormatDesc.

        Args:
            *args:
                Positional arguments. Initialize all or a subset of the member variables
                according to their order of declaration.
            **kwargs:
                Can be used to initialize member variables at construction,
                Just pass an argument expression of the form <member>=<value>
                per member that you want to initialize.
        """
        hipChannelFormatDesc.__allocate(&self._ptr)
        self._is_ptr_owner = True
        attribs = self.PROPERTIES()
        used_attribs = set()
        if len(args) > len(attribs):
            raise ValueError("More positional arguments specified than this type has properties.")
        for i,v in enumerate(args):
            setattr(self,attribs[i],v)
            used_attribs.add(attribs[i])
        valid_names = ", ".join(["'"+p+"'" for p in attribs])
        for k,v in kwargs.items():
            if k in used_attribs:
                raise KeyError(f"argument '{k}' has already been specified as positional argument.")
            elif k not in attribs:
                raise KeyError(f"'{k}' is no valid property name. Valid names: {valid_names}")
            setattr(self,k,v)
    def get_x(self, i):
        """Get value ``x`` of ``(<chip.hipChannelFormatDesc*>self._ptr)[i]``.
        """
        return (<chip.hipChannelFormatDesc*>self._ptr)[i].x
    def set_x(self, i, int value):
        """Set value ``x`` of ``(<chip.hipChannelFormatDesc*>self._ptr)[i]``.
        """
        (<chip.hipChannelFormatDesc*>self._ptr)[i].x = value
    @property
    def x(self):
        """(undocumented)"""
        return self.get_x(0)
    @x.setter
    def x(self, int value):
        self.set_x(0,value)

    def get_y(self, i):
        """Get value ``y`` of ``(<chip.hipChannelFormatDesc*>self._ptr)[i]``.
        """
        return (<chip.hipChannelFormatDesc*>self._ptr)[i].y
    def set_y(self, i, int value):
        """Set value ``y`` of ``(<chip.hipChannelFormatDesc*>self._ptr)[i]``.
        """
        (<chip.hipChannelFormatDesc*>self._ptr)[i].y = value
    @property
    def y(self):
        """(undocumented)"""
        return self.get_y(0)
    @y.setter
    def y(self, int value):
        self.set_y(0,value)

    def get_z(self, i):
        """Get value ``z`` of ``(<chip.hipChannelFormatDesc*>self._ptr)[i]``.
        """
        return (<chip.hipChannelFormatDesc*>self._ptr)[i].z
    def set_z(self, i, int value):
        """Set value ``z`` of ``(<chip.hipChannelFormatDesc*>self._ptr)[i]``.
        """
        (<chip.hipChannelFormatDesc*>self._ptr)[i].z = value
    @property
    def z(self):
        """(undocumented)"""
        return self.get_z(0)
    @z.setter
    def z(self, int value):
        self.set_z(0,value)

    def get_w(self, i):
        """Get value ``w`` of ``(<chip.hipChannelFormatDesc*>self._ptr)[i]``.
        """
        return (<chip.hipChannelFormatDesc*>self._ptr)[i].w
    def set_w(self, i, int value):
        """Set value ``w`` of ``(<chip.hipChannelFormatDesc*>self._ptr)[i]``.
        """
        (<chip.hipChannelFormatDesc*>self._ptr)[i].w = value
    @property
    def w(self):
        """(undocumented)"""
        return self.get_w(0)
    @w.setter
    def w(self, int value):
        self.set_w(0,value)

    def get_f(self, i):
        """Get value of ``f`` of ``(<chip.hipChannelFormatDesc*>self._ptr)[i]``.
        """
        return hipChannelFormatKind((<chip.hipChannelFormatDesc*>self._ptr)[i].f)
    def set_f(self, i, value):
        """Set value ``f`` of ``(<chip.hipChannelFormatDesc*>self._ptr)[i]``.
        """
        if not isinstance(value, hipChannelFormatKind):
            raise TypeError("'value' must be of type 'hipChannelFormatKind'")
        (<chip.hipChannelFormatDesc*>self._ptr)[i].f = value.value
    @property
    def f(self):
        """(undocumented)"""
        return self.get_f(0)
    @f.setter
    def f(self, value):
        self.set_f(0,value)

    @staticmethod
    def PROPERTIES():
        return ["x","y","z","w","f"]

    def __contains__(self,item):
        properties = self.PROPERTIES()
        return item in properties

    def __getitem__(self,item):
        properties = self.PROPERTIES()
        if isinstance(item,int):
            if item < 0 or item >= len(properties):
                raise IndexError()
            return getattr(self,properties[item])
        raise ValueError("'item' type must be 'int'")


cdef class hipArray(hip._util.types.Pointer):
    """Python wrapper for cdef class chip.hipArray.

    Python wrapper for cdef class chip.hipArray.

    If this type is initialized via its `__init__` method, it allocates a
    member of the underlying C type and destroys it again if the wrapper
    type is deallocated.

    This type also serves as adapter when appearing as argument type in a
    function signature. In this case, the type can further be initialized
    from a number of Python objects:

    * `None`:

      This will set the ``self._ptr`` attribute to ``NULL``.

    * `int`:

      Interprets the integer value as pointer address and writes it to ``self._ptr``.
      No ownership is transferred.

    * `ctypes.c_void_p`:

      Takes the pointer address ``pyobj.value`` and writes it to ``self._ptr``.
      No ownership is transferred.

    * `object` that implements the `CUDA Array Interface <https://numba.readthedocs.io/en/stable/cuda/cuda_array_interface.html>`_ protocol:

      Takes the integer-valued pointer address, i.e. the first entry of the `data` tuple
      from `pyobj`'s member ``__cuda_array_interface__``  and writes it to ``self._ptr``.

    * `object` that implements the Python buffer protocol:

      If the object represents a simple contiguous array,
      writes the `Py_buffer` associated with ``pyobj`` to `self._py_buffer`,
      sets the `self._py_buffer_acquired` flag to `True`, and
      writes `self._py_buffer.buf` to the data pointer `self._ptr`.

    * `hip._util.types.Pointer`:

      Takes the pointer address ``pyobj._ptr`` and writes it to ``self._ptr``.
      No ownership is transferred.

    Type checks are performed in the above order.

    C Attributes:
        _ptr (C type ``void *``, protected):
            Stores a pointer to the data of the original Python object.
        _is_ptr_owner (C type ``bint``, protected):
            If this wrapper is the owner of the underlying data.
        _py_buffer (C type ``Py_buffer`, protected):
            Stores a pointer to the data of the original Python object.
        _py_buffer_acquired (C type ``bint``, protected):
            Stores a pointer to the data of the original Python object.
    """
    # C members declared in pxd file

    def __cinit__(self):
        self._ptr = NULL
        self._is_ptr_owner = False
        self._py_buffer_acquired = False

    cdef chip.hipArray* getElementPtr(self):
        return <chip.hipArray*>self._ptr

    @staticmethod
    cdef hipArray fromPtr(void* ptr, bint owner=False):
        """Factory function to create ``hipArray`` objects from
        given ``chip.hipArray`` pointer.
        """
        # Fast call to __new__() that bypasses the __init__() constructor.
        cdef hipArray wrapper = hipArray.__new__(hipArray)
        wrapper._ptr = ptr
        wrapper._is_ptr_owner = owner
        return wrapper

    @staticmethod
    def fromObj(pyobj):
        """Creates a hipArray from a Python object.

        Derives a hipArray from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``hipArray`` reference, this method
        returns it directly. No new ``hipArray`` is created in this case.
        """
        return hipArray.fromPyobj(pyobj)

    @staticmethod
    cdef hipArray fromPyobj(object pyobj):
        """Creates a hipArray from a Python object.

        Derives a hipArray from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``hipArray`` reference, this method
        returns it directly. No new ``hipArray`` is created in this case.

        Args:
            pyobj (object): Must be either `None`; a `hip._util.types.Pointer`; a simple, contiguous buffer according to the buffer protocol;
                            or of type `hipArray`; `int`; or `ctypes.c_void_p`.

        Note:
            This routine does not perform a copy but returns the original ``pyobj``
            if ``pyobj`` is an instance of hipArray!
        """
        cdef hipArray wrapper

        if isinstance(pyobj,hipArray):
            return pyobj
        else:
            wrapper = hipArray.__new__(hipArray)
            wrapper.init_from_pyobj(pyobj)
            return wrapper

    def __dealloc__(self):
        # Release the buffer handle
        if self._py_buffer_acquired is True:
            cpython.buffer.PyBuffer_Release(&self._py_buffer)

    def __int__(self):
        """Returns the data's address as long integer.
        """
        return cpython.long.PyLong_FromVoidPtr(self._ptr)

    def __repr__(self):
        return f"<hipArray object, ptr: {int(self)}>"

    def as_c_void_p(self):
        """Returns the data's address as `ctypes.c_void_p`
        Note:
            Implemented as function to not collide with
            autogenerated property names.
        """
        return ctypes.c_void_p(int(self))

    @staticmethod
    def PROPERTIES():
        return []

    def __contains__(self,item):
        properties = self.PROPERTIES()
        return item in properties

    def __getitem__(self,item):
        properties = self.PROPERTIES()
        if isinstance(item,int):
            if item < 0 or item >= len(properties):
                raise IndexError()
            return getattr(self,properties[item])
        raise ValueError("'item' type must be 'int'")


hipArray_t = hipArray

hipArray_const_t = hipArray

class _hipArray_Format__Base(enum.IntEnum):
    """Empty enum base class that allows subclassing.
    """
    pass
class hipArray_Format(_hipArray_Format__Base):
    """hipArray_Format

    Attributes:
        HIP_AD_FORMAT_UNSIGNED_INT8:
            (undocumented)
        HIP_AD_FORMAT_UNSIGNED_INT16:
            (undocumented)
        HIP_AD_FORMAT_UNSIGNED_INT32:
            (undocumented)
        HIP_AD_FORMAT_SIGNED_INT8:
            (undocumented)
        HIP_AD_FORMAT_SIGNED_INT16:
            (undocumented)
        HIP_AD_FORMAT_SIGNED_INT32:
            (undocumented)
        HIP_AD_FORMAT_HALF:
            (undocumented)
        HIP_AD_FORMAT_FLOAT:
            (undocumented)
    """
    HIP_AD_FORMAT_UNSIGNED_INT8 = chip.HIP_AD_FORMAT_UNSIGNED_INT8
    HIP_AD_FORMAT_UNSIGNED_INT16 = chip.HIP_AD_FORMAT_UNSIGNED_INT16
    HIP_AD_FORMAT_UNSIGNED_INT32 = chip.HIP_AD_FORMAT_UNSIGNED_INT32
    HIP_AD_FORMAT_SIGNED_INT8 = chip.HIP_AD_FORMAT_SIGNED_INT8
    HIP_AD_FORMAT_SIGNED_INT16 = chip.HIP_AD_FORMAT_SIGNED_INT16
    HIP_AD_FORMAT_SIGNED_INT32 = chip.HIP_AD_FORMAT_SIGNED_INT32
    HIP_AD_FORMAT_HALF = chip.HIP_AD_FORMAT_HALF
    HIP_AD_FORMAT_FLOAT = chip.HIP_AD_FORMAT_FLOAT
    @staticmethod
    def ctypes_type():
        """The type of the enum constants as ctypes type."""
        return ctypes.c_uint


cdef class HIP_ARRAY_DESCRIPTOR(hip._util.types.Pointer):
    """Python wrapper for cdef class chip.HIP_ARRAY_DESCRIPTOR.

    Python wrapper for cdef class chip.HIP_ARRAY_DESCRIPTOR.

    If this type is initialized via its `__init__` method, it allocates a
    member of the underlying C type and destroys it again if the wrapper
    type is deallocated.

    This type also serves as adapter when appearing as argument type in a
    function signature. In this case, the type can further be initialized
    from a number of Python objects:

    * `None`:

      This will set the ``self._ptr`` attribute to ``NULL``.

    * `int`:

      Interprets the integer value as pointer address and writes it to ``self._ptr``.
      No ownership is transferred.

    * `ctypes.c_void_p`:

      Takes the pointer address ``pyobj.value`` and writes it to ``self._ptr``.
      No ownership is transferred.

    * `object` that implements the `CUDA Array Interface <https://numba.readthedocs.io/en/stable/cuda/cuda_array_interface.html>`_ protocol:

      Takes the integer-valued pointer address, i.e. the first entry of the `data` tuple
      from `pyobj`'s member ``__cuda_array_interface__``  and writes it to ``self._ptr``.

    * `object` that implements the Python buffer protocol:

      If the object represents a simple contiguous array,
      writes the `Py_buffer` associated with ``pyobj`` to `self._py_buffer`,
      sets the `self._py_buffer_acquired` flag to `True`, and
      writes `self._py_buffer.buf` to the data pointer `self._ptr`.

    * `hip._util.types.Pointer`:

      Takes the pointer address ``pyobj._ptr`` and writes it to ``self._ptr``.
      No ownership is transferred.

    Type checks are performed in the above order.

    C Attributes:
        _ptr (C type ``void *``, protected):
            Stores a pointer to the data of the original Python object.
        _is_ptr_owner (C type ``bint``, protected):
            If this wrapper is the owner of the underlying data.
        _py_buffer (C type ``Py_buffer`, protected):
            Stores a pointer to the data of the original Python object.
        _py_buffer_acquired (C type ``bint``, protected):
            Stores a pointer to the data of the original Python object.
    """
    # C members declared in pxd file

    def __cinit__(self):
        self._ptr = NULL
        self._is_ptr_owner = False
        self._py_buffer_acquired = False

    cdef chip.HIP_ARRAY_DESCRIPTOR* getElementPtr(self):
        return <chip.HIP_ARRAY_DESCRIPTOR*>self._ptr

    @staticmethod
    cdef HIP_ARRAY_DESCRIPTOR fromPtr(void* ptr, bint owner=False):
        """Factory function to create ``HIP_ARRAY_DESCRIPTOR`` objects from
        given ``chip.HIP_ARRAY_DESCRIPTOR`` pointer.

        Setting ``owner`` flag to ``True`` causes
        the extension type to free the structure pointed to by ``ptr``
        when the wrapper object is deallocated.
        """
        # Fast call to __new__() that bypasses the __init__() constructor.
        cdef HIP_ARRAY_DESCRIPTOR wrapper = HIP_ARRAY_DESCRIPTOR.__new__(HIP_ARRAY_DESCRIPTOR)
        wrapper._ptr = ptr
        wrapper._is_ptr_owner = owner
        return wrapper

    @staticmethod
    def fromObj(pyobj):
        """Creates a HIP_ARRAY_DESCRIPTOR from a Python object.

        Derives a HIP_ARRAY_DESCRIPTOR from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``HIP_ARRAY_DESCRIPTOR`` reference, this method
        returns it directly. No new ``HIP_ARRAY_DESCRIPTOR`` is created in this case.
        """
        return HIP_ARRAY_DESCRIPTOR.fromPyobj(pyobj)

    @staticmethod
    cdef HIP_ARRAY_DESCRIPTOR fromPyobj(object pyobj):
        """Creates a HIP_ARRAY_DESCRIPTOR from a Python object.

        Derives a HIP_ARRAY_DESCRIPTOR from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``HIP_ARRAY_DESCRIPTOR`` reference, this method
        returns it directly. No new ``HIP_ARRAY_DESCRIPTOR`` is created in this case.

        Args:
            pyobj (object): Must be either `None`; a `hip._util.types.Pointer`; a simple, contiguous buffer according to the buffer protocol;
                            or of type `HIP_ARRAY_DESCRIPTOR`; `int`; or `ctypes.c_void_p`.

        Note:
            This routine does not perform a copy but returns the original ``pyobj``
            if ``pyobj`` is an instance of HIP_ARRAY_DESCRIPTOR!
        """
        cdef HIP_ARRAY_DESCRIPTOR wrapper

        if isinstance(pyobj,HIP_ARRAY_DESCRIPTOR):
            return pyobj
        else:
            wrapper = HIP_ARRAY_DESCRIPTOR.__new__(HIP_ARRAY_DESCRIPTOR)
            wrapper.init_from_pyobj(pyobj)
            return wrapper

    def __dealloc__(self):
        # Release the buffer handle
        if self._py_buffer_acquired is True:
            cpython.buffer.PyBuffer_Release(&self._py_buffer)
        # De-allocate if not null and flag is set
        if self._ptr is not NULL and self._is_ptr_owner is True:
            stdlib.free(self._ptr)
            self._ptr = NULL

    @staticmethod
    cdef __allocate(void** ptr):
        ptr[0] = stdlib.malloc(sizeof(chip.HIP_ARRAY_DESCRIPTOR))
        string.memset(<void*>ptr[0], 0, sizeof(chip.HIP_ARRAY_DESCRIPTOR))

        if ptr[0] is NULL:
            raise MemoryError

    @staticmethod
    cdef HIP_ARRAY_DESCRIPTOR new():
        """Factory function to create HIP_ARRAY_DESCRIPTOR objects with
        newly allocated chip.HIP_ARRAY_DESCRIPTOR"""
        cdef void* ptr
        HIP_ARRAY_DESCRIPTOR.__allocate(&ptr)
        return HIP_ARRAY_DESCRIPTOR.fromPtr(ptr, owner=True)

    @staticmethod
    cdef HIP_ARRAY_DESCRIPTOR fromValue(chip.HIP_ARRAY_DESCRIPTOR other):
        """Allocate new C type and copy from ``other``.
        """
        wrapper = HIP_ARRAY_DESCRIPTOR.new()
        string.memcpy(wrapper._ptr, &other, sizeof(chip.HIP_ARRAY_DESCRIPTOR))
        return wrapper

    def c_sizeof(self):
        """Returns the size of the underlying C type in bytes.
        Note:
            Implemented as function to not collide with
            autogenerated property names.
        """
        return sizeof(chip.HIP_ARRAY_DESCRIPTOR)

    def __int__(self):
        """Returns the data's address as long integer.
        """
        return cpython.long.PyLong_FromVoidPtr(self._ptr)

    def __repr__(self):
        return f"<HIP_ARRAY_DESCRIPTOR object, ptr: {int(self)}>"

    def as_c_void_p(self):
        """Returns the data's address as `ctypes.c_void_p`
        Note:
            Implemented as function to not collide with
            autogenerated property names.
        """
        return ctypes.c_void_p(int(self))

    def __init__(self,*args,**kwargs):
        """Constructor type HIP_ARRAY_DESCRIPTOR.

        Constructor for type HIP_ARRAY_DESCRIPTOR.

        Args:
            *args:
                Positional arguments. Initialize all or a subset of the member variables
                according to their order of declaration.
            **kwargs:
                Can be used to initialize member variables at construction,
                Just pass an argument expression of the form <member>=<value>
                per member that you want to initialize.
        """
        HIP_ARRAY_DESCRIPTOR.__allocate(&self._ptr)
        self._is_ptr_owner = True
        attribs = self.PROPERTIES()
        used_attribs = set()
        if len(args) > len(attribs):
            raise ValueError("More positional arguments specified than this type has properties.")
        for i,v in enumerate(args):
            setattr(self,attribs[i],v)
            used_attribs.add(attribs[i])
        valid_names = ", ".join(["'"+p+"'" for p in attribs])
        for k,v in kwargs.items():
            if k in used_attribs:
                raise KeyError(f"argument '{k}' has already been specified as positional argument.")
            elif k not in attribs:
                raise KeyError(f"'{k}' is no valid property name. Valid names: {valid_names}")
            setattr(self,k,v)
    def get_Width(self, i):
        """Get value ``Width`` of ``(<chip.HIP_ARRAY_DESCRIPTOR*>self._ptr)[i]``.
        """
        return (<chip.HIP_ARRAY_DESCRIPTOR*>self._ptr)[i].Width
    def set_Width(self, i, unsigned long value):
        """Set value ``Width`` of ``(<chip.HIP_ARRAY_DESCRIPTOR*>self._ptr)[i]``.
        """
        (<chip.HIP_ARRAY_DESCRIPTOR*>self._ptr)[i].Width = value
    @property
    def Width(self):
        """(undocumented)"""
        return self.get_Width(0)
    @Width.setter
    def Width(self, unsigned long value):
        self.set_Width(0,value)

    def get_Height(self, i):
        """Get value ``Height`` of ``(<chip.HIP_ARRAY_DESCRIPTOR*>self._ptr)[i]``.
        """
        return (<chip.HIP_ARRAY_DESCRIPTOR*>self._ptr)[i].Height
    def set_Height(self, i, unsigned long value):
        """Set value ``Height`` of ``(<chip.HIP_ARRAY_DESCRIPTOR*>self._ptr)[i]``.
        """
        (<chip.HIP_ARRAY_DESCRIPTOR*>self._ptr)[i].Height = value
    @property
    def Height(self):
        """(undocumented)"""
        return self.get_Height(0)
    @Height.setter
    def Height(self, unsigned long value):
        self.set_Height(0,value)

    def get_Format(self, i):
        """Get value of ``Format`` of ``(<chip.HIP_ARRAY_DESCRIPTOR*>self._ptr)[i]``.
        """
        return hipArray_Format((<chip.HIP_ARRAY_DESCRIPTOR*>self._ptr)[i].Format)
    def set_Format(self, i, value):
        """Set value ``Format`` of ``(<chip.HIP_ARRAY_DESCRIPTOR*>self._ptr)[i]``.
        """
        if not isinstance(value, hipArray_Format):
            raise TypeError("'value' must be of type 'hipArray_Format'")
        (<chip.HIP_ARRAY_DESCRIPTOR*>self._ptr)[i].Format = value.value
    @property
    def Format(self):
        """(undocumented)"""
        return self.get_Format(0)
    @Format.setter
    def Format(self, value):
        self.set_Format(0,value)

    def get_NumChannels(self, i):
        """Get value ``NumChannels`` of ``(<chip.HIP_ARRAY_DESCRIPTOR*>self._ptr)[i]``.
        """
        return (<chip.HIP_ARRAY_DESCRIPTOR*>self._ptr)[i].NumChannels
    def set_NumChannels(self, i, unsigned int value):
        """Set value ``NumChannels`` of ``(<chip.HIP_ARRAY_DESCRIPTOR*>self._ptr)[i]``.
        """
        (<chip.HIP_ARRAY_DESCRIPTOR*>self._ptr)[i].NumChannels = value
    @property
    def NumChannels(self):
        """(undocumented)"""
        return self.get_NumChannels(0)
    @NumChannels.setter
    def NumChannels(self, unsigned int value):
        self.set_NumChannels(0,value)

    @staticmethod
    def PROPERTIES():
        return ["Width","Height","Format","NumChannels"]

    def __contains__(self,item):
        properties = self.PROPERTIES()
        return item in properties

    def __getitem__(self,item):
        properties = self.PROPERTIES()
        if isinstance(item,int):
            if item < 0 or item >= len(properties):
                raise IndexError()
            return getattr(self,properties[item])
        raise ValueError("'item' type must be 'int'")


cdef class HIP_ARRAY3D_DESCRIPTOR(hip._util.types.Pointer):
    """Python wrapper for cdef class chip.HIP_ARRAY3D_DESCRIPTOR.

    Python wrapper for cdef class chip.HIP_ARRAY3D_DESCRIPTOR.

    If this type is initialized via its `__init__` method, it allocates a
    member of the underlying C type and destroys it again if the wrapper
    type is deallocated.

    This type also serves as adapter when appearing as argument type in a
    function signature. In this case, the type can further be initialized
    from a number of Python objects:

    * `None`:

      This will set the ``self._ptr`` attribute to ``NULL``.

    * `int`:

      Interprets the integer value as pointer address and writes it to ``self._ptr``.
      No ownership is transferred.

    * `ctypes.c_void_p`:

      Takes the pointer address ``pyobj.value`` and writes it to ``self._ptr``.
      No ownership is transferred.

    * `object` that implements the `CUDA Array Interface <https://numba.readthedocs.io/en/stable/cuda/cuda_array_interface.html>`_ protocol:

      Takes the integer-valued pointer address, i.e. the first entry of the `data` tuple
      from `pyobj`'s member ``__cuda_array_interface__``  and writes it to ``self._ptr``.

    * `object` that implements the Python buffer protocol:

      If the object represents a simple contiguous array,
      writes the `Py_buffer` associated with ``pyobj`` to `self._py_buffer`,
      sets the `self._py_buffer_acquired` flag to `True`, and
      writes `self._py_buffer.buf` to the data pointer `self._ptr`.

    * `hip._util.types.Pointer`:

      Takes the pointer address ``pyobj._ptr`` and writes it to ``self._ptr``.
      No ownership is transferred.

    Type checks are performed in the above order.

    C Attributes:
        _ptr (C type ``void *``, protected):
            Stores a pointer to the data of the original Python object.
        _is_ptr_owner (C type ``bint``, protected):
            If this wrapper is the owner of the underlying data.
        _py_buffer (C type ``Py_buffer`, protected):
            Stores a pointer to the data of the original Python object.
        _py_buffer_acquired (C type ``bint``, protected):
            Stores a pointer to the data of the original Python object.
    """
    # C members declared in pxd file

    def __cinit__(self):
        self._ptr = NULL
        self._is_ptr_owner = False
        self._py_buffer_acquired = False

    cdef chip.HIP_ARRAY3D_DESCRIPTOR* getElementPtr(self):
        return <chip.HIP_ARRAY3D_DESCRIPTOR*>self._ptr

    @staticmethod
    cdef HIP_ARRAY3D_DESCRIPTOR fromPtr(void* ptr, bint owner=False):
        """Factory function to create ``HIP_ARRAY3D_DESCRIPTOR`` objects from
        given ``chip.HIP_ARRAY3D_DESCRIPTOR`` pointer.

        Setting ``owner`` flag to ``True`` causes
        the extension type to free the structure pointed to by ``ptr``
        when the wrapper object is deallocated.
        """
        # Fast call to __new__() that bypasses the __init__() constructor.
        cdef HIP_ARRAY3D_DESCRIPTOR wrapper = HIP_ARRAY3D_DESCRIPTOR.__new__(HIP_ARRAY3D_DESCRIPTOR)
        wrapper._ptr = ptr
        wrapper._is_ptr_owner = owner
        return wrapper

    @staticmethod
    def fromObj(pyobj):
        """Creates a HIP_ARRAY3D_DESCRIPTOR from a Python object.

        Derives a HIP_ARRAY3D_DESCRIPTOR from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``HIP_ARRAY3D_DESCRIPTOR`` reference, this method
        returns it directly. No new ``HIP_ARRAY3D_DESCRIPTOR`` is created in this case.
        """
        return HIP_ARRAY3D_DESCRIPTOR.fromPyobj(pyobj)

    @staticmethod
    cdef HIP_ARRAY3D_DESCRIPTOR fromPyobj(object pyobj):
        """Creates a HIP_ARRAY3D_DESCRIPTOR from a Python object.

        Derives a HIP_ARRAY3D_DESCRIPTOR from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``HIP_ARRAY3D_DESCRIPTOR`` reference, this method
        returns it directly. No new ``HIP_ARRAY3D_DESCRIPTOR`` is created in this case.

        Args:
            pyobj (object): Must be either `None`; a `hip._util.types.Pointer`; a simple, contiguous buffer according to the buffer protocol;
                            or of type `HIP_ARRAY3D_DESCRIPTOR`; `int`; or `ctypes.c_void_p`.

        Note:
            This routine does not perform a copy but returns the original ``pyobj``
            if ``pyobj`` is an instance of HIP_ARRAY3D_DESCRIPTOR!
        """
        cdef HIP_ARRAY3D_DESCRIPTOR wrapper

        if isinstance(pyobj,HIP_ARRAY3D_DESCRIPTOR):
            return pyobj
        else:
            wrapper = HIP_ARRAY3D_DESCRIPTOR.__new__(HIP_ARRAY3D_DESCRIPTOR)
            wrapper.init_from_pyobj(pyobj)
            return wrapper

    def __dealloc__(self):
        # Release the buffer handle
        if self._py_buffer_acquired is True:
            cpython.buffer.PyBuffer_Release(&self._py_buffer)
        # De-allocate if not null and flag is set
        if self._ptr is not NULL and self._is_ptr_owner is True:
            stdlib.free(self._ptr)
            self._ptr = NULL

    @staticmethod
    cdef __allocate(void** ptr):
        ptr[0] = stdlib.malloc(sizeof(chip.HIP_ARRAY3D_DESCRIPTOR))
        string.memset(<void*>ptr[0], 0, sizeof(chip.HIP_ARRAY3D_DESCRIPTOR))

        if ptr[0] is NULL:
            raise MemoryError

    @staticmethod
    cdef HIP_ARRAY3D_DESCRIPTOR new():
        """Factory function to create HIP_ARRAY3D_DESCRIPTOR objects with
        newly allocated chip.HIP_ARRAY3D_DESCRIPTOR"""
        cdef void* ptr
        HIP_ARRAY3D_DESCRIPTOR.__allocate(&ptr)
        return HIP_ARRAY3D_DESCRIPTOR.fromPtr(ptr, owner=True)

    @staticmethod
    cdef HIP_ARRAY3D_DESCRIPTOR fromValue(chip.HIP_ARRAY3D_DESCRIPTOR other):
        """Allocate new C type and copy from ``other``.
        """
        wrapper = HIP_ARRAY3D_DESCRIPTOR.new()
        string.memcpy(wrapper._ptr, &other, sizeof(chip.HIP_ARRAY3D_DESCRIPTOR))
        return wrapper

    def c_sizeof(self):
        """Returns the size of the underlying C type in bytes.
        Note:
            Implemented as function to not collide with
            autogenerated property names.
        """
        return sizeof(chip.HIP_ARRAY3D_DESCRIPTOR)

    def __int__(self):
        """Returns the data's address as long integer.
        """
        return cpython.long.PyLong_FromVoidPtr(self._ptr)

    def __repr__(self):
        return f"<HIP_ARRAY3D_DESCRIPTOR object, ptr: {int(self)}>"

    def as_c_void_p(self):
        """Returns the data's address as `ctypes.c_void_p`
        Note:
            Implemented as function to not collide with
            autogenerated property names.
        """
        return ctypes.c_void_p(int(self))

    def __init__(self,*args,**kwargs):
        """Constructor type HIP_ARRAY3D_DESCRIPTOR.

        Constructor for type HIP_ARRAY3D_DESCRIPTOR.

        Args:
            *args:
                Positional arguments. Initialize all or a subset of the member variables
                according to their order of declaration.
            **kwargs:
                Can be used to initialize member variables at construction,
                Just pass an argument expression of the form <member>=<value>
                per member that you want to initialize.
        """
        HIP_ARRAY3D_DESCRIPTOR.__allocate(&self._ptr)
        self._is_ptr_owner = True
        attribs = self.PROPERTIES()
        used_attribs = set()
        if len(args) > len(attribs):
            raise ValueError("More positional arguments specified than this type has properties.")
        for i,v in enumerate(args):
            setattr(self,attribs[i],v)
            used_attribs.add(attribs[i])
        valid_names = ", ".join(["'"+p+"'" for p in attribs])
        for k,v in kwargs.items():
            if k in used_attribs:
                raise KeyError(f"argument '{k}' has already been specified as positional argument.")
            elif k not in attribs:
                raise KeyError(f"'{k}' is no valid property name. Valid names: {valid_names}")
            setattr(self,k,v)
    def get_Width(self, i):
        """Get value ``Width`` of ``(<chip.HIP_ARRAY3D_DESCRIPTOR*>self._ptr)[i]``.
        """
        return (<chip.HIP_ARRAY3D_DESCRIPTOR*>self._ptr)[i].Width
    def set_Width(self, i, unsigned long value):
        """Set value ``Width`` of ``(<chip.HIP_ARRAY3D_DESCRIPTOR*>self._ptr)[i]``.
        """
        (<chip.HIP_ARRAY3D_DESCRIPTOR*>self._ptr)[i].Width = value
    @property
    def Width(self):
        """(undocumented)"""
        return self.get_Width(0)
    @Width.setter
    def Width(self, unsigned long value):
        self.set_Width(0,value)

    def get_Height(self, i):
        """Get value ``Height`` of ``(<chip.HIP_ARRAY3D_DESCRIPTOR*>self._ptr)[i]``.
        """
        return (<chip.HIP_ARRAY3D_DESCRIPTOR*>self._ptr)[i].Height
    def set_Height(self, i, unsigned long value):
        """Set value ``Height`` of ``(<chip.HIP_ARRAY3D_DESCRIPTOR*>self._ptr)[i]``.
        """
        (<chip.HIP_ARRAY3D_DESCRIPTOR*>self._ptr)[i].Height = value
    @property
    def Height(self):
        """(undocumented)"""
        return self.get_Height(0)
    @Height.setter
    def Height(self, unsigned long value):
        self.set_Height(0,value)

    def get_Depth(self, i):
        """Get value ``Depth`` of ``(<chip.HIP_ARRAY3D_DESCRIPTOR*>self._ptr)[i]``.
        """
        return (<chip.HIP_ARRAY3D_DESCRIPTOR*>self._ptr)[i].Depth
    def set_Depth(self, i, unsigned long value):
        """Set value ``Depth`` of ``(<chip.HIP_ARRAY3D_DESCRIPTOR*>self._ptr)[i]``.
        """
        (<chip.HIP_ARRAY3D_DESCRIPTOR*>self._ptr)[i].Depth = value
    @property
    def Depth(self):
        """(undocumented)"""
        return self.get_Depth(0)
    @Depth.setter
    def Depth(self, unsigned long value):
        self.set_Depth(0,value)

    def get_Format(self, i):
        """Get value of ``Format`` of ``(<chip.HIP_ARRAY3D_DESCRIPTOR*>self._ptr)[i]``.
        """
        return hipArray_Format((<chip.HIP_ARRAY3D_DESCRIPTOR*>self._ptr)[i].Format)
    def set_Format(self, i, value):
        """Set value ``Format`` of ``(<chip.HIP_ARRAY3D_DESCRIPTOR*>self._ptr)[i]``.
        """
        if not isinstance(value, hipArray_Format):
            raise TypeError("'value' must be of type 'hipArray_Format'")
        (<chip.HIP_ARRAY3D_DESCRIPTOR*>self._ptr)[i].Format = value.value
    @property
    def Format(self):
        """(undocumented)"""
        return self.get_Format(0)
    @Format.setter
    def Format(self, value):
        self.set_Format(0,value)

    def get_NumChannels(self, i):
        """Get value ``NumChannels`` of ``(<chip.HIP_ARRAY3D_DESCRIPTOR*>self._ptr)[i]``.
        """
        return (<chip.HIP_ARRAY3D_DESCRIPTOR*>self._ptr)[i].NumChannels
    def set_NumChannels(self, i, unsigned int value):
        """Set value ``NumChannels`` of ``(<chip.HIP_ARRAY3D_DESCRIPTOR*>self._ptr)[i]``.
        """
        (<chip.HIP_ARRAY3D_DESCRIPTOR*>self._ptr)[i].NumChannels = value
    @property
    def NumChannels(self):
        """(undocumented)"""
        return self.get_NumChannels(0)
    @NumChannels.setter
    def NumChannels(self, unsigned int value):
        self.set_NumChannels(0,value)

    def get_Flags(self, i):
        """Get value ``Flags`` of ``(<chip.HIP_ARRAY3D_DESCRIPTOR*>self._ptr)[i]``.
        """
        return (<chip.HIP_ARRAY3D_DESCRIPTOR*>self._ptr)[i].Flags
    def set_Flags(self, i, unsigned int value):
        """Set value ``Flags`` of ``(<chip.HIP_ARRAY3D_DESCRIPTOR*>self._ptr)[i]``.
        """
        (<chip.HIP_ARRAY3D_DESCRIPTOR*>self._ptr)[i].Flags = value
    @property
    def Flags(self):
        """(undocumented)"""
        return self.get_Flags(0)
    @Flags.setter
    def Flags(self, unsigned int value):
        self.set_Flags(0,value)

    @staticmethod
    def PROPERTIES():
        return ["Width","Height","Depth","Format","NumChannels","Flags"]

    def __contains__(self,item):
        properties = self.PROPERTIES()
        return item in properties

    def __getitem__(self,item):
        properties = self.PROPERTIES()
        if isinstance(item,int):
            if item < 0 or item >= len(properties):
                raise IndexError()
            return getattr(self,properties[item])
        raise ValueError("'item' type must be 'int'")


cdef class hip_Memcpy2D(hip._util.types.Pointer):
    """Python wrapper for cdef class chip.hip_Memcpy2D.

    Python wrapper for cdef class chip.hip_Memcpy2D.

    If this type is initialized via its `__init__` method, it allocates a
    member of the underlying C type and destroys it again if the wrapper
    type is deallocated.

    This type also serves as adapter when appearing as argument type in a
    function signature. In this case, the type can further be initialized
    from a number of Python objects:

    * `None`:

      This will set the ``self._ptr`` attribute to ``NULL``.

    * `int`:

      Interprets the integer value as pointer address and writes it to ``self._ptr``.
      No ownership is transferred.

    * `ctypes.c_void_p`:

      Takes the pointer address ``pyobj.value`` and writes it to ``self._ptr``.
      No ownership is transferred.

    * `object` that implements the `CUDA Array Interface <https://numba.readthedocs.io/en/stable/cuda/cuda_array_interface.html>`_ protocol:

      Takes the integer-valued pointer address, i.e. the first entry of the `data` tuple
      from `pyobj`'s member ``__cuda_array_interface__``  and writes it to ``self._ptr``.

    * `object` that implements the Python buffer protocol:

      If the object represents a simple contiguous array,
      writes the `Py_buffer` associated with ``pyobj`` to `self._py_buffer`,
      sets the `self._py_buffer_acquired` flag to `True`, and
      writes `self._py_buffer.buf` to the data pointer `self._ptr`.

    * `hip._util.types.Pointer`:

      Takes the pointer address ``pyobj._ptr`` and writes it to ``self._ptr``.
      No ownership is transferred.

    Type checks are performed in the above order.

    C Attributes:
        _ptr (C type ``void *``, protected):
            Stores a pointer to the data of the original Python object.
        _is_ptr_owner (C type ``bint``, protected):
            If this wrapper is the owner of the underlying data.
        _py_buffer (C type ``Py_buffer`, protected):
            Stores a pointer to the data of the original Python object.
        _py_buffer_acquired (C type ``bint``, protected):
            Stores a pointer to the data of the original Python object.
    """
    # C members declared in pxd file

    def __cinit__(self):
        self._ptr = NULL
        self._is_ptr_owner = False
        self._py_buffer_acquired = False

    cdef chip.hip_Memcpy2D* getElementPtr(self):
        return <chip.hip_Memcpy2D*>self._ptr

    @staticmethod
    cdef hip_Memcpy2D fromPtr(void* ptr, bint owner=False):
        """Factory function to create ``hip_Memcpy2D`` objects from
        given ``chip.hip_Memcpy2D`` pointer.

        Setting ``owner`` flag to ``True`` causes
        the extension type to free the structure pointed to by ``ptr``
        when the wrapper object is deallocated.
        """
        # Fast call to __new__() that bypasses the __init__() constructor.
        cdef hip_Memcpy2D wrapper = hip_Memcpy2D.__new__(hip_Memcpy2D)
        wrapper._ptr = ptr
        wrapper._is_ptr_owner = owner
        return wrapper

    @staticmethod
    def fromObj(pyobj):
        """Creates a hip_Memcpy2D from a Python object.

        Derives a hip_Memcpy2D from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``hip_Memcpy2D`` reference, this method
        returns it directly. No new ``hip_Memcpy2D`` is created in this case.
        """
        return hip_Memcpy2D.fromPyobj(pyobj)

    @staticmethod
    cdef hip_Memcpy2D fromPyobj(object pyobj):
        """Creates a hip_Memcpy2D from a Python object.

        Derives a hip_Memcpy2D from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``hip_Memcpy2D`` reference, this method
        returns it directly. No new ``hip_Memcpy2D`` is created in this case.

        Args:
            pyobj (object): Must be either `None`; a `hip._util.types.Pointer`; a simple, contiguous buffer according to the buffer protocol;
                            or of type `hip_Memcpy2D`; `int`; or `ctypes.c_void_p`.

        Note:
            This routine does not perform a copy but returns the original ``pyobj``
            if ``pyobj`` is an instance of hip_Memcpy2D!
        """
        cdef hip_Memcpy2D wrapper

        if isinstance(pyobj,hip_Memcpy2D):
            return pyobj
        else:
            wrapper = hip_Memcpy2D.__new__(hip_Memcpy2D)
            wrapper.init_from_pyobj(pyobj)
            return wrapper

    def __dealloc__(self):
        # Release the buffer handle
        if self._py_buffer_acquired is True:
            cpython.buffer.PyBuffer_Release(&self._py_buffer)
        # De-allocate if not null and flag is set
        if self._ptr is not NULL and self._is_ptr_owner is True:
            stdlib.free(self._ptr)
            self._ptr = NULL

    @staticmethod
    cdef __allocate(void** ptr):
        ptr[0] = stdlib.malloc(sizeof(chip.hip_Memcpy2D))
        string.memset(<void*>ptr[0], 0, sizeof(chip.hip_Memcpy2D))

        if ptr[0] is NULL:
            raise MemoryError

    @staticmethod
    cdef hip_Memcpy2D new():
        """Factory function to create hip_Memcpy2D objects with
        newly allocated chip.hip_Memcpy2D"""
        cdef void* ptr
        hip_Memcpy2D.__allocate(&ptr)
        return hip_Memcpy2D.fromPtr(ptr, owner=True)

    @staticmethod
    cdef hip_Memcpy2D fromValue(chip.hip_Memcpy2D other):
        """Allocate new C type and copy from ``other``.
        """
        wrapper = hip_Memcpy2D.new()
        string.memcpy(wrapper._ptr, &other, sizeof(chip.hip_Memcpy2D))
        return wrapper

    def c_sizeof(self):
        """Returns the size of the underlying C type in bytes.
        Note:
            Implemented as function to not collide with
            autogenerated property names.
        """
        return sizeof(chip.hip_Memcpy2D)

    def __int__(self):
        """Returns the data's address as long integer.
        """
        return cpython.long.PyLong_FromVoidPtr(self._ptr)

    def __repr__(self):
        return f"<hip_Memcpy2D object, ptr: {int(self)}>"

    def as_c_void_p(self):
        """Returns the data's address as `ctypes.c_void_p`
        Note:
            Implemented as function to not collide with
            autogenerated property names.
        """
        return ctypes.c_void_p(int(self))

    def __init__(self,**kwargs):
        """Constructor type hip_Memcpy2D.

        Constructor for type hip_Memcpy2D.

        Args:
            **kwargs:
                Can be used to initialize member variables at construction,
                Just pass an argument expression of the form <member>=<value>
                per member that you want to initialize.
        """
        hip_Memcpy2D.__allocate(&self._ptr)
        self._is_ptr_owner = True
        attribs = self.PROPERTIES()
        used_attribs = set()
        valid_names = ", ".join(["'"+p+"'" for p in attribs])
        for k,v in kwargs.items():
            if k in used_attribs:
                raise KeyError(f"argument '{k}' has already been specified as positional argument.")
            elif k not in attribs:
                raise KeyError(f"'{k}' is no valid property name. Valid names: {valid_names}")
            setattr(self,k,v)
    def get_srcXInBytes(self, i):
        """Get value ``srcXInBytes`` of ``(<chip.hip_Memcpy2D*>self._ptr)[i]``.
        """
        return (<chip.hip_Memcpy2D*>self._ptr)[i].srcXInBytes
    def set_srcXInBytes(self, i, unsigned long value):
        """Set value ``srcXInBytes`` of ``(<chip.hip_Memcpy2D*>self._ptr)[i]``.
        """
        (<chip.hip_Memcpy2D*>self._ptr)[i].srcXInBytes = value
    @property
    def srcXInBytes(self):
        """(undocumented)"""
        return self.get_srcXInBytes(0)
    @srcXInBytes.setter
    def srcXInBytes(self, unsigned long value):
        self.set_srcXInBytes(0,value)

    def get_srcY(self, i):
        """Get value ``srcY`` of ``(<chip.hip_Memcpy2D*>self._ptr)[i]``.
        """
        return (<chip.hip_Memcpy2D*>self._ptr)[i].srcY
    def set_srcY(self, i, unsigned long value):
        """Set value ``srcY`` of ``(<chip.hip_Memcpy2D*>self._ptr)[i]``.
        """
        (<chip.hip_Memcpy2D*>self._ptr)[i].srcY = value
    @property
    def srcY(self):
        """(undocumented)"""
        return self.get_srcY(0)
    @srcY.setter
    def srcY(self, unsigned long value):
        self.set_srcY(0,value)

    def get_srcMemoryType(self, i):
        """Get value of ``srcMemoryType`` of ``(<chip.hip_Memcpy2D*>self._ptr)[i]``.
        """
        return hipMemoryType((<chip.hip_Memcpy2D*>self._ptr)[i].srcMemoryType)
    def set_srcMemoryType(self, i, value):
        """Set value ``srcMemoryType`` of ``(<chip.hip_Memcpy2D*>self._ptr)[i]``.
        """
        if not isinstance(value, hipMemoryType):
            raise TypeError("'value' must be of type 'hipMemoryType'")
        (<chip.hip_Memcpy2D*>self._ptr)[i].srcMemoryType = value.value
    @property
    def srcMemoryType(self):
        """(undocumented)"""
        return self.get_srcMemoryType(0)
    @srcMemoryType.setter
    def srcMemoryType(self, value):
        self.set_srcMemoryType(0,value)

    def get_srcHost(self, i):
        """Get value ``srcHost`` of ``(<chip.hip_Memcpy2D*>self._ptr)[i]``.
        """
        return hip._util.types.Pointer.fromPtr((<chip.hip_Memcpy2D*>self._ptr)[i].srcHost)
    def set_srcHost(self, i, object value):
        """Set value ``srcHost`` of ``(<chip.hip_Memcpy2D*>self._ptr)[i]``.

        Note:
            This can be dangerous if the pointer is from a python object
            that is later on garbage collected.
        """
        (<chip.hip_Memcpy2D*>self._ptr)[i].srcHost = <const void *>cpython.long.PyLong_AsVoidPtr(int(hip._util.types.Pointer.fromPyobj(value)))
    @property
    def srcHost(self):
        """(undocumented)
        Note:
            Setting this srcHost can be dangerous if the underlying pointer is from a python object that
            is later on garbage collected.
        """
        return self.get_srcHost(0)
    @srcHost.setter
    def srcHost(self, object value):
        self.set_srcHost(0,value)

    def get_srcDevice(self, i):
        """Get value ``srcDevice`` of ``(<chip.hip_Memcpy2D*>self._ptr)[i]``.
        """
        return hip._util.types.Pointer.fromPtr((<chip.hip_Memcpy2D*>self._ptr)[i].srcDevice)
    def set_srcDevice(self, i, object value):
        """Set value ``srcDevice`` of ``(<chip.hip_Memcpy2D*>self._ptr)[i]``.

        Note:
            This can be dangerous if the pointer is from a python object
            that is later on garbage collected.
        """
        (<chip.hip_Memcpy2D*>self._ptr)[i].srcDevice = <void *>cpython.long.PyLong_AsVoidPtr(int(hip._util.types.Pointer.fromPyobj(value)))
    @property
    def srcDevice(self):
        """(undocumented)
        Note:
            Setting this srcDevice can be dangerous if the underlying pointer is from a python object that
            is later on garbage collected.
        """
        return self.get_srcDevice(0)
    @srcDevice.setter
    def srcDevice(self, object value):
        self.set_srcDevice(0,value)

    def get_srcPitch(self, i):
        """Get value ``srcPitch`` of ``(<chip.hip_Memcpy2D*>self._ptr)[i]``.
        """
        return (<chip.hip_Memcpy2D*>self._ptr)[i].srcPitch
    def set_srcPitch(self, i, unsigned long value):
        """Set value ``srcPitch`` of ``(<chip.hip_Memcpy2D*>self._ptr)[i]``.
        """
        (<chip.hip_Memcpy2D*>self._ptr)[i].srcPitch = value
    @property
    def srcPitch(self):
        """(undocumented)"""
        return self.get_srcPitch(0)
    @srcPitch.setter
    def srcPitch(self, unsigned long value):
        self.set_srcPitch(0,value)

    def get_dstXInBytes(self, i):
        """Get value ``dstXInBytes`` of ``(<chip.hip_Memcpy2D*>self._ptr)[i]``.
        """
        return (<chip.hip_Memcpy2D*>self._ptr)[i].dstXInBytes
    def set_dstXInBytes(self, i, unsigned long value):
        """Set value ``dstXInBytes`` of ``(<chip.hip_Memcpy2D*>self._ptr)[i]``.
        """
        (<chip.hip_Memcpy2D*>self._ptr)[i].dstXInBytes = value
    @property
    def dstXInBytes(self):
        """(undocumented)"""
        return self.get_dstXInBytes(0)
    @dstXInBytes.setter
    def dstXInBytes(self, unsigned long value):
        self.set_dstXInBytes(0,value)

    def get_dstY(self, i):
        """Get value ``dstY`` of ``(<chip.hip_Memcpy2D*>self._ptr)[i]``.
        """
        return (<chip.hip_Memcpy2D*>self._ptr)[i].dstY
    def set_dstY(self, i, unsigned long value):
        """Set value ``dstY`` of ``(<chip.hip_Memcpy2D*>self._ptr)[i]``.
        """
        (<chip.hip_Memcpy2D*>self._ptr)[i].dstY = value
    @property
    def dstY(self):
        """(undocumented)"""
        return self.get_dstY(0)
    @dstY.setter
    def dstY(self, unsigned long value):
        self.set_dstY(0,value)

    def get_dstMemoryType(self, i):
        """Get value of ``dstMemoryType`` of ``(<chip.hip_Memcpy2D*>self._ptr)[i]``.
        """
        return hipMemoryType((<chip.hip_Memcpy2D*>self._ptr)[i].dstMemoryType)
    def set_dstMemoryType(self, i, value):
        """Set value ``dstMemoryType`` of ``(<chip.hip_Memcpy2D*>self._ptr)[i]``.
        """
        if not isinstance(value, hipMemoryType):
            raise TypeError("'value' must be of type 'hipMemoryType'")
        (<chip.hip_Memcpy2D*>self._ptr)[i].dstMemoryType = value.value
    @property
    def dstMemoryType(self):
        """(undocumented)"""
        return self.get_dstMemoryType(0)
    @dstMemoryType.setter
    def dstMemoryType(self, value):
        self.set_dstMemoryType(0,value)

    def get_dstHost(self, i):
        """Get value ``dstHost`` of ``(<chip.hip_Memcpy2D*>self._ptr)[i]``.
        """
        return hip._util.types.Pointer.fromPtr((<chip.hip_Memcpy2D*>self._ptr)[i].dstHost)
    def set_dstHost(self, i, object value):
        """Set value ``dstHost`` of ``(<chip.hip_Memcpy2D*>self._ptr)[i]``.

        Note:
            This can be dangerous if the pointer is from a python object
            that is later on garbage collected.
        """
        (<chip.hip_Memcpy2D*>self._ptr)[i].dstHost = <void *>cpython.long.PyLong_AsVoidPtr(int(hip._util.types.Pointer.fromPyobj(value)))
    @property
    def dstHost(self):
        """(undocumented)
        Note:
            Setting this dstHost can be dangerous if the underlying pointer is from a python object that
            is later on garbage collected.
        """
        return self.get_dstHost(0)
    @dstHost.setter
    def dstHost(self, object value):
        self.set_dstHost(0,value)

    def get_dstDevice(self, i):
        """Get value ``dstDevice`` of ``(<chip.hip_Memcpy2D*>self._ptr)[i]``.
        """
        return hip._util.types.Pointer.fromPtr((<chip.hip_Memcpy2D*>self._ptr)[i].dstDevice)
    def set_dstDevice(self, i, object value):
        """Set value ``dstDevice`` of ``(<chip.hip_Memcpy2D*>self._ptr)[i]``.

        Note:
            This can be dangerous if the pointer is from a python object
            that is later on garbage collected.
        """
        (<chip.hip_Memcpy2D*>self._ptr)[i].dstDevice = <void *>cpython.long.PyLong_AsVoidPtr(int(hip._util.types.Pointer.fromPyobj(value)))
    @property
    def dstDevice(self):
        """(undocumented)
        Note:
            Setting this dstDevice can be dangerous if the underlying pointer is from a python object that
            is later on garbage collected.
        """
        return self.get_dstDevice(0)
    @dstDevice.setter
    def dstDevice(self, object value):
        self.set_dstDevice(0,value)

    def get_dstPitch(self, i):
        """Get value ``dstPitch`` of ``(<chip.hip_Memcpy2D*>self._ptr)[i]``.
        """
        return (<chip.hip_Memcpy2D*>self._ptr)[i].dstPitch
    def set_dstPitch(self, i, unsigned long value):
        """Set value ``dstPitch`` of ``(<chip.hip_Memcpy2D*>self._ptr)[i]``.
        """
        (<chip.hip_Memcpy2D*>self._ptr)[i].dstPitch = value
    @property
    def dstPitch(self):
        """(undocumented)"""
        return self.get_dstPitch(0)
    @dstPitch.setter
    def dstPitch(self, unsigned long value):
        self.set_dstPitch(0,value)

    def get_WidthInBytes(self, i):
        """Get value ``WidthInBytes`` of ``(<chip.hip_Memcpy2D*>self._ptr)[i]``.
        """
        return (<chip.hip_Memcpy2D*>self._ptr)[i].WidthInBytes
    def set_WidthInBytes(self, i, unsigned long value):
        """Set value ``WidthInBytes`` of ``(<chip.hip_Memcpy2D*>self._ptr)[i]``.
        """
        (<chip.hip_Memcpy2D*>self._ptr)[i].WidthInBytes = value
    @property
    def WidthInBytes(self):
        """(undocumented)"""
        return self.get_WidthInBytes(0)
    @WidthInBytes.setter
    def WidthInBytes(self, unsigned long value):
        self.set_WidthInBytes(0,value)

    def get_Height(self, i):
        """Get value ``Height`` of ``(<chip.hip_Memcpy2D*>self._ptr)[i]``.
        """
        return (<chip.hip_Memcpy2D*>self._ptr)[i].Height
    def set_Height(self, i, unsigned long value):
        """Set value ``Height`` of ``(<chip.hip_Memcpy2D*>self._ptr)[i]``.
        """
        (<chip.hip_Memcpy2D*>self._ptr)[i].Height = value
    @property
    def Height(self):
        """(undocumented)"""
        return self.get_Height(0)
    @Height.setter
    def Height(self, unsigned long value):
        self.set_Height(0,value)

    @staticmethod
    def PROPERTIES():
        return ["srcXInBytes","srcY","srcMemoryType","srcHost","srcDevice","srcPitch","dstXInBytes","dstY","dstMemoryType","dstHost","dstDevice","dstPitch","WidthInBytes","Height"]

    def __contains__(self,item):
        properties = self.PROPERTIES()
        return item in properties

    def __getitem__(self,item):
        properties = self.PROPERTIES()
        if isinstance(item,int):
            if item < 0 or item >= len(properties):
                raise IndexError()
            return getattr(self,properties[item])
        raise ValueError("'item' type must be 'int'")


cdef class hipMipmappedArray(hip._util.types.Pointer):
    """Python wrapper for cdef class chip.hipMipmappedArray.

    Python wrapper for cdef class chip.hipMipmappedArray.

    If this type is initialized via its `__init__` method, it allocates a
    member of the underlying C type and destroys it again if the wrapper
    type is deallocated.

    This type also serves as adapter when appearing as argument type in a
    function signature. In this case, the type can further be initialized
    from a number of Python objects:

    * `None`:

      This will set the ``self._ptr`` attribute to ``NULL``.

    * `int`:

      Interprets the integer value as pointer address and writes it to ``self._ptr``.
      No ownership is transferred.

    * `ctypes.c_void_p`:

      Takes the pointer address ``pyobj.value`` and writes it to ``self._ptr``.
      No ownership is transferred.

    * `object` that implements the `CUDA Array Interface <https://numba.readthedocs.io/en/stable/cuda/cuda_array_interface.html>`_ protocol:

      Takes the integer-valued pointer address, i.e. the first entry of the `data` tuple
      from `pyobj`'s member ``__cuda_array_interface__``  and writes it to ``self._ptr``.

    * `object` that implements the Python buffer protocol:

      If the object represents a simple contiguous array,
      writes the `Py_buffer` associated with ``pyobj`` to `self._py_buffer`,
      sets the `self._py_buffer_acquired` flag to `True`, and
      writes `self._py_buffer.buf` to the data pointer `self._ptr`.

    * `hip._util.types.Pointer`:

      Takes the pointer address ``pyobj._ptr`` and writes it to ``self._ptr``.
      No ownership is transferred.

    Type checks are performed in the above order.

    C Attributes:
        _ptr (C type ``void *``, protected):
            Stores a pointer to the data of the original Python object.
        _is_ptr_owner (C type ``bint``, protected):
            If this wrapper is the owner of the underlying data.
        _py_buffer (C type ``Py_buffer`, protected):
            Stores a pointer to the data of the original Python object.
        _py_buffer_acquired (C type ``bint``, protected):
            Stores a pointer to the data of the original Python object.
    """
    # C members declared in pxd file

    def __cinit__(self):
        self._ptr = NULL
        self._is_ptr_owner = False
        self._py_buffer_acquired = False

    cdef chip.hipMipmappedArray* getElementPtr(self):
        return <chip.hipMipmappedArray*>self._ptr

    @staticmethod
    cdef hipMipmappedArray fromPtr(void* ptr, bint owner=False):
        """Factory function to create ``hipMipmappedArray`` objects from
        given ``chip.hipMipmappedArray`` pointer.

        Setting ``owner`` flag to ``True`` causes
        the extension type to free the structure pointed to by ``ptr``
        when the wrapper object is deallocated.
        """
        # Fast call to __new__() that bypasses the __init__() constructor.
        cdef hipMipmappedArray wrapper = hipMipmappedArray.__new__(hipMipmappedArray)
        wrapper._ptr = ptr
        wrapper._is_ptr_owner = owner
        return wrapper

    @staticmethod
    def fromObj(pyobj):
        """Creates a hipMipmappedArray from a Python object.

        Derives a hipMipmappedArray from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``hipMipmappedArray`` reference, this method
        returns it directly. No new ``hipMipmappedArray`` is created in this case.
        """
        return hipMipmappedArray.fromPyobj(pyobj)

    @staticmethod
    cdef hipMipmappedArray fromPyobj(object pyobj):
        """Creates a hipMipmappedArray from a Python object.

        Derives a hipMipmappedArray from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``hipMipmappedArray`` reference, this method
        returns it directly. No new ``hipMipmappedArray`` is created in this case.

        Args:
            pyobj (object): Must be either `None`; a `hip._util.types.Pointer`; a simple, contiguous buffer according to the buffer protocol;
                            or of type `hipMipmappedArray`; `int`; or `ctypes.c_void_p`.

        Note:
            This routine does not perform a copy but returns the original ``pyobj``
            if ``pyobj`` is an instance of hipMipmappedArray!
        """
        cdef hipMipmappedArray wrapper

        if isinstance(pyobj,hipMipmappedArray):
            return pyobj
        else:
            wrapper = hipMipmappedArray.__new__(hipMipmappedArray)
            wrapper.init_from_pyobj(pyobj)
            return wrapper

    def __dealloc__(self):
        # Release the buffer handle
        if self._py_buffer_acquired is True:
            cpython.buffer.PyBuffer_Release(&self._py_buffer)
        # De-allocate if not null and flag is set
        if self._ptr is not NULL and self._is_ptr_owner is True:
            stdlib.free(self._ptr)
            self._ptr = NULL

    @staticmethod
    cdef __allocate(void** ptr):
        ptr[0] = stdlib.malloc(sizeof(chip.hipMipmappedArray))
        string.memset(<void*>ptr[0], 0, sizeof(chip.hipMipmappedArray))

        if ptr[0] is NULL:
            raise MemoryError

    @staticmethod
    cdef hipMipmappedArray new():
        """Factory function to create hipMipmappedArray objects with
        newly allocated chip.hipMipmappedArray"""
        cdef void* ptr
        hipMipmappedArray.__allocate(&ptr)
        return hipMipmappedArray.fromPtr(ptr, owner=True)

    @staticmethod
    cdef hipMipmappedArray fromValue(chip.hipMipmappedArray other):
        """Allocate new C type and copy from ``other``.
        """
        wrapper = hipMipmappedArray.new()
        string.memcpy(wrapper._ptr, &other, sizeof(chip.hipMipmappedArray))
        return wrapper

    def c_sizeof(self):
        """Returns the size of the underlying C type in bytes.
        Note:
            Implemented as function to not collide with
            autogenerated property names.
        """
        return sizeof(chip.hipMipmappedArray)

    def __int__(self):
        """Returns the data's address as long integer.
        """
        return cpython.long.PyLong_FromVoidPtr(self._ptr)

    def __repr__(self):
        return f"<hipMipmappedArray object, ptr: {int(self)}>"

    def as_c_void_p(self):
        """Returns the data's address as `ctypes.c_void_p`
        Note:
            Implemented as function to not collide with
            autogenerated property names.
        """
        return ctypes.c_void_p(int(self))

    def __init__(self,*args,**kwargs):
        """Constructor type hipMipmappedArray.

        Constructor for type hipMipmappedArray.

        Args:
            *args:
                Positional arguments. Initialize all or a subset of the member variables
                according to their order of declaration.
            **kwargs:
                Can be used to initialize member variables at construction,
                Just pass an argument expression of the form <member>=<value>
                per member that you want to initialize.
        """
        hipMipmappedArray.__allocate(&self._ptr)
        self._is_ptr_owner = True
        attribs = self.PROPERTIES()
        used_attribs = set()
        if len(args) > len(attribs):
            raise ValueError("More positional arguments specified than this type has properties.")
        for i,v in enumerate(args):
            setattr(self,attribs[i],v)
            used_attribs.add(attribs[i])
        valid_names = ", ".join(["'"+p+"'" for p in attribs])
        for k,v in kwargs.items():
            if k in used_attribs:
                raise KeyError(f"argument '{k}' has already been specified as positional argument.")
            elif k not in attribs:
                raise KeyError(f"'{k}' is no valid property name. Valid names: {valid_names}")
            setattr(self,k,v)
    def get_data(self, i):
        """Get value ``data`` of ``(<chip.hipMipmappedArray*>self._ptr)[i]``.
        """
        return hip._util.types.Pointer.fromPtr((<chip.hipMipmappedArray*>self._ptr)[i].data)
    def set_data(self, i, object value):
        """Set value ``data`` of ``(<chip.hipMipmappedArray*>self._ptr)[i]``.

        Note:
            This can be dangerous if the pointer is from a python object
            that is later on garbage collected.
        """
        (<chip.hipMipmappedArray*>self._ptr)[i].data = <void *>cpython.long.PyLong_AsVoidPtr(int(hip._util.types.Pointer.fromPyobj(value)))
    @property
    def data(self):
        """(undocumented)
        Note:
            Setting this data can be dangerous if the underlying pointer is from a python object that
            is later on garbage collected.
        """
        return self.get_data(0)
    @data.setter
    def data(self, object value):
        self.set_data(0,value)

    def get_desc(self, i):
        """Get value of ``desc`` of ``(<chip.hipMipmappedArray*>self._ptr)[i]``.
        """
        return hipChannelFormatDesc.fromPtr(&(<chip.hipMipmappedArray*>self._ptr)[i].desc)
    @property
    def desc(self):
        """(undocumented)"""
        return self.get_desc(0)

    def get_type(self, i):
        """Get value ``type`` of ``(<chip.hipMipmappedArray*>self._ptr)[i]``.
        """
        return (<chip.hipMipmappedArray*>self._ptr)[i].type
    def set_type(self, i, unsigned int value):
        """Set value ``type`` of ``(<chip.hipMipmappedArray*>self._ptr)[i]``.
        """
        (<chip.hipMipmappedArray*>self._ptr)[i].type = value
    @property
    def type(self):
        """(undocumented)"""
        return self.get_type(0)
    @type.setter
    def type(self, unsigned int value):
        self.set_type(0,value)

    def get_width(self, i):
        """Get value ``width`` of ``(<chip.hipMipmappedArray*>self._ptr)[i]``.
        """
        return (<chip.hipMipmappedArray*>self._ptr)[i].width
    def set_width(self, i, unsigned int value):
        """Set value ``width`` of ``(<chip.hipMipmappedArray*>self._ptr)[i]``.
        """
        (<chip.hipMipmappedArray*>self._ptr)[i].width = value
    @property
    def width(self):
        """(undocumented)"""
        return self.get_width(0)
    @width.setter
    def width(self, unsigned int value):
        self.set_width(0,value)

    def get_height(self, i):
        """Get value ``height`` of ``(<chip.hipMipmappedArray*>self._ptr)[i]``.
        """
        return (<chip.hipMipmappedArray*>self._ptr)[i].height
    def set_height(self, i, unsigned int value):
        """Set value ``height`` of ``(<chip.hipMipmappedArray*>self._ptr)[i]``.
        """
        (<chip.hipMipmappedArray*>self._ptr)[i].height = value
    @property
    def height(self):
        """(undocumented)"""
        return self.get_height(0)
    @height.setter
    def height(self, unsigned int value):
        self.set_height(0,value)

    def get_depth(self, i):
        """Get value ``depth`` of ``(<chip.hipMipmappedArray*>self._ptr)[i]``.
        """
        return (<chip.hipMipmappedArray*>self._ptr)[i].depth
    def set_depth(self, i, unsigned int value):
        """Set value ``depth`` of ``(<chip.hipMipmappedArray*>self._ptr)[i]``.
        """
        (<chip.hipMipmappedArray*>self._ptr)[i].depth = value
    @property
    def depth(self):
        """(undocumented)"""
        return self.get_depth(0)
    @depth.setter
    def depth(self, unsigned int value):
        self.set_depth(0,value)

    def get_min_mipmap_level(self, i):
        """Get value ``min_mipmap_level`` of ``(<chip.hipMipmappedArray*>self._ptr)[i]``.
        """
        return (<chip.hipMipmappedArray*>self._ptr)[i].min_mipmap_level
    def set_min_mipmap_level(self, i, unsigned int value):
        """Set value ``min_mipmap_level`` of ``(<chip.hipMipmappedArray*>self._ptr)[i]``.
        """
        (<chip.hipMipmappedArray*>self._ptr)[i].min_mipmap_level = value
    @property
    def min_mipmap_level(self):
        """(undocumented)"""
        return self.get_min_mipmap_level(0)
    @min_mipmap_level.setter
    def min_mipmap_level(self, unsigned int value):
        self.set_min_mipmap_level(0,value)

    def get_max_mipmap_level(self, i):
        """Get value ``max_mipmap_level`` of ``(<chip.hipMipmappedArray*>self._ptr)[i]``.
        """
        return (<chip.hipMipmappedArray*>self._ptr)[i].max_mipmap_level
    def set_max_mipmap_level(self, i, unsigned int value):
        """Set value ``max_mipmap_level`` of ``(<chip.hipMipmappedArray*>self._ptr)[i]``.
        """
        (<chip.hipMipmappedArray*>self._ptr)[i].max_mipmap_level = value
    @property
    def max_mipmap_level(self):
        """(undocumented)"""
        return self.get_max_mipmap_level(0)
    @max_mipmap_level.setter
    def max_mipmap_level(self, unsigned int value):
        self.set_max_mipmap_level(0,value)

    def get_flags(self, i):
        """Get value ``flags`` of ``(<chip.hipMipmappedArray*>self._ptr)[i]``.
        """
        return (<chip.hipMipmappedArray*>self._ptr)[i].flags
    def set_flags(self, i, unsigned int value):
        """Set value ``flags`` of ``(<chip.hipMipmappedArray*>self._ptr)[i]``.
        """
        (<chip.hipMipmappedArray*>self._ptr)[i].flags = value
    @property
    def flags(self):
        """(undocumented)"""
        return self.get_flags(0)
    @flags.setter
    def flags(self, unsigned int value):
        self.set_flags(0,value)

    def get_format(self, i):
        """Get value of ``format`` of ``(<chip.hipMipmappedArray*>self._ptr)[i]``.
        """
        return hipArray_Format((<chip.hipMipmappedArray*>self._ptr)[i].format)
    def set_format(self, i, value):
        """Set value ``format`` of ``(<chip.hipMipmappedArray*>self._ptr)[i]``.
        """
        if not isinstance(value, hipArray_Format):
            raise TypeError("'value' must be of type 'hipArray_Format'")
        (<chip.hipMipmappedArray*>self._ptr)[i].format = value.value
    @property
    def format(self):
        """(undocumented)"""
        return self.get_format(0)
    @format.setter
    def format(self, value):
        self.set_format(0,value)

    def get_num_channels(self, i):
        """Get value ``num_channels`` of ``(<chip.hipMipmappedArray*>self._ptr)[i]``.
        """
        return (<chip.hipMipmappedArray*>self._ptr)[i].num_channels
    def set_num_channels(self, i, unsigned int value):
        """Set value ``num_channels`` of ``(<chip.hipMipmappedArray*>self._ptr)[i]``.
        """
        (<chip.hipMipmappedArray*>self._ptr)[i].num_channels = value
    @property
    def num_channels(self):
        """(undocumented)"""
        return self.get_num_channels(0)
    @num_channels.setter
    def num_channels(self, unsigned int value):
        self.set_num_channels(0,value)

    @staticmethod
    def PROPERTIES():
        return ["data","desc","type","width","height","depth","min_mipmap_level","max_mipmap_level","flags","format","num_channels"]

    def __contains__(self,item):
        properties = self.PROPERTIES()
        return item in properties

    def __getitem__(self,item):
        properties = self.PROPERTIES()
        if isinstance(item,int):
            if item < 0 or item >= len(properties):
                raise IndexError()
            return getattr(self,properties[item])
        raise ValueError("'item' type must be 'int'")


hipMipmappedArray_t = hipMipmappedArray

hipMipmappedArray_const_t = hipMipmappedArray

class _hipResourceType__Base(enum.IntEnum):
    """Empty enum base class that allows subclassing.
    """
    pass
class hipResourceType(_hipResourceType__Base):
    """hip resource types

    Attributes:
        hipResourceTypeArray:
            (undocumented)
        hipResourceTypeMipmappedArray:
            (undocumented)
        hipResourceTypeLinear:
            (undocumented)
        hipResourceTypePitch2D:
            (undocumented)
    """
    hipResourceTypeArray = chip.hipResourceTypeArray
    hipResourceTypeMipmappedArray = chip.hipResourceTypeMipmappedArray
    hipResourceTypeLinear = chip.hipResourceTypeLinear
    hipResourceTypePitch2D = chip.hipResourceTypePitch2D
    @staticmethod
    def ctypes_type():
        """The type of the enum constants as ctypes type."""
        return ctypes.c_uint


class _HIPresourcetype_enum__Base(enum.IntEnum):
    """Empty enum base class that allows subclassing.
    """
    pass
class HIPresourcetype_enum(_HIPresourcetype_enum__Base):
    """HIPresourcetype_enum

    Attributes:
        HIP_RESOURCE_TYPE_ARRAY:
            Array resoure
        HIP_RESOURCE_TYPE_MIPMAPPED_ARRAY:
            Mipmapped array resource
        HIP_RESOURCE_TYPE_LINEAR:
            Linear resource
        HIP_RESOURCE_TYPE_PITCH2D:
            Pitch 2D resource
    """
    HIP_RESOURCE_TYPE_ARRAY = chip.HIP_RESOURCE_TYPE_ARRAY
    HIP_RESOURCE_TYPE_MIPMAPPED_ARRAY = chip.HIP_RESOURCE_TYPE_MIPMAPPED_ARRAY
    HIP_RESOURCE_TYPE_LINEAR = chip.HIP_RESOURCE_TYPE_LINEAR
    HIP_RESOURCE_TYPE_PITCH2D = chip.HIP_RESOURCE_TYPE_PITCH2D
    @staticmethod
    def ctypes_type():
        """The type of the enum constants as ctypes type."""
        return ctypes.c_uint


HIPresourcetype = HIPresourcetype_enum

hipResourcetype = HIPresourcetype_enum

class _HIPaddress_mode_enum__Base(enum.IntEnum):
    """Empty enum base class that allows subclassing.
    """
    pass
class HIPaddress_mode_enum(_HIPaddress_mode_enum__Base):
    """hip address modes

    Attributes:
        HIP_TR_ADDRESS_MODE_WRAP:
            (undocumented)
        HIP_TR_ADDRESS_MODE_CLAMP:
            (undocumented)
        HIP_TR_ADDRESS_MODE_MIRROR:
            (undocumented)
        HIP_TR_ADDRESS_MODE_BORDER:
            (undocumented)
    """
    HIP_TR_ADDRESS_MODE_WRAP = chip.HIP_TR_ADDRESS_MODE_WRAP
    HIP_TR_ADDRESS_MODE_CLAMP = chip.HIP_TR_ADDRESS_MODE_CLAMP
    HIP_TR_ADDRESS_MODE_MIRROR = chip.HIP_TR_ADDRESS_MODE_MIRROR
    HIP_TR_ADDRESS_MODE_BORDER = chip.HIP_TR_ADDRESS_MODE_BORDER
    @staticmethod
    def ctypes_type():
        """The type of the enum constants as ctypes type."""
        return ctypes.c_uint


HIPaddress_mode = HIPaddress_mode_enum

class _HIPfilter_mode_enum__Base(enum.IntEnum):
    """Empty enum base class that allows subclassing.
    """
    pass
class HIPfilter_mode_enum(_HIPfilter_mode_enum__Base):
    """hip filter modes

    Attributes:
        HIP_TR_FILTER_MODE_POINT:
            (undocumented)
        HIP_TR_FILTER_MODE_LINEAR:
            (undocumented)
    """
    HIP_TR_FILTER_MODE_POINT = chip.HIP_TR_FILTER_MODE_POINT
    HIP_TR_FILTER_MODE_LINEAR = chip.HIP_TR_FILTER_MODE_LINEAR
    @staticmethod
    def ctypes_type():
        """The type of the enum constants as ctypes type."""
        return ctypes.c_uint


HIPfilter_mode = HIPfilter_mode_enum

cdef class HIP_TEXTURE_DESC_st(hip._util.types.Pointer):
    """Python wrapper for cdef class chip.HIP_TEXTURE_DESC_st.

    Python wrapper for cdef class chip.HIP_TEXTURE_DESC_st.

    If this type is initialized via its `__init__` method, it allocates a
    member of the underlying C type and destroys it again if the wrapper
    type is deallocated.

    This type also serves as adapter when appearing as argument type in a
    function signature. In this case, the type can further be initialized
    from a number of Python objects:

    * `None`:

      This will set the ``self._ptr`` attribute to ``NULL``.

    * `int`:

      Interprets the integer value as pointer address and writes it to ``self._ptr``.
      No ownership is transferred.

    * `ctypes.c_void_p`:

      Takes the pointer address ``pyobj.value`` and writes it to ``self._ptr``.
      No ownership is transferred.

    * `object` that implements the `CUDA Array Interface <https://numba.readthedocs.io/en/stable/cuda/cuda_array_interface.html>`_ protocol:

      Takes the integer-valued pointer address, i.e. the first entry of the `data` tuple
      from `pyobj`'s member ``__cuda_array_interface__``  and writes it to ``self._ptr``.

    * `object` that implements the Python buffer protocol:

      If the object represents a simple contiguous array,
      writes the `Py_buffer` associated with ``pyobj`` to `self._py_buffer`,
      sets the `self._py_buffer_acquired` flag to `True`, and
      writes `self._py_buffer.buf` to the data pointer `self._ptr`.

    * `hip._util.types.Pointer`:

      Takes the pointer address ``pyobj._ptr`` and writes it to ``self._ptr``.
      No ownership is transferred.

    Type checks are performed in the above order.

    C Attributes:
        _ptr (C type ``void *``, protected):
            Stores a pointer to the data of the original Python object.
        _is_ptr_owner (C type ``bint``, protected):
            If this wrapper is the owner of the underlying data.
        _py_buffer (C type ``Py_buffer`, protected):
            Stores a pointer to the data of the original Python object.
        _py_buffer_acquired (C type ``bint``, protected):
            Stores a pointer to the data of the original Python object.
    """
    # C members declared in pxd file

    def __cinit__(self):
        self._ptr = NULL
        self._is_ptr_owner = False
        self._py_buffer_acquired = False

    cdef chip.HIP_TEXTURE_DESC_st* getElementPtr(self):
        return <chip.HIP_TEXTURE_DESC_st*>self._ptr

    @staticmethod
    cdef HIP_TEXTURE_DESC_st fromPtr(void* ptr, bint owner=False):
        """Factory function to create ``HIP_TEXTURE_DESC_st`` objects from
        given ``chip.HIP_TEXTURE_DESC_st`` pointer.

        Setting ``owner`` flag to ``True`` causes
        the extension type to free the structure pointed to by ``ptr``
        when the wrapper object is deallocated.
        """
        # Fast call to __new__() that bypasses the __init__() constructor.
        cdef HIP_TEXTURE_DESC_st wrapper = HIP_TEXTURE_DESC_st.__new__(HIP_TEXTURE_DESC_st)
        wrapper._ptr = ptr
        wrapper._is_ptr_owner = owner
        return wrapper

    @staticmethod
    def fromObj(pyobj):
        """Creates a HIP_TEXTURE_DESC_st from a Python object.

        Derives a HIP_TEXTURE_DESC_st from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``HIP_TEXTURE_DESC_st`` reference, this method
        returns it directly. No new ``HIP_TEXTURE_DESC_st`` is created in this case.
        """
        return HIP_TEXTURE_DESC_st.fromPyobj(pyobj)

    @staticmethod
    cdef HIP_TEXTURE_DESC_st fromPyobj(object pyobj):
        """Creates a HIP_TEXTURE_DESC_st from a Python object.

        Derives a HIP_TEXTURE_DESC_st from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``HIP_TEXTURE_DESC_st`` reference, this method
        returns it directly. No new ``HIP_TEXTURE_DESC_st`` is created in this case.

        Args:
            pyobj (object): Must be either `None`; a `hip._util.types.Pointer`; a simple, contiguous buffer according to the buffer protocol;
                            or of type `HIP_TEXTURE_DESC_st`; `int`; or `ctypes.c_void_p`.

        Note:
            This routine does not perform a copy but returns the original ``pyobj``
            if ``pyobj`` is an instance of HIP_TEXTURE_DESC_st!
        """
        cdef HIP_TEXTURE_DESC_st wrapper

        if isinstance(pyobj,HIP_TEXTURE_DESC_st):
            return pyobj
        else:
            wrapper = HIP_TEXTURE_DESC_st.__new__(HIP_TEXTURE_DESC_st)
            wrapper.init_from_pyobj(pyobj)
            return wrapper

    def __dealloc__(self):
        # Release the buffer handle
        if self._py_buffer_acquired is True:
            cpython.buffer.PyBuffer_Release(&self._py_buffer)
        # De-allocate if not null and flag is set
        if self._ptr is not NULL and self._is_ptr_owner is True:
            stdlib.free(self._ptr)
            self._ptr = NULL

    @staticmethod
    cdef __allocate(void** ptr):
        ptr[0] = stdlib.malloc(sizeof(chip.HIP_TEXTURE_DESC_st))
        string.memset(<void*>ptr[0], 0, sizeof(chip.HIP_TEXTURE_DESC_st))

        if ptr[0] is NULL:
            raise MemoryError

    @staticmethod
    cdef HIP_TEXTURE_DESC_st new():
        """Factory function to create HIP_TEXTURE_DESC_st objects with
        newly allocated chip.HIP_TEXTURE_DESC_st"""
        cdef void* ptr
        HIP_TEXTURE_DESC_st.__allocate(&ptr)
        return HIP_TEXTURE_DESC_st.fromPtr(ptr, owner=True)

    @staticmethod
    cdef HIP_TEXTURE_DESC_st fromValue(chip.HIP_TEXTURE_DESC_st other):
        """Allocate new C type and copy from ``other``.
        """
        wrapper = HIP_TEXTURE_DESC_st.new()
        string.memcpy(wrapper._ptr, &other, sizeof(chip.HIP_TEXTURE_DESC_st))
        return wrapper

    def c_sizeof(self):
        """Returns the size of the underlying C type in bytes.
        Note:
            Implemented as function to not collide with
            autogenerated property names.
        """
        return sizeof(chip.HIP_TEXTURE_DESC_st)

    def __int__(self):
        """Returns the data's address as long integer.
        """
        return cpython.long.PyLong_FromVoidPtr(self._ptr)

    def __repr__(self):
        return f"<HIP_TEXTURE_DESC_st object, ptr: {int(self)}>"

    def as_c_void_p(self):
        """Returns the data's address as `ctypes.c_void_p`
        Note:
            Implemented as function to not collide with
            autogenerated property names.
        """
        return ctypes.c_void_p(int(self))

    def __init__(self,**kwargs):
        """Constructor type HIP_TEXTURE_DESC_st.

        Constructor for type HIP_TEXTURE_DESC_st.

        Args:
            **kwargs:
                Can be used to initialize member variables at construction,
                Just pass an argument expression of the form <member>=<value>
                per member that you want to initialize.
        """
        HIP_TEXTURE_DESC_st.__allocate(&self._ptr)
        self._is_ptr_owner = True
        attribs = self.PROPERTIES()
        used_attribs = set()
        valid_names = ", ".join(["'"+p+"'" for p in attribs])
        for k,v in kwargs.items():
            if k in used_attribs:
                raise KeyError(f"argument '{k}' has already been specified as positional argument.")
            elif k not in attribs:
                raise KeyError(f"'{k}' is no valid property name. Valid names: {valid_names}")
            setattr(self,k,v)
    def get_filterMode(self, i):
        """Get value of ``filterMode`` of ``(<chip.HIP_TEXTURE_DESC_st*>self._ptr)[i]``.
        """
        return HIPfilter_mode_enum((<chip.HIP_TEXTURE_DESC_st*>self._ptr)[i].filterMode)
    def set_filterMode(self, i, value):
        """Set value ``filterMode`` of ``(<chip.HIP_TEXTURE_DESC_st*>self._ptr)[i]``.
        """
        if not isinstance(value, HIPfilter_mode_enum):
            raise TypeError("'value' must be of type 'HIPfilter_mode_enum'")
        (<chip.HIP_TEXTURE_DESC_st*>self._ptr)[i].filterMode = value.value
    @property
    def filterMode(self):
        """Filter mode"""
        return self.get_filterMode(0)
    @filterMode.setter
    def filterMode(self, value):
        self.set_filterMode(0,value)

    def get_flags(self, i):
        """Get value ``flags`` of ``(<chip.HIP_TEXTURE_DESC_st*>self._ptr)[i]``.
        """
        return (<chip.HIP_TEXTURE_DESC_st*>self._ptr)[i].flags
    def set_flags(self, i, unsigned int value):
        """Set value ``flags`` of ``(<chip.HIP_TEXTURE_DESC_st*>self._ptr)[i]``.
        """
        (<chip.HIP_TEXTURE_DESC_st*>self._ptr)[i].flags = value
    @property
    def flags(self):
        """Flags"""
        return self.get_flags(0)
    @flags.setter
    def flags(self, unsigned int value):
        self.set_flags(0,value)

    def get_maxAnisotropy(self, i):
        """Get value ``maxAnisotropy`` of ``(<chip.HIP_TEXTURE_DESC_st*>self._ptr)[i]``.
        """
        return (<chip.HIP_TEXTURE_DESC_st*>self._ptr)[i].maxAnisotropy
    def set_maxAnisotropy(self, i, unsigned int value):
        """Set value ``maxAnisotropy`` of ``(<chip.HIP_TEXTURE_DESC_st*>self._ptr)[i]``.
        """
        (<chip.HIP_TEXTURE_DESC_st*>self._ptr)[i].maxAnisotropy = value
    @property
    def maxAnisotropy(self):
        """Maximum anisotropy ratio"""
        return self.get_maxAnisotropy(0)
    @maxAnisotropy.setter
    def maxAnisotropy(self, unsigned int value):
        self.set_maxAnisotropy(0,value)

    def get_mipmapFilterMode(self, i):
        """Get value of ``mipmapFilterMode`` of ``(<chip.HIP_TEXTURE_DESC_st*>self._ptr)[i]``.
        """
        return HIPfilter_mode_enum((<chip.HIP_TEXTURE_DESC_st*>self._ptr)[i].mipmapFilterMode)
    def set_mipmapFilterMode(self, i, value):
        """Set value ``mipmapFilterMode`` of ``(<chip.HIP_TEXTURE_DESC_st*>self._ptr)[i]``.
        """
        if not isinstance(value, HIPfilter_mode_enum):
            raise TypeError("'value' must be of type 'HIPfilter_mode_enum'")
        (<chip.HIP_TEXTURE_DESC_st*>self._ptr)[i].mipmapFilterMode = value.value
    @property
    def mipmapFilterMode(self):
        """Mipmap filter mode"""
        return self.get_mipmapFilterMode(0)
    @mipmapFilterMode.setter
    def mipmapFilterMode(self, value):
        self.set_mipmapFilterMode(0,value)

    def get_mipmapLevelBias(self, i):
        """Get value ``mipmapLevelBias`` of ``(<chip.HIP_TEXTURE_DESC_st*>self._ptr)[i]``.
        """
        return (<chip.HIP_TEXTURE_DESC_st*>self._ptr)[i].mipmapLevelBias
    def set_mipmapLevelBias(self, i, float value):
        """Set value ``mipmapLevelBias`` of ``(<chip.HIP_TEXTURE_DESC_st*>self._ptr)[i]``.
        """
        (<chip.HIP_TEXTURE_DESC_st*>self._ptr)[i].mipmapLevelBias = value
    @property
    def mipmapLevelBias(self):
        """Mipmap level bias"""
        return self.get_mipmapLevelBias(0)
    @mipmapLevelBias.setter
    def mipmapLevelBias(self, float value):
        self.set_mipmapLevelBias(0,value)

    def get_minMipmapLevelClamp(self, i):
        """Get value ``minMipmapLevelClamp`` of ``(<chip.HIP_TEXTURE_DESC_st*>self._ptr)[i]``.
        """
        return (<chip.HIP_TEXTURE_DESC_st*>self._ptr)[i].minMipmapLevelClamp
    def set_minMipmapLevelClamp(self, i, float value):
        """Set value ``minMipmapLevelClamp`` of ``(<chip.HIP_TEXTURE_DESC_st*>self._ptr)[i]``.
        """
        (<chip.HIP_TEXTURE_DESC_st*>self._ptr)[i].minMipmapLevelClamp = value
    @property
    def minMipmapLevelClamp(self):
        """Mipmap minimum level clamp"""
        return self.get_minMipmapLevelClamp(0)
    @minMipmapLevelClamp.setter
    def minMipmapLevelClamp(self, float value):
        self.set_minMipmapLevelClamp(0,value)

    def get_maxMipmapLevelClamp(self, i):
        """Get value ``maxMipmapLevelClamp`` of ``(<chip.HIP_TEXTURE_DESC_st*>self._ptr)[i]``.
        """
        return (<chip.HIP_TEXTURE_DESC_st*>self._ptr)[i].maxMipmapLevelClamp
    def set_maxMipmapLevelClamp(self, i, float value):
        """Set value ``maxMipmapLevelClamp`` of ``(<chip.HIP_TEXTURE_DESC_st*>self._ptr)[i]``.
        """
        (<chip.HIP_TEXTURE_DESC_st*>self._ptr)[i].maxMipmapLevelClamp = value
    @property
    def maxMipmapLevelClamp(self):
        """Mipmap maximum level clamp"""
        return self.get_maxMipmapLevelClamp(0)
    @maxMipmapLevelClamp.setter
    def maxMipmapLevelClamp(self, float value):
        self.set_maxMipmapLevelClamp(0,value)

    def get_borderColor(self, i):
        """Get value of ``borderColor`` of ``(<chip.HIP_TEXTURE_DESC_st*>self._ptr)[i]``.
        """
        return (<chip.HIP_TEXTURE_DESC_st*>self._ptr)[i].borderColor
    # TODO add setters
    #def set_borderColor(self, i, float[4] value):
    #    """Set value ``borderColor`` of ``(<chip.HIP_TEXTURE_DESC_st*>self._ptr)[i]``.
    #    """
    #    (<chip.HIP_TEXTURE_DESC_st*>self._ptr)[i].borderColor = value
    @property
    def borderColor(self):
        """Border Color"""
        return self.get_borderColor(0)
    # TODO add setters
    #@borderColor.setter
    #def borderColor(self, float[4] value):
    #    self.set_borderColor(0,value)

    def get_reserved(self, i):
        """Get value of ``reserved`` of ``(<chip.HIP_TEXTURE_DESC_st*>self._ptr)[i]``.
        """
        return (<chip.HIP_TEXTURE_DESC_st*>self._ptr)[i].reserved
    # TODO add setters
    #def set_reserved(self, i, int[12] value):
    #    """Set value ``reserved`` of ``(<chip.HIP_TEXTURE_DESC_st*>self._ptr)[i]``.
    #    """
    #    (<chip.HIP_TEXTURE_DESC_st*>self._ptr)[i].reserved = value
    @property
    def reserved(self):
        """(undocumented)"""
        return self.get_reserved(0)
    # TODO add setters
    #@reserved.setter
    #def reserved(self, int[12] value):
    #    self.set_reserved(0,value)

    @staticmethod
    def PROPERTIES():
        return ["filterMode","flags","maxAnisotropy","mipmapFilterMode","mipmapLevelBias","minMipmapLevelClamp","maxMipmapLevelClamp","borderColor","reserved"]

    def __contains__(self,item):
        properties = self.PROPERTIES()
        return item in properties

    def __getitem__(self,item):
        properties = self.PROPERTIES()
        if isinstance(item,int):
            if item < 0 or item >= len(properties):
                raise IndexError()
            return getattr(self,properties[item])
        raise ValueError("'item' type must be 'int'")


HIP_TEXTURE_DESC = HIP_TEXTURE_DESC_st

class _hipResourceViewFormat__Base(enum.IntEnum):
    """Empty enum base class that allows subclassing.
    """
    pass
class hipResourceViewFormat(_hipResourceViewFormat__Base):
    """hip texture resource view formats

    Attributes:
        hipResViewFormatNone:
            (undocumented)
        hipResViewFormatUnsignedChar1:
            (undocumented)
        hipResViewFormatUnsignedChar2:
            (undocumented)
        hipResViewFormatUnsignedChar4:
            (undocumented)
        hipResViewFormatSignedChar1:
            (undocumented)
        hipResViewFormatSignedChar2:
            (undocumented)
        hipResViewFormatSignedChar4:
            (undocumented)
        hipResViewFormatUnsignedShort1:
            (undocumented)
        hipResViewFormatUnsignedShort2:
            (undocumented)
        hipResViewFormatUnsignedShort4:
            (undocumented)
        hipResViewFormatSignedShort1:
            (undocumented)
        hipResViewFormatSignedShort2:
            (undocumented)
        hipResViewFormatSignedShort4:
            (undocumented)
        hipResViewFormatUnsignedInt1:
            (undocumented)
        hipResViewFormatUnsignedInt2:
            (undocumented)
        hipResViewFormatUnsignedInt4:
            (undocumented)
        hipResViewFormatSignedInt1:
            (undocumented)
        hipResViewFormatSignedInt2:
            (undocumented)
        hipResViewFormatSignedInt4:
            (undocumented)
        hipResViewFormatHalf1:
            (undocumented)
        hipResViewFormatHalf2:
            (undocumented)
        hipResViewFormatHalf4:
            (undocumented)
        hipResViewFormatFloat1:
            (undocumented)
        hipResViewFormatFloat2:
            (undocumented)
        hipResViewFormatFloat4:
            (undocumented)
        hipResViewFormatUnsignedBlockCompressed1:
            (undocumented)
        hipResViewFormatUnsignedBlockCompressed2:
            (undocumented)
        hipResViewFormatUnsignedBlockCompressed3:
            (undocumented)
        hipResViewFormatUnsignedBlockCompressed4:
            (undocumented)
        hipResViewFormatSignedBlockCompressed4:
            (undocumented)
        hipResViewFormatUnsignedBlockCompressed5:
            (undocumented)
        hipResViewFormatSignedBlockCompressed5:
            (undocumented)
        hipResViewFormatUnsignedBlockCompressed6H:
            (undocumented)
        hipResViewFormatSignedBlockCompressed6H:
            (undocumented)
        hipResViewFormatUnsignedBlockCompressed7:
            (undocumented)
    """
    hipResViewFormatNone = chip.hipResViewFormatNone
    hipResViewFormatUnsignedChar1 = chip.hipResViewFormatUnsignedChar1
    hipResViewFormatUnsignedChar2 = chip.hipResViewFormatUnsignedChar2
    hipResViewFormatUnsignedChar4 = chip.hipResViewFormatUnsignedChar4
    hipResViewFormatSignedChar1 = chip.hipResViewFormatSignedChar1
    hipResViewFormatSignedChar2 = chip.hipResViewFormatSignedChar2
    hipResViewFormatSignedChar4 = chip.hipResViewFormatSignedChar4
    hipResViewFormatUnsignedShort1 = chip.hipResViewFormatUnsignedShort1
    hipResViewFormatUnsignedShort2 = chip.hipResViewFormatUnsignedShort2
    hipResViewFormatUnsignedShort4 = chip.hipResViewFormatUnsignedShort4
    hipResViewFormatSignedShort1 = chip.hipResViewFormatSignedShort1
    hipResViewFormatSignedShort2 = chip.hipResViewFormatSignedShort2
    hipResViewFormatSignedShort4 = chip.hipResViewFormatSignedShort4
    hipResViewFormatUnsignedInt1 = chip.hipResViewFormatUnsignedInt1
    hipResViewFormatUnsignedInt2 = chip.hipResViewFormatUnsignedInt2
    hipResViewFormatUnsignedInt4 = chip.hipResViewFormatUnsignedInt4
    hipResViewFormatSignedInt1 = chip.hipResViewFormatSignedInt1
    hipResViewFormatSignedInt2 = chip.hipResViewFormatSignedInt2
    hipResViewFormatSignedInt4 = chip.hipResViewFormatSignedInt4
    hipResViewFormatHalf1 = chip.hipResViewFormatHalf1
    hipResViewFormatHalf2 = chip.hipResViewFormatHalf2
    hipResViewFormatHalf4 = chip.hipResViewFormatHalf4
    hipResViewFormatFloat1 = chip.hipResViewFormatFloat1
    hipResViewFormatFloat2 = chip.hipResViewFormatFloat2
    hipResViewFormatFloat4 = chip.hipResViewFormatFloat4
    hipResViewFormatUnsignedBlockCompressed1 = chip.hipResViewFormatUnsignedBlockCompressed1
    hipResViewFormatUnsignedBlockCompressed2 = chip.hipResViewFormatUnsignedBlockCompressed2
    hipResViewFormatUnsignedBlockCompressed3 = chip.hipResViewFormatUnsignedBlockCompressed3
    hipResViewFormatUnsignedBlockCompressed4 = chip.hipResViewFormatUnsignedBlockCompressed4
    hipResViewFormatSignedBlockCompressed4 = chip.hipResViewFormatSignedBlockCompressed4
    hipResViewFormatUnsignedBlockCompressed5 = chip.hipResViewFormatUnsignedBlockCompressed5
    hipResViewFormatSignedBlockCompressed5 = chip.hipResViewFormatSignedBlockCompressed5
    hipResViewFormatUnsignedBlockCompressed6H = chip.hipResViewFormatUnsignedBlockCompressed6H
    hipResViewFormatSignedBlockCompressed6H = chip.hipResViewFormatSignedBlockCompressed6H
    hipResViewFormatUnsignedBlockCompressed7 = chip.hipResViewFormatUnsignedBlockCompressed7
    @staticmethod
    def ctypes_type():
        """The type of the enum constants as ctypes type."""
        return ctypes.c_uint


class _HIPresourceViewFormat_enum__Base(enum.IntEnum):
    """Empty enum base class that allows subclassing.
    """
    pass
class HIPresourceViewFormat_enum(_HIPresourceViewFormat_enum__Base):
    """HIPresourceViewFormat_enum

    Attributes:
        HIP_RES_VIEW_FORMAT_NONE:
            No resource view format (use underlying resource format)
        HIP_RES_VIEW_FORMAT_UINT_1X8:
            1 channel unsigned 8-bit integers
        HIP_RES_VIEW_FORMAT_UINT_2X8:
            2 channel unsigned 8-bit integers
        HIP_RES_VIEW_FORMAT_UINT_4X8:
            4 channel unsigned 8-bit integers
        HIP_RES_VIEW_FORMAT_SINT_1X8:
            1 channel signed 8-bit integers
        HIP_RES_VIEW_FORMAT_SINT_2X8:
            2 channel signed 8-bit integers
        HIP_RES_VIEW_FORMAT_SINT_4X8:
            4 channel signed 8-bit integers
        HIP_RES_VIEW_FORMAT_UINT_1X16:
            1 channel unsigned 16-bit integers
        HIP_RES_VIEW_FORMAT_UINT_2X16:
            2 channel unsigned 16-bit integers
        HIP_RES_VIEW_FORMAT_UINT_4X16:
            4 channel unsigned 16-bit integers
        HIP_RES_VIEW_FORMAT_SINT_1X16:
            1 channel signed 16-bit integers
        HIP_RES_VIEW_FORMAT_SINT_2X16:
            2 channel signed 16-bit integers
        HIP_RES_VIEW_FORMAT_SINT_4X16:
            4 channel signed 16-bit integers
        HIP_RES_VIEW_FORMAT_UINT_1X32:
            1 channel unsigned 32-bit integers
        HIP_RES_VIEW_FORMAT_UINT_2X32:
            2 channel unsigned 32-bit integers
        HIP_RES_VIEW_FORMAT_UINT_4X32:
            4 channel unsigned 32-bit integers
        HIP_RES_VIEW_FORMAT_SINT_1X32:
            1 channel signed 32-bit integers
        HIP_RES_VIEW_FORMAT_SINT_2X32:
            2 channel signed 32-bit integers
        HIP_RES_VIEW_FORMAT_SINT_4X32:
            4 channel signed 32-bit integers
        HIP_RES_VIEW_FORMAT_FLOAT_1X16:
            1 channel 16-bit floating point
        HIP_RES_VIEW_FORMAT_FLOAT_2X16:
            2 channel 16-bit floating point
        HIP_RES_VIEW_FORMAT_FLOAT_4X16:
            4 channel 16-bit floating point
        HIP_RES_VIEW_FORMAT_FLOAT_1X32:
            1 channel 32-bit floating point
        HIP_RES_VIEW_FORMAT_FLOAT_2X32:
            2 channel 32-bit floating point
        HIP_RES_VIEW_FORMAT_FLOAT_4X32:
            4 channel 32-bit floating point
        HIP_RES_VIEW_FORMAT_UNSIGNED_BC1:
            Block compressed 1
        HIP_RES_VIEW_FORMAT_UNSIGNED_BC2:
            Block compressed 2
        HIP_RES_VIEW_FORMAT_UNSIGNED_BC3:
            Block compressed 3
        HIP_RES_VIEW_FORMAT_UNSIGNED_BC4:
            Block compressed 4 unsigned
        HIP_RES_VIEW_FORMAT_SIGNED_BC4:
            Block compressed 4 signed
        HIP_RES_VIEW_FORMAT_UNSIGNED_BC5:
            Block compressed 5 unsigned
        HIP_RES_VIEW_FORMAT_SIGNED_BC5:
            Block compressed 5 signed
        HIP_RES_VIEW_FORMAT_UNSIGNED_BC6H:
            Block compressed 6 unsigned half-float
        HIP_RES_VIEW_FORMAT_SIGNED_BC6H:
            Block compressed 6 signed half-float
        HIP_RES_VIEW_FORMAT_UNSIGNED_BC7:
            Block compressed 7
    """
    HIP_RES_VIEW_FORMAT_NONE = chip.HIP_RES_VIEW_FORMAT_NONE
    HIP_RES_VIEW_FORMAT_UINT_1X8 = chip.HIP_RES_VIEW_FORMAT_UINT_1X8
    HIP_RES_VIEW_FORMAT_UINT_2X8 = chip.HIP_RES_VIEW_FORMAT_UINT_2X8
    HIP_RES_VIEW_FORMAT_UINT_4X8 = chip.HIP_RES_VIEW_FORMAT_UINT_4X8
    HIP_RES_VIEW_FORMAT_SINT_1X8 = chip.HIP_RES_VIEW_FORMAT_SINT_1X8
    HIP_RES_VIEW_FORMAT_SINT_2X8 = chip.HIP_RES_VIEW_FORMAT_SINT_2X8
    HIP_RES_VIEW_FORMAT_SINT_4X8 = chip.HIP_RES_VIEW_FORMAT_SINT_4X8
    HIP_RES_VIEW_FORMAT_UINT_1X16 = chip.HIP_RES_VIEW_FORMAT_UINT_1X16
    HIP_RES_VIEW_FORMAT_UINT_2X16 = chip.HIP_RES_VIEW_FORMAT_UINT_2X16
    HIP_RES_VIEW_FORMAT_UINT_4X16 = chip.HIP_RES_VIEW_FORMAT_UINT_4X16
    HIP_RES_VIEW_FORMAT_SINT_1X16 = chip.HIP_RES_VIEW_FORMAT_SINT_1X16
    HIP_RES_VIEW_FORMAT_SINT_2X16 = chip.HIP_RES_VIEW_FORMAT_SINT_2X16
    HIP_RES_VIEW_FORMAT_SINT_4X16 = chip.HIP_RES_VIEW_FORMAT_SINT_4X16
    HIP_RES_VIEW_FORMAT_UINT_1X32 = chip.HIP_RES_VIEW_FORMAT_UINT_1X32
    HIP_RES_VIEW_FORMAT_UINT_2X32 = chip.HIP_RES_VIEW_FORMAT_UINT_2X32
    HIP_RES_VIEW_FORMAT_UINT_4X32 = chip.HIP_RES_VIEW_FORMAT_UINT_4X32
    HIP_RES_VIEW_FORMAT_SINT_1X32 = chip.HIP_RES_VIEW_FORMAT_SINT_1X32
    HIP_RES_VIEW_FORMAT_SINT_2X32 = chip.HIP_RES_VIEW_FORMAT_SINT_2X32
    HIP_RES_VIEW_FORMAT_SINT_4X32 = chip.HIP_RES_VIEW_FORMAT_SINT_4X32
    HIP_RES_VIEW_FORMAT_FLOAT_1X16 = chip.HIP_RES_VIEW_FORMAT_FLOAT_1X16
    HIP_RES_VIEW_FORMAT_FLOAT_2X16 = chip.HIP_RES_VIEW_FORMAT_FLOAT_2X16
    HIP_RES_VIEW_FORMAT_FLOAT_4X16 = chip.HIP_RES_VIEW_FORMAT_FLOAT_4X16
    HIP_RES_VIEW_FORMAT_FLOAT_1X32 = chip.HIP_RES_VIEW_FORMAT_FLOAT_1X32
    HIP_RES_VIEW_FORMAT_FLOAT_2X32 = chip.HIP_RES_VIEW_FORMAT_FLOAT_2X32
    HIP_RES_VIEW_FORMAT_FLOAT_4X32 = chip.HIP_RES_VIEW_FORMAT_FLOAT_4X32
    HIP_RES_VIEW_FORMAT_UNSIGNED_BC1 = chip.HIP_RES_VIEW_FORMAT_UNSIGNED_BC1
    HIP_RES_VIEW_FORMAT_UNSIGNED_BC2 = chip.HIP_RES_VIEW_FORMAT_UNSIGNED_BC2
    HIP_RES_VIEW_FORMAT_UNSIGNED_BC3 = chip.HIP_RES_VIEW_FORMAT_UNSIGNED_BC3
    HIP_RES_VIEW_FORMAT_UNSIGNED_BC4 = chip.HIP_RES_VIEW_FORMAT_UNSIGNED_BC4
    HIP_RES_VIEW_FORMAT_SIGNED_BC4 = chip.HIP_RES_VIEW_FORMAT_SIGNED_BC4
    HIP_RES_VIEW_FORMAT_UNSIGNED_BC5 = chip.HIP_RES_VIEW_FORMAT_UNSIGNED_BC5
    HIP_RES_VIEW_FORMAT_SIGNED_BC5 = chip.HIP_RES_VIEW_FORMAT_SIGNED_BC5
    HIP_RES_VIEW_FORMAT_UNSIGNED_BC6H = chip.HIP_RES_VIEW_FORMAT_UNSIGNED_BC6H
    HIP_RES_VIEW_FORMAT_SIGNED_BC6H = chip.HIP_RES_VIEW_FORMAT_SIGNED_BC6H
    HIP_RES_VIEW_FORMAT_UNSIGNED_BC7 = chip.HIP_RES_VIEW_FORMAT_UNSIGNED_BC7
    @staticmethod
    def ctypes_type():
        """The type of the enum constants as ctypes type."""
        return ctypes.c_uint


HIPresourceViewFormat = HIPresourceViewFormat_enum

cdef class hipResourceDesc_union_0_struct_0(hip._util.types.Pointer):
    """Python wrapper for cdef class chip.hipResourceDesc_union_0_struct_0.

    Python wrapper for cdef class chip.hipResourceDesc_union_0_struct_0.

    If this type is initialized via its `__init__` method, it allocates a
    member of the underlying C type and destroys it again if the wrapper
    type is deallocated.

    This type also serves as adapter when appearing as argument type in a
    function signature. In this case, the type can further be initialized
    from a number of Python objects:

    * `None`:

      This will set the ``self._ptr`` attribute to ``NULL``.

    * `int`:

      Interprets the integer value as pointer address and writes it to ``self._ptr``.
      No ownership is transferred.

    * `ctypes.c_void_p`:

      Takes the pointer address ``pyobj.value`` and writes it to ``self._ptr``.
      No ownership is transferred.

    * `object` that implements the `CUDA Array Interface <https://numba.readthedocs.io/en/stable/cuda/cuda_array_interface.html>`_ protocol:

      Takes the integer-valued pointer address, i.e. the first entry of the `data` tuple
      from `pyobj`'s member ``__cuda_array_interface__``  and writes it to ``self._ptr``.

    * `object` that implements the Python buffer protocol:

      If the object represents a simple contiguous array,
      writes the `Py_buffer` associated with ``pyobj`` to `self._py_buffer`,
      sets the `self._py_buffer_acquired` flag to `True`, and
      writes `self._py_buffer.buf` to the data pointer `self._ptr`.

    * `hip._util.types.Pointer`:

      Takes the pointer address ``pyobj._ptr`` and writes it to ``self._ptr``.
      No ownership is transferred.

    Type checks are performed in the above order.

    C Attributes:
        _ptr (C type ``void *``, protected):
            Stores a pointer to the data of the original Python object.
        _is_ptr_owner (C type ``bint``, protected):
            If this wrapper is the owner of the underlying data.
        _py_buffer (C type ``Py_buffer`, protected):
            Stores a pointer to the data of the original Python object.
        _py_buffer_acquired (C type ``bint``, protected):
            Stores a pointer to the data of the original Python object.
    """
    # C members declared in pxd file

    def __cinit__(self):
        self._ptr = NULL
        self._is_ptr_owner = False
        self._py_buffer_acquired = False

    cdef chip.hipResourceDesc_union_0_struct_0* getElementPtr(self):
        return <chip.hipResourceDesc_union_0_struct_0*>self._ptr

    @staticmethod
    cdef hipResourceDesc_union_0_struct_0 fromPtr(void* ptr, bint owner=False):
        """Factory function to create ``hipResourceDesc_union_0_struct_0`` objects from
        given ``chip.hipResourceDesc_union_0_struct_0`` pointer.

        Setting ``owner`` flag to ``True`` causes
        the extension type to free the structure pointed to by ``ptr``
        when the wrapper object is deallocated.
        """
        # Fast call to __new__() that bypasses the __init__() constructor.
        cdef hipResourceDesc_union_0_struct_0 wrapper = hipResourceDesc_union_0_struct_0.__new__(hipResourceDesc_union_0_struct_0)
        wrapper._ptr = ptr
        wrapper._is_ptr_owner = owner
        return wrapper

    @staticmethod
    def fromObj(pyobj):
        """Creates a hipResourceDesc_union_0_struct_0 from a Python object.

        Derives a hipResourceDesc_union_0_struct_0 from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``hipResourceDesc_union_0_struct_0`` reference, this method
        returns it directly. No new ``hipResourceDesc_union_0_struct_0`` is created in this case.
        """
        return hipResourceDesc_union_0_struct_0.fromPyobj(pyobj)

    @staticmethod
    cdef hipResourceDesc_union_0_struct_0 fromPyobj(object pyobj):
        """Creates a hipResourceDesc_union_0_struct_0 from a Python object.

        Derives a hipResourceDesc_union_0_struct_0 from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``hipResourceDesc_union_0_struct_0`` reference, this method
        returns it directly. No new ``hipResourceDesc_union_0_struct_0`` is created in this case.

        Args:
            pyobj (object): Must be either `None`; a `hip._util.types.Pointer`; a simple, contiguous buffer according to the buffer protocol;
                            or of type `hipResourceDesc_union_0_struct_0`; `int`; or `ctypes.c_void_p`.

        Note:
            This routine does not perform a copy but returns the original ``pyobj``
            if ``pyobj`` is an instance of hipResourceDesc_union_0_struct_0!
        """
        cdef hipResourceDesc_union_0_struct_0 wrapper

        if isinstance(pyobj,hipResourceDesc_union_0_struct_0):
            return pyobj
        else:
            wrapper = hipResourceDesc_union_0_struct_0.__new__(hipResourceDesc_union_0_struct_0)
            wrapper.init_from_pyobj(pyobj)
            return wrapper

    def __dealloc__(self):
        # Release the buffer handle
        if self._py_buffer_acquired is True:
            cpython.buffer.PyBuffer_Release(&self._py_buffer)
        # De-allocate if not null and flag is set
        if self._ptr is not NULL and self._is_ptr_owner is True:
            stdlib.free(self._ptr)
            self._ptr = NULL

    @staticmethod
    cdef __allocate(void** ptr):
        ptr[0] = stdlib.malloc(sizeof(chip.hipResourceDesc_union_0_struct_0))
        string.memset(<void*>ptr[0], 0, sizeof(chip.hipResourceDesc_union_0_struct_0))

        if ptr[0] is NULL:
            raise MemoryError

    @staticmethod
    cdef hipResourceDesc_union_0_struct_0 new():
        """Factory function to create hipResourceDesc_union_0_struct_0 objects with
        newly allocated chip.hipResourceDesc_union_0_struct_0"""
        cdef void* ptr
        hipResourceDesc_union_0_struct_0.__allocate(&ptr)
        return hipResourceDesc_union_0_struct_0.fromPtr(ptr, owner=True)

    @staticmethod
    cdef hipResourceDesc_union_0_struct_0 fromValue(chip.hipResourceDesc_union_0_struct_0 other):
        """Allocate new C type and copy from ``other``.
        """
        wrapper = hipResourceDesc_union_0_struct_0.new()
        string.memcpy(wrapper._ptr, &other, sizeof(chip.hipResourceDesc_union_0_struct_0))
        return wrapper

    def c_sizeof(self):
        """Returns the size of the underlying C type in bytes.
        Note:
            Implemented as function to not collide with
            autogenerated property names.
        """
        return sizeof(chip.hipResourceDesc_union_0_struct_0)

    def __int__(self):
        """Returns the data's address as long integer.
        """
        return cpython.long.PyLong_FromVoidPtr(self._ptr)

    def __repr__(self):
        return f"<hipResourceDesc_union_0_struct_0 object, ptr: {int(self)}>"

    def as_c_void_p(self):
        """Returns the data's address as `ctypes.c_void_p`
        Note:
            Implemented as function to not collide with
            autogenerated property names.
        """
        return ctypes.c_void_p(int(self))

    def __init__(self,**kwargs):
        """Constructor type hipResourceDesc_union_0_struct_0.

        Constructor for type hipResourceDesc_union_0_struct_0.

        Args:
            **kwargs:
                Can be used to initialize member variables at construction,
                Just pass an argument expression of the form <member>=<value>
                per member that you want to initialize.
        """
        hipResourceDesc_union_0_struct_0.__allocate(&self._ptr)
        self._is_ptr_owner = True
        attribs = self.PROPERTIES()
        used_attribs = set()
        valid_names = ", ".join(["'"+p+"'" for p in attribs])
        for k,v in kwargs.items():
            if k in used_attribs:
                raise KeyError(f"argument '{k}' has already been specified as positional argument.")
            elif k not in attribs:
                raise KeyError(f"'{k}' is no valid property name. Valid names: {valid_names}")
            setattr(self,k,v)
    @staticmethod
    def PROPERTIES():
        return []

    def __contains__(self,item):
        properties = self.PROPERTIES()
        return item in properties

    def __getitem__(self,item):
        properties = self.PROPERTIES()
        if isinstance(item,int):
            if item < 0 or item >= len(properties):
                raise IndexError()
            return getattr(self,properties[item])
        raise ValueError("'item' type must be 'int'")


cdef class hipResourceDesc_union_0_struct_1(hip._util.types.Pointer):
    """Python wrapper for cdef class chip.hipResourceDesc_union_0_struct_1.

    Python wrapper for cdef class chip.hipResourceDesc_union_0_struct_1.

    If this type is initialized via its `__init__` method, it allocates a
    member of the underlying C type and destroys it again if the wrapper
    type is deallocated.

    This type also serves as adapter when appearing as argument type in a
    function signature. In this case, the type can further be initialized
    from a number of Python objects:

    * `None`:

      This will set the ``self._ptr`` attribute to ``NULL``.

    * `int`:

      Interprets the integer value as pointer address and writes it to ``self._ptr``.
      No ownership is transferred.

    * `ctypes.c_void_p`:

      Takes the pointer address ``pyobj.value`` and writes it to ``self._ptr``.
      No ownership is transferred.

    * `object` that implements the `CUDA Array Interface <https://numba.readthedocs.io/en/stable/cuda/cuda_array_interface.html>`_ protocol:

      Takes the integer-valued pointer address, i.e. the first entry of the `data` tuple
      from `pyobj`'s member ``__cuda_array_interface__``  and writes it to ``self._ptr``.

    * `object` that implements the Python buffer protocol:

      If the object represents a simple contiguous array,
      writes the `Py_buffer` associated with ``pyobj`` to `self._py_buffer`,
      sets the `self._py_buffer_acquired` flag to `True`, and
      writes `self._py_buffer.buf` to the data pointer `self._ptr`.

    * `hip._util.types.Pointer`:

      Takes the pointer address ``pyobj._ptr`` and writes it to ``self._ptr``.
      No ownership is transferred.

    Type checks are performed in the above order.

    C Attributes:
        _ptr (C type ``void *``, protected):
            Stores a pointer to the data of the original Python object.
        _is_ptr_owner (C type ``bint``, protected):
            If this wrapper is the owner of the underlying data.
        _py_buffer (C type ``Py_buffer`, protected):
            Stores a pointer to the data of the original Python object.
        _py_buffer_acquired (C type ``bint``, protected):
            Stores a pointer to the data of the original Python object.
    """
    # C members declared in pxd file

    def __cinit__(self):
        self._ptr = NULL
        self._is_ptr_owner = False
        self._py_buffer_acquired = False

    cdef chip.hipResourceDesc_union_0_struct_1* getElementPtr(self):
        return <chip.hipResourceDesc_union_0_struct_1*>self._ptr

    @staticmethod
    cdef hipResourceDesc_union_0_struct_1 fromPtr(void* ptr, bint owner=False):
        """Factory function to create ``hipResourceDesc_union_0_struct_1`` objects from
        given ``chip.hipResourceDesc_union_0_struct_1`` pointer.

        Setting ``owner`` flag to ``True`` causes
        the extension type to free the structure pointed to by ``ptr``
        when the wrapper object is deallocated.
        """
        # Fast call to __new__() that bypasses the __init__() constructor.
        cdef hipResourceDesc_union_0_struct_1 wrapper = hipResourceDesc_union_0_struct_1.__new__(hipResourceDesc_union_0_struct_1)
        wrapper._ptr = ptr
        wrapper._is_ptr_owner = owner
        return wrapper

    @staticmethod
    def fromObj(pyobj):
        """Creates a hipResourceDesc_union_0_struct_1 from a Python object.

        Derives a hipResourceDesc_union_0_struct_1 from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``hipResourceDesc_union_0_struct_1`` reference, this method
        returns it directly. No new ``hipResourceDesc_union_0_struct_1`` is created in this case.
        """
        return hipResourceDesc_union_0_struct_1.fromPyobj(pyobj)

    @staticmethod
    cdef hipResourceDesc_union_0_struct_1 fromPyobj(object pyobj):
        """Creates a hipResourceDesc_union_0_struct_1 from a Python object.

        Derives a hipResourceDesc_union_0_struct_1 from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``hipResourceDesc_union_0_struct_1`` reference, this method
        returns it directly. No new ``hipResourceDesc_union_0_struct_1`` is created in this case.

        Args:
            pyobj (object): Must be either `None`; a `hip._util.types.Pointer`; a simple, contiguous buffer according to the buffer protocol;
                            or of type `hipResourceDesc_union_0_struct_1`; `int`; or `ctypes.c_void_p`.

        Note:
            This routine does not perform a copy but returns the original ``pyobj``
            if ``pyobj`` is an instance of hipResourceDesc_union_0_struct_1!
        """
        cdef hipResourceDesc_union_0_struct_1 wrapper

        if isinstance(pyobj,hipResourceDesc_union_0_struct_1):
            return pyobj
        else:
            wrapper = hipResourceDesc_union_0_struct_1.__new__(hipResourceDesc_union_0_struct_1)
            wrapper.init_from_pyobj(pyobj)
            return wrapper

    def __dealloc__(self):
        # Release the buffer handle
        if self._py_buffer_acquired is True:
            cpython.buffer.PyBuffer_Release(&self._py_buffer)
        # De-allocate if not null and flag is set
        if self._ptr is not NULL and self._is_ptr_owner is True:
            stdlib.free(self._ptr)
            self._ptr = NULL

    @staticmethod
    cdef __allocate(void** ptr):
        ptr[0] = stdlib.malloc(sizeof(chip.hipResourceDesc_union_0_struct_1))
        string.memset(<void*>ptr[0], 0, sizeof(chip.hipResourceDesc_union_0_struct_1))

        if ptr[0] is NULL:
            raise MemoryError

    @staticmethod
    cdef hipResourceDesc_union_0_struct_1 new():
        """Factory function to create hipResourceDesc_union_0_struct_1 objects with
        newly allocated chip.hipResourceDesc_union_0_struct_1"""
        cdef void* ptr
        hipResourceDesc_union_0_struct_1.__allocate(&ptr)
        return hipResourceDesc_union_0_struct_1.fromPtr(ptr, owner=True)

    @staticmethod
    cdef hipResourceDesc_union_0_struct_1 fromValue(chip.hipResourceDesc_union_0_struct_1 other):
        """Allocate new C type and copy from ``other``.
        """
        wrapper = hipResourceDesc_union_0_struct_1.new()
        string.memcpy(wrapper._ptr, &other, sizeof(chip.hipResourceDesc_union_0_struct_1))
        return wrapper

    def c_sizeof(self):
        """Returns the size of the underlying C type in bytes.
        Note:
            Implemented as function to not collide with
            autogenerated property names.
        """
        return sizeof(chip.hipResourceDesc_union_0_struct_1)

    def __int__(self):
        """Returns the data's address as long integer.
        """
        return cpython.long.PyLong_FromVoidPtr(self._ptr)

    def __repr__(self):
        return f"<hipResourceDesc_union_0_struct_1 object, ptr: {int(self)}>"

    def as_c_void_p(self):
        """Returns the data's address as `ctypes.c_void_p`
        Note:
            Implemented as function to not collide with
            autogenerated property names.
        """
        return ctypes.c_void_p(int(self))

    def __init__(self,**kwargs):
        """Constructor type hipResourceDesc_union_0_struct_1.

        Constructor for type hipResourceDesc_union_0_struct_1.

        Args:
            **kwargs:
                Can be used to initialize member variables at construction,
                Just pass an argument expression of the form <member>=<value>
                per member that you want to initialize.
        """
        hipResourceDesc_union_0_struct_1.__allocate(&self._ptr)
        self._is_ptr_owner = True
        attribs = self.PROPERTIES()
        used_attribs = set()
        valid_names = ", ".join(["'"+p+"'" for p in attribs])
        for k,v in kwargs.items():
            if k in used_attribs:
                raise KeyError(f"argument '{k}' has already been specified as positional argument.")
            elif k not in attribs:
                raise KeyError(f"'{k}' is no valid property name. Valid names: {valid_names}")
            setattr(self,k,v)
    @staticmethod
    def PROPERTIES():
        return []

    def __contains__(self,item):
        properties = self.PROPERTIES()
        return item in properties

    def __getitem__(self,item):
        properties = self.PROPERTIES()
        if isinstance(item,int):
            if item < 0 or item >= len(properties):
                raise IndexError()
            return getattr(self,properties[item])
        raise ValueError("'item' type must be 'int'")


cdef class hipResourceDesc_union_0_struct_2(hip._util.types.Pointer):
    """Python wrapper for cdef class chip.hipResourceDesc_union_0_struct_2.

    Python wrapper for cdef class chip.hipResourceDesc_union_0_struct_2.

    If this type is initialized via its `__init__` method, it allocates a
    member of the underlying C type and destroys it again if the wrapper
    type is deallocated.

    This type also serves as adapter when appearing as argument type in a
    function signature. In this case, the type can further be initialized
    from a number of Python objects:

    * `None`:

      This will set the ``self._ptr`` attribute to ``NULL``.

    * `int`:

      Interprets the integer value as pointer address and writes it to ``self._ptr``.
      No ownership is transferred.

    * `ctypes.c_void_p`:

      Takes the pointer address ``pyobj.value`` and writes it to ``self._ptr``.
      No ownership is transferred.

    * `object` that implements the `CUDA Array Interface <https://numba.readthedocs.io/en/stable/cuda/cuda_array_interface.html>`_ protocol:

      Takes the integer-valued pointer address, i.e. the first entry of the `data` tuple
      from `pyobj`'s member ``__cuda_array_interface__``  and writes it to ``self._ptr``.

    * `object` that implements the Python buffer protocol:

      If the object represents a simple contiguous array,
      writes the `Py_buffer` associated with ``pyobj`` to `self._py_buffer`,
      sets the `self._py_buffer_acquired` flag to `True`, and
      writes `self._py_buffer.buf` to the data pointer `self._ptr`.

    * `hip._util.types.Pointer`:

      Takes the pointer address ``pyobj._ptr`` and writes it to ``self._ptr``.
      No ownership is transferred.

    Type checks are performed in the above order.

    C Attributes:
        _ptr (C type ``void *``, protected):
            Stores a pointer to the data of the original Python object.
        _is_ptr_owner (C type ``bint``, protected):
            If this wrapper is the owner of the underlying data.
        _py_buffer (C type ``Py_buffer`, protected):
            Stores a pointer to the data of the original Python object.
        _py_buffer_acquired (C type ``bint``, protected):
            Stores a pointer to the data of the original Python object.
    """
    # C members declared in pxd file

    def __cinit__(self):
        self._ptr = NULL
        self._is_ptr_owner = False
        self._py_buffer_acquired = False

    cdef chip.hipResourceDesc_union_0_struct_2* getElementPtr(self):
        return <chip.hipResourceDesc_union_0_struct_2*>self._ptr

    @staticmethod
    cdef hipResourceDesc_union_0_struct_2 fromPtr(void* ptr, bint owner=False):
        """Factory function to create ``hipResourceDesc_union_0_struct_2`` objects from
        given ``chip.hipResourceDesc_union_0_struct_2`` pointer.

        Setting ``owner`` flag to ``True`` causes
        the extension type to free the structure pointed to by ``ptr``
        when the wrapper object is deallocated.
        """
        # Fast call to __new__() that bypasses the __init__() constructor.
        cdef hipResourceDesc_union_0_struct_2 wrapper = hipResourceDesc_union_0_struct_2.__new__(hipResourceDesc_union_0_struct_2)
        wrapper._ptr = ptr
        wrapper._is_ptr_owner = owner
        return wrapper

    @staticmethod
    def fromObj(pyobj):
        """Creates a hipResourceDesc_union_0_struct_2 from a Python object.

        Derives a hipResourceDesc_union_0_struct_2 from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``hipResourceDesc_union_0_struct_2`` reference, this method
        returns it directly. No new ``hipResourceDesc_union_0_struct_2`` is created in this case.
        """
        return hipResourceDesc_union_0_struct_2.fromPyobj(pyobj)

    @staticmethod
    cdef hipResourceDesc_union_0_struct_2 fromPyobj(object pyobj):
        """Creates a hipResourceDesc_union_0_struct_2 from a Python object.

        Derives a hipResourceDesc_union_0_struct_2 from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``hipResourceDesc_union_0_struct_2`` reference, this method
        returns it directly. No new ``hipResourceDesc_union_0_struct_2`` is created in this case.

        Args:
            pyobj (object): Must be either `None`; a `hip._util.types.Pointer`; a simple, contiguous buffer according to the buffer protocol;
                            or of type `hipResourceDesc_union_0_struct_2`; `int`; or `ctypes.c_void_p`.

        Note:
            This routine does not perform a copy but returns the original ``pyobj``
            if ``pyobj`` is an instance of hipResourceDesc_union_0_struct_2!
        """
        cdef hipResourceDesc_union_0_struct_2 wrapper

        if isinstance(pyobj,hipResourceDesc_union_0_struct_2):
            return pyobj
        else:
            wrapper = hipResourceDesc_union_0_struct_2.__new__(hipResourceDesc_union_0_struct_2)
            wrapper.init_from_pyobj(pyobj)
            return wrapper

    def __dealloc__(self):
        # Release the buffer handle
        if self._py_buffer_acquired is True:
            cpython.buffer.PyBuffer_Release(&self._py_buffer)
        # De-allocate if not null and flag is set
        if self._ptr is not NULL and self._is_ptr_owner is True:
            stdlib.free(self._ptr)
            self._ptr = NULL

    @staticmethod
    cdef __allocate(void** ptr):
        ptr[0] = stdlib.malloc(sizeof(chip.hipResourceDesc_union_0_struct_2))
        string.memset(<void*>ptr[0], 0, sizeof(chip.hipResourceDesc_union_0_struct_2))

        if ptr[0] is NULL:
            raise MemoryError

    @staticmethod
    cdef hipResourceDesc_union_0_struct_2 new():
        """Factory function to create hipResourceDesc_union_0_struct_2 objects with
        newly allocated chip.hipResourceDesc_union_0_struct_2"""
        cdef void* ptr
        hipResourceDesc_union_0_struct_2.__allocate(&ptr)
        return hipResourceDesc_union_0_struct_2.fromPtr(ptr, owner=True)

    @staticmethod
    cdef hipResourceDesc_union_0_struct_2 fromValue(chip.hipResourceDesc_union_0_struct_2 other):
        """Allocate new C type and copy from ``other``.
        """
        wrapper = hipResourceDesc_union_0_struct_2.new()
        string.memcpy(wrapper._ptr, &other, sizeof(chip.hipResourceDesc_union_0_struct_2))
        return wrapper

    def c_sizeof(self):
        """Returns the size of the underlying C type in bytes.
        Note:
            Implemented as function to not collide with
            autogenerated property names.
        """
        return sizeof(chip.hipResourceDesc_union_0_struct_2)

    def __int__(self):
        """Returns the data's address as long integer.
        """
        return cpython.long.PyLong_FromVoidPtr(self._ptr)

    def __repr__(self):
        return f"<hipResourceDesc_union_0_struct_2 object, ptr: {int(self)}>"

    def as_c_void_p(self):
        """Returns the data's address as `ctypes.c_void_p`
        Note:
            Implemented as function to not collide with
            autogenerated property names.
        """
        return ctypes.c_void_p(int(self))

    def __init__(self,*args,**kwargs):
        """Constructor type hipResourceDesc_union_0_struct_2.

        Constructor for type hipResourceDesc_union_0_struct_2.

        Args:
            *args:
                Positional arguments. Initialize all or a subset of the member variables
                according to their order of declaration.
            **kwargs:
                Can be used to initialize member variables at construction,
                Just pass an argument expression of the form <member>=<value>
                per member that you want to initialize.
        """
        hipResourceDesc_union_0_struct_2.__allocate(&self._ptr)
        self._is_ptr_owner = True
        attribs = self.PROPERTIES()
        used_attribs = set()
        if len(args) > len(attribs):
            raise ValueError("More positional arguments specified than this type has properties.")
        for i,v in enumerate(args):
            setattr(self,attribs[i],v)
            used_attribs.add(attribs[i])
        valid_names = ", ".join(["'"+p+"'" for p in attribs])
        for k,v in kwargs.items():
            if k in used_attribs:
                raise KeyError(f"argument '{k}' has already been specified as positional argument.")
            elif k not in attribs:
                raise KeyError(f"'{k}' is no valid property name. Valid names: {valid_names}")
            setattr(self,k,v)
    def get_devPtr(self, i):
        """Get value ``devPtr`` of ``(<chip.hipResourceDesc_union_0_struct_2*>self._ptr)[i]``.
        """
        return hip._util.types.Pointer.fromPtr((<chip.hipResourceDesc_union_0_struct_2*>self._ptr)[i].devPtr)
    def set_devPtr(self, i, object value):
        """Set value ``devPtr`` of ``(<chip.hipResourceDesc_union_0_struct_2*>self._ptr)[i]``.

        Note:
            This can be dangerous if the pointer is from a python object
            that is later on garbage collected.
        """
        (<chip.hipResourceDesc_union_0_struct_2*>self._ptr)[i].devPtr = <void *>cpython.long.PyLong_AsVoidPtr(int(hip._util.types.Pointer.fromPyobj(value)))
    @property
    def devPtr(self):
        """(undocumented)
        Note:
            Setting this devPtr can be dangerous if the underlying pointer is from a python object that
            is later on garbage collected.
        """
        return self.get_devPtr(0)
    @devPtr.setter
    def devPtr(self, object value):
        self.set_devPtr(0,value)

    def get_desc(self, i):
        """Get value of ``desc`` of ``(<chip.hipResourceDesc_union_0_struct_2*>self._ptr)[i]``.
        """
        return hipChannelFormatDesc.fromPtr(&(<chip.hipResourceDesc_union_0_struct_2*>self._ptr)[i].desc)
    @property
    def desc(self):
        """(undocumented)"""
        return self.get_desc(0)

    def get_sizeInBytes(self, i):
        """Get value ``sizeInBytes`` of ``(<chip.hipResourceDesc_union_0_struct_2*>self._ptr)[i]``.
        """
        return (<chip.hipResourceDesc_union_0_struct_2*>self._ptr)[i].sizeInBytes
    def set_sizeInBytes(self, i, unsigned long value):
        """Set value ``sizeInBytes`` of ``(<chip.hipResourceDesc_union_0_struct_2*>self._ptr)[i]``.
        """
        (<chip.hipResourceDesc_union_0_struct_2*>self._ptr)[i].sizeInBytes = value
    @property
    def sizeInBytes(self):
        """(undocumented)"""
        return self.get_sizeInBytes(0)
    @sizeInBytes.setter
    def sizeInBytes(self, unsigned long value):
        self.set_sizeInBytes(0,value)

    @staticmethod
    def PROPERTIES():
        return ["devPtr","desc","sizeInBytes"]

    def __contains__(self,item):
        properties = self.PROPERTIES()
        return item in properties

    def __getitem__(self,item):
        properties = self.PROPERTIES()
        if isinstance(item,int):
            if item < 0 or item >= len(properties):
                raise IndexError()
            return getattr(self,properties[item])
        raise ValueError("'item' type must be 'int'")


cdef class hipResourceDesc_union_0_struct_3(hip._util.types.Pointer):
    """Python wrapper for cdef class chip.hipResourceDesc_union_0_struct_3.

    Python wrapper for cdef class chip.hipResourceDesc_union_0_struct_3.

    If this type is initialized via its `__init__` method, it allocates a
    member of the underlying C type and destroys it again if the wrapper
    type is deallocated.

    This type also serves as adapter when appearing as argument type in a
    function signature. In this case, the type can further be initialized
    from a number of Python objects:

    * `None`:

      This will set the ``self._ptr`` attribute to ``NULL``.

    * `int`:

      Interprets the integer value as pointer address and writes it to ``self._ptr``.
      No ownership is transferred.

    * `ctypes.c_void_p`:

      Takes the pointer address ``pyobj.value`` and writes it to ``self._ptr``.
      No ownership is transferred.

    * `object` that implements the `CUDA Array Interface <https://numba.readthedocs.io/en/stable/cuda/cuda_array_interface.html>`_ protocol:

      Takes the integer-valued pointer address, i.e. the first entry of the `data` tuple
      from `pyobj`'s member ``__cuda_array_interface__``  and writes it to ``self._ptr``.

    * `object` that implements the Python buffer protocol:

      If the object represents a simple contiguous array,
      writes the `Py_buffer` associated with ``pyobj`` to `self._py_buffer`,
      sets the `self._py_buffer_acquired` flag to `True`, and
      writes `self._py_buffer.buf` to the data pointer `self._ptr`.

    * `hip._util.types.Pointer`:

      Takes the pointer address ``pyobj._ptr`` and writes it to ``self._ptr``.
      No ownership is transferred.

    Type checks are performed in the above order.

    C Attributes:
        _ptr (C type ``void *``, protected):
            Stores a pointer to the data of the original Python object.
        _is_ptr_owner (C type ``bint``, protected):
            If this wrapper is the owner of the underlying data.
        _py_buffer (C type ``Py_buffer`, protected):
            Stores a pointer to the data of the original Python object.
        _py_buffer_acquired (C type ``bint``, protected):
            Stores a pointer to the data of the original Python object.
    """
    # C members declared in pxd file

    def __cinit__(self):
        self._ptr = NULL
        self._is_ptr_owner = False
        self._py_buffer_acquired = False

    cdef chip.hipResourceDesc_union_0_struct_3* getElementPtr(self):
        return <chip.hipResourceDesc_union_0_struct_3*>self._ptr

    @staticmethod
    cdef hipResourceDesc_union_0_struct_3 fromPtr(void* ptr, bint owner=False):
        """Factory function to create ``hipResourceDesc_union_0_struct_3`` objects from
        given ``chip.hipResourceDesc_union_0_struct_3`` pointer.

        Setting ``owner`` flag to ``True`` causes
        the extension type to free the structure pointed to by ``ptr``
        when the wrapper object is deallocated.
        """
        # Fast call to __new__() that bypasses the __init__() constructor.
        cdef hipResourceDesc_union_0_struct_3 wrapper = hipResourceDesc_union_0_struct_3.__new__(hipResourceDesc_union_0_struct_3)
        wrapper._ptr = ptr
        wrapper._is_ptr_owner = owner
        return wrapper

    @staticmethod
    def fromObj(pyobj):
        """Creates a hipResourceDesc_union_0_struct_3 from a Python object.

        Derives a hipResourceDesc_union_0_struct_3 from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``hipResourceDesc_union_0_struct_3`` reference, this method
        returns it directly. No new ``hipResourceDesc_union_0_struct_3`` is created in this case.
        """
        return hipResourceDesc_union_0_struct_3.fromPyobj(pyobj)

    @staticmethod
    cdef hipResourceDesc_union_0_struct_3 fromPyobj(object pyobj):
        """Creates a hipResourceDesc_union_0_struct_3 from a Python object.

        Derives a hipResourceDesc_union_0_struct_3 from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``hipResourceDesc_union_0_struct_3`` reference, this method
        returns it directly. No new ``hipResourceDesc_union_0_struct_3`` is created in this case.

        Args:
            pyobj (object): Must be either `None`; a `hip._util.types.Pointer`; a simple, contiguous buffer according to the buffer protocol;
                            or of type `hipResourceDesc_union_0_struct_3`; `int`; or `ctypes.c_void_p`.

        Note:
            This routine does not perform a copy but returns the original ``pyobj``
            if ``pyobj`` is an instance of hipResourceDesc_union_0_struct_3!
        """
        cdef hipResourceDesc_union_0_struct_3 wrapper

        if isinstance(pyobj,hipResourceDesc_union_0_struct_3):
            return pyobj
        else:
            wrapper = hipResourceDesc_union_0_struct_3.__new__(hipResourceDesc_union_0_struct_3)
            wrapper.init_from_pyobj(pyobj)
            return wrapper

    def __dealloc__(self):
        # Release the buffer handle
        if self._py_buffer_acquired is True:
            cpython.buffer.PyBuffer_Release(&self._py_buffer)
        # De-allocate if not null and flag is set
        if self._ptr is not NULL and self._is_ptr_owner is True:
            stdlib.free(self._ptr)
            self._ptr = NULL

    @staticmethod
    cdef __allocate(void** ptr):
        ptr[0] = stdlib.malloc(sizeof(chip.hipResourceDesc_union_0_struct_3))
        string.memset(<void*>ptr[0], 0, sizeof(chip.hipResourceDesc_union_0_struct_3))

        if ptr[0] is NULL:
            raise MemoryError

    @staticmethod
    cdef hipResourceDesc_union_0_struct_3 new():
        """Factory function to create hipResourceDesc_union_0_struct_3 objects with
        newly allocated chip.hipResourceDesc_union_0_struct_3"""
        cdef void* ptr
        hipResourceDesc_union_0_struct_3.__allocate(&ptr)
        return hipResourceDesc_union_0_struct_3.fromPtr(ptr, owner=True)

    @staticmethod
    cdef hipResourceDesc_union_0_struct_3 fromValue(chip.hipResourceDesc_union_0_struct_3 other):
        """Allocate new C type and copy from ``other``.
        """
        wrapper = hipResourceDesc_union_0_struct_3.new()
        string.memcpy(wrapper._ptr, &other, sizeof(chip.hipResourceDesc_union_0_struct_3))
        return wrapper

    def c_sizeof(self):
        """Returns the size of the underlying C type in bytes.
        Note:
            Implemented as function to not collide with
            autogenerated property names.
        """
        return sizeof(chip.hipResourceDesc_union_0_struct_3)

    def __int__(self):
        """Returns the data's address as long integer.
        """
        return cpython.long.PyLong_FromVoidPtr(self._ptr)

    def __repr__(self):
        return f"<hipResourceDesc_union_0_struct_3 object, ptr: {int(self)}>"

    def as_c_void_p(self):
        """Returns the data's address as `ctypes.c_void_p`
        Note:
            Implemented as function to not collide with
            autogenerated property names.
        """
        return ctypes.c_void_p(int(self))

    def __init__(self,*args,**kwargs):
        """Constructor type hipResourceDesc_union_0_struct_3.

        Constructor for type hipResourceDesc_union_0_struct_3.

        Args:
            *args:
                Positional arguments. Initialize all or a subset of the member variables
                according to their order of declaration.
            **kwargs:
                Can be used to initialize member variables at construction,
                Just pass an argument expression of the form <member>=<value>
                per member that you want to initialize.
        """
        hipResourceDesc_union_0_struct_3.__allocate(&self._ptr)
        self._is_ptr_owner = True
        attribs = self.PROPERTIES()
        used_attribs = set()
        if len(args) > len(attribs):
            raise ValueError("More positional arguments specified than this type has properties.")
        for i,v in enumerate(args):
            setattr(self,attribs[i],v)
            used_attribs.add(attribs[i])
        valid_names = ", ".join(["'"+p+"'" for p in attribs])
        for k,v in kwargs.items():
            if k in used_attribs:
                raise KeyError(f"argument '{k}' has already been specified as positional argument.")
            elif k not in attribs:
                raise KeyError(f"'{k}' is no valid property name. Valid names: {valid_names}")
            setattr(self,k,v)
    def get_devPtr(self, i):
        """Get value ``devPtr`` of ``(<chip.hipResourceDesc_union_0_struct_3*>self._ptr)[i]``.
        """
        return hip._util.types.Pointer.fromPtr((<chip.hipResourceDesc_union_0_struct_3*>self._ptr)[i].devPtr)
    def set_devPtr(self, i, object value):
        """Set value ``devPtr`` of ``(<chip.hipResourceDesc_union_0_struct_3*>self._ptr)[i]``.

        Note:
            This can be dangerous if the pointer is from a python object
            that is later on garbage collected.
        """
        (<chip.hipResourceDesc_union_0_struct_3*>self._ptr)[i].devPtr = <void *>cpython.long.PyLong_AsVoidPtr(int(hip._util.types.Pointer.fromPyobj(value)))
    @property
    def devPtr(self):
        """(undocumented)
        Note:
            Setting this devPtr can be dangerous if the underlying pointer is from a python object that
            is later on garbage collected.
        """
        return self.get_devPtr(0)
    @devPtr.setter
    def devPtr(self, object value):
        self.set_devPtr(0,value)

    def get_desc(self, i):
        """Get value of ``desc`` of ``(<chip.hipResourceDesc_union_0_struct_3*>self._ptr)[i]``.
        """
        return hipChannelFormatDesc.fromPtr(&(<chip.hipResourceDesc_union_0_struct_3*>self._ptr)[i].desc)
    @property
    def desc(self):
        """(undocumented)"""
        return self.get_desc(0)

    def get_width(self, i):
        """Get value ``width`` of ``(<chip.hipResourceDesc_union_0_struct_3*>self._ptr)[i]``.
        """
        return (<chip.hipResourceDesc_union_0_struct_3*>self._ptr)[i].width
    def set_width(self, i, unsigned long value):
        """Set value ``width`` of ``(<chip.hipResourceDesc_union_0_struct_3*>self._ptr)[i]``.
        """
        (<chip.hipResourceDesc_union_0_struct_3*>self._ptr)[i].width = value
    @property
    def width(self):
        """(undocumented)"""
        return self.get_width(0)
    @width.setter
    def width(self, unsigned long value):
        self.set_width(0,value)

    def get_height(self, i):
        """Get value ``height`` of ``(<chip.hipResourceDesc_union_0_struct_3*>self._ptr)[i]``.
        """
        return (<chip.hipResourceDesc_union_0_struct_3*>self._ptr)[i].height
    def set_height(self, i, unsigned long value):
        """Set value ``height`` of ``(<chip.hipResourceDesc_union_0_struct_3*>self._ptr)[i]``.
        """
        (<chip.hipResourceDesc_union_0_struct_3*>self._ptr)[i].height = value
    @property
    def height(self):
        """(undocumented)"""
        return self.get_height(0)
    @height.setter
    def height(self, unsigned long value):
        self.set_height(0,value)

    def get_pitchInBytes(self, i):
        """Get value ``pitchInBytes`` of ``(<chip.hipResourceDesc_union_0_struct_3*>self._ptr)[i]``.
        """
        return (<chip.hipResourceDesc_union_0_struct_3*>self._ptr)[i].pitchInBytes
    def set_pitchInBytes(self, i, unsigned long value):
        """Set value ``pitchInBytes`` of ``(<chip.hipResourceDesc_union_0_struct_3*>self._ptr)[i]``.
        """
        (<chip.hipResourceDesc_union_0_struct_3*>self._ptr)[i].pitchInBytes = value
    @property
    def pitchInBytes(self):
        """(undocumented)"""
        return self.get_pitchInBytes(0)
    @pitchInBytes.setter
    def pitchInBytes(self, unsigned long value):
        self.set_pitchInBytes(0,value)

    @staticmethod
    def PROPERTIES():
        return ["devPtr","desc","width","height","pitchInBytes"]

    def __contains__(self,item):
        properties = self.PROPERTIES()
        return item in properties

    def __getitem__(self,item):
        properties = self.PROPERTIES()
        if isinstance(item,int):
            if item < 0 or item >= len(properties):
                raise IndexError()
            return getattr(self,properties[item])
        raise ValueError("'item' type must be 'int'")


cdef class hipResourceDesc_union_0(hip._util.types.Pointer):
    """Python wrapper for cdef class chip.hipResourceDesc_union_0.

    Python wrapper for cdef class chip.hipResourceDesc_union_0.

    If this type is initialized via its `__init__` method, it allocates a
    member of the underlying C type and destroys it again if the wrapper
    type is deallocated.

    This type also serves as adapter when appearing as argument type in a
    function signature. In this case, the type can further be initialized
    from a number of Python objects:

    * `None`:

      This will set the ``self._ptr`` attribute to ``NULL``.

    * `int`:

      Interprets the integer value as pointer address and writes it to ``self._ptr``.
      No ownership is transferred.

    * `ctypes.c_void_p`:

      Takes the pointer address ``pyobj.value`` and writes it to ``self._ptr``.
      No ownership is transferred.

    * `object` that implements the `CUDA Array Interface <https://numba.readthedocs.io/en/stable/cuda/cuda_array_interface.html>`_ protocol:

      Takes the integer-valued pointer address, i.e. the first entry of the `data` tuple
      from `pyobj`'s member ``__cuda_array_interface__``  and writes it to ``self._ptr``.

    * `object` that implements the Python buffer protocol:

      If the object represents a simple contiguous array,
      writes the `Py_buffer` associated with ``pyobj`` to `self._py_buffer`,
      sets the `self._py_buffer_acquired` flag to `True`, and
      writes `self._py_buffer.buf` to the data pointer `self._ptr`.

    * `hip._util.types.Pointer`:

      Takes the pointer address ``pyobj._ptr`` and writes it to ``self._ptr``.
      No ownership is transferred.

    Type checks are performed in the above order.

    C Attributes:
        _ptr (C type ``void *``, protected):
            Stores a pointer to the data of the original Python object.
        _is_ptr_owner (C type ``bint``, protected):
            If this wrapper is the owner of the underlying data.
        _py_buffer (C type ``Py_buffer`, protected):
            Stores a pointer to the data of the original Python object.
        _py_buffer_acquired (C type ``bint``, protected):
            Stores a pointer to the data of the original Python object.
    """
    # C members declared in pxd file

    def __cinit__(self):
        self._ptr = NULL
        self._is_ptr_owner = False
        self._py_buffer_acquired = False

    cdef chip.hipResourceDesc_union_0* getElementPtr(self):
        return <chip.hipResourceDesc_union_0*>self._ptr

    @staticmethod
    cdef hipResourceDesc_union_0 fromPtr(void* ptr, bint owner=False):
        """Factory function to create ``hipResourceDesc_union_0`` objects from
        given ``chip.hipResourceDesc_union_0`` pointer.

        Setting ``owner`` flag to ``True`` causes
        the extension type to free the structure pointed to by ``ptr``
        when the wrapper object is deallocated.
        """
        # Fast call to __new__() that bypasses the __init__() constructor.
        cdef hipResourceDesc_union_0 wrapper = hipResourceDesc_union_0.__new__(hipResourceDesc_union_0)
        wrapper._ptr = ptr
        wrapper._is_ptr_owner = owner
        return wrapper

    @staticmethod
    def fromObj(pyobj):
        """Creates a hipResourceDesc_union_0 from a Python object.

        Derives a hipResourceDesc_union_0 from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``hipResourceDesc_union_0`` reference, this method
        returns it directly. No new ``hipResourceDesc_union_0`` is created in this case.
        """
        return hipResourceDesc_union_0.fromPyobj(pyobj)

    @staticmethod
    cdef hipResourceDesc_union_0 fromPyobj(object pyobj):
        """Creates a hipResourceDesc_union_0 from a Python object.

        Derives a hipResourceDesc_union_0 from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``hipResourceDesc_union_0`` reference, this method
        returns it directly. No new ``hipResourceDesc_union_0`` is created in this case.

        Args:
            pyobj (object): Must be either `None`; a `hip._util.types.Pointer`; a simple, contiguous buffer according to the buffer protocol;
                            or of type `hipResourceDesc_union_0`; `int`; or `ctypes.c_void_p`.

        Note:
            This routine does not perform a copy but returns the original ``pyobj``
            if ``pyobj`` is an instance of hipResourceDesc_union_0!
        """
        cdef hipResourceDesc_union_0 wrapper

        if isinstance(pyobj,hipResourceDesc_union_0):
            return pyobj
        else:
            wrapper = hipResourceDesc_union_0.__new__(hipResourceDesc_union_0)
            wrapper.init_from_pyobj(pyobj)
            return wrapper

    def __dealloc__(self):
        # Release the buffer handle
        if self._py_buffer_acquired is True:
            cpython.buffer.PyBuffer_Release(&self._py_buffer)
        # De-allocate if not null and flag is set
        if self._ptr is not NULL and self._is_ptr_owner is True:
            stdlib.free(self._ptr)
            self._ptr = NULL

    @staticmethod
    cdef __allocate(void** ptr):
        ptr[0] = stdlib.malloc(sizeof(chip.hipResourceDesc_union_0))
        string.memset(<void*>ptr[0], 0, sizeof(chip.hipResourceDesc_union_0))

        if ptr[0] is NULL:
            raise MemoryError

    @staticmethod
    cdef hipResourceDesc_union_0 new():
        """Factory function to create hipResourceDesc_union_0 objects with
        newly allocated chip.hipResourceDesc_union_0"""
        cdef void* ptr
        hipResourceDesc_union_0.__allocate(&ptr)
        return hipResourceDesc_union_0.fromPtr(ptr, owner=True)

    @staticmethod
    cdef hipResourceDesc_union_0 fromValue(chip.hipResourceDesc_union_0 other):
        """Allocate new C type and copy from ``other``.
        """
        wrapper = hipResourceDesc_union_0.new()
        string.memcpy(wrapper._ptr, &other, sizeof(chip.hipResourceDesc_union_0))
        return wrapper

    def c_sizeof(self):
        """Returns the size of the underlying C type in bytes.
        Note:
            Implemented as function to not collide with
            autogenerated property names.
        """
        return sizeof(chip.hipResourceDesc_union_0)

    def __int__(self):
        """Returns the data's address as long integer.
        """
        return cpython.long.PyLong_FromVoidPtr(self._ptr)

    def __repr__(self):
        return f"<hipResourceDesc_union_0 object, ptr: {int(self)}>"

    def as_c_void_p(self):
        """Returns the data's address as `ctypes.c_void_p`
        Note:
            Implemented as function to not collide with
            autogenerated property names.
        """
        return ctypes.c_void_p(int(self))

    def __init__(self,**kwargs):
        """Constructor type hipResourceDesc_union_0.

        Constructor for type hipResourceDesc_union_0.

        Args:
            **kwargs:
                Can be used to initialize member variables at construction,
                Just pass an argument expression of the form <member>=<value>
                per member that you want to initialize.
        """
        hipResourceDesc_union_0.__allocate(&self._ptr)
        self._is_ptr_owner = True
        attribs = self.PROPERTIES()
        used_attribs = set()
        if len(kwargs) > 1:
            raise ValueError("Not more than one attribute might specified for Python types derived from C union types.")
        valid_names = ", ".join(["'"+p+"'" for p in attribs])
        for k,v in kwargs.items():
            if k in used_attribs:
                raise KeyError(f"argument '{k}' has already been specified as positional argument.")
            elif k not in attribs:
                raise KeyError(f"'{k}' is no valid property name. Valid names: {valid_names}")
            setattr(self,k,v)
    def get_array(self, i):
        """Get value of ``array`` of ``(<chip.hipResourceDesc_union_0*>self._ptr)[i]``.
        """
        return hipResourceDesc_union_0_struct_0.fromPtr(&(<chip.hipResourceDesc_union_0*>self._ptr)[i].array)
    @property
    def array(self):
        """(undocumented)"""
        return self.get_array(0)

    def get_mipmap(self, i):
        """Get value of ``mipmap`` of ``(<chip.hipResourceDesc_union_0*>self._ptr)[i]``.
        """
        return hipResourceDesc_union_0_struct_1.fromPtr(&(<chip.hipResourceDesc_union_0*>self._ptr)[i].mipmap)
    @property
    def mipmap(self):
        """(undocumented)"""
        return self.get_mipmap(0)

    def get_linear(self, i):
        """Get value of ``linear`` of ``(<chip.hipResourceDesc_union_0*>self._ptr)[i]``.
        """
        return hipResourceDesc_union_0_struct_2.fromPtr(&(<chip.hipResourceDesc_union_0*>self._ptr)[i].linear)
    @property
    def linear(self):
        """(undocumented)"""
        return self.get_linear(0)

    def get_pitch2D(self, i):
        """Get value of ``pitch2D`` of ``(<chip.hipResourceDesc_union_0*>self._ptr)[i]``.
        """
        return hipResourceDesc_union_0_struct_3.fromPtr(&(<chip.hipResourceDesc_union_0*>self._ptr)[i].pitch2D)
    @property
    def pitch2D(self):
        """(undocumented)"""
        return self.get_pitch2D(0)

    @staticmethod
    def PROPERTIES():
        return ["array","mipmap","linear","pitch2D"]


cdef class hipResourceDesc(hip._util.types.Pointer):
    """Python wrapper for cdef class chip.hipResourceDesc.

    Python wrapper for cdef class chip.hipResourceDesc.

    If this type is initialized via its `__init__` method, it allocates a
    member of the underlying C type and destroys it again if the wrapper
    type is deallocated.

    This type also serves as adapter when appearing as argument type in a
    function signature. In this case, the type can further be initialized
    from a number of Python objects:

    * `None`:

      This will set the ``self._ptr`` attribute to ``NULL``.

    * `int`:

      Interprets the integer value as pointer address and writes it to ``self._ptr``.
      No ownership is transferred.

    * `ctypes.c_void_p`:

      Takes the pointer address ``pyobj.value`` and writes it to ``self._ptr``.
      No ownership is transferred.

    * `object` that implements the `CUDA Array Interface <https://numba.readthedocs.io/en/stable/cuda/cuda_array_interface.html>`_ protocol:

      Takes the integer-valued pointer address, i.e. the first entry of the `data` tuple
      from `pyobj`'s member ``__cuda_array_interface__``  and writes it to ``self._ptr``.

    * `object` that implements the Python buffer protocol:

      If the object represents a simple contiguous array,
      writes the `Py_buffer` associated with ``pyobj`` to `self._py_buffer`,
      sets the `self._py_buffer_acquired` flag to `True`, and
      writes `self._py_buffer.buf` to the data pointer `self._ptr`.

    * `hip._util.types.Pointer`:

      Takes the pointer address ``pyobj._ptr`` and writes it to ``self._ptr``.
      No ownership is transferred.

    Type checks are performed in the above order.

    C Attributes:
        _ptr (C type ``void *``, protected):
            Stores a pointer to the data of the original Python object.
        _is_ptr_owner (C type ``bint``, protected):
            If this wrapper is the owner of the underlying data.
        _py_buffer (C type ``Py_buffer`, protected):
            Stores a pointer to the data of the original Python object.
        _py_buffer_acquired (C type ``bint``, protected):
            Stores a pointer to the data of the original Python object.
    """
    # C members declared in pxd file

    def __cinit__(self):
        self._ptr = NULL
        self._is_ptr_owner = False
        self._py_buffer_acquired = False

    cdef chip.hipResourceDesc* getElementPtr(self):
        return <chip.hipResourceDesc*>self._ptr

    @staticmethod
    cdef hipResourceDesc fromPtr(void* ptr, bint owner=False):
        """Factory function to create ``hipResourceDesc`` objects from
        given ``chip.hipResourceDesc`` pointer.

        Setting ``owner`` flag to ``True`` causes
        the extension type to free the structure pointed to by ``ptr``
        when the wrapper object is deallocated.
        """
        # Fast call to __new__() that bypasses the __init__() constructor.
        cdef hipResourceDesc wrapper = hipResourceDesc.__new__(hipResourceDesc)
        wrapper._ptr = ptr
        wrapper._is_ptr_owner = owner
        return wrapper

    @staticmethod
    def fromObj(pyobj):
        """Creates a hipResourceDesc from a Python object.

        Derives a hipResourceDesc from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``hipResourceDesc`` reference, this method
        returns it directly. No new ``hipResourceDesc`` is created in this case.
        """
        return hipResourceDesc.fromPyobj(pyobj)

    @staticmethod
    cdef hipResourceDesc fromPyobj(object pyobj):
        """Creates a hipResourceDesc from a Python object.

        Derives a hipResourceDesc from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``hipResourceDesc`` reference, this method
        returns it directly. No new ``hipResourceDesc`` is created in this case.

        Args:
            pyobj (object): Must be either `None`; a `hip._util.types.Pointer`; a simple, contiguous buffer according to the buffer protocol;
                            or of type `hipResourceDesc`; `int`; or `ctypes.c_void_p`.

        Note:
            This routine does not perform a copy but returns the original ``pyobj``
            if ``pyobj`` is an instance of hipResourceDesc!
        """
        cdef hipResourceDesc wrapper

        if isinstance(pyobj,hipResourceDesc):
            return pyobj
        else:
            wrapper = hipResourceDesc.__new__(hipResourceDesc)
            wrapper.init_from_pyobj(pyobj)
            return wrapper

    def __dealloc__(self):
        # Release the buffer handle
        if self._py_buffer_acquired is True:
            cpython.buffer.PyBuffer_Release(&self._py_buffer)
        # De-allocate if not null and flag is set
        if self._ptr is not NULL and self._is_ptr_owner is True:
            stdlib.free(self._ptr)
            self._ptr = NULL

    @staticmethod
    cdef __allocate(void** ptr):
        ptr[0] = stdlib.malloc(sizeof(chip.hipResourceDesc))
        string.memset(<void*>ptr[0], 0, sizeof(chip.hipResourceDesc))

        if ptr[0] is NULL:
            raise MemoryError

    @staticmethod
    cdef hipResourceDesc new():
        """Factory function to create hipResourceDesc objects with
        newly allocated chip.hipResourceDesc"""
        cdef void* ptr
        hipResourceDesc.__allocate(&ptr)
        return hipResourceDesc.fromPtr(ptr, owner=True)

    @staticmethod
    cdef hipResourceDesc fromValue(chip.hipResourceDesc other):
        """Allocate new C type and copy from ``other``.
        """
        wrapper = hipResourceDesc.new()
        string.memcpy(wrapper._ptr, &other, sizeof(chip.hipResourceDesc))
        return wrapper

    def c_sizeof(self):
        """Returns the size of the underlying C type in bytes.
        Note:
            Implemented as function to not collide with
            autogenerated property names.
        """
        return sizeof(chip.hipResourceDesc)

    def __int__(self):
        """Returns the data's address as long integer.
        """
        return cpython.long.PyLong_FromVoidPtr(self._ptr)

    def __repr__(self):
        return f"<hipResourceDesc object, ptr: {int(self)}>"

    def as_c_void_p(self):
        """Returns the data's address as `ctypes.c_void_p`
        Note:
            Implemented as function to not collide with
            autogenerated property names.
        """
        return ctypes.c_void_p(int(self))

    def __init__(self,*args,**kwargs):
        """Constructor type hipResourceDesc.

        Constructor for type hipResourceDesc.

        Args:
            *args:
                Positional arguments. Initialize all or a subset of the member variables
                according to their order of declaration.
            **kwargs:
                Can be used to initialize member variables at construction,
                Just pass an argument expression of the form <member>=<value>
                per member that you want to initialize.
        """
        hipResourceDesc.__allocate(&self._ptr)
        self._is_ptr_owner = True
        attribs = self.PROPERTIES()
        used_attribs = set()
        if len(args) > len(attribs):
            raise ValueError("More positional arguments specified than this type has properties.")
        for i,v in enumerate(args):
            setattr(self,attribs[i],v)
            used_attribs.add(attribs[i])
        valid_names = ", ".join(["'"+p+"'" for p in attribs])
        for k,v in kwargs.items():
            if k in used_attribs:
                raise KeyError(f"argument '{k}' has already been specified as positional argument.")
            elif k not in attribs:
                raise KeyError(f"'{k}' is no valid property name. Valid names: {valid_names}")
            setattr(self,k,v)
    def get_resType(self, i):
        """Get value of ``resType`` of ``(<chip.hipResourceDesc*>self._ptr)[i]``.
        """
        return hipResourceType((<chip.hipResourceDesc*>self._ptr)[i].resType)
    def set_resType(self, i, value):
        """Set value ``resType`` of ``(<chip.hipResourceDesc*>self._ptr)[i]``.
        """
        if not isinstance(value, hipResourceType):
            raise TypeError("'value' must be of type 'hipResourceType'")
        (<chip.hipResourceDesc*>self._ptr)[i].resType = value.value
    @property
    def resType(self):
        """(undocumented)"""
        return self.get_resType(0)
    @resType.setter
    def resType(self, value):
        self.set_resType(0,value)

    def get_res(self, i):
        """Get value of ``res`` of ``(<chip.hipResourceDesc*>self._ptr)[i]``.
        """
        return hipResourceDesc_union_0.fromPtr(&(<chip.hipResourceDesc*>self._ptr)[i].res)
    @property
    def res(self):
        """(undocumented)"""
        return self.get_res(0)

    @staticmethod
    def PROPERTIES():
        return ["resType","res"]

    def __contains__(self,item):
        properties = self.PROPERTIES()
        return item in properties

    def __getitem__(self,item):
        properties = self.PROPERTIES()
        if isinstance(item,int):
            if item < 0 or item >= len(properties):
                raise IndexError()
            return getattr(self,properties[item])
        raise ValueError("'item' type must be 'int'")


cdef class HIP_RESOURCE_DESC_st_union_0_struct_0(hip._util.types.Pointer):
    """Python wrapper for cdef class chip.HIP_RESOURCE_DESC_st_union_0_struct_0.

    Python wrapper for cdef class chip.HIP_RESOURCE_DESC_st_union_0_struct_0.

    If this type is initialized via its `__init__` method, it allocates a
    member of the underlying C type and destroys it again if the wrapper
    type is deallocated.

    This type also serves as adapter when appearing as argument type in a
    function signature. In this case, the type can further be initialized
    from a number of Python objects:

    * `None`:

      This will set the ``self._ptr`` attribute to ``NULL``.

    * `int`:

      Interprets the integer value as pointer address and writes it to ``self._ptr``.
      No ownership is transferred.

    * `ctypes.c_void_p`:

      Takes the pointer address ``pyobj.value`` and writes it to ``self._ptr``.
      No ownership is transferred.

    * `object` that implements the `CUDA Array Interface <https://numba.readthedocs.io/en/stable/cuda/cuda_array_interface.html>`_ protocol:

      Takes the integer-valued pointer address, i.e. the first entry of the `data` tuple
      from `pyobj`'s member ``__cuda_array_interface__``  and writes it to ``self._ptr``.

    * `object` that implements the Python buffer protocol:

      If the object represents a simple contiguous array,
      writes the `Py_buffer` associated with ``pyobj`` to `self._py_buffer`,
      sets the `self._py_buffer_acquired` flag to `True`, and
      writes `self._py_buffer.buf` to the data pointer `self._ptr`.

    * `hip._util.types.Pointer`:

      Takes the pointer address ``pyobj._ptr`` and writes it to ``self._ptr``.
      No ownership is transferred.

    Type checks are performed in the above order.

    C Attributes:
        _ptr (C type ``void *``, protected):
            Stores a pointer to the data of the original Python object.
        _is_ptr_owner (C type ``bint``, protected):
            If this wrapper is the owner of the underlying data.
        _py_buffer (C type ``Py_buffer`, protected):
            Stores a pointer to the data of the original Python object.
        _py_buffer_acquired (C type ``bint``, protected):
            Stores a pointer to the data of the original Python object.
    """
    # C members declared in pxd file

    def __cinit__(self):
        self._ptr = NULL
        self._is_ptr_owner = False
        self._py_buffer_acquired = False

    cdef chip.HIP_RESOURCE_DESC_st_union_0_struct_0* getElementPtr(self):
        return <chip.HIP_RESOURCE_DESC_st_union_0_struct_0*>self._ptr

    @staticmethod
    cdef HIP_RESOURCE_DESC_st_union_0_struct_0 fromPtr(void* ptr, bint owner=False):
        """Factory function to create ``HIP_RESOURCE_DESC_st_union_0_struct_0`` objects from
        given ``chip.HIP_RESOURCE_DESC_st_union_0_struct_0`` pointer.

        Setting ``owner`` flag to ``True`` causes
        the extension type to free the structure pointed to by ``ptr``
        when the wrapper object is deallocated.
        """
        # Fast call to __new__() that bypasses the __init__() constructor.
        cdef HIP_RESOURCE_DESC_st_union_0_struct_0 wrapper = HIP_RESOURCE_DESC_st_union_0_struct_0.__new__(HIP_RESOURCE_DESC_st_union_0_struct_0)
        wrapper._ptr = ptr
        wrapper._is_ptr_owner = owner
        return wrapper

    @staticmethod
    def fromObj(pyobj):
        """Creates a HIP_RESOURCE_DESC_st_union_0_struct_0 from a Python object.

        Derives a HIP_RESOURCE_DESC_st_union_0_struct_0 from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``HIP_RESOURCE_DESC_st_union_0_struct_0`` reference, this method
        returns it directly. No new ``HIP_RESOURCE_DESC_st_union_0_struct_0`` is created in this case.
        """
        return HIP_RESOURCE_DESC_st_union_0_struct_0.fromPyobj(pyobj)

    @staticmethod
    cdef HIP_RESOURCE_DESC_st_union_0_struct_0 fromPyobj(object pyobj):
        """Creates a HIP_RESOURCE_DESC_st_union_0_struct_0 from a Python object.

        Derives a HIP_RESOURCE_DESC_st_union_0_struct_0 from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``HIP_RESOURCE_DESC_st_union_0_struct_0`` reference, this method
        returns it directly. No new ``HIP_RESOURCE_DESC_st_union_0_struct_0`` is created in this case.

        Args:
            pyobj (object): Must be either `None`; a `hip._util.types.Pointer`; a simple, contiguous buffer according to the buffer protocol;
                            or of type `HIP_RESOURCE_DESC_st_union_0_struct_0`; `int`; or `ctypes.c_void_p`.

        Note:
            This routine does not perform a copy but returns the original ``pyobj``
            if ``pyobj`` is an instance of HIP_RESOURCE_DESC_st_union_0_struct_0!
        """
        cdef HIP_RESOURCE_DESC_st_union_0_struct_0 wrapper

        if isinstance(pyobj,HIP_RESOURCE_DESC_st_union_0_struct_0):
            return pyobj
        else:
            wrapper = HIP_RESOURCE_DESC_st_union_0_struct_0.__new__(HIP_RESOURCE_DESC_st_union_0_struct_0)
            wrapper.init_from_pyobj(pyobj)
            return wrapper

    def __dealloc__(self):
        # Release the buffer handle
        if self._py_buffer_acquired is True:
            cpython.buffer.PyBuffer_Release(&self._py_buffer)
        # De-allocate if not null and flag is set
        if self._ptr is not NULL and self._is_ptr_owner is True:
            stdlib.free(self._ptr)
            self._ptr = NULL

    @staticmethod
    cdef __allocate(void** ptr):
        ptr[0] = stdlib.malloc(sizeof(chip.HIP_RESOURCE_DESC_st_union_0_struct_0))
        string.memset(<void*>ptr[0], 0, sizeof(chip.HIP_RESOURCE_DESC_st_union_0_struct_0))

        if ptr[0] is NULL:
            raise MemoryError

    @staticmethod
    cdef HIP_RESOURCE_DESC_st_union_0_struct_0 new():
        """Factory function to create HIP_RESOURCE_DESC_st_union_0_struct_0 objects with
        newly allocated chip.HIP_RESOURCE_DESC_st_union_0_struct_0"""
        cdef void* ptr
        HIP_RESOURCE_DESC_st_union_0_struct_0.__allocate(&ptr)
        return HIP_RESOURCE_DESC_st_union_0_struct_0.fromPtr(ptr, owner=True)

    @staticmethod
    cdef HIP_RESOURCE_DESC_st_union_0_struct_0 fromValue(chip.HIP_RESOURCE_DESC_st_union_0_struct_0 other):
        """Allocate new C type and copy from ``other``.
        """
        wrapper = HIP_RESOURCE_DESC_st_union_0_struct_0.new()
        string.memcpy(wrapper._ptr, &other, sizeof(chip.HIP_RESOURCE_DESC_st_union_0_struct_0))
        return wrapper

    def c_sizeof(self):
        """Returns the size of the underlying C type in bytes.
        Note:
            Implemented as function to not collide with
            autogenerated property names.
        """
        return sizeof(chip.HIP_RESOURCE_DESC_st_union_0_struct_0)

    def __int__(self):
        """Returns the data's address as long integer.
        """
        return cpython.long.PyLong_FromVoidPtr(self._ptr)

    def __repr__(self):
        return f"<HIP_RESOURCE_DESC_st_union_0_struct_0 object, ptr: {int(self)}>"

    def as_c_void_p(self):
        """Returns the data's address as `ctypes.c_void_p`
        Note:
            Implemented as function to not collide with
            autogenerated property names.
        """
        return ctypes.c_void_p(int(self))

    def __init__(self,**kwargs):
        """Constructor type HIP_RESOURCE_DESC_st_union_0_struct_0.

        Constructor for type HIP_RESOURCE_DESC_st_union_0_struct_0.

        Args:
            **kwargs:
                Can be used to initialize member variables at construction,
                Just pass an argument expression of the form <member>=<value>
                per member that you want to initialize.
        """
        HIP_RESOURCE_DESC_st_union_0_struct_0.__allocate(&self._ptr)
        self._is_ptr_owner = True
        attribs = self.PROPERTIES()
        used_attribs = set()
        valid_names = ", ".join(["'"+p+"'" for p in attribs])
        for k,v in kwargs.items():
            if k in used_attribs:
                raise KeyError(f"argument '{k}' has already been specified as positional argument.")
            elif k not in attribs:
                raise KeyError(f"'{k}' is no valid property name. Valid names: {valid_names}")
            setattr(self,k,v)
    @staticmethod
    def PROPERTIES():
        return []

    def __contains__(self,item):
        properties = self.PROPERTIES()
        return item in properties

    def __getitem__(self,item):
        properties = self.PROPERTIES()
        if isinstance(item,int):
            if item < 0 or item >= len(properties):
                raise IndexError()
            return getattr(self,properties[item])
        raise ValueError("'item' type must be 'int'")


cdef class HIP_RESOURCE_DESC_st_union_0_struct_1(hip._util.types.Pointer):
    """Python wrapper for cdef class chip.HIP_RESOURCE_DESC_st_union_0_struct_1.

    Python wrapper for cdef class chip.HIP_RESOURCE_DESC_st_union_0_struct_1.

    If this type is initialized via its `__init__` method, it allocates a
    member of the underlying C type and destroys it again if the wrapper
    type is deallocated.

    This type also serves as adapter when appearing as argument type in a
    function signature. In this case, the type can further be initialized
    from a number of Python objects:

    * `None`:

      This will set the ``self._ptr`` attribute to ``NULL``.

    * `int`:

      Interprets the integer value as pointer address and writes it to ``self._ptr``.
      No ownership is transferred.

    * `ctypes.c_void_p`:

      Takes the pointer address ``pyobj.value`` and writes it to ``self._ptr``.
      No ownership is transferred.

    * `object` that implements the `CUDA Array Interface <https://numba.readthedocs.io/en/stable/cuda/cuda_array_interface.html>`_ protocol:

      Takes the integer-valued pointer address, i.e. the first entry of the `data` tuple
      from `pyobj`'s member ``__cuda_array_interface__``  and writes it to ``self._ptr``.

    * `object` that implements the Python buffer protocol:

      If the object represents a simple contiguous array,
      writes the `Py_buffer` associated with ``pyobj`` to `self._py_buffer`,
      sets the `self._py_buffer_acquired` flag to `True`, and
      writes `self._py_buffer.buf` to the data pointer `self._ptr`.

    * `hip._util.types.Pointer`:

      Takes the pointer address ``pyobj._ptr`` and writes it to ``self._ptr``.
      No ownership is transferred.

    Type checks are performed in the above order.

    C Attributes:
        _ptr (C type ``void *``, protected):
            Stores a pointer to the data of the original Python object.
        _is_ptr_owner (C type ``bint``, protected):
            If this wrapper is the owner of the underlying data.
        _py_buffer (C type ``Py_buffer`, protected):
            Stores a pointer to the data of the original Python object.
        _py_buffer_acquired (C type ``bint``, protected):
            Stores a pointer to the data of the original Python object.
    """
    # C members declared in pxd file

    def __cinit__(self):
        self._ptr = NULL
        self._is_ptr_owner = False
        self._py_buffer_acquired = False

    cdef chip.HIP_RESOURCE_DESC_st_union_0_struct_1* getElementPtr(self):
        return <chip.HIP_RESOURCE_DESC_st_union_0_struct_1*>self._ptr

    @staticmethod
    cdef HIP_RESOURCE_DESC_st_union_0_struct_1 fromPtr(void* ptr, bint owner=False):
        """Factory function to create ``HIP_RESOURCE_DESC_st_union_0_struct_1`` objects from
        given ``chip.HIP_RESOURCE_DESC_st_union_0_struct_1`` pointer.

        Setting ``owner`` flag to ``True`` causes
        the extension type to free the structure pointed to by ``ptr``
        when the wrapper object is deallocated.
        """
        # Fast call to __new__() that bypasses the __init__() constructor.
        cdef HIP_RESOURCE_DESC_st_union_0_struct_1 wrapper = HIP_RESOURCE_DESC_st_union_0_struct_1.__new__(HIP_RESOURCE_DESC_st_union_0_struct_1)
        wrapper._ptr = ptr
        wrapper._is_ptr_owner = owner
        return wrapper

    @staticmethod
    def fromObj(pyobj):
        """Creates a HIP_RESOURCE_DESC_st_union_0_struct_1 from a Python object.

        Derives a HIP_RESOURCE_DESC_st_union_0_struct_1 from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``HIP_RESOURCE_DESC_st_union_0_struct_1`` reference, this method
        returns it directly. No new ``HIP_RESOURCE_DESC_st_union_0_struct_1`` is created in this case.
        """
        return HIP_RESOURCE_DESC_st_union_0_struct_1.fromPyobj(pyobj)

    @staticmethod
    cdef HIP_RESOURCE_DESC_st_union_0_struct_1 fromPyobj(object pyobj):
        """Creates a HIP_RESOURCE_DESC_st_union_0_struct_1 from a Python object.

        Derives a HIP_RESOURCE_DESC_st_union_0_struct_1 from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``HIP_RESOURCE_DESC_st_union_0_struct_1`` reference, this method
        returns it directly. No new ``HIP_RESOURCE_DESC_st_union_0_struct_1`` is created in this case.

        Args:
            pyobj (object): Must be either `None`; a `hip._util.types.Pointer`; a simple, contiguous buffer according to the buffer protocol;
                            or of type `HIP_RESOURCE_DESC_st_union_0_struct_1`; `int`; or `ctypes.c_void_p`.

        Note:
            This routine does not perform a copy but returns the original ``pyobj``
            if ``pyobj`` is an instance of HIP_RESOURCE_DESC_st_union_0_struct_1!
        """
        cdef HIP_RESOURCE_DESC_st_union_0_struct_1 wrapper

        if isinstance(pyobj,HIP_RESOURCE_DESC_st_union_0_struct_1):
            return pyobj
        else:
            wrapper = HIP_RESOURCE_DESC_st_union_0_struct_1.__new__(HIP_RESOURCE_DESC_st_union_0_struct_1)
            wrapper.init_from_pyobj(pyobj)
            return wrapper

    def __dealloc__(self):
        # Release the buffer handle
        if self._py_buffer_acquired is True:
            cpython.buffer.PyBuffer_Release(&self._py_buffer)
        # De-allocate if not null and flag is set
        if self._ptr is not NULL and self._is_ptr_owner is True:
            stdlib.free(self._ptr)
            self._ptr = NULL

    @staticmethod
    cdef __allocate(void** ptr):
        ptr[0] = stdlib.malloc(sizeof(chip.HIP_RESOURCE_DESC_st_union_0_struct_1))
        string.memset(<void*>ptr[0], 0, sizeof(chip.HIP_RESOURCE_DESC_st_union_0_struct_1))

        if ptr[0] is NULL:
            raise MemoryError

    @staticmethod
    cdef HIP_RESOURCE_DESC_st_union_0_struct_1 new():
        """Factory function to create HIP_RESOURCE_DESC_st_union_0_struct_1 objects with
        newly allocated chip.HIP_RESOURCE_DESC_st_union_0_struct_1"""
        cdef void* ptr
        HIP_RESOURCE_DESC_st_union_0_struct_1.__allocate(&ptr)
        return HIP_RESOURCE_DESC_st_union_0_struct_1.fromPtr(ptr, owner=True)

    @staticmethod
    cdef HIP_RESOURCE_DESC_st_union_0_struct_1 fromValue(chip.HIP_RESOURCE_DESC_st_union_0_struct_1 other):
        """Allocate new C type and copy from ``other``.
        """
        wrapper = HIP_RESOURCE_DESC_st_union_0_struct_1.new()
        string.memcpy(wrapper._ptr, &other, sizeof(chip.HIP_RESOURCE_DESC_st_union_0_struct_1))
        return wrapper

    def c_sizeof(self):
        """Returns the size of the underlying C type in bytes.
        Note:
            Implemented as function to not collide with
            autogenerated property names.
        """
        return sizeof(chip.HIP_RESOURCE_DESC_st_union_0_struct_1)

    def __int__(self):
        """Returns the data's address as long integer.
        """
        return cpython.long.PyLong_FromVoidPtr(self._ptr)

    def __repr__(self):
        return f"<HIP_RESOURCE_DESC_st_union_0_struct_1 object, ptr: {int(self)}>"

    def as_c_void_p(self):
        """Returns the data's address as `ctypes.c_void_p`
        Note:
            Implemented as function to not collide with
            autogenerated property names.
        """
        return ctypes.c_void_p(int(self))

    def __init__(self,**kwargs):
        """Constructor type HIP_RESOURCE_DESC_st_union_0_struct_1.

        Constructor for type HIP_RESOURCE_DESC_st_union_0_struct_1.

        Args:
            **kwargs:
                Can be used to initialize member variables at construction,
                Just pass an argument expression of the form <member>=<value>
                per member that you want to initialize.
        """
        HIP_RESOURCE_DESC_st_union_0_struct_1.__allocate(&self._ptr)
        self._is_ptr_owner = True
        attribs = self.PROPERTIES()
        used_attribs = set()
        valid_names = ", ".join(["'"+p+"'" for p in attribs])
        for k,v in kwargs.items():
            if k in used_attribs:
                raise KeyError(f"argument '{k}' has already been specified as positional argument.")
            elif k not in attribs:
                raise KeyError(f"'{k}' is no valid property name. Valid names: {valid_names}")
            setattr(self,k,v)
    @staticmethod
    def PROPERTIES():
        return []

    def __contains__(self,item):
        properties = self.PROPERTIES()
        return item in properties

    def __getitem__(self,item):
        properties = self.PROPERTIES()
        if isinstance(item,int):
            if item < 0 or item >= len(properties):
                raise IndexError()
            return getattr(self,properties[item])
        raise ValueError("'item' type must be 'int'")


cdef class HIP_RESOURCE_DESC_st_union_0_struct_2(hip._util.types.Pointer):
    """Python wrapper for cdef class chip.HIP_RESOURCE_DESC_st_union_0_struct_2.

    Python wrapper for cdef class chip.HIP_RESOURCE_DESC_st_union_0_struct_2.

    If this type is initialized via its `__init__` method, it allocates a
    member of the underlying C type and destroys it again if the wrapper
    type is deallocated.

    This type also serves as adapter when appearing as argument type in a
    function signature. In this case, the type can further be initialized
    from a number of Python objects:

    * `None`:

      This will set the ``self._ptr`` attribute to ``NULL``.

    * `int`:

      Interprets the integer value as pointer address and writes it to ``self._ptr``.
      No ownership is transferred.

    * `ctypes.c_void_p`:

      Takes the pointer address ``pyobj.value`` and writes it to ``self._ptr``.
      No ownership is transferred.

    * `object` that implements the `CUDA Array Interface <https://numba.readthedocs.io/en/stable/cuda/cuda_array_interface.html>`_ protocol:

      Takes the integer-valued pointer address, i.e. the first entry of the `data` tuple
      from `pyobj`'s member ``__cuda_array_interface__``  and writes it to ``self._ptr``.

    * `object` that implements the Python buffer protocol:

      If the object represents a simple contiguous array,
      writes the `Py_buffer` associated with ``pyobj`` to `self._py_buffer`,
      sets the `self._py_buffer_acquired` flag to `True`, and
      writes `self._py_buffer.buf` to the data pointer `self._ptr`.

    * `hip._util.types.Pointer`:

      Takes the pointer address ``pyobj._ptr`` and writes it to ``self._ptr``.
      No ownership is transferred.

    Type checks are performed in the above order.

    C Attributes:
        _ptr (C type ``void *``, protected):
            Stores a pointer to the data of the original Python object.
        _is_ptr_owner (C type ``bint``, protected):
            If this wrapper is the owner of the underlying data.
        _py_buffer (C type ``Py_buffer`, protected):
            Stores a pointer to the data of the original Python object.
        _py_buffer_acquired (C type ``bint``, protected):
            Stores a pointer to the data of the original Python object.
    """
    # C members declared in pxd file

    def __cinit__(self):
        self._ptr = NULL
        self._is_ptr_owner = False
        self._py_buffer_acquired = False

    cdef chip.HIP_RESOURCE_DESC_st_union_0_struct_2* getElementPtr(self):
        return <chip.HIP_RESOURCE_DESC_st_union_0_struct_2*>self._ptr

    @staticmethod
    cdef HIP_RESOURCE_DESC_st_union_0_struct_2 fromPtr(void* ptr, bint owner=False):
        """Factory function to create ``HIP_RESOURCE_DESC_st_union_0_struct_2`` objects from
        given ``chip.HIP_RESOURCE_DESC_st_union_0_struct_2`` pointer.

        Setting ``owner`` flag to ``True`` causes
        the extension type to free the structure pointed to by ``ptr``
        when the wrapper object is deallocated.
        """
        # Fast call to __new__() that bypasses the __init__() constructor.
        cdef HIP_RESOURCE_DESC_st_union_0_struct_2 wrapper = HIP_RESOURCE_DESC_st_union_0_struct_2.__new__(HIP_RESOURCE_DESC_st_union_0_struct_2)
        wrapper._ptr = ptr
        wrapper._is_ptr_owner = owner
        return wrapper

    @staticmethod
    def fromObj(pyobj):
        """Creates a HIP_RESOURCE_DESC_st_union_0_struct_2 from a Python object.

        Derives a HIP_RESOURCE_DESC_st_union_0_struct_2 from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``HIP_RESOURCE_DESC_st_union_0_struct_2`` reference, this method
        returns it directly. No new ``HIP_RESOURCE_DESC_st_union_0_struct_2`` is created in this case.
        """
        return HIP_RESOURCE_DESC_st_union_0_struct_2.fromPyobj(pyobj)

    @staticmethod
    cdef HIP_RESOURCE_DESC_st_union_0_struct_2 fromPyobj(object pyobj):
        """Creates a HIP_RESOURCE_DESC_st_union_0_struct_2 from a Python object.

        Derives a HIP_RESOURCE_DESC_st_union_0_struct_2 from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``HIP_RESOURCE_DESC_st_union_0_struct_2`` reference, this method
        returns it directly. No new ``HIP_RESOURCE_DESC_st_union_0_struct_2`` is created in this case.

        Args:
            pyobj (object): Must be either `None`; a `hip._util.types.Pointer`; a simple, contiguous buffer according to the buffer protocol;
                            or of type `HIP_RESOURCE_DESC_st_union_0_struct_2`; `int`; or `ctypes.c_void_p`.

        Note:
            This routine does not perform a copy but returns the original ``pyobj``
            if ``pyobj`` is an instance of HIP_RESOURCE_DESC_st_union_0_struct_2!
        """
        cdef HIP_RESOURCE_DESC_st_union_0_struct_2 wrapper

        if isinstance(pyobj,HIP_RESOURCE_DESC_st_union_0_struct_2):
            return pyobj
        else:
            wrapper = HIP_RESOURCE_DESC_st_union_0_struct_2.__new__(HIP_RESOURCE_DESC_st_union_0_struct_2)
            wrapper.init_from_pyobj(pyobj)
            return wrapper

    def __dealloc__(self):
        # Release the buffer handle
        if self._py_buffer_acquired is True:
            cpython.buffer.PyBuffer_Release(&self._py_buffer)
        # De-allocate if not null and flag is set
        if self._ptr is not NULL and self._is_ptr_owner is True:
            stdlib.free(self._ptr)
            self._ptr = NULL

    @staticmethod
    cdef __allocate(void** ptr):
        ptr[0] = stdlib.malloc(sizeof(chip.HIP_RESOURCE_DESC_st_union_0_struct_2))
        string.memset(<void*>ptr[0], 0, sizeof(chip.HIP_RESOURCE_DESC_st_union_0_struct_2))

        if ptr[0] is NULL:
            raise MemoryError

    @staticmethod
    cdef HIP_RESOURCE_DESC_st_union_0_struct_2 new():
        """Factory function to create HIP_RESOURCE_DESC_st_union_0_struct_2 objects with
        newly allocated chip.HIP_RESOURCE_DESC_st_union_0_struct_2"""
        cdef void* ptr
        HIP_RESOURCE_DESC_st_union_0_struct_2.__allocate(&ptr)
        return HIP_RESOURCE_DESC_st_union_0_struct_2.fromPtr(ptr, owner=True)

    @staticmethod
    cdef HIP_RESOURCE_DESC_st_union_0_struct_2 fromValue(chip.HIP_RESOURCE_DESC_st_union_0_struct_2 other):
        """Allocate new C type and copy from ``other``.
        """
        wrapper = HIP_RESOURCE_DESC_st_union_0_struct_2.new()
        string.memcpy(wrapper._ptr, &other, sizeof(chip.HIP_RESOURCE_DESC_st_union_0_struct_2))
        return wrapper

    def c_sizeof(self):
        """Returns the size of the underlying C type in bytes.
        Note:
            Implemented as function to not collide with
            autogenerated property names.
        """
        return sizeof(chip.HIP_RESOURCE_DESC_st_union_0_struct_2)

    def __int__(self):
        """Returns the data's address as long integer.
        """
        return cpython.long.PyLong_FromVoidPtr(self._ptr)

    def __repr__(self):
        return f"<HIP_RESOURCE_DESC_st_union_0_struct_2 object, ptr: {int(self)}>"

    def as_c_void_p(self):
        """Returns the data's address as `ctypes.c_void_p`
        Note:
            Implemented as function to not collide with
            autogenerated property names.
        """
        return ctypes.c_void_p(int(self))

    def __init__(self,*args,**kwargs):
        """Constructor type HIP_RESOURCE_DESC_st_union_0_struct_2.

        Constructor for type HIP_RESOURCE_DESC_st_union_0_struct_2.

        Args:
            *args:
                Positional arguments. Initialize all or a subset of the member variables
                according to their order of declaration.
            **kwargs:
                Can be used to initialize member variables at construction,
                Just pass an argument expression of the form <member>=<value>
                per member that you want to initialize.
        """
        HIP_RESOURCE_DESC_st_union_0_struct_2.__allocate(&self._ptr)
        self._is_ptr_owner = True
        attribs = self.PROPERTIES()
        used_attribs = set()
        if len(args) > len(attribs):
            raise ValueError("More positional arguments specified than this type has properties.")
        for i,v in enumerate(args):
            setattr(self,attribs[i],v)
            used_attribs.add(attribs[i])
        valid_names = ", ".join(["'"+p+"'" for p in attribs])
        for k,v in kwargs.items():
            if k in used_attribs:
                raise KeyError(f"argument '{k}' has already been specified as positional argument.")
            elif k not in attribs:
                raise KeyError(f"'{k}' is no valid property name. Valid names: {valid_names}")
            setattr(self,k,v)
    def get_devPtr(self, i):
        """Get value ``devPtr`` of ``(<chip.HIP_RESOURCE_DESC_st_union_0_struct_2*>self._ptr)[i]``.
        """
        return hip._util.types.Pointer.fromPtr((<chip.HIP_RESOURCE_DESC_st_union_0_struct_2*>self._ptr)[i].devPtr)
    def set_devPtr(self, i, object value):
        """Set value ``devPtr`` of ``(<chip.HIP_RESOURCE_DESC_st_union_0_struct_2*>self._ptr)[i]``.

        Note:
            This can be dangerous if the pointer is from a python object
            that is later on garbage collected.
        """
        (<chip.HIP_RESOURCE_DESC_st_union_0_struct_2*>self._ptr)[i].devPtr = <void *>cpython.long.PyLong_AsVoidPtr(int(hip._util.types.Pointer.fromPyobj(value)))
    @property
    def devPtr(self):
        """Device pointer
        Note:
            Setting this devPtr can be dangerous if the underlying pointer is from a python object that
            is later on garbage collected.
        """
        return self.get_devPtr(0)
    @devPtr.setter
    def devPtr(self, object value):
        self.set_devPtr(0,value)

    def get_format(self, i):
        """Get value of ``format`` of ``(<chip.HIP_RESOURCE_DESC_st_union_0_struct_2*>self._ptr)[i]``.
        """
        return hipArray_Format((<chip.HIP_RESOURCE_DESC_st_union_0_struct_2*>self._ptr)[i].format)
    def set_format(self, i, value):
        """Set value ``format`` of ``(<chip.HIP_RESOURCE_DESC_st_union_0_struct_2*>self._ptr)[i]``.
        """
        if not isinstance(value, hipArray_Format):
            raise TypeError("'value' must be of type 'hipArray_Format'")
        (<chip.HIP_RESOURCE_DESC_st_union_0_struct_2*>self._ptr)[i].format = value.value
    @property
    def format(self):
        """Array format"""
        return self.get_format(0)
    @format.setter
    def format(self, value):
        self.set_format(0,value)

    def get_numChannels(self, i):
        """Get value ``numChannels`` of ``(<chip.HIP_RESOURCE_DESC_st_union_0_struct_2*>self._ptr)[i]``.
        """
        return (<chip.HIP_RESOURCE_DESC_st_union_0_struct_2*>self._ptr)[i].numChannels
    def set_numChannels(self, i, unsigned int value):
        """Set value ``numChannels`` of ``(<chip.HIP_RESOURCE_DESC_st_union_0_struct_2*>self._ptr)[i]``.
        """
        (<chip.HIP_RESOURCE_DESC_st_union_0_struct_2*>self._ptr)[i].numChannels = value
    @property
    def numChannels(self):
        """Channels per array element"""
        return self.get_numChannels(0)
    @numChannels.setter
    def numChannels(self, unsigned int value):
        self.set_numChannels(0,value)

    def get_sizeInBytes(self, i):
        """Get value ``sizeInBytes`` of ``(<chip.HIP_RESOURCE_DESC_st_union_0_struct_2*>self._ptr)[i]``.
        """
        return (<chip.HIP_RESOURCE_DESC_st_union_0_struct_2*>self._ptr)[i].sizeInBytes
    def set_sizeInBytes(self, i, unsigned long value):
        """Set value ``sizeInBytes`` of ``(<chip.HIP_RESOURCE_DESC_st_union_0_struct_2*>self._ptr)[i]``.
        """
        (<chip.HIP_RESOURCE_DESC_st_union_0_struct_2*>self._ptr)[i].sizeInBytes = value
    @property
    def sizeInBytes(self):
        """Size in bytes"""
        return self.get_sizeInBytes(0)
    @sizeInBytes.setter
    def sizeInBytes(self, unsigned long value):
        self.set_sizeInBytes(0,value)

    @staticmethod
    def PROPERTIES():
        return ["devPtr","format","numChannels","sizeInBytes"]

    def __contains__(self,item):
        properties = self.PROPERTIES()
        return item in properties

    def __getitem__(self,item):
        properties = self.PROPERTIES()
        if isinstance(item,int):
            if item < 0 or item >= len(properties):
                raise IndexError()
            return getattr(self,properties[item])
        raise ValueError("'item' type must be 'int'")


cdef class HIP_RESOURCE_DESC_st_union_0_struct_3(hip._util.types.Pointer):
    """Python wrapper for cdef class chip.HIP_RESOURCE_DESC_st_union_0_struct_3.

    Python wrapper for cdef class chip.HIP_RESOURCE_DESC_st_union_0_struct_3.

    If this type is initialized via its `__init__` method, it allocates a
    member of the underlying C type and destroys it again if the wrapper
    type is deallocated.

    This type also serves as adapter when appearing as argument type in a
    function signature. In this case, the type can further be initialized
    from a number of Python objects:

    * `None`:

      This will set the ``self._ptr`` attribute to ``NULL``.

    * `int`:

      Interprets the integer value as pointer address and writes it to ``self._ptr``.
      No ownership is transferred.

    * `ctypes.c_void_p`:

      Takes the pointer address ``pyobj.value`` and writes it to ``self._ptr``.
      No ownership is transferred.

    * `object` that implements the `CUDA Array Interface <https://numba.readthedocs.io/en/stable/cuda/cuda_array_interface.html>`_ protocol:

      Takes the integer-valued pointer address, i.e. the first entry of the `data` tuple
      from `pyobj`'s member ``__cuda_array_interface__``  and writes it to ``self._ptr``.

    * `object` that implements the Python buffer protocol:

      If the object represents a simple contiguous array,
      writes the `Py_buffer` associated with ``pyobj`` to `self._py_buffer`,
      sets the `self._py_buffer_acquired` flag to `True`, and
      writes `self._py_buffer.buf` to the data pointer `self._ptr`.

    * `hip._util.types.Pointer`:

      Takes the pointer address ``pyobj._ptr`` and writes it to ``self._ptr``.
      No ownership is transferred.

    Type checks are performed in the above order.

    C Attributes:
        _ptr (C type ``void *``, protected):
            Stores a pointer to the data of the original Python object.
        _is_ptr_owner (C type ``bint``, protected):
            If this wrapper is the owner of the underlying data.
        _py_buffer (C type ``Py_buffer`, protected):
            Stores a pointer to the data of the original Python object.
        _py_buffer_acquired (C type ``bint``, protected):
            Stores a pointer to the data of the original Python object.
    """
    # C members declared in pxd file

    def __cinit__(self):
        self._ptr = NULL
        self._is_ptr_owner = False
        self._py_buffer_acquired = False

    cdef chip.HIP_RESOURCE_DESC_st_union_0_struct_3* getElementPtr(self):
        return <chip.HIP_RESOURCE_DESC_st_union_0_struct_3*>self._ptr

    @staticmethod
    cdef HIP_RESOURCE_DESC_st_union_0_struct_3 fromPtr(void* ptr, bint owner=False):
        """Factory function to create ``HIP_RESOURCE_DESC_st_union_0_struct_3`` objects from
        given ``chip.HIP_RESOURCE_DESC_st_union_0_struct_3`` pointer.

        Setting ``owner`` flag to ``True`` causes
        the extension type to free the structure pointed to by ``ptr``
        when the wrapper object is deallocated.
        """
        # Fast call to __new__() that bypasses the __init__() constructor.
        cdef HIP_RESOURCE_DESC_st_union_0_struct_3 wrapper = HIP_RESOURCE_DESC_st_union_0_struct_3.__new__(HIP_RESOURCE_DESC_st_union_0_struct_3)
        wrapper._ptr = ptr
        wrapper._is_ptr_owner = owner
        return wrapper

    @staticmethod
    def fromObj(pyobj):
        """Creates a HIP_RESOURCE_DESC_st_union_0_struct_3 from a Python object.

        Derives a HIP_RESOURCE_DESC_st_union_0_struct_3 from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``HIP_RESOURCE_DESC_st_union_0_struct_3`` reference, this method
        returns it directly. No new ``HIP_RESOURCE_DESC_st_union_0_struct_3`` is created in this case.
        """
        return HIP_RESOURCE_DESC_st_union_0_struct_3.fromPyobj(pyobj)

    @staticmethod
    cdef HIP_RESOURCE_DESC_st_union_0_struct_3 fromPyobj(object pyobj):
        """Creates a HIP_RESOURCE_DESC_st_union_0_struct_3 from a Python object.

        Derives a HIP_RESOURCE_DESC_st_union_0_struct_3 from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``HIP_RESOURCE_DESC_st_union_0_struct_3`` reference, this method
        returns it directly. No new ``HIP_RESOURCE_DESC_st_union_0_struct_3`` is created in this case.

        Args:
            pyobj (object): Must be either `None`; a `hip._util.types.Pointer`; a simple, contiguous buffer according to the buffer protocol;
                            or of type `HIP_RESOURCE_DESC_st_union_0_struct_3`; `int`; or `ctypes.c_void_p`.

        Note:
            This routine does not perform a copy but returns the original ``pyobj``
            if ``pyobj`` is an instance of HIP_RESOURCE_DESC_st_union_0_struct_3!
        """
        cdef HIP_RESOURCE_DESC_st_union_0_struct_3 wrapper

        if isinstance(pyobj,HIP_RESOURCE_DESC_st_union_0_struct_3):
            return pyobj
        else:
            wrapper = HIP_RESOURCE_DESC_st_union_0_struct_3.__new__(HIP_RESOURCE_DESC_st_union_0_struct_3)
            wrapper.init_from_pyobj(pyobj)
            return wrapper

    def __dealloc__(self):
        # Release the buffer handle
        if self._py_buffer_acquired is True:
            cpython.buffer.PyBuffer_Release(&self._py_buffer)
        # De-allocate if not null and flag is set
        if self._ptr is not NULL and self._is_ptr_owner is True:
            stdlib.free(self._ptr)
            self._ptr = NULL

    @staticmethod
    cdef __allocate(void** ptr):
        ptr[0] = stdlib.malloc(sizeof(chip.HIP_RESOURCE_DESC_st_union_0_struct_3))
        string.memset(<void*>ptr[0], 0, sizeof(chip.HIP_RESOURCE_DESC_st_union_0_struct_3))

        if ptr[0] is NULL:
            raise MemoryError

    @staticmethod
    cdef HIP_RESOURCE_DESC_st_union_0_struct_3 new():
        """Factory function to create HIP_RESOURCE_DESC_st_union_0_struct_3 objects with
        newly allocated chip.HIP_RESOURCE_DESC_st_union_0_struct_3"""
        cdef void* ptr
        HIP_RESOURCE_DESC_st_union_0_struct_3.__allocate(&ptr)
        return HIP_RESOURCE_DESC_st_union_0_struct_3.fromPtr(ptr, owner=True)

    @staticmethod
    cdef HIP_RESOURCE_DESC_st_union_0_struct_3 fromValue(chip.HIP_RESOURCE_DESC_st_union_0_struct_3 other):
        """Allocate new C type and copy from ``other``.
        """
        wrapper = HIP_RESOURCE_DESC_st_union_0_struct_3.new()
        string.memcpy(wrapper._ptr, &other, sizeof(chip.HIP_RESOURCE_DESC_st_union_0_struct_3))
        return wrapper

    def c_sizeof(self):
        """Returns the size of the underlying C type in bytes.
        Note:
            Implemented as function to not collide with
            autogenerated property names.
        """
        return sizeof(chip.HIP_RESOURCE_DESC_st_union_0_struct_3)

    def __int__(self):
        """Returns the data's address as long integer.
        """
        return cpython.long.PyLong_FromVoidPtr(self._ptr)

    def __repr__(self):
        return f"<HIP_RESOURCE_DESC_st_union_0_struct_3 object, ptr: {int(self)}>"

    def as_c_void_p(self):
        """Returns the data's address as `ctypes.c_void_p`
        Note:
            Implemented as function to not collide with
            autogenerated property names.
        """
        return ctypes.c_void_p(int(self))

    def __init__(self,*args,**kwargs):
        """Constructor type HIP_RESOURCE_DESC_st_union_0_struct_3.

        Constructor for type HIP_RESOURCE_DESC_st_union_0_struct_3.

        Args:
            *args:
                Positional arguments. Initialize all or a subset of the member variables
                according to their order of declaration.
            **kwargs:
                Can be used to initialize member variables at construction,
                Just pass an argument expression of the form <member>=<value>
                per member that you want to initialize.
        """
        HIP_RESOURCE_DESC_st_union_0_struct_3.__allocate(&self._ptr)
        self._is_ptr_owner = True
        attribs = self.PROPERTIES()
        used_attribs = set()
        if len(args) > len(attribs):
            raise ValueError("More positional arguments specified than this type has properties.")
        for i,v in enumerate(args):
            setattr(self,attribs[i],v)
            used_attribs.add(attribs[i])
        valid_names = ", ".join(["'"+p+"'" for p in attribs])
        for k,v in kwargs.items():
            if k in used_attribs:
                raise KeyError(f"argument '{k}' has already been specified as positional argument.")
            elif k not in attribs:
                raise KeyError(f"'{k}' is no valid property name. Valid names: {valid_names}")
            setattr(self,k,v)
    def get_devPtr(self, i):
        """Get value ``devPtr`` of ``(<chip.HIP_RESOURCE_DESC_st_union_0_struct_3*>self._ptr)[i]``.
        """
        return hip._util.types.Pointer.fromPtr((<chip.HIP_RESOURCE_DESC_st_union_0_struct_3*>self._ptr)[i].devPtr)
    def set_devPtr(self, i, object value):
        """Set value ``devPtr`` of ``(<chip.HIP_RESOURCE_DESC_st_union_0_struct_3*>self._ptr)[i]``.

        Note:
            This can be dangerous if the pointer is from a python object
            that is later on garbage collected.
        """
        (<chip.HIP_RESOURCE_DESC_st_union_0_struct_3*>self._ptr)[i].devPtr = <void *>cpython.long.PyLong_AsVoidPtr(int(hip._util.types.Pointer.fromPyobj(value)))
    @property
    def devPtr(self):
        """Device pointer
        Note:
            Setting this devPtr can be dangerous if the underlying pointer is from a python object that
            is later on garbage collected.
        """
        return self.get_devPtr(0)
    @devPtr.setter
    def devPtr(self, object value):
        self.set_devPtr(0,value)

    def get_format(self, i):
        """Get value of ``format`` of ``(<chip.HIP_RESOURCE_DESC_st_union_0_struct_3*>self._ptr)[i]``.
        """
        return hipArray_Format((<chip.HIP_RESOURCE_DESC_st_union_0_struct_3*>self._ptr)[i].format)
    def set_format(self, i, value):
        """Set value ``format`` of ``(<chip.HIP_RESOURCE_DESC_st_union_0_struct_3*>self._ptr)[i]``.
        """
        if not isinstance(value, hipArray_Format):
            raise TypeError("'value' must be of type 'hipArray_Format'")
        (<chip.HIP_RESOURCE_DESC_st_union_0_struct_3*>self._ptr)[i].format = value.value
    @property
    def format(self):
        """Array format"""
        return self.get_format(0)
    @format.setter
    def format(self, value):
        self.set_format(0,value)

    def get_numChannels(self, i):
        """Get value ``numChannels`` of ``(<chip.HIP_RESOURCE_DESC_st_union_0_struct_3*>self._ptr)[i]``.
        """
        return (<chip.HIP_RESOURCE_DESC_st_union_0_struct_3*>self._ptr)[i].numChannels
    def set_numChannels(self, i, unsigned int value):
        """Set value ``numChannels`` of ``(<chip.HIP_RESOURCE_DESC_st_union_0_struct_3*>self._ptr)[i]``.
        """
        (<chip.HIP_RESOURCE_DESC_st_union_0_struct_3*>self._ptr)[i].numChannels = value
    @property
    def numChannels(self):
        """Channels per array element"""
        return self.get_numChannels(0)
    @numChannels.setter
    def numChannels(self, unsigned int value):
        self.set_numChannels(0,value)

    def get_width(self, i):
        """Get value ``width`` of ``(<chip.HIP_RESOURCE_DESC_st_union_0_struct_3*>self._ptr)[i]``.
        """
        return (<chip.HIP_RESOURCE_DESC_st_union_0_struct_3*>self._ptr)[i].width
    def set_width(self, i, unsigned long value):
        """Set value ``width`` of ``(<chip.HIP_RESOURCE_DESC_st_union_0_struct_3*>self._ptr)[i]``.
        """
        (<chip.HIP_RESOURCE_DESC_st_union_0_struct_3*>self._ptr)[i].width = value
    @property
    def width(self):
        """Width of the array in elements"""
        return self.get_width(0)
    @width.setter
    def width(self, unsigned long value):
        self.set_width(0,value)

    def get_height(self, i):
        """Get value ``height`` of ``(<chip.HIP_RESOURCE_DESC_st_union_0_struct_3*>self._ptr)[i]``.
        """
        return (<chip.HIP_RESOURCE_DESC_st_union_0_struct_3*>self._ptr)[i].height
    def set_height(self, i, unsigned long value):
        """Set value ``height`` of ``(<chip.HIP_RESOURCE_DESC_st_union_0_struct_3*>self._ptr)[i]``.
        """
        (<chip.HIP_RESOURCE_DESC_st_union_0_struct_3*>self._ptr)[i].height = value
    @property
    def height(self):
        """Height of the array in elements"""
        return self.get_height(0)
    @height.setter
    def height(self, unsigned long value):
        self.set_height(0,value)

    def get_pitchInBytes(self, i):
        """Get value ``pitchInBytes`` of ``(<chip.HIP_RESOURCE_DESC_st_union_0_struct_3*>self._ptr)[i]``.
        """
        return (<chip.HIP_RESOURCE_DESC_st_union_0_struct_3*>self._ptr)[i].pitchInBytes
    def set_pitchInBytes(self, i, unsigned long value):
        """Set value ``pitchInBytes`` of ``(<chip.HIP_RESOURCE_DESC_st_union_0_struct_3*>self._ptr)[i]``.
        """
        (<chip.HIP_RESOURCE_DESC_st_union_0_struct_3*>self._ptr)[i].pitchInBytes = value
    @property
    def pitchInBytes(self):
        """Pitch between two rows in bytes"""
        return self.get_pitchInBytes(0)
    @pitchInBytes.setter
    def pitchInBytes(self, unsigned long value):
        self.set_pitchInBytes(0,value)

    @staticmethod
    def PROPERTIES():
        return ["devPtr","format","numChannels","width","height","pitchInBytes"]

    def __contains__(self,item):
        properties = self.PROPERTIES()
        return item in properties

    def __getitem__(self,item):
        properties = self.PROPERTIES()
        if isinstance(item,int):
            if item < 0 or item >= len(properties):
                raise IndexError()
            return getattr(self,properties[item])
        raise ValueError("'item' type must be 'int'")


cdef class HIP_RESOURCE_DESC_st_union_0_struct_4(hip._util.types.Pointer):
    """Python wrapper for cdef class chip.HIP_RESOURCE_DESC_st_union_0_struct_4.

    Python wrapper for cdef class chip.HIP_RESOURCE_DESC_st_union_0_struct_4.

    If this type is initialized via its `__init__` method, it allocates a
    member of the underlying C type and destroys it again if the wrapper
    type is deallocated.

    This type also serves as adapter when appearing as argument type in a
    function signature. In this case, the type can further be initialized
    from a number of Python objects:

    * `None`:

      This will set the ``self._ptr`` attribute to ``NULL``.

    * `int`:

      Interprets the integer value as pointer address and writes it to ``self._ptr``.
      No ownership is transferred.

    * `ctypes.c_void_p`:

      Takes the pointer address ``pyobj.value`` and writes it to ``self._ptr``.
      No ownership is transferred.

    * `object` that implements the `CUDA Array Interface <https://numba.readthedocs.io/en/stable/cuda/cuda_array_interface.html>`_ protocol:

      Takes the integer-valued pointer address, i.e. the first entry of the `data` tuple
      from `pyobj`'s member ``__cuda_array_interface__``  and writes it to ``self._ptr``.

    * `object` that implements the Python buffer protocol:

      If the object represents a simple contiguous array,
      writes the `Py_buffer` associated with ``pyobj`` to `self._py_buffer`,
      sets the `self._py_buffer_acquired` flag to `True`, and
      writes `self._py_buffer.buf` to the data pointer `self._ptr`.

    * `hip._util.types.Pointer`:

      Takes the pointer address ``pyobj._ptr`` and writes it to ``self._ptr``.
      No ownership is transferred.

    Type checks are performed in the above order.

    C Attributes:
        _ptr (C type ``void *``, protected):
            Stores a pointer to the data of the original Python object.
        _is_ptr_owner (C type ``bint``, protected):
            If this wrapper is the owner of the underlying data.
        _py_buffer (C type ``Py_buffer`, protected):
            Stores a pointer to the data of the original Python object.
        _py_buffer_acquired (C type ``bint``, protected):
            Stores a pointer to the data of the original Python object.
    """
    # C members declared in pxd file

    def __cinit__(self):
        self._ptr = NULL
        self._is_ptr_owner = False
        self._py_buffer_acquired = False

    cdef chip.HIP_RESOURCE_DESC_st_union_0_struct_4* getElementPtr(self):
        return <chip.HIP_RESOURCE_DESC_st_union_0_struct_4*>self._ptr

    @staticmethod
    cdef HIP_RESOURCE_DESC_st_union_0_struct_4 fromPtr(void* ptr, bint owner=False):
        """Factory function to create ``HIP_RESOURCE_DESC_st_union_0_struct_4`` objects from
        given ``chip.HIP_RESOURCE_DESC_st_union_0_struct_4`` pointer.

        Setting ``owner`` flag to ``True`` causes
        the extension type to free the structure pointed to by ``ptr``
        when the wrapper object is deallocated.
        """
        # Fast call to __new__() that bypasses the __init__() constructor.
        cdef HIP_RESOURCE_DESC_st_union_0_struct_4 wrapper = HIP_RESOURCE_DESC_st_union_0_struct_4.__new__(HIP_RESOURCE_DESC_st_union_0_struct_4)
        wrapper._ptr = ptr
        wrapper._is_ptr_owner = owner
        return wrapper

    @staticmethod
    def fromObj(pyobj):
        """Creates a HIP_RESOURCE_DESC_st_union_0_struct_4 from a Python object.

        Derives a HIP_RESOURCE_DESC_st_union_0_struct_4 from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``HIP_RESOURCE_DESC_st_union_0_struct_4`` reference, this method
        returns it directly. No new ``HIP_RESOURCE_DESC_st_union_0_struct_4`` is created in this case.
        """
        return HIP_RESOURCE_DESC_st_union_0_struct_4.fromPyobj(pyobj)

    @staticmethod
    cdef HIP_RESOURCE_DESC_st_union_0_struct_4 fromPyobj(object pyobj):
        """Creates a HIP_RESOURCE_DESC_st_union_0_struct_4 from a Python object.

        Derives a HIP_RESOURCE_DESC_st_union_0_struct_4 from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``HIP_RESOURCE_DESC_st_union_0_struct_4`` reference, this method
        returns it directly. No new ``HIP_RESOURCE_DESC_st_union_0_struct_4`` is created in this case.

        Args:
            pyobj (object): Must be either `None`; a `hip._util.types.Pointer`; a simple, contiguous buffer according to the buffer protocol;
                            or of type `HIP_RESOURCE_DESC_st_union_0_struct_4`; `int`; or `ctypes.c_void_p`.

        Note:
            This routine does not perform a copy but returns the original ``pyobj``
            if ``pyobj`` is an instance of HIP_RESOURCE_DESC_st_union_0_struct_4!
        """
        cdef HIP_RESOURCE_DESC_st_union_0_struct_4 wrapper

        if isinstance(pyobj,HIP_RESOURCE_DESC_st_union_0_struct_4):
            return pyobj
        else:
            wrapper = HIP_RESOURCE_DESC_st_union_0_struct_4.__new__(HIP_RESOURCE_DESC_st_union_0_struct_4)
            wrapper.init_from_pyobj(pyobj)
            return wrapper

    def __dealloc__(self):
        # Release the buffer handle
        if self._py_buffer_acquired is True:
            cpython.buffer.PyBuffer_Release(&self._py_buffer)
        # De-allocate if not null and flag is set
        if self._ptr is not NULL and self._is_ptr_owner is True:
            stdlib.free(self._ptr)
            self._ptr = NULL

    @staticmethod
    cdef __allocate(void** ptr):
        ptr[0] = stdlib.malloc(sizeof(chip.HIP_RESOURCE_DESC_st_union_0_struct_4))
        string.memset(<void*>ptr[0], 0, sizeof(chip.HIP_RESOURCE_DESC_st_union_0_struct_4))

        if ptr[0] is NULL:
            raise MemoryError

    @staticmethod
    cdef HIP_RESOURCE_DESC_st_union_0_struct_4 new():
        """Factory function to create HIP_RESOURCE_DESC_st_union_0_struct_4 objects with
        newly allocated chip.HIP_RESOURCE_DESC_st_union_0_struct_4"""
        cdef void* ptr
        HIP_RESOURCE_DESC_st_union_0_struct_4.__allocate(&ptr)
        return HIP_RESOURCE_DESC_st_union_0_struct_4.fromPtr(ptr, owner=True)

    @staticmethod
    cdef HIP_RESOURCE_DESC_st_union_0_struct_4 fromValue(chip.HIP_RESOURCE_DESC_st_union_0_struct_4 other):
        """Allocate new C type and copy from ``other``.
        """
        wrapper = HIP_RESOURCE_DESC_st_union_0_struct_4.new()
        string.memcpy(wrapper._ptr, &other, sizeof(chip.HIP_RESOURCE_DESC_st_union_0_struct_4))
        return wrapper

    def c_sizeof(self):
        """Returns the size of the underlying C type in bytes.
        Note:
            Implemented as function to not collide with
            autogenerated property names.
        """
        return sizeof(chip.HIP_RESOURCE_DESC_st_union_0_struct_4)

    def __int__(self):
        """Returns the data's address as long integer.
        """
        return cpython.long.PyLong_FromVoidPtr(self._ptr)

    def __repr__(self):
        return f"<HIP_RESOURCE_DESC_st_union_0_struct_4 object, ptr: {int(self)}>"

    def as_c_void_p(self):
        """Returns the data's address as `ctypes.c_void_p`
        Note:
            Implemented as function to not collide with
            autogenerated property names.
        """
        return ctypes.c_void_p(int(self))

    def __init__(self,*args,**kwargs):
        """Constructor type HIP_RESOURCE_DESC_st_union_0_struct_4.

        Constructor for type HIP_RESOURCE_DESC_st_union_0_struct_4.

        Args:
            *args:
                Positional arguments. Initialize all or a subset of the member variables
                according to their order of declaration.
            **kwargs:
                Can be used to initialize member variables at construction,
                Just pass an argument expression of the form <member>=<value>
                per member that you want to initialize.
        """
        HIP_RESOURCE_DESC_st_union_0_struct_4.__allocate(&self._ptr)
        self._is_ptr_owner = True
        attribs = self.PROPERTIES()
        used_attribs = set()
        if len(args) > len(attribs):
            raise ValueError("More positional arguments specified than this type has properties.")
        for i,v in enumerate(args):
            setattr(self,attribs[i],v)
            used_attribs.add(attribs[i])
        valid_names = ", ".join(["'"+p+"'" for p in attribs])
        for k,v in kwargs.items():
            if k in used_attribs:
                raise KeyError(f"argument '{k}' has already been specified as positional argument.")
            elif k not in attribs:
                raise KeyError(f"'{k}' is no valid property name. Valid names: {valid_names}")
            setattr(self,k,v)
    def get_reserved(self, i):
        """Get value of ``reserved`` of ``(<chip.HIP_RESOURCE_DESC_st_union_0_struct_4*>self._ptr)[i]``.
        """
        return (<chip.HIP_RESOURCE_DESC_st_union_0_struct_4*>self._ptr)[i].reserved
    # TODO add setters
    #def set_reserved(self, i, int[32] value):
    #    """Set value ``reserved`` of ``(<chip.HIP_RESOURCE_DESC_st_union_0_struct_4*>self._ptr)[i]``.
    #    """
    #    (<chip.HIP_RESOURCE_DESC_st_union_0_struct_4*>self._ptr)[i].reserved = value
    @property
    def reserved(self):
        """(undocumented)"""
        return self.get_reserved(0)
    # TODO add setters
    #@reserved.setter
    #def reserved(self, int[32] value):
    #    self.set_reserved(0,value)

    @staticmethod
    def PROPERTIES():
        return ["reserved"]

    def __contains__(self,item):
        properties = self.PROPERTIES()
        return item in properties

    def __getitem__(self,item):
        properties = self.PROPERTIES()
        if isinstance(item,int):
            if item < 0 or item >= len(properties):
                raise IndexError()
            return getattr(self,properties[item])
        raise ValueError("'item' type must be 'int'")


cdef class HIP_RESOURCE_DESC_st_union_0(hip._util.types.Pointer):
    """Python wrapper for cdef class chip.HIP_RESOURCE_DESC_st_union_0.

    Python wrapper for cdef class chip.HIP_RESOURCE_DESC_st_union_0.

    If this type is initialized via its `__init__` method, it allocates a
    member of the underlying C type and destroys it again if the wrapper
    type is deallocated.

    This type also serves as adapter when appearing as argument type in a
    function signature. In this case, the type can further be initialized
    from a number of Python objects:

    * `None`:

      This will set the ``self._ptr`` attribute to ``NULL``.

    * `int`:

      Interprets the integer value as pointer address and writes it to ``self._ptr``.
      No ownership is transferred.

    * `ctypes.c_void_p`:

      Takes the pointer address ``pyobj.value`` and writes it to ``self._ptr``.
      No ownership is transferred.

    * `object` that implements the `CUDA Array Interface <https://numba.readthedocs.io/en/stable/cuda/cuda_array_interface.html>`_ protocol:

      Takes the integer-valued pointer address, i.e. the first entry of the `data` tuple
      from `pyobj`'s member ``__cuda_array_interface__``  and writes it to ``self._ptr``.

    * `object` that implements the Python buffer protocol:

      If the object represents a simple contiguous array,
      writes the `Py_buffer` associated with ``pyobj`` to `self._py_buffer`,
      sets the `self._py_buffer_acquired` flag to `True`, and
      writes `self._py_buffer.buf` to the data pointer `self._ptr`.

    * `hip._util.types.Pointer`:

      Takes the pointer address ``pyobj._ptr`` and writes it to ``self._ptr``.
      No ownership is transferred.

    Type checks are performed in the above order.

    C Attributes:
        _ptr (C type ``void *``, protected):
            Stores a pointer to the data of the original Python object.
        _is_ptr_owner (C type ``bint``, protected):
            If this wrapper is the owner of the underlying data.
        _py_buffer (C type ``Py_buffer`, protected):
            Stores a pointer to the data of the original Python object.
        _py_buffer_acquired (C type ``bint``, protected):
            Stores a pointer to the data of the original Python object.
    """
    # C members declared in pxd file

    def __cinit__(self):
        self._ptr = NULL
        self._is_ptr_owner = False
        self._py_buffer_acquired = False

    cdef chip.HIP_RESOURCE_DESC_st_union_0* getElementPtr(self):
        return <chip.HIP_RESOURCE_DESC_st_union_0*>self._ptr

    @staticmethod
    cdef HIP_RESOURCE_DESC_st_union_0 fromPtr(void* ptr, bint owner=False):
        """Factory function to create ``HIP_RESOURCE_DESC_st_union_0`` objects from
        given ``chip.HIP_RESOURCE_DESC_st_union_0`` pointer.

        Setting ``owner`` flag to ``True`` causes
        the extension type to free the structure pointed to by ``ptr``
        when the wrapper object is deallocated.
        """
        # Fast call to __new__() that bypasses the __init__() constructor.
        cdef HIP_RESOURCE_DESC_st_union_0 wrapper = HIP_RESOURCE_DESC_st_union_0.__new__(HIP_RESOURCE_DESC_st_union_0)
        wrapper._ptr = ptr
        wrapper._is_ptr_owner = owner
        return wrapper

    @staticmethod
    def fromObj(pyobj):
        """Creates a HIP_RESOURCE_DESC_st_union_0 from a Python object.

        Derives a HIP_RESOURCE_DESC_st_union_0 from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``HIP_RESOURCE_DESC_st_union_0`` reference, this method
        returns it directly. No new ``HIP_RESOURCE_DESC_st_union_0`` is created in this case.
        """
        return HIP_RESOURCE_DESC_st_union_0.fromPyobj(pyobj)

    @staticmethod
    cdef HIP_RESOURCE_DESC_st_union_0 fromPyobj(object pyobj):
        """Creates a HIP_RESOURCE_DESC_st_union_0 from a Python object.

        Derives a HIP_RESOURCE_DESC_st_union_0 from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``HIP_RESOURCE_DESC_st_union_0`` reference, this method
        returns it directly. No new ``HIP_RESOURCE_DESC_st_union_0`` is created in this case.

        Args:
            pyobj (object): Must be either `None`; a `hip._util.types.Pointer`; a simple, contiguous buffer according to the buffer protocol;
                            or of type `HIP_RESOURCE_DESC_st_union_0`; `int`; or `ctypes.c_void_p`.

        Note:
            This routine does not perform a copy but returns the original ``pyobj``
            if ``pyobj`` is an instance of HIP_RESOURCE_DESC_st_union_0!
        """
        cdef HIP_RESOURCE_DESC_st_union_0 wrapper

        if isinstance(pyobj,HIP_RESOURCE_DESC_st_union_0):
            return pyobj
        else:
            wrapper = HIP_RESOURCE_DESC_st_union_0.__new__(HIP_RESOURCE_DESC_st_union_0)
            wrapper.init_from_pyobj(pyobj)
            return wrapper

    def __dealloc__(self):
        # Release the buffer handle
        if self._py_buffer_acquired is True:
            cpython.buffer.PyBuffer_Release(&self._py_buffer)
        # De-allocate if not null and flag is set
        if self._ptr is not NULL and self._is_ptr_owner is True:
            stdlib.free(self._ptr)
            self._ptr = NULL

    @staticmethod
    cdef __allocate(void** ptr):
        ptr[0] = stdlib.malloc(sizeof(chip.HIP_RESOURCE_DESC_st_union_0))
        string.memset(<void*>ptr[0], 0, sizeof(chip.HIP_RESOURCE_DESC_st_union_0))

        if ptr[0] is NULL:
            raise MemoryError

    @staticmethod
    cdef HIP_RESOURCE_DESC_st_union_0 new():
        """Factory function to create HIP_RESOURCE_DESC_st_union_0 objects with
        newly allocated chip.HIP_RESOURCE_DESC_st_union_0"""
        cdef void* ptr
        HIP_RESOURCE_DESC_st_union_0.__allocate(&ptr)
        return HIP_RESOURCE_DESC_st_union_0.fromPtr(ptr, owner=True)

    @staticmethod
    cdef HIP_RESOURCE_DESC_st_union_0 fromValue(chip.HIP_RESOURCE_DESC_st_union_0 other):
        """Allocate new C type and copy from ``other``.
        """
        wrapper = HIP_RESOURCE_DESC_st_union_0.new()
        string.memcpy(wrapper._ptr, &other, sizeof(chip.HIP_RESOURCE_DESC_st_union_0))
        return wrapper

    def c_sizeof(self):
        """Returns the size of the underlying C type in bytes.
        Note:
            Implemented as function to not collide with
            autogenerated property names.
        """
        return sizeof(chip.HIP_RESOURCE_DESC_st_union_0)

    def __int__(self):
        """Returns the data's address as long integer.
        """
        return cpython.long.PyLong_FromVoidPtr(self._ptr)

    def __repr__(self):
        return f"<HIP_RESOURCE_DESC_st_union_0 object, ptr: {int(self)}>"

    def as_c_void_p(self):
        """Returns the data's address as `ctypes.c_void_p`
        Note:
            Implemented as function to not collide with
            autogenerated property names.
        """
        return ctypes.c_void_p(int(self))

    def __init__(self,**kwargs):
        """Constructor type HIP_RESOURCE_DESC_st_union_0.

        Constructor for type HIP_RESOURCE_DESC_st_union_0.

        Args:
            **kwargs:
                Can be used to initialize member variables at construction,
                Just pass an argument expression of the form <member>=<value>
                per member that you want to initialize.
        """
        HIP_RESOURCE_DESC_st_union_0.__allocate(&self._ptr)
        self._is_ptr_owner = True
        attribs = self.PROPERTIES()
        used_attribs = set()
        if len(kwargs) > 1:
            raise ValueError("Not more than one attribute might specified for Python types derived from C union types.")
        valid_names = ", ".join(["'"+p+"'" for p in attribs])
        for k,v in kwargs.items():
            if k in used_attribs:
                raise KeyError(f"argument '{k}' has already been specified as positional argument.")
            elif k not in attribs:
                raise KeyError(f"'{k}' is no valid property name. Valid names: {valid_names}")
            setattr(self,k,v)
    def get_array(self, i):
        """Get value of ``array`` of ``(<chip.HIP_RESOURCE_DESC_st_union_0*>self._ptr)[i]``.
        """
        return HIP_RESOURCE_DESC_st_union_0_struct_0.fromPtr(&(<chip.HIP_RESOURCE_DESC_st_union_0*>self._ptr)[i].array)
    @property
    def array(self):
        """(undocumented)"""
        return self.get_array(0)

    def get_mipmap(self, i):
        """Get value of ``mipmap`` of ``(<chip.HIP_RESOURCE_DESC_st_union_0*>self._ptr)[i]``.
        """
        return HIP_RESOURCE_DESC_st_union_0_struct_1.fromPtr(&(<chip.HIP_RESOURCE_DESC_st_union_0*>self._ptr)[i].mipmap)
    @property
    def mipmap(self):
        """(undocumented)"""
        return self.get_mipmap(0)

    def get_linear(self, i):
        """Get value of ``linear`` of ``(<chip.HIP_RESOURCE_DESC_st_union_0*>self._ptr)[i]``.
        """
        return HIP_RESOURCE_DESC_st_union_0_struct_2.fromPtr(&(<chip.HIP_RESOURCE_DESC_st_union_0*>self._ptr)[i].linear)
    @property
    def linear(self):
        """(undocumented)"""
        return self.get_linear(0)

    def get_pitch2D(self, i):
        """Get value of ``pitch2D`` of ``(<chip.HIP_RESOURCE_DESC_st_union_0*>self._ptr)[i]``.
        """
        return HIP_RESOURCE_DESC_st_union_0_struct_3.fromPtr(&(<chip.HIP_RESOURCE_DESC_st_union_0*>self._ptr)[i].pitch2D)
    @property
    def pitch2D(self):
        """(undocumented)"""
        return self.get_pitch2D(0)

    def get_reserved(self, i):
        """Get value of ``reserved`` of ``(<chip.HIP_RESOURCE_DESC_st_union_0*>self._ptr)[i]``.
        """
        return HIP_RESOURCE_DESC_st_union_0_struct_4.fromPtr(&(<chip.HIP_RESOURCE_DESC_st_union_0*>self._ptr)[i].reserved)
    @property
    def reserved(self):
        """(undocumented)"""
        return self.get_reserved(0)

    @staticmethod
    def PROPERTIES():
        return ["array","mipmap","linear","pitch2D","reserved"]


cdef class HIP_RESOURCE_DESC_st(hip._util.types.Pointer):
    """Python wrapper for cdef class chip.HIP_RESOURCE_DESC_st.

    Python wrapper for cdef class chip.HIP_RESOURCE_DESC_st.

    If this type is initialized via its `__init__` method, it allocates a
    member of the underlying C type and destroys it again if the wrapper
    type is deallocated.

    This type also serves as adapter when appearing as argument type in a
    function signature. In this case, the type can further be initialized
    from a number of Python objects:

    * `None`:

      This will set the ``self._ptr`` attribute to ``NULL``.

    * `int`:

      Interprets the integer value as pointer address and writes it to ``self._ptr``.
      No ownership is transferred.

    * `ctypes.c_void_p`:

      Takes the pointer address ``pyobj.value`` and writes it to ``self._ptr``.
      No ownership is transferred.

    * `object` that implements the `CUDA Array Interface <https://numba.readthedocs.io/en/stable/cuda/cuda_array_interface.html>`_ protocol:

      Takes the integer-valued pointer address, i.e. the first entry of the `data` tuple
      from `pyobj`'s member ``__cuda_array_interface__``  and writes it to ``self._ptr``.

    * `object` that implements the Python buffer protocol:

      If the object represents a simple contiguous array,
      writes the `Py_buffer` associated with ``pyobj`` to `self._py_buffer`,
      sets the `self._py_buffer_acquired` flag to `True`, and
      writes `self._py_buffer.buf` to the data pointer `self._ptr`.

    * `hip._util.types.Pointer`:

      Takes the pointer address ``pyobj._ptr`` and writes it to ``self._ptr``.
      No ownership is transferred.

    Type checks are performed in the above order.

    C Attributes:
        _ptr (C type ``void *``, protected):
            Stores a pointer to the data of the original Python object.
        _is_ptr_owner (C type ``bint``, protected):
            If this wrapper is the owner of the underlying data.
        _py_buffer (C type ``Py_buffer`, protected):
            Stores a pointer to the data of the original Python object.
        _py_buffer_acquired (C type ``bint``, protected):
            Stores a pointer to the data of the original Python object.
    """
    # C members declared in pxd file

    def __cinit__(self):
        self._ptr = NULL
        self._is_ptr_owner = False
        self._py_buffer_acquired = False

    cdef chip.HIP_RESOURCE_DESC_st* getElementPtr(self):
        return <chip.HIP_RESOURCE_DESC_st*>self._ptr

    @staticmethod
    cdef HIP_RESOURCE_DESC_st fromPtr(void* ptr, bint owner=False):
        """Factory function to create ``HIP_RESOURCE_DESC_st`` objects from
        given ``chip.HIP_RESOURCE_DESC_st`` pointer.

        Setting ``owner`` flag to ``True`` causes
        the extension type to free the structure pointed to by ``ptr``
        when the wrapper object is deallocated.
        """
        # Fast call to __new__() that bypasses the __init__() constructor.
        cdef HIP_RESOURCE_DESC_st wrapper = HIP_RESOURCE_DESC_st.__new__(HIP_RESOURCE_DESC_st)
        wrapper._ptr = ptr
        wrapper._is_ptr_owner = owner
        return wrapper

    @staticmethod
    def fromObj(pyobj):
        """Creates a HIP_RESOURCE_DESC_st from a Python object.

        Derives a HIP_RESOURCE_DESC_st from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``HIP_RESOURCE_DESC_st`` reference, this method
        returns it directly. No new ``HIP_RESOURCE_DESC_st`` is created in this case.
        """
        return HIP_RESOURCE_DESC_st.fromPyobj(pyobj)

    @staticmethod
    cdef HIP_RESOURCE_DESC_st fromPyobj(object pyobj):
        """Creates a HIP_RESOURCE_DESC_st from a Python object.

        Derives a HIP_RESOURCE_DESC_st from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``HIP_RESOURCE_DESC_st`` reference, this method
        returns it directly. No new ``HIP_RESOURCE_DESC_st`` is created in this case.

        Args:
            pyobj (object): Must be either `None`; a `hip._util.types.Pointer`; a simple, contiguous buffer according to the buffer protocol;
                            or of type `HIP_RESOURCE_DESC_st`; `int`; or `ctypes.c_void_p`.

        Note:
            This routine does not perform a copy but returns the original ``pyobj``
            if ``pyobj`` is an instance of HIP_RESOURCE_DESC_st!
        """
        cdef HIP_RESOURCE_DESC_st wrapper

        if isinstance(pyobj,HIP_RESOURCE_DESC_st):
            return pyobj
        else:
            wrapper = HIP_RESOURCE_DESC_st.__new__(HIP_RESOURCE_DESC_st)
            wrapper.init_from_pyobj(pyobj)
            return wrapper

    def __dealloc__(self):
        # Release the buffer handle
        if self._py_buffer_acquired is True:
            cpython.buffer.PyBuffer_Release(&self._py_buffer)
        # De-allocate if not null and flag is set
        if self._ptr is not NULL and self._is_ptr_owner is True:
            stdlib.free(self._ptr)
            self._ptr = NULL

    @staticmethod
    cdef __allocate(void** ptr):
        ptr[0] = stdlib.malloc(sizeof(chip.HIP_RESOURCE_DESC_st))
        string.memset(<void*>ptr[0], 0, sizeof(chip.HIP_RESOURCE_DESC_st))

        if ptr[0] is NULL:
            raise MemoryError

    @staticmethod
    cdef HIP_RESOURCE_DESC_st new():
        """Factory function to create HIP_RESOURCE_DESC_st objects with
        newly allocated chip.HIP_RESOURCE_DESC_st"""
        cdef void* ptr
        HIP_RESOURCE_DESC_st.__allocate(&ptr)
        return HIP_RESOURCE_DESC_st.fromPtr(ptr, owner=True)

    @staticmethod
    cdef HIP_RESOURCE_DESC_st fromValue(chip.HIP_RESOURCE_DESC_st other):
        """Allocate new C type and copy from ``other``.
        """
        wrapper = HIP_RESOURCE_DESC_st.new()
        string.memcpy(wrapper._ptr, &other, sizeof(chip.HIP_RESOURCE_DESC_st))
        return wrapper

    def c_sizeof(self):
        """Returns the size of the underlying C type in bytes.
        Note:
            Implemented as function to not collide with
            autogenerated property names.
        """
        return sizeof(chip.HIP_RESOURCE_DESC_st)

    def __int__(self):
        """Returns the data's address as long integer.
        """
        return cpython.long.PyLong_FromVoidPtr(self._ptr)

    def __repr__(self):
        return f"<HIP_RESOURCE_DESC_st object, ptr: {int(self)}>"

    def as_c_void_p(self):
        """Returns the data's address as `ctypes.c_void_p`
        Note:
            Implemented as function to not collide with
            autogenerated property names.
        """
        return ctypes.c_void_p(int(self))

    def __init__(self,*args,**kwargs):
        """Constructor type HIP_RESOURCE_DESC_st.

        Constructor for type HIP_RESOURCE_DESC_st.

        Args:
            *args:
                Positional arguments. Initialize all or a subset of the member variables
                according to their order of declaration.
            **kwargs:
                Can be used to initialize member variables at construction,
                Just pass an argument expression of the form <member>=<value>
                per member that you want to initialize.
        """
        HIP_RESOURCE_DESC_st.__allocate(&self._ptr)
        self._is_ptr_owner = True
        attribs = self.PROPERTIES()
        used_attribs = set()
        if len(args) > len(attribs):
            raise ValueError("More positional arguments specified than this type has properties.")
        for i,v in enumerate(args):
            setattr(self,attribs[i],v)
            used_attribs.add(attribs[i])
        valid_names = ", ".join(["'"+p+"'" for p in attribs])
        for k,v in kwargs.items():
            if k in used_attribs:
                raise KeyError(f"argument '{k}' has already been specified as positional argument.")
            elif k not in attribs:
                raise KeyError(f"'{k}' is no valid property name. Valid names: {valid_names}")
            setattr(self,k,v)
    def get_resType(self, i):
        """Get value of ``resType`` of ``(<chip.HIP_RESOURCE_DESC_st*>self._ptr)[i]``.
        """
        return HIPresourcetype_enum((<chip.HIP_RESOURCE_DESC_st*>self._ptr)[i].resType)
    def set_resType(self, i, value):
        """Set value ``resType`` of ``(<chip.HIP_RESOURCE_DESC_st*>self._ptr)[i]``.
        """
        if not isinstance(value, HIPresourcetype_enum):
            raise TypeError("'value' must be of type 'HIPresourcetype_enum'")
        (<chip.HIP_RESOURCE_DESC_st*>self._ptr)[i].resType = value.value
    @property
    def resType(self):
        """Resource type"""
        return self.get_resType(0)
    @resType.setter
    def resType(self, value):
        self.set_resType(0,value)

    def get_res(self, i):
        """Get value of ``res`` of ``(<chip.HIP_RESOURCE_DESC_st*>self._ptr)[i]``.
        """
        return HIP_RESOURCE_DESC_st_union_0.fromPtr(&(<chip.HIP_RESOURCE_DESC_st*>self._ptr)[i].res)
    @property
    def res(self):
        """(undocumented)"""
        return self.get_res(0)

    def get_flags(self, i):
        """Get value ``flags`` of ``(<chip.HIP_RESOURCE_DESC_st*>self._ptr)[i]``.
        """
        return (<chip.HIP_RESOURCE_DESC_st*>self._ptr)[i].flags
    def set_flags(self, i, unsigned int value):
        """Set value ``flags`` of ``(<chip.HIP_RESOURCE_DESC_st*>self._ptr)[i]``.
        """
        (<chip.HIP_RESOURCE_DESC_st*>self._ptr)[i].flags = value
    @property
    def flags(self):
        """Flags (must be zero)"""
        return self.get_flags(0)
    @flags.setter
    def flags(self, unsigned int value):
        self.set_flags(0,value)

    @staticmethod
    def PROPERTIES():
        return ["resType","res","flags"]

    def __contains__(self,item):
        properties = self.PROPERTIES()
        return item in properties

    def __getitem__(self,item):
        properties = self.PROPERTIES()
        if isinstance(item,int):
            if item < 0 or item >= len(properties):
                raise IndexError()
            return getattr(self,properties[item])
        raise ValueError("'item' type must be 'int'")


HIP_RESOURCE_DESC = HIP_RESOURCE_DESC_st

cdef class hipResourceViewDesc(hip._util.types.Pointer):
    """Python wrapper for cdef class chip.hipResourceViewDesc.

    Python wrapper for cdef class chip.hipResourceViewDesc.

    If this type is initialized via its `__init__` method, it allocates a
    member of the underlying C type and destroys it again if the wrapper
    type is deallocated.

    This type also serves as adapter when appearing as argument type in a
    function signature. In this case, the type can further be initialized
    from a number of Python objects:

    * `None`:

      This will set the ``self._ptr`` attribute to ``NULL``.

    * `int`:

      Interprets the integer value as pointer address and writes it to ``self._ptr``.
      No ownership is transferred.

    * `ctypes.c_void_p`:

      Takes the pointer address ``pyobj.value`` and writes it to ``self._ptr``.
      No ownership is transferred.

    * `object` that implements the `CUDA Array Interface <https://numba.readthedocs.io/en/stable/cuda/cuda_array_interface.html>`_ protocol:

      Takes the integer-valued pointer address, i.e. the first entry of the `data` tuple
      from `pyobj`'s member ``__cuda_array_interface__``  and writes it to ``self._ptr``.

    * `object` that implements the Python buffer protocol:

      If the object represents a simple contiguous array,
      writes the `Py_buffer` associated with ``pyobj`` to `self._py_buffer`,
      sets the `self._py_buffer_acquired` flag to `True`, and
      writes `self._py_buffer.buf` to the data pointer `self._ptr`.

    * `hip._util.types.Pointer`:

      Takes the pointer address ``pyobj._ptr`` and writes it to ``self._ptr``.
      No ownership is transferred.

    Type checks are performed in the above order.

    C Attributes:
        _ptr (C type ``void *``, protected):
            Stores a pointer to the data of the original Python object.
        _is_ptr_owner (C type ``bint``, protected):
            If this wrapper is the owner of the underlying data.
        _py_buffer (C type ``Py_buffer`, protected):
            Stores a pointer to the data of the original Python object.
        _py_buffer_acquired (C type ``bint``, protected):
            Stores a pointer to the data of the original Python object.
    """
    # C members declared in pxd file

    def __cinit__(self):
        self._ptr = NULL
        self._is_ptr_owner = False
        self._py_buffer_acquired = False

    cdef chip.hipResourceViewDesc* getElementPtr(self):
        return <chip.hipResourceViewDesc*>self._ptr

    @staticmethod
    cdef hipResourceViewDesc fromPtr(void* ptr, bint owner=False):
        """Factory function to create ``hipResourceViewDesc`` objects from
        given ``chip.hipResourceViewDesc`` pointer.

        Setting ``owner`` flag to ``True`` causes
        the extension type to free the structure pointed to by ``ptr``
        when the wrapper object is deallocated.
        """
        # Fast call to __new__() that bypasses the __init__() constructor.
        cdef hipResourceViewDesc wrapper = hipResourceViewDesc.__new__(hipResourceViewDesc)
        wrapper._ptr = ptr
        wrapper._is_ptr_owner = owner
        return wrapper

    @staticmethod
    def fromObj(pyobj):
        """Creates a hipResourceViewDesc from a Python object.

        Derives a hipResourceViewDesc from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``hipResourceViewDesc`` reference, this method
        returns it directly. No new ``hipResourceViewDesc`` is created in this case.
        """
        return hipResourceViewDesc.fromPyobj(pyobj)

    @staticmethod
    cdef hipResourceViewDesc fromPyobj(object pyobj):
        """Creates a hipResourceViewDesc from a Python object.

        Derives a hipResourceViewDesc from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``hipResourceViewDesc`` reference, this method
        returns it directly. No new ``hipResourceViewDesc`` is created in this case.

        Args:
            pyobj (object): Must be either `None`; a `hip._util.types.Pointer`; a simple, contiguous buffer according to the buffer protocol;
                            or of type `hipResourceViewDesc`; `int`; or `ctypes.c_void_p`.

        Note:
            This routine does not perform a copy but returns the original ``pyobj``
            if ``pyobj`` is an instance of hipResourceViewDesc!
        """
        cdef hipResourceViewDesc wrapper

        if isinstance(pyobj,hipResourceViewDesc):
            return pyobj
        else:
            wrapper = hipResourceViewDesc.__new__(hipResourceViewDesc)
            wrapper.init_from_pyobj(pyobj)
            return wrapper

    def __dealloc__(self):
        # Release the buffer handle
        if self._py_buffer_acquired is True:
            cpython.buffer.PyBuffer_Release(&self._py_buffer)
        # De-allocate if not null and flag is set
        if self._ptr is not NULL and self._is_ptr_owner is True:
            stdlib.free(self._ptr)
            self._ptr = NULL

    @staticmethod
    cdef __allocate(void** ptr):
        ptr[0] = stdlib.malloc(sizeof(chip.hipResourceViewDesc))
        string.memset(<void*>ptr[0], 0, sizeof(chip.hipResourceViewDesc))

        if ptr[0] is NULL:
            raise MemoryError

    @staticmethod
    cdef hipResourceViewDesc new():
        """Factory function to create hipResourceViewDesc objects with
        newly allocated chip.hipResourceViewDesc"""
        cdef void* ptr
        hipResourceViewDesc.__allocate(&ptr)
        return hipResourceViewDesc.fromPtr(ptr, owner=True)

    @staticmethod
    cdef hipResourceViewDesc fromValue(chip.hipResourceViewDesc other):
        """Allocate new C type and copy from ``other``.
        """
        wrapper = hipResourceViewDesc.new()
        string.memcpy(wrapper._ptr, &other, sizeof(chip.hipResourceViewDesc))
        return wrapper

    def c_sizeof(self):
        """Returns the size of the underlying C type in bytes.
        Note:
            Implemented as function to not collide with
            autogenerated property names.
        """
        return sizeof(chip.hipResourceViewDesc)

    def __int__(self):
        """Returns the data's address as long integer.
        """
        return cpython.long.PyLong_FromVoidPtr(self._ptr)

    def __repr__(self):
        return f"<hipResourceViewDesc object, ptr: {int(self)}>"

    def as_c_void_p(self):
        """Returns the data's address as `ctypes.c_void_p`
        Note:
            Implemented as function to not collide with
            autogenerated property names.
        """
        return ctypes.c_void_p(int(self))

    def __init__(self,*args,**kwargs):
        """Constructor type hipResourceViewDesc.

        Constructor for type hipResourceViewDesc.

        Args:
            *args:
                Positional arguments. Initialize all or a subset of the member variables
                according to their order of declaration.
            **kwargs:
                Can be used to initialize member variables at construction,
                Just pass an argument expression of the form <member>=<value>
                per member that you want to initialize.
        """
        hipResourceViewDesc.__allocate(&self._ptr)
        self._is_ptr_owner = True
        attribs = self.PROPERTIES()
        used_attribs = set()
        if len(args) > len(attribs):
            raise ValueError("More positional arguments specified than this type has properties.")
        for i,v in enumerate(args):
            setattr(self,attribs[i],v)
            used_attribs.add(attribs[i])
        valid_names = ", ".join(["'"+p+"'" for p in attribs])
        for k,v in kwargs.items():
            if k in used_attribs:
                raise KeyError(f"argument '{k}' has already been specified as positional argument.")
            elif k not in attribs:
                raise KeyError(f"'{k}' is no valid property name. Valid names: {valid_names}")
            setattr(self,k,v)
    def get_format(self, i):
        """Get value of ``format`` of ``(<chip.hipResourceViewDesc*>self._ptr)[i]``.
        """
        return hipResourceViewFormat((<chip.hipResourceViewDesc*>self._ptr)[i].format)
    def set_format(self, i, value):
        """Set value ``format`` of ``(<chip.hipResourceViewDesc*>self._ptr)[i]``.
        """
        if not isinstance(value, hipResourceViewFormat):
            raise TypeError("'value' must be of type 'hipResourceViewFormat'")
        (<chip.hipResourceViewDesc*>self._ptr)[i].format = value.value
    @property
    def format(self):
        """(undocumented)"""
        return self.get_format(0)
    @format.setter
    def format(self, value):
        self.set_format(0,value)

    def get_width(self, i):
        """Get value ``width`` of ``(<chip.hipResourceViewDesc*>self._ptr)[i]``.
        """
        return (<chip.hipResourceViewDesc*>self._ptr)[i].width
    def set_width(self, i, unsigned long value):
        """Set value ``width`` of ``(<chip.hipResourceViewDesc*>self._ptr)[i]``.
        """
        (<chip.hipResourceViewDesc*>self._ptr)[i].width = value
    @property
    def width(self):
        """(undocumented)"""
        return self.get_width(0)
    @width.setter
    def width(self, unsigned long value):
        self.set_width(0,value)

    def get_height(self, i):
        """Get value ``height`` of ``(<chip.hipResourceViewDesc*>self._ptr)[i]``.
        """
        return (<chip.hipResourceViewDesc*>self._ptr)[i].height
    def set_height(self, i, unsigned long value):
        """Set value ``height`` of ``(<chip.hipResourceViewDesc*>self._ptr)[i]``.
        """
        (<chip.hipResourceViewDesc*>self._ptr)[i].height = value
    @property
    def height(self):
        """(undocumented)"""
        return self.get_height(0)
    @height.setter
    def height(self, unsigned long value):
        self.set_height(0,value)

    def get_depth(self, i):
        """Get value ``depth`` of ``(<chip.hipResourceViewDesc*>self._ptr)[i]``.
        """
        return (<chip.hipResourceViewDesc*>self._ptr)[i].depth
    def set_depth(self, i, unsigned long value):
        """Set value ``depth`` of ``(<chip.hipResourceViewDesc*>self._ptr)[i]``.
        """
        (<chip.hipResourceViewDesc*>self._ptr)[i].depth = value
    @property
    def depth(self):
        """(undocumented)"""
        return self.get_depth(0)
    @depth.setter
    def depth(self, unsigned long value):
        self.set_depth(0,value)

    def get_firstMipmapLevel(self, i):
        """Get value ``firstMipmapLevel`` of ``(<chip.hipResourceViewDesc*>self._ptr)[i]``.
        """
        return (<chip.hipResourceViewDesc*>self._ptr)[i].firstMipmapLevel
    def set_firstMipmapLevel(self, i, unsigned int value):
        """Set value ``firstMipmapLevel`` of ``(<chip.hipResourceViewDesc*>self._ptr)[i]``.
        """
        (<chip.hipResourceViewDesc*>self._ptr)[i].firstMipmapLevel = value
    @property
    def firstMipmapLevel(self):
        """(undocumented)"""
        return self.get_firstMipmapLevel(0)
    @firstMipmapLevel.setter
    def firstMipmapLevel(self, unsigned int value):
        self.set_firstMipmapLevel(0,value)

    def get_lastMipmapLevel(self, i):
        """Get value ``lastMipmapLevel`` of ``(<chip.hipResourceViewDesc*>self._ptr)[i]``.
        """
        return (<chip.hipResourceViewDesc*>self._ptr)[i].lastMipmapLevel
    def set_lastMipmapLevel(self, i, unsigned int value):
        """Set value ``lastMipmapLevel`` of ``(<chip.hipResourceViewDesc*>self._ptr)[i]``.
        """
        (<chip.hipResourceViewDesc*>self._ptr)[i].lastMipmapLevel = value
    @property
    def lastMipmapLevel(self):
        """(undocumented)"""
        return self.get_lastMipmapLevel(0)
    @lastMipmapLevel.setter
    def lastMipmapLevel(self, unsigned int value):
        self.set_lastMipmapLevel(0,value)

    def get_firstLayer(self, i):
        """Get value ``firstLayer`` of ``(<chip.hipResourceViewDesc*>self._ptr)[i]``.
        """
        return (<chip.hipResourceViewDesc*>self._ptr)[i].firstLayer
    def set_firstLayer(self, i, unsigned int value):
        """Set value ``firstLayer`` of ``(<chip.hipResourceViewDesc*>self._ptr)[i]``.
        """
        (<chip.hipResourceViewDesc*>self._ptr)[i].firstLayer = value
    @property
    def firstLayer(self):
        """(undocumented)"""
        return self.get_firstLayer(0)
    @firstLayer.setter
    def firstLayer(self, unsigned int value):
        self.set_firstLayer(0,value)

    def get_lastLayer(self, i):
        """Get value ``lastLayer`` of ``(<chip.hipResourceViewDesc*>self._ptr)[i]``.
        """
        return (<chip.hipResourceViewDesc*>self._ptr)[i].lastLayer
    def set_lastLayer(self, i, unsigned int value):
        """Set value ``lastLayer`` of ``(<chip.hipResourceViewDesc*>self._ptr)[i]``.
        """
        (<chip.hipResourceViewDesc*>self._ptr)[i].lastLayer = value
    @property
    def lastLayer(self):
        """(undocumented)"""
        return self.get_lastLayer(0)
    @lastLayer.setter
    def lastLayer(self, unsigned int value):
        self.set_lastLayer(0,value)

    @staticmethod
    def PROPERTIES():
        return ["format","width","height","depth","firstMipmapLevel","lastMipmapLevel","firstLayer","lastLayer"]

    def __contains__(self,item):
        properties = self.PROPERTIES()
        return item in properties

    def __getitem__(self,item):
        properties = self.PROPERTIES()
        if isinstance(item,int):
            if item < 0 or item >= len(properties):
                raise IndexError()
            return getattr(self,properties[item])
        raise ValueError("'item' type must be 'int'")


cdef class HIP_RESOURCE_VIEW_DESC_st(hip._util.types.Pointer):
    """Python wrapper for cdef class chip.HIP_RESOURCE_VIEW_DESC_st.

    Python wrapper for cdef class chip.HIP_RESOURCE_VIEW_DESC_st.

    If this type is initialized via its `__init__` method, it allocates a
    member of the underlying C type and destroys it again if the wrapper
    type is deallocated.

    This type also serves as adapter when appearing as argument type in a
    function signature. In this case, the type can further be initialized
    from a number of Python objects:

    * `None`:

      This will set the ``self._ptr`` attribute to ``NULL``.

    * `int`:

      Interprets the integer value as pointer address and writes it to ``self._ptr``.
      No ownership is transferred.

    * `ctypes.c_void_p`:

      Takes the pointer address ``pyobj.value`` and writes it to ``self._ptr``.
      No ownership is transferred.

    * `object` that implements the `CUDA Array Interface <https://numba.readthedocs.io/en/stable/cuda/cuda_array_interface.html>`_ protocol:

      Takes the integer-valued pointer address, i.e. the first entry of the `data` tuple
      from `pyobj`'s member ``__cuda_array_interface__``  and writes it to ``self._ptr``.

    * `object` that implements the Python buffer protocol:

      If the object represents a simple contiguous array,
      writes the `Py_buffer` associated with ``pyobj`` to `self._py_buffer`,
      sets the `self._py_buffer_acquired` flag to `True`, and
      writes `self._py_buffer.buf` to the data pointer `self._ptr`.

    * `hip._util.types.Pointer`:

      Takes the pointer address ``pyobj._ptr`` and writes it to ``self._ptr``.
      No ownership is transferred.

    Type checks are performed in the above order.

    C Attributes:
        _ptr (C type ``void *``, protected):
            Stores a pointer to the data of the original Python object.
        _is_ptr_owner (C type ``bint``, protected):
            If this wrapper is the owner of the underlying data.
        _py_buffer (C type ``Py_buffer`, protected):
            Stores a pointer to the data of the original Python object.
        _py_buffer_acquired (C type ``bint``, protected):
            Stores a pointer to the data of the original Python object.
    """
    # C members declared in pxd file

    def __cinit__(self):
        self._ptr = NULL
        self._is_ptr_owner = False
        self._py_buffer_acquired = False

    cdef chip.HIP_RESOURCE_VIEW_DESC_st* getElementPtr(self):
        return <chip.HIP_RESOURCE_VIEW_DESC_st*>self._ptr

    @staticmethod
    cdef HIP_RESOURCE_VIEW_DESC_st fromPtr(void* ptr, bint owner=False):
        """Factory function to create ``HIP_RESOURCE_VIEW_DESC_st`` objects from
        given ``chip.HIP_RESOURCE_VIEW_DESC_st`` pointer.

        Setting ``owner`` flag to ``True`` causes
        the extension type to free the structure pointed to by ``ptr``
        when the wrapper object is deallocated.
        """
        # Fast call to __new__() that bypasses the __init__() constructor.
        cdef HIP_RESOURCE_VIEW_DESC_st wrapper = HIP_RESOURCE_VIEW_DESC_st.__new__(HIP_RESOURCE_VIEW_DESC_st)
        wrapper._ptr = ptr
        wrapper._is_ptr_owner = owner
        return wrapper

    @staticmethod
    def fromObj(pyobj):
        """Creates a HIP_RESOURCE_VIEW_DESC_st from a Python object.

        Derives a HIP_RESOURCE_VIEW_DESC_st from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``HIP_RESOURCE_VIEW_DESC_st`` reference, this method
        returns it directly. No new ``HIP_RESOURCE_VIEW_DESC_st`` is created in this case.
        """
        return HIP_RESOURCE_VIEW_DESC_st.fromPyobj(pyobj)

    @staticmethod
    cdef HIP_RESOURCE_VIEW_DESC_st fromPyobj(object pyobj):
        """Creates a HIP_RESOURCE_VIEW_DESC_st from a Python object.

        Derives a HIP_RESOURCE_VIEW_DESC_st from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``HIP_RESOURCE_VIEW_DESC_st`` reference, this method
        returns it directly. No new ``HIP_RESOURCE_VIEW_DESC_st`` is created in this case.

        Args:
            pyobj (object): Must be either `None`; a `hip._util.types.Pointer`; a simple, contiguous buffer according to the buffer protocol;
                            or of type `HIP_RESOURCE_VIEW_DESC_st`; `int`; or `ctypes.c_void_p`.

        Note:
            This routine does not perform a copy but returns the original ``pyobj``
            if ``pyobj`` is an instance of HIP_RESOURCE_VIEW_DESC_st!
        """
        cdef HIP_RESOURCE_VIEW_DESC_st wrapper

        if isinstance(pyobj,HIP_RESOURCE_VIEW_DESC_st):
            return pyobj
        else:
            wrapper = HIP_RESOURCE_VIEW_DESC_st.__new__(HIP_RESOURCE_VIEW_DESC_st)
            wrapper.init_from_pyobj(pyobj)
            return wrapper

    def __dealloc__(self):
        # Release the buffer handle
        if self._py_buffer_acquired is True:
            cpython.buffer.PyBuffer_Release(&self._py_buffer)
        # De-allocate if not null and flag is set
        if self._ptr is not NULL and self._is_ptr_owner is True:
            stdlib.free(self._ptr)
            self._ptr = NULL

    @staticmethod
    cdef __allocate(void** ptr):
        ptr[0] = stdlib.malloc(sizeof(chip.HIP_RESOURCE_VIEW_DESC_st))
        string.memset(<void*>ptr[0], 0, sizeof(chip.HIP_RESOURCE_VIEW_DESC_st))

        if ptr[0] is NULL:
            raise MemoryError

    @staticmethod
    cdef HIP_RESOURCE_VIEW_DESC_st new():
        """Factory function to create HIP_RESOURCE_VIEW_DESC_st objects with
        newly allocated chip.HIP_RESOURCE_VIEW_DESC_st"""
        cdef void* ptr
        HIP_RESOURCE_VIEW_DESC_st.__allocate(&ptr)
        return HIP_RESOURCE_VIEW_DESC_st.fromPtr(ptr, owner=True)

    @staticmethod
    cdef HIP_RESOURCE_VIEW_DESC_st fromValue(chip.HIP_RESOURCE_VIEW_DESC_st other):
        """Allocate new C type and copy from ``other``.
        """
        wrapper = HIP_RESOURCE_VIEW_DESC_st.new()
        string.memcpy(wrapper._ptr, &other, sizeof(chip.HIP_RESOURCE_VIEW_DESC_st))
        return wrapper

    def c_sizeof(self):
        """Returns the size of the underlying C type in bytes.
        Note:
            Implemented as function to not collide with
            autogenerated property names.
        """
        return sizeof(chip.HIP_RESOURCE_VIEW_DESC_st)

    def __int__(self):
        """Returns the data's address as long integer.
        """
        return cpython.long.PyLong_FromVoidPtr(self._ptr)

    def __repr__(self):
        return f"<HIP_RESOURCE_VIEW_DESC_st object, ptr: {int(self)}>"

    def as_c_void_p(self):
        """Returns the data's address as `ctypes.c_void_p`
        Note:
            Implemented as function to not collide with
            autogenerated property names.
        """
        return ctypes.c_void_p(int(self))

    def __init__(self,*args,**kwargs):
        """Constructor type HIP_RESOURCE_VIEW_DESC_st.

        Constructor for type HIP_RESOURCE_VIEW_DESC_st.

        Args:
            *args:
                Positional arguments. Initialize all or a subset of the member variables
                according to their order of declaration.
            **kwargs:
                Can be used to initialize member variables at construction,
                Just pass an argument expression of the form <member>=<value>
                per member that you want to initialize.
        """
        HIP_RESOURCE_VIEW_DESC_st.__allocate(&self._ptr)
        self._is_ptr_owner = True
        attribs = self.PROPERTIES()
        used_attribs = set()
        if len(args) > len(attribs):
            raise ValueError("More positional arguments specified than this type has properties.")
        for i,v in enumerate(args):
            setattr(self,attribs[i],v)
            used_attribs.add(attribs[i])
        valid_names = ", ".join(["'"+p+"'" for p in attribs])
        for k,v in kwargs.items():
            if k in used_attribs:
                raise KeyError(f"argument '{k}' has already been specified as positional argument.")
            elif k not in attribs:
                raise KeyError(f"'{k}' is no valid property name. Valid names: {valid_names}")
            setattr(self,k,v)
    def get_format(self, i):
        """Get value of ``format`` of ``(<chip.HIP_RESOURCE_VIEW_DESC_st*>self._ptr)[i]``.
        """
        return HIPresourceViewFormat_enum((<chip.HIP_RESOURCE_VIEW_DESC_st*>self._ptr)[i].format)
    def set_format(self, i, value):
        """Set value ``format`` of ``(<chip.HIP_RESOURCE_VIEW_DESC_st*>self._ptr)[i]``.
        """
        if not isinstance(value, HIPresourceViewFormat_enum):
            raise TypeError("'value' must be of type 'HIPresourceViewFormat_enum'")
        (<chip.HIP_RESOURCE_VIEW_DESC_st*>self._ptr)[i].format = value.value
    @property
    def format(self):
        """Resource view format"""
        return self.get_format(0)
    @format.setter
    def format(self, value):
        self.set_format(0,value)

    def get_width(self, i):
        """Get value ``width`` of ``(<chip.HIP_RESOURCE_VIEW_DESC_st*>self._ptr)[i]``.
        """
        return (<chip.HIP_RESOURCE_VIEW_DESC_st*>self._ptr)[i].width
    def set_width(self, i, unsigned long value):
        """Set value ``width`` of ``(<chip.HIP_RESOURCE_VIEW_DESC_st*>self._ptr)[i]``.
        """
        (<chip.HIP_RESOURCE_VIEW_DESC_st*>self._ptr)[i].width = value
    @property
    def width(self):
        """Width of the resource view"""
        return self.get_width(0)
    @width.setter
    def width(self, unsigned long value):
        self.set_width(0,value)

    def get_height(self, i):
        """Get value ``height`` of ``(<chip.HIP_RESOURCE_VIEW_DESC_st*>self._ptr)[i]``.
        """
        return (<chip.HIP_RESOURCE_VIEW_DESC_st*>self._ptr)[i].height
    def set_height(self, i, unsigned long value):
        """Set value ``height`` of ``(<chip.HIP_RESOURCE_VIEW_DESC_st*>self._ptr)[i]``.
        """
        (<chip.HIP_RESOURCE_VIEW_DESC_st*>self._ptr)[i].height = value
    @property
    def height(self):
        """Height of the resource view"""
        return self.get_height(0)
    @height.setter
    def height(self, unsigned long value):
        self.set_height(0,value)

    def get_depth(self, i):
        """Get value ``depth`` of ``(<chip.HIP_RESOURCE_VIEW_DESC_st*>self._ptr)[i]``.
        """
        return (<chip.HIP_RESOURCE_VIEW_DESC_st*>self._ptr)[i].depth
    def set_depth(self, i, unsigned long value):
        """Set value ``depth`` of ``(<chip.HIP_RESOURCE_VIEW_DESC_st*>self._ptr)[i]``.
        """
        (<chip.HIP_RESOURCE_VIEW_DESC_st*>self._ptr)[i].depth = value
    @property
    def depth(self):
        """Depth of the resource view"""
        return self.get_depth(0)
    @depth.setter
    def depth(self, unsigned long value):
        self.set_depth(0,value)

    def get_firstMipmapLevel(self, i):
        """Get value ``firstMipmapLevel`` of ``(<chip.HIP_RESOURCE_VIEW_DESC_st*>self._ptr)[i]``.
        """
        return (<chip.HIP_RESOURCE_VIEW_DESC_st*>self._ptr)[i].firstMipmapLevel
    def set_firstMipmapLevel(self, i, unsigned int value):
        """Set value ``firstMipmapLevel`` of ``(<chip.HIP_RESOURCE_VIEW_DESC_st*>self._ptr)[i]``.
        """
        (<chip.HIP_RESOURCE_VIEW_DESC_st*>self._ptr)[i].firstMipmapLevel = value
    @property
    def firstMipmapLevel(self):
        """First defined mipmap level"""
        return self.get_firstMipmapLevel(0)
    @firstMipmapLevel.setter
    def firstMipmapLevel(self, unsigned int value):
        self.set_firstMipmapLevel(0,value)

    def get_lastMipmapLevel(self, i):
        """Get value ``lastMipmapLevel`` of ``(<chip.HIP_RESOURCE_VIEW_DESC_st*>self._ptr)[i]``.
        """
        return (<chip.HIP_RESOURCE_VIEW_DESC_st*>self._ptr)[i].lastMipmapLevel
    def set_lastMipmapLevel(self, i, unsigned int value):
        """Set value ``lastMipmapLevel`` of ``(<chip.HIP_RESOURCE_VIEW_DESC_st*>self._ptr)[i]``.
        """
        (<chip.HIP_RESOURCE_VIEW_DESC_st*>self._ptr)[i].lastMipmapLevel = value
    @property
    def lastMipmapLevel(self):
        """Last defined mipmap level"""
        return self.get_lastMipmapLevel(0)
    @lastMipmapLevel.setter
    def lastMipmapLevel(self, unsigned int value):
        self.set_lastMipmapLevel(0,value)

    def get_firstLayer(self, i):
        """Get value ``firstLayer`` of ``(<chip.HIP_RESOURCE_VIEW_DESC_st*>self._ptr)[i]``.
        """
        return (<chip.HIP_RESOURCE_VIEW_DESC_st*>self._ptr)[i].firstLayer
    def set_firstLayer(self, i, unsigned int value):
        """Set value ``firstLayer`` of ``(<chip.HIP_RESOURCE_VIEW_DESC_st*>self._ptr)[i]``.
        """
        (<chip.HIP_RESOURCE_VIEW_DESC_st*>self._ptr)[i].firstLayer = value
    @property
    def firstLayer(self):
        """First layer index"""
        return self.get_firstLayer(0)
    @firstLayer.setter
    def firstLayer(self, unsigned int value):
        self.set_firstLayer(0,value)

    def get_lastLayer(self, i):
        """Get value ``lastLayer`` of ``(<chip.HIP_RESOURCE_VIEW_DESC_st*>self._ptr)[i]``.
        """
        return (<chip.HIP_RESOURCE_VIEW_DESC_st*>self._ptr)[i].lastLayer
    def set_lastLayer(self, i, unsigned int value):
        """Set value ``lastLayer`` of ``(<chip.HIP_RESOURCE_VIEW_DESC_st*>self._ptr)[i]``.
        """
        (<chip.HIP_RESOURCE_VIEW_DESC_st*>self._ptr)[i].lastLayer = value
    @property
    def lastLayer(self):
        """Last layer index"""
        return self.get_lastLayer(0)
    @lastLayer.setter
    def lastLayer(self, unsigned int value):
        self.set_lastLayer(0,value)

    def get_reserved(self, i):
        """Get value of ``reserved`` of ``(<chip.HIP_RESOURCE_VIEW_DESC_st*>self._ptr)[i]``.
        """
        return (<chip.HIP_RESOURCE_VIEW_DESC_st*>self._ptr)[i].reserved
    # TODO add setters
    #def set_reserved(self, i, unsigned int[16] value):
    #    """Set value ``reserved`` of ``(<chip.HIP_RESOURCE_VIEW_DESC_st*>self._ptr)[i]``.
    #    """
    #    (<chip.HIP_RESOURCE_VIEW_DESC_st*>self._ptr)[i].reserved = value
    @property
    def reserved(self):
        """(undocumented)"""
        return self.get_reserved(0)
    # TODO add setters
    #@reserved.setter
    #def reserved(self, unsigned int[16] value):
    #    self.set_reserved(0,value)

    @staticmethod
    def PROPERTIES():
        return ["format","width","height","depth","firstMipmapLevel","lastMipmapLevel","firstLayer","lastLayer","reserved"]

    def __contains__(self,item):
        properties = self.PROPERTIES()
        return item in properties

    def __getitem__(self,item):
        properties = self.PROPERTIES()
        if isinstance(item,int):
            if item < 0 or item >= len(properties):
                raise IndexError()
            return getattr(self,properties[item])
        raise ValueError("'item' type must be 'int'")


HIP_RESOURCE_VIEW_DESC = HIP_RESOURCE_VIEW_DESC_st

class _hipMemcpyKind__Base(enum.IntEnum):
    """Empty enum base class that allows subclassing.
    """
    pass
class hipMemcpyKind(_hipMemcpyKind__Base):
    """hipMemcpyKind

    Attributes:
        hipMemcpyHostToHost:
            Host-to-Host Copy
        hipMemcpyHostToDevice:
            Host-to-Device Copy
        hipMemcpyDeviceToHost:
            Device-to-Host Copy
        hipMemcpyDeviceToDevice:
            Device-to-Device Copy
        hipMemcpyDefault:
            Runtime will automatically determine copy-kind based on virtual addresses.
        hipMemcpyDeviceToDeviceNoCU:
            Device-to-Device Copy without using compute units
    """
    hipMemcpyHostToHost = chip.hipMemcpyHostToHost
    hipMemcpyHostToDevice = chip.hipMemcpyHostToDevice
    hipMemcpyDeviceToHost = chip.hipMemcpyDeviceToHost
    hipMemcpyDeviceToDevice = chip.hipMemcpyDeviceToDevice
    hipMemcpyDefault = chip.hipMemcpyDefault
    hipMemcpyDeviceToDeviceNoCU = chip.hipMemcpyDeviceToDeviceNoCU
    @staticmethod
    def ctypes_type():
        """The type of the enum constants as ctypes type."""
        return ctypes.c_uint


cdef class hipPitchedPtr(hip._util.types.Pointer):
    """Python wrapper for cdef class chip.hipPitchedPtr.

    Python wrapper for cdef class chip.hipPitchedPtr.

    If this type is initialized via its `__init__` method, it allocates a
    member of the underlying C type and destroys it again if the wrapper
    type is deallocated.

    This type also serves as adapter when appearing as argument type in a
    function signature. In this case, the type can further be initialized
    from a number of Python objects:

    * `None`:

      This will set the ``self._ptr`` attribute to ``NULL``.

    * `int`:

      Interprets the integer value as pointer address and writes it to ``self._ptr``.
      No ownership is transferred.

    * `ctypes.c_void_p`:

      Takes the pointer address ``pyobj.value`` and writes it to ``self._ptr``.
      No ownership is transferred.

    * `object` that implements the `CUDA Array Interface <https://numba.readthedocs.io/en/stable/cuda/cuda_array_interface.html>`_ protocol:

      Takes the integer-valued pointer address, i.e. the first entry of the `data` tuple
      from `pyobj`'s member ``__cuda_array_interface__``  and writes it to ``self._ptr``.

    * `object` that implements the Python buffer protocol:

      If the object represents a simple contiguous array,
      writes the `Py_buffer` associated with ``pyobj`` to `self._py_buffer`,
      sets the `self._py_buffer_acquired` flag to `True`, and
      writes `self._py_buffer.buf` to the data pointer `self._ptr`.

    * `hip._util.types.Pointer`:

      Takes the pointer address ``pyobj._ptr`` and writes it to ``self._ptr``.
      No ownership is transferred.

    Type checks are performed in the above order.

    C Attributes:
        _ptr (C type ``void *``, protected):
            Stores a pointer to the data of the original Python object.
        _is_ptr_owner (C type ``bint``, protected):
            If this wrapper is the owner of the underlying data.
        _py_buffer (C type ``Py_buffer`, protected):
            Stores a pointer to the data of the original Python object.
        _py_buffer_acquired (C type ``bint``, protected):
            Stores a pointer to the data of the original Python object.
    """
    # C members declared in pxd file

    def __cinit__(self):
        self._ptr = NULL
        self._is_ptr_owner = False
        self._py_buffer_acquired = False

    cdef chip.hipPitchedPtr* getElementPtr(self):
        return <chip.hipPitchedPtr*>self._ptr

    @staticmethod
    cdef hipPitchedPtr fromPtr(void* ptr, bint owner=False):
        """Factory function to create ``hipPitchedPtr`` objects from
        given ``chip.hipPitchedPtr`` pointer.

        Setting ``owner`` flag to ``True`` causes
        the extension type to free the structure pointed to by ``ptr``
        when the wrapper object is deallocated.
        """
        # Fast call to __new__() that bypasses the __init__() constructor.
        cdef hipPitchedPtr wrapper = hipPitchedPtr.__new__(hipPitchedPtr)
        wrapper._ptr = ptr
        wrapper._is_ptr_owner = owner
        return wrapper

    @staticmethod
    def fromObj(pyobj):
        """Creates a hipPitchedPtr from a Python object.

        Derives a hipPitchedPtr from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``hipPitchedPtr`` reference, this method
        returns it directly. No new ``hipPitchedPtr`` is created in this case.
        """
        return hipPitchedPtr.fromPyobj(pyobj)

    @staticmethod
    cdef hipPitchedPtr fromPyobj(object pyobj):
        """Creates a hipPitchedPtr from a Python object.

        Derives a hipPitchedPtr from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``hipPitchedPtr`` reference, this method
        returns it directly. No new ``hipPitchedPtr`` is created in this case.

        Args:
            pyobj (object): Must be either `None`; a `hip._util.types.Pointer`; a simple, contiguous buffer according to the buffer protocol;
                            or of type `hipPitchedPtr`; `int`; or `ctypes.c_void_p`.

        Note:
            This routine does not perform a copy but returns the original ``pyobj``
            if ``pyobj`` is an instance of hipPitchedPtr!
        """
        cdef hipPitchedPtr wrapper

        if isinstance(pyobj,hipPitchedPtr):
            return pyobj
        else:
            wrapper = hipPitchedPtr.__new__(hipPitchedPtr)
            wrapper.init_from_pyobj(pyobj)
            return wrapper

    def __dealloc__(self):
        # Release the buffer handle
        if self._py_buffer_acquired is True:
            cpython.buffer.PyBuffer_Release(&self._py_buffer)
        # De-allocate if not null and flag is set
        if self._ptr is not NULL and self._is_ptr_owner is True:
            stdlib.free(self._ptr)
            self._ptr = NULL

    @staticmethod
    cdef __allocate(void** ptr):
        ptr[0] = stdlib.malloc(sizeof(chip.hipPitchedPtr))
        string.memset(<void*>ptr[0], 0, sizeof(chip.hipPitchedPtr))

        if ptr[0] is NULL:
            raise MemoryError

    @staticmethod
    cdef hipPitchedPtr new():
        """Factory function to create hipPitchedPtr objects with
        newly allocated chip.hipPitchedPtr"""
        cdef void* ptr
        hipPitchedPtr.__allocate(&ptr)
        return hipPitchedPtr.fromPtr(ptr, owner=True)

    @staticmethod
    cdef hipPitchedPtr fromValue(chip.hipPitchedPtr other):
        """Allocate new C type and copy from ``other``.
        """
        wrapper = hipPitchedPtr.new()
        string.memcpy(wrapper._ptr, &other, sizeof(chip.hipPitchedPtr))
        return wrapper

    def c_sizeof(self):
        """Returns the size of the underlying C type in bytes.
        Note:
            Implemented as function to not collide with
            autogenerated property names.
        """
        return sizeof(chip.hipPitchedPtr)

    def __int__(self):
        """Returns the data's address as long integer.
        """
        return cpython.long.PyLong_FromVoidPtr(self._ptr)

    def __repr__(self):
        return f"<hipPitchedPtr object, ptr: {int(self)}>"

    def as_c_void_p(self):
        """Returns the data's address as `ctypes.c_void_p`
        Note:
            Implemented as function to not collide with
            autogenerated property names.
        """
        return ctypes.c_void_p(int(self))

    def __init__(self,*args,**kwargs):
        """Constructor type hipPitchedPtr.

        Constructor for type hipPitchedPtr.

        Args:
            *args:
                Positional arguments. Initialize all or a subset of the member variables
                according to their order of declaration.
            **kwargs:
                Can be used to initialize member variables at construction,
                Just pass an argument expression of the form <member>=<value>
                per member that you want to initialize.
        """
        hipPitchedPtr.__allocate(&self._ptr)
        self._is_ptr_owner = True
        attribs = self.PROPERTIES()
        used_attribs = set()
        if len(args) > len(attribs):
            raise ValueError("More positional arguments specified than this type has properties.")
        for i,v in enumerate(args):
            setattr(self,attribs[i],v)
            used_attribs.add(attribs[i])
        valid_names = ", ".join(["'"+p+"'" for p in attribs])
        for k,v in kwargs.items():
            if k in used_attribs:
                raise KeyError(f"argument '{k}' has already been specified as positional argument.")
            elif k not in attribs:
                raise KeyError(f"'{k}' is no valid property name. Valid names: {valid_names}")
            setattr(self,k,v)
    def get_ptr(self, i):
        """Get value ``ptr`` of ``(<chip.hipPitchedPtr*>self._ptr)[i]``.
        """
        return hip._util.types.Pointer.fromPtr((<chip.hipPitchedPtr*>self._ptr)[i].ptr)
    def set_ptr(self, i, object value):
        """Set value ``ptr`` of ``(<chip.hipPitchedPtr*>self._ptr)[i]``.

        Note:
            This can be dangerous if the pointer is from a python object
            that is later on garbage collected.
        """
        (<chip.hipPitchedPtr*>self._ptr)[i].ptr = <void *>cpython.long.PyLong_AsVoidPtr(int(hip._util.types.Pointer.fromPyobj(value)))
    @property
    def ptr(self):
        """(undocumented)
        Note:
            Setting this ptr can be dangerous if the underlying pointer is from a python object that
            is later on garbage collected.
        """
        return self.get_ptr(0)
    @ptr.setter
    def ptr(self, object value):
        self.set_ptr(0,value)

    def get_pitch(self, i):
        """Get value ``pitch`` of ``(<chip.hipPitchedPtr*>self._ptr)[i]``.
        """
        return (<chip.hipPitchedPtr*>self._ptr)[i].pitch
    def set_pitch(self, i, unsigned long value):
        """Set value ``pitch`` of ``(<chip.hipPitchedPtr*>self._ptr)[i]``.
        """
        (<chip.hipPitchedPtr*>self._ptr)[i].pitch = value
    @property
    def pitch(self):
        """(undocumented)"""
        return self.get_pitch(0)
    @pitch.setter
    def pitch(self, unsigned long value):
        self.set_pitch(0,value)

    def get_xsize(self, i):
        """Get value ``xsize`` of ``(<chip.hipPitchedPtr*>self._ptr)[i]``.
        """
        return (<chip.hipPitchedPtr*>self._ptr)[i].xsize
    def set_xsize(self, i, unsigned long value):
        """Set value ``xsize`` of ``(<chip.hipPitchedPtr*>self._ptr)[i]``.
        """
        (<chip.hipPitchedPtr*>self._ptr)[i].xsize = value
    @property
    def xsize(self):
        """(undocumented)"""
        return self.get_xsize(0)
    @xsize.setter
    def xsize(self, unsigned long value):
        self.set_xsize(0,value)

    def get_ysize(self, i):
        """Get value ``ysize`` of ``(<chip.hipPitchedPtr*>self._ptr)[i]``.
        """
        return (<chip.hipPitchedPtr*>self._ptr)[i].ysize
    def set_ysize(self, i, unsigned long value):
        """Set value ``ysize`` of ``(<chip.hipPitchedPtr*>self._ptr)[i]``.
        """
        (<chip.hipPitchedPtr*>self._ptr)[i].ysize = value
    @property
    def ysize(self):
        """(undocumented)"""
        return self.get_ysize(0)
    @ysize.setter
    def ysize(self, unsigned long value):
        self.set_ysize(0,value)

    @staticmethod
    def PROPERTIES():
        return ["ptr","pitch","xsize","ysize"]

    def __contains__(self,item):
        properties = self.PROPERTIES()
        return item in properties

    def __getitem__(self,item):
        properties = self.PROPERTIES()
        if isinstance(item,int):
            if item < 0 or item >= len(properties):
                raise IndexError()
            return getattr(self,properties[item])
        raise ValueError("'item' type must be 'int'")


cdef class hipExtent(hip._util.types.Pointer):
    """Python wrapper for cdef class chip.hipExtent.

    Python wrapper for cdef class chip.hipExtent.

    If this type is initialized via its `__init__` method, it allocates a
    member of the underlying C type and destroys it again if the wrapper
    type is deallocated.

    This type also serves as adapter when appearing as argument type in a
    function signature. In this case, the type can further be initialized
    from a number of Python objects:

    * `None`:

      This will set the ``self._ptr`` attribute to ``NULL``.

    * `int`:

      Interprets the integer value as pointer address and writes it to ``self._ptr``.
      No ownership is transferred.

    * `ctypes.c_void_p`:

      Takes the pointer address ``pyobj.value`` and writes it to ``self._ptr``.
      No ownership is transferred.

    * `object` that implements the `CUDA Array Interface <https://numba.readthedocs.io/en/stable/cuda/cuda_array_interface.html>`_ protocol:

      Takes the integer-valued pointer address, i.e. the first entry of the `data` tuple
      from `pyobj`'s member ``__cuda_array_interface__``  and writes it to ``self._ptr``.

    * `object` that implements the Python buffer protocol:

      If the object represents a simple contiguous array,
      writes the `Py_buffer` associated with ``pyobj`` to `self._py_buffer`,
      sets the `self._py_buffer_acquired` flag to `True`, and
      writes `self._py_buffer.buf` to the data pointer `self._ptr`.

    * `hip._util.types.Pointer`:

      Takes the pointer address ``pyobj._ptr`` and writes it to ``self._ptr``.
      No ownership is transferred.

    Type checks are performed in the above order.

    C Attributes:
        _ptr (C type ``void *``, protected):
            Stores a pointer to the data of the original Python object.
        _is_ptr_owner (C type ``bint``, protected):
            If this wrapper is the owner of the underlying data.
        _py_buffer (C type ``Py_buffer`, protected):
            Stores a pointer to the data of the original Python object.
        _py_buffer_acquired (C type ``bint``, protected):
            Stores a pointer to the data of the original Python object.
    """
    # C members declared in pxd file

    def __cinit__(self):
        self._ptr = NULL
        self._is_ptr_owner = False
        self._py_buffer_acquired = False

    cdef chip.hipExtent* getElementPtr(self):
        return <chip.hipExtent*>self._ptr

    @staticmethod
    cdef hipExtent fromPtr(void* ptr, bint owner=False):
        """Factory function to create ``hipExtent`` objects from
        given ``chip.hipExtent`` pointer.

        Setting ``owner`` flag to ``True`` causes
        the extension type to free the structure pointed to by ``ptr``
        when the wrapper object is deallocated.
        """
        # Fast call to __new__() that bypasses the __init__() constructor.
        cdef hipExtent wrapper = hipExtent.__new__(hipExtent)
        wrapper._ptr = ptr
        wrapper._is_ptr_owner = owner
        return wrapper

    @staticmethod
    def fromObj(pyobj):
        """Creates a hipExtent from a Python object.

        Derives a hipExtent from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``hipExtent`` reference, this method
        returns it directly. No new ``hipExtent`` is created in this case.
        """
        return hipExtent.fromPyobj(pyobj)

    @staticmethod
    cdef hipExtent fromPyobj(object pyobj):
        """Creates a hipExtent from a Python object.

        Derives a hipExtent from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``hipExtent`` reference, this method
        returns it directly. No new ``hipExtent`` is created in this case.

        Args:
            pyobj (object): Must be either `None`; a `hip._util.types.Pointer`; a simple, contiguous buffer according to the buffer protocol;
                            or of type `hipExtent`; `int`; or `ctypes.c_void_p`.

        Note:
            This routine does not perform a copy but returns the original ``pyobj``
            if ``pyobj`` is an instance of hipExtent!
        """
        cdef hipExtent wrapper

        if isinstance(pyobj,hipExtent):
            return pyobj
        else:
            wrapper = hipExtent.__new__(hipExtent)
            wrapper.init_from_pyobj(pyobj)
            return wrapper

    def __dealloc__(self):
        # Release the buffer handle
        if self._py_buffer_acquired is True:
            cpython.buffer.PyBuffer_Release(&self._py_buffer)
        # De-allocate if not null and flag is set
        if self._ptr is not NULL and self._is_ptr_owner is True:
            stdlib.free(self._ptr)
            self._ptr = NULL

    @staticmethod
    cdef __allocate(void** ptr):
        ptr[0] = stdlib.malloc(sizeof(chip.hipExtent))
        string.memset(<void*>ptr[0], 0, sizeof(chip.hipExtent))

        if ptr[0] is NULL:
            raise MemoryError

    @staticmethod
    cdef hipExtent new():
        """Factory function to create hipExtent objects with
        newly allocated chip.hipExtent"""
        cdef void* ptr
        hipExtent.__allocate(&ptr)
        return hipExtent.fromPtr(ptr, owner=True)

    @staticmethod
    cdef hipExtent fromValue(chip.hipExtent other):
        """Allocate new C type and copy from ``other``.
        """
        wrapper = hipExtent.new()
        string.memcpy(wrapper._ptr, &other, sizeof(chip.hipExtent))
        return wrapper

    def c_sizeof(self):
        """Returns the size of the underlying C type in bytes.
        Note:
            Implemented as function to not collide with
            autogenerated property names.
        """
        return sizeof(chip.hipExtent)

    def __int__(self):
        """Returns the data's address as long integer.
        """
        return cpython.long.PyLong_FromVoidPtr(self._ptr)

    def __repr__(self):
        return f"<hipExtent object, ptr: {int(self)}>"

    def as_c_void_p(self):
        """Returns the data's address as `ctypes.c_void_p`
        Note:
            Implemented as function to not collide with
            autogenerated property names.
        """
        return ctypes.c_void_p(int(self))

    def __init__(self,*args,**kwargs):
        """Constructor type hipExtent.

        Constructor for type hipExtent.

        Args:
            *args:
                Positional arguments. Initialize all or a subset of the member variables
                according to their order of declaration.
            **kwargs:
                Can be used to initialize member variables at construction,
                Just pass an argument expression of the form <member>=<value>
                per member that you want to initialize.
        """
        hipExtent.__allocate(&self._ptr)
        self._is_ptr_owner = True
        attribs = self.PROPERTIES()
        used_attribs = set()
        if len(args) > len(attribs):
            raise ValueError("More positional arguments specified than this type has properties.")
        for i,v in enumerate(args):
            setattr(self,attribs[i],v)
            used_attribs.add(attribs[i])
        valid_names = ", ".join(["'"+p+"'" for p in attribs])
        for k,v in kwargs.items():
            if k in used_attribs:
                raise KeyError(f"argument '{k}' has already been specified as positional argument.")
            elif k not in attribs:
                raise KeyError(f"'{k}' is no valid property name. Valid names: {valid_names}")
            setattr(self,k,v)
    def get_width(self, i):
        """Get value ``width`` of ``(<chip.hipExtent*>self._ptr)[i]``.
        """
        return (<chip.hipExtent*>self._ptr)[i].width
    def set_width(self, i, unsigned long value):
        """Set value ``width`` of ``(<chip.hipExtent*>self._ptr)[i]``.
        """
        (<chip.hipExtent*>self._ptr)[i].width = value
    @property
    def width(self):
        """(undocumented)"""
        return self.get_width(0)
    @width.setter
    def width(self, unsigned long value):
        self.set_width(0,value)

    def get_height(self, i):
        """Get value ``height`` of ``(<chip.hipExtent*>self._ptr)[i]``.
        """
        return (<chip.hipExtent*>self._ptr)[i].height
    def set_height(self, i, unsigned long value):
        """Set value ``height`` of ``(<chip.hipExtent*>self._ptr)[i]``.
        """
        (<chip.hipExtent*>self._ptr)[i].height = value
    @property
    def height(self):
        """(undocumented)"""
        return self.get_height(0)
    @height.setter
    def height(self, unsigned long value):
        self.set_height(0,value)

    def get_depth(self, i):
        """Get value ``depth`` of ``(<chip.hipExtent*>self._ptr)[i]``.
        """
        return (<chip.hipExtent*>self._ptr)[i].depth
    def set_depth(self, i, unsigned long value):
        """Set value ``depth`` of ``(<chip.hipExtent*>self._ptr)[i]``.
        """
        (<chip.hipExtent*>self._ptr)[i].depth = value
    @property
    def depth(self):
        """(undocumented)"""
        return self.get_depth(0)
    @depth.setter
    def depth(self, unsigned long value):
        self.set_depth(0,value)

    @staticmethod
    def PROPERTIES():
        return ["width","height","depth"]

    def __contains__(self,item):
        properties = self.PROPERTIES()
        return item in properties

    def __getitem__(self,item):
        properties = self.PROPERTIES()
        if isinstance(item,int):
            if item < 0 or item >= len(properties):
                raise IndexError()
            return getattr(self,properties[item])
        raise ValueError("'item' type must be 'int'")


cdef class hipPos(hip._util.types.Pointer):
    """Python wrapper for cdef class chip.hipPos.

    Python wrapper for cdef class chip.hipPos.

    If this type is initialized via its `__init__` method, it allocates a
    member of the underlying C type and destroys it again if the wrapper
    type is deallocated.

    This type also serves as adapter when appearing as argument type in a
    function signature. In this case, the type can further be initialized
    from a number of Python objects:

    * `None`:

      This will set the ``self._ptr`` attribute to ``NULL``.

    * `int`:

      Interprets the integer value as pointer address and writes it to ``self._ptr``.
      No ownership is transferred.

    * `ctypes.c_void_p`:

      Takes the pointer address ``pyobj.value`` and writes it to ``self._ptr``.
      No ownership is transferred.

    * `object` that implements the `CUDA Array Interface <https://numba.readthedocs.io/en/stable/cuda/cuda_array_interface.html>`_ protocol:

      Takes the integer-valued pointer address, i.e. the first entry of the `data` tuple
      from `pyobj`'s member ``__cuda_array_interface__``  and writes it to ``self._ptr``.

    * `object` that implements the Python buffer protocol:

      If the object represents a simple contiguous array,
      writes the `Py_buffer` associated with ``pyobj`` to `self._py_buffer`,
      sets the `self._py_buffer_acquired` flag to `True`, and
      writes `self._py_buffer.buf` to the data pointer `self._ptr`.

    * `hip._util.types.Pointer`:

      Takes the pointer address ``pyobj._ptr`` and writes it to ``self._ptr``.
      No ownership is transferred.

    Type checks are performed in the above order.

    C Attributes:
        _ptr (C type ``void *``, protected):
            Stores a pointer to the data of the original Python object.
        _is_ptr_owner (C type ``bint``, protected):
            If this wrapper is the owner of the underlying data.
        _py_buffer (C type ``Py_buffer`, protected):
            Stores a pointer to the data of the original Python object.
        _py_buffer_acquired (C type ``bint``, protected):
            Stores a pointer to the data of the original Python object.
    """
    # C members declared in pxd file

    def __cinit__(self):
        self._ptr = NULL
        self._is_ptr_owner = False
        self._py_buffer_acquired = False

    cdef chip.hipPos* getElementPtr(self):
        return <chip.hipPos*>self._ptr

    @staticmethod
    cdef hipPos fromPtr(void* ptr, bint owner=False):
        """Factory function to create ``hipPos`` objects from
        given ``chip.hipPos`` pointer.

        Setting ``owner`` flag to ``True`` causes
        the extension type to free the structure pointed to by ``ptr``
        when the wrapper object is deallocated.
        """
        # Fast call to __new__() that bypasses the __init__() constructor.
        cdef hipPos wrapper = hipPos.__new__(hipPos)
        wrapper._ptr = ptr
        wrapper._is_ptr_owner = owner
        return wrapper

    @staticmethod
    def fromObj(pyobj):
        """Creates a hipPos from a Python object.

        Derives a hipPos from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``hipPos`` reference, this method
        returns it directly. No new ``hipPos`` is created in this case.
        """
        return hipPos.fromPyobj(pyobj)

    @staticmethod
    cdef hipPos fromPyobj(object pyobj):
        """Creates a hipPos from a Python object.

        Derives a hipPos from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``hipPos`` reference, this method
        returns it directly. No new ``hipPos`` is created in this case.

        Args:
            pyobj (object): Must be either `None`; a `hip._util.types.Pointer`; a simple, contiguous buffer according to the buffer protocol;
                            or of type `hipPos`; `int`; or `ctypes.c_void_p`.

        Note:
            This routine does not perform a copy but returns the original ``pyobj``
            if ``pyobj`` is an instance of hipPos!
        """
        cdef hipPos wrapper

        if isinstance(pyobj,hipPos):
            return pyobj
        else:
            wrapper = hipPos.__new__(hipPos)
            wrapper.init_from_pyobj(pyobj)
            return wrapper

    def __dealloc__(self):
        # Release the buffer handle
        if self._py_buffer_acquired is True:
            cpython.buffer.PyBuffer_Release(&self._py_buffer)
        # De-allocate if not null and flag is set
        if self._ptr is not NULL and self._is_ptr_owner is True:
            stdlib.free(self._ptr)
            self._ptr = NULL

    @staticmethod
    cdef __allocate(void** ptr):
        ptr[0] = stdlib.malloc(sizeof(chip.hipPos))
        string.memset(<void*>ptr[0], 0, sizeof(chip.hipPos))

        if ptr[0] is NULL:
            raise MemoryError

    @staticmethod
    cdef hipPos new():
        """Factory function to create hipPos objects with
        newly allocated chip.hipPos"""
        cdef void* ptr
        hipPos.__allocate(&ptr)
        return hipPos.fromPtr(ptr, owner=True)

    @staticmethod
    cdef hipPos fromValue(chip.hipPos other):
        """Allocate new C type and copy from ``other``.
        """
        wrapper = hipPos.new()
        string.memcpy(wrapper._ptr, &other, sizeof(chip.hipPos))
        return wrapper

    def c_sizeof(self):
        """Returns the size of the underlying C type in bytes.
        Note:
            Implemented as function to not collide with
            autogenerated property names.
        """
        return sizeof(chip.hipPos)

    def __int__(self):
        """Returns the data's address as long integer.
        """
        return cpython.long.PyLong_FromVoidPtr(self._ptr)

    def __repr__(self):
        return f"<hipPos object, ptr: {int(self)}>"

    def as_c_void_p(self):
        """Returns the data's address as `ctypes.c_void_p`
        Note:
            Implemented as function to not collide with
            autogenerated property names.
        """
        return ctypes.c_void_p(int(self))

    def __init__(self,*args,**kwargs):
        """Constructor type hipPos.

        Constructor for type hipPos.

        Args:
            *args:
                Positional arguments. Initialize all or a subset of the member variables
                according to their order of declaration.
            **kwargs:
                Can be used to initialize member variables at construction,
                Just pass an argument expression of the form <member>=<value>
                per member that you want to initialize.
        """
        hipPos.__allocate(&self._ptr)
        self._is_ptr_owner = True
        attribs = self.PROPERTIES()
        used_attribs = set()
        if len(args) > len(attribs):
            raise ValueError("More positional arguments specified than this type has properties.")
        for i,v in enumerate(args):
            setattr(self,attribs[i],v)
            used_attribs.add(attribs[i])
        valid_names = ", ".join(["'"+p+"'" for p in attribs])
        for k,v in kwargs.items():
            if k in used_attribs:
                raise KeyError(f"argument '{k}' has already been specified as positional argument.")
            elif k not in attribs:
                raise KeyError(f"'{k}' is no valid property name. Valid names: {valid_names}")
            setattr(self,k,v)
    def get_x(self, i):
        """Get value ``x`` of ``(<chip.hipPos*>self._ptr)[i]``.
        """
        return (<chip.hipPos*>self._ptr)[i].x
    def set_x(self, i, unsigned long value):
        """Set value ``x`` of ``(<chip.hipPos*>self._ptr)[i]``.
        """
        (<chip.hipPos*>self._ptr)[i].x = value
    @property
    def x(self):
        """(undocumented)"""
        return self.get_x(0)
    @x.setter
    def x(self, unsigned long value):
        self.set_x(0,value)

    def get_y(self, i):
        """Get value ``y`` of ``(<chip.hipPos*>self._ptr)[i]``.
        """
        return (<chip.hipPos*>self._ptr)[i].y
    def set_y(self, i, unsigned long value):
        """Set value ``y`` of ``(<chip.hipPos*>self._ptr)[i]``.
        """
        (<chip.hipPos*>self._ptr)[i].y = value
    @property
    def y(self):
        """(undocumented)"""
        return self.get_y(0)
    @y.setter
    def y(self, unsigned long value):
        self.set_y(0,value)

    def get_z(self, i):
        """Get value ``z`` of ``(<chip.hipPos*>self._ptr)[i]``.
        """
        return (<chip.hipPos*>self._ptr)[i].z
    def set_z(self, i, unsigned long value):
        """Set value ``z`` of ``(<chip.hipPos*>self._ptr)[i]``.
        """
        (<chip.hipPos*>self._ptr)[i].z = value
    @property
    def z(self):
        """(undocumented)"""
        return self.get_z(0)
    @z.setter
    def z(self, unsigned long value):
        self.set_z(0,value)

    @staticmethod
    def PROPERTIES():
        return ["x","y","z"]

    def __contains__(self,item):
        properties = self.PROPERTIES()
        return item in properties

    def __getitem__(self,item):
        properties = self.PROPERTIES()
        if isinstance(item,int):
            if item < 0 or item >= len(properties):
                raise IndexError()
            return getattr(self,properties[item])
        raise ValueError("'item' type must be 'int'")


cdef class hipMemcpy3DParms(hip._util.types.Pointer):
    """Python wrapper for cdef class chip.hipMemcpy3DParms.

    Python wrapper for cdef class chip.hipMemcpy3DParms.

    If this type is initialized via its `__init__` method, it allocates a
    member of the underlying C type and destroys it again if the wrapper
    type is deallocated.

    This type also serves as adapter when appearing as argument type in a
    function signature. In this case, the type can further be initialized
    from a number of Python objects:

    * `None`:

      This will set the ``self._ptr`` attribute to ``NULL``.

    * `int`:

      Interprets the integer value as pointer address and writes it to ``self._ptr``.
      No ownership is transferred.

    * `ctypes.c_void_p`:

      Takes the pointer address ``pyobj.value`` and writes it to ``self._ptr``.
      No ownership is transferred.

    * `object` that implements the `CUDA Array Interface <https://numba.readthedocs.io/en/stable/cuda/cuda_array_interface.html>`_ protocol:

      Takes the integer-valued pointer address, i.e. the first entry of the `data` tuple
      from `pyobj`'s member ``__cuda_array_interface__``  and writes it to ``self._ptr``.

    * `object` that implements the Python buffer protocol:

      If the object represents a simple contiguous array,
      writes the `Py_buffer` associated with ``pyobj`` to `self._py_buffer`,
      sets the `self._py_buffer_acquired` flag to `True`, and
      writes `self._py_buffer.buf` to the data pointer `self._ptr`.

    * `hip._util.types.Pointer`:

      Takes the pointer address ``pyobj._ptr`` and writes it to ``self._ptr``.
      No ownership is transferred.

    Type checks are performed in the above order.

    C Attributes:
        _ptr (C type ``void *``, protected):
            Stores a pointer to the data of the original Python object.
        _is_ptr_owner (C type ``bint``, protected):
            If this wrapper is the owner of the underlying data.
        _py_buffer (C type ``Py_buffer`, protected):
            Stores a pointer to the data of the original Python object.
        _py_buffer_acquired (C type ``bint``, protected):
            Stores a pointer to the data of the original Python object.
    """
    # C members declared in pxd file

    def __cinit__(self):
        self._ptr = NULL
        self._is_ptr_owner = False
        self._py_buffer_acquired = False

    cdef chip.hipMemcpy3DParms* getElementPtr(self):
        return <chip.hipMemcpy3DParms*>self._ptr

    @staticmethod
    cdef hipMemcpy3DParms fromPtr(void* ptr, bint owner=False):
        """Factory function to create ``hipMemcpy3DParms`` objects from
        given ``chip.hipMemcpy3DParms`` pointer.

        Setting ``owner`` flag to ``True`` causes
        the extension type to free the structure pointed to by ``ptr``
        when the wrapper object is deallocated.
        """
        # Fast call to __new__() that bypasses the __init__() constructor.
        cdef hipMemcpy3DParms wrapper = hipMemcpy3DParms.__new__(hipMemcpy3DParms)
        wrapper._ptr = ptr
        wrapper._is_ptr_owner = owner
        return wrapper

    @staticmethod
    def fromObj(pyobj):
        """Creates a hipMemcpy3DParms from a Python object.

        Derives a hipMemcpy3DParms from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``hipMemcpy3DParms`` reference, this method
        returns it directly. No new ``hipMemcpy3DParms`` is created in this case.
        """
        return hipMemcpy3DParms.fromPyobj(pyobj)

    @staticmethod
    cdef hipMemcpy3DParms fromPyobj(object pyobj):
        """Creates a hipMemcpy3DParms from a Python object.

        Derives a hipMemcpy3DParms from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``hipMemcpy3DParms`` reference, this method
        returns it directly. No new ``hipMemcpy3DParms`` is created in this case.

        Args:
            pyobj (object): Must be either `None`; a `hip._util.types.Pointer`; a simple, contiguous buffer according to the buffer protocol;
                            or of type `hipMemcpy3DParms`; `int`; or `ctypes.c_void_p`.

        Note:
            This routine does not perform a copy but returns the original ``pyobj``
            if ``pyobj`` is an instance of hipMemcpy3DParms!
        """
        cdef hipMemcpy3DParms wrapper

        if isinstance(pyobj,hipMemcpy3DParms):
            return pyobj
        else:
            wrapper = hipMemcpy3DParms.__new__(hipMemcpy3DParms)
            wrapper.init_from_pyobj(pyobj)
            return wrapper

    def __dealloc__(self):
        # Release the buffer handle
        if self._py_buffer_acquired is True:
            cpython.buffer.PyBuffer_Release(&self._py_buffer)
        # De-allocate if not null and flag is set
        if self._ptr is not NULL and self._is_ptr_owner is True:
            stdlib.free(self._ptr)
            self._ptr = NULL

    @staticmethod
    cdef __allocate(void** ptr):
        ptr[0] = stdlib.malloc(sizeof(chip.hipMemcpy3DParms))
        string.memset(<void*>ptr[0], 0, sizeof(chip.hipMemcpy3DParms))

        if ptr[0] is NULL:
            raise MemoryError

    @staticmethod
    cdef hipMemcpy3DParms new():
        """Factory function to create hipMemcpy3DParms objects with
        newly allocated chip.hipMemcpy3DParms"""
        cdef void* ptr
        hipMemcpy3DParms.__allocate(&ptr)
        return hipMemcpy3DParms.fromPtr(ptr, owner=True)

    @staticmethod
    cdef hipMemcpy3DParms fromValue(chip.hipMemcpy3DParms other):
        """Allocate new C type and copy from ``other``.
        """
        wrapper = hipMemcpy3DParms.new()
        string.memcpy(wrapper._ptr, &other, sizeof(chip.hipMemcpy3DParms))
        return wrapper

    def c_sizeof(self):
        """Returns the size of the underlying C type in bytes.
        Note:
            Implemented as function to not collide with
            autogenerated property names.
        """
        return sizeof(chip.hipMemcpy3DParms)

    def __int__(self):
        """Returns the data's address as long integer.
        """
        return cpython.long.PyLong_FromVoidPtr(self._ptr)

    def __repr__(self):
        return f"<hipMemcpy3DParms object, ptr: {int(self)}>"

    def as_c_void_p(self):
        """Returns the data's address as `ctypes.c_void_p`
        Note:
            Implemented as function to not collide with
            autogenerated property names.
        """
        return ctypes.c_void_p(int(self))

    def __init__(self,**kwargs):
        """Constructor type hipMemcpy3DParms.

        Constructor for type hipMemcpy3DParms.

        Args:
            **kwargs:
                Can be used to initialize member variables at construction,
                Just pass an argument expression of the form <member>=<value>
                per member that you want to initialize.
        """
        hipMemcpy3DParms.__allocate(&self._ptr)
        self._is_ptr_owner = True
        attribs = self.PROPERTIES()
        used_attribs = set()
        valid_names = ", ".join(["'"+p+"'" for p in attribs])
        for k,v in kwargs.items():
            if k in used_attribs:
                raise KeyError(f"argument '{k}' has already been specified as positional argument.")
            elif k not in attribs:
                raise KeyError(f"'{k}' is no valid property name. Valid names: {valid_names}")
            setattr(self,k,v)
    def get_srcPos(self, i):
        """Get value of ``srcPos`` of ``(<chip.hipMemcpy3DParms*>self._ptr)[i]``.
        """
        return hipPos.fromPtr(&(<chip.hipMemcpy3DParms*>self._ptr)[i].srcPos)
    @property
    def srcPos(self):
        """(undocumented)"""
        return self.get_srcPos(0)

    def get_srcPtr(self, i):
        """Get value of ``srcPtr`` of ``(<chip.hipMemcpy3DParms*>self._ptr)[i]``.
        """
        return hipPitchedPtr.fromPtr(&(<chip.hipMemcpy3DParms*>self._ptr)[i].srcPtr)
    @property
    def srcPtr(self):
        """(undocumented)"""
        return self.get_srcPtr(0)

    def get_dstPos(self, i):
        """Get value of ``dstPos`` of ``(<chip.hipMemcpy3DParms*>self._ptr)[i]``.
        """
        return hipPos.fromPtr(&(<chip.hipMemcpy3DParms*>self._ptr)[i].dstPos)
    @property
    def dstPos(self):
        """(undocumented)"""
        return self.get_dstPos(0)

    def get_dstPtr(self, i):
        """Get value of ``dstPtr`` of ``(<chip.hipMemcpy3DParms*>self._ptr)[i]``.
        """
        return hipPitchedPtr.fromPtr(&(<chip.hipMemcpy3DParms*>self._ptr)[i].dstPtr)
    @property
    def dstPtr(self):
        """(undocumented)"""
        return self.get_dstPtr(0)

    def get_extent(self, i):
        """Get value of ``extent`` of ``(<chip.hipMemcpy3DParms*>self._ptr)[i]``.
        """
        return hipExtent.fromPtr(&(<chip.hipMemcpy3DParms*>self._ptr)[i].extent)
    @property
    def extent(self):
        """(undocumented)"""
        return self.get_extent(0)

    def get_kind(self, i):
        """Get value of ``kind`` of ``(<chip.hipMemcpy3DParms*>self._ptr)[i]``.
        """
        return hipMemcpyKind((<chip.hipMemcpy3DParms*>self._ptr)[i].kind)
    def set_kind(self, i, value):
        """Set value ``kind`` of ``(<chip.hipMemcpy3DParms*>self._ptr)[i]``.
        """
        if not isinstance(value, hipMemcpyKind):
            raise TypeError("'value' must be of type 'hipMemcpyKind'")
        (<chip.hipMemcpy3DParms*>self._ptr)[i].kind = value.value
    @property
    def kind(self):
        """(undocumented)"""
        return self.get_kind(0)
    @kind.setter
    def kind(self, value):
        self.set_kind(0,value)

    @staticmethod
    def PROPERTIES():
        return ["srcPos","srcPtr","dstPos","dstPtr","extent","kind"]

    def __contains__(self,item):
        properties = self.PROPERTIES()
        return item in properties

    def __getitem__(self,item):
        properties = self.PROPERTIES()
        if isinstance(item,int):
            if item < 0 or item >= len(properties):
                raise IndexError()
            return getattr(self,properties[item])
        raise ValueError("'item' type must be 'int'")


cdef class HIP_MEMCPY3D(hip._util.types.Pointer):
    """Python wrapper for cdef class chip.HIP_MEMCPY3D.

    Python wrapper for cdef class chip.HIP_MEMCPY3D.

    If this type is initialized via its `__init__` method, it allocates a
    member of the underlying C type and destroys it again if the wrapper
    type is deallocated.

    This type also serves as adapter when appearing as argument type in a
    function signature. In this case, the type can further be initialized
    from a number of Python objects:

    * `None`:

      This will set the ``self._ptr`` attribute to ``NULL``.

    * `int`:

      Interprets the integer value as pointer address and writes it to ``self._ptr``.
      No ownership is transferred.

    * `ctypes.c_void_p`:

      Takes the pointer address ``pyobj.value`` and writes it to ``self._ptr``.
      No ownership is transferred.

    * `object` that implements the `CUDA Array Interface <https://numba.readthedocs.io/en/stable/cuda/cuda_array_interface.html>`_ protocol:

      Takes the integer-valued pointer address, i.e. the first entry of the `data` tuple
      from `pyobj`'s member ``__cuda_array_interface__``  and writes it to ``self._ptr``.

    * `object` that implements the Python buffer protocol:

      If the object represents a simple contiguous array,
      writes the `Py_buffer` associated with ``pyobj`` to `self._py_buffer`,
      sets the `self._py_buffer_acquired` flag to `True`, and
      writes `self._py_buffer.buf` to the data pointer `self._ptr`.

    * `hip._util.types.Pointer`:

      Takes the pointer address ``pyobj._ptr`` and writes it to ``self._ptr``.
      No ownership is transferred.

    Type checks are performed in the above order.

    C Attributes:
        _ptr (C type ``void *``, protected):
            Stores a pointer to the data of the original Python object.
        _is_ptr_owner (C type ``bint``, protected):
            If this wrapper is the owner of the underlying data.
        _py_buffer (C type ``Py_buffer`, protected):
            Stores a pointer to the data of the original Python object.
        _py_buffer_acquired (C type ``bint``, protected):
            Stores a pointer to the data of the original Python object.
    """
    # C members declared in pxd file

    def __cinit__(self):
        self._ptr = NULL
        self._is_ptr_owner = False
        self._py_buffer_acquired = False

    cdef chip.HIP_MEMCPY3D* getElementPtr(self):
        return <chip.HIP_MEMCPY3D*>self._ptr

    @staticmethod
    cdef HIP_MEMCPY3D fromPtr(void* ptr, bint owner=False):
        """Factory function to create ``HIP_MEMCPY3D`` objects from
        given ``chip.HIP_MEMCPY3D`` pointer.

        Setting ``owner`` flag to ``True`` causes
        the extension type to free the structure pointed to by ``ptr``
        when the wrapper object is deallocated.
        """
        # Fast call to __new__() that bypasses the __init__() constructor.
        cdef HIP_MEMCPY3D wrapper = HIP_MEMCPY3D.__new__(HIP_MEMCPY3D)
        wrapper._ptr = ptr
        wrapper._is_ptr_owner = owner
        return wrapper

    @staticmethod
    def fromObj(pyobj):
        """Creates a HIP_MEMCPY3D from a Python object.

        Derives a HIP_MEMCPY3D from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``HIP_MEMCPY3D`` reference, this method
        returns it directly. No new ``HIP_MEMCPY3D`` is created in this case.
        """
        return HIP_MEMCPY3D.fromPyobj(pyobj)

    @staticmethod
    cdef HIP_MEMCPY3D fromPyobj(object pyobj):
        """Creates a HIP_MEMCPY3D from a Python object.

        Derives a HIP_MEMCPY3D from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``HIP_MEMCPY3D`` reference, this method
        returns it directly. No new ``HIP_MEMCPY3D`` is created in this case.

        Args:
            pyobj (object): Must be either `None`; a `hip._util.types.Pointer`; a simple, contiguous buffer according to the buffer protocol;
                            or of type `HIP_MEMCPY3D`; `int`; or `ctypes.c_void_p`.

        Note:
            This routine does not perform a copy but returns the original ``pyobj``
            if ``pyobj`` is an instance of HIP_MEMCPY3D!
        """
        cdef HIP_MEMCPY3D wrapper

        if isinstance(pyobj,HIP_MEMCPY3D):
            return pyobj
        else:
            wrapper = HIP_MEMCPY3D.__new__(HIP_MEMCPY3D)
            wrapper.init_from_pyobj(pyobj)
            return wrapper

    def __dealloc__(self):
        # Release the buffer handle
        if self._py_buffer_acquired is True:
            cpython.buffer.PyBuffer_Release(&self._py_buffer)
        # De-allocate if not null and flag is set
        if self._ptr is not NULL and self._is_ptr_owner is True:
            stdlib.free(self._ptr)
            self._ptr = NULL

    @staticmethod
    cdef __allocate(void** ptr):
        ptr[0] = stdlib.malloc(sizeof(chip.HIP_MEMCPY3D))
        string.memset(<void*>ptr[0], 0, sizeof(chip.HIP_MEMCPY3D))

        if ptr[0] is NULL:
            raise MemoryError

    @staticmethod
    cdef HIP_MEMCPY3D new():
        """Factory function to create HIP_MEMCPY3D objects with
        newly allocated chip.HIP_MEMCPY3D"""
        cdef void* ptr
        HIP_MEMCPY3D.__allocate(&ptr)
        return HIP_MEMCPY3D.fromPtr(ptr, owner=True)

    @staticmethod
    cdef HIP_MEMCPY3D fromValue(chip.HIP_MEMCPY3D other):
        """Allocate new C type and copy from ``other``.
        """
        wrapper = HIP_MEMCPY3D.new()
        string.memcpy(wrapper._ptr, &other, sizeof(chip.HIP_MEMCPY3D))
        return wrapper

    def c_sizeof(self):
        """Returns the size of the underlying C type in bytes.
        Note:
            Implemented as function to not collide with
            autogenerated property names.
        """
        return sizeof(chip.HIP_MEMCPY3D)

    def __int__(self):
        """Returns the data's address as long integer.
        """
        return cpython.long.PyLong_FromVoidPtr(self._ptr)

    def __repr__(self):
        return f"<HIP_MEMCPY3D object, ptr: {int(self)}>"

    def as_c_void_p(self):
        """Returns the data's address as `ctypes.c_void_p`
        Note:
            Implemented as function to not collide with
            autogenerated property names.
        """
        return ctypes.c_void_p(int(self))

    def __init__(self,**kwargs):
        """Constructor type HIP_MEMCPY3D.

        Constructor for type HIP_MEMCPY3D.

        Args:
            **kwargs:
                Can be used to initialize member variables at construction,
                Just pass an argument expression of the form <member>=<value>
                per member that you want to initialize.
        """
        HIP_MEMCPY3D.__allocate(&self._ptr)
        self._is_ptr_owner = True
        attribs = self.PROPERTIES()
        used_attribs = set()
        valid_names = ", ".join(["'"+p+"'" for p in attribs])
        for k,v in kwargs.items():
            if k in used_attribs:
                raise KeyError(f"argument '{k}' has already been specified as positional argument.")
            elif k not in attribs:
                raise KeyError(f"'{k}' is no valid property name. Valid names: {valid_names}")
            setattr(self,k,v)
    def get_srcXInBytes(self, i):
        """Get value ``srcXInBytes`` of ``(<chip.HIP_MEMCPY3D*>self._ptr)[i]``.
        """
        return (<chip.HIP_MEMCPY3D*>self._ptr)[i].srcXInBytes
    def set_srcXInBytes(self, i, unsigned long value):
        """Set value ``srcXInBytes`` of ``(<chip.HIP_MEMCPY3D*>self._ptr)[i]``.
        """
        (<chip.HIP_MEMCPY3D*>self._ptr)[i].srcXInBytes = value
    @property
    def srcXInBytes(self):
        """(undocumented)"""
        return self.get_srcXInBytes(0)
    @srcXInBytes.setter
    def srcXInBytes(self, unsigned long value):
        self.set_srcXInBytes(0,value)

    def get_srcY(self, i):
        """Get value ``srcY`` of ``(<chip.HIP_MEMCPY3D*>self._ptr)[i]``.
        """
        return (<chip.HIP_MEMCPY3D*>self._ptr)[i].srcY
    def set_srcY(self, i, unsigned long value):
        """Set value ``srcY`` of ``(<chip.HIP_MEMCPY3D*>self._ptr)[i]``.
        """
        (<chip.HIP_MEMCPY3D*>self._ptr)[i].srcY = value
    @property
    def srcY(self):
        """(undocumented)"""
        return self.get_srcY(0)
    @srcY.setter
    def srcY(self, unsigned long value):
        self.set_srcY(0,value)

    def get_srcZ(self, i):
        """Get value ``srcZ`` of ``(<chip.HIP_MEMCPY3D*>self._ptr)[i]``.
        """
        return (<chip.HIP_MEMCPY3D*>self._ptr)[i].srcZ
    def set_srcZ(self, i, unsigned long value):
        """Set value ``srcZ`` of ``(<chip.HIP_MEMCPY3D*>self._ptr)[i]``.
        """
        (<chip.HIP_MEMCPY3D*>self._ptr)[i].srcZ = value
    @property
    def srcZ(self):
        """(undocumented)"""
        return self.get_srcZ(0)
    @srcZ.setter
    def srcZ(self, unsigned long value):
        self.set_srcZ(0,value)

    def get_srcLOD(self, i):
        """Get value ``srcLOD`` of ``(<chip.HIP_MEMCPY3D*>self._ptr)[i]``.
        """
        return (<chip.HIP_MEMCPY3D*>self._ptr)[i].srcLOD
    def set_srcLOD(self, i, unsigned long value):
        """Set value ``srcLOD`` of ``(<chip.HIP_MEMCPY3D*>self._ptr)[i]``.
        """
        (<chip.HIP_MEMCPY3D*>self._ptr)[i].srcLOD = value
    @property
    def srcLOD(self):
        """(undocumented)"""
        return self.get_srcLOD(0)
    @srcLOD.setter
    def srcLOD(self, unsigned long value):
        self.set_srcLOD(0,value)

    def get_srcMemoryType(self, i):
        """Get value of ``srcMemoryType`` of ``(<chip.HIP_MEMCPY3D*>self._ptr)[i]``.
        """
        return hipMemoryType((<chip.HIP_MEMCPY3D*>self._ptr)[i].srcMemoryType)
    def set_srcMemoryType(self, i, value):
        """Set value ``srcMemoryType`` of ``(<chip.HIP_MEMCPY3D*>self._ptr)[i]``.
        """
        if not isinstance(value, hipMemoryType):
            raise TypeError("'value' must be of type 'hipMemoryType'")
        (<chip.HIP_MEMCPY3D*>self._ptr)[i].srcMemoryType = value.value
    @property
    def srcMemoryType(self):
        """(undocumented)"""
        return self.get_srcMemoryType(0)
    @srcMemoryType.setter
    def srcMemoryType(self, value):
        self.set_srcMemoryType(0,value)

    def get_srcHost(self, i):
        """Get value ``srcHost`` of ``(<chip.HIP_MEMCPY3D*>self._ptr)[i]``.
        """
        return hip._util.types.Pointer.fromPtr((<chip.HIP_MEMCPY3D*>self._ptr)[i].srcHost)
    def set_srcHost(self, i, object value):
        """Set value ``srcHost`` of ``(<chip.HIP_MEMCPY3D*>self._ptr)[i]``.

        Note:
            This can be dangerous if the pointer is from a python object
            that is later on garbage collected.
        """
        (<chip.HIP_MEMCPY3D*>self._ptr)[i].srcHost = <const void *>cpython.long.PyLong_AsVoidPtr(int(hip._util.types.Pointer.fromPyobj(value)))
    @property
    def srcHost(self):
        """(undocumented)
        Note:
            Setting this srcHost can be dangerous if the underlying pointer is from a python object that
            is later on garbage collected.
        """
        return self.get_srcHost(0)
    @srcHost.setter
    def srcHost(self, object value):
        self.set_srcHost(0,value)

    def get_srcDevice(self, i):
        """Get value ``srcDevice`` of ``(<chip.HIP_MEMCPY3D*>self._ptr)[i]``.
        """
        return hip._util.types.Pointer.fromPtr((<chip.HIP_MEMCPY3D*>self._ptr)[i].srcDevice)
    def set_srcDevice(self, i, object value):
        """Set value ``srcDevice`` of ``(<chip.HIP_MEMCPY3D*>self._ptr)[i]``.

        Note:
            This can be dangerous if the pointer is from a python object
            that is later on garbage collected.
        """
        (<chip.HIP_MEMCPY3D*>self._ptr)[i].srcDevice = <void *>cpython.long.PyLong_AsVoidPtr(int(hip._util.types.Pointer.fromPyobj(value)))
    @property
    def srcDevice(self):
        """(undocumented)
        Note:
            Setting this srcDevice can be dangerous if the underlying pointer is from a python object that
            is later on garbage collected.
        """
        return self.get_srcDevice(0)
    @srcDevice.setter
    def srcDevice(self, object value):
        self.set_srcDevice(0,value)

    def get_srcPitch(self, i):
        """Get value ``srcPitch`` of ``(<chip.HIP_MEMCPY3D*>self._ptr)[i]``.
        """
        return (<chip.HIP_MEMCPY3D*>self._ptr)[i].srcPitch
    def set_srcPitch(self, i, unsigned long value):
        """Set value ``srcPitch`` of ``(<chip.HIP_MEMCPY3D*>self._ptr)[i]``.
        """
        (<chip.HIP_MEMCPY3D*>self._ptr)[i].srcPitch = value
    @property
    def srcPitch(self):
        """(undocumented)"""
        return self.get_srcPitch(0)
    @srcPitch.setter
    def srcPitch(self, unsigned long value):
        self.set_srcPitch(0,value)

    def get_srcHeight(self, i):
        """Get value ``srcHeight`` of ``(<chip.HIP_MEMCPY3D*>self._ptr)[i]``.
        """
        return (<chip.HIP_MEMCPY3D*>self._ptr)[i].srcHeight
    def set_srcHeight(self, i, unsigned long value):
        """Set value ``srcHeight`` of ``(<chip.HIP_MEMCPY3D*>self._ptr)[i]``.
        """
        (<chip.HIP_MEMCPY3D*>self._ptr)[i].srcHeight = value
    @property
    def srcHeight(self):
        """(undocumented)"""
        return self.get_srcHeight(0)
    @srcHeight.setter
    def srcHeight(self, unsigned long value):
        self.set_srcHeight(0,value)

    def get_dstXInBytes(self, i):
        """Get value ``dstXInBytes`` of ``(<chip.HIP_MEMCPY3D*>self._ptr)[i]``.
        """
        return (<chip.HIP_MEMCPY3D*>self._ptr)[i].dstXInBytes
    def set_dstXInBytes(self, i, unsigned long value):
        """Set value ``dstXInBytes`` of ``(<chip.HIP_MEMCPY3D*>self._ptr)[i]``.
        """
        (<chip.HIP_MEMCPY3D*>self._ptr)[i].dstXInBytes = value
    @property
    def dstXInBytes(self):
        """(undocumented)"""
        return self.get_dstXInBytes(0)
    @dstXInBytes.setter
    def dstXInBytes(self, unsigned long value):
        self.set_dstXInBytes(0,value)

    def get_dstY(self, i):
        """Get value ``dstY`` of ``(<chip.HIP_MEMCPY3D*>self._ptr)[i]``.
        """
        return (<chip.HIP_MEMCPY3D*>self._ptr)[i].dstY
    def set_dstY(self, i, unsigned long value):
        """Set value ``dstY`` of ``(<chip.HIP_MEMCPY3D*>self._ptr)[i]``.
        """
        (<chip.HIP_MEMCPY3D*>self._ptr)[i].dstY = value
    @property
    def dstY(self):
        """(undocumented)"""
        return self.get_dstY(0)
    @dstY.setter
    def dstY(self, unsigned long value):
        self.set_dstY(0,value)

    def get_dstZ(self, i):
        """Get value ``dstZ`` of ``(<chip.HIP_MEMCPY3D*>self._ptr)[i]``.
        """
        return (<chip.HIP_MEMCPY3D*>self._ptr)[i].dstZ
    def set_dstZ(self, i, unsigned long value):
        """Set value ``dstZ`` of ``(<chip.HIP_MEMCPY3D*>self._ptr)[i]``.
        """
        (<chip.HIP_MEMCPY3D*>self._ptr)[i].dstZ = value
    @property
    def dstZ(self):
        """(undocumented)"""
        return self.get_dstZ(0)
    @dstZ.setter
    def dstZ(self, unsigned long value):
        self.set_dstZ(0,value)

    def get_dstLOD(self, i):
        """Get value ``dstLOD`` of ``(<chip.HIP_MEMCPY3D*>self._ptr)[i]``.
        """
        return (<chip.HIP_MEMCPY3D*>self._ptr)[i].dstLOD
    def set_dstLOD(self, i, unsigned long value):
        """Set value ``dstLOD`` of ``(<chip.HIP_MEMCPY3D*>self._ptr)[i]``.
        """
        (<chip.HIP_MEMCPY3D*>self._ptr)[i].dstLOD = value
    @property
    def dstLOD(self):
        """(undocumented)"""
        return self.get_dstLOD(0)
    @dstLOD.setter
    def dstLOD(self, unsigned long value):
        self.set_dstLOD(0,value)

    def get_dstMemoryType(self, i):
        """Get value of ``dstMemoryType`` of ``(<chip.HIP_MEMCPY3D*>self._ptr)[i]``.
        """
        return hipMemoryType((<chip.HIP_MEMCPY3D*>self._ptr)[i].dstMemoryType)
    def set_dstMemoryType(self, i, value):
        """Set value ``dstMemoryType`` of ``(<chip.HIP_MEMCPY3D*>self._ptr)[i]``.
        """
        if not isinstance(value, hipMemoryType):
            raise TypeError("'value' must be of type 'hipMemoryType'")
        (<chip.HIP_MEMCPY3D*>self._ptr)[i].dstMemoryType = value.value
    @property
    def dstMemoryType(self):
        """(undocumented)"""
        return self.get_dstMemoryType(0)
    @dstMemoryType.setter
    def dstMemoryType(self, value):
        self.set_dstMemoryType(0,value)

    def get_dstHost(self, i):
        """Get value ``dstHost`` of ``(<chip.HIP_MEMCPY3D*>self._ptr)[i]``.
        """
        return hip._util.types.Pointer.fromPtr((<chip.HIP_MEMCPY3D*>self._ptr)[i].dstHost)
    def set_dstHost(self, i, object value):
        """Set value ``dstHost`` of ``(<chip.HIP_MEMCPY3D*>self._ptr)[i]``.

        Note:
            This can be dangerous if the pointer is from a python object
            that is later on garbage collected.
        """
        (<chip.HIP_MEMCPY3D*>self._ptr)[i].dstHost = <void *>cpython.long.PyLong_AsVoidPtr(int(hip._util.types.Pointer.fromPyobj(value)))
    @property
    def dstHost(self):
        """(undocumented)
        Note:
            Setting this dstHost can be dangerous if the underlying pointer is from a python object that
            is later on garbage collected.
        """
        return self.get_dstHost(0)
    @dstHost.setter
    def dstHost(self, object value):
        self.set_dstHost(0,value)

    def get_dstDevice(self, i):
        """Get value ``dstDevice`` of ``(<chip.HIP_MEMCPY3D*>self._ptr)[i]``.
        """
        return hip._util.types.Pointer.fromPtr((<chip.HIP_MEMCPY3D*>self._ptr)[i].dstDevice)
    def set_dstDevice(self, i, object value):
        """Set value ``dstDevice`` of ``(<chip.HIP_MEMCPY3D*>self._ptr)[i]``.

        Note:
            This can be dangerous if the pointer is from a python object
            that is later on garbage collected.
        """
        (<chip.HIP_MEMCPY3D*>self._ptr)[i].dstDevice = <void *>cpython.long.PyLong_AsVoidPtr(int(hip._util.types.Pointer.fromPyobj(value)))
    @property
    def dstDevice(self):
        """(undocumented)
        Note:
            Setting this dstDevice can be dangerous if the underlying pointer is from a python object that
            is later on garbage collected.
        """
        return self.get_dstDevice(0)
    @dstDevice.setter
    def dstDevice(self, object value):
        self.set_dstDevice(0,value)

    def get_dstPitch(self, i):
        """Get value ``dstPitch`` of ``(<chip.HIP_MEMCPY3D*>self._ptr)[i]``.
        """
        return (<chip.HIP_MEMCPY3D*>self._ptr)[i].dstPitch
    def set_dstPitch(self, i, unsigned long value):
        """Set value ``dstPitch`` of ``(<chip.HIP_MEMCPY3D*>self._ptr)[i]``.
        """
        (<chip.HIP_MEMCPY3D*>self._ptr)[i].dstPitch = value
    @property
    def dstPitch(self):
        """(undocumented)"""
        return self.get_dstPitch(0)
    @dstPitch.setter
    def dstPitch(self, unsigned long value):
        self.set_dstPitch(0,value)

    def get_dstHeight(self, i):
        """Get value ``dstHeight`` of ``(<chip.HIP_MEMCPY3D*>self._ptr)[i]``.
        """
        return (<chip.HIP_MEMCPY3D*>self._ptr)[i].dstHeight
    def set_dstHeight(self, i, unsigned long value):
        """Set value ``dstHeight`` of ``(<chip.HIP_MEMCPY3D*>self._ptr)[i]``.
        """
        (<chip.HIP_MEMCPY3D*>self._ptr)[i].dstHeight = value
    @property
    def dstHeight(self):
        """(undocumented)"""
        return self.get_dstHeight(0)
    @dstHeight.setter
    def dstHeight(self, unsigned long value):
        self.set_dstHeight(0,value)

    def get_WidthInBytes(self, i):
        """Get value ``WidthInBytes`` of ``(<chip.HIP_MEMCPY3D*>self._ptr)[i]``.
        """
        return (<chip.HIP_MEMCPY3D*>self._ptr)[i].WidthInBytes
    def set_WidthInBytes(self, i, unsigned long value):
        """Set value ``WidthInBytes`` of ``(<chip.HIP_MEMCPY3D*>self._ptr)[i]``.
        """
        (<chip.HIP_MEMCPY3D*>self._ptr)[i].WidthInBytes = value
    @property
    def WidthInBytes(self):
        """(undocumented)"""
        return self.get_WidthInBytes(0)
    @WidthInBytes.setter
    def WidthInBytes(self, unsigned long value):
        self.set_WidthInBytes(0,value)

    def get_Height(self, i):
        """Get value ``Height`` of ``(<chip.HIP_MEMCPY3D*>self._ptr)[i]``.
        """
        return (<chip.HIP_MEMCPY3D*>self._ptr)[i].Height
    def set_Height(self, i, unsigned long value):
        """Set value ``Height`` of ``(<chip.HIP_MEMCPY3D*>self._ptr)[i]``.
        """
        (<chip.HIP_MEMCPY3D*>self._ptr)[i].Height = value
    @property
    def Height(self):
        """(undocumented)"""
        return self.get_Height(0)
    @Height.setter
    def Height(self, unsigned long value):
        self.set_Height(0,value)

    def get_Depth(self, i):
        """Get value ``Depth`` of ``(<chip.HIP_MEMCPY3D*>self._ptr)[i]``.
        """
        return (<chip.HIP_MEMCPY3D*>self._ptr)[i].Depth
    def set_Depth(self, i, unsigned long value):
        """Set value ``Depth`` of ``(<chip.HIP_MEMCPY3D*>self._ptr)[i]``.
        """
        (<chip.HIP_MEMCPY3D*>self._ptr)[i].Depth = value
    @property
    def Depth(self):
        """(undocumented)"""
        return self.get_Depth(0)
    @Depth.setter
    def Depth(self, unsigned long value):
        self.set_Depth(0,value)

    @staticmethod
    def PROPERTIES():
        return ["srcXInBytes","srcY","srcZ","srcLOD","srcMemoryType","srcHost","srcDevice","srcPitch","srcHeight","dstXInBytes","dstY","dstZ","dstLOD","dstMemoryType","dstHost","dstDevice","dstPitch","dstHeight","WidthInBytes","Height","Depth"]

    def __contains__(self,item):
        properties = self.PROPERTIES()
        return item in properties

    def __getitem__(self,item):
        properties = self.PROPERTIES()
        if isinstance(item,int):
            if item < 0 or item >= len(properties):
                raise IndexError()
            return getattr(self,properties[item])
        raise ValueError("'item' type must be 'int'")


class _hipFunction_attribute__Base(enum.IntEnum):
    """Empty enum base class that allows subclassing.
    """
    pass
class hipFunction_attribute(_hipFunction_attribute__Base):
    """hipFunction_attribute

    Attributes:
        HIP_FUNC_ATTRIBUTE_MAX_THREADS_PER_BLOCK:
            (undocumented)
        HIP_FUNC_ATTRIBUTE_SHARED_SIZE_BYTES:
            (undocumented)
        HIP_FUNC_ATTRIBUTE_CONST_SIZE_BYTES:
            (undocumented)
        HIP_FUNC_ATTRIBUTE_LOCAL_SIZE_BYTES:
            (undocumented)
        HIP_FUNC_ATTRIBUTE_NUM_REGS:
            (undocumented)
        HIP_FUNC_ATTRIBUTE_PTX_VERSION:
            (undocumented)
        HIP_FUNC_ATTRIBUTE_BINARY_VERSION:
            (undocumented)
        HIP_FUNC_ATTRIBUTE_CACHE_MODE_CA:
            (undocumented)
        HIP_FUNC_ATTRIBUTE_MAX_DYNAMIC_SHARED_SIZE_BYTES:
            (undocumented)
        HIP_FUNC_ATTRIBUTE_PREFERRED_SHARED_MEMORY_CARVEOUT:
            (undocumented)
        HIP_FUNC_ATTRIBUTE_MAX:
            (undocumented)
    """
    HIP_FUNC_ATTRIBUTE_MAX_THREADS_PER_BLOCK = chip.HIP_FUNC_ATTRIBUTE_MAX_THREADS_PER_BLOCK
    HIP_FUNC_ATTRIBUTE_SHARED_SIZE_BYTES = chip.HIP_FUNC_ATTRIBUTE_SHARED_SIZE_BYTES
    HIP_FUNC_ATTRIBUTE_CONST_SIZE_BYTES = chip.HIP_FUNC_ATTRIBUTE_CONST_SIZE_BYTES
    HIP_FUNC_ATTRIBUTE_LOCAL_SIZE_BYTES = chip.HIP_FUNC_ATTRIBUTE_LOCAL_SIZE_BYTES
    HIP_FUNC_ATTRIBUTE_NUM_REGS = chip.HIP_FUNC_ATTRIBUTE_NUM_REGS
    HIP_FUNC_ATTRIBUTE_PTX_VERSION = chip.HIP_FUNC_ATTRIBUTE_PTX_VERSION
    HIP_FUNC_ATTRIBUTE_BINARY_VERSION = chip.HIP_FUNC_ATTRIBUTE_BINARY_VERSION
    HIP_FUNC_ATTRIBUTE_CACHE_MODE_CA = chip.HIP_FUNC_ATTRIBUTE_CACHE_MODE_CA
    HIP_FUNC_ATTRIBUTE_MAX_DYNAMIC_SHARED_SIZE_BYTES = chip.HIP_FUNC_ATTRIBUTE_MAX_DYNAMIC_SHARED_SIZE_BYTES
    HIP_FUNC_ATTRIBUTE_PREFERRED_SHARED_MEMORY_CARVEOUT = chip.HIP_FUNC_ATTRIBUTE_PREFERRED_SHARED_MEMORY_CARVEOUT
    HIP_FUNC_ATTRIBUTE_MAX = chip.HIP_FUNC_ATTRIBUTE_MAX
    @staticmethod
    def ctypes_type():
        """The type of the enum constants as ctypes type."""
        return ctypes.c_uint


class _hipPointer_attribute__Base(enum.IntEnum):
    """Empty enum base class that allows subclassing.
    """
    pass
class hipPointer_attribute(_hipPointer_attribute__Base):
    """hipPointer_attribute

    Attributes:
        HIP_POINTER_ATTRIBUTE_CONTEXT:
            The context on which a pointer was allocated
        HIP_POINTER_ATTRIBUTE_MEMORY_TYPE:
            memory type describing location of a pointer
        HIP_POINTER_ATTRIBUTE_DEVICE_POINTER:
            address at which the pointer is allocated on device
        HIP_POINTER_ATTRIBUTE_HOST_POINTER:
            address at which the pointer is allocated on host
        HIP_POINTER_ATTRIBUTE_P2P_TOKENS:
            A pair of tokens for use with linux kernel interface
        HIP_POINTER_ATTRIBUTE_SYNC_MEMOPS:
            Synchronize every synchronous memory operation initiated on this region
        HIP_POINTER_ATTRIBUTE_BUFFER_ID:
            Unique ID for an allocated memory region
        HIP_POINTER_ATTRIBUTE_IS_MANAGED:
            Indicates if the pointer points to managed memory
        HIP_POINTER_ATTRIBUTE_DEVICE_ORDINAL:
            device ordinal of a device on which a pointer was allocated or registered
        HIP_POINTER_ATTRIBUTE_IS_LEGACY_HIP_IPC_CAPABLE:
            if this pointer maps to an allocation that is suitable for hipIpcGetMemHandle
        HIP_POINTER_ATTRIBUTE_RANGE_START_ADDR:
            Starting address for this requested pointer
        HIP_POINTER_ATTRIBUTE_RANGE_SIZE:
            Size of the address range for this requested pointer
        HIP_POINTER_ATTRIBUTE_MAPPED:
            tells if this pointer is in a valid address range that is mapped to a backing allocation
        HIP_POINTER_ATTRIBUTE_ALLOWED_HANDLE_TYPES:
            Bitmask of allowed hipmemAllocationHandleType for this allocation
        HIP_POINTER_ATTRIBUTE_IS_GPU_DIRECT_RDMA_CAPABLE:
            returns if the memory referenced by this pointer can be used with the GPUDirect RDMA API
        HIP_POINTER_ATTRIBUTE_ACCESS_FLAGS:
            Returns the access flags the device associated with for the corresponding memory referenced by the ptr
        HIP_POINTER_ATTRIBUTE_MEMPOOL_HANDLE:
            Returns the mempool handle for the allocation if it was allocated from a mempool
    """
    HIP_POINTER_ATTRIBUTE_CONTEXT = chip.HIP_POINTER_ATTRIBUTE_CONTEXT
    HIP_POINTER_ATTRIBUTE_MEMORY_TYPE = chip.HIP_POINTER_ATTRIBUTE_MEMORY_TYPE
    HIP_POINTER_ATTRIBUTE_DEVICE_POINTER = chip.HIP_POINTER_ATTRIBUTE_DEVICE_POINTER
    HIP_POINTER_ATTRIBUTE_HOST_POINTER = chip.HIP_POINTER_ATTRIBUTE_HOST_POINTER
    HIP_POINTER_ATTRIBUTE_P2P_TOKENS = chip.HIP_POINTER_ATTRIBUTE_P2P_TOKENS
    HIP_POINTER_ATTRIBUTE_SYNC_MEMOPS = chip.HIP_POINTER_ATTRIBUTE_SYNC_MEMOPS
    HIP_POINTER_ATTRIBUTE_BUFFER_ID = chip.HIP_POINTER_ATTRIBUTE_BUFFER_ID
    HIP_POINTER_ATTRIBUTE_IS_MANAGED = chip.HIP_POINTER_ATTRIBUTE_IS_MANAGED
    HIP_POINTER_ATTRIBUTE_DEVICE_ORDINAL = chip.HIP_POINTER_ATTRIBUTE_DEVICE_ORDINAL
    HIP_POINTER_ATTRIBUTE_IS_LEGACY_HIP_IPC_CAPABLE = chip.HIP_POINTER_ATTRIBUTE_IS_LEGACY_HIP_IPC_CAPABLE
    HIP_POINTER_ATTRIBUTE_RANGE_START_ADDR = chip.HIP_POINTER_ATTRIBUTE_RANGE_START_ADDR
    HIP_POINTER_ATTRIBUTE_RANGE_SIZE = chip.HIP_POINTER_ATTRIBUTE_RANGE_SIZE
    HIP_POINTER_ATTRIBUTE_MAPPED = chip.HIP_POINTER_ATTRIBUTE_MAPPED
    HIP_POINTER_ATTRIBUTE_ALLOWED_HANDLE_TYPES = chip.HIP_POINTER_ATTRIBUTE_ALLOWED_HANDLE_TYPES
    HIP_POINTER_ATTRIBUTE_IS_GPU_DIRECT_RDMA_CAPABLE = chip.HIP_POINTER_ATTRIBUTE_IS_GPU_DIRECT_RDMA_CAPABLE
    HIP_POINTER_ATTRIBUTE_ACCESS_FLAGS = chip.HIP_POINTER_ATTRIBUTE_ACCESS_FLAGS
    HIP_POINTER_ATTRIBUTE_MEMPOOL_HANDLE = chip.HIP_POINTER_ATTRIBUTE_MEMPOOL_HANDLE
    @staticmethod
    def ctypes_type():
        """The type of the enum constants as ctypes type."""
        return ctypes.c_uint


cdef class uchar1(hip._util.types.Pointer):
    """Python wrapper for cdef class chip.uchar1.

    Python wrapper for cdef class chip.uchar1.

    If this type is initialized via its `__init__` method, it allocates a
    member of the underlying C type and destroys it again if the wrapper
    type is deallocated.

    This type also serves as adapter when appearing as argument type in a
    function signature. In this case, the type can further be initialized
    from a number of Python objects:

    * `None`:

      This will set the ``self._ptr`` attribute to ``NULL``.

    * `int`:

      Interprets the integer value as pointer address and writes it to ``self._ptr``.
      No ownership is transferred.

    * `ctypes.c_void_p`:

      Takes the pointer address ``pyobj.value`` and writes it to ``self._ptr``.
      No ownership is transferred.

    * `object` that implements the `CUDA Array Interface <https://numba.readthedocs.io/en/stable/cuda/cuda_array_interface.html>`_ protocol:

      Takes the integer-valued pointer address, i.e. the first entry of the `data` tuple
      from `pyobj`'s member ``__cuda_array_interface__``  and writes it to ``self._ptr``.

    * `object` that implements the Python buffer protocol:

      If the object represents a simple contiguous array,
      writes the `Py_buffer` associated with ``pyobj`` to `self._py_buffer`,
      sets the `self._py_buffer_acquired` flag to `True`, and
      writes `self._py_buffer.buf` to the data pointer `self._ptr`.

    * `hip._util.types.Pointer`:

      Takes the pointer address ``pyobj._ptr`` and writes it to ``self._ptr``.
      No ownership is transferred.

    Type checks are performed in the above order.

    C Attributes:
        _ptr (C type ``void *``, protected):
            Stores a pointer to the data of the original Python object.
        _is_ptr_owner (C type ``bint``, protected):
            If this wrapper is the owner of the underlying data.
        _py_buffer (C type ``Py_buffer`, protected):
            Stores a pointer to the data of the original Python object.
        _py_buffer_acquired (C type ``bint``, protected):
            Stores a pointer to the data of the original Python object.
    """
    # C members declared in pxd file

    def __cinit__(self):
        self._ptr = NULL
        self._is_ptr_owner = False
        self._py_buffer_acquired = False

    cdef chip.uchar1* getElementPtr(self):
        return <chip.uchar1*>self._ptr

    @staticmethod
    cdef uchar1 fromPtr(void* ptr, bint owner=False):
        """Factory function to create ``uchar1`` objects from
        given ``chip.uchar1`` pointer.

        Setting ``owner`` flag to ``True`` causes
        the extension type to free the structure pointed to by ``ptr``
        when the wrapper object is deallocated.
        """
        # Fast call to __new__() that bypasses the __init__() constructor.
        cdef uchar1 wrapper = uchar1.__new__(uchar1)
        wrapper._ptr = ptr
        wrapper._is_ptr_owner = owner
        return wrapper

    @staticmethod
    def fromObj(pyobj):
        """Creates a uchar1 from a Python object.

        Derives a uchar1 from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``uchar1`` reference, this method
        returns it directly. No new ``uchar1`` is created in this case.
        """
        return uchar1.fromPyobj(pyobj)

    @staticmethod
    cdef uchar1 fromPyobj(object pyobj):
        """Creates a uchar1 from a Python object.

        Derives a uchar1 from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``uchar1`` reference, this method
        returns it directly. No new ``uchar1`` is created in this case.

        Args:
            pyobj (object): Must be either `None`; a `hip._util.types.Pointer`; a simple, contiguous buffer according to the buffer protocol;
                            or of type `uchar1`; `int`; or `ctypes.c_void_p`.

        Note:
            This routine does not perform a copy but returns the original ``pyobj``
            if ``pyobj`` is an instance of uchar1!
        """
        cdef uchar1 wrapper

        if isinstance(pyobj,uchar1):
            return pyobj
        else:
            wrapper = uchar1.__new__(uchar1)
            wrapper.init_from_pyobj(pyobj)
            return wrapper

    def __dealloc__(self):
        # Release the buffer handle
        if self._py_buffer_acquired is True:
            cpython.buffer.PyBuffer_Release(&self._py_buffer)
        # De-allocate if not null and flag is set
        if self._ptr is not NULL and self._is_ptr_owner is True:
            stdlib.free(self._ptr)
            self._ptr = NULL

    @staticmethod
    cdef __allocate(void** ptr):
        ptr[0] = stdlib.malloc(sizeof(chip.uchar1))
        string.memset(<void*>ptr[0], 0, sizeof(chip.uchar1))

        if ptr[0] is NULL:
            raise MemoryError

    @staticmethod
    cdef uchar1 new():
        """Factory function to create uchar1 objects with
        newly allocated chip.uchar1"""
        cdef void* ptr
        uchar1.__allocate(&ptr)
        return uchar1.fromPtr(ptr, owner=True)

    @staticmethod
    cdef uchar1 fromValue(chip.uchar1 other):
        """Allocate new C type and copy from ``other``.
        """
        wrapper = uchar1.new()
        string.memcpy(wrapper._ptr, &other, sizeof(chip.uchar1))
        return wrapper

    def c_sizeof(self):
        """Returns the size of the underlying C type in bytes.
        Note:
            Implemented as function to not collide with
            autogenerated property names.
        """
        return sizeof(chip.uchar1)

    def __int__(self):
        """Returns the data's address as long integer.
        """
        return cpython.long.PyLong_FromVoidPtr(self._ptr)

    def __repr__(self):
        return f"<uchar1 object, ptr: {int(self)}>"

    def as_c_void_p(self):
        """Returns the data's address as `ctypes.c_void_p`
        Note:
            Implemented as function to not collide with
            autogenerated property names.
        """
        return ctypes.c_void_p(int(self))

    def __init__(self,*args,**kwargs):
        """Constructor type uchar1.

        Constructor for type uchar1.

        Args:
            *args:
                Positional arguments. Initialize all or a subset of the member variables
                according to their order of declaration.
            **kwargs:
                Can be used to initialize member variables at construction,
                Just pass an argument expression of the form <member>=<value>
                per member that you want to initialize.
        """
        uchar1.__allocate(&self._ptr)
        self._is_ptr_owner = True
        attribs = self.PROPERTIES()
        used_attribs = set()
        if len(args) > len(attribs):
            raise ValueError("More positional arguments specified than this type has properties.")
        for i,v in enumerate(args):
            setattr(self,attribs[i],v)
            used_attribs.add(attribs[i])
        valid_names = ", ".join(["'"+p+"'" for p in attribs])
        for k,v in kwargs.items():
            if k in used_attribs:
                raise KeyError(f"argument '{k}' has already been specified as positional argument.")
            elif k not in attribs:
                raise KeyError(f"'{k}' is no valid property name. Valid names: {valid_names}")
            setattr(self,k,v)
    def get_x(self, i):
        """Get value ``x`` of ``(<chip.uchar1*>self._ptr)[i]``.
        """
        return (<chip.uchar1*>self._ptr)[i].x
    def set_x(self, i, unsigned char value):
        """Set value ``x`` of ``(<chip.uchar1*>self._ptr)[i]``.
        """
        (<chip.uchar1*>self._ptr)[i].x = value
    @property
    def x(self):
        """(undocumented)"""
        return self.get_x(0)
    @x.setter
    def x(self, unsigned char value):
        self.set_x(0,value)

    @staticmethod
    def PROPERTIES():
        return ["x"]

    def __contains__(self,item):
        properties = self.PROPERTIES()
        return item in properties

    def __getitem__(self,item):
        properties = self.PROPERTIES()
        if isinstance(item,int):
            if item < 0 or item >= len(properties):
                raise IndexError()
            return getattr(self,properties[item])
        raise ValueError("'item' type must be 'int'")


cdef class uchar2(hip._util.types.Pointer):
    """Python wrapper for cdef class chip.uchar2.

    Python wrapper for cdef class chip.uchar2.

    If this type is initialized via its `__init__` method, it allocates a
    member of the underlying C type and destroys it again if the wrapper
    type is deallocated.

    This type also serves as adapter when appearing as argument type in a
    function signature. In this case, the type can further be initialized
    from a number of Python objects:

    * `None`:

      This will set the ``self._ptr`` attribute to ``NULL``.

    * `int`:

      Interprets the integer value as pointer address and writes it to ``self._ptr``.
      No ownership is transferred.

    * `ctypes.c_void_p`:

      Takes the pointer address ``pyobj.value`` and writes it to ``self._ptr``.
      No ownership is transferred.

    * `object` that implements the `CUDA Array Interface <https://numba.readthedocs.io/en/stable/cuda/cuda_array_interface.html>`_ protocol:

      Takes the integer-valued pointer address, i.e. the first entry of the `data` tuple
      from `pyobj`'s member ``__cuda_array_interface__``  and writes it to ``self._ptr``.

    * `object` that implements the Python buffer protocol:

      If the object represents a simple contiguous array,
      writes the `Py_buffer` associated with ``pyobj`` to `self._py_buffer`,
      sets the `self._py_buffer_acquired` flag to `True`, and
      writes `self._py_buffer.buf` to the data pointer `self._ptr`.

    * `hip._util.types.Pointer`:

      Takes the pointer address ``pyobj._ptr`` and writes it to ``self._ptr``.
      No ownership is transferred.

    Type checks are performed in the above order.

    C Attributes:
        _ptr (C type ``void *``, protected):
            Stores a pointer to the data of the original Python object.
        _is_ptr_owner (C type ``bint``, protected):
            If this wrapper is the owner of the underlying data.
        _py_buffer (C type ``Py_buffer`, protected):
            Stores a pointer to the data of the original Python object.
        _py_buffer_acquired (C type ``bint``, protected):
            Stores a pointer to the data of the original Python object.
    """
    # C members declared in pxd file

    def __cinit__(self):
        self._ptr = NULL
        self._is_ptr_owner = False
        self._py_buffer_acquired = False

    cdef chip.uchar2* getElementPtr(self):
        return <chip.uchar2*>self._ptr

    @staticmethod
    cdef uchar2 fromPtr(void* ptr, bint owner=False):
        """Factory function to create ``uchar2`` objects from
        given ``chip.uchar2`` pointer.

        Setting ``owner`` flag to ``True`` causes
        the extension type to free the structure pointed to by ``ptr``
        when the wrapper object is deallocated.
        """
        # Fast call to __new__() that bypasses the __init__() constructor.
        cdef uchar2 wrapper = uchar2.__new__(uchar2)
        wrapper._ptr = ptr
        wrapper._is_ptr_owner = owner
        return wrapper

    @staticmethod
    def fromObj(pyobj):
        """Creates a uchar2 from a Python object.

        Derives a uchar2 from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``uchar2`` reference, this method
        returns it directly. No new ``uchar2`` is created in this case.
        """
        return uchar2.fromPyobj(pyobj)

    @staticmethod
    cdef uchar2 fromPyobj(object pyobj):
        """Creates a uchar2 from a Python object.

        Derives a uchar2 from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``uchar2`` reference, this method
        returns it directly. No new ``uchar2`` is created in this case.

        Args:
            pyobj (object): Must be either `None`; a `hip._util.types.Pointer`; a simple, contiguous buffer according to the buffer protocol;
                            or of type `uchar2`; `int`; or `ctypes.c_void_p`.

        Note:
            This routine does not perform a copy but returns the original ``pyobj``
            if ``pyobj`` is an instance of uchar2!
        """
        cdef uchar2 wrapper

        if isinstance(pyobj,uchar2):
            return pyobj
        else:
            wrapper = uchar2.__new__(uchar2)
            wrapper.init_from_pyobj(pyobj)
            return wrapper

    def __dealloc__(self):
        # Release the buffer handle
        if self._py_buffer_acquired is True:
            cpython.buffer.PyBuffer_Release(&self._py_buffer)
        # De-allocate if not null and flag is set
        if self._ptr is not NULL and self._is_ptr_owner is True:
            stdlib.free(self._ptr)
            self._ptr = NULL

    @staticmethod
    cdef __allocate(void** ptr):
        ptr[0] = stdlib.malloc(sizeof(chip.uchar2))
        string.memset(<void*>ptr[0], 0, sizeof(chip.uchar2))

        if ptr[0] is NULL:
            raise MemoryError

    @staticmethod
    cdef uchar2 new():
        """Factory function to create uchar2 objects with
        newly allocated chip.uchar2"""
        cdef void* ptr
        uchar2.__allocate(&ptr)
        return uchar2.fromPtr(ptr, owner=True)

    @staticmethod
    cdef uchar2 fromValue(chip.uchar2 other):
        """Allocate new C type and copy from ``other``.
        """
        wrapper = uchar2.new()
        string.memcpy(wrapper._ptr, &other, sizeof(chip.uchar2))
        return wrapper

    def c_sizeof(self):
        """Returns the size of the underlying C type in bytes.
        Note:
            Implemented as function to not collide with
            autogenerated property names.
        """
        return sizeof(chip.uchar2)

    def __int__(self):
        """Returns the data's address as long integer.
        """
        return cpython.long.PyLong_FromVoidPtr(self._ptr)

    def __repr__(self):
        return f"<uchar2 object, ptr: {int(self)}>"

    def as_c_void_p(self):
        """Returns the data's address as `ctypes.c_void_p`
        Note:
            Implemented as function to not collide with
            autogenerated property names.
        """
        return ctypes.c_void_p(int(self))

    def __init__(self,*args,**kwargs):
        """Constructor type uchar2.

        Constructor for type uchar2.

        Args:
            *args:
                Positional arguments. Initialize all or a subset of the member variables
                according to their order of declaration.
            **kwargs:
                Can be used to initialize member variables at construction,
                Just pass an argument expression of the form <member>=<value>
                per member that you want to initialize.
        """
        uchar2.__allocate(&self._ptr)
        self._is_ptr_owner = True
        attribs = self.PROPERTIES()
        used_attribs = set()
        if len(args) > len(attribs):
            raise ValueError("More positional arguments specified than this type has properties.")
        for i,v in enumerate(args):
            setattr(self,attribs[i],v)
            used_attribs.add(attribs[i])
        valid_names = ", ".join(["'"+p+"'" for p in attribs])
        for k,v in kwargs.items():
            if k in used_attribs:
                raise KeyError(f"argument '{k}' has already been specified as positional argument.")
            elif k not in attribs:
                raise KeyError(f"'{k}' is no valid property name. Valid names: {valid_names}")
            setattr(self,k,v)
    def get_x(self, i):
        """Get value ``x`` of ``(<chip.uchar2*>self._ptr)[i]``.
        """
        return (<chip.uchar2*>self._ptr)[i].x
    def set_x(self, i, unsigned char value):
        """Set value ``x`` of ``(<chip.uchar2*>self._ptr)[i]``.
        """
        (<chip.uchar2*>self._ptr)[i].x = value
    @property
    def x(self):
        """(undocumented)"""
        return self.get_x(0)
    @x.setter
    def x(self, unsigned char value):
        self.set_x(0,value)

    def get_y(self, i):
        """Get value ``y`` of ``(<chip.uchar2*>self._ptr)[i]``.
        """
        return (<chip.uchar2*>self._ptr)[i].y
    def set_y(self, i, unsigned char value):
        """Set value ``y`` of ``(<chip.uchar2*>self._ptr)[i]``.
        """
        (<chip.uchar2*>self._ptr)[i].y = value
    @property
    def y(self):
        """(undocumented)"""
        return self.get_y(0)
    @y.setter
    def y(self, unsigned char value):
        self.set_y(0,value)

    @staticmethod
    def PROPERTIES():
        return ["x","y"]

    def __contains__(self,item):
        properties = self.PROPERTIES()
        return item in properties

    def __getitem__(self,item):
        properties = self.PROPERTIES()
        if isinstance(item,int):
            if item < 0 or item >= len(properties):
                raise IndexError()
            return getattr(self,properties[item])
        raise ValueError("'item' type must be 'int'")


cdef class uchar3(hip._util.types.Pointer):
    """Python wrapper for cdef class chip.uchar3.

    Python wrapper for cdef class chip.uchar3.

    If this type is initialized via its `__init__` method, it allocates a
    member of the underlying C type and destroys it again if the wrapper
    type is deallocated.

    This type also serves as adapter when appearing as argument type in a
    function signature. In this case, the type can further be initialized
    from a number of Python objects:

    * `None`:

      This will set the ``self._ptr`` attribute to ``NULL``.

    * `int`:

      Interprets the integer value as pointer address and writes it to ``self._ptr``.
      No ownership is transferred.

    * `ctypes.c_void_p`:

      Takes the pointer address ``pyobj.value`` and writes it to ``self._ptr``.
      No ownership is transferred.

    * `object` that implements the `CUDA Array Interface <https://numba.readthedocs.io/en/stable/cuda/cuda_array_interface.html>`_ protocol:

      Takes the integer-valued pointer address, i.e. the first entry of the `data` tuple
      from `pyobj`'s member ``__cuda_array_interface__``  and writes it to ``self._ptr``.

    * `object` that implements the Python buffer protocol:

      If the object represents a simple contiguous array,
      writes the `Py_buffer` associated with ``pyobj`` to `self._py_buffer`,
      sets the `self._py_buffer_acquired` flag to `True`, and
      writes `self._py_buffer.buf` to the data pointer `self._ptr`.

    * `hip._util.types.Pointer`:

      Takes the pointer address ``pyobj._ptr`` and writes it to ``self._ptr``.
      No ownership is transferred.

    Type checks are performed in the above order.

    C Attributes:
        _ptr (C type ``void *``, protected):
            Stores a pointer to the data of the original Python object.
        _is_ptr_owner (C type ``bint``, protected):
            If this wrapper is the owner of the underlying data.
        _py_buffer (C type ``Py_buffer`, protected):
            Stores a pointer to the data of the original Python object.
        _py_buffer_acquired (C type ``bint``, protected):
            Stores a pointer to the data of the original Python object.
    """
    # C members declared in pxd file

    def __cinit__(self):
        self._ptr = NULL
        self._is_ptr_owner = False
        self._py_buffer_acquired = False

    cdef chip.uchar3* getElementPtr(self):
        return <chip.uchar3*>self._ptr

    @staticmethod
    cdef uchar3 fromPtr(void* ptr, bint owner=False):
        """Factory function to create ``uchar3`` objects from
        given ``chip.uchar3`` pointer.

        Setting ``owner`` flag to ``True`` causes
        the extension type to free the structure pointed to by ``ptr``
        when the wrapper object is deallocated.
        """
        # Fast call to __new__() that bypasses the __init__() constructor.
        cdef uchar3 wrapper = uchar3.__new__(uchar3)
        wrapper._ptr = ptr
        wrapper._is_ptr_owner = owner
        return wrapper

    @staticmethod
    def fromObj(pyobj):
        """Creates a uchar3 from a Python object.

        Derives a uchar3 from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``uchar3`` reference, this method
        returns it directly. No new ``uchar3`` is created in this case.
        """
        return uchar3.fromPyobj(pyobj)

    @staticmethod
    cdef uchar3 fromPyobj(object pyobj):
        """Creates a uchar3 from a Python object.

        Derives a uchar3 from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``uchar3`` reference, this method
        returns it directly. No new ``uchar3`` is created in this case.

        Args:
            pyobj (object): Must be either `None`; a `hip._util.types.Pointer`; a simple, contiguous buffer according to the buffer protocol;
                            or of type `uchar3`; `int`; or `ctypes.c_void_p`.

        Note:
            This routine does not perform a copy but returns the original ``pyobj``
            if ``pyobj`` is an instance of uchar3!
        """
        cdef uchar3 wrapper

        if isinstance(pyobj,uchar3):
            return pyobj
        else:
            wrapper = uchar3.__new__(uchar3)
            wrapper.init_from_pyobj(pyobj)
            return wrapper

    def __dealloc__(self):
        # Release the buffer handle
        if self._py_buffer_acquired is True:
            cpython.buffer.PyBuffer_Release(&self._py_buffer)
        # De-allocate if not null and flag is set
        if self._ptr is not NULL and self._is_ptr_owner is True:
            stdlib.free(self._ptr)
            self._ptr = NULL

    @staticmethod
    cdef __allocate(void** ptr):
        ptr[0] = stdlib.malloc(sizeof(chip.uchar3))
        string.memset(<void*>ptr[0], 0, sizeof(chip.uchar3))

        if ptr[0] is NULL:
            raise MemoryError

    @staticmethod
    cdef uchar3 new():
        """Factory function to create uchar3 objects with
        newly allocated chip.uchar3"""
        cdef void* ptr
        uchar3.__allocate(&ptr)
        return uchar3.fromPtr(ptr, owner=True)

    @staticmethod
    cdef uchar3 fromValue(chip.uchar3 other):
        """Allocate new C type and copy from ``other``.
        """
        wrapper = uchar3.new()
        string.memcpy(wrapper._ptr, &other, sizeof(chip.uchar3))
        return wrapper

    def c_sizeof(self):
        """Returns the size of the underlying C type in bytes.
        Note:
            Implemented as function to not collide with
            autogenerated property names.
        """
        return sizeof(chip.uchar3)

    def __int__(self):
        """Returns the data's address as long integer.
        """
        return cpython.long.PyLong_FromVoidPtr(self._ptr)

    def __repr__(self):
        return f"<uchar3 object, ptr: {int(self)}>"

    def as_c_void_p(self):
        """Returns the data's address as `ctypes.c_void_p`
        Note:
            Implemented as function to not collide with
            autogenerated property names.
        """
        return ctypes.c_void_p(int(self))

    def __init__(self,*args,**kwargs):
        """Constructor type uchar3.

        Constructor for type uchar3.

        Args:
            *args:
                Positional arguments. Initialize all or a subset of the member variables
                according to their order of declaration.
            **kwargs:
                Can be used to initialize member variables at construction,
                Just pass an argument expression of the form <member>=<value>
                per member that you want to initialize.
        """
        uchar3.__allocate(&self._ptr)
        self._is_ptr_owner = True
        attribs = self.PROPERTIES()
        used_attribs = set()
        if len(args) > len(attribs):
            raise ValueError("More positional arguments specified than this type has properties.")
        for i,v in enumerate(args):
            setattr(self,attribs[i],v)
            used_attribs.add(attribs[i])
        valid_names = ", ".join(["'"+p+"'" for p in attribs])
        for k,v in kwargs.items():
            if k in used_attribs:
                raise KeyError(f"argument '{k}' has already been specified as positional argument.")
            elif k not in attribs:
                raise KeyError(f"'{k}' is no valid property name. Valid names: {valid_names}")
            setattr(self,k,v)
    def get_x(self, i):
        """Get value ``x`` of ``(<chip.uchar3*>self._ptr)[i]``.
        """
        return (<chip.uchar3*>self._ptr)[i].x
    def set_x(self, i, unsigned char value):
        """Set value ``x`` of ``(<chip.uchar3*>self._ptr)[i]``.
        """
        (<chip.uchar3*>self._ptr)[i].x = value
    @property
    def x(self):
        """(undocumented)"""
        return self.get_x(0)
    @x.setter
    def x(self, unsigned char value):
        self.set_x(0,value)

    def get_y(self, i):
        """Get value ``y`` of ``(<chip.uchar3*>self._ptr)[i]``.
        """
        return (<chip.uchar3*>self._ptr)[i].y
    def set_y(self, i, unsigned char value):
        """Set value ``y`` of ``(<chip.uchar3*>self._ptr)[i]``.
        """
        (<chip.uchar3*>self._ptr)[i].y = value
    @property
    def y(self):
        """(undocumented)"""
        return self.get_y(0)
    @y.setter
    def y(self, unsigned char value):
        self.set_y(0,value)

    def get_z(self, i):
        """Get value ``z`` of ``(<chip.uchar3*>self._ptr)[i]``.
        """
        return (<chip.uchar3*>self._ptr)[i].z
    def set_z(self, i, unsigned char value):
        """Set value ``z`` of ``(<chip.uchar3*>self._ptr)[i]``.
        """
        (<chip.uchar3*>self._ptr)[i].z = value
    @property
    def z(self):
        """(undocumented)"""
        return self.get_z(0)
    @z.setter
    def z(self, unsigned char value):
        self.set_z(0,value)

    @staticmethod
    def PROPERTIES():
        return ["x","y","z"]

    def __contains__(self,item):
        properties = self.PROPERTIES()
        return item in properties

    def __getitem__(self,item):
        properties = self.PROPERTIES()
        if isinstance(item,int):
            if item < 0 or item >= len(properties):
                raise IndexError()
            return getattr(self,properties[item])
        raise ValueError("'item' type must be 'int'")


cdef class uchar4(hip._util.types.Pointer):
    """Python wrapper for cdef class chip.uchar4.

    Python wrapper for cdef class chip.uchar4.

    If this type is initialized via its `__init__` method, it allocates a
    member of the underlying C type and destroys it again if the wrapper
    type is deallocated.

    This type also serves as adapter when appearing as argument type in a
    function signature. In this case, the type can further be initialized
    from a number of Python objects:

    * `None`:

      This will set the ``self._ptr`` attribute to ``NULL``.

    * `int`:

      Interprets the integer value as pointer address and writes it to ``self._ptr``.
      No ownership is transferred.

    * `ctypes.c_void_p`:

      Takes the pointer address ``pyobj.value`` and writes it to ``self._ptr``.
      No ownership is transferred.

    * `object` that implements the `CUDA Array Interface <https://numba.readthedocs.io/en/stable/cuda/cuda_array_interface.html>`_ protocol:

      Takes the integer-valued pointer address, i.e. the first entry of the `data` tuple
      from `pyobj`'s member ``__cuda_array_interface__``  and writes it to ``self._ptr``.

    * `object` that implements the Python buffer protocol:

      If the object represents a simple contiguous array,
      writes the `Py_buffer` associated with ``pyobj`` to `self._py_buffer`,
      sets the `self._py_buffer_acquired` flag to `True`, and
      writes `self._py_buffer.buf` to the data pointer `self._ptr`.

    * `hip._util.types.Pointer`:

      Takes the pointer address ``pyobj._ptr`` and writes it to ``self._ptr``.
      No ownership is transferred.

    Type checks are performed in the above order.

    C Attributes:
        _ptr (C type ``void *``, protected):
            Stores a pointer to the data of the original Python object.
        _is_ptr_owner (C type ``bint``, protected):
            If this wrapper is the owner of the underlying data.
        _py_buffer (C type ``Py_buffer`, protected):
            Stores a pointer to the data of the original Python object.
        _py_buffer_acquired (C type ``bint``, protected):
            Stores a pointer to the data of the original Python object.
    """
    # C members declared in pxd file

    def __cinit__(self):
        self._ptr = NULL
        self._is_ptr_owner = False
        self._py_buffer_acquired = False

    cdef chip.uchar4* getElementPtr(self):
        return <chip.uchar4*>self._ptr

    @staticmethod
    cdef uchar4 fromPtr(void* ptr, bint owner=False):
        """Factory function to create ``uchar4`` objects from
        given ``chip.uchar4`` pointer.

        Setting ``owner`` flag to ``True`` causes
        the extension type to free the structure pointed to by ``ptr``
        when the wrapper object is deallocated.
        """
        # Fast call to __new__() that bypasses the __init__() constructor.
        cdef uchar4 wrapper = uchar4.__new__(uchar4)
        wrapper._ptr = ptr
        wrapper._is_ptr_owner = owner
        return wrapper

    @staticmethod
    def fromObj(pyobj):
        """Creates a uchar4 from a Python object.

        Derives a uchar4 from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``uchar4`` reference, this method
        returns it directly. No new ``uchar4`` is created in this case.
        """
        return uchar4.fromPyobj(pyobj)

    @staticmethod
    cdef uchar4 fromPyobj(object pyobj):
        """Creates a uchar4 from a Python object.

        Derives a uchar4 from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``uchar4`` reference, this method
        returns it directly. No new ``uchar4`` is created in this case.

        Args:
            pyobj (object): Must be either `None`; a `hip._util.types.Pointer`; a simple, contiguous buffer according to the buffer protocol;
                            or of type `uchar4`; `int`; or `ctypes.c_void_p`.

        Note:
            This routine does not perform a copy but returns the original ``pyobj``
            if ``pyobj`` is an instance of uchar4!
        """
        cdef uchar4 wrapper

        if isinstance(pyobj,uchar4):
            return pyobj
        else:
            wrapper = uchar4.__new__(uchar4)
            wrapper.init_from_pyobj(pyobj)
            return wrapper

    def __dealloc__(self):
        # Release the buffer handle
        if self._py_buffer_acquired is True:
            cpython.buffer.PyBuffer_Release(&self._py_buffer)
        # De-allocate if not null and flag is set
        if self._ptr is not NULL and self._is_ptr_owner is True:
            stdlib.free(self._ptr)
            self._ptr = NULL

    @staticmethod
    cdef __allocate(void** ptr):
        ptr[0] = stdlib.malloc(sizeof(chip.uchar4))
        string.memset(<void*>ptr[0], 0, sizeof(chip.uchar4))

        if ptr[0] is NULL:
            raise MemoryError

    @staticmethod
    cdef uchar4 new():
        """Factory function to create uchar4 objects with
        newly allocated chip.uchar4"""
        cdef void* ptr
        uchar4.__allocate(&ptr)
        return uchar4.fromPtr(ptr, owner=True)

    @staticmethod
    cdef uchar4 fromValue(chip.uchar4 other):
        """Allocate new C type and copy from ``other``.
        """
        wrapper = uchar4.new()
        string.memcpy(wrapper._ptr, &other, sizeof(chip.uchar4))
        return wrapper

    def c_sizeof(self):
        """Returns the size of the underlying C type in bytes.
        Note:
            Implemented as function to not collide with
            autogenerated property names.
        """
        return sizeof(chip.uchar4)

    def __int__(self):
        """Returns the data's address as long integer.
        """
        return cpython.long.PyLong_FromVoidPtr(self._ptr)

    def __repr__(self):
        return f"<uchar4 object, ptr: {int(self)}>"

    def as_c_void_p(self):
        """Returns the data's address as `ctypes.c_void_p`
        Note:
            Implemented as function to not collide with
            autogenerated property names.
        """
        return ctypes.c_void_p(int(self))

    def __init__(self,*args,**kwargs):
        """Constructor type uchar4.

        Constructor for type uchar4.

        Args:
            *args:
                Positional arguments. Initialize all or a subset of the member variables
                according to their order of declaration.
            **kwargs:
                Can be used to initialize member variables at construction,
                Just pass an argument expression of the form <member>=<value>
                per member that you want to initialize.
        """
        uchar4.__allocate(&self._ptr)
        self._is_ptr_owner = True
        attribs = self.PROPERTIES()
        used_attribs = set()
        if len(args) > len(attribs):
            raise ValueError("More positional arguments specified than this type has properties.")
        for i,v in enumerate(args):
            setattr(self,attribs[i],v)
            used_attribs.add(attribs[i])
        valid_names = ", ".join(["'"+p+"'" for p in attribs])
        for k,v in kwargs.items():
            if k in used_attribs:
                raise KeyError(f"argument '{k}' has already been specified as positional argument.")
            elif k not in attribs:
                raise KeyError(f"'{k}' is no valid property name. Valid names: {valid_names}")
            setattr(self,k,v)
    def get_x(self, i):
        """Get value ``x`` of ``(<chip.uchar4*>self._ptr)[i]``.
        """
        return (<chip.uchar4*>self._ptr)[i].x
    def set_x(self, i, unsigned char value):
        """Set value ``x`` of ``(<chip.uchar4*>self._ptr)[i]``.
        """
        (<chip.uchar4*>self._ptr)[i].x = value
    @property
    def x(self):
        """(undocumented)"""
        return self.get_x(0)
    @x.setter
    def x(self, unsigned char value):
        self.set_x(0,value)

    def get_y(self, i):
        """Get value ``y`` of ``(<chip.uchar4*>self._ptr)[i]``.
        """
        return (<chip.uchar4*>self._ptr)[i].y
    def set_y(self, i, unsigned char value):
        """Set value ``y`` of ``(<chip.uchar4*>self._ptr)[i]``.
        """
        (<chip.uchar4*>self._ptr)[i].y = value
    @property
    def y(self):
        """(undocumented)"""
        return self.get_y(0)
    @y.setter
    def y(self, unsigned char value):
        self.set_y(0,value)

    def get_z(self, i):
        """Get value ``z`` of ``(<chip.uchar4*>self._ptr)[i]``.
        """
        return (<chip.uchar4*>self._ptr)[i].z
    def set_z(self, i, unsigned char value):
        """Set value ``z`` of ``(<chip.uchar4*>self._ptr)[i]``.
        """
        (<chip.uchar4*>self._ptr)[i].z = value
    @property
    def z(self):
        """(undocumented)"""
        return self.get_z(0)
    @z.setter
    def z(self, unsigned char value):
        self.set_z(0,value)

    def get_w(self, i):
        """Get value ``w`` of ``(<chip.uchar4*>self._ptr)[i]``.
        """
        return (<chip.uchar4*>self._ptr)[i].w
    def set_w(self, i, unsigned char value):
        """Set value ``w`` of ``(<chip.uchar4*>self._ptr)[i]``.
        """
        (<chip.uchar4*>self._ptr)[i].w = value
    @property
    def w(self):
        """(undocumented)"""
        return self.get_w(0)
    @w.setter
    def w(self, unsigned char value):
        self.set_w(0,value)

    @staticmethod
    def PROPERTIES():
        return ["x","y","z","w"]

    def __contains__(self,item):
        properties = self.PROPERTIES()
        return item in properties

    def __getitem__(self,item):
        properties = self.PROPERTIES()
        if isinstance(item,int):
            if item < 0 or item >= len(properties):
                raise IndexError()
            return getattr(self,properties[item])
        raise ValueError("'item' type must be 'int'")


cdef class char1(hip._util.types.Pointer):
    """Python wrapper for cdef class chip.char1.

    Python wrapper for cdef class chip.char1.

    If this type is initialized via its `__init__` method, it allocates a
    member of the underlying C type and destroys it again if the wrapper
    type is deallocated.

    This type also serves as adapter when appearing as argument type in a
    function signature. In this case, the type can further be initialized
    from a number of Python objects:

    * `None`:

      This will set the ``self._ptr`` attribute to ``NULL``.

    * `int`:

      Interprets the integer value as pointer address and writes it to ``self._ptr``.
      No ownership is transferred.

    * `ctypes.c_void_p`:

      Takes the pointer address ``pyobj.value`` and writes it to ``self._ptr``.
      No ownership is transferred.

    * `object` that implements the `CUDA Array Interface <https://numba.readthedocs.io/en/stable/cuda/cuda_array_interface.html>`_ protocol:

      Takes the integer-valued pointer address, i.e. the first entry of the `data` tuple
      from `pyobj`'s member ``__cuda_array_interface__``  and writes it to ``self._ptr``.

    * `object` that implements the Python buffer protocol:

      If the object represents a simple contiguous array,
      writes the `Py_buffer` associated with ``pyobj`` to `self._py_buffer`,
      sets the `self._py_buffer_acquired` flag to `True`, and
      writes `self._py_buffer.buf` to the data pointer `self._ptr`.

    * `hip._util.types.Pointer`:

      Takes the pointer address ``pyobj._ptr`` and writes it to ``self._ptr``.
      No ownership is transferred.

    Type checks are performed in the above order.

    C Attributes:
        _ptr (C type ``void *``, protected):
            Stores a pointer to the data of the original Python object.
        _is_ptr_owner (C type ``bint``, protected):
            If this wrapper is the owner of the underlying data.
        _py_buffer (C type ``Py_buffer`, protected):
            Stores a pointer to the data of the original Python object.
        _py_buffer_acquired (C type ``bint``, protected):
            Stores a pointer to the data of the original Python object.
    """
    # C members declared in pxd file

    def __cinit__(self):
        self._ptr = NULL
        self._is_ptr_owner = False
        self._py_buffer_acquired = False

    cdef chip.char1* getElementPtr(self):
        return <chip.char1*>self._ptr

    @staticmethod
    cdef char1 fromPtr(void* ptr, bint owner=False):
        """Factory function to create ``char1`` objects from
        given ``chip.char1`` pointer.

        Setting ``owner`` flag to ``True`` causes
        the extension type to free the structure pointed to by ``ptr``
        when the wrapper object is deallocated.
        """
        # Fast call to __new__() that bypasses the __init__() constructor.
        cdef char1 wrapper = char1.__new__(char1)
        wrapper._ptr = ptr
        wrapper._is_ptr_owner = owner
        return wrapper

    @staticmethod
    def fromObj(pyobj):
        """Creates a char1 from a Python object.

        Derives a char1 from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``char1`` reference, this method
        returns it directly. No new ``char1`` is created in this case.
        """
        return char1.fromPyobj(pyobj)

    @staticmethod
    cdef char1 fromPyobj(object pyobj):
        """Creates a char1 from a Python object.

        Derives a char1 from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``char1`` reference, this method
        returns it directly. No new ``char1`` is created in this case.

        Args:
            pyobj (object): Must be either `None`; a `hip._util.types.Pointer`; a simple, contiguous buffer according to the buffer protocol;
                            or of type `char1`; `int`; or `ctypes.c_void_p`.

        Note:
            This routine does not perform a copy but returns the original ``pyobj``
            if ``pyobj`` is an instance of char1!
        """
        cdef char1 wrapper

        if isinstance(pyobj,char1):
            return pyobj
        else:
            wrapper = char1.__new__(char1)
            wrapper.init_from_pyobj(pyobj)
            return wrapper

    def __dealloc__(self):
        # Release the buffer handle
        if self._py_buffer_acquired is True:
            cpython.buffer.PyBuffer_Release(&self._py_buffer)
        # De-allocate if not null and flag is set
        if self._ptr is not NULL and self._is_ptr_owner is True:
            stdlib.free(self._ptr)
            self._ptr = NULL

    @staticmethod
    cdef __allocate(void** ptr):
        ptr[0] = stdlib.malloc(sizeof(chip.char1))
        string.memset(<void*>ptr[0], 0, sizeof(chip.char1))

        if ptr[0] is NULL:
            raise MemoryError

    @staticmethod
    cdef char1 new():
        """Factory function to create char1 objects with
        newly allocated chip.char1"""
        cdef void* ptr
        char1.__allocate(&ptr)
        return char1.fromPtr(ptr, owner=True)

    @staticmethod
    cdef char1 fromValue(chip.char1 other):
        """Allocate new C type and copy from ``other``.
        """
        wrapper = char1.new()
        string.memcpy(wrapper._ptr, &other, sizeof(chip.char1))
        return wrapper

    def c_sizeof(self):
        """Returns the size of the underlying C type in bytes.
        Note:
            Implemented as function to not collide with
            autogenerated property names.
        """
        return sizeof(chip.char1)

    def __int__(self):
        """Returns the data's address as long integer.
        """
        return cpython.long.PyLong_FromVoidPtr(self._ptr)

    def __repr__(self):
        return f"<char1 object, ptr: {int(self)}>"

    def as_c_void_p(self):
        """Returns the data's address as `ctypes.c_void_p`
        Note:
            Implemented as function to not collide with
            autogenerated property names.
        """
        return ctypes.c_void_p(int(self))

    def __init__(self,*args,**kwargs):
        """Constructor type char1.

        Constructor for type char1.

        Args:
            *args:
                Positional arguments. Initialize all or a subset of the member variables
                according to their order of declaration.
            **kwargs:
                Can be used to initialize member variables at construction,
                Just pass an argument expression of the form <member>=<value>
                per member that you want to initialize.
        """
        char1.__allocate(&self._ptr)
        self._is_ptr_owner = True
        attribs = self.PROPERTIES()
        used_attribs = set()
        if len(args) > len(attribs):
            raise ValueError("More positional arguments specified than this type has properties.")
        for i,v in enumerate(args):
            setattr(self,attribs[i],v)
            used_attribs.add(attribs[i])
        valid_names = ", ".join(["'"+p+"'" for p in attribs])
        for k,v in kwargs.items():
            if k in used_attribs:
                raise KeyError(f"argument '{k}' has already been specified as positional argument.")
            elif k not in attribs:
                raise KeyError(f"'{k}' is no valid property name. Valid names: {valid_names}")
            setattr(self,k,v)
    def get_x(self, i):
        """Get value ``x`` of ``(<chip.char1*>self._ptr)[i]``.
        """
        return (<chip.char1*>self._ptr)[i].x
    def set_x(self, i, char value):
        """Set value ``x`` of ``(<chip.char1*>self._ptr)[i]``.
        """
        (<chip.char1*>self._ptr)[i].x = value
    @property
    def x(self):
        """(undocumented)"""
        return self.get_x(0)
    @x.setter
    def x(self, char value):
        self.set_x(0,value)

    @staticmethod
    def PROPERTIES():
        return ["x"]

    def __contains__(self,item):
        properties = self.PROPERTIES()
        return item in properties

    def __getitem__(self,item):
        properties = self.PROPERTIES()
        if isinstance(item,int):
            if item < 0 or item >= len(properties):
                raise IndexError()
            return getattr(self,properties[item])
        raise ValueError("'item' type must be 'int'")


cdef class char2(hip._util.types.Pointer):
    """Python wrapper for cdef class chip.char2.

    Python wrapper for cdef class chip.char2.

    If this type is initialized via its `__init__` method, it allocates a
    member of the underlying C type and destroys it again if the wrapper
    type is deallocated.

    This type also serves as adapter when appearing as argument type in a
    function signature. In this case, the type can further be initialized
    from a number of Python objects:

    * `None`:

      This will set the ``self._ptr`` attribute to ``NULL``.

    * `int`:

      Interprets the integer value as pointer address and writes it to ``self._ptr``.
      No ownership is transferred.

    * `ctypes.c_void_p`:

      Takes the pointer address ``pyobj.value`` and writes it to ``self._ptr``.
      No ownership is transferred.

    * `object` that implements the `CUDA Array Interface <https://numba.readthedocs.io/en/stable/cuda/cuda_array_interface.html>`_ protocol:

      Takes the integer-valued pointer address, i.e. the first entry of the `data` tuple
      from `pyobj`'s member ``__cuda_array_interface__``  and writes it to ``self._ptr``.

    * `object` that implements the Python buffer protocol:

      If the object represents a simple contiguous array,
      writes the `Py_buffer` associated with ``pyobj`` to `self._py_buffer`,
      sets the `self._py_buffer_acquired` flag to `True`, and
      writes `self._py_buffer.buf` to the data pointer `self._ptr`.

    * `hip._util.types.Pointer`:

      Takes the pointer address ``pyobj._ptr`` and writes it to ``self._ptr``.
      No ownership is transferred.

    Type checks are performed in the above order.

    C Attributes:
        _ptr (C type ``void *``, protected):
            Stores a pointer to the data of the original Python object.
        _is_ptr_owner (C type ``bint``, protected):
            If this wrapper is the owner of the underlying data.
        _py_buffer (C type ``Py_buffer`, protected):
            Stores a pointer to the data of the original Python object.
        _py_buffer_acquired (C type ``bint``, protected):
            Stores a pointer to the data of the original Python object.
    """
    # C members declared in pxd file

    def __cinit__(self):
        self._ptr = NULL
        self._is_ptr_owner = False
        self._py_buffer_acquired = False

    cdef chip.char2* getElementPtr(self):
        return <chip.char2*>self._ptr

    @staticmethod
    cdef char2 fromPtr(void* ptr, bint owner=False):
        """Factory function to create ``char2`` objects from
        given ``chip.char2`` pointer.

        Setting ``owner`` flag to ``True`` causes
        the extension type to free the structure pointed to by ``ptr``
        when the wrapper object is deallocated.
        """
        # Fast call to __new__() that bypasses the __init__() constructor.
        cdef char2 wrapper = char2.__new__(char2)
        wrapper._ptr = ptr
        wrapper._is_ptr_owner = owner
        return wrapper

    @staticmethod
    def fromObj(pyobj):
        """Creates a char2 from a Python object.

        Derives a char2 from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``char2`` reference, this method
        returns it directly. No new ``char2`` is created in this case.
        """
        return char2.fromPyobj(pyobj)

    @staticmethod
    cdef char2 fromPyobj(object pyobj):
        """Creates a char2 from a Python object.

        Derives a char2 from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``char2`` reference, this method
        returns it directly. No new ``char2`` is created in this case.

        Args:
            pyobj (object): Must be either `None`; a `hip._util.types.Pointer`; a simple, contiguous buffer according to the buffer protocol;
                            or of type `char2`; `int`; or `ctypes.c_void_p`.

        Note:
            This routine does not perform a copy but returns the original ``pyobj``
            if ``pyobj`` is an instance of char2!
        """
        cdef char2 wrapper

        if isinstance(pyobj,char2):
            return pyobj
        else:
            wrapper = char2.__new__(char2)
            wrapper.init_from_pyobj(pyobj)
            return wrapper

    def __dealloc__(self):
        # Release the buffer handle
        if self._py_buffer_acquired is True:
            cpython.buffer.PyBuffer_Release(&self._py_buffer)
        # De-allocate if not null and flag is set
        if self._ptr is not NULL and self._is_ptr_owner is True:
            stdlib.free(self._ptr)
            self._ptr = NULL

    @staticmethod
    cdef __allocate(void** ptr):
        ptr[0] = stdlib.malloc(sizeof(chip.char2))
        string.memset(<void*>ptr[0], 0, sizeof(chip.char2))

        if ptr[0] is NULL:
            raise MemoryError

    @staticmethod
    cdef char2 new():
        """Factory function to create char2 objects with
        newly allocated chip.char2"""
        cdef void* ptr
        char2.__allocate(&ptr)
        return char2.fromPtr(ptr, owner=True)

    @staticmethod
    cdef char2 fromValue(chip.char2 other):
        """Allocate new C type and copy from ``other``.
        """
        wrapper = char2.new()
        string.memcpy(wrapper._ptr, &other, sizeof(chip.char2))
        return wrapper

    def c_sizeof(self):
        """Returns the size of the underlying C type in bytes.
        Note:
            Implemented as function to not collide with
            autogenerated property names.
        """
        return sizeof(chip.char2)

    def __int__(self):
        """Returns the data's address as long integer.
        """
        return cpython.long.PyLong_FromVoidPtr(self._ptr)

    def __repr__(self):
        return f"<char2 object, ptr: {int(self)}>"

    def as_c_void_p(self):
        """Returns the data's address as `ctypes.c_void_p`
        Note:
            Implemented as function to not collide with
            autogenerated property names.
        """
        return ctypes.c_void_p(int(self))

    def __init__(self,*args,**kwargs):
        """Constructor type char2.

        Constructor for type char2.

        Args:
            *args:
                Positional arguments. Initialize all or a subset of the member variables
                according to their order of declaration.
            **kwargs:
                Can be used to initialize member variables at construction,
                Just pass an argument expression of the form <member>=<value>
                per member that you want to initialize.
        """
        char2.__allocate(&self._ptr)
        self._is_ptr_owner = True
        attribs = self.PROPERTIES()
        used_attribs = set()
        if len(args) > len(attribs):
            raise ValueError("More positional arguments specified than this type has properties.")
        for i,v in enumerate(args):
            setattr(self,attribs[i],v)
            used_attribs.add(attribs[i])
        valid_names = ", ".join(["'"+p+"'" for p in attribs])
        for k,v in kwargs.items():
            if k in used_attribs:
                raise KeyError(f"argument '{k}' has already been specified as positional argument.")
            elif k not in attribs:
                raise KeyError(f"'{k}' is no valid property name. Valid names: {valid_names}")
            setattr(self,k,v)
    def get_x(self, i):
        """Get value ``x`` of ``(<chip.char2*>self._ptr)[i]``.
        """
        return (<chip.char2*>self._ptr)[i].x
    def set_x(self, i, char value):
        """Set value ``x`` of ``(<chip.char2*>self._ptr)[i]``.
        """
        (<chip.char2*>self._ptr)[i].x = value
    @property
    def x(self):
        """(undocumented)"""
        return self.get_x(0)
    @x.setter
    def x(self, char value):
        self.set_x(0,value)

    def get_y(self, i):
        """Get value ``y`` of ``(<chip.char2*>self._ptr)[i]``.
        """
        return (<chip.char2*>self._ptr)[i].y
    def set_y(self, i, char value):
        """Set value ``y`` of ``(<chip.char2*>self._ptr)[i]``.
        """
        (<chip.char2*>self._ptr)[i].y = value
    @property
    def y(self):
        """(undocumented)"""
        return self.get_y(0)
    @y.setter
    def y(self, char value):
        self.set_y(0,value)

    @staticmethod
    def PROPERTIES():
        return ["x","y"]

    def __contains__(self,item):
        properties = self.PROPERTIES()
        return item in properties

    def __getitem__(self,item):
        properties = self.PROPERTIES()
        if isinstance(item,int):
            if item < 0 or item >= len(properties):
                raise IndexError()
            return getattr(self,properties[item])
        raise ValueError("'item' type must be 'int'")


cdef class char3(hip._util.types.Pointer):
    """Python wrapper for cdef class chip.char3.

    Python wrapper for cdef class chip.char3.

    If this type is initialized via its `__init__` method, it allocates a
    member of the underlying C type and destroys it again if the wrapper
    type is deallocated.

    This type also serves as adapter when appearing as argument type in a
    function signature. In this case, the type can further be initialized
    from a number of Python objects:

    * `None`:

      This will set the ``self._ptr`` attribute to ``NULL``.

    * `int`:

      Interprets the integer value as pointer address and writes it to ``self._ptr``.
      No ownership is transferred.

    * `ctypes.c_void_p`:

      Takes the pointer address ``pyobj.value`` and writes it to ``self._ptr``.
      No ownership is transferred.

    * `object` that implements the `CUDA Array Interface <https://numba.readthedocs.io/en/stable/cuda/cuda_array_interface.html>`_ protocol:

      Takes the integer-valued pointer address, i.e. the first entry of the `data` tuple
      from `pyobj`'s member ``__cuda_array_interface__``  and writes it to ``self._ptr``.

    * `object` that implements the Python buffer protocol:

      If the object represents a simple contiguous array,
      writes the `Py_buffer` associated with ``pyobj`` to `self._py_buffer`,
      sets the `self._py_buffer_acquired` flag to `True`, and
      writes `self._py_buffer.buf` to the data pointer `self._ptr`.

    * `hip._util.types.Pointer`:

      Takes the pointer address ``pyobj._ptr`` and writes it to ``self._ptr``.
      No ownership is transferred.

    Type checks are performed in the above order.

    C Attributes:
        _ptr (C type ``void *``, protected):
            Stores a pointer to the data of the original Python object.
        _is_ptr_owner (C type ``bint``, protected):
            If this wrapper is the owner of the underlying data.
        _py_buffer (C type ``Py_buffer`, protected):
            Stores a pointer to the data of the original Python object.
        _py_buffer_acquired (C type ``bint``, protected):
            Stores a pointer to the data of the original Python object.
    """
    # C members declared in pxd file

    def __cinit__(self):
        self._ptr = NULL
        self._is_ptr_owner = False
        self._py_buffer_acquired = False

    cdef chip.char3* getElementPtr(self):
        return <chip.char3*>self._ptr

    @staticmethod
    cdef char3 fromPtr(void* ptr, bint owner=False):
        """Factory function to create ``char3`` objects from
        given ``chip.char3`` pointer.

        Setting ``owner`` flag to ``True`` causes
        the extension type to free the structure pointed to by ``ptr``
        when the wrapper object is deallocated.
        """
        # Fast call to __new__() that bypasses the __init__() constructor.
        cdef char3 wrapper = char3.__new__(char3)
        wrapper._ptr = ptr
        wrapper._is_ptr_owner = owner
        return wrapper

    @staticmethod
    def fromObj(pyobj):
        """Creates a char3 from a Python object.

        Derives a char3 from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``char3`` reference, this method
        returns it directly. No new ``char3`` is created in this case.
        """
        return char3.fromPyobj(pyobj)

    @staticmethod
    cdef char3 fromPyobj(object pyobj):
        """Creates a char3 from a Python object.

        Derives a char3 from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``char3`` reference, this method
        returns it directly. No new ``char3`` is created in this case.

        Args:
            pyobj (object): Must be either `None`; a `hip._util.types.Pointer`; a simple, contiguous buffer according to the buffer protocol;
                            or of type `char3`; `int`; or `ctypes.c_void_p`.

        Note:
            This routine does not perform a copy but returns the original ``pyobj``
            if ``pyobj`` is an instance of char3!
        """
        cdef char3 wrapper

        if isinstance(pyobj,char3):
            return pyobj
        else:
            wrapper = char3.__new__(char3)
            wrapper.init_from_pyobj(pyobj)
            return wrapper

    def __dealloc__(self):
        # Release the buffer handle
        if self._py_buffer_acquired is True:
            cpython.buffer.PyBuffer_Release(&self._py_buffer)
        # De-allocate if not null and flag is set
        if self._ptr is not NULL and self._is_ptr_owner is True:
            stdlib.free(self._ptr)
            self._ptr = NULL

    @staticmethod
    cdef __allocate(void** ptr):
        ptr[0] = stdlib.malloc(sizeof(chip.char3))
        string.memset(<void*>ptr[0], 0, sizeof(chip.char3))

        if ptr[0] is NULL:
            raise MemoryError

    @staticmethod
    cdef char3 new():
        """Factory function to create char3 objects with
        newly allocated chip.char3"""
        cdef void* ptr
        char3.__allocate(&ptr)
        return char3.fromPtr(ptr, owner=True)

    @staticmethod
    cdef char3 fromValue(chip.char3 other):
        """Allocate new C type and copy from ``other``.
        """
        wrapper = char3.new()
        string.memcpy(wrapper._ptr, &other, sizeof(chip.char3))
        return wrapper

    def c_sizeof(self):
        """Returns the size of the underlying C type in bytes.
        Note:
            Implemented as function to not collide with
            autogenerated property names.
        """
        return sizeof(chip.char3)

    def __int__(self):
        """Returns the data's address as long integer.
        """
        return cpython.long.PyLong_FromVoidPtr(self._ptr)

    def __repr__(self):
        return f"<char3 object, ptr: {int(self)}>"

    def as_c_void_p(self):
        """Returns the data's address as `ctypes.c_void_p`
        Note:
            Implemented as function to not collide with
            autogenerated property names.
        """
        return ctypes.c_void_p(int(self))

    def __init__(self,*args,**kwargs):
        """Constructor type char3.

        Constructor for type char3.

        Args:
            *args:
                Positional arguments. Initialize all or a subset of the member variables
                according to their order of declaration.
            **kwargs:
                Can be used to initialize member variables at construction,
                Just pass an argument expression of the form <member>=<value>
                per member that you want to initialize.
        """
        char3.__allocate(&self._ptr)
        self._is_ptr_owner = True
        attribs = self.PROPERTIES()
        used_attribs = set()
        if len(args) > len(attribs):
            raise ValueError("More positional arguments specified than this type has properties.")
        for i,v in enumerate(args):
            setattr(self,attribs[i],v)
            used_attribs.add(attribs[i])
        valid_names = ", ".join(["'"+p+"'" for p in attribs])
        for k,v in kwargs.items():
            if k in used_attribs:
                raise KeyError(f"argument '{k}' has already been specified as positional argument.")
            elif k not in attribs:
                raise KeyError(f"'{k}' is no valid property name. Valid names: {valid_names}")
            setattr(self,k,v)
    def get_x(self, i):
        """Get value ``x`` of ``(<chip.char3*>self._ptr)[i]``.
        """
        return (<chip.char3*>self._ptr)[i].x
    def set_x(self, i, char value):
        """Set value ``x`` of ``(<chip.char3*>self._ptr)[i]``.
        """
        (<chip.char3*>self._ptr)[i].x = value
    @property
    def x(self):
        """(undocumented)"""
        return self.get_x(0)
    @x.setter
    def x(self, char value):
        self.set_x(0,value)

    def get_y(self, i):
        """Get value ``y`` of ``(<chip.char3*>self._ptr)[i]``.
        """
        return (<chip.char3*>self._ptr)[i].y
    def set_y(self, i, char value):
        """Set value ``y`` of ``(<chip.char3*>self._ptr)[i]``.
        """
        (<chip.char3*>self._ptr)[i].y = value
    @property
    def y(self):
        """(undocumented)"""
        return self.get_y(0)
    @y.setter
    def y(self, char value):
        self.set_y(0,value)

    def get_z(self, i):
        """Get value ``z`` of ``(<chip.char3*>self._ptr)[i]``.
        """
        return (<chip.char3*>self._ptr)[i].z
    def set_z(self, i, char value):
        """Set value ``z`` of ``(<chip.char3*>self._ptr)[i]``.
        """
        (<chip.char3*>self._ptr)[i].z = value
    @property
    def z(self):
        """(undocumented)"""
        return self.get_z(0)
    @z.setter
    def z(self, char value):
        self.set_z(0,value)

    @staticmethod
    def PROPERTIES():
        return ["x","y","z"]

    def __contains__(self,item):
        properties = self.PROPERTIES()
        return item in properties

    def __getitem__(self,item):
        properties = self.PROPERTIES()
        if isinstance(item,int):
            if item < 0 or item >= len(properties):
                raise IndexError()
            return getattr(self,properties[item])
        raise ValueError("'item' type must be 'int'")


cdef class char4(hip._util.types.Pointer):
    """Python wrapper for cdef class chip.char4.

    Python wrapper for cdef class chip.char4.

    If this type is initialized via its `__init__` method, it allocates a
    member of the underlying C type and destroys it again if the wrapper
    type is deallocated.

    This type also serves as adapter when appearing as argument type in a
    function signature. In this case, the type can further be initialized
    from a number of Python objects:

    * `None`:

      This will set the ``self._ptr`` attribute to ``NULL``.

    * `int`:

      Interprets the integer value as pointer address and writes it to ``self._ptr``.
      No ownership is transferred.

    * `ctypes.c_void_p`:

      Takes the pointer address ``pyobj.value`` and writes it to ``self._ptr``.
      No ownership is transferred.

    * `object` that implements the `CUDA Array Interface <https://numba.readthedocs.io/en/stable/cuda/cuda_array_interface.html>`_ protocol:

      Takes the integer-valued pointer address, i.e. the first entry of the `data` tuple
      from `pyobj`'s member ``__cuda_array_interface__``  and writes it to ``self._ptr``.

    * `object` that implements the Python buffer protocol:

      If the object represents a simple contiguous array,
      writes the `Py_buffer` associated with ``pyobj`` to `self._py_buffer`,
      sets the `self._py_buffer_acquired` flag to `True`, and
      writes `self._py_buffer.buf` to the data pointer `self._ptr`.

    * `hip._util.types.Pointer`:

      Takes the pointer address ``pyobj._ptr`` and writes it to ``self._ptr``.
      No ownership is transferred.

    Type checks are performed in the above order.

    C Attributes:
        _ptr (C type ``void *``, protected):
            Stores a pointer to the data of the original Python object.
        _is_ptr_owner (C type ``bint``, protected):
            If this wrapper is the owner of the underlying data.
        _py_buffer (C type ``Py_buffer`, protected):
            Stores a pointer to the data of the original Python object.
        _py_buffer_acquired (C type ``bint``, protected):
            Stores a pointer to the data of the original Python object.
    """
    # C members declared in pxd file

    def __cinit__(self):
        self._ptr = NULL
        self._is_ptr_owner = False
        self._py_buffer_acquired = False

    cdef chip.char4* getElementPtr(self):
        return <chip.char4*>self._ptr

    @staticmethod
    cdef char4 fromPtr(void* ptr, bint owner=False):
        """Factory function to create ``char4`` objects from
        given ``chip.char4`` pointer.

        Setting ``owner`` flag to ``True`` causes
        the extension type to free the structure pointed to by ``ptr``
        when the wrapper object is deallocated.
        """
        # Fast call to __new__() that bypasses the __init__() constructor.
        cdef char4 wrapper = char4.__new__(char4)
        wrapper._ptr = ptr
        wrapper._is_ptr_owner = owner
        return wrapper

    @staticmethod
    def fromObj(pyobj):
        """Creates a char4 from a Python object.

        Derives a char4 from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``char4`` reference, this method
        returns it directly. No new ``char4`` is created in this case.
        """
        return char4.fromPyobj(pyobj)

    @staticmethod
    cdef char4 fromPyobj(object pyobj):
        """Creates a char4 from a Python object.

        Derives a char4 from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``char4`` reference, this method
        returns it directly. No new ``char4`` is created in this case.

        Args:
            pyobj (object): Must be either `None`; a `hip._util.types.Pointer`; a simple, contiguous buffer according to the buffer protocol;
                            or of type `char4`; `int`; or `ctypes.c_void_p`.

        Note:
            This routine does not perform a copy but returns the original ``pyobj``
            if ``pyobj`` is an instance of char4!
        """
        cdef char4 wrapper

        if isinstance(pyobj,char4):
            return pyobj
        else:
            wrapper = char4.__new__(char4)
            wrapper.init_from_pyobj(pyobj)
            return wrapper

    def __dealloc__(self):
        # Release the buffer handle
        if self._py_buffer_acquired is True:
            cpython.buffer.PyBuffer_Release(&self._py_buffer)
        # De-allocate if not null and flag is set
        if self._ptr is not NULL and self._is_ptr_owner is True:
            stdlib.free(self._ptr)
            self._ptr = NULL

    @staticmethod
    cdef __allocate(void** ptr):
        ptr[0] = stdlib.malloc(sizeof(chip.char4))
        string.memset(<void*>ptr[0], 0, sizeof(chip.char4))

        if ptr[0] is NULL:
            raise MemoryError

    @staticmethod
    cdef char4 new():
        """Factory function to create char4 objects with
        newly allocated chip.char4"""
        cdef void* ptr
        char4.__allocate(&ptr)
        return char4.fromPtr(ptr, owner=True)

    @staticmethod
    cdef char4 fromValue(chip.char4 other):
        """Allocate new C type and copy from ``other``.
        """
        wrapper = char4.new()
        string.memcpy(wrapper._ptr, &other, sizeof(chip.char4))
        return wrapper

    def c_sizeof(self):
        """Returns the size of the underlying C type in bytes.
        Note:
            Implemented as function to not collide with
            autogenerated property names.
        """
        return sizeof(chip.char4)

    def __int__(self):
        """Returns the data's address as long integer.
        """
        return cpython.long.PyLong_FromVoidPtr(self._ptr)

    def __repr__(self):
        return f"<char4 object, ptr: {int(self)}>"

    def as_c_void_p(self):
        """Returns the data's address as `ctypes.c_void_p`
        Note:
            Implemented as function to not collide with
            autogenerated property names.
        """
        return ctypes.c_void_p(int(self))

    def __init__(self,*args,**kwargs):
        """Constructor type char4.

        Constructor for type char4.

        Args:
            *args:
                Positional arguments. Initialize all or a subset of the member variables
                according to their order of declaration.
            **kwargs:
                Can be used to initialize member variables at construction,
                Just pass an argument expression of the form <member>=<value>
                per member that you want to initialize.
        """
        char4.__allocate(&self._ptr)
        self._is_ptr_owner = True
        attribs = self.PROPERTIES()
        used_attribs = set()
        if len(args) > len(attribs):
            raise ValueError("More positional arguments specified than this type has properties.")
        for i,v in enumerate(args):
            setattr(self,attribs[i],v)
            used_attribs.add(attribs[i])
        valid_names = ", ".join(["'"+p+"'" for p in attribs])
        for k,v in kwargs.items():
            if k in used_attribs:
                raise KeyError(f"argument '{k}' has already been specified as positional argument.")
            elif k not in attribs:
                raise KeyError(f"'{k}' is no valid property name. Valid names: {valid_names}")
            setattr(self,k,v)
    def get_x(self, i):
        """Get value ``x`` of ``(<chip.char4*>self._ptr)[i]``.
        """
        return (<chip.char4*>self._ptr)[i].x
    def set_x(self, i, char value):
        """Set value ``x`` of ``(<chip.char4*>self._ptr)[i]``.
        """
        (<chip.char4*>self._ptr)[i].x = value
    @property
    def x(self):
        """(undocumented)"""
        return self.get_x(0)
    @x.setter
    def x(self, char value):
        self.set_x(0,value)

    def get_y(self, i):
        """Get value ``y`` of ``(<chip.char4*>self._ptr)[i]``.
        """
        return (<chip.char4*>self._ptr)[i].y
    def set_y(self, i, char value):
        """Set value ``y`` of ``(<chip.char4*>self._ptr)[i]``.
        """
        (<chip.char4*>self._ptr)[i].y = value
    @property
    def y(self):
        """(undocumented)"""
        return self.get_y(0)
    @y.setter
    def y(self, char value):
        self.set_y(0,value)

    def get_z(self, i):
        """Get value ``z`` of ``(<chip.char4*>self._ptr)[i]``.
        """
        return (<chip.char4*>self._ptr)[i].z
    def set_z(self, i, char value):
        """Set value ``z`` of ``(<chip.char4*>self._ptr)[i]``.
        """
        (<chip.char4*>self._ptr)[i].z = value
    @property
    def z(self):
        """(undocumented)"""
        return self.get_z(0)
    @z.setter
    def z(self, char value):
        self.set_z(0,value)

    def get_w(self, i):
        """Get value ``w`` of ``(<chip.char4*>self._ptr)[i]``.
        """
        return (<chip.char4*>self._ptr)[i].w
    def set_w(self, i, char value):
        """Set value ``w`` of ``(<chip.char4*>self._ptr)[i]``.
        """
        (<chip.char4*>self._ptr)[i].w = value
    @property
    def w(self):
        """(undocumented)"""
        return self.get_w(0)
    @w.setter
    def w(self, char value):
        self.set_w(0,value)

    @staticmethod
    def PROPERTIES():
        return ["x","y","z","w"]

    def __contains__(self,item):
        properties = self.PROPERTIES()
        return item in properties

    def __getitem__(self,item):
        properties = self.PROPERTIES()
        if isinstance(item,int):
            if item < 0 or item >= len(properties):
                raise IndexError()
            return getattr(self,properties[item])
        raise ValueError("'item' type must be 'int'")


cdef class ushort1(hip._util.types.Pointer):
    """Python wrapper for cdef class chip.ushort1.

    Python wrapper for cdef class chip.ushort1.

    If this type is initialized via its `__init__` method, it allocates a
    member of the underlying C type and destroys it again if the wrapper
    type is deallocated.

    This type also serves as adapter when appearing as argument type in a
    function signature. In this case, the type can further be initialized
    from a number of Python objects:

    * `None`:

      This will set the ``self._ptr`` attribute to ``NULL``.

    * `int`:

      Interprets the integer value as pointer address and writes it to ``self._ptr``.
      No ownership is transferred.

    * `ctypes.c_void_p`:

      Takes the pointer address ``pyobj.value`` and writes it to ``self._ptr``.
      No ownership is transferred.

    * `object` that implements the `CUDA Array Interface <https://numba.readthedocs.io/en/stable/cuda/cuda_array_interface.html>`_ protocol:

      Takes the integer-valued pointer address, i.e. the first entry of the `data` tuple
      from `pyobj`'s member ``__cuda_array_interface__``  and writes it to ``self._ptr``.

    * `object` that implements the Python buffer protocol:

      If the object represents a simple contiguous array,
      writes the `Py_buffer` associated with ``pyobj`` to `self._py_buffer`,
      sets the `self._py_buffer_acquired` flag to `True`, and
      writes `self._py_buffer.buf` to the data pointer `self._ptr`.

    * `hip._util.types.Pointer`:

      Takes the pointer address ``pyobj._ptr`` and writes it to ``self._ptr``.
      No ownership is transferred.

    Type checks are performed in the above order.

    C Attributes:
        _ptr (C type ``void *``, protected):
            Stores a pointer to the data of the original Python object.
        _is_ptr_owner (C type ``bint``, protected):
            If this wrapper is the owner of the underlying data.
        _py_buffer (C type ``Py_buffer`, protected):
            Stores a pointer to the data of the original Python object.
        _py_buffer_acquired (C type ``bint``, protected):
            Stores a pointer to the data of the original Python object.
    """
    # C members declared in pxd file

    def __cinit__(self):
        self._ptr = NULL
        self._is_ptr_owner = False
        self._py_buffer_acquired = False

    cdef chip.ushort1* getElementPtr(self):
        return <chip.ushort1*>self._ptr

    @staticmethod
    cdef ushort1 fromPtr(void* ptr, bint owner=False):
        """Factory function to create ``ushort1`` objects from
        given ``chip.ushort1`` pointer.

        Setting ``owner`` flag to ``True`` causes
        the extension type to free the structure pointed to by ``ptr``
        when the wrapper object is deallocated.
        """
        # Fast call to __new__() that bypasses the __init__() constructor.
        cdef ushort1 wrapper = ushort1.__new__(ushort1)
        wrapper._ptr = ptr
        wrapper._is_ptr_owner = owner
        return wrapper

    @staticmethod
    def fromObj(pyobj):
        """Creates a ushort1 from a Python object.

        Derives a ushort1 from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``ushort1`` reference, this method
        returns it directly. No new ``ushort1`` is created in this case.
        """
        return ushort1.fromPyobj(pyobj)

    @staticmethod
    cdef ushort1 fromPyobj(object pyobj):
        """Creates a ushort1 from a Python object.

        Derives a ushort1 from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``ushort1`` reference, this method
        returns it directly. No new ``ushort1`` is created in this case.

        Args:
            pyobj (object): Must be either `None`; a `hip._util.types.Pointer`; a simple, contiguous buffer according to the buffer protocol;
                            or of type `ushort1`; `int`; or `ctypes.c_void_p`.

        Note:
            This routine does not perform a copy but returns the original ``pyobj``
            if ``pyobj`` is an instance of ushort1!
        """
        cdef ushort1 wrapper

        if isinstance(pyobj,ushort1):
            return pyobj
        else:
            wrapper = ushort1.__new__(ushort1)
            wrapper.init_from_pyobj(pyobj)
            return wrapper

    def __dealloc__(self):
        # Release the buffer handle
        if self._py_buffer_acquired is True:
            cpython.buffer.PyBuffer_Release(&self._py_buffer)
        # De-allocate if not null and flag is set
        if self._ptr is not NULL and self._is_ptr_owner is True:
            stdlib.free(self._ptr)
            self._ptr = NULL

    @staticmethod
    cdef __allocate(void** ptr):
        ptr[0] = stdlib.malloc(sizeof(chip.ushort1))
        string.memset(<void*>ptr[0], 0, sizeof(chip.ushort1))

        if ptr[0] is NULL:
            raise MemoryError

    @staticmethod
    cdef ushort1 new():
        """Factory function to create ushort1 objects with
        newly allocated chip.ushort1"""
        cdef void* ptr
        ushort1.__allocate(&ptr)
        return ushort1.fromPtr(ptr, owner=True)

    @staticmethod
    cdef ushort1 fromValue(chip.ushort1 other):
        """Allocate new C type and copy from ``other``.
        """
        wrapper = ushort1.new()
        string.memcpy(wrapper._ptr, &other, sizeof(chip.ushort1))
        return wrapper

    def c_sizeof(self):
        """Returns the size of the underlying C type in bytes.
        Note:
            Implemented as function to not collide with
            autogenerated property names.
        """
        return sizeof(chip.ushort1)

    def __int__(self):
        """Returns the data's address as long integer.
        """
        return cpython.long.PyLong_FromVoidPtr(self._ptr)

    def __repr__(self):
        return f"<ushort1 object, ptr: {int(self)}>"

    def as_c_void_p(self):
        """Returns the data's address as `ctypes.c_void_p`
        Note:
            Implemented as function to not collide with
            autogenerated property names.
        """
        return ctypes.c_void_p(int(self))

    def __init__(self,*args,**kwargs):
        """Constructor type ushort1.

        Constructor for type ushort1.

        Args:
            *args:
                Positional arguments. Initialize all or a subset of the member variables
                according to their order of declaration.
            **kwargs:
                Can be used to initialize member variables at construction,
                Just pass an argument expression of the form <member>=<value>
                per member that you want to initialize.
        """
        ushort1.__allocate(&self._ptr)
        self._is_ptr_owner = True
        attribs = self.PROPERTIES()
        used_attribs = set()
        if len(args) > len(attribs):
            raise ValueError("More positional arguments specified than this type has properties.")
        for i,v in enumerate(args):
            setattr(self,attribs[i],v)
            used_attribs.add(attribs[i])
        valid_names = ", ".join(["'"+p+"'" for p in attribs])
        for k,v in kwargs.items():
            if k in used_attribs:
                raise KeyError(f"argument '{k}' has already been specified as positional argument.")
            elif k not in attribs:
                raise KeyError(f"'{k}' is no valid property name. Valid names: {valid_names}")
            setattr(self,k,v)
    def get_x(self, i):
        """Get value ``x`` of ``(<chip.ushort1*>self._ptr)[i]``.
        """
        return (<chip.ushort1*>self._ptr)[i].x
    def set_x(self, i, unsigned short value):
        """Set value ``x`` of ``(<chip.ushort1*>self._ptr)[i]``.
        """
        (<chip.ushort1*>self._ptr)[i].x = value
    @property
    def x(self):
        """(undocumented)"""
        return self.get_x(0)
    @x.setter
    def x(self, unsigned short value):
        self.set_x(0,value)

    @staticmethod
    def PROPERTIES():
        return ["x"]

    def __contains__(self,item):
        properties = self.PROPERTIES()
        return item in properties

    def __getitem__(self,item):
        properties = self.PROPERTIES()
        if isinstance(item,int):
            if item < 0 or item >= len(properties):
                raise IndexError()
            return getattr(self,properties[item])
        raise ValueError("'item' type must be 'int'")


cdef class ushort2(hip._util.types.Pointer):
    """Python wrapper for cdef class chip.ushort2.

    Python wrapper for cdef class chip.ushort2.

    If this type is initialized via its `__init__` method, it allocates a
    member of the underlying C type and destroys it again if the wrapper
    type is deallocated.

    This type also serves as adapter when appearing as argument type in a
    function signature. In this case, the type can further be initialized
    from a number of Python objects:

    * `None`:

      This will set the ``self._ptr`` attribute to ``NULL``.

    * `int`:

      Interprets the integer value as pointer address and writes it to ``self._ptr``.
      No ownership is transferred.

    * `ctypes.c_void_p`:

      Takes the pointer address ``pyobj.value`` and writes it to ``self._ptr``.
      No ownership is transferred.

    * `object` that implements the `CUDA Array Interface <https://numba.readthedocs.io/en/stable/cuda/cuda_array_interface.html>`_ protocol:

      Takes the integer-valued pointer address, i.e. the first entry of the `data` tuple
      from `pyobj`'s member ``__cuda_array_interface__``  and writes it to ``self._ptr``.

    * `object` that implements the Python buffer protocol:

      If the object represents a simple contiguous array,
      writes the `Py_buffer` associated with ``pyobj`` to `self._py_buffer`,
      sets the `self._py_buffer_acquired` flag to `True`, and
      writes `self._py_buffer.buf` to the data pointer `self._ptr`.

    * `hip._util.types.Pointer`:

      Takes the pointer address ``pyobj._ptr`` and writes it to ``self._ptr``.
      No ownership is transferred.

    Type checks are performed in the above order.

    C Attributes:
        _ptr (C type ``void *``, protected):
            Stores a pointer to the data of the original Python object.
        _is_ptr_owner (C type ``bint``, protected):
            If this wrapper is the owner of the underlying data.
        _py_buffer (C type ``Py_buffer`, protected):
            Stores a pointer to the data of the original Python object.
        _py_buffer_acquired (C type ``bint``, protected):
            Stores a pointer to the data of the original Python object.
    """
    # C members declared in pxd file

    def __cinit__(self):
        self._ptr = NULL
        self._is_ptr_owner = False
        self._py_buffer_acquired = False

    cdef chip.ushort2* getElementPtr(self):
        return <chip.ushort2*>self._ptr

    @staticmethod
    cdef ushort2 fromPtr(void* ptr, bint owner=False):
        """Factory function to create ``ushort2`` objects from
        given ``chip.ushort2`` pointer.

        Setting ``owner`` flag to ``True`` causes
        the extension type to free the structure pointed to by ``ptr``
        when the wrapper object is deallocated.
        """
        # Fast call to __new__() that bypasses the __init__() constructor.
        cdef ushort2 wrapper = ushort2.__new__(ushort2)
        wrapper._ptr = ptr
        wrapper._is_ptr_owner = owner
        return wrapper

    @staticmethod
    def fromObj(pyobj):
        """Creates a ushort2 from a Python object.

        Derives a ushort2 from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``ushort2`` reference, this method
        returns it directly. No new ``ushort2`` is created in this case.
        """
        return ushort2.fromPyobj(pyobj)

    @staticmethod
    cdef ushort2 fromPyobj(object pyobj):
        """Creates a ushort2 from a Python object.

        Derives a ushort2 from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``ushort2`` reference, this method
        returns it directly. No new ``ushort2`` is created in this case.

        Args:
            pyobj (object): Must be either `None`; a `hip._util.types.Pointer`; a simple, contiguous buffer according to the buffer protocol;
                            or of type `ushort2`; `int`; or `ctypes.c_void_p`.

        Note:
            This routine does not perform a copy but returns the original ``pyobj``
            if ``pyobj`` is an instance of ushort2!
        """
        cdef ushort2 wrapper

        if isinstance(pyobj,ushort2):
            return pyobj
        else:
            wrapper = ushort2.__new__(ushort2)
            wrapper.init_from_pyobj(pyobj)
            return wrapper

    def __dealloc__(self):
        # Release the buffer handle
        if self._py_buffer_acquired is True:
            cpython.buffer.PyBuffer_Release(&self._py_buffer)
        # De-allocate if not null and flag is set
        if self._ptr is not NULL and self._is_ptr_owner is True:
            stdlib.free(self._ptr)
            self._ptr = NULL

    @staticmethod
    cdef __allocate(void** ptr):
        ptr[0] = stdlib.malloc(sizeof(chip.ushort2))
        string.memset(<void*>ptr[0], 0, sizeof(chip.ushort2))

        if ptr[0] is NULL:
            raise MemoryError

    @staticmethod
    cdef ushort2 new():
        """Factory function to create ushort2 objects with
        newly allocated chip.ushort2"""
        cdef void* ptr
        ushort2.__allocate(&ptr)
        return ushort2.fromPtr(ptr, owner=True)

    @staticmethod
    cdef ushort2 fromValue(chip.ushort2 other):
        """Allocate new C type and copy from ``other``.
        """
        wrapper = ushort2.new()
        string.memcpy(wrapper._ptr, &other, sizeof(chip.ushort2))
        return wrapper

    def c_sizeof(self):
        """Returns the size of the underlying C type in bytes.
        Note:
            Implemented as function to not collide with
            autogenerated property names.
        """
        return sizeof(chip.ushort2)

    def __int__(self):
        """Returns the data's address as long integer.
        """
        return cpython.long.PyLong_FromVoidPtr(self._ptr)

    def __repr__(self):
        return f"<ushort2 object, ptr: {int(self)}>"

    def as_c_void_p(self):
        """Returns the data's address as `ctypes.c_void_p`
        Note:
            Implemented as function to not collide with
            autogenerated property names.
        """
        return ctypes.c_void_p(int(self))

    def __init__(self,*args,**kwargs):
        """Constructor type ushort2.

        Constructor for type ushort2.

        Args:
            *args:
                Positional arguments. Initialize all or a subset of the member variables
                according to their order of declaration.
            **kwargs:
                Can be used to initialize member variables at construction,
                Just pass an argument expression of the form <member>=<value>
                per member that you want to initialize.
        """
        ushort2.__allocate(&self._ptr)
        self._is_ptr_owner = True
        attribs = self.PROPERTIES()
        used_attribs = set()
        if len(args) > len(attribs):
            raise ValueError("More positional arguments specified than this type has properties.")
        for i,v in enumerate(args):
            setattr(self,attribs[i],v)
            used_attribs.add(attribs[i])
        valid_names = ", ".join(["'"+p+"'" for p in attribs])
        for k,v in kwargs.items():
            if k in used_attribs:
                raise KeyError(f"argument '{k}' has already been specified as positional argument.")
            elif k not in attribs:
                raise KeyError(f"'{k}' is no valid property name. Valid names: {valid_names}")
            setattr(self,k,v)
    def get_x(self, i):
        """Get value ``x`` of ``(<chip.ushort2*>self._ptr)[i]``.
        """
        return (<chip.ushort2*>self._ptr)[i].x
    def set_x(self, i, unsigned short value):
        """Set value ``x`` of ``(<chip.ushort2*>self._ptr)[i]``.
        """
        (<chip.ushort2*>self._ptr)[i].x = value
    @property
    def x(self):
        """(undocumented)"""
        return self.get_x(0)
    @x.setter
    def x(self, unsigned short value):
        self.set_x(0,value)

    def get_y(self, i):
        """Get value ``y`` of ``(<chip.ushort2*>self._ptr)[i]``.
        """
        return (<chip.ushort2*>self._ptr)[i].y
    def set_y(self, i, unsigned short value):
        """Set value ``y`` of ``(<chip.ushort2*>self._ptr)[i]``.
        """
        (<chip.ushort2*>self._ptr)[i].y = value
    @property
    def y(self):
        """(undocumented)"""
        return self.get_y(0)
    @y.setter
    def y(self, unsigned short value):
        self.set_y(0,value)

    @staticmethod
    def PROPERTIES():
        return ["x","y"]

    def __contains__(self,item):
        properties = self.PROPERTIES()
        return item in properties

    def __getitem__(self,item):
        properties = self.PROPERTIES()
        if isinstance(item,int):
            if item < 0 or item >= len(properties):
                raise IndexError()
            return getattr(self,properties[item])
        raise ValueError("'item' type must be 'int'")


cdef class ushort3(hip._util.types.Pointer):
    """Python wrapper for cdef class chip.ushort3.

    Python wrapper for cdef class chip.ushort3.

    If this type is initialized via its `__init__` method, it allocates a
    member of the underlying C type and destroys it again if the wrapper
    type is deallocated.

    This type also serves as adapter when appearing as argument type in a
    function signature. In this case, the type can further be initialized
    from a number of Python objects:

    * `None`:

      This will set the ``self._ptr`` attribute to ``NULL``.

    * `int`:

      Interprets the integer value as pointer address and writes it to ``self._ptr``.
      No ownership is transferred.

    * `ctypes.c_void_p`:

      Takes the pointer address ``pyobj.value`` and writes it to ``self._ptr``.
      No ownership is transferred.

    * `object` that implements the `CUDA Array Interface <https://numba.readthedocs.io/en/stable/cuda/cuda_array_interface.html>`_ protocol:

      Takes the integer-valued pointer address, i.e. the first entry of the `data` tuple
      from `pyobj`'s member ``__cuda_array_interface__``  and writes it to ``self._ptr``.

    * `object` that implements the Python buffer protocol:

      If the object represents a simple contiguous array,
      writes the `Py_buffer` associated with ``pyobj`` to `self._py_buffer`,
      sets the `self._py_buffer_acquired` flag to `True`, and
      writes `self._py_buffer.buf` to the data pointer `self._ptr`.

    * `hip._util.types.Pointer`:

      Takes the pointer address ``pyobj._ptr`` and writes it to ``self._ptr``.
      No ownership is transferred.

    Type checks are performed in the above order.

    C Attributes:
        _ptr (C type ``void *``, protected):
            Stores a pointer to the data of the original Python object.
        _is_ptr_owner (C type ``bint``, protected):
            If this wrapper is the owner of the underlying data.
        _py_buffer (C type ``Py_buffer`, protected):
            Stores a pointer to the data of the original Python object.
        _py_buffer_acquired (C type ``bint``, protected):
            Stores a pointer to the data of the original Python object.
    """
    # C members declared in pxd file

    def __cinit__(self):
        self._ptr = NULL
        self._is_ptr_owner = False
        self._py_buffer_acquired = False

    cdef chip.ushort3* getElementPtr(self):
        return <chip.ushort3*>self._ptr

    @staticmethod
    cdef ushort3 fromPtr(void* ptr, bint owner=False):
        """Factory function to create ``ushort3`` objects from
        given ``chip.ushort3`` pointer.

        Setting ``owner`` flag to ``True`` causes
        the extension type to free the structure pointed to by ``ptr``
        when the wrapper object is deallocated.
        """
        # Fast call to __new__() that bypasses the __init__() constructor.
        cdef ushort3 wrapper = ushort3.__new__(ushort3)
        wrapper._ptr = ptr
        wrapper._is_ptr_owner = owner
        return wrapper

    @staticmethod
    def fromObj(pyobj):
        """Creates a ushort3 from a Python object.

        Derives a ushort3 from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``ushort3`` reference, this method
        returns it directly. No new ``ushort3`` is created in this case.
        """
        return ushort3.fromPyobj(pyobj)

    @staticmethod
    cdef ushort3 fromPyobj(object pyobj):
        """Creates a ushort3 from a Python object.

        Derives a ushort3 from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``ushort3`` reference, this method
        returns it directly. No new ``ushort3`` is created in this case.

        Args:
            pyobj (object): Must be either `None`; a `hip._util.types.Pointer`; a simple, contiguous buffer according to the buffer protocol;
                            or of type `ushort3`; `int`; or `ctypes.c_void_p`.

        Note:
            This routine does not perform a copy but returns the original ``pyobj``
            if ``pyobj`` is an instance of ushort3!
        """
        cdef ushort3 wrapper

        if isinstance(pyobj,ushort3):
            return pyobj
        else:
            wrapper = ushort3.__new__(ushort3)
            wrapper.init_from_pyobj(pyobj)
            return wrapper

    def __dealloc__(self):
        # Release the buffer handle
        if self._py_buffer_acquired is True:
            cpython.buffer.PyBuffer_Release(&self._py_buffer)
        # De-allocate if not null and flag is set
        if self._ptr is not NULL and self._is_ptr_owner is True:
            stdlib.free(self._ptr)
            self._ptr = NULL

    @staticmethod
    cdef __allocate(void** ptr):
        ptr[0] = stdlib.malloc(sizeof(chip.ushort3))
        string.memset(<void*>ptr[0], 0, sizeof(chip.ushort3))

        if ptr[0] is NULL:
            raise MemoryError

    @staticmethod
    cdef ushort3 new():
        """Factory function to create ushort3 objects with
        newly allocated chip.ushort3"""
        cdef void* ptr
        ushort3.__allocate(&ptr)
        return ushort3.fromPtr(ptr, owner=True)

    @staticmethod
    cdef ushort3 fromValue(chip.ushort3 other):
        """Allocate new C type and copy from ``other``.
        """
        wrapper = ushort3.new()
        string.memcpy(wrapper._ptr, &other, sizeof(chip.ushort3))
        return wrapper

    def c_sizeof(self):
        """Returns the size of the underlying C type in bytes.
        Note:
            Implemented as function to not collide with
            autogenerated property names.
        """
        return sizeof(chip.ushort3)

    def __int__(self):
        """Returns the data's address as long integer.
        """
        return cpython.long.PyLong_FromVoidPtr(self._ptr)

    def __repr__(self):
        return f"<ushort3 object, ptr: {int(self)}>"

    def as_c_void_p(self):
        """Returns the data's address as `ctypes.c_void_p`
        Note:
            Implemented as function to not collide with
            autogenerated property names.
        """
        return ctypes.c_void_p(int(self))

    def __init__(self,*args,**kwargs):
        """Constructor type ushort3.

        Constructor for type ushort3.

        Args:
            *args:
                Positional arguments. Initialize all or a subset of the member variables
                according to their order of declaration.
            **kwargs:
                Can be used to initialize member variables at construction,
                Just pass an argument expression of the form <member>=<value>
                per member that you want to initialize.
        """
        ushort3.__allocate(&self._ptr)
        self._is_ptr_owner = True
        attribs = self.PROPERTIES()
        used_attribs = set()
        if len(args) > len(attribs):
            raise ValueError("More positional arguments specified than this type has properties.")
        for i,v in enumerate(args):
            setattr(self,attribs[i],v)
            used_attribs.add(attribs[i])
        valid_names = ", ".join(["'"+p+"'" for p in attribs])
        for k,v in kwargs.items():
            if k in used_attribs:
                raise KeyError(f"argument '{k}' has already been specified as positional argument.")
            elif k not in attribs:
                raise KeyError(f"'{k}' is no valid property name. Valid names: {valid_names}")
            setattr(self,k,v)
    def get_x(self, i):
        """Get value ``x`` of ``(<chip.ushort3*>self._ptr)[i]``.
        """
        return (<chip.ushort3*>self._ptr)[i].x
    def set_x(self, i, unsigned short value):
        """Set value ``x`` of ``(<chip.ushort3*>self._ptr)[i]``.
        """
        (<chip.ushort3*>self._ptr)[i].x = value
    @property
    def x(self):
        """(undocumented)"""
        return self.get_x(0)
    @x.setter
    def x(self, unsigned short value):
        self.set_x(0,value)

    def get_y(self, i):
        """Get value ``y`` of ``(<chip.ushort3*>self._ptr)[i]``.
        """
        return (<chip.ushort3*>self._ptr)[i].y
    def set_y(self, i, unsigned short value):
        """Set value ``y`` of ``(<chip.ushort3*>self._ptr)[i]``.
        """
        (<chip.ushort3*>self._ptr)[i].y = value
    @property
    def y(self):
        """(undocumented)"""
        return self.get_y(0)
    @y.setter
    def y(self, unsigned short value):
        self.set_y(0,value)

    def get_z(self, i):
        """Get value ``z`` of ``(<chip.ushort3*>self._ptr)[i]``.
        """
        return (<chip.ushort3*>self._ptr)[i].z
    def set_z(self, i, unsigned short value):
        """Set value ``z`` of ``(<chip.ushort3*>self._ptr)[i]``.
        """
        (<chip.ushort3*>self._ptr)[i].z = value
    @property
    def z(self):
        """(undocumented)"""
        return self.get_z(0)
    @z.setter
    def z(self, unsigned short value):
        self.set_z(0,value)

    @staticmethod
    def PROPERTIES():
        return ["x","y","z"]

    def __contains__(self,item):
        properties = self.PROPERTIES()
        return item in properties

    def __getitem__(self,item):
        properties = self.PROPERTIES()
        if isinstance(item,int):
            if item < 0 or item >= len(properties):
                raise IndexError()
            return getattr(self,properties[item])
        raise ValueError("'item' type must be 'int'")


cdef class ushort4(hip._util.types.Pointer):
    """Python wrapper for cdef class chip.ushort4.

    Python wrapper for cdef class chip.ushort4.

    If this type is initialized via its `__init__` method, it allocates a
    member of the underlying C type and destroys it again if the wrapper
    type is deallocated.

    This type also serves as adapter when appearing as argument type in a
    function signature. In this case, the type can further be initialized
    from a number of Python objects:

    * `None`:

      This will set the ``self._ptr`` attribute to ``NULL``.

    * `int`:

      Interprets the integer value as pointer address and writes it to ``self._ptr``.
      No ownership is transferred.

    * `ctypes.c_void_p`:

      Takes the pointer address ``pyobj.value`` and writes it to ``self._ptr``.
      No ownership is transferred.

    * `object` that implements the `CUDA Array Interface <https://numba.readthedocs.io/en/stable/cuda/cuda_array_interface.html>`_ protocol:

      Takes the integer-valued pointer address, i.e. the first entry of the `data` tuple
      from `pyobj`'s member ``__cuda_array_interface__``  and writes it to ``self._ptr``.

    * `object` that implements the Python buffer protocol:

      If the object represents a simple contiguous array,
      writes the `Py_buffer` associated with ``pyobj`` to `self._py_buffer`,
      sets the `self._py_buffer_acquired` flag to `True`, and
      writes `self._py_buffer.buf` to the data pointer `self._ptr`.

    * `hip._util.types.Pointer`:

      Takes the pointer address ``pyobj._ptr`` and writes it to ``self._ptr``.
      No ownership is transferred.

    Type checks are performed in the above order.

    C Attributes:
        _ptr (C type ``void *``, protected):
            Stores a pointer to the data of the original Python object.
        _is_ptr_owner (C type ``bint``, protected):
            If this wrapper is the owner of the underlying data.
        _py_buffer (C type ``Py_buffer`, protected):
            Stores a pointer to the data of the original Python object.
        _py_buffer_acquired (C type ``bint``, protected):
            Stores a pointer to the data of the original Python object.
    """
    # C members declared in pxd file

    def __cinit__(self):
        self._ptr = NULL
        self._is_ptr_owner = False
        self._py_buffer_acquired = False

    cdef chip.ushort4* getElementPtr(self):
        return <chip.ushort4*>self._ptr

    @staticmethod
    cdef ushort4 fromPtr(void* ptr, bint owner=False):
        """Factory function to create ``ushort4`` objects from
        given ``chip.ushort4`` pointer.

        Setting ``owner`` flag to ``True`` causes
        the extension type to free the structure pointed to by ``ptr``
        when the wrapper object is deallocated.
        """
        # Fast call to __new__() that bypasses the __init__() constructor.
        cdef ushort4 wrapper = ushort4.__new__(ushort4)
        wrapper._ptr = ptr
        wrapper._is_ptr_owner = owner
        return wrapper

    @staticmethod
    def fromObj(pyobj):
        """Creates a ushort4 from a Python object.

        Derives a ushort4 from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``ushort4`` reference, this method
        returns it directly. No new ``ushort4`` is created in this case.
        """
        return ushort4.fromPyobj(pyobj)

    @staticmethod
    cdef ushort4 fromPyobj(object pyobj):
        """Creates a ushort4 from a Python object.

        Derives a ushort4 from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``ushort4`` reference, this method
        returns it directly. No new ``ushort4`` is created in this case.

        Args:
            pyobj (object): Must be either `None`; a `hip._util.types.Pointer`; a simple, contiguous buffer according to the buffer protocol;
                            or of type `ushort4`; `int`; or `ctypes.c_void_p`.

        Note:
            This routine does not perform a copy but returns the original ``pyobj``
            if ``pyobj`` is an instance of ushort4!
        """
        cdef ushort4 wrapper

        if isinstance(pyobj,ushort4):
            return pyobj
        else:
            wrapper = ushort4.__new__(ushort4)
            wrapper.init_from_pyobj(pyobj)
            return wrapper

    def __dealloc__(self):
        # Release the buffer handle
        if self._py_buffer_acquired is True:
            cpython.buffer.PyBuffer_Release(&self._py_buffer)
        # De-allocate if not null and flag is set
        if self._ptr is not NULL and self._is_ptr_owner is True:
            stdlib.free(self._ptr)
            self._ptr = NULL

    @staticmethod
    cdef __allocate(void** ptr):
        ptr[0] = stdlib.malloc(sizeof(chip.ushort4))
        string.memset(<void*>ptr[0], 0, sizeof(chip.ushort4))

        if ptr[0] is NULL:
            raise MemoryError

    @staticmethod
    cdef ushort4 new():
        """Factory function to create ushort4 objects with
        newly allocated chip.ushort4"""
        cdef void* ptr
        ushort4.__allocate(&ptr)
        return ushort4.fromPtr(ptr, owner=True)

    @staticmethod
    cdef ushort4 fromValue(chip.ushort4 other):
        """Allocate new C type and copy from ``other``.
        """
        wrapper = ushort4.new()
        string.memcpy(wrapper._ptr, &other, sizeof(chip.ushort4))
        return wrapper

    def c_sizeof(self):
        """Returns the size of the underlying C type in bytes.
        Note:
            Implemented as function to not collide with
            autogenerated property names.
        """
        return sizeof(chip.ushort4)

    def __int__(self):
        """Returns the data's address as long integer.
        """
        return cpython.long.PyLong_FromVoidPtr(self._ptr)

    def __repr__(self):
        return f"<ushort4 object, ptr: {int(self)}>"

    def as_c_void_p(self):
        """Returns the data's address as `ctypes.c_void_p`
        Note:
            Implemented as function to not collide with
            autogenerated property names.
        """
        return ctypes.c_void_p(int(self))

    def __init__(self,*args,**kwargs):
        """Constructor type ushort4.

        Constructor for type ushort4.

        Args:
            *args:
                Positional arguments. Initialize all or a subset of the member variables
                according to their order of declaration.
            **kwargs:
                Can be used to initialize member variables at construction,
                Just pass an argument expression of the form <member>=<value>
                per member that you want to initialize.
        """
        ushort4.__allocate(&self._ptr)
        self._is_ptr_owner = True
        attribs = self.PROPERTIES()
        used_attribs = set()
        if len(args) > len(attribs):
            raise ValueError("More positional arguments specified than this type has properties.")
        for i,v in enumerate(args):
            setattr(self,attribs[i],v)
            used_attribs.add(attribs[i])
        valid_names = ", ".join(["'"+p+"'" for p in attribs])
        for k,v in kwargs.items():
            if k in used_attribs:
                raise KeyError(f"argument '{k}' has already been specified as positional argument.")
            elif k not in attribs:
                raise KeyError(f"'{k}' is no valid property name. Valid names: {valid_names}")
            setattr(self,k,v)
    def get_x(self, i):
        """Get value ``x`` of ``(<chip.ushort4*>self._ptr)[i]``.
        """
        return (<chip.ushort4*>self._ptr)[i].x
    def set_x(self, i, unsigned short value):
        """Set value ``x`` of ``(<chip.ushort4*>self._ptr)[i]``.
        """
        (<chip.ushort4*>self._ptr)[i].x = value
    @property
    def x(self):
        """(undocumented)"""
        return self.get_x(0)
    @x.setter
    def x(self, unsigned short value):
        self.set_x(0,value)

    def get_y(self, i):
        """Get value ``y`` of ``(<chip.ushort4*>self._ptr)[i]``.
        """
        return (<chip.ushort4*>self._ptr)[i].y
    def set_y(self, i, unsigned short value):
        """Set value ``y`` of ``(<chip.ushort4*>self._ptr)[i]``.
        """
        (<chip.ushort4*>self._ptr)[i].y = value
    @property
    def y(self):
        """(undocumented)"""
        return self.get_y(0)
    @y.setter
    def y(self, unsigned short value):
        self.set_y(0,value)

    def get_z(self, i):
        """Get value ``z`` of ``(<chip.ushort4*>self._ptr)[i]``.
        """
        return (<chip.ushort4*>self._ptr)[i].z
    def set_z(self, i, unsigned short value):
        """Set value ``z`` of ``(<chip.ushort4*>self._ptr)[i]``.
        """
        (<chip.ushort4*>self._ptr)[i].z = value
    @property
    def z(self):
        """(undocumented)"""
        return self.get_z(0)
    @z.setter
    def z(self, unsigned short value):
        self.set_z(0,value)

    def get_w(self, i):
        """Get value ``w`` of ``(<chip.ushort4*>self._ptr)[i]``.
        """
        return (<chip.ushort4*>self._ptr)[i].w
    def set_w(self, i, unsigned short value):
        """Set value ``w`` of ``(<chip.ushort4*>self._ptr)[i]``.
        """
        (<chip.ushort4*>self._ptr)[i].w = value
    @property
    def w(self):
        """(undocumented)"""
        return self.get_w(0)
    @w.setter
    def w(self, unsigned short value):
        self.set_w(0,value)

    @staticmethod
    def PROPERTIES():
        return ["x","y","z","w"]

    def __contains__(self,item):
        properties = self.PROPERTIES()
        return item in properties

    def __getitem__(self,item):
        properties = self.PROPERTIES()
        if isinstance(item,int):
            if item < 0 or item >= len(properties):
                raise IndexError()
            return getattr(self,properties[item])
        raise ValueError("'item' type must be 'int'")


cdef class short1(hip._util.types.Pointer):
    """Python wrapper for cdef class chip.short1.

    Python wrapper for cdef class chip.short1.

    If this type is initialized via its `__init__` method, it allocates a
    member of the underlying C type and destroys it again if the wrapper
    type is deallocated.

    This type also serves as adapter when appearing as argument type in a
    function signature. In this case, the type can further be initialized
    from a number of Python objects:

    * `None`:

      This will set the ``self._ptr`` attribute to ``NULL``.

    * `int`:

      Interprets the integer value as pointer address and writes it to ``self._ptr``.
      No ownership is transferred.

    * `ctypes.c_void_p`:

      Takes the pointer address ``pyobj.value`` and writes it to ``self._ptr``.
      No ownership is transferred.

    * `object` that implements the `CUDA Array Interface <https://numba.readthedocs.io/en/stable/cuda/cuda_array_interface.html>`_ protocol:

      Takes the integer-valued pointer address, i.e. the first entry of the `data` tuple
      from `pyobj`'s member ``__cuda_array_interface__``  and writes it to ``self._ptr``.

    * `object` that implements the Python buffer protocol:

      If the object represents a simple contiguous array,
      writes the `Py_buffer` associated with ``pyobj`` to `self._py_buffer`,
      sets the `self._py_buffer_acquired` flag to `True`, and
      writes `self._py_buffer.buf` to the data pointer `self._ptr`.

    * `hip._util.types.Pointer`:

      Takes the pointer address ``pyobj._ptr`` and writes it to ``self._ptr``.
      No ownership is transferred.

    Type checks are performed in the above order.

    C Attributes:
        _ptr (C type ``void *``, protected):
            Stores a pointer to the data of the original Python object.
        _is_ptr_owner (C type ``bint``, protected):
            If this wrapper is the owner of the underlying data.
        _py_buffer (C type ``Py_buffer`, protected):
            Stores a pointer to the data of the original Python object.
        _py_buffer_acquired (C type ``bint``, protected):
            Stores a pointer to the data of the original Python object.
    """
    # C members declared in pxd file

    def __cinit__(self):
        self._ptr = NULL
        self._is_ptr_owner = False
        self._py_buffer_acquired = False

    cdef chip.short1* getElementPtr(self):
        return <chip.short1*>self._ptr

    @staticmethod
    cdef short1 fromPtr(void* ptr, bint owner=False):
        """Factory function to create ``short1`` objects from
        given ``chip.short1`` pointer.

        Setting ``owner`` flag to ``True`` causes
        the extension type to free the structure pointed to by ``ptr``
        when the wrapper object is deallocated.
        """
        # Fast call to __new__() that bypasses the __init__() constructor.
        cdef short1 wrapper = short1.__new__(short1)
        wrapper._ptr = ptr
        wrapper._is_ptr_owner = owner
        return wrapper

    @staticmethod
    def fromObj(pyobj):
        """Creates a short1 from a Python object.

        Derives a short1 from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``short1`` reference, this method
        returns it directly. No new ``short1`` is created in this case.
        """
        return short1.fromPyobj(pyobj)

    @staticmethod
    cdef short1 fromPyobj(object pyobj):
        """Creates a short1 from a Python object.

        Derives a short1 from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``short1`` reference, this method
        returns it directly. No new ``short1`` is created in this case.

        Args:
            pyobj (object): Must be either `None`; a `hip._util.types.Pointer`; a simple, contiguous buffer according to the buffer protocol;
                            or of type `short1`; `int`; or `ctypes.c_void_p`.

        Note:
            This routine does not perform a copy but returns the original ``pyobj``
            if ``pyobj`` is an instance of short1!
        """
        cdef short1 wrapper

        if isinstance(pyobj,short1):
            return pyobj
        else:
            wrapper = short1.__new__(short1)
            wrapper.init_from_pyobj(pyobj)
            return wrapper

    def __dealloc__(self):
        # Release the buffer handle
        if self._py_buffer_acquired is True:
            cpython.buffer.PyBuffer_Release(&self._py_buffer)
        # De-allocate if not null and flag is set
        if self._ptr is not NULL and self._is_ptr_owner is True:
            stdlib.free(self._ptr)
            self._ptr = NULL

    @staticmethod
    cdef __allocate(void** ptr):
        ptr[0] = stdlib.malloc(sizeof(chip.short1))
        string.memset(<void*>ptr[0], 0, sizeof(chip.short1))

        if ptr[0] is NULL:
            raise MemoryError

    @staticmethod
    cdef short1 new():
        """Factory function to create short1 objects with
        newly allocated chip.short1"""
        cdef void* ptr
        short1.__allocate(&ptr)
        return short1.fromPtr(ptr, owner=True)

    @staticmethod
    cdef short1 fromValue(chip.short1 other):
        """Allocate new C type and copy from ``other``.
        """
        wrapper = short1.new()
        string.memcpy(wrapper._ptr, &other, sizeof(chip.short1))
        return wrapper

    def c_sizeof(self):
        """Returns the size of the underlying C type in bytes.
        Note:
            Implemented as function to not collide with
            autogenerated property names.
        """
        return sizeof(chip.short1)

    def __int__(self):
        """Returns the data's address as long integer.
        """
        return cpython.long.PyLong_FromVoidPtr(self._ptr)

    def __repr__(self):
        return f"<short1 object, ptr: {int(self)}>"

    def as_c_void_p(self):
        """Returns the data's address as `ctypes.c_void_p`
        Note:
            Implemented as function to not collide with
            autogenerated property names.
        """
        return ctypes.c_void_p(int(self))

    def __init__(self,*args,**kwargs):
        """Constructor type short1.

        Constructor for type short1.

        Args:
            *args:
                Positional arguments. Initialize all or a subset of the member variables
                according to their order of declaration.
            **kwargs:
                Can be used to initialize member variables at construction,
                Just pass an argument expression of the form <member>=<value>
                per member that you want to initialize.
        """
        short1.__allocate(&self._ptr)
        self._is_ptr_owner = True
        attribs = self.PROPERTIES()
        used_attribs = set()
        if len(args) > len(attribs):
            raise ValueError("More positional arguments specified than this type has properties.")
        for i,v in enumerate(args):
            setattr(self,attribs[i],v)
            used_attribs.add(attribs[i])
        valid_names = ", ".join(["'"+p+"'" for p in attribs])
        for k,v in kwargs.items():
            if k in used_attribs:
                raise KeyError(f"argument '{k}' has already been specified as positional argument.")
            elif k not in attribs:
                raise KeyError(f"'{k}' is no valid property name. Valid names: {valid_names}")
            setattr(self,k,v)
    def get_x(self, i):
        """Get value ``x`` of ``(<chip.short1*>self._ptr)[i]``.
        """
        return (<chip.short1*>self._ptr)[i].x
    def set_x(self, i, short value):
        """Set value ``x`` of ``(<chip.short1*>self._ptr)[i]``.
        """
        (<chip.short1*>self._ptr)[i].x = value
    @property
    def x(self):
        """(undocumented)"""
        return self.get_x(0)
    @x.setter
    def x(self, short value):
        self.set_x(0,value)

    @staticmethod
    def PROPERTIES():
        return ["x"]

    def __contains__(self,item):
        properties = self.PROPERTIES()
        return item in properties

    def __getitem__(self,item):
        properties = self.PROPERTIES()
        if isinstance(item,int):
            if item < 0 or item >= len(properties):
                raise IndexError()
            return getattr(self,properties[item])
        raise ValueError("'item' type must be 'int'")


cdef class short2(hip._util.types.Pointer):
    """Python wrapper for cdef class chip.short2.

    Python wrapper for cdef class chip.short2.

    If this type is initialized via its `__init__` method, it allocates a
    member of the underlying C type and destroys it again if the wrapper
    type is deallocated.

    This type also serves as adapter when appearing as argument type in a
    function signature. In this case, the type can further be initialized
    from a number of Python objects:

    * `None`:

      This will set the ``self._ptr`` attribute to ``NULL``.

    * `int`:

      Interprets the integer value as pointer address and writes it to ``self._ptr``.
      No ownership is transferred.

    * `ctypes.c_void_p`:

      Takes the pointer address ``pyobj.value`` and writes it to ``self._ptr``.
      No ownership is transferred.

    * `object` that implements the `CUDA Array Interface <https://numba.readthedocs.io/en/stable/cuda/cuda_array_interface.html>`_ protocol:

      Takes the integer-valued pointer address, i.e. the first entry of the `data` tuple
      from `pyobj`'s member ``__cuda_array_interface__``  and writes it to ``self._ptr``.

    * `object` that implements the Python buffer protocol:

      If the object represents a simple contiguous array,
      writes the `Py_buffer` associated with ``pyobj`` to `self._py_buffer`,
      sets the `self._py_buffer_acquired` flag to `True`, and
      writes `self._py_buffer.buf` to the data pointer `self._ptr`.

    * `hip._util.types.Pointer`:

      Takes the pointer address ``pyobj._ptr`` and writes it to ``self._ptr``.
      No ownership is transferred.

    Type checks are performed in the above order.

    C Attributes:
        _ptr (C type ``void *``, protected):
            Stores a pointer to the data of the original Python object.
        _is_ptr_owner (C type ``bint``, protected):
            If this wrapper is the owner of the underlying data.
        _py_buffer (C type ``Py_buffer`, protected):
            Stores a pointer to the data of the original Python object.
        _py_buffer_acquired (C type ``bint``, protected):
            Stores a pointer to the data of the original Python object.
    """
    # C members declared in pxd file

    def __cinit__(self):
        self._ptr = NULL
        self._is_ptr_owner = False
        self._py_buffer_acquired = False

    cdef chip.short2* getElementPtr(self):
        return <chip.short2*>self._ptr

    @staticmethod
    cdef short2 fromPtr(void* ptr, bint owner=False):
        """Factory function to create ``short2`` objects from
        given ``chip.short2`` pointer.

        Setting ``owner`` flag to ``True`` causes
        the extension type to free the structure pointed to by ``ptr``
        when the wrapper object is deallocated.
        """
        # Fast call to __new__() that bypasses the __init__() constructor.
        cdef short2 wrapper = short2.__new__(short2)
        wrapper._ptr = ptr
        wrapper._is_ptr_owner = owner
        return wrapper

    @staticmethod
    def fromObj(pyobj):
        """Creates a short2 from a Python object.

        Derives a short2 from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``short2`` reference, this method
        returns it directly. No new ``short2`` is created in this case.
        """
        return short2.fromPyobj(pyobj)

    @staticmethod
    cdef short2 fromPyobj(object pyobj):
        """Creates a short2 from a Python object.

        Derives a short2 from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``short2`` reference, this method
        returns it directly. No new ``short2`` is created in this case.

        Args:
            pyobj (object): Must be either `None`; a `hip._util.types.Pointer`; a simple, contiguous buffer according to the buffer protocol;
                            or of type `short2`; `int`; or `ctypes.c_void_p`.

        Note:
            This routine does not perform a copy but returns the original ``pyobj``
            if ``pyobj`` is an instance of short2!
        """
        cdef short2 wrapper

        if isinstance(pyobj,short2):
            return pyobj
        else:
            wrapper = short2.__new__(short2)
            wrapper.init_from_pyobj(pyobj)
            return wrapper

    def __dealloc__(self):
        # Release the buffer handle
        if self._py_buffer_acquired is True:
            cpython.buffer.PyBuffer_Release(&self._py_buffer)
        # De-allocate if not null and flag is set
        if self._ptr is not NULL and self._is_ptr_owner is True:
            stdlib.free(self._ptr)
            self._ptr = NULL

    @staticmethod
    cdef __allocate(void** ptr):
        ptr[0] = stdlib.malloc(sizeof(chip.short2))
        string.memset(<void*>ptr[0], 0, sizeof(chip.short2))

        if ptr[0] is NULL:
            raise MemoryError

    @staticmethod
    cdef short2 new():
        """Factory function to create short2 objects with
        newly allocated chip.short2"""
        cdef void* ptr
        short2.__allocate(&ptr)
        return short2.fromPtr(ptr, owner=True)

    @staticmethod
    cdef short2 fromValue(chip.short2 other):
        """Allocate new C type and copy from ``other``.
        """
        wrapper = short2.new()
        string.memcpy(wrapper._ptr, &other, sizeof(chip.short2))
        return wrapper

    def c_sizeof(self):
        """Returns the size of the underlying C type in bytes.
        Note:
            Implemented as function to not collide with
            autogenerated property names.
        """
        return sizeof(chip.short2)

    def __int__(self):
        """Returns the data's address as long integer.
        """
        return cpython.long.PyLong_FromVoidPtr(self._ptr)

    def __repr__(self):
        return f"<short2 object, ptr: {int(self)}>"

    def as_c_void_p(self):
        """Returns the data's address as `ctypes.c_void_p`
        Note:
            Implemented as function to not collide with
            autogenerated property names.
        """
        return ctypes.c_void_p(int(self))

    def __init__(self,*args,**kwargs):
        """Constructor type short2.

        Constructor for type short2.

        Args:
            *args:
                Positional arguments. Initialize all or a subset of the member variables
                according to their order of declaration.
            **kwargs:
                Can be used to initialize member variables at construction,
                Just pass an argument expression of the form <member>=<value>
                per member that you want to initialize.
        """
        short2.__allocate(&self._ptr)
        self._is_ptr_owner = True
        attribs = self.PROPERTIES()
        used_attribs = set()
        if len(args) > len(attribs):
            raise ValueError("More positional arguments specified than this type has properties.")
        for i,v in enumerate(args):
            setattr(self,attribs[i],v)
            used_attribs.add(attribs[i])
        valid_names = ", ".join(["'"+p+"'" for p in attribs])
        for k,v in kwargs.items():
            if k in used_attribs:
                raise KeyError(f"argument '{k}' has already been specified as positional argument.")
            elif k not in attribs:
                raise KeyError(f"'{k}' is no valid property name. Valid names: {valid_names}")
            setattr(self,k,v)
    def get_x(self, i):
        """Get value ``x`` of ``(<chip.short2*>self._ptr)[i]``.
        """
        return (<chip.short2*>self._ptr)[i].x
    def set_x(self, i, short value):
        """Set value ``x`` of ``(<chip.short2*>self._ptr)[i]``.
        """
        (<chip.short2*>self._ptr)[i].x = value
    @property
    def x(self):
        """(undocumented)"""
        return self.get_x(0)
    @x.setter
    def x(self, short value):
        self.set_x(0,value)

    def get_y(self, i):
        """Get value ``y`` of ``(<chip.short2*>self._ptr)[i]``.
        """
        return (<chip.short2*>self._ptr)[i].y
    def set_y(self, i, short value):
        """Set value ``y`` of ``(<chip.short2*>self._ptr)[i]``.
        """
        (<chip.short2*>self._ptr)[i].y = value
    @property
    def y(self):
        """(undocumented)"""
        return self.get_y(0)
    @y.setter
    def y(self, short value):
        self.set_y(0,value)

    @staticmethod
    def PROPERTIES():
        return ["x","y"]

    def __contains__(self,item):
        properties = self.PROPERTIES()
        return item in properties

    def __getitem__(self,item):
        properties = self.PROPERTIES()
        if isinstance(item,int):
            if item < 0 or item >= len(properties):
                raise IndexError()
            return getattr(self,properties[item])
        raise ValueError("'item' type must be 'int'")


cdef class short3(hip._util.types.Pointer):
    """Python wrapper for cdef class chip.short3.

    Python wrapper for cdef class chip.short3.

    If this type is initialized via its `__init__` method, it allocates a
    member of the underlying C type and destroys it again if the wrapper
    type is deallocated.

    This type also serves as adapter when appearing as argument type in a
    function signature. In this case, the type can further be initialized
    from a number of Python objects:

    * `None`:

      This will set the ``self._ptr`` attribute to ``NULL``.

    * `int`:

      Interprets the integer value as pointer address and writes it to ``self._ptr``.
      No ownership is transferred.

    * `ctypes.c_void_p`:

      Takes the pointer address ``pyobj.value`` and writes it to ``self._ptr``.
      No ownership is transferred.

    * `object` that implements the `CUDA Array Interface <https://numba.readthedocs.io/en/stable/cuda/cuda_array_interface.html>`_ protocol:

      Takes the integer-valued pointer address, i.e. the first entry of the `data` tuple
      from `pyobj`'s member ``__cuda_array_interface__``  and writes it to ``self._ptr``.

    * `object` that implements the Python buffer protocol:

      If the object represents a simple contiguous array,
      writes the `Py_buffer` associated with ``pyobj`` to `self._py_buffer`,
      sets the `self._py_buffer_acquired` flag to `True`, and
      writes `self._py_buffer.buf` to the data pointer `self._ptr`.

    * `hip._util.types.Pointer`:

      Takes the pointer address ``pyobj._ptr`` and writes it to ``self._ptr``.
      No ownership is transferred.

    Type checks are performed in the above order.

    C Attributes:
        _ptr (C type ``void *``, protected):
            Stores a pointer to the data of the original Python object.
        _is_ptr_owner (C type ``bint``, protected):
            If this wrapper is the owner of the underlying data.
        _py_buffer (C type ``Py_buffer`, protected):
            Stores a pointer to the data of the original Python object.
        _py_buffer_acquired (C type ``bint``, protected):
            Stores a pointer to the data of the original Python object.
    """
    # C members declared in pxd file

    def __cinit__(self):
        self._ptr = NULL
        self._is_ptr_owner = False
        self._py_buffer_acquired = False

    cdef chip.short3* getElementPtr(self):
        return <chip.short3*>self._ptr

    @staticmethod
    cdef short3 fromPtr(void* ptr, bint owner=False):
        """Factory function to create ``short3`` objects from
        given ``chip.short3`` pointer.

        Setting ``owner`` flag to ``True`` causes
        the extension type to free the structure pointed to by ``ptr``
        when the wrapper object is deallocated.
        """
        # Fast call to __new__() that bypasses the __init__() constructor.
        cdef short3 wrapper = short3.__new__(short3)
        wrapper._ptr = ptr
        wrapper._is_ptr_owner = owner
        return wrapper

    @staticmethod
    def fromObj(pyobj):
        """Creates a short3 from a Python object.

        Derives a short3 from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``short3`` reference, this method
        returns it directly. No new ``short3`` is created in this case.
        """
        return short3.fromPyobj(pyobj)

    @staticmethod
    cdef short3 fromPyobj(object pyobj):
        """Creates a short3 from a Python object.

        Derives a short3 from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``short3`` reference, this method
        returns it directly. No new ``short3`` is created in this case.

        Args:
            pyobj (object): Must be either `None`; a `hip._util.types.Pointer`; a simple, contiguous buffer according to the buffer protocol;
                            or of type `short3`; `int`; or `ctypes.c_void_p`.

        Note:
            This routine does not perform a copy but returns the original ``pyobj``
            if ``pyobj`` is an instance of short3!
        """
        cdef short3 wrapper

        if isinstance(pyobj,short3):
            return pyobj
        else:
            wrapper = short3.__new__(short3)
            wrapper.init_from_pyobj(pyobj)
            return wrapper

    def __dealloc__(self):
        # Release the buffer handle
        if self._py_buffer_acquired is True:
            cpython.buffer.PyBuffer_Release(&self._py_buffer)
        # De-allocate if not null and flag is set
        if self._ptr is not NULL and self._is_ptr_owner is True:
            stdlib.free(self._ptr)
            self._ptr = NULL

    @staticmethod
    cdef __allocate(void** ptr):
        ptr[0] = stdlib.malloc(sizeof(chip.short3))
        string.memset(<void*>ptr[0], 0, sizeof(chip.short3))

        if ptr[0] is NULL:
            raise MemoryError

    @staticmethod
    cdef short3 new():
        """Factory function to create short3 objects with
        newly allocated chip.short3"""
        cdef void* ptr
        short3.__allocate(&ptr)
        return short3.fromPtr(ptr, owner=True)

    @staticmethod
    cdef short3 fromValue(chip.short3 other):
        """Allocate new C type and copy from ``other``.
        """
        wrapper = short3.new()
        string.memcpy(wrapper._ptr, &other, sizeof(chip.short3))
        return wrapper

    def c_sizeof(self):
        """Returns the size of the underlying C type in bytes.
        Note:
            Implemented as function to not collide with
            autogenerated property names.
        """
        return sizeof(chip.short3)

    def __int__(self):
        """Returns the data's address as long integer.
        """
        return cpython.long.PyLong_FromVoidPtr(self._ptr)

    def __repr__(self):
        return f"<short3 object, ptr: {int(self)}>"

    def as_c_void_p(self):
        """Returns the data's address as `ctypes.c_void_p`
        Note:
            Implemented as function to not collide with
            autogenerated property names.
        """
        return ctypes.c_void_p(int(self))

    def __init__(self,*args,**kwargs):
        """Constructor type short3.

        Constructor for type short3.

        Args:
            *args:
                Positional arguments. Initialize all or a subset of the member variables
                according to their order of declaration.
            **kwargs:
                Can be used to initialize member variables at construction,
                Just pass an argument expression of the form <member>=<value>
                per member that you want to initialize.
        """
        short3.__allocate(&self._ptr)
        self._is_ptr_owner = True
        attribs = self.PROPERTIES()
        used_attribs = set()
        if len(args) > len(attribs):
            raise ValueError("More positional arguments specified than this type has properties.")
        for i,v in enumerate(args):
            setattr(self,attribs[i],v)
            used_attribs.add(attribs[i])
        valid_names = ", ".join(["'"+p+"'" for p in attribs])
        for k,v in kwargs.items():
            if k in used_attribs:
                raise KeyError(f"argument '{k}' has already been specified as positional argument.")
            elif k not in attribs:
                raise KeyError(f"'{k}' is no valid property name. Valid names: {valid_names}")
            setattr(self,k,v)
    def get_x(self, i):
        """Get value ``x`` of ``(<chip.short3*>self._ptr)[i]``.
        """
        return (<chip.short3*>self._ptr)[i].x
    def set_x(self, i, short value):
        """Set value ``x`` of ``(<chip.short3*>self._ptr)[i]``.
        """
        (<chip.short3*>self._ptr)[i].x = value
    @property
    def x(self):
        """(undocumented)"""
        return self.get_x(0)
    @x.setter
    def x(self, short value):
        self.set_x(0,value)

    def get_y(self, i):
        """Get value ``y`` of ``(<chip.short3*>self._ptr)[i]``.
        """
        return (<chip.short3*>self._ptr)[i].y
    def set_y(self, i, short value):
        """Set value ``y`` of ``(<chip.short3*>self._ptr)[i]``.
        """
        (<chip.short3*>self._ptr)[i].y = value
    @property
    def y(self):
        """(undocumented)"""
        return self.get_y(0)
    @y.setter
    def y(self, short value):
        self.set_y(0,value)

    def get_z(self, i):
        """Get value ``z`` of ``(<chip.short3*>self._ptr)[i]``.
        """
        return (<chip.short3*>self._ptr)[i].z
    def set_z(self, i, short value):
        """Set value ``z`` of ``(<chip.short3*>self._ptr)[i]``.
        """
        (<chip.short3*>self._ptr)[i].z = value
    @property
    def z(self):
        """(undocumented)"""
        return self.get_z(0)
    @z.setter
    def z(self, short value):
        self.set_z(0,value)

    @staticmethod
    def PROPERTIES():
        return ["x","y","z"]

    def __contains__(self,item):
        properties = self.PROPERTIES()
        return item in properties

    def __getitem__(self,item):
        properties = self.PROPERTIES()
        if isinstance(item,int):
            if item < 0 or item >= len(properties):
                raise IndexError()
            return getattr(self,properties[item])
        raise ValueError("'item' type must be 'int'")


cdef class short4(hip._util.types.Pointer):
    """Python wrapper for cdef class chip.short4.

    Python wrapper for cdef class chip.short4.

    If this type is initialized via its `__init__` method, it allocates a
    member of the underlying C type and destroys it again if the wrapper
    type is deallocated.

    This type also serves as adapter when appearing as argument type in a
    function signature. In this case, the type can further be initialized
    from a number of Python objects:

    * `None`:

      This will set the ``self._ptr`` attribute to ``NULL``.

    * `int`:

      Interprets the integer value as pointer address and writes it to ``self._ptr``.
      No ownership is transferred.

    * `ctypes.c_void_p`:

      Takes the pointer address ``pyobj.value`` and writes it to ``self._ptr``.
      No ownership is transferred.

    * `object` that implements the `CUDA Array Interface <https://numba.readthedocs.io/en/stable/cuda/cuda_array_interface.html>`_ protocol:

      Takes the integer-valued pointer address, i.e. the first entry of the `data` tuple
      from `pyobj`'s member ``__cuda_array_interface__``  and writes it to ``self._ptr``.

    * `object` that implements the Python buffer protocol:

      If the object represents a simple contiguous array,
      writes the `Py_buffer` associated with ``pyobj`` to `self._py_buffer`,
      sets the `self._py_buffer_acquired` flag to `True`, and
      writes `self._py_buffer.buf` to the data pointer `self._ptr`.

    * `hip._util.types.Pointer`:

      Takes the pointer address ``pyobj._ptr`` and writes it to ``self._ptr``.
      No ownership is transferred.

    Type checks are performed in the above order.

    C Attributes:
        _ptr (C type ``void *``, protected):
            Stores a pointer to the data of the original Python object.
        _is_ptr_owner (C type ``bint``, protected):
            If this wrapper is the owner of the underlying data.
        _py_buffer (C type ``Py_buffer`, protected):
            Stores a pointer to the data of the original Python object.
        _py_buffer_acquired (C type ``bint``, protected):
            Stores a pointer to the data of the original Python object.
    """
    # C members declared in pxd file

    def __cinit__(self):
        self._ptr = NULL
        self._is_ptr_owner = False
        self._py_buffer_acquired = False

    cdef chip.short4* getElementPtr(self):
        return <chip.short4*>self._ptr

    @staticmethod
    cdef short4 fromPtr(void* ptr, bint owner=False):
        """Factory function to create ``short4`` objects from
        given ``chip.short4`` pointer.

        Setting ``owner`` flag to ``True`` causes
        the extension type to free the structure pointed to by ``ptr``
        when the wrapper object is deallocated.
        """
        # Fast call to __new__() that bypasses the __init__() constructor.
        cdef short4 wrapper = short4.__new__(short4)
        wrapper._ptr = ptr
        wrapper._is_ptr_owner = owner
        return wrapper

    @staticmethod
    def fromObj(pyobj):
        """Creates a short4 from a Python object.

        Derives a short4 from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``short4`` reference, this method
        returns it directly. No new ``short4`` is created in this case.
        """
        return short4.fromPyobj(pyobj)

    @staticmethod
    cdef short4 fromPyobj(object pyobj):
        """Creates a short4 from a Python object.

        Derives a short4 from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``short4`` reference, this method
        returns it directly. No new ``short4`` is created in this case.

        Args:
            pyobj (object): Must be either `None`; a `hip._util.types.Pointer`; a simple, contiguous buffer according to the buffer protocol;
                            or of type `short4`; `int`; or `ctypes.c_void_p`.

        Note:
            This routine does not perform a copy but returns the original ``pyobj``
            if ``pyobj`` is an instance of short4!
        """
        cdef short4 wrapper

        if isinstance(pyobj,short4):
            return pyobj
        else:
            wrapper = short4.__new__(short4)
            wrapper.init_from_pyobj(pyobj)
            return wrapper

    def __dealloc__(self):
        # Release the buffer handle
        if self._py_buffer_acquired is True:
            cpython.buffer.PyBuffer_Release(&self._py_buffer)
        # De-allocate if not null and flag is set
        if self._ptr is not NULL and self._is_ptr_owner is True:
            stdlib.free(self._ptr)
            self._ptr = NULL

    @staticmethod
    cdef __allocate(void** ptr):
        ptr[0] = stdlib.malloc(sizeof(chip.short4))
        string.memset(<void*>ptr[0], 0, sizeof(chip.short4))

        if ptr[0] is NULL:
            raise MemoryError

    @staticmethod
    cdef short4 new():
        """Factory function to create short4 objects with
        newly allocated chip.short4"""
        cdef void* ptr
        short4.__allocate(&ptr)
        return short4.fromPtr(ptr, owner=True)

    @staticmethod
    cdef short4 fromValue(chip.short4 other):
        """Allocate new C type and copy from ``other``.
        """
        wrapper = short4.new()
        string.memcpy(wrapper._ptr, &other, sizeof(chip.short4))
        return wrapper

    def c_sizeof(self):
        """Returns the size of the underlying C type in bytes.
        Note:
            Implemented as function to not collide with
            autogenerated property names.
        """
        return sizeof(chip.short4)

    def __int__(self):
        """Returns the data's address as long integer.
        """
        return cpython.long.PyLong_FromVoidPtr(self._ptr)

    def __repr__(self):
        return f"<short4 object, ptr: {int(self)}>"

    def as_c_void_p(self):
        """Returns the data's address as `ctypes.c_void_p`
        Note:
            Implemented as function to not collide with
            autogenerated property names.
        """
        return ctypes.c_void_p(int(self))

    def __init__(self,*args,**kwargs):
        """Constructor type short4.

        Constructor for type short4.

        Args:
            *args:
                Positional arguments. Initialize all or a subset of the member variables
                according to their order of declaration.
            **kwargs:
                Can be used to initialize member variables at construction,
                Just pass an argument expression of the form <member>=<value>
                per member that you want to initialize.
        """
        short4.__allocate(&self._ptr)
        self._is_ptr_owner = True
        attribs = self.PROPERTIES()
        used_attribs = set()
        if len(args) > len(attribs):
            raise ValueError("More positional arguments specified than this type has properties.")
        for i,v in enumerate(args):
            setattr(self,attribs[i],v)
            used_attribs.add(attribs[i])
        valid_names = ", ".join(["'"+p+"'" for p in attribs])
        for k,v in kwargs.items():
            if k in used_attribs:
                raise KeyError(f"argument '{k}' has already been specified as positional argument.")
            elif k not in attribs:
                raise KeyError(f"'{k}' is no valid property name. Valid names: {valid_names}")
            setattr(self,k,v)
    def get_x(self, i):
        """Get value ``x`` of ``(<chip.short4*>self._ptr)[i]``.
        """
        return (<chip.short4*>self._ptr)[i].x
    def set_x(self, i, short value):
        """Set value ``x`` of ``(<chip.short4*>self._ptr)[i]``.
        """
        (<chip.short4*>self._ptr)[i].x = value
    @property
    def x(self):
        """(undocumented)"""
        return self.get_x(0)
    @x.setter
    def x(self, short value):
        self.set_x(0,value)

    def get_y(self, i):
        """Get value ``y`` of ``(<chip.short4*>self._ptr)[i]``.
        """
        return (<chip.short4*>self._ptr)[i].y
    def set_y(self, i, short value):
        """Set value ``y`` of ``(<chip.short4*>self._ptr)[i]``.
        """
        (<chip.short4*>self._ptr)[i].y = value
    @property
    def y(self):
        """(undocumented)"""
        return self.get_y(0)
    @y.setter
    def y(self, short value):
        self.set_y(0,value)

    def get_z(self, i):
        """Get value ``z`` of ``(<chip.short4*>self._ptr)[i]``.
        """
        return (<chip.short4*>self._ptr)[i].z
    def set_z(self, i, short value):
        """Set value ``z`` of ``(<chip.short4*>self._ptr)[i]``.
        """
        (<chip.short4*>self._ptr)[i].z = value
    @property
    def z(self):
        """(undocumented)"""
        return self.get_z(0)
    @z.setter
    def z(self, short value):
        self.set_z(0,value)

    def get_w(self, i):
        """Get value ``w`` of ``(<chip.short4*>self._ptr)[i]``.
        """
        return (<chip.short4*>self._ptr)[i].w
    def set_w(self, i, short value):
        """Set value ``w`` of ``(<chip.short4*>self._ptr)[i]``.
        """
        (<chip.short4*>self._ptr)[i].w = value
    @property
    def w(self):
        """(undocumented)"""
        return self.get_w(0)
    @w.setter
    def w(self, short value):
        self.set_w(0,value)

    @staticmethod
    def PROPERTIES():
        return ["x","y","z","w"]

    def __contains__(self,item):
        properties = self.PROPERTIES()
        return item in properties

    def __getitem__(self,item):
        properties = self.PROPERTIES()
        if isinstance(item,int):
            if item < 0 or item >= len(properties):
                raise IndexError()
            return getattr(self,properties[item])
        raise ValueError("'item' type must be 'int'")


cdef class uint1(hip._util.types.Pointer):
    """Python wrapper for cdef class chip.uint1.

    Python wrapper for cdef class chip.uint1.

    If this type is initialized via its `__init__` method, it allocates a
    member of the underlying C type and destroys it again if the wrapper
    type is deallocated.

    This type also serves as adapter when appearing as argument type in a
    function signature. In this case, the type can further be initialized
    from a number of Python objects:

    * `None`:

      This will set the ``self._ptr`` attribute to ``NULL``.

    * `int`:

      Interprets the integer value as pointer address and writes it to ``self._ptr``.
      No ownership is transferred.

    * `ctypes.c_void_p`:

      Takes the pointer address ``pyobj.value`` and writes it to ``self._ptr``.
      No ownership is transferred.

    * `object` that implements the `CUDA Array Interface <https://numba.readthedocs.io/en/stable/cuda/cuda_array_interface.html>`_ protocol:

      Takes the integer-valued pointer address, i.e. the first entry of the `data` tuple
      from `pyobj`'s member ``__cuda_array_interface__``  and writes it to ``self._ptr``.

    * `object` that implements the Python buffer protocol:

      If the object represents a simple contiguous array,
      writes the `Py_buffer` associated with ``pyobj`` to `self._py_buffer`,
      sets the `self._py_buffer_acquired` flag to `True`, and
      writes `self._py_buffer.buf` to the data pointer `self._ptr`.

    * `hip._util.types.Pointer`:

      Takes the pointer address ``pyobj._ptr`` and writes it to ``self._ptr``.
      No ownership is transferred.

    Type checks are performed in the above order.

    C Attributes:
        _ptr (C type ``void *``, protected):
            Stores a pointer to the data of the original Python object.
        _is_ptr_owner (C type ``bint``, protected):
            If this wrapper is the owner of the underlying data.
        _py_buffer (C type ``Py_buffer`, protected):
            Stores a pointer to the data of the original Python object.
        _py_buffer_acquired (C type ``bint``, protected):
            Stores a pointer to the data of the original Python object.
    """
    # C members declared in pxd file

    def __cinit__(self):
        self._ptr = NULL
        self._is_ptr_owner = False
        self._py_buffer_acquired = False

    cdef chip.uint1* getElementPtr(self):
        return <chip.uint1*>self._ptr

    @staticmethod
    cdef uint1 fromPtr(void* ptr, bint owner=False):
        """Factory function to create ``uint1`` objects from
        given ``chip.uint1`` pointer.

        Setting ``owner`` flag to ``True`` causes
        the extension type to free the structure pointed to by ``ptr``
        when the wrapper object is deallocated.
        """
        # Fast call to __new__() that bypasses the __init__() constructor.
        cdef uint1 wrapper = uint1.__new__(uint1)
        wrapper._ptr = ptr
        wrapper._is_ptr_owner = owner
        return wrapper

    @staticmethod
    def fromObj(pyobj):
        """Creates a uint1 from a Python object.

        Derives a uint1 from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``uint1`` reference, this method
        returns it directly. No new ``uint1`` is created in this case.
        """
        return uint1.fromPyobj(pyobj)

    @staticmethod
    cdef uint1 fromPyobj(object pyobj):
        """Creates a uint1 from a Python object.

        Derives a uint1 from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``uint1`` reference, this method
        returns it directly. No new ``uint1`` is created in this case.

        Args:
            pyobj (object): Must be either `None`; a `hip._util.types.Pointer`; a simple, contiguous buffer according to the buffer protocol;
                            or of type `uint1`; `int`; or `ctypes.c_void_p`.

        Note:
            This routine does not perform a copy but returns the original ``pyobj``
            if ``pyobj`` is an instance of uint1!
        """
        cdef uint1 wrapper

        if isinstance(pyobj,uint1):
            return pyobj
        else:
            wrapper = uint1.__new__(uint1)
            wrapper.init_from_pyobj(pyobj)
            return wrapper

    def __dealloc__(self):
        # Release the buffer handle
        if self._py_buffer_acquired is True:
            cpython.buffer.PyBuffer_Release(&self._py_buffer)
        # De-allocate if not null and flag is set
        if self._ptr is not NULL and self._is_ptr_owner is True:
            stdlib.free(self._ptr)
            self._ptr = NULL

    @staticmethod
    cdef __allocate(void** ptr):
        ptr[0] = stdlib.malloc(sizeof(chip.uint1))
        string.memset(<void*>ptr[0], 0, sizeof(chip.uint1))

        if ptr[0] is NULL:
            raise MemoryError

    @staticmethod
    cdef uint1 new():
        """Factory function to create uint1 objects with
        newly allocated chip.uint1"""
        cdef void* ptr
        uint1.__allocate(&ptr)
        return uint1.fromPtr(ptr, owner=True)

    @staticmethod
    cdef uint1 fromValue(chip.uint1 other):
        """Allocate new C type and copy from ``other``.
        """
        wrapper = uint1.new()
        string.memcpy(wrapper._ptr, &other, sizeof(chip.uint1))
        return wrapper

    def c_sizeof(self):
        """Returns the size of the underlying C type in bytes.
        Note:
            Implemented as function to not collide with
            autogenerated property names.
        """
        return sizeof(chip.uint1)

    def __int__(self):
        """Returns the data's address as long integer.
        """
        return cpython.long.PyLong_FromVoidPtr(self._ptr)

    def __repr__(self):
        return f"<uint1 object, ptr: {int(self)}>"

    def as_c_void_p(self):
        """Returns the data's address as `ctypes.c_void_p`
        Note:
            Implemented as function to not collide with
            autogenerated property names.
        """
        return ctypes.c_void_p(int(self))

    def __init__(self,*args,**kwargs):
        """Constructor type uint1.

        Constructor for type uint1.

        Args:
            *args:
                Positional arguments. Initialize all or a subset of the member variables
                according to their order of declaration.
            **kwargs:
                Can be used to initialize member variables at construction,
                Just pass an argument expression of the form <member>=<value>
                per member that you want to initialize.
        """
        uint1.__allocate(&self._ptr)
        self._is_ptr_owner = True
        attribs = self.PROPERTIES()
        used_attribs = set()
        if len(args) > len(attribs):
            raise ValueError("More positional arguments specified than this type has properties.")
        for i,v in enumerate(args):
            setattr(self,attribs[i],v)
            used_attribs.add(attribs[i])
        valid_names = ", ".join(["'"+p+"'" for p in attribs])
        for k,v in kwargs.items():
            if k in used_attribs:
                raise KeyError(f"argument '{k}' has already been specified as positional argument.")
            elif k not in attribs:
                raise KeyError(f"'{k}' is no valid property name. Valid names: {valid_names}")
            setattr(self,k,v)
    def get_x(self, i):
        """Get value ``x`` of ``(<chip.uint1*>self._ptr)[i]``.
        """
        return (<chip.uint1*>self._ptr)[i].x
    def set_x(self, i, unsigned int value):
        """Set value ``x`` of ``(<chip.uint1*>self._ptr)[i]``.
        """
        (<chip.uint1*>self._ptr)[i].x = value
    @property
    def x(self):
        """(undocumented)"""
        return self.get_x(0)
    @x.setter
    def x(self, unsigned int value):
        self.set_x(0,value)

    @staticmethod
    def PROPERTIES():
        return ["x"]

    def __contains__(self,item):
        properties = self.PROPERTIES()
        return item in properties

    def __getitem__(self,item):
        properties = self.PROPERTIES()
        if isinstance(item,int):
            if item < 0 or item >= len(properties):
                raise IndexError()
            return getattr(self,properties[item])
        raise ValueError("'item' type must be 'int'")


cdef class uint2(hip._util.types.Pointer):
    """Python wrapper for cdef class chip.uint2.

    Python wrapper for cdef class chip.uint2.

    If this type is initialized via its `__init__` method, it allocates a
    member of the underlying C type and destroys it again if the wrapper
    type is deallocated.

    This type also serves as adapter when appearing as argument type in a
    function signature. In this case, the type can further be initialized
    from a number of Python objects:

    * `None`:

      This will set the ``self._ptr`` attribute to ``NULL``.

    * `int`:

      Interprets the integer value as pointer address and writes it to ``self._ptr``.
      No ownership is transferred.

    * `ctypes.c_void_p`:

      Takes the pointer address ``pyobj.value`` and writes it to ``self._ptr``.
      No ownership is transferred.

    * `object` that implements the `CUDA Array Interface <https://numba.readthedocs.io/en/stable/cuda/cuda_array_interface.html>`_ protocol:

      Takes the integer-valued pointer address, i.e. the first entry of the `data` tuple
      from `pyobj`'s member ``__cuda_array_interface__``  and writes it to ``self._ptr``.

    * `object` that implements the Python buffer protocol:

      If the object represents a simple contiguous array,
      writes the `Py_buffer` associated with ``pyobj`` to `self._py_buffer`,
      sets the `self._py_buffer_acquired` flag to `True`, and
      writes `self._py_buffer.buf` to the data pointer `self._ptr`.

    * `hip._util.types.Pointer`:

      Takes the pointer address ``pyobj._ptr`` and writes it to ``self._ptr``.
      No ownership is transferred.

    Type checks are performed in the above order.

    C Attributes:
        _ptr (C type ``void *``, protected):
            Stores a pointer to the data of the original Python object.
        _is_ptr_owner (C type ``bint``, protected):
            If this wrapper is the owner of the underlying data.
        _py_buffer (C type ``Py_buffer`, protected):
            Stores a pointer to the data of the original Python object.
        _py_buffer_acquired (C type ``bint``, protected):
            Stores a pointer to the data of the original Python object.
    """
    # C members declared in pxd file

    def __cinit__(self):
        self._ptr = NULL
        self._is_ptr_owner = False
        self._py_buffer_acquired = False

    cdef chip.uint2* getElementPtr(self):
        return <chip.uint2*>self._ptr

    @staticmethod
    cdef uint2 fromPtr(void* ptr, bint owner=False):
        """Factory function to create ``uint2`` objects from
        given ``chip.uint2`` pointer.

        Setting ``owner`` flag to ``True`` causes
        the extension type to free the structure pointed to by ``ptr``
        when the wrapper object is deallocated.
        """
        # Fast call to __new__() that bypasses the __init__() constructor.
        cdef uint2 wrapper = uint2.__new__(uint2)
        wrapper._ptr = ptr
        wrapper._is_ptr_owner = owner
        return wrapper

    @staticmethod
    def fromObj(pyobj):
        """Creates a uint2 from a Python object.

        Derives a uint2 from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``uint2`` reference, this method
        returns it directly. No new ``uint2`` is created in this case.
        """
        return uint2.fromPyobj(pyobj)

    @staticmethod
    cdef uint2 fromPyobj(object pyobj):
        """Creates a uint2 from a Python object.

        Derives a uint2 from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``uint2`` reference, this method
        returns it directly. No new ``uint2`` is created in this case.

        Args:
            pyobj (object): Must be either `None`; a `hip._util.types.Pointer`; a simple, contiguous buffer according to the buffer protocol;
                            or of type `uint2`; `int`; or `ctypes.c_void_p`.

        Note:
            This routine does not perform a copy but returns the original ``pyobj``
            if ``pyobj`` is an instance of uint2!
        """
        cdef uint2 wrapper

        if isinstance(pyobj,uint2):
            return pyobj
        else:
            wrapper = uint2.__new__(uint2)
            wrapper.init_from_pyobj(pyobj)
            return wrapper

    def __dealloc__(self):
        # Release the buffer handle
        if self._py_buffer_acquired is True:
            cpython.buffer.PyBuffer_Release(&self._py_buffer)
        # De-allocate if not null and flag is set
        if self._ptr is not NULL and self._is_ptr_owner is True:
            stdlib.free(self._ptr)
            self._ptr = NULL

    @staticmethod
    cdef __allocate(void** ptr):
        ptr[0] = stdlib.malloc(sizeof(chip.uint2))
        string.memset(<void*>ptr[0], 0, sizeof(chip.uint2))

        if ptr[0] is NULL:
            raise MemoryError

    @staticmethod
    cdef uint2 new():
        """Factory function to create uint2 objects with
        newly allocated chip.uint2"""
        cdef void* ptr
        uint2.__allocate(&ptr)
        return uint2.fromPtr(ptr, owner=True)

    @staticmethod
    cdef uint2 fromValue(chip.uint2 other):
        """Allocate new C type and copy from ``other``.
        """
        wrapper = uint2.new()
        string.memcpy(wrapper._ptr, &other, sizeof(chip.uint2))
        return wrapper

    def c_sizeof(self):
        """Returns the size of the underlying C type in bytes.
        Note:
            Implemented as function to not collide with
            autogenerated property names.
        """
        return sizeof(chip.uint2)

    def __int__(self):
        """Returns the data's address as long integer.
        """
        return cpython.long.PyLong_FromVoidPtr(self._ptr)

    def __repr__(self):
        return f"<uint2 object, ptr: {int(self)}>"

    def as_c_void_p(self):
        """Returns the data's address as `ctypes.c_void_p`
        Note:
            Implemented as function to not collide with
            autogenerated property names.
        """
        return ctypes.c_void_p(int(self))

    def __init__(self,*args,**kwargs):
        """Constructor type uint2.

        Constructor for type uint2.

        Args:
            *args:
                Positional arguments. Initialize all or a subset of the member variables
                according to their order of declaration.
            **kwargs:
                Can be used to initialize member variables at construction,
                Just pass an argument expression of the form <member>=<value>
                per member that you want to initialize.
        """
        uint2.__allocate(&self._ptr)
        self._is_ptr_owner = True
        attribs = self.PROPERTIES()
        used_attribs = set()
        if len(args) > len(attribs):
            raise ValueError("More positional arguments specified than this type has properties.")
        for i,v in enumerate(args):
            setattr(self,attribs[i],v)
            used_attribs.add(attribs[i])
        valid_names = ", ".join(["'"+p+"'" for p in attribs])
        for k,v in kwargs.items():
            if k in used_attribs:
                raise KeyError(f"argument '{k}' has already been specified as positional argument.")
            elif k not in attribs:
                raise KeyError(f"'{k}' is no valid property name. Valid names: {valid_names}")
            setattr(self,k,v)
    def get_x(self, i):
        """Get value ``x`` of ``(<chip.uint2*>self._ptr)[i]``.
        """
        return (<chip.uint2*>self._ptr)[i].x
    def set_x(self, i, unsigned int value):
        """Set value ``x`` of ``(<chip.uint2*>self._ptr)[i]``.
        """
        (<chip.uint2*>self._ptr)[i].x = value
    @property
    def x(self):
        """(undocumented)"""
        return self.get_x(0)
    @x.setter
    def x(self, unsigned int value):
        self.set_x(0,value)

    def get_y(self, i):
        """Get value ``y`` of ``(<chip.uint2*>self._ptr)[i]``.
        """
        return (<chip.uint2*>self._ptr)[i].y
    def set_y(self, i, unsigned int value):
        """Set value ``y`` of ``(<chip.uint2*>self._ptr)[i]``.
        """
        (<chip.uint2*>self._ptr)[i].y = value
    @property
    def y(self):
        """(undocumented)"""
        return self.get_y(0)
    @y.setter
    def y(self, unsigned int value):
        self.set_y(0,value)

    @staticmethod
    def PROPERTIES():
        return ["x","y"]

    def __contains__(self,item):
        properties = self.PROPERTIES()
        return item in properties

    def __getitem__(self,item):
        properties = self.PROPERTIES()
        if isinstance(item,int):
            if item < 0 or item >= len(properties):
                raise IndexError()
            return getattr(self,properties[item])
        raise ValueError("'item' type must be 'int'")


cdef class uint3(hip._util.types.Pointer):
    """Python wrapper for cdef class chip.uint3.

    Python wrapper for cdef class chip.uint3.

    If this type is initialized via its `__init__` method, it allocates a
    member of the underlying C type and destroys it again if the wrapper
    type is deallocated.

    This type also serves as adapter when appearing as argument type in a
    function signature. In this case, the type can further be initialized
    from a number of Python objects:

    * `None`:

      This will set the ``self._ptr`` attribute to ``NULL``.

    * `int`:

      Interprets the integer value as pointer address and writes it to ``self._ptr``.
      No ownership is transferred.

    * `ctypes.c_void_p`:

      Takes the pointer address ``pyobj.value`` and writes it to ``self._ptr``.
      No ownership is transferred.

    * `object` that implements the `CUDA Array Interface <https://numba.readthedocs.io/en/stable/cuda/cuda_array_interface.html>`_ protocol:

      Takes the integer-valued pointer address, i.e. the first entry of the `data` tuple
      from `pyobj`'s member ``__cuda_array_interface__``  and writes it to ``self._ptr``.

    * `object` that implements the Python buffer protocol:

      If the object represents a simple contiguous array,
      writes the `Py_buffer` associated with ``pyobj`` to `self._py_buffer`,
      sets the `self._py_buffer_acquired` flag to `True`, and
      writes `self._py_buffer.buf` to the data pointer `self._ptr`.

    * `hip._util.types.Pointer`:

      Takes the pointer address ``pyobj._ptr`` and writes it to ``self._ptr``.
      No ownership is transferred.

    Type checks are performed in the above order.

    C Attributes:
        _ptr (C type ``void *``, protected):
            Stores a pointer to the data of the original Python object.
        _is_ptr_owner (C type ``bint``, protected):
            If this wrapper is the owner of the underlying data.
        _py_buffer (C type ``Py_buffer`, protected):
            Stores a pointer to the data of the original Python object.
        _py_buffer_acquired (C type ``bint``, protected):
            Stores a pointer to the data of the original Python object.
    """
    # C members declared in pxd file

    def __cinit__(self):
        self._ptr = NULL
        self._is_ptr_owner = False
        self._py_buffer_acquired = False

    cdef chip.uint3* getElementPtr(self):
        return <chip.uint3*>self._ptr

    @staticmethod
    cdef uint3 fromPtr(void* ptr, bint owner=False):
        """Factory function to create ``uint3`` objects from
        given ``chip.uint3`` pointer.

        Setting ``owner`` flag to ``True`` causes
        the extension type to free the structure pointed to by ``ptr``
        when the wrapper object is deallocated.
        """
        # Fast call to __new__() that bypasses the __init__() constructor.
        cdef uint3 wrapper = uint3.__new__(uint3)
        wrapper._ptr = ptr
        wrapper._is_ptr_owner = owner
        return wrapper

    @staticmethod
    def fromObj(pyobj):
        """Creates a uint3 from a Python object.

        Derives a uint3 from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``uint3`` reference, this method
        returns it directly. No new ``uint3`` is created in this case.
        """
        return uint3.fromPyobj(pyobj)

    @staticmethod
    cdef uint3 fromPyobj(object pyobj):
        """Creates a uint3 from a Python object.

        Derives a uint3 from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``uint3`` reference, this method
        returns it directly. No new ``uint3`` is created in this case.

        Args:
            pyobj (object): Must be either `None`; a `hip._util.types.Pointer`; a simple, contiguous buffer according to the buffer protocol;
                            or of type `uint3`; `int`; or `ctypes.c_void_p`.

        Note:
            This routine does not perform a copy but returns the original ``pyobj``
            if ``pyobj`` is an instance of uint3!
        """
        cdef uint3 wrapper

        if isinstance(pyobj,uint3):
            return pyobj
        else:
            wrapper = uint3.__new__(uint3)
            wrapper.init_from_pyobj(pyobj)
            return wrapper

    def __dealloc__(self):
        # Release the buffer handle
        if self._py_buffer_acquired is True:
            cpython.buffer.PyBuffer_Release(&self._py_buffer)
        # De-allocate if not null and flag is set
        if self._ptr is not NULL and self._is_ptr_owner is True:
            stdlib.free(self._ptr)
            self._ptr = NULL

    @staticmethod
    cdef __allocate(void** ptr):
        ptr[0] = stdlib.malloc(sizeof(chip.uint3))
        string.memset(<void*>ptr[0], 0, sizeof(chip.uint3))

        if ptr[0] is NULL:
            raise MemoryError

    @staticmethod
    cdef uint3 new():
        """Factory function to create uint3 objects with
        newly allocated chip.uint3"""
        cdef void* ptr
        uint3.__allocate(&ptr)
        return uint3.fromPtr(ptr, owner=True)

    @staticmethod
    cdef uint3 fromValue(chip.uint3 other):
        """Allocate new C type and copy from ``other``.
        """
        wrapper = uint3.new()
        string.memcpy(wrapper._ptr, &other, sizeof(chip.uint3))
        return wrapper

    def c_sizeof(self):
        """Returns the size of the underlying C type in bytes.
        Note:
            Implemented as function to not collide with
            autogenerated property names.
        """
        return sizeof(chip.uint3)

    def __int__(self):
        """Returns the data's address as long integer.
        """
        return cpython.long.PyLong_FromVoidPtr(self._ptr)

    def __repr__(self):
        return f"<uint3 object, ptr: {int(self)}>"

    def as_c_void_p(self):
        """Returns the data's address as `ctypes.c_void_p`
        Note:
            Implemented as function to not collide with
            autogenerated property names.
        """
        return ctypes.c_void_p(int(self))

    def __init__(self,*args,**kwargs):
        """Constructor type uint3.

        Constructor for type uint3.

        Args:
            *args:
                Positional arguments. Initialize all or a subset of the member variables
                according to their order of declaration.
            **kwargs:
                Can be used to initialize member variables at construction,
                Just pass an argument expression of the form <member>=<value>
                per member that you want to initialize.
        """
        uint3.__allocate(&self._ptr)
        self._is_ptr_owner = True
        attribs = self.PROPERTIES()
        used_attribs = set()
        if len(args) > len(attribs):
            raise ValueError("More positional arguments specified than this type has properties.")
        for i,v in enumerate(args):
            setattr(self,attribs[i],v)
            used_attribs.add(attribs[i])
        valid_names = ", ".join(["'"+p+"'" for p in attribs])
        for k,v in kwargs.items():
            if k in used_attribs:
                raise KeyError(f"argument '{k}' has already been specified as positional argument.")
            elif k not in attribs:
                raise KeyError(f"'{k}' is no valid property name. Valid names: {valid_names}")
            setattr(self,k,v)
    def get_x(self, i):
        """Get value ``x`` of ``(<chip.uint3*>self._ptr)[i]``.
        """
        return (<chip.uint3*>self._ptr)[i].x
    def set_x(self, i, unsigned int value):
        """Set value ``x`` of ``(<chip.uint3*>self._ptr)[i]``.
        """
        (<chip.uint3*>self._ptr)[i].x = value
    @property
    def x(self):
        """(undocumented)"""
        return self.get_x(0)
    @x.setter
    def x(self, unsigned int value):
        self.set_x(0,value)

    def get_y(self, i):
        """Get value ``y`` of ``(<chip.uint3*>self._ptr)[i]``.
        """
        return (<chip.uint3*>self._ptr)[i].y
    def set_y(self, i, unsigned int value):
        """Set value ``y`` of ``(<chip.uint3*>self._ptr)[i]``.
        """
        (<chip.uint3*>self._ptr)[i].y = value
    @property
    def y(self):
        """(undocumented)"""
        return self.get_y(0)
    @y.setter
    def y(self, unsigned int value):
        self.set_y(0,value)

    def get_z(self, i):
        """Get value ``z`` of ``(<chip.uint3*>self._ptr)[i]``.
        """
        return (<chip.uint3*>self._ptr)[i].z
    def set_z(self, i, unsigned int value):
        """Set value ``z`` of ``(<chip.uint3*>self._ptr)[i]``.
        """
        (<chip.uint3*>self._ptr)[i].z = value
    @property
    def z(self):
        """(undocumented)"""
        return self.get_z(0)
    @z.setter
    def z(self, unsigned int value):
        self.set_z(0,value)

    @staticmethod
    def PROPERTIES():
        return ["x","y","z"]

    def __contains__(self,item):
        properties = self.PROPERTIES()
        return item in properties

    def __getitem__(self,item):
        properties = self.PROPERTIES()
        if isinstance(item,int):
            if item < 0 or item >= len(properties):
                raise IndexError()
            return getattr(self,properties[item])
        raise ValueError("'item' type must be 'int'")


cdef class uint4(hip._util.types.Pointer):
    """Python wrapper for cdef class chip.uint4.

    Python wrapper for cdef class chip.uint4.

    If this type is initialized via its `__init__` method, it allocates a
    member of the underlying C type and destroys it again if the wrapper
    type is deallocated.

    This type also serves as adapter when appearing as argument type in a
    function signature. In this case, the type can further be initialized
    from a number of Python objects:

    * `None`:

      This will set the ``self._ptr`` attribute to ``NULL``.

    * `int`:

      Interprets the integer value as pointer address and writes it to ``self._ptr``.
      No ownership is transferred.

    * `ctypes.c_void_p`:

      Takes the pointer address ``pyobj.value`` and writes it to ``self._ptr``.
      No ownership is transferred.

    * `object` that implements the `CUDA Array Interface <https://numba.readthedocs.io/en/stable/cuda/cuda_array_interface.html>`_ protocol:

      Takes the integer-valued pointer address, i.e. the first entry of the `data` tuple
      from `pyobj`'s member ``__cuda_array_interface__``  and writes it to ``self._ptr``.

    * `object` that implements the Python buffer protocol:

      If the object represents a simple contiguous array,
      writes the `Py_buffer` associated with ``pyobj`` to `self._py_buffer`,
      sets the `self._py_buffer_acquired` flag to `True`, and
      writes `self._py_buffer.buf` to the data pointer `self._ptr`.

    * `hip._util.types.Pointer`:

      Takes the pointer address ``pyobj._ptr`` and writes it to ``self._ptr``.
      No ownership is transferred.

    Type checks are performed in the above order.

    C Attributes:
        _ptr (C type ``void *``, protected):
            Stores a pointer to the data of the original Python object.
        _is_ptr_owner (C type ``bint``, protected):
            If this wrapper is the owner of the underlying data.
        _py_buffer (C type ``Py_buffer`, protected):
            Stores a pointer to the data of the original Python object.
        _py_buffer_acquired (C type ``bint``, protected):
            Stores a pointer to the data of the original Python object.
    """
    # C members declared in pxd file

    def __cinit__(self):
        self._ptr = NULL
        self._is_ptr_owner = False
        self._py_buffer_acquired = False

    cdef chip.uint4* getElementPtr(self):
        return <chip.uint4*>self._ptr

    @staticmethod
    cdef uint4 fromPtr(void* ptr, bint owner=False):
        """Factory function to create ``uint4`` objects from
        given ``chip.uint4`` pointer.

        Setting ``owner`` flag to ``True`` causes
        the extension type to free the structure pointed to by ``ptr``
        when the wrapper object is deallocated.
        """
        # Fast call to __new__() that bypasses the __init__() constructor.
        cdef uint4 wrapper = uint4.__new__(uint4)
        wrapper._ptr = ptr
        wrapper._is_ptr_owner = owner
        return wrapper

    @staticmethod
    def fromObj(pyobj):
        """Creates a uint4 from a Python object.

        Derives a uint4 from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``uint4`` reference, this method
        returns it directly. No new ``uint4`` is created in this case.
        """
        return uint4.fromPyobj(pyobj)

    @staticmethod
    cdef uint4 fromPyobj(object pyobj):
        """Creates a uint4 from a Python object.

        Derives a uint4 from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``uint4`` reference, this method
        returns it directly. No new ``uint4`` is created in this case.

        Args:
            pyobj (object): Must be either `None`; a `hip._util.types.Pointer`; a simple, contiguous buffer according to the buffer protocol;
                            or of type `uint4`; `int`; or `ctypes.c_void_p`.

        Note:
            This routine does not perform a copy but returns the original ``pyobj``
            if ``pyobj`` is an instance of uint4!
        """
        cdef uint4 wrapper

        if isinstance(pyobj,uint4):
            return pyobj
        else:
            wrapper = uint4.__new__(uint4)
            wrapper.init_from_pyobj(pyobj)
            return wrapper

    def __dealloc__(self):
        # Release the buffer handle
        if self._py_buffer_acquired is True:
            cpython.buffer.PyBuffer_Release(&self._py_buffer)
        # De-allocate if not null and flag is set
        if self._ptr is not NULL and self._is_ptr_owner is True:
            stdlib.free(self._ptr)
            self._ptr = NULL

    @staticmethod
    cdef __allocate(void** ptr):
        ptr[0] = stdlib.malloc(sizeof(chip.uint4))
        string.memset(<void*>ptr[0], 0, sizeof(chip.uint4))

        if ptr[0] is NULL:
            raise MemoryError

    @staticmethod
    cdef uint4 new():
        """Factory function to create uint4 objects with
        newly allocated chip.uint4"""
        cdef void* ptr
        uint4.__allocate(&ptr)
        return uint4.fromPtr(ptr, owner=True)

    @staticmethod
    cdef uint4 fromValue(chip.uint4 other):
        """Allocate new C type and copy from ``other``.
        """
        wrapper = uint4.new()
        string.memcpy(wrapper._ptr, &other, sizeof(chip.uint4))
        return wrapper

    def c_sizeof(self):
        """Returns the size of the underlying C type in bytes.
        Note:
            Implemented as function to not collide with
            autogenerated property names.
        """
        return sizeof(chip.uint4)

    def __int__(self):
        """Returns the data's address as long integer.
        """
        return cpython.long.PyLong_FromVoidPtr(self._ptr)

    def __repr__(self):
        return f"<uint4 object, ptr: {int(self)}>"

    def as_c_void_p(self):
        """Returns the data's address as `ctypes.c_void_p`
        Note:
            Implemented as function to not collide with
            autogenerated property names.
        """
        return ctypes.c_void_p(int(self))

    def __init__(self,*args,**kwargs):
        """Constructor type uint4.

        Constructor for type uint4.

        Args:
            *args:
                Positional arguments. Initialize all or a subset of the member variables
                according to their order of declaration.
            **kwargs:
                Can be used to initialize member variables at construction,
                Just pass an argument expression of the form <member>=<value>
                per member that you want to initialize.
        """
        uint4.__allocate(&self._ptr)
        self._is_ptr_owner = True
        attribs = self.PROPERTIES()
        used_attribs = set()
        if len(args) > len(attribs):
            raise ValueError("More positional arguments specified than this type has properties.")
        for i,v in enumerate(args):
            setattr(self,attribs[i],v)
            used_attribs.add(attribs[i])
        valid_names = ", ".join(["'"+p+"'" for p in attribs])
        for k,v in kwargs.items():
            if k in used_attribs:
                raise KeyError(f"argument '{k}' has already been specified as positional argument.")
            elif k not in attribs:
                raise KeyError(f"'{k}' is no valid property name. Valid names: {valid_names}")
            setattr(self,k,v)
    def get_x(self, i):
        """Get value ``x`` of ``(<chip.uint4*>self._ptr)[i]``.
        """
        return (<chip.uint4*>self._ptr)[i].x
    def set_x(self, i, unsigned int value):
        """Set value ``x`` of ``(<chip.uint4*>self._ptr)[i]``.
        """
        (<chip.uint4*>self._ptr)[i].x = value
    @property
    def x(self):
        """(undocumented)"""
        return self.get_x(0)
    @x.setter
    def x(self, unsigned int value):
        self.set_x(0,value)

    def get_y(self, i):
        """Get value ``y`` of ``(<chip.uint4*>self._ptr)[i]``.
        """
        return (<chip.uint4*>self._ptr)[i].y
    def set_y(self, i, unsigned int value):
        """Set value ``y`` of ``(<chip.uint4*>self._ptr)[i]``.
        """
        (<chip.uint4*>self._ptr)[i].y = value
    @property
    def y(self):
        """(undocumented)"""
        return self.get_y(0)
    @y.setter
    def y(self, unsigned int value):
        self.set_y(0,value)

    def get_z(self, i):
        """Get value ``z`` of ``(<chip.uint4*>self._ptr)[i]``.
        """
        return (<chip.uint4*>self._ptr)[i].z
    def set_z(self, i, unsigned int value):
        """Set value ``z`` of ``(<chip.uint4*>self._ptr)[i]``.
        """
        (<chip.uint4*>self._ptr)[i].z = value
    @property
    def z(self):
        """(undocumented)"""
        return self.get_z(0)
    @z.setter
    def z(self, unsigned int value):
        self.set_z(0,value)

    def get_w(self, i):
        """Get value ``w`` of ``(<chip.uint4*>self._ptr)[i]``.
        """
        return (<chip.uint4*>self._ptr)[i].w
    def set_w(self, i, unsigned int value):
        """Set value ``w`` of ``(<chip.uint4*>self._ptr)[i]``.
        """
        (<chip.uint4*>self._ptr)[i].w = value
    @property
    def w(self):
        """(undocumented)"""
        return self.get_w(0)
    @w.setter
    def w(self, unsigned int value):
        self.set_w(0,value)

    @staticmethod
    def PROPERTIES():
        return ["x","y","z","w"]

    def __contains__(self,item):
        properties = self.PROPERTIES()
        return item in properties

    def __getitem__(self,item):
        properties = self.PROPERTIES()
        if isinstance(item,int):
            if item < 0 or item >= len(properties):
                raise IndexError()
            return getattr(self,properties[item])
        raise ValueError("'item' type must be 'int'")


cdef class int1(hip._util.types.Pointer):
    """Python wrapper for cdef class chip.int1.

    Python wrapper for cdef class chip.int1.

    If this type is initialized via its `__init__` method, it allocates a
    member of the underlying C type and destroys it again if the wrapper
    type is deallocated.

    This type also serves as adapter when appearing as argument type in a
    function signature. In this case, the type can further be initialized
    from a number of Python objects:

    * `None`:

      This will set the ``self._ptr`` attribute to ``NULL``.

    * `int`:

      Interprets the integer value as pointer address and writes it to ``self._ptr``.
      No ownership is transferred.

    * `ctypes.c_void_p`:

      Takes the pointer address ``pyobj.value`` and writes it to ``self._ptr``.
      No ownership is transferred.

    * `object` that implements the `CUDA Array Interface <https://numba.readthedocs.io/en/stable/cuda/cuda_array_interface.html>`_ protocol:

      Takes the integer-valued pointer address, i.e. the first entry of the `data` tuple
      from `pyobj`'s member ``__cuda_array_interface__``  and writes it to ``self._ptr``.

    * `object` that implements the Python buffer protocol:

      If the object represents a simple contiguous array,
      writes the `Py_buffer` associated with ``pyobj`` to `self._py_buffer`,
      sets the `self._py_buffer_acquired` flag to `True`, and
      writes `self._py_buffer.buf` to the data pointer `self._ptr`.

    * `hip._util.types.Pointer`:

      Takes the pointer address ``pyobj._ptr`` and writes it to ``self._ptr``.
      No ownership is transferred.

    Type checks are performed in the above order.

    C Attributes:
        _ptr (C type ``void *``, protected):
            Stores a pointer to the data of the original Python object.
        _is_ptr_owner (C type ``bint``, protected):
            If this wrapper is the owner of the underlying data.
        _py_buffer (C type ``Py_buffer`, protected):
            Stores a pointer to the data of the original Python object.
        _py_buffer_acquired (C type ``bint``, protected):
            Stores a pointer to the data of the original Python object.
    """
    # C members declared in pxd file

    def __cinit__(self):
        self._ptr = NULL
        self._is_ptr_owner = False
        self._py_buffer_acquired = False

    cdef chip.int1* getElementPtr(self):
        return <chip.int1*>self._ptr

    @staticmethod
    cdef int1 fromPtr(void* ptr, bint owner=False):
        """Factory function to create ``int1`` objects from
        given ``chip.int1`` pointer.

        Setting ``owner`` flag to ``True`` causes
        the extension type to free the structure pointed to by ``ptr``
        when the wrapper object is deallocated.
        """
        # Fast call to __new__() that bypasses the __init__() constructor.
        cdef int1 wrapper = int1.__new__(int1)
        wrapper._ptr = ptr
        wrapper._is_ptr_owner = owner
        return wrapper

    @staticmethod
    def fromObj(pyobj):
        """Creates a int1 from a Python object.

        Derives a int1 from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``int1`` reference, this method
        returns it directly. No new ``int1`` is created in this case.
        """
        return int1.fromPyobj(pyobj)

    @staticmethod
    cdef int1 fromPyobj(object pyobj):
        """Creates a int1 from a Python object.

        Derives a int1 from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``int1`` reference, this method
        returns it directly. No new ``int1`` is created in this case.

        Args:
            pyobj (object): Must be either `None`; a `hip._util.types.Pointer`; a simple, contiguous buffer according to the buffer protocol;
                            or of type `int1`; `int`; or `ctypes.c_void_p`.

        Note:
            This routine does not perform a copy but returns the original ``pyobj``
            if ``pyobj`` is an instance of int1!
        """
        cdef int1 wrapper

        if isinstance(pyobj,int1):
            return pyobj
        else:
            wrapper = int1.__new__(int1)
            wrapper.init_from_pyobj(pyobj)
            return wrapper

    def __dealloc__(self):
        # Release the buffer handle
        if self._py_buffer_acquired is True:
            cpython.buffer.PyBuffer_Release(&self._py_buffer)
        # De-allocate if not null and flag is set
        if self._ptr is not NULL and self._is_ptr_owner is True:
            stdlib.free(self._ptr)
            self._ptr = NULL

    @staticmethod
    cdef __allocate(void** ptr):
        ptr[0] = stdlib.malloc(sizeof(chip.int1))
        string.memset(<void*>ptr[0], 0, sizeof(chip.int1))

        if ptr[0] is NULL:
            raise MemoryError

    @staticmethod
    cdef int1 new():
        """Factory function to create int1 objects with
        newly allocated chip.int1"""
        cdef void* ptr
        int1.__allocate(&ptr)
        return int1.fromPtr(ptr, owner=True)

    @staticmethod
    cdef int1 fromValue(chip.int1 other):
        """Allocate new C type and copy from ``other``.
        """
        wrapper = int1.new()
        string.memcpy(wrapper._ptr, &other, sizeof(chip.int1))
        return wrapper

    def c_sizeof(self):
        """Returns the size of the underlying C type in bytes.
        Note:
            Implemented as function to not collide with
            autogenerated property names.
        """
        return sizeof(chip.int1)

    def __int__(self):
        """Returns the data's address as long integer.
        """
        return cpython.long.PyLong_FromVoidPtr(self._ptr)

    def __repr__(self):
        return f"<int1 object, ptr: {int(self)}>"

    def as_c_void_p(self):
        """Returns the data's address as `ctypes.c_void_p`
        Note:
            Implemented as function to not collide with
            autogenerated property names.
        """
        return ctypes.c_void_p(int(self))

    def __init__(self,*args,**kwargs):
        """Constructor type int1.

        Constructor for type int1.

        Args:
            *args:
                Positional arguments. Initialize all or a subset of the member variables
                according to their order of declaration.
            **kwargs:
                Can be used to initialize member variables at construction,
                Just pass an argument expression of the form <member>=<value>
                per member that you want to initialize.
        """
        int1.__allocate(&self._ptr)
        self._is_ptr_owner = True
        attribs = self.PROPERTIES()
        used_attribs = set()
        if len(args) > len(attribs):
            raise ValueError("More positional arguments specified than this type has properties.")
        for i,v in enumerate(args):
            setattr(self,attribs[i],v)
            used_attribs.add(attribs[i])
        valid_names = ", ".join(["'"+p+"'" for p in attribs])
        for k,v in kwargs.items():
            if k in used_attribs:
                raise KeyError(f"argument '{k}' has already been specified as positional argument.")
            elif k not in attribs:
                raise KeyError(f"'{k}' is no valid property name. Valid names: {valid_names}")
            setattr(self,k,v)
    def get_x(self, i):
        """Get value ``x`` of ``(<chip.int1*>self._ptr)[i]``.
        """
        return (<chip.int1*>self._ptr)[i].x
    def set_x(self, i, int value):
        """Set value ``x`` of ``(<chip.int1*>self._ptr)[i]``.
        """
        (<chip.int1*>self._ptr)[i].x = value
    @property
    def x(self):
        """(undocumented)"""
        return self.get_x(0)
    @x.setter
    def x(self, int value):
        self.set_x(0,value)

    @staticmethod
    def PROPERTIES():
        return ["x"]

    def __contains__(self,item):
        properties = self.PROPERTIES()
        return item in properties

    def __getitem__(self,item):
        properties = self.PROPERTIES()
        if isinstance(item,int):
            if item < 0 or item >= len(properties):
                raise IndexError()
            return getattr(self,properties[item])
        raise ValueError("'item' type must be 'int'")


cdef class int2(hip._util.types.Pointer):
    """Python wrapper for cdef class chip.int2.

    Python wrapper for cdef class chip.int2.

    If this type is initialized via its `__init__` method, it allocates a
    member of the underlying C type and destroys it again if the wrapper
    type is deallocated.

    This type also serves as adapter when appearing as argument type in a
    function signature. In this case, the type can further be initialized
    from a number of Python objects:

    * `None`:

      This will set the ``self._ptr`` attribute to ``NULL``.

    * `int`:

      Interprets the integer value as pointer address and writes it to ``self._ptr``.
      No ownership is transferred.

    * `ctypes.c_void_p`:

      Takes the pointer address ``pyobj.value`` and writes it to ``self._ptr``.
      No ownership is transferred.

    * `object` that implements the `CUDA Array Interface <https://numba.readthedocs.io/en/stable/cuda/cuda_array_interface.html>`_ protocol:

      Takes the integer-valued pointer address, i.e. the first entry of the `data` tuple
      from `pyobj`'s member ``__cuda_array_interface__``  and writes it to ``self._ptr``.

    * `object` that implements the Python buffer protocol:

      If the object represents a simple contiguous array,
      writes the `Py_buffer` associated with ``pyobj`` to `self._py_buffer`,
      sets the `self._py_buffer_acquired` flag to `True`, and
      writes `self._py_buffer.buf` to the data pointer `self._ptr`.

    * `hip._util.types.Pointer`:

      Takes the pointer address ``pyobj._ptr`` and writes it to ``self._ptr``.
      No ownership is transferred.

    Type checks are performed in the above order.

    C Attributes:
        _ptr (C type ``void *``, protected):
            Stores a pointer to the data of the original Python object.
        _is_ptr_owner (C type ``bint``, protected):
            If this wrapper is the owner of the underlying data.
        _py_buffer (C type ``Py_buffer`, protected):
            Stores a pointer to the data of the original Python object.
        _py_buffer_acquired (C type ``bint``, protected):
            Stores a pointer to the data of the original Python object.
    """
    # C members declared in pxd file

    def __cinit__(self):
        self._ptr = NULL
        self._is_ptr_owner = False
        self._py_buffer_acquired = False

    cdef chip.int2* getElementPtr(self):
        return <chip.int2*>self._ptr

    @staticmethod
    cdef int2 fromPtr(void* ptr, bint owner=False):
        """Factory function to create ``int2`` objects from
        given ``chip.int2`` pointer.

        Setting ``owner`` flag to ``True`` causes
        the extension type to free the structure pointed to by ``ptr``
        when the wrapper object is deallocated.
        """
        # Fast call to __new__() that bypasses the __init__() constructor.
        cdef int2 wrapper = int2.__new__(int2)
        wrapper._ptr = ptr
        wrapper._is_ptr_owner = owner
        return wrapper

    @staticmethod
    def fromObj(pyobj):
        """Creates a int2 from a Python object.

        Derives a int2 from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``int2`` reference, this method
        returns it directly. No new ``int2`` is created in this case.
        """
        return int2.fromPyobj(pyobj)

    @staticmethod
    cdef int2 fromPyobj(object pyobj):
        """Creates a int2 from a Python object.

        Derives a int2 from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``int2`` reference, this method
        returns it directly. No new ``int2`` is created in this case.

        Args:
            pyobj (object): Must be either `None`; a `hip._util.types.Pointer`; a simple, contiguous buffer according to the buffer protocol;
                            or of type `int2`; `int`; or `ctypes.c_void_p`.

        Note:
            This routine does not perform a copy but returns the original ``pyobj``
            if ``pyobj`` is an instance of int2!
        """
        cdef int2 wrapper

        if isinstance(pyobj,int2):
            return pyobj
        else:
            wrapper = int2.__new__(int2)
            wrapper.init_from_pyobj(pyobj)
            return wrapper

    def __dealloc__(self):
        # Release the buffer handle
        if self._py_buffer_acquired is True:
            cpython.buffer.PyBuffer_Release(&self._py_buffer)
        # De-allocate if not null and flag is set
        if self._ptr is not NULL and self._is_ptr_owner is True:
            stdlib.free(self._ptr)
            self._ptr = NULL

    @staticmethod
    cdef __allocate(void** ptr):
        ptr[0] = stdlib.malloc(sizeof(chip.int2))
        string.memset(<void*>ptr[0], 0, sizeof(chip.int2))

        if ptr[0] is NULL:
            raise MemoryError

    @staticmethod
    cdef int2 new():
        """Factory function to create int2 objects with
        newly allocated chip.int2"""
        cdef void* ptr
        int2.__allocate(&ptr)
        return int2.fromPtr(ptr, owner=True)

    @staticmethod
    cdef int2 fromValue(chip.int2 other):
        """Allocate new C type and copy from ``other``.
        """
        wrapper = int2.new()
        string.memcpy(wrapper._ptr, &other, sizeof(chip.int2))
        return wrapper

    def c_sizeof(self):
        """Returns the size of the underlying C type in bytes.
        Note:
            Implemented as function to not collide with
            autogenerated property names.
        """
        return sizeof(chip.int2)

    def __int__(self):
        """Returns the data's address as long integer.
        """
        return cpython.long.PyLong_FromVoidPtr(self._ptr)

    def __repr__(self):
        return f"<int2 object, ptr: {int(self)}>"

    def as_c_void_p(self):
        """Returns the data's address as `ctypes.c_void_p`
        Note:
            Implemented as function to not collide with
            autogenerated property names.
        """
        return ctypes.c_void_p(int(self))

    def __init__(self,*args,**kwargs):
        """Constructor type int2.

        Constructor for type int2.

        Args:
            *args:
                Positional arguments. Initialize all or a subset of the member variables
                according to their order of declaration.
            **kwargs:
                Can be used to initialize member variables at construction,
                Just pass an argument expression of the form <member>=<value>
                per member that you want to initialize.
        """
        int2.__allocate(&self._ptr)
        self._is_ptr_owner = True
        attribs = self.PROPERTIES()
        used_attribs = set()
        if len(args) > len(attribs):
            raise ValueError("More positional arguments specified than this type has properties.")
        for i,v in enumerate(args):
            setattr(self,attribs[i],v)
            used_attribs.add(attribs[i])
        valid_names = ", ".join(["'"+p+"'" for p in attribs])
        for k,v in kwargs.items():
            if k in used_attribs:
                raise KeyError(f"argument '{k}' has already been specified as positional argument.")
            elif k not in attribs:
                raise KeyError(f"'{k}' is no valid property name. Valid names: {valid_names}")
            setattr(self,k,v)
    def get_x(self, i):
        """Get value ``x`` of ``(<chip.int2*>self._ptr)[i]``.
        """
        return (<chip.int2*>self._ptr)[i].x
    def set_x(self, i, int value):
        """Set value ``x`` of ``(<chip.int2*>self._ptr)[i]``.
        """
        (<chip.int2*>self._ptr)[i].x = value
    @property
    def x(self):
        """(undocumented)"""
        return self.get_x(0)
    @x.setter
    def x(self, int value):
        self.set_x(0,value)

    def get_y(self, i):
        """Get value ``y`` of ``(<chip.int2*>self._ptr)[i]``.
        """
        return (<chip.int2*>self._ptr)[i].y
    def set_y(self, i, int value):
        """Set value ``y`` of ``(<chip.int2*>self._ptr)[i]``.
        """
        (<chip.int2*>self._ptr)[i].y = value
    @property
    def y(self):
        """(undocumented)"""
        return self.get_y(0)
    @y.setter
    def y(self, int value):
        self.set_y(0,value)

    @staticmethod
    def PROPERTIES():
        return ["x","y"]

    def __contains__(self,item):
        properties = self.PROPERTIES()
        return item in properties

    def __getitem__(self,item):
        properties = self.PROPERTIES()
        if isinstance(item,int):
            if item < 0 or item >= len(properties):
                raise IndexError()
            return getattr(self,properties[item])
        raise ValueError("'item' type must be 'int'")


cdef class int3(hip._util.types.Pointer):
    """Python wrapper for cdef class chip.int3.

    Python wrapper for cdef class chip.int3.

    If this type is initialized via its `__init__` method, it allocates a
    member of the underlying C type and destroys it again if the wrapper
    type is deallocated.

    This type also serves as adapter when appearing as argument type in a
    function signature. In this case, the type can further be initialized
    from a number of Python objects:

    * `None`:

      This will set the ``self._ptr`` attribute to ``NULL``.

    * `int`:

      Interprets the integer value as pointer address and writes it to ``self._ptr``.
      No ownership is transferred.

    * `ctypes.c_void_p`:

      Takes the pointer address ``pyobj.value`` and writes it to ``self._ptr``.
      No ownership is transferred.

    * `object` that implements the `CUDA Array Interface <https://numba.readthedocs.io/en/stable/cuda/cuda_array_interface.html>`_ protocol:

      Takes the integer-valued pointer address, i.e. the first entry of the `data` tuple
      from `pyobj`'s member ``__cuda_array_interface__``  and writes it to ``self._ptr``.

    * `object` that implements the Python buffer protocol:

      If the object represents a simple contiguous array,
      writes the `Py_buffer` associated with ``pyobj`` to `self._py_buffer`,
      sets the `self._py_buffer_acquired` flag to `True`, and
      writes `self._py_buffer.buf` to the data pointer `self._ptr`.

    * `hip._util.types.Pointer`:

      Takes the pointer address ``pyobj._ptr`` and writes it to ``self._ptr``.
      No ownership is transferred.

    Type checks are performed in the above order.

    C Attributes:
        _ptr (C type ``void *``, protected):
            Stores a pointer to the data of the original Python object.
        _is_ptr_owner (C type ``bint``, protected):
            If this wrapper is the owner of the underlying data.
        _py_buffer (C type ``Py_buffer`, protected):
            Stores a pointer to the data of the original Python object.
        _py_buffer_acquired (C type ``bint``, protected):
            Stores a pointer to the data of the original Python object.
    """
    # C members declared in pxd file

    def __cinit__(self):
        self._ptr = NULL
        self._is_ptr_owner = False
        self._py_buffer_acquired = False

    cdef chip.int3* getElementPtr(self):
        return <chip.int3*>self._ptr

    @staticmethod
    cdef int3 fromPtr(void* ptr, bint owner=False):
        """Factory function to create ``int3`` objects from
        given ``chip.int3`` pointer.

        Setting ``owner`` flag to ``True`` causes
        the extension type to free the structure pointed to by ``ptr``
        when the wrapper object is deallocated.
        """
        # Fast call to __new__() that bypasses the __init__() constructor.
        cdef int3 wrapper = int3.__new__(int3)
        wrapper._ptr = ptr
        wrapper._is_ptr_owner = owner
        return wrapper

    @staticmethod
    def fromObj(pyobj):
        """Creates a int3 from a Python object.

        Derives a int3 from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``int3`` reference, this method
        returns it directly. No new ``int3`` is created in this case.
        """
        return int3.fromPyobj(pyobj)

    @staticmethod
    cdef int3 fromPyobj(object pyobj):
        """Creates a int3 from a Python object.

        Derives a int3 from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``int3`` reference, this method
        returns it directly. No new ``int3`` is created in this case.

        Args:
            pyobj (object): Must be either `None`; a `hip._util.types.Pointer`; a simple, contiguous buffer according to the buffer protocol;
                            or of type `int3`; `int`; or `ctypes.c_void_p`.

        Note:
            This routine does not perform a copy but returns the original ``pyobj``
            if ``pyobj`` is an instance of int3!
        """
        cdef int3 wrapper

        if isinstance(pyobj,int3):
            return pyobj
        else:
            wrapper = int3.__new__(int3)
            wrapper.init_from_pyobj(pyobj)
            return wrapper

    def __dealloc__(self):
        # Release the buffer handle
        if self._py_buffer_acquired is True:
            cpython.buffer.PyBuffer_Release(&self._py_buffer)
        # De-allocate if not null and flag is set
        if self._ptr is not NULL and self._is_ptr_owner is True:
            stdlib.free(self._ptr)
            self._ptr = NULL

    @staticmethod
    cdef __allocate(void** ptr):
        ptr[0] = stdlib.malloc(sizeof(chip.int3))
        string.memset(<void*>ptr[0], 0, sizeof(chip.int3))

        if ptr[0] is NULL:
            raise MemoryError

    @staticmethod
    cdef int3 new():
        """Factory function to create int3 objects with
        newly allocated chip.int3"""
        cdef void* ptr
        int3.__allocate(&ptr)
        return int3.fromPtr(ptr, owner=True)

    @staticmethod
    cdef int3 fromValue(chip.int3 other):
        """Allocate new C type and copy from ``other``.
        """
        wrapper = int3.new()
        string.memcpy(wrapper._ptr, &other, sizeof(chip.int3))
        return wrapper

    def c_sizeof(self):
        """Returns the size of the underlying C type in bytes.
        Note:
            Implemented as function to not collide with
            autogenerated property names.
        """
        return sizeof(chip.int3)

    def __int__(self):
        """Returns the data's address as long integer.
        """
        return cpython.long.PyLong_FromVoidPtr(self._ptr)

    def __repr__(self):
        return f"<int3 object, ptr: {int(self)}>"

    def as_c_void_p(self):
        """Returns the data's address as `ctypes.c_void_p`
        Note:
            Implemented as function to not collide with
            autogenerated property names.
        """
        return ctypes.c_void_p(int(self))

    def __init__(self,*args,**kwargs):
        """Constructor type int3.

        Constructor for type int3.

        Args:
            *args:
                Positional arguments. Initialize all or a subset of the member variables
                according to their order of declaration.
            **kwargs:
                Can be used to initialize member variables at construction,
                Just pass an argument expression of the form <member>=<value>
                per member that you want to initialize.
        """
        int3.__allocate(&self._ptr)
        self._is_ptr_owner = True
        attribs = self.PROPERTIES()
        used_attribs = set()
        if len(args) > len(attribs):
            raise ValueError("More positional arguments specified than this type has properties.")
        for i,v in enumerate(args):
            setattr(self,attribs[i],v)
            used_attribs.add(attribs[i])
        valid_names = ", ".join(["'"+p+"'" for p in attribs])
        for k,v in kwargs.items():
            if k in used_attribs:
                raise KeyError(f"argument '{k}' has already been specified as positional argument.")
            elif k not in attribs:
                raise KeyError(f"'{k}' is no valid property name. Valid names: {valid_names}")
            setattr(self,k,v)
    def get_x(self, i):
        """Get value ``x`` of ``(<chip.int3*>self._ptr)[i]``.
        """
        return (<chip.int3*>self._ptr)[i].x
    def set_x(self, i, int value):
        """Set value ``x`` of ``(<chip.int3*>self._ptr)[i]``.
        """
        (<chip.int3*>self._ptr)[i].x = value
    @property
    def x(self):
        """(undocumented)"""
        return self.get_x(0)
    @x.setter
    def x(self, int value):
        self.set_x(0,value)

    def get_y(self, i):
        """Get value ``y`` of ``(<chip.int3*>self._ptr)[i]``.
        """
        return (<chip.int3*>self._ptr)[i].y
    def set_y(self, i, int value):
        """Set value ``y`` of ``(<chip.int3*>self._ptr)[i]``.
        """
        (<chip.int3*>self._ptr)[i].y = value
    @property
    def y(self):
        """(undocumented)"""
        return self.get_y(0)
    @y.setter
    def y(self, int value):
        self.set_y(0,value)

    def get_z(self, i):
        """Get value ``z`` of ``(<chip.int3*>self._ptr)[i]``.
        """
        return (<chip.int3*>self._ptr)[i].z
    def set_z(self, i, int value):
        """Set value ``z`` of ``(<chip.int3*>self._ptr)[i]``.
        """
        (<chip.int3*>self._ptr)[i].z = value
    @property
    def z(self):
        """(undocumented)"""
        return self.get_z(0)
    @z.setter
    def z(self, int value):
        self.set_z(0,value)

    @staticmethod
    def PROPERTIES():
        return ["x","y","z"]

    def __contains__(self,item):
        properties = self.PROPERTIES()
        return item in properties

    def __getitem__(self,item):
        properties = self.PROPERTIES()
        if isinstance(item,int):
            if item < 0 or item >= len(properties):
                raise IndexError()
            return getattr(self,properties[item])
        raise ValueError("'item' type must be 'int'")


cdef class int4(hip._util.types.Pointer):
    """Python wrapper for cdef class chip.int4.

    Python wrapper for cdef class chip.int4.

    If this type is initialized via its `__init__` method, it allocates a
    member of the underlying C type and destroys it again if the wrapper
    type is deallocated.

    This type also serves as adapter when appearing as argument type in a
    function signature. In this case, the type can further be initialized
    from a number of Python objects:

    * `None`:

      This will set the ``self._ptr`` attribute to ``NULL``.

    * `int`:

      Interprets the integer value as pointer address and writes it to ``self._ptr``.
      No ownership is transferred.

    * `ctypes.c_void_p`:

      Takes the pointer address ``pyobj.value`` and writes it to ``self._ptr``.
      No ownership is transferred.

    * `object` that implements the `CUDA Array Interface <https://numba.readthedocs.io/en/stable/cuda/cuda_array_interface.html>`_ protocol:

      Takes the integer-valued pointer address, i.e. the first entry of the `data` tuple
      from `pyobj`'s member ``__cuda_array_interface__``  and writes it to ``self._ptr``.

    * `object` that implements the Python buffer protocol:

      If the object represents a simple contiguous array,
      writes the `Py_buffer` associated with ``pyobj`` to `self._py_buffer`,
      sets the `self._py_buffer_acquired` flag to `True`, and
      writes `self._py_buffer.buf` to the data pointer `self._ptr`.

    * `hip._util.types.Pointer`:

      Takes the pointer address ``pyobj._ptr`` and writes it to ``self._ptr``.
      No ownership is transferred.

    Type checks are performed in the above order.

    C Attributes:
        _ptr (C type ``void *``, protected):
            Stores a pointer to the data of the original Python object.
        _is_ptr_owner (C type ``bint``, protected):
            If this wrapper is the owner of the underlying data.
        _py_buffer (C type ``Py_buffer`, protected):
            Stores a pointer to the data of the original Python object.
        _py_buffer_acquired (C type ``bint``, protected):
            Stores a pointer to the data of the original Python object.
    """
    # C members declared in pxd file

    def __cinit__(self):
        self._ptr = NULL
        self._is_ptr_owner = False
        self._py_buffer_acquired = False

    cdef chip.int4* getElementPtr(self):
        return <chip.int4*>self._ptr

    @staticmethod
    cdef int4 fromPtr(void* ptr, bint owner=False):
        """Factory function to create ``int4`` objects from
        given ``chip.int4`` pointer.

        Setting ``owner`` flag to ``True`` causes
        the extension type to free the structure pointed to by ``ptr``
        when the wrapper object is deallocated.
        """
        # Fast call to __new__() that bypasses the __init__() constructor.
        cdef int4 wrapper = int4.__new__(int4)
        wrapper._ptr = ptr
        wrapper._is_ptr_owner = owner
        return wrapper

    @staticmethod
    def fromObj(pyobj):
        """Creates a int4 from a Python object.

        Derives a int4 from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``int4`` reference, this method
        returns it directly. No new ``int4`` is created in this case.
        """
        return int4.fromPyobj(pyobj)

    @staticmethod
    cdef int4 fromPyobj(object pyobj):
        """Creates a int4 from a Python object.

        Derives a int4 from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``int4`` reference, this method
        returns it directly. No new ``int4`` is created in this case.

        Args:
            pyobj (object): Must be either `None`; a `hip._util.types.Pointer`; a simple, contiguous buffer according to the buffer protocol;
                            or of type `int4`; `int`; or `ctypes.c_void_p`.

        Note:
            This routine does not perform a copy but returns the original ``pyobj``
            if ``pyobj`` is an instance of int4!
        """
        cdef int4 wrapper

        if isinstance(pyobj,int4):
            return pyobj
        else:
            wrapper = int4.__new__(int4)
            wrapper.init_from_pyobj(pyobj)
            return wrapper

    def __dealloc__(self):
        # Release the buffer handle
        if self._py_buffer_acquired is True:
            cpython.buffer.PyBuffer_Release(&self._py_buffer)
        # De-allocate if not null and flag is set
        if self._ptr is not NULL and self._is_ptr_owner is True:
            stdlib.free(self._ptr)
            self._ptr = NULL

    @staticmethod
    cdef __allocate(void** ptr):
        ptr[0] = stdlib.malloc(sizeof(chip.int4))
        string.memset(<void*>ptr[0], 0, sizeof(chip.int4))

        if ptr[0] is NULL:
            raise MemoryError

    @staticmethod
    cdef int4 new():
        """Factory function to create int4 objects with
        newly allocated chip.int4"""
        cdef void* ptr
        int4.__allocate(&ptr)
        return int4.fromPtr(ptr, owner=True)

    @staticmethod
    cdef int4 fromValue(chip.int4 other):
        """Allocate new C type and copy from ``other``.
        """
        wrapper = int4.new()
        string.memcpy(wrapper._ptr, &other, sizeof(chip.int4))
        return wrapper

    def c_sizeof(self):
        """Returns the size of the underlying C type in bytes.
        Note:
            Implemented as function to not collide with
            autogenerated property names.
        """
        return sizeof(chip.int4)

    def __int__(self):
        """Returns the data's address as long integer.
        """
        return cpython.long.PyLong_FromVoidPtr(self._ptr)

    def __repr__(self):
        return f"<int4 object, ptr: {int(self)}>"

    def as_c_void_p(self):
        """Returns the data's address as `ctypes.c_void_p`
        Note:
            Implemented as function to not collide with
            autogenerated property names.
        """
        return ctypes.c_void_p(int(self))

    def __init__(self,*args,**kwargs):
        """Constructor type int4.

        Constructor for type int4.

        Args:
            *args:
                Positional arguments. Initialize all or a subset of the member variables
                according to their order of declaration.
            **kwargs:
                Can be used to initialize member variables at construction,
                Just pass an argument expression of the form <member>=<value>
                per member that you want to initialize.
        """
        int4.__allocate(&self._ptr)
        self._is_ptr_owner = True
        attribs = self.PROPERTIES()
        used_attribs = set()
        if len(args) > len(attribs):
            raise ValueError("More positional arguments specified than this type has properties.")
        for i,v in enumerate(args):
            setattr(self,attribs[i],v)
            used_attribs.add(attribs[i])
        valid_names = ", ".join(["'"+p+"'" for p in attribs])
        for k,v in kwargs.items():
            if k in used_attribs:
                raise KeyError(f"argument '{k}' has already been specified as positional argument.")
            elif k not in attribs:
                raise KeyError(f"'{k}' is no valid property name. Valid names: {valid_names}")
            setattr(self,k,v)
    def get_x(self, i):
        """Get value ``x`` of ``(<chip.int4*>self._ptr)[i]``.
        """
        return (<chip.int4*>self._ptr)[i].x
    def set_x(self, i, int value):
        """Set value ``x`` of ``(<chip.int4*>self._ptr)[i]``.
        """
        (<chip.int4*>self._ptr)[i].x = value
    @property
    def x(self):
        """(undocumented)"""
        return self.get_x(0)
    @x.setter
    def x(self, int value):
        self.set_x(0,value)

    def get_y(self, i):
        """Get value ``y`` of ``(<chip.int4*>self._ptr)[i]``.
        """
        return (<chip.int4*>self._ptr)[i].y
    def set_y(self, i, int value):
        """Set value ``y`` of ``(<chip.int4*>self._ptr)[i]``.
        """
        (<chip.int4*>self._ptr)[i].y = value
    @property
    def y(self):
        """(undocumented)"""
        return self.get_y(0)
    @y.setter
    def y(self, int value):
        self.set_y(0,value)

    def get_z(self, i):
        """Get value ``z`` of ``(<chip.int4*>self._ptr)[i]``.
        """
        return (<chip.int4*>self._ptr)[i].z
    def set_z(self, i, int value):
        """Set value ``z`` of ``(<chip.int4*>self._ptr)[i]``.
        """
        (<chip.int4*>self._ptr)[i].z = value
    @property
    def z(self):
        """(undocumented)"""
        return self.get_z(0)
    @z.setter
    def z(self, int value):
        self.set_z(0,value)

    def get_w(self, i):
        """Get value ``w`` of ``(<chip.int4*>self._ptr)[i]``.
        """
        return (<chip.int4*>self._ptr)[i].w
    def set_w(self, i, int value):
        """Set value ``w`` of ``(<chip.int4*>self._ptr)[i]``.
        """
        (<chip.int4*>self._ptr)[i].w = value
    @property
    def w(self):
        """(undocumented)"""
        return self.get_w(0)
    @w.setter
    def w(self, int value):
        self.set_w(0,value)

    @staticmethod
    def PROPERTIES():
        return ["x","y","z","w"]

    def __contains__(self,item):
        properties = self.PROPERTIES()
        return item in properties

    def __getitem__(self,item):
        properties = self.PROPERTIES()
        if isinstance(item,int):
            if item < 0 or item >= len(properties):
                raise IndexError()
            return getattr(self,properties[item])
        raise ValueError("'item' type must be 'int'")


cdef class ulong1(hip._util.types.Pointer):
    """Python wrapper for cdef class chip.ulong1.

    Python wrapper for cdef class chip.ulong1.

    If this type is initialized via its `__init__` method, it allocates a
    member of the underlying C type and destroys it again if the wrapper
    type is deallocated.

    This type also serves as adapter when appearing as argument type in a
    function signature. In this case, the type can further be initialized
    from a number of Python objects:

    * `None`:

      This will set the ``self._ptr`` attribute to ``NULL``.

    * `int`:

      Interprets the integer value as pointer address and writes it to ``self._ptr``.
      No ownership is transferred.

    * `ctypes.c_void_p`:

      Takes the pointer address ``pyobj.value`` and writes it to ``self._ptr``.
      No ownership is transferred.

    * `object` that implements the `CUDA Array Interface <https://numba.readthedocs.io/en/stable/cuda/cuda_array_interface.html>`_ protocol:

      Takes the integer-valued pointer address, i.e. the first entry of the `data` tuple
      from `pyobj`'s member ``__cuda_array_interface__``  and writes it to ``self._ptr``.

    * `object` that implements the Python buffer protocol:

      If the object represents a simple contiguous array,
      writes the `Py_buffer` associated with ``pyobj`` to `self._py_buffer`,
      sets the `self._py_buffer_acquired` flag to `True`, and
      writes `self._py_buffer.buf` to the data pointer `self._ptr`.

    * `hip._util.types.Pointer`:

      Takes the pointer address ``pyobj._ptr`` and writes it to ``self._ptr``.
      No ownership is transferred.

    Type checks are performed in the above order.

    C Attributes:
        _ptr (C type ``void *``, protected):
            Stores a pointer to the data of the original Python object.
        _is_ptr_owner (C type ``bint``, protected):
            If this wrapper is the owner of the underlying data.
        _py_buffer (C type ``Py_buffer`, protected):
            Stores a pointer to the data of the original Python object.
        _py_buffer_acquired (C type ``bint``, protected):
            Stores a pointer to the data of the original Python object.
    """
    # C members declared in pxd file

    def __cinit__(self):
        self._ptr = NULL
        self._is_ptr_owner = False
        self._py_buffer_acquired = False

    cdef chip.ulong1* getElementPtr(self):
        return <chip.ulong1*>self._ptr

    @staticmethod
    cdef ulong1 fromPtr(void* ptr, bint owner=False):
        """Factory function to create ``ulong1`` objects from
        given ``chip.ulong1`` pointer.

        Setting ``owner`` flag to ``True`` causes
        the extension type to free the structure pointed to by ``ptr``
        when the wrapper object is deallocated.
        """
        # Fast call to __new__() that bypasses the __init__() constructor.
        cdef ulong1 wrapper = ulong1.__new__(ulong1)
        wrapper._ptr = ptr
        wrapper._is_ptr_owner = owner
        return wrapper

    @staticmethod
    def fromObj(pyobj):
        """Creates a ulong1 from a Python object.

        Derives a ulong1 from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``ulong1`` reference, this method
        returns it directly. No new ``ulong1`` is created in this case.
        """
        return ulong1.fromPyobj(pyobj)

    @staticmethod
    cdef ulong1 fromPyobj(object pyobj):
        """Creates a ulong1 from a Python object.

        Derives a ulong1 from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``ulong1`` reference, this method
        returns it directly. No new ``ulong1`` is created in this case.

        Args:
            pyobj (object): Must be either `None`; a `hip._util.types.Pointer`; a simple, contiguous buffer according to the buffer protocol;
                            or of type `ulong1`; `int`; or `ctypes.c_void_p`.

        Note:
            This routine does not perform a copy but returns the original ``pyobj``
            if ``pyobj`` is an instance of ulong1!
        """
        cdef ulong1 wrapper

        if isinstance(pyobj,ulong1):
            return pyobj
        else:
            wrapper = ulong1.__new__(ulong1)
            wrapper.init_from_pyobj(pyobj)
            return wrapper

    def __dealloc__(self):
        # Release the buffer handle
        if self._py_buffer_acquired is True:
            cpython.buffer.PyBuffer_Release(&self._py_buffer)
        # De-allocate if not null and flag is set
        if self._ptr is not NULL and self._is_ptr_owner is True:
            stdlib.free(self._ptr)
            self._ptr = NULL

    @staticmethod
    cdef __allocate(void** ptr):
        ptr[0] = stdlib.malloc(sizeof(chip.ulong1))
        string.memset(<void*>ptr[0], 0, sizeof(chip.ulong1))

        if ptr[0] is NULL:
            raise MemoryError

    @staticmethod
    cdef ulong1 new():
        """Factory function to create ulong1 objects with
        newly allocated chip.ulong1"""
        cdef void* ptr
        ulong1.__allocate(&ptr)
        return ulong1.fromPtr(ptr, owner=True)

    @staticmethod
    cdef ulong1 fromValue(chip.ulong1 other):
        """Allocate new C type and copy from ``other``.
        """
        wrapper = ulong1.new()
        string.memcpy(wrapper._ptr, &other, sizeof(chip.ulong1))
        return wrapper

    def c_sizeof(self):
        """Returns the size of the underlying C type in bytes.
        Note:
            Implemented as function to not collide with
            autogenerated property names.
        """
        return sizeof(chip.ulong1)

    def __int__(self):
        """Returns the data's address as long integer.
        """
        return cpython.long.PyLong_FromVoidPtr(self._ptr)

    def __repr__(self):
        return f"<ulong1 object, ptr: {int(self)}>"

    def as_c_void_p(self):
        """Returns the data's address as `ctypes.c_void_p`
        Note:
            Implemented as function to not collide with
            autogenerated property names.
        """
        return ctypes.c_void_p(int(self))

    def __init__(self,*args,**kwargs):
        """Constructor type ulong1.

        Constructor for type ulong1.

        Args:
            *args:
                Positional arguments. Initialize all or a subset of the member variables
                according to their order of declaration.
            **kwargs:
                Can be used to initialize member variables at construction,
                Just pass an argument expression of the form <member>=<value>
                per member that you want to initialize.
        """
        ulong1.__allocate(&self._ptr)
        self._is_ptr_owner = True
        attribs = self.PROPERTIES()
        used_attribs = set()
        if len(args) > len(attribs):
            raise ValueError("More positional arguments specified than this type has properties.")
        for i,v in enumerate(args):
            setattr(self,attribs[i],v)
            used_attribs.add(attribs[i])
        valid_names = ", ".join(["'"+p+"'" for p in attribs])
        for k,v in kwargs.items():
            if k in used_attribs:
                raise KeyError(f"argument '{k}' has already been specified as positional argument.")
            elif k not in attribs:
                raise KeyError(f"'{k}' is no valid property name. Valid names: {valid_names}")
            setattr(self,k,v)
    def get_x(self, i):
        """Get value ``x`` of ``(<chip.ulong1*>self._ptr)[i]``.
        """
        return (<chip.ulong1*>self._ptr)[i].x
    def set_x(self, i, unsigned long value):
        """Set value ``x`` of ``(<chip.ulong1*>self._ptr)[i]``.
        """
        (<chip.ulong1*>self._ptr)[i].x = value
    @property
    def x(self):
        """(undocumented)"""
        return self.get_x(0)
    @x.setter
    def x(self, unsigned long value):
        self.set_x(0,value)

    @staticmethod
    def PROPERTIES():
        return ["x"]

    def __contains__(self,item):
        properties = self.PROPERTIES()
        return item in properties

    def __getitem__(self,item):
        properties = self.PROPERTIES()
        if isinstance(item,int):
            if item < 0 or item >= len(properties):
                raise IndexError()
            return getattr(self,properties[item])
        raise ValueError("'item' type must be 'int'")


cdef class ulong2(hip._util.types.Pointer):
    """Python wrapper for cdef class chip.ulong2.

    Python wrapper for cdef class chip.ulong2.

    If this type is initialized via its `__init__` method, it allocates a
    member of the underlying C type and destroys it again if the wrapper
    type is deallocated.

    This type also serves as adapter when appearing as argument type in a
    function signature. In this case, the type can further be initialized
    from a number of Python objects:

    * `None`:

      This will set the ``self._ptr`` attribute to ``NULL``.

    * `int`:

      Interprets the integer value as pointer address and writes it to ``self._ptr``.
      No ownership is transferred.

    * `ctypes.c_void_p`:

      Takes the pointer address ``pyobj.value`` and writes it to ``self._ptr``.
      No ownership is transferred.

    * `object` that implements the `CUDA Array Interface <https://numba.readthedocs.io/en/stable/cuda/cuda_array_interface.html>`_ protocol:

      Takes the integer-valued pointer address, i.e. the first entry of the `data` tuple
      from `pyobj`'s member ``__cuda_array_interface__``  and writes it to ``self._ptr``.

    * `object` that implements the Python buffer protocol:

      If the object represents a simple contiguous array,
      writes the `Py_buffer` associated with ``pyobj`` to `self._py_buffer`,
      sets the `self._py_buffer_acquired` flag to `True`, and
      writes `self._py_buffer.buf` to the data pointer `self._ptr`.

    * `hip._util.types.Pointer`:

      Takes the pointer address ``pyobj._ptr`` and writes it to ``self._ptr``.
      No ownership is transferred.

    Type checks are performed in the above order.

    C Attributes:
        _ptr (C type ``void *``, protected):
            Stores a pointer to the data of the original Python object.
        _is_ptr_owner (C type ``bint``, protected):
            If this wrapper is the owner of the underlying data.
        _py_buffer (C type ``Py_buffer`, protected):
            Stores a pointer to the data of the original Python object.
        _py_buffer_acquired (C type ``bint``, protected):
            Stores a pointer to the data of the original Python object.
    """
    # C members declared in pxd file

    def __cinit__(self):
        self._ptr = NULL
        self._is_ptr_owner = False
        self._py_buffer_acquired = False

    cdef chip.ulong2* getElementPtr(self):
        return <chip.ulong2*>self._ptr

    @staticmethod
    cdef ulong2 fromPtr(void* ptr, bint owner=False):
        """Factory function to create ``ulong2`` objects from
        given ``chip.ulong2`` pointer.

        Setting ``owner`` flag to ``True`` causes
        the extension type to free the structure pointed to by ``ptr``
        when the wrapper object is deallocated.
        """
        # Fast call to __new__() that bypasses the __init__() constructor.
        cdef ulong2 wrapper = ulong2.__new__(ulong2)
        wrapper._ptr = ptr
        wrapper._is_ptr_owner = owner
        return wrapper

    @staticmethod
    def fromObj(pyobj):
        """Creates a ulong2 from a Python object.

        Derives a ulong2 from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``ulong2`` reference, this method
        returns it directly. No new ``ulong2`` is created in this case.
        """
        return ulong2.fromPyobj(pyobj)

    @staticmethod
    cdef ulong2 fromPyobj(object pyobj):
        """Creates a ulong2 from a Python object.

        Derives a ulong2 from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``ulong2`` reference, this method
        returns it directly. No new ``ulong2`` is created in this case.

        Args:
            pyobj (object): Must be either `None`; a `hip._util.types.Pointer`; a simple, contiguous buffer according to the buffer protocol;
                            or of type `ulong2`; `int`; or `ctypes.c_void_p`.

        Note:
            This routine does not perform a copy but returns the original ``pyobj``
            if ``pyobj`` is an instance of ulong2!
        """
        cdef ulong2 wrapper

        if isinstance(pyobj,ulong2):
            return pyobj
        else:
            wrapper = ulong2.__new__(ulong2)
            wrapper.init_from_pyobj(pyobj)
            return wrapper

    def __dealloc__(self):
        # Release the buffer handle
        if self._py_buffer_acquired is True:
            cpython.buffer.PyBuffer_Release(&self._py_buffer)
        # De-allocate if not null and flag is set
        if self._ptr is not NULL and self._is_ptr_owner is True:
            stdlib.free(self._ptr)
            self._ptr = NULL

    @staticmethod
    cdef __allocate(void** ptr):
        ptr[0] = stdlib.malloc(sizeof(chip.ulong2))
        string.memset(<void*>ptr[0], 0, sizeof(chip.ulong2))

        if ptr[0] is NULL:
            raise MemoryError

    @staticmethod
    cdef ulong2 new():
        """Factory function to create ulong2 objects with
        newly allocated chip.ulong2"""
        cdef void* ptr
        ulong2.__allocate(&ptr)
        return ulong2.fromPtr(ptr, owner=True)

    @staticmethod
    cdef ulong2 fromValue(chip.ulong2 other):
        """Allocate new C type and copy from ``other``.
        """
        wrapper = ulong2.new()
        string.memcpy(wrapper._ptr, &other, sizeof(chip.ulong2))
        return wrapper

    def c_sizeof(self):
        """Returns the size of the underlying C type in bytes.
        Note:
            Implemented as function to not collide with
            autogenerated property names.
        """
        return sizeof(chip.ulong2)

    def __int__(self):
        """Returns the data's address as long integer.
        """
        return cpython.long.PyLong_FromVoidPtr(self._ptr)

    def __repr__(self):
        return f"<ulong2 object, ptr: {int(self)}>"

    def as_c_void_p(self):
        """Returns the data's address as `ctypes.c_void_p`
        Note:
            Implemented as function to not collide with
            autogenerated property names.
        """
        return ctypes.c_void_p(int(self))

    def __init__(self,*args,**kwargs):
        """Constructor type ulong2.

        Constructor for type ulong2.

        Args:
            *args:
                Positional arguments. Initialize all or a subset of the member variables
                according to their order of declaration.
            **kwargs:
                Can be used to initialize member variables at construction,
                Just pass an argument expression of the form <member>=<value>
                per member that you want to initialize.
        """
        ulong2.__allocate(&self._ptr)
        self._is_ptr_owner = True
        attribs = self.PROPERTIES()
        used_attribs = set()
        if len(args) > len(attribs):
            raise ValueError("More positional arguments specified than this type has properties.")
        for i,v in enumerate(args):
            setattr(self,attribs[i],v)
            used_attribs.add(attribs[i])
        valid_names = ", ".join(["'"+p+"'" for p in attribs])
        for k,v in kwargs.items():
            if k in used_attribs:
                raise KeyError(f"argument '{k}' has already been specified as positional argument.")
            elif k not in attribs:
                raise KeyError(f"'{k}' is no valid property name. Valid names: {valid_names}")
            setattr(self,k,v)
    def get_x(self, i):
        """Get value ``x`` of ``(<chip.ulong2*>self._ptr)[i]``.
        """
        return (<chip.ulong2*>self._ptr)[i].x
    def set_x(self, i, unsigned long value):
        """Set value ``x`` of ``(<chip.ulong2*>self._ptr)[i]``.
        """
        (<chip.ulong2*>self._ptr)[i].x = value
    @property
    def x(self):
        """(undocumented)"""
        return self.get_x(0)
    @x.setter
    def x(self, unsigned long value):
        self.set_x(0,value)

    def get_y(self, i):
        """Get value ``y`` of ``(<chip.ulong2*>self._ptr)[i]``.
        """
        return (<chip.ulong2*>self._ptr)[i].y
    def set_y(self, i, unsigned long value):
        """Set value ``y`` of ``(<chip.ulong2*>self._ptr)[i]``.
        """
        (<chip.ulong2*>self._ptr)[i].y = value
    @property
    def y(self):
        """(undocumented)"""
        return self.get_y(0)
    @y.setter
    def y(self, unsigned long value):
        self.set_y(0,value)

    @staticmethod
    def PROPERTIES():
        return ["x","y"]

    def __contains__(self,item):
        properties = self.PROPERTIES()
        return item in properties

    def __getitem__(self,item):
        properties = self.PROPERTIES()
        if isinstance(item,int):
            if item < 0 or item >= len(properties):
                raise IndexError()
            return getattr(self,properties[item])
        raise ValueError("'item' type must be 'int'")


cdef class ulong3(hip._util.types.Pointer):
    """Python wrapper for cdef class chip.ulong3.

    Python wrapper for cdef class chip.ulong3.

    If this type is initialized via its `__init__` method, it allocates a
    member of the underlying C type and destroys it again if the wrapper
    type is deallocated.

    This type also serves as adapter when appearing as argument type in a
    function signature. In this case, the type can further be initialized
    from a number of Python objects:

    * `None`:

      This will set the ``self._ptr`` attribute to ``NULL``.

    * `int`:

      Interprets the integer value as pointer address and writes it to ``self._ptr``.
      No ownership is transferred.

    * `ctypes.c_void_p`:

      Takes the pointer address ``pyobj.value`` and writes it to ``self._ptr``.
      No ownership is transferred.

    * `object` that implements the `CUDA Array Interface <https://numba.readthedocs.io/en/stable/cuda/cuda_array_interface.html>`_ protocol:

      Takes the integer-valued pointer address, i.e. the first entry of the `data` tuple
      from `pyobj`'s member ``__cuda_array_interface__``  and writes it to ``self._ptr``.

    * `object` that implements the Python buffer protocol:

      If the object represents a simple contiguous array,
      writes the `Py_buffer` associated with ``pyobj`` to `self._py_buffer`,
      sets the `self._py_buffer_acquired` flag to `True`, and
      writes `self._py_buffer.buf` to the data pointer `self._ptr`.

    * `hip._util.types.Pointer`:

      Takes the pointer address ``pyobj._ptr`` and writes it to ``self._ptr``.
      No ownership is transferred.

    Type checks are performed in the above order.

    C Attributes:
        _ptr (C type ``void *``, protected):
            Stores a pointer to the data of the original Python object.
        _is_ptr_owner (C type ``bint``, protected):
            If this wrapper is the owner of the underlying data.
        _py_buffer (C type ``Py_buffer`, protected):
            Stores a pointer to the data of the original Python object.
        _py_buffer_acquired (C type ``bint``, protected):
            Stores a pointer to the data of the original Python object.
    """
    # C members declared in pxd file

    def __cinit__(self):
        self._ptr = NULL
        self._is_ptr_owner = False
        self._py_buffer_acquired = False

    cdef chip.ulong3* getElementPtr(self):
        return <chip.ulong3*>self._ptr

    @staticmethod
    cdef ulong3 fromPtr(void* ptr, bint owner=False):
        """Factory function to create ``ulong3`` objects from
        given ``chip.ulong3`` pointer.

        Setting ``owner`` flag to ``True`` causes
        the extension type to free the structure pointed to by ``ptr``
        when the wrapper object is deallocated.
        """
        # Fast call to __new__() that bypasses the __init__() constructor.
        cdef ulong3 wrapper = ulong3.__new__(ulong3)
        wrapper._ptr = ptr
        wrapper._is_ptr_owner = owner
        return wrapper

    @staticmethod
    def fromObj(pyobj):
        """Creates a ulong3 from a Python object.

        Derives a ulong3 from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``ulong3`` reference, this method
        returns it directly. No new ``ulong3`` is created in this case.
        """
        return ulong3.fromPyobj(pyobj)

    @staticmethod
    cdef ulong3 fromPyobj(object pyobj):
        """Creates a ulong3 from a Python object.

        Derives a ulong3 from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``ulong3`` reference, this method
        returns it directly. No new ``ulong3`` is created in this case.

        Args:
            pyobj (object): Must be either `None`; a `hip._util.types.Pointer`; a simple, contiguous buffer according to the buffer protocol;
                            or of type `ulong3`; `int`; or `ctypes.c_void_p`.

        Note:
            This routine does not perform a copy but returns the original ``pyobj``
            if ``pyobj`` is an instance of ulong3!
        """
        cdef ulong3 wrapper

        if isinstance(pyobj,ulong3):
            return pyobj
        else:
            wrapper = ulong3.__new__(ulong3)
            wrapper.init_from_pyobj(pyobj)
            return wrapper

    def __dealloc__(self):
        # Release the buffer handle
        if self._py_buffer_acquired is True:
            cpython.buffer.PyBuffer_Release(&self._py_buffer)
        # De-allocate if not null and flag is set
        if self._ptr is not NULL and self._is_ptr_owner is True:
            stdlib.free(self._ptr)
            self._ptr = NULL

    @staticmethod
    cdef __allocate(void** ptr):
        ptr[0] = stdlib.malloc(sizeof(chip.ulong3))
        string.memset(<void*>ptr[0], 0, sizeof(chip.ulong3))

        if ptr[0] is NULL:
            raise MemoryError

    @staticmethod
    cdef ulong3 new():
        """Factory function to create ulong3 objects with
        newly allocated chip.ulong3"""
        cdef void* ptr
        ulong3.__allocate(&ptr)
        return ulong3.fromPtr(ptr, owner=True)

    @staticmethod
    cdef ulong3 fromValue(chip.ulong3 other):
        """Allocate new C type and copy from ``other``.
        """
        wrapper = ulong3.new()
        string.memcpy(wrapper._ptr, &other, sizeof(chip.ulong3))
        return wrapper

    def c_sizeof(self):
        """Returns the size of the underlying C type in bytes.
        Note:
            Implemented as function to not collide with
            autogenerated property names.
        """
        return sizeof(chip.ulong3)

    def __int__(self):
        """Returns the data's address as long integer.
        """
        return cpython.long.PyLong_FromVoidPtr(self._ptr)

    def __repr__(self):
        return f"<ulong3 object, ptr: {int(self)}>"

    def as_c_void_p(self):
        """Returns the data's address as `ctypes.c_void_p`
        Note:
            Implemented as function to not collide with
            autogenerated property names.
        """
        return ctypes.c_void_p(int(self))

    def __init__(self,*args,**kwargs):
        """Constructor type ulong3.

        Constructor for type ulong3.

        Args:
            *args:
                Positional arguments. Initialize all or a subset of the member variables
                according to their order of declaration.
            **kwargs:
                Can be used to initialize member variables at construction,
                Just pass an argument expression of the form <member>=<value>
                per member that you want to initialize.
        """
        ulong3.__allocate(&self._ptr)
        self._is_ptr_owner = True
        attribs = self.PROPERTIES()
        used_attribs = set()
        if len(args) > len(attribs):
            raise ValueError("More positional arguments specified than this type has properties.")
        for i,v in enumerate(args):
            setattr(self,attribs[i],v)
            used_attribs.add(attribs[i])
        valid_names = ", ".join(["'"+p+"'" for p in attribs])
        for k,v in kwargs.items():
            if k in used_attribs:
                raise KeyError(f"argument '{k}' has already been specified as positional argument.")
            elif k not in attribs:
                raise KeyError(f"'{k}' is no valid property name. Valid names: {valid_names}")
            setattr(self,k,v)
    def get_x(self, i):
        """Get value ``x`` of ``(<chip.ulong3*>self._ptr)[i]``.
        """
        return (<chip.ulong3*>self._ptr)[i].x
    def set_x(self, i, unsigned long value):
        """Set value ``x`` of ``(<chip.ulong3*>self._ptr)[i]``.
        """
        (<chip.ulong3*>self._ptr)[i].x = value
    @property
    def x(self):
        """(undocumented)"""
        return self.get_x(0)
    @x.setter
    def x(self, unsigned long value):
        self.set_x(0,value)

    def get_y(self, i):
        """Get value ``y`` of ``(<chip.ulong3*>self._ptr)[i]``.
        """
        return (<chip.ulong3*>self._ptr)[i].y
    def set_y(self, i, unsigned long value):
        """Set value ``y`` of ``(<chip.ulong3*>self._ptr)[i]``.
        """
        (<chip.ulong3*>self._ptr)[i].y = value
    @property
    def y(self):
        """(undocumented)"""
        return self.get_y(0)
    @y.setter
    def y(self, unsigned long value):
        self.set_y(0,value)

    def get_z(self, i):
        """Get value ``z`` of ``(<chip.ulong3*>self._ptr)[i]``.
        """
        return (<chip.ulong3*>self._ptr)[i].z
    def set_z(self, i, unsigned long value):
        """Set value ``z`` of ``(<chip.ulong3*>self._ptr)[i]``.
        """
        (<chip.ulong3*>self._ptr)[i].z = value
    @property
    def z(self):
        """(undocumented)"""
        return self.get_z(0)
    @z.setter
    def z(self, unsigned long value):
        self.set_z(0,value)

    @staticmethod
    def PROPERTIES():
        return ["x","y","z"]

    def __contains__(self,item):
        properties = self.PROPERTIES()
        return item in properties

    def __getitem__(self,item):
        properties = self.PROPERTIES()
        if isinstance(item,int):
            if item < 0 or item >= len(properties):
                raise IndexError()
            return getattr(self,properties[item])
        raise ValueError("'item' type must be 'int'")


cdef class ulong4(hip._util.types.Pointer):
    """Python wrapper for cdef class chip.ulong4.

    Python wrapper for cdef class chip.ulong4.

    If this type is initialized via its `__init__` method, it allocates a
    member of the underlying C type and destroys it again if the wrapper
    type is deallocated.

    This type also serves as adapter when appearing as argument type in a
    function signature. In this case, the type can further be initialized
    from a number of Python objects:

    * `None`:

      This will set the ``self._ptr`` attribute to ``NULL``.

    * `int`:

      Interprets the integer value as pointer address and writes it to ``self._ptr``.
      No ownership is transferred.

    * `ctypes.c_void_p`:

      Takes the pointer address ``pyobj.value`` and writes it to ``self._ptr``.
      No ownership is transferred.

    * `object` that implements the `CUDA Array Interface <https://numba.readthedocs.io/en/stable/cuda/cuda_array_interface.html>`_ protocol:

      Takes the integer-valued pointer address, i.e. the first entry of the `data` tuple
      from `pyobj`'s member ``__cuda_array_interface__``  and writes it to ``self._ptr``.

    * `object` that implements the Python buffer protocol:

      If the object represents a simple contiguous array,
      writes the `Py_buffer` associated with ``pyobj`` to `self._py_buffer`,
      sets the `self._py_buffer_acquired` flag to `True`, and
      writes `self._py_buffer.buf` to the data pointer `self._ptr`.

    * `hip._util.types.Pointer`:

      Takes the pointer address ``pyobj._ptr`` and writes it to ``self._ptr``.
      No ownership is transferred.

    Type checks are performed in the above order.

    C Attributes:
        _ptr (C type ``void *``, protected):
            Stores a pointer to the data of the original Python object.
        _is_ptr_owner (C type ``bint``, protected):
            If this wrapper is the owner of the underlying data.
        _py_buffer (C type ``Py_buffer`, protected):
            Stores a pointer to the data of the original Python object.
        _py_buffer_acquired (C type ``bint``, protected):
            Stores a pointer to the data of the original Python object.
    """
    # C members declared in pxd file

    def __cinit__(self):
        self._ptr = NULL
        self._is_ptr_owner = False
        self._py_buffer_acquired = False

    cdef chip.ulong4* getElementPtr(self):
        return <chip.ulong4*>self._ptr

    @staticmethod
    cdef ulong4 fromPtr(void* ptr, bint owner=False):
        """Factory function to create ``ulong4`` objects from
        given ``chip.ulong4`` pointer.

        Setting ``owner`` flag to ``True`` causes
        the extension type to free the structure pointed to by ``ptr``
        when the wrapper object is deallocated.
        """
        # Fast call to __new__() that bypasses the __init__() constructor.
        cdef ulong4 wrapper = ulong4.__new__(ulong4)
        wrapper._ptr = ptr
        wrapper._is_ptr_owner = owner
        return wrapper

    @staticmethod
    def fromObj(pyobj):
        """Creates a ulong4 from a Python object.

        Derives a ulong4 from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``ulong4`` reference, this method
        returns it directly. No new ``ulong4`` is created in this case.
        """
        return ulong4.fromPyobj(pyobj)

    @staticmethod
    cdef ulong4 fromPyobj(object pyobj):
        """Creates a ulong4 from a Python object.

        Derives a ulong4 from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``ulong4`` reference, this method
        returns it directly. No new ``ulong4`` is created in this case.

        Args:
            pyobj (object): Must be either `None`; a `hip._util.types.Pointer`; a simple, contiguous buffer according to the buffer protocol;
                            or of type `ulong4`; `int`; or `ctypes.c_void_p`.

        Note:
            This routine does not perform a copy but returns the original ``pyobj``
            if ``pyobj`` is an instance of ulong4!
        """
        cdef ulong4 wrapper

        if isinstance(pyobj,ulong4):
            return pyobj
        else:
            wrapper = ulong4.__new__(ulong4)
            wrapper.init_from_pyobj(pyobj)
            return wrapper

    def __dealloc__(self):
        # Release the buffer handle
        if self._py_buffer_acquired is True:
            cpython.buffer.PyBuffer_Release(&self._py_buffer)
        # De-allocate if not null and flag is set
        if self._ptr is not NULL and self._is_ptr_owner is True:
            stdlib.free(self._ptr)
            self._ptr = NULL

    @staticmethod
    cdef __allocate(void** ptr):
        ptr[0] = stdlib.malloc(sizeof(chip.ulong4))
        string.memset(<void*>ptr[0], 0, sizeof(chip.ulong4))

        if ptr[0] is NULL:
            raise MemoryError

    @staticmethod
    cdef ulong4 new():
        """Factory function to create ulong4 objects with
        newly allocated chip.ulong4"""
        cdef void* ptr
        ulong4.__allocate(&ptr)
        return ulong4.fromPtr(ptr, owner=True)

    @staticmethod
    cdef ulong4 fromValue(chip.ulong4 other):
        """Allocate new C type and copy from ``other``.
        """
        wrapper = ulong4.new()
        string.memcpy(wrapper._ptr, &other, sizeof(chip.ulong4))
        return wrapper

    def c_sizeof(self):
        """Returns the size of the underlying C type in bytes.
        Note:
            Implemented as function to not collide with
            autogenerated property names.
        """
        return sizeof(chip.ulong4)

    def __int__(self):
        """Returns the data's address as long integer.
        """
        return cpython.long.PyLong_FromVoidPtr(self._ptr)

    def __repr__(self):
        return f"<ulong4 object, ptr: {int(self)}>"

    def as_c_void_p(self):
        """Returns the data's address as `ctypes.c_void_p`
        Note:
            Implemented as function to not collide with
            autogenerated property names.
        """
        return ctypes.c_void_p(int(self))

    def __init__(self,*args,**kwargs):
        """Constructor type ulong4.

        Constructor for type ulong4.

        Args:
            *args:
                Positional arguments. Initialize all or a subset of the member variables
                according to their order of declaration.
            **kwargs:
                Can be used to initialize member variables at construction,
                Just pass an argument expression of the form <member>=<value>
                per member that you want to initialize.
        """
        ulong4.__allocate(&self._ptr)
        self._is_ptr_owner = True
        attribs = self.PROPERTIES()
        used_attribs = set()
        if len(args) > len(attribs):
            raise ValueError("More positional arguments specified than this type has properties.")
        for i,v in enumerate(args):
            setattr(self,attribs[i],v)
            used_attribs.add(attribs[i])
        valid_names = ", ".join(["'"+p+"'" for p in attribs])
        for k,v in kwargs.items():
            if k in used_attribs:
                raise KeyError(f"argument '{k}' has already been specified as positional argument.")
            elif k not in attribs:
                raise KeyError(f"'{k}' is no valid property name. Valid names: {valid_names}")
            setattr(self,k,v)
    def get_x(self, i):
        """Get value ``x`` of ``(<chip.ulong4*>self._ptr)[i]``.
        """
        return (<chip.ulong4*>self._ptr)[i].x
    def set_x(self, i, unsigned long value):
        """Set value ``x`` of ``(<chip.ulong4*>self._ptr)[i]``.
        """
        (<chip.ulong4*>self._ptr)[i].x = value
    @property
    def x(self):
        """(undocumented)"""
        return self.get_x(0)
    @x.setter
    def x(self, unsigned long value):
        self.set_x(0,value)

    def get_y(self, i):
        """Get value ``y`` of ``(<chip.ulong4*>self._ptr)[i]``.
        """
        return (<chip.ulong4*>self._ptr)[i].y
    def set_y(self, i, unsigned long value):
        """Set value ``y`` of ``(<chip.ulong4*>self._ptr)[i]``.
        """
        (<chip.ulong4*>self._ptr)[i].y = value
    @property
    def y(self):
        """(undocumented)"""
        return self.get_y(0)
    @y.setter
    def y(self, unsigned long value):
        self.set_y(0,value)

    def get_z(self, i):
        """Get value ``z`` of ``(<chip.ulong4*>self._ptr)[i]``.
        """
        return (<chip.ulong4*>self._ptr)[i].z
    def set_z(self, i, unsigned long value):
        """Set value ``z`` of ``(<chip.ulong4*>self._ptr)[i]``.
        """
        (<chip.ulong4*>self._ptr)[i].z = value
    @property
    def z(self):
        """(undocumented)"""
        return self.get_z(0)
    @z.setter
    def z(self, unsigned long value):
        self.set_z(0,value)

    def get_w(self, i):
        """Get value ``w`` of ``(<chip.ulong4*>self._ptr)[i]``.
        """
        return (<chip.ulong4*>self._ptr)[i].w
    def set_w(self, i, unsigned long value):
        """Set value ``w`` of ``(<chip.ulong4*>self._ptr)[i]``.
        """
        (<chip.ulong4*>self._ptr)[i].w = value
    @property
    def w(self):
        """(undocumented)"""
        return self.get_w(0)
    @w.setter
    def w(self, unsigned long value):
        self.set_w(0,value)

    @staticmethod
    def PROPERTIES():
        return ["x","y","z","w"]

    def __contains__(self,item):
        properties = self.PROPERTIES()
        return item in properties

    def __getitem__(self,item):
        properties = self.PROPERTIES()
        if isinstance(item,int):
            if item < 0 or item >= len(properties):
                raise IndexError()
            return getattr(self,properties[item])
        raise ValueError("'item' type must be 'int'")


cdef class long1(hip._util.types.Pointer):
    """Python wrapper for cdef class chip.long1.

    Python wrapper for cdef class chip.long1.

    If this type is initialized via its `__init__` method, it allocates a
    member of the underlying C type and destroys it again if the wrapper
    type is deallocated.

    This type also serves as adapter when appearing as argument type in a
    function signature. In this case, the type can further be initialized
    from a number of Python objects:

    * `None`:

      This will set the ``self._ptr`` attribute to ``NULL``.

    * `int`:

      Interprets the integer value as pointer address and writes it to ``self._ptr``.
      No ownership is transferred.

    * `ctypes.c_void_p`:

      Takes the pointer address ``pyobj.value`` and writes it to ``self._ptr``.
      No ownership is transferred.

    * `object` that implements the `CUDA Array Interface <https://numba.readthedocs.io/en/stable/cuda/cuda_array_interface.html>`_ protocol:

      Takes the integer-valued pointer address, i.e. the first entry of the `data` tuple
      from `pyobj`'s member ``__cuda_array_interface__``  and writes it to ``self._ptr``.

    * `object` that implements the Python buffer protocol:

      If the object represents a simple contiguous array,
      writes the `Py_buffer` associated with ``pyobj`` to `self._py_buffer`,
      sets the `self._py_buffer_acquired` flag to `True`, and
      writes `self._py_buffer.buf` to the data pointer `self._ptr`.

    * `hip._util.types.Pointer`:

      Takes the pointer address ``pyobj._ptr`` and writes it to ``self._ptr``.
      No ownership is transferred.

    Type checks are performed in the above order.

    C Attributes:
        _ptr (C type ``void *``, protected):
            Stores a pointer to the data of the original Python object.
        _is_ptr_owner (C type ``bint``, protected):
            If this wrapper is the owner of the underlying data.
        _py_buffer (C type ``Py_buffer`, protected):
            Stores a pointer to the data of the original Python object.
        _py_buffer_acquired (C type ``bint``, protected):
            Stores a pointer to the data of the original Python object.
    """
    # C members declared in pxd file

    def __cinit__(self):
        self._ptr = NULL
        self._is_ptr_owner = False
        self._py_buffer_acquired = False

    cdef chip.long1* getElementPtr(self):
        return <chip.long1*>self._ptr

    @staticmethod
    cdef long1 fromPtr(void* ptr, bint owner=False):
        """Factory function to create ``long1`` objects from
        given ``chip.long1`` pointer.

        Setting ``owner`` flag to ``True`` causes
        the extension type to free the structure pointed to by ``ptr``
        when the wrapper object is deallocated.
        """
        # Fast call to __new__() that bypasses the __init__() constructor.
        cdef long1 wrapper = long1.__new__(long1)
        wrapper._ptr = ptr
        wrapper._is_ptr_owner = owner
        return wrapper

    @staticmethod
    def fromObj(pyobj):
        """Creates a long1 from a Python object.

        Derives a long1 from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``long1`` reference, this method
        returns it directly. No new ``long1`` is created in this case.
        """
        return long1.fromPyobj(pyobj)

    @staticmethod
    cdef long1 fromPyobj(object pyobj):
        """Creates a long1 from a Python object.

        Derives a long1 from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``long1`` reference, this method
        returns it directly. No new ``long1`` is created in this case.

        Args:
            pyobj (object): Must be either `None`; a `hip._util.types.Pointer`; a simple, contiguous buffer according to the buffer protocol;
                            or of type `long1`; `int`; or `ctypes.c_void_p`.

        Note:
            This routine does not perform a copy but returns the original ``pyobj``
            if ``pyobj`` is an instance of long1!
        """
        cdef long1 wrapper

        if isinstance(pyobj,long1):
            return pyobj
        else:
            wrapper = long1.__new__(long1)
            wrapper.init_from_pyobj(pyobj)
            return wrapper

    def __dealloc__(self):
        # Release the buffer handle
        if self._py_buffer_acquired is True:
            cpython.buffer.PyBuffer_Release(&self._py_buffer)
        # De-allocate if not null and flag is set
        if self._ptr is not NULL and self._is_ptr_owner is True:
            stdlib.free(self._ptr)
            self._ptr = NULL

    @staticmethod
    cdef __allocate(void** ptr):
        ptr[0] = stdlib.malloc(sizeof(chip.long1))
        string.memset(<void*>ptr[0], 0, sizeof(chip.long1))

        if ptr[0] is NULL:
            raise MemoryError

    @staticmethod
    cdef long1 new():
        """Factory function to create long1 objects with
        newly allocated chip.long1"""
        cdef void* ptr
        long1.__allocate(&ptr)
        return long1.fromPtr(ptr, owner=True)

    @staticmethod
    cdef long1 fromValue(chip.long1 other):
        """Allocate new C type and copy from ``other``.
        """
        wrapper = long1.new()
        string.memcpy(wrapper._ptr, &other, sizeof(chip.long1))
        return wrapper

    def c_sizeof(self):
        """Returns the size of the underlying C type in bytes.
        Note:
            Implemented as function to not collide with
            autogenerated property names.
        """
        return sizeof(chip.long1)

    def __int__(self):
        """Returns the data's address as long integer.
        """
        return cpython.long.PyLong_FromVoidPtr(self._ptr)

    def __repr__(self):
        return f"<long1 object, ptr: {int(self)}>"

    def as_c_void_p(self):
        """Returns the data's address as `ctypes.c_void_p`
        Note:
            Implemented as function to not collide with
            autogenerated property names.
        """
        return ctypes.c_void_p(int(self))

    def __init__(self,*args,**kwargs):
        """Constructor type long1.

        Constructor for type long1.

        Args:
            *args:
                Positional arguments. Initialize all or a subset of the member variables
                according to their order of declaration.
            **kwargs:
                Can be used to initialize member variables at construction,
                Just pass an argument expression of the form <member>=<value>
                per member that you want to initialize.
        """
        long1.__allocate(&self._ptr)
        self._is_ptr_owner = True
        attribs = self.PROPERTIES()
        used_attribs = set()
        if len(args) > len(attribs):
            raise ValueError("More positional arguments specified than this type has properties.")
        for i,v in enumerate(args):
            setattr(self,attribs[i],v)
            used_attribs.add(attribs[i])
        valid_names = ", ".join(["'"+p+"'" for p in attribs])
        for k,v in kwargs.items():
            if k in used_attribs:
                raise KeyError(f"argument '{k}' has already been specified as positional argument.")
            elif k not in attribs:
                raise KeyError(f"'{k}' is no valid property name. Valid names: {valid_names}")
            setattr(self,k,v)
    def get_x(self, i):
        """Get value ``x`` of ``(<chip.long1*>self._ptr)[i]``.
        """
        return (<chip.long1*>self._ptr)[i].x
    def set_x(self, i, long value):
        """Set value ``x`` of ``(<chip.long1*>self._ptr)[i]``.
        """
        (<chip.long1*>self._ptr)[i].x = value
    @property
    def x(self):
        """(undocumented)"""
        return self.get_x(0)
    @x.setter
    def x(self, long value):
        self.set_x(0,value)

    @staticmethod
    def PROPERTIES():
        return ["x"]

    def __contains__(self,item):
        properties = self.PROPERTIES()
        return item in properties

    def __getitem__(self,item):
        properties = self.PROPERTIES()
        if isinstance(item,int):
            if item < 0 or item >= len(properties):
                raise IndexError()
            return getattr(self,properties[item])
        raise ValueError("'item' type must be 'int'")


cdef class long2(hip._util.types.Pointer):
    """Python wrapper for cdef class chip.long2.

    Python wrapper for cdef class chip.long2.

    If this type is initialized via its `__init__` method, it allocates a
    member of the underlying C type and destroys it again if the wrapper
    type is deallocated.

    This type also serves as adapter when appearing as argument type in a
    function signature. In this case, the type can further be initialized
    from a number of Python objects:

    * `None`:

      This will set the ``self._ptr`` attribute to ``NULL``.

    * `int`:

      Interprets the integer value as pointer address and writes it to ``self._ptr``.
      No ownership is transferred.

    * `ctypes.c_void_p`:

      Takes the pointer address ``pyobj.value`` and writes it to ``self._ptr``.
      No ownership is transferred.

    * `object` that implements the `CUDA Array Interface <https://numba.readthedocs.io/en/stable/cuda/cuda_array_interface.html>`_ protocol:

      Takes the integer-valued pointer address, i.e. the first entry of the `data` tuple
      from `pyobj`'s member ``__cuda_array_interface__``  and writes it to ``self._ptr``.

    * `object` that implements the Python buffer protocol:

      If the object represents a simple contiguous array,
      writes the `Py_buffer` associated with ``pyobj`` to `self._py_buffer`,
      sets the `self._py_buffer_acquired` flag to `True`, and
      writes `self._py_buffer.buf` to the data pointer `self._ptr`.

    * `hip._util.types.Pointer`:

      Takes the pointer address ``pyobj._ptr`` and writes it to ``self._ptr``.
      No ownership is transferred.

    Type checks are performed in the above order.

    C Attributes:
        _ptr (C type ``void *``, protected):
            Stores a pointer to the data of the original Python object.
        _is_ptr_owner (C type ``bint``, protected):
            If this wrapper is the owner of the underlying data.
        _py_buffer (C type ``Py_buffer`, protected):
            Stores a pointer to the data of the original Python object.
        _py_buffer_acquired (C type ``bint``, protected):
            Stores a pointer to the data of the original Python object.
    """
    # C members declared in pxd file

    def __cinit__(self):
        self._ptr = NULL
        self._is_ptr_owner = False
        self._py_buffer_acquired = False

    cdef chip.long2* getElementPtr(self):
        return <chip.long2*>self._ptr

    @staticmethod
    cdef long2 fromPtr(void* ptr, bint owner=False):
        """Factory function to create ``long2`` objects from
        given ``chip.long2`` pointer.

        Setting ``owner`` flag to ``True`` causes
        the extension type to free the structure pointed to by ``ptr``
        when the wrapper object is deallocated.
        """
        # Fast call to __new__() that bypasses the __init__() constructor.
        cdef long2 wrapper = long2.__new__(long2)
        wrapper._ptr = ptr
        wrapper._is_ptr_owner = owner
        return wrapper

    @staticmethod
    def fromObj(pyobj):
        """Creates a long2 from a Python object.

        Derives a long2 from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``long2`` reference, this method
        returns it directly. No new ``long2`` is created in this case.
        """
        return long2.fromPyobj(pyobj)

    @staticmethod
    cdef long2 fromPyobj(object pyobj):
        """Creates a long2 from a Python object.

        Derives a long2 from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``long2`` reference, this method
        returns it directly. No new ``long2`` is created in this case.

        Args:
            pyobj (object): Must be either `None`; a `hip._util.types.Pointer`; a simple, contiguous buffer according to the buffer protocol;
                            or of type `long2`; `int`; or `ctypes.c_void_p`.

        Note:
            This routine does not perform a copy but returns the original ``pyobj``
            if ``pyobj`` is an instance of long2!
        """
        cdef long2 wrapper

        if isinstance(pyobj,long2):
            return pyobj
        else:
            wrapper = long2.__new__(long2)
            wrapper.init_from_pyobj(pyobj)
            return wrapper

    def __dealloc__(self):
        # Release the buffer handle
        if self._py_buffer_acquired is True:
            cpython.buffer.PyBuffer_Release(&self._py_buffer)
        # De-allocate if not null and flag is set
        if self._ptr is not NULL and self._is_ptr_owner is True:
            stdlib.free(self._ptr)
            self._ptr = NULL

    @staticmethod
    cdef __allocate(void** ptr):
        ptr[0] = stdlib.malloc(sizeof(chip.long2))
        string.memset(<void*>ptr[0], 0, sizeof(chip.long2))

        if ptr[0] is NULL:
            raise MemoryError

    @staticmethod
    cdef long2 new():
        """Factory function to create long2 objects with
        newly allocated chip.long2"""
        cdef void* ptr
        long2.__allocate(&ptr)
        return long2.fromPtr(ptr, owner=True)

    @staticmethod
    cdef long2 fromValue(chip.long2 other):
        """Allocate new C type and copy from ``other``.
        """
        wrapper = long2.new()
        string.memcpy(wrapper._ptr, &other, sizeof(chip.long2))
        return wrapper

    def c_sizeof(self):
        """Returns the size of the underlying C type in bytes.
        Note:
            Implemented as function to not collide with
            autogenerated property names.
        """
        return sizeof(chip.long2)

    def __int__(self):
        """Returns the data's address as long integer.
        """
        return cpython.long.PyLong_FromVoidPtr(self._ptr)

    def __repr__(self):
        return f"<long2 object, ptr: {int(self)}>"

    def as_c_void_p(self):
        """Returns the data's address as `ctypes.c_void_p`
        Note:
            Implemented as function to not collide with
            autogenerated property names.
        """
        return ctypes.c_void_p(int(self))

    def __init__(self,*args,**kwargs):
        """Constructor type long2.

        Constructor for type long2.

        Args:
            *args:
                Positional arguments. Initialize all or a subset of the member variables
                according to their order of declaration.
            **kwargs:
                Can be used to initialize member variables at construction,
                Just pass an argument expression of the form <member>=<value>
                per member that you want to initialize.
        """
        long2.__allocate(&self._ptr)
        self._is_ptr_owner = True
        attribs = self.PROPERTIES()
        used_attribs = set()
        if len(args) > len(attribs):
            raise ValueError("More positional arguments specified than this type has properties.")
        for i,v in enumerate(args):
            setattr(self,attribs[i],v)
            used_attribs.add(attribs[i])
        valid_names = ", ".join(["'"+p+"'" for p in attribs])
        for k,v in kwargs.items():
            if k in used_attribs:
                raise KeyError(f"argument '{k}' has already been specified as positional argument.")
            elif k not in attribs:
                raise KeyError(f"'{k}' is no valid property name. Valid names: {valid_names}")
            setattr(self,k,v)
    def get_x(self, i):
        """Get value ``x`` of ``(<chip.long2*>self._ptr)[i]``.
        """
        return (<chip.long2*>self._ptr)[i].x
    def set_x(self, i, long value):
        """Set value ``x`` of ``(<chip.long2*>self._ptr)[i]``.
        """
        (<chip.long2*>self._ptr)[i].x = value
    @property
    def x(self):
        """(undocumented)"""
        return self.get_x(0)
    @x.setter
    def x(self, long value):
        self.set_x(0,value)

    def get_y(self, i):
        """Get value ``y`` of ``(<chip.long2*>self._ptr)[i]``.
        """
        return (<chip.long2*>self._ptr)[i].y
    def set_y(self, i, long value):
        """Set value ``y`` of ``(<chip.long2*>self._ptr)[i]``.
        """
        (<chip.long2*>self._ptr)[i].y = value
    @property
    def y(self):
        """(undocumented)"""
        return self.get_y(0)
    @y.setter
    def y(self, long value):
        self.set_y(0,value)

    @staticmethod
    def PROPERTIES():
        return ["x","y"]

    def __contains__(self,item):
        properties = self.PROPERTIES()
        return item in properties

    def __getitem__(self,item):
        properties = self.PROPERTIES()
        if isinstance(item,int):
            if item < 0 or item >= len(properties):
                raise IndexError()
            return getattr(self,properties[item])
        raise ValueError("'item' type must be 'int'")


cdef class long3(hip._util.types.Pointer):
    """Python wrapper for cdef class chip.long3.

    Python wrapper for cdef class chip.long3.

    If this type is initialized via its `__init__` method, it allocates a
    member of the underlying C type and destroys it again if the wrapper
    type is deallocated.

    This type also serves as adapter when appearing as argument type in a
    function signature. In this case, the type can further be initialized
    from a number of Python objects:

    * `None`:

      This will set the ``self._ptr`` attribute to ``NULL``.

    * `int`:

      Interprets the integer value as pointer address and writes it to ``self._ptr``.
      No ownership is transferred.

    * `ctypes.c_void_p`:

      Takes the pointer address ``pyobj.value`` and writes it to ``self._ptr``.
      No ownership is transferred.

    * `object` that implements the `CUDA Array Interface <https://numba.readthedocs.io/en/stable/cuda/cuda_array_interface.html>`_ protocol:

      Takes the integer-valued pointer address, i.e. the first entry of the `data` tuple
      from `pyobj`'s member ``__cuda_array_interface__``  and writes it to ``self._ptr``.

    * `object` that implements the Python buffer protocol:

      If the object represents a simple contiguous array,
      writes the `Py_buffer` associated with ``pyobj`` to `self._py_buffer`,
      sets the `self._py_buffer_acquired` flag to `True`, and
      writes `self._py_buffer.buf` to the data pointer `self._ptr`.

    * `hip._util.types.Pointer`:

      Takes the pointer address ``pyobj._ptr`` and writes it to ``self._ptr``.
      No ownership is transferred.

    Type checks are performed in the above order.

    C Attributes:
        _ptr (C type ``void *``, protected):
            Stores a pointer to the data of the original Python object.
        _is_ptr_owner (C type ``bint``, protected):
            If this wrapper is the owner of the underlying data.
        _py_buffer (C type ``Py_buffer`, protected):
            Stores a pointer to the data of the original Python object.
        _py_buffer_acquired (C type ``bint``, protected):
            Stores a pointer to the data of the original Python object.
    """
    # C members declared in pxd file

    def __cinit__(self):
        self._ptr = NULL
        self._is_ptr_owner = False
        self._py_buffer_acquired = False

    cdef chip.long3* getElementPtr(self):
        return <chip.long3*>self._ptr

    @staticmethod
    cdef long3 fromPtr(void* ptr, bint owner=False):
        """Factory function to create ``long3`` objects from
        given ``chip.long3`` pointer.

        Setting ``owner`` flag to ``True`` causes
        the extension type to free the structure pointed to by ``ptr``
        when the wrapper object is deallocated.
        """
        # Fast call to __new__() that bypasses the __init__() constructor.
        cdef long3 wrapper = long3.__new__(long3)
        wrapper._ptr = ptr
        wrapper._is_ptr_owner = owner
        return wrapper

    @staticmethod
    def fromObj(pyobj):
        """Creates a long3 from a Python object.

        Derives a long3 from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``long3`` reference, this method
        returns it directly. No new ``long3`` is created in this case.
        """
        return long3.fromPyobj(pyobj)

    @staticmethod
    cdef long3 fromPyobj(object pyobj):
        """Creates a long3 from a Python object.

        Derives a long3 from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``long3`` reference, this method
        returns it directly. No new ``long3`` is created in this case.

        Args:
            pyobj (object): Must be either `None`; a `hip._util.types.Pointer`; a simple, contiguous buffer according to the buffer protocol;
                            or of type `long3`; `int`; or `ctypes.c_void_p`.

        Note:
            This routine does not perform a copy but returns the original ``pyobj``
            if ``pyobj`` is an instance of long3!
        """
        cdef long3 wrapper

        if isinstance(pyobj,long3):
            return pyobj
        else:
            wrapper = long3.__new__(long3)
            wrapper.init_from_pyobj(pyobj)
            return wrapper

    def __dealloc__(self):
        # Release the buffer handle
        if self._py_buffer_acquired is True:
            cpython.buffer.PyBuffer_Release(&self._py_buffer)
        # De-allocate if not null and flag is set
        if self._ptr is not NULL and self._is_ptr_owner is True:
            stdlib.free(self._ptr)
            self._ptr = NULL

    @staticmethod
    cdef __allocate(void** ptr):
        ptr[0] = stdlib.malloc(sizeof(chip.long3))
        string.memset(<void*>ptr[0], 0, sizeof(chip.long3))

        if ptr[0] is NULL:
            raise MemoryError

    @staticmethod
    cdef long3 new():
        """Factory function to create long3 objects with
        newly allocated chip.long3"""
        cdef void* ptr
        long3.__allocate(&ptr)
        return long3.fromPtr(ptr, owner=True)

    @staticmethod
    cdef long3 fromValue(chip.long3 other):
        """Allocate new C type and copy from ``other``.
        """
        wrapper = long3.new()
        string.memcpy(wrapper._ptr, &other, sizeof(chip.long3))
        return wrapper

    def c_sizeof(self):
        """Returns the size of the underlying C type in bytes.
        Note:
            Implemented as function to not collide with
            autogenerated property names.
        """
        return sizeof(chip.long3)

    def __int__(self):
        """Returns the data's address as long integer.
        """
        return cpython.long.PyLong_FromVoidPtr(self._ptr)

    def __repr__(self):
        return f"<long3 object, ptr: {int(self)}>"

    def as_c_void_p(self):
        """Returns the data's address as `ctypes.c_void_p`
        Note:
            Implemented as function to not collide with
            autogenerated property names.
        """
        return ctypes.c_void_p(int(self))

    def __init__(self,*args,**kwargs):
        """Constructor type long3.

        Constructor for type long3.

        Args:
            *args:
                Positional arguments. Initialize all or a subset of the member variables
                according to their order of declaration.
            **kwargs:
                Can be used to initialize member variables at construction,
                Just pass an argument expression of the form <member>=<value>
                per member that you want to initialize.
        """
        long3.__allocate(&self._ptr)
        self._is_ptr_owner = True
        attribs = self.PROPERTIES()
        used_attribs = set()
        if len(args) > len(attribs):
            raise ValueError("More positional arguments specified than this type has properties.")
        for i,v in enumerate(args):
            setattr(self,attribs[i],v)
            used_attribs.add(attribs[i])
        valid_names = ", ".join(["'"+p+"'" for p in attribs])
        for k,v in kwargs.items():
            if k in used_attribs:
                raise KeyError(f"argument '{k}' has already been specified as positional argument.")
            elif k not in attribs:
                raise KeyError(f"'{k}' is no valid property name. Valid names: {valid_names}")
            setattr(self,k,v)
    def get_x(self, i):
        """Get value ``x`` of ``(<chip.long3*>self._ptr)[i]``.
        """
        return (<chip.long3*>self._ptr)[i].x
    def set_x(self, i, long value):
        """Set value ``x`` of ``(<chip.long3*>self._ptr)[i]``.
        """
        (<chip.long3*>self._ptr)[i].x = value
    @property
    def x(self):
        """(undocumented)"""
        return self.get_x(0)
    @x.setter
    def x(self, long value):
        self.set_x(0,value)

    def get_y(self, i):
        """Get value ``y`` of ``(<chip.long3*>self._ptr)[i]``.
        """
        return (<chip.long3*>self._ptr)[i].y
    def set_y(self, i, long value):
        """Set value ``y`` of ``(<chip.long3*>self._ptr)[i]``.
        """
        (<chip.long3*>self._ptr)[i].y = value
    @property
    def y(self):
        """(undocumented)"""
        return self.get_y(0)
    @y.setter
    def y(self, long value):
        self.set_y(0,value)

    def get_z(self, i):
        """Get value ``z`` of ``(<chip.long3*>self._ptr)[i]``.
        """
        return (<chip.long3*>self._ptr)[i].z
    def set_z(self, i, long value):
        """Set value ``z`` of ``(<chip.long3*>self._ptr)[i]``.
        """
        (<chip.long3*>self._ptr)[i].z = value
    @property
    def z(self):
        """(undocumented)"""
        return self.get_z(0)
    @z.setter
    def z(self, long value):
        self.set_z(0,value)

    @staticmethod
    def PROPERTIES():
        return ["x","y","z"]

    def __contains__(self,item):
        properties = self.PROPERTIES()
        return item in properties

    def __getitem__(self,item):
        properties = self.PROPERTIES()
        if isinstance(item,int):
            if item < 0 or item >= len(properties):
                raise IndexError()
            return getattr(self,properties[item])
        raise ValueError("'item' type must be 'int'")


cdef class long4(hip._util.types.Pointer):
    """Python wrapper for cdef class chip.long4.

    Python wrapper for cdef class chip.long4.

    If this type is initialized via its `__init__` method, it allocates a
    member of the underlying C type and destroys it again if the wrapper
    type is deallocated.

    This type also serves as adapter when appearing as argument type in a
    function signature. In this case, the type can further be initialized
    from a number of Python objects:

    * `None`:

      This will set the ``self._ptr`` attribute to ``NULL``.

    * `int`:

      Interprets the integer value as pointer address and writes it to ``self._ptr``.
      No ownership is transferred.

    * `ctypes.c_void_p`:

      Takes the pointer address ``pyobj.value`` and writes it to ``self._ptr``.
      No ownership is transferred.

    * `object` that implements the `CUDA Array Interface <https://numba.readthedocs.io/en/stable/cuda/cuda_array_interface.html>`_ protocol:

      Takes the integer-valued pointer address, i.e. the first entry of the `data` tuple
      from `pyobj`'s member ``__cuda_array_interface__``  and writes it to ``self._ptr``.

    * `object` that implements the Python buffer protocol:

      If the object represents a simple contiguous array,
      writes the `Py_buffer` associated with ``pyobj`` to `self._py_buffer`,
      sets the `self._py_buffer_acquired` flag to `True`, and
      writes `self._py_buffer.buf` to the data pointer `self._ptr`.

    * `hip._util.types.Pointer`:

      Takes the pointer address ``pyobj._ptr`` and writes it to ``self._ptr``.
      No ownership is transferred.

    Type checks are performed in the above order.

    C Attributes:
        _ptr (C type ``void *``, protected):
            Stores a pointer to the data of the original Python object.
        _is_ptr_owner (C type ``bint``, protected):
            If this wrapper is the owner of the underlying data.
        _py_buffer (C type ``Py_buffer`, protected):
            Stores a pointer to the data of the original Python object.
        _py_buffer_acquired (C type ``bint``, protected):
            Stores a pointer to the data of the original Python object.
    """
    # C members declared in pxd file

    def __cinit__(self):
        self._ptr = NULL
        self._is_ptr_owner = False
        self._py_buffer_acquired = False

    cdef chip.long4* getElementPtr(self):
        return <chip.long4*>self._ptr

    @staticmethod
    cdef long4 fromPtr(void* ptr, bint owner=False):
        """Factory function to create ``long4`` objects from
        given ``chip.long4`` pointer.

        Setting ``owner`` flag to ``True`` causes
        the extension type to free the structure pointed to by ``ptr``
        when the wrapper object is deallocated.
        """
        # Fast call to __new__() that bypasses the __init__() constructor.
        cdef long4 wrapper = long4.__new__(long4)
        wrapper._ptr = ptr
        wrapper._is_ptr_owner = owner
        return wrapper

    @staticmethod
    def fromObj(pyobj):
        """Creates a long4 from a Python object.

        Derives a long4 from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``long4`` reference, this method
        returns it directly. No new ``long4`` is created in this case.
        """
        return long4.fromPyobj(pyobj)

    @staticmethod
    cdef long4 fromPyobj(object pyobj):
        """Creates a long4 from a Python object.

        Derives a long4 from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``long4`` reference, this method
        returns it directly. No new ``long4`` is created in this case.

        Args:
            pyobj (object): Must be either `None`; a `hip._util.types.Pointer`; a simple, contiguous buffer according to the buffer protocol;
                            or of type `long4`; `int`; or `ctypes.c_void_p`.

        Note:
            This routine does not perform a copy but returns the original ``pyobj``
            if ``pyobj`` is an instance of long4!
        """
        cdef long4 wrapper

        if isinstance(pyobj,long4):
            return pyobj
        else:
            wrapper = long4.__new__(long4)
            wrapper.init_from_pyobj(pyobj)
            return wrapper

    def __dealloc__(self):
        # Release the buffer handle
        if self._py_buffer_acquired is True:
            cpython.buffer.PyBuffer_Release(&self._py_buffer)
        # De-allocate if not null and flag is set
        if self._ptr is not NULL and self._is_ptr_owner is True:
            stdlib.free(self._ptr)
            self._ptr = NULL

    @staticmethod
    cdef __allocate(void** ptr):
        ptr[0] = stdlib.malloc(sizeof(chip.long4))
        string.memset(<void*>ptr[0], 0, sizeof(chip.long4))

        if ptr[0] is NULL:
            raise MemoryError

    @staticmethod
    cdef long4 new():
        """Factory function to create long4 objects with
        newly allocated chip.long4"""
        cdef void* ptr
        long4.__allocate(&ptr)
        return long4.fromPtr(ptr, owner=True)

    @staticmethod
    cdef long4 fromValue(chip.long4 other):
        """Allocate new C type and copy from ``other``.
        """
        wrapper = long4.new()
        string.memcpy(wrapper._ptr, &other, sizeof(chip.long4))
        return wrapper

    def c_sizeof(self):
        """Returns the size of the underlying C type in bytes.
        Note:
            Implemented as function to not collide with
            autogenerated property names.
        """
        return sizeof(chip.long4)

    def __int__(self):
        """Returns the data's address as long integer.
        """
        return cpython.long.PyLong_FromVoidPtr(self._ptr)

    def __repr__(self):
        return f"<long4 object, ptr: {int(self)}>"

    def as_c_void_p(self):
        """Returns the data's address as `ctypes.c_void_p`
        Note:
            Implemented as function to not collide with
            autogenerated property names.
        """
        return ctypes.c_void_p(int(self))

    def __init__(self,*args,**kwargs):
        """Constructor type long4.

        Constructor for type long4.

        Args:
            *args:
                Positional arguments. Initialize all or a subset of the member variables
                according to their order of declaration.
            **kwargs:
                Can be used to initialize member variables at construction,
                Just pass an argument expression of the form <member>=<value>
                per member that you want to initialize.
        """
        long4.__allocate(&self._ptr)
        self._is_ptr_owner = True
        attribs = self.PROPERTIES()
        used_attribs = set()
        if len(args) > len(attribs):
            raise ValueError("More positional arguments specified than this type has properties.")
        for i,v in enumerate(args):
            setattr(self,attribs[i],v)
            used_attribs.add(attribs[i])
        valid_names = ", ".join(["'"+p+"'" for p in attribs])
        for k,v in kwargs.items():
            if k in used_attribs:
                raise KeyError(f"argument '{k}' has already been specified as positional argument.")
            elif k not in attribs:
                raise KeyError(f"'{k}' is no valid property name. Valid names: {valid_names}")
            setattr(self,k,v)
    def get_x(self, i):
        """Get value ``x`` of ``(<chip.long4*>self._ptr)[i]``.
        """
        return (<chip.long4*>self._ptr)[i].x
    def set_x(self, i, long value):
        """Set value ``x`` of ``(<chip.long4*>self._ptr)[i]``.
        """
        (<chip.long4*>self._ptr)[i].x = value
    @property
    def x(self):
        """(undocumented)"""
        return self.get_x(0)
    @x.setter
    def x(self, long value):
        self.set_x(0,value)

    def get_y(self, i):
        """Get value ``y`` of ``(<chip.long4*>self._ptr)[i]``.
        """
        return (<chip.long4*>self._ptr)[i].y
    def set_y(self, i, long value):
        """Set value ``y`` of ``(<chip.long4*>self._ptr)[i]``.
        """
        (<chip.long4*>self._ptr)[i].y = value
    @property
    def y(self):
        """(undocumented)"""
        return self.get_y(0)
    @y.setter
    def y(self, long value):
        self.set_y(0,value)

    def get_z(self, i):
        """Get value ``z`` of ``(<chip.long4*>self._ptr)[i]``.
        """
        return (<chip.long4*>self._ptr)[i].z
    def set_z(self, i, long value):
        """Set value ``z`` of ``(<chip.long4*>self._ptr)[i]``.
        """
        (<chip.long4*>self._ptr)[i].z = value
    @property
    def z(self):
        """(undocumented)"""
        return self.get_z(0)
    @z.setter
    def z(self, long value):
        self.set_z(0,value)

    def get_w(self, i):
        """Get value ``w`` of ``(<chip.long4*>self._ptr)[i]``.
        """
        return (<chip.long4*>self._ptr)[i].w
    def set_w(self, i, long value):
        """Set value ``w`` of ``(<chip.long4*>self._ptr)[i]``.
        """
        (<chip.long4*>self._ptr)[i].w = value
    @property
    def w(self):
        """(undocumented)"""
        return self.get_w(0)
    @w.setter
    def w(self, long value):
        self.set_w(0,value)

    @staticmethod
    def PROPERTIES():
        return ["x","y","z","w"]

    def __contains__(self,item):
        properties = self.PROPERTIES()
        return item in properties

    def __getitem__(self,item):
        properties = self.PROPERTIES()
        if isinstance(item,int):
            if item < 0 or item >= len(properties):
                raise IndexError()
            return getattr(self,properties[item])
        raise ValueError("'item' type must be 'int'")


cdef class ulonglong1(hip._util.types.Pointer):
    """Python wrapper for cdef class chip.ulonglong1.

    Python wrapper for cdef class chip.ulonglong1.

    If this type is initialized via its `__init__` method, it allocates a
    member of the underlying C type and destroys it again if the wrapper
    type is deallocated.

    This type also serves as adapter when appearing as argument type in a
    function signature. In this case, the type can further be initialized
    from a number of Python objects:

    * `None`:

      This will set the ``self._ptr`` attribute to ``NULL``.

    * `int`:

      Interprets the integer value as pointer address and writes it to ``self._ptr``.
      No ownership is transferred.

    * `ctypes.c_void_p`:

      Takes the pointer address ``pyobj.value`` and writes it to ``self._ptr``.
      No ownership is transferred.

    * `object` that implements the `CUDA Array Interface <https://numba.readthedocs.io/en/stable/cuda/cuda_array_interface.html>`_ protocol:

      Takes the integer-valued pointer address, i.e. the first entry of the `data` tuple
      from `pyobj`'s member ``__cuda_array_interface__``  and writes it to ``self._ptr``.

    * `object` that implements the Python buffer protocol:

      If the object represents a simple contiguous array,
      writes the `Py_buffer` associated with ``pyobj`` to `self._py_buffer`,
      sets the `self._py_buffer_acquired` flag to `True`, and
      writes `self._py_buffer.buf` to the data pointer `self._ptr`.

    * `hip._util.types.Pointer`:

      Takes the pointer address ``pyobj._ptr`` and writes it to ``self._ptr``.
      No ownership is transferred.

    Type checks are performed in the above order.

    C Attributes:
        _ptr (C type ``void *``, protected):
            Stores a pointer to the data of the original Python object.
        _is_ptr_owner (C type ``bint``, protected):
            If this wrapper is the owner of the underlying data.
        _py_buffer (C type ``Py_buffer`, protected):
            Stores a pointer to the data of the original Python object.
        _py_buffer_acquired (C type ``bint``, protected):
            Stores a pointer to the data of the original Python object.
    """
    # C members declared in pxd file

    def __cinit__(self):
        self._ptr = NULL
        self._is_ptr_owner = False
        self._py_buffer_acquired = False

    cdef chip.ulonglong1* getElementPtr(self):
        return <chip.ulonglong1*>self._ptr

    @staticmethod
    cdef ulonglong1 fromPtr(void* ptr, bint owner=False):
        """Factory function to create ``ulonglong1`` objects from
        given ``chip.ulonglong1`` pointer.

        Setting ``owner`` flag to ``True`` causes
        the extension type to free the structure pointed to by ``ptr``
        when the wrapper object is deallocated.
        """
        # Fast call to __new__() that bypasses the __init__() constructor.
        cdef ulonglong1 wrapper = ulonglong1.__new__(ulonglong1)
        wrapper._ptr = ptr
        wrapper._is_ptr_owner = owner
        return wrapper

    @staticmethod
    def fromObj(pyobj):
        """Creates a ulonglong1 from a Python object.

        Derives a ulonglong1 from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``ulonglong1`` reference, this method
        returns it directly. No new ``ulonglong1`` is created in this case.
        """
        return ulonglong1.fromPyobj(pyobj)

    @staticmethod
    cdef ulonglong1 fromPyobj(object pyobj):
        """Creates a ulonglong1 from a Python object.

        Derives a ulonglong1 from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``ulonglong1`` reference, this method
        returns it directly. No new ``ulonglong1`` is created in this case.

        Args:
            pyobj (object): Must be either `None`; a `hip._util.types.Pointer`; a simple, contiguous buffer according to the buffer protocol;
                            or of type `ulonglong1`; `int`; or `ctypes.c_void_p`.

        Note:
            This routine does not perform a copy but returns the original ``pyobj``
            if ``pyobj`` is an instance of ulonglong1!
        """
        cdef ulonglong1 wrapper

        if isinstance(pyobj,ulonglong1):
            return pyobj
        else:
            wrapper = ulonglong1.__new__(ulonglong1)
            wrapper.init_from_pyobj(pyobj)
            return wrapper

    def __dealloc__(self):
        # Release the buffer handle
        if self._py_buffer_acquired is True:
            cpython.buffer.PyBuffer_Release(&self._py_buffer)
        # De-allocate if not null and flag is set
        if self._ptr is not NULL and self._is_ptr_owner is True:
            stdlib.free(self._ptr)
            self._ptr = NULL

    @staticmethod
    cdef __allocate(void** ptr):
        ptr[0] = stdlib.malloc(sizeof(chip.ulonglong1))
        string.memset(<void*>ptr[0], 0, sizeof(chip.ulonglong1))

        if ptr[0] is NULL:
            raise MemoryError

    @staticmethod
    cdef ulonglong1 new():
        """Factory function to create ulonglong1 objects with
        newly allocated chip.ulonglong1"""
        cdef void* ptr
        ulonglong1.__allocate(&ptr)
        return ulonglong1.fromPtr(ptr, owner=True)

    @staticmethod
    cdef ulonglong1 fromValue(chip.ulonglong1 other):
        """Allocate new C type and copy from ``other``.
        """
        wrapper = ulonglong1.new()
        string.memcpy(wrapper._ptr, &other, sizeof(chip.ulonglong1))
        return wrapper

    def c_sizeof(self):
        """Returns the size of the underlying C type in bytes.
        Note:
            Implemented as function to not collide with
            autogenerated property names.
        """
        return sizeof(chip.ulonglong1)

    def __int__(self):
        """Returns the data's address as long integer.
        """
        return cpython.long.PyLong_FromVoidPtr(self._ptr)

    def __repr__(self):
        return f"<ulonglong1 object, ptr: {int(self)}>"

    def as_c_void_p(self):
        """Returns the data's address as `ctypes.c_void_p`
        Note:
            Implemented as function to not collide with
            autogenerated property names.
        """
        return ctypes.c_void_p(int(self))

    def __init__(self,*args,**kwargs):
        """Constructor type ulonglong1.

        Constructor for type ulonglong1.

        Args:
            *args:
                Positional arguments. Initialize all or a subset of the member variables
                according to their order of declaration.
            **kwargs:
                Can be used to initialize member variables at construction,
                Just pass an argument expression of the form <member>=<value>
                per member that you want to initialize.
        """
        ulonglong1.__allocate(&self._ptr)
        self._is_ptr_owner = True
        attribs = self.PROPERTIES()
        used_attribs = set()
        if len(args) > len(attribs):
            raise ValueError("More positional arguments specified than this type has properties.")
        for i,v in enumerate(args):
            setattr(self,attribs[i],v)
            used_attribs.add(attribs[i])
        valid_names = ", ".join(["'"+p+"'" for p in attribs])
        for k,v in kwargs.items():
            if k in used_attribs:
                raise KeyError(f"argument '{k}' has already been specified as positional argument.")
            elif k not in attribs:
                raise KeyError(f"'{k}' is no valid property name. Valid names: {valid_names}")
            setattr(self,k,v)
    def get_x(self, i):
        """Get value ``x`` of ``(<chip.ulonglong1*>self._ptr)[i]``.
        """
        return (<chip.ulonglong1*>self._ptr)[i].x
    def set_x(self, i, unsigned long long value):
        """Set value ``x`` of ``(<chip.ulonglong1*>self._ptr)[i]``.
        """
        (<chip.ulonglong1*>self._ptr)[i].x = value
    @property
    def x(self):
        """(undocumented)"""
        return self.get_x(0)
    @x.setter
    def x(self, unsigned long long value):
        self.set_x(0,value)

    @staticmethod
    def PROPERTIES():
        return ["x"]

    def __contains__(self,item):
        properties = self.PROPERTIES()
        return item in properties

    def __getitem__(self,item):
        properties = self.PROPERTIES()
        if isinstance(item,int):
            if item < 0 or item >= len(properties):
                raise IndexError()
            return getattr(self,properties[item])
        raise ValueError("'item' type must be 'int'")


cdef class ulonglong2(hip._util.types.Pointer):
    """Python wrapper for cdef class chip.ulonglong2.

    Python wrapper for cdef class chip.ulonglong2.

    If this type is initialized via its `__init__` method, it allocates a
    member of the underlying C type and destroys it again if the wrapper
    type is deallocated.

    This type also serves as adapter when appearing as argument type in a
    function signature. In this case, the type can further be initialized
    from a number of Python objects:

    * `None`:

      This will set the ``self._ptr`` attribute to ``NULL``.

    * `int`:

      Interprets the integer value as pointer address and writes it to ``self._ptr``.
      No ownership is transferred.

    * `ctypes.c_void_p`:

      Takes the pointer address ``pyobj.value`` and writes it to ``self._ptr``.
      No ownership is transferred.

    * `object` that implements the `CUDA Array Interface <https://numba.readthedocs.io/en/stable/cuda/cuda_array_interface.html>`_ protocol:

      Takes the integer-valued pointer address, i.e. the first entry of the `data` tuple
      from `pyobj`'s member ``__cuda_array_interface__``  and writes it to ``self._ptr``.

    * `object` that implements the Python buffer protocol:

      If the object represents a simple contiguous array,
      writes the `Py_buffer` associated with ``pyobj`` to `self._py_buffer`,
      sets the `self._py_buffer_acquired` flag to `True`, and
      writes `self._py_buffer.buf` to the data pointer `self._ptr`.

    * `hip._util.types.Pointer`:

      Takes the pointer address ``pyobj._ptr`` and writes it to ``self._ptr``.
      No ownership is transferred.

    Type checks are performed in the above order.

    C Attributes:
        _ptr (C type ``void *``, protected):
            Stores a pointer to the data of the original Python object.
        _is_ptr_owner (C type ``bint``, protected):
            If this wrapper is the owner of the underlying data.
        _py_buffer (C type ``Py_buffer`, protected):
            Stores a pointer to the data of the original Python object.
        _py_buffer_acquired (C type ``bint``, protected):
            Stores a pointer to the data of the original Python object.
    """
    # C members declared in pxd file

    def __cinit__(self):
        self._ptr = NULL
        self._is_ptr_owner = False
        self._py_buffer_acquired = False

    cdef chip.ulonglong2* getElementPtr(self):
        return <chip.ulonglong2*>self._ptr

    @staticmethod
    cdef ulonglong2 fromPtr(void* ptr, bint owner=False):
        """Factory function to create ``ulonglong2`` objects from
        given ``chip.ulonglong2`` pointer.

        Setting ``owner`` flag to ``True`` causes
        the extension type to free the structure pointed to by ``ptr``
        when the wrapper object is deallocated.
        """
        # Fast call to __new__() that bypasses the __init__() constructor.
        cdef ulonglong2 wrapper = ulonglong2.__new__(ulonglong2)
        wrapper._ptr = ptr
        wrapper._is_ptr_owner = owner
        return wrapper

    @staticmethod
    def fromObj(pyobj):
        """Creates a ulonglong2 from a Python object.

        Derives a ulonglong2 from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``ulonglong2`` reference, this method
        returns it directly. No new ``ulonglong2`` is created in this case.
        """
        return ulonglong2.fromPyobj(pyobj)

    @staticmethod
    cdef ulonglong2 fromPyobj(object pyobj):
        """Creates a ulonglong2 from a Python object.

        Derives a ulonglong2 from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``ulonglong2`` reference, this method
        returns it directly. No new ``ulonglong2`` is created in this case.

        Args:
            pyobj (object): Must be either `None`; a `hip._util.types.Pointer`; a simple, contiguous buffer according to the buffer protocol;
                            or of type `ulonglong2`; `int`; or `ctypes.c_void_p`.

        Note:
            This routine does not perform a copy but returns the original ``pyobj``
            if ``pyobj`` is an instance of ulonglong2!
        """
        cdef ulonglong2 wrapper

        if isinstance(pyobj,ulonglong2):
            return pyobj
        else:
            wrapper = ulonglong2.__new__(ulonglong2)
            wrapper.init_from_pyobj(pyobj)
            return wrapper

    def __dealloc__(self):
        # Release the buffer handle
        if self._py_buffer_acquired is True:
            cpython.buffer.PyBuffer_Release(&self._py_buffer)
        # De-allocate if not null and flag is set
        if self._ptr is not NULL and self._is_ptr_owner is True:
            stdlib.free(self._ptr)
            self._ptr = NULL

    @staticmethod
    cdef __allocate(void** ptr):
        ptr[0] = stdlib.malloc(sizeof(chip.ulonglong2))
        string.memset(<void*>ptr[0], 0, sizeof(chip.ulonglong2))

        if ptr[0] is NULL:
            raise MemoryError

    @staticmethod
    cdef ulonglong2 new():
        """Factory function to create ulonglong2 objects with
        newly allocated chip.ulonglong2"""
        cdef void* ptr
        ulonglong2.__allocate(&ptr)
        return ulonglong2.fromPtr(ptr, owner=True)

    @staticmethod
    cdef ulonglong2 fromValue(chip.ulonglong2 other):
        """Allocate new C type and copy from ``other``.
        """
        wrapper = ulonglong2.new()
        string.memcpy(wrapper._ptr, &other, sizeof(chip.ulonglong2))
        return wrapper

    def c_sizeof(self):
        """Returns the size of the underlying C type in bytes.
        Note:
            Implemented as function to not collide with
            autogenerated property names.
        """
        return sizeof(chip.ulonglong2)

    def __int__(self):
        """Returns the data's address as long integer.
        """
        return cpython.long.PyLong_FromVoidPtr(self._ptr)

    def __repr__(self):
        return f"<ulonglong2 object, ptr: {int(self)}>"

    def as_c_void_p(self):
        """Returns the data's address as `ctypes.c_void_p`
        Note:
            Implemented as function to not collide with
            autogenerated property names.
        """
        return ctypes.c_void_p(int(self))

    def __init__(self,*args,**kwargs):
        """Constructor type ulonglong2.

        Constructor for type ulonglong2.

        Args:
            *args:
                Positional arguments. Initialize all or a subset of the member variables
                according to their order of declaration.
            **kwargs:
                Can be used to initialize member variables at construction,
                Just pass an argument expression of the form <member>=<value>
                per member that you want to initialize.
        """
        ulonglong2.__allocate(&self._ptr)
        self._is_ptr_owner = True
        attribs = self.PROPERTIES()
        used_attribs = set()
        if len(args) > len(attribs):
            raise ValueError("More positional arguments specified than this type has properties.")
        for i,v in enumerate(args):
            setattr(self,attribs[i],v)
            used_attribs.add(attribs[i])
        valid_names = ", ".join(["'"+p+"'" for p in attribs])
        for k,v in kwargs.items():
            if k in used_attribs:
                raise KeyError(f"argument '{k}' has already been specified as positional argument.")
            elif k not in attribs:
                raise KeyError(f"'{k}' is no valid property name. Valid names: {valid_names}")
            setattr(self,k,v)
    def get_x(self, i):
        """Get value ``x`` of ``(<chip.ulonglong2*>self._ptr)[i]``.
        """
        return (<chip.ulonglong2*>self._ptr)[i].x
    def set_x(self, i, unsigned long long value):
        """Set value ``x`` of ``(<chip.ulonglong2*>self._ptr)[i]``.
        """
        (<chip.ulonglong2*>self._ptr)[i].x = value
    @property
    def x(self):
        """(undocumented)"""
        return self.get_x(0)
    @x.setter
    def x(self, unsigned long long value):
        self.set_x(0,value)

    def get_y(self, i):
        """Get value ``y`` of ``(<chip.ulonglong2*>self._ptr)[i]``.
        """
        return (<chip.ulonglong2*>self._ptr)[i].y
    def set_y(self, i, unsigned long long value):
        """Set value ``y`` of ``(<chip.ulonglong2*>self._ptr)[i]``.
        """
        (<chip.ulonglong2*>self._ptr)[i].y = value
    @property
    def y(self):
        """(undocumented)"""
        return self.get_y(0)
    @y.setter
    def y(self, unsigned long long value):
        self.set_y(0,value)

    @staticmethod
    def PROPERTIES():
        return ["x","y"]

    def __contains__(self,item):
        properties = self.PROPERTIES()
        return item in properties

    def __getitem__(self,item):
        properties = self.PROPERTIES()
        if isinstance(item,int):
            if item < 0 or item >= len(properties):
                raise IndexError()
            return getattr(self,properties[item])
        raise ValueError("'item' type must be 'int'")


cdef class ulonglong3(hip._util.types.Pointer):
    """Python wrapper for cdef class chip.ulonglong3.

    Python wrapper for cdef class chip.ulonglong3.

    If this type is initialized via its `__init__` method, it allocates a
    member of the underlying C type and destroys it again if the wrapper
    type is deallocated.

    This type also serves as adapter when appearing as argument type in a
    function signature. In this case, the type can further be initialized
    from a number of Python objects:

    * `None`:

      This will set the ``self._ptr`` attribute to ``NULL``.

    * `int`:

      Interprets the integer value as pointer address and writes it to ``self._ptr``.
      No ownership is transferred.

    * `ctypes.c_void_p`:

      Takes the pointer address ``pyobj.value`` and writes it to ``self._ptr``.
      No ownership is transferred.

    * `object` that implements the `CUDA Array Interface <https://numba.readthedocs.io/en/stable/cuda/cuda_array_interface.html>`_ protocol:

      Takes the integer-valued pointer address, i.e. the first entry of the `data` tuple
      from `pyobj`'s member ``__cuda_array_interface__``  and writes it to ``self._ptr``.

    * `object` that implements the Python buffer protocol:

      If the object represents a simple contiguous array,
      writes the `Py_buffer` associated with ``pyobj`` to `self._py_buffer`,
      sets the `self._py_buffer_acquired` flag to `True`, and
      writes `self._py_buffer.buf` to the data pointer `self._ptr`.

    * `hip._util.types.Pointer`:

      Takes the pointer address ``pyobj._ptr`` and writes it to ``self._ptr``.
      No ownership is transferred.

    Type checks are performed in the above order.

    C Attributes:
        _ptr (C type ``void *``, protected):
            Stores a pointer to the data of the original Python object.
        _is_ptr_owner (C type ``bint``, protected):
            If this wrapper is the owner of the underlying data.
        _py_buffer (C type ``Py_buffer`, protected):
            Stores a pointer to the data of the original Python object.
        _py_buffer_acquired (C type ``bint``, protected):
            Stores a pointer to the data of the original Python object.
    """
    # C members declared in pxd file

    def __cinit__(self):
        self._ptr = NULL
        self._is_ptr_owner = False
        self._py_buffer_acquired = False

    cdef chip.ulonglong3* getElementPtr(self):
        return <chip.ulonglong3*>self._ptr

    @staticmethod
    cdef ulonglong3 fromPtr(void* ptr, bint owner=False):
        """Factory function to create ``ulonglong3`` objects from
        given ``chip.ulonglong3`` pointer.

        Setting ``owner`` flag to ``True`` causes
        the extension type to free the structure pointed to by ``ptr``
        when the wrapper object is deallocated.
        """
        # Fast call to __new__() that bypasses the __init__() constructor.
        cdef ulonglong3 wrapper = ulonglong3.__new__(ulonglong3)
        wrapper._ptr = ptr
        wrapper._is_ptr_owner = owner
        return wrapper

    @staticmethod
    def fromObj(pyobj):
        """Creates a ulonglong3 from a Python object.

        Derives a ulonglong3 from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``ulonglong3`` reference, this method
        returns it directly. No new ``ulonglong3`` is created in this case.
        """
        return ulonglong3.fromPyobj(pyobj)

    @staticmethod
    cdef ulonglong3 fromPyobj(object pyobj):
        """Creates a ulonglong3 from a Python object.

        Derives a ulonglong3 from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``ulonglong3`` reference, this method
        returns it directly. No new ``ulonglong3`` is created in this case.

        Args:
            pyobj (object): Must be either `None`; a `hip._util.types.Pointer`; a simple, contiguous buffer according to the buffer protocol;
                            or of type `ulonglong3`; `int`; or `ctypes.c_void_p`.

        Note:
            This routine does not perform a copy but returns the original ``pyobj``
            if ``pyobj`` is an instance of ulonglong3!
        """
        cdef ulonglong3 wrapper

        if isinstance(pyobj,ulonglong3):
            return pyobj
        else:
            wrapper = ulonglong3.__new__(ulonglong3)
            wrapper.init_from_pyobj(pyobj)
            return wrapper

    def __dealloc__(self):
        # Release the buffer handle
        if self._py_buffer_acquired is True:
            cpython.buffer.PyBuffer_Release(&self._py_buffer)
        # De-allocate if not null and flag is set
        if self._ptr is not NULL and self._is_ptr_owner is True:
            stdlib.free(self._ptr)
            self._ptr = NULL

    @staticmethod
    cdef __allocate(void** ptr):
        ptr[0] = stdlib.malloc(sizeof(chip.ulonglong3))
        string.memset(<void*>ptr[0], 0, sizeof(chip.ulonglong3))

        if ptr[0] is NULL:
            raise MemoryError

    @staticmethod
    cdef ulonglong3 new():
        """Factory function to create ulonglong3 objects with
        newly allocated chip.ulonglong3"""
        cdef void* ptr
        ulonglong3.__allocate(&ptr)
        return ulonglong3.fromPtr(ptr, owner=True)

    @staticmethod
    cdef ulonglong3 fromValue(chip.ulonglong3 other):
        """Allocate new C type and copy from ``other``.
        """
        wrapper = ulonglong3.new()
        string.memcpy(wrapper._ptr, &other, sizeof(chip.ulonglong3))
        return wrapper

    def c_sizeof(self):
        """Returns the size of the underlying C type in bytes.
        Note:
            Implemented as function to not collide with
            autogenerated property names.
        """
        return sizeof(chip.ulonglong3)

    def __int__(self):
        """Returns the data's address as long integer.
        """
        return cpython.long.PyLong_FromVoidPtr(self._ptr)

    def __repr__(self):
        return f"<ulonglong3 object, ptr: {int(self)}>"

    def as_c_void_p(self):
        """Returns the data's address as `ctypes.c_void_p`
        Note:
            Implemented as function to not collide with
            autogenerated property names.
        """
        return ctypes.c_void_p(int(self))

    def __init__(self,*args,**kwargs):
        """Constructor type ulonglong3.

        Constructor for type ulonglong3.

        Args:
            *args:
                Positional arguments. Initialize all or a subset of the member variables
                according to their order of declaration.
            **kwargs:
                Can be used to initialize member variables at construction,
                Just pass an argument expression of the form <member>=<value>
                per member that you want to initialize.
        """
        ulonglong3.__allocate(&self._ptr)
        self._is_ptr_owner = True
        attribs = self.PROPERTIES()
        used_attribs = set()
        if len(args) > len(attribs):
            raise ValueError("More positional arguments specified than this type has properties.")
        for i,v in enumerate(args):
            setattr(self,attribs[i],v)
            used_attribs.add(attribs[i])
        valid_names = ", ".join(["'"+p+"'" for p in attribs])
        for k,v in kwargs.items():
            if k in used_attribs:
                raise KeyError(f"argument '{k}' has already been specified as positional argument.")
            elif k not in attribs:
                raise KeyError(f"'{k}' is no valid property name. Valid names: {valid_names}")
            setattr(self,k,v)
    def get_x(self, i):
        """Get value ``x`` of ``(<chip.ulonglong3*>self._ptr)[i]``.
        """
        return (<chip.ulonglong3*>self._ptr)[i].x
    def set_x(self, i, unsigned long long value):
        """Set value ``x`` of ``(<chip.ulonglong3*>self._ptr)[i]``.
        """
        (<chip.ulonglong3*>self._ptr)[i].x = value
    @property
    def x(self):
        """(undocumented)"""
        return self.get_x(0)
    @x.setter
    def x(self, unsigned long long value):
        self.set_x(0,value)

    def get_y(self, i):
        """Get value ``y`` of ``(<chip.ulonglong3*>self._ptr)[i]``.
        """
        return (<chip.ulonglong3*>self._ptr)[i].y
    def set_y(self, i, unsigned long long value):
        """Set value ``y`` of ``(<chip.ulonglong3*>self._ptr)[i]``.
        """
        (<chip.ulonglong3*>self._ptr)[i].y = value
    @property
    def y(self):
        """(undocumented)"""
        return self.get_y(0)
    @y.setter
    def y(self, unsigned long long value):
        self.set_y(0,value)

    def get_z(self, i):
        """Get value ``z`` of ``(<chip.ulonglong3*>self._ptr)[i]``.
        """
        return (<chip.ulonglong3*>self._ptr)[i].z
    def set_z(self, i, unsigned long long value):
        """Set value ``z`` of ``(<chip.ulonglong3*>self._ptr)[i]``.
        """
        (<chip.ulonglong3*>self._ptr)[i].z = value
    @property
    def z(self):
        """(undocumented)"""
        return self.get_z(0)
    @z.setter
    def z(self, unsigned long long value):
        self.set_z(0,value)

    @staticmethod
    def PROPERTIES():
        return ["x","y","z"]

    def __contains__(self,item):
        properties = self.PROPERTIES()
        return item in properties

    def __getitem__(self,item):
        properties = self.PROPERTIES()
        if isinstance(item,int):
            if item < 0 or item >= len(properties):
                raise IndexError()
            return getattr(self,properties[item])
        raise ValueError("'item' type must be 'int'")


cdef class ulonglong4(hip._util.types.Pointer):
    """Python wrapper for cdef class chip.ulonglong4.

    Python wrapper for cdef class chip.ulonglong4.

    If this type is initialized via its `__init__` method, it allocates a
    member of the underlying C type and destroys it again if the wrapper
    type is deallocated.

    This type also serves as adapter when appearing as argument type in a
    function signature. In this case, the type can further be initialized
    from a number of Python objects:

    * `None`:

      This will set the ``self._ptr`` attribute to ``NULL``.

    * `int`:

      Interprets the integer value as pointer address and writes it to ``self._ptr``.
      No ownership is transferred.

    * `ctypes.c_void_p`:

      Takes the pointer address ``pyobj.value`` and writes it to ``self._ptr``.
      No ownership is transferred.

    * `object` that implements the `CUDA Array Interface <https://numba.readthedocs.io/en/stable/cuda/cuda_array_interface.html>`_ protocol:

      Takes the integer-valued pointer address, i.e. the first entry of the `data` tuple
      from `pyobj`'s member ``__cuda_array_interface__``  and writes it to ``self._ptr``.

    * `object` that implements the Python buffer protocol:

      If the object represents a simple contiguous array,
      writes the `Py_buffer` associated with ``pyobj`` to `self._py_buffer`,
      sets the `self._py_buffer_acquired` flag to `True`, and
      writes `self._py_buffer.buf` to the data pointer `self._ptr`.

    * `hip._util.types.Pointer`:

      Takes the pointer address ``pyobj._ptr`` and writes it to ``self._ptr``.
      No ownership is transferred.

    Type checks are performed in the above order.

    C Attributes:
        _ptr (C type ``void *``, protected):
            Stores a pointer to the data of the original Python object.
        _is_ptr_owner (C type ``bint``, protected):
            If this wrapper is the owner of the underlying data.
        _py_buffer (C type ``Py_buffer`, protected):
            Stores a pointer to the data of the original Python object.
        _py_buffer_acquired (C type ``bint``, protected):
            Stores a pointer to the data of the original Python object.
    """
    # C members declared in pxd file

    def __cinit__(self):
        self._ptr = NULL
        self._is_ptr_owner = False
        self._py_buffer_acquired = False

    cdef chip.ulonglong4* getElementPtr(self):
        return <chip.ulonglong4*>self._ptr

    @staticmethod
    cdef ulonglong4 fromPtr(void* ptr, bint owner=False):
        """Factory function to create ``ulonglong4`` objects from
        given ``chip.ulonglong4`` pointer.

        Setting ``owner`` flag to ``True`` causes
        the extension type to free the structure pointed to by ``ptr``
        when the wrapper object is deallocated.
        """
        # Fast call to __new__() that bypasses the __init__() constructor.
        cdef ulonglong4 wrapper = ulonglong4.__new__(ulonglong4)
        wrapper._ptr = ptr
        wrapper._is_ptr_owner = owner
        return wrapper

    @staticmethod
    def fromObj(pyobj):
        """Creates a ulonglong4 from a Python object.

        Derives a ulonglong4 from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``ulonglong4`` reference, this method
        returns it directly. No new ``ulonglong4`` is created in this case.
        """
        return ulonglong4.fromPyobj(pyobj)

    @staticmethod
    cdef ulonglong4 fromPyobj(object pyobj):
        """Creates a ulonglong4 from a Python object.

        Derives a ulonglong4 from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``ulonglong4`` reference, this method
        returns it directly. No new ``ulonglong4`` is created in this case.

        Args:
            pyobj (object): Must be either `None`; a `hip._util.types.Pointer`; a simple, contiguous buffer according to the buffer protocol;
                            or of type `ulonglong4`; `int`; or `ctypes.c_void_p`.

        Note:
            This routine does not perform a copy but returns the original ``pyobj``
            if ``pyobj`` is an instance of ulonglong4!
        """
        cdef ulonglong4 wrapper

        if isinstance(pyobj,ulonglong4):
            return pyobj
        else:
            wrapper = ulonglong4.__new__(ulonglong4)
            wrapper.init_from_pyobj(pyobj)
            return wrapper

    def __dealloc__(self):
        # Release the buffer handle
        if self._py_buffer_acquired is True:
            cpython.buffer.PyBuffer_Release(&self._py_buffer)
        # De-allocate if not null and flag is set
        if self._ptr is not NULL and self._is_ptr_owner is True:
            stdlib.free(self._ptr)
            self._ptr = NULL

    @staticmethod
    cdef __allocate(void** ptr):
        ptr[0] = stdlib.malloc(sizeof(chip.ulonglong4))
        string.memset(<void*>ptr[0], 0, sizeof(chip.ulonglong4))

        if ptr[0] is NULL:
            raise MemoryError

    @staticmethod
    cdef ulonglong4 new():
        """Factory function to create ulonglong4 objects with
        newly allocated chip.ulonglong4"""
        cdef void* ptr
        ulonglong4.__allocate(&ptr)
        return ulonglong4.fromPtr(ptr, owner=True)

    @staticmethod
    cdef ulonglong4 fromValue(chip.ulonglong4 other):
        """Allocate new C type and copy from ``other``.
        """
        wrapper = ulonglong4.new()
        string.memcpy(wrapper._ptr, &other, sizeof(chip.ulonglong4))
        return wrapper

    def c_sizeof(self):
        """Returns the size of the underlying C type in bytes.
        Note:
            Implemented as function to not collide with
            autogenerated property names.
        """
        return sizeof(chip.ulonglong4)

    def __int__(self):
        """Returns the data's address as long integer.
        """
        return cpython.long.PyLong_FromVoidPtr(self._ptr)

    def __repr__(self):
        return f"<ulonglong4 object, ptr: {int(self)}>"

    def as_c_void_p(self):
        """Returns the data's address as `ctypes.c_void_p`
        Note:
            Implemented as function to not collide with
            autogenerated property names.
        """
        return ctypes.c_void_p(int(self))

    def __init__(self,*args,**kwargs):
        """Constructor type ulonglong4.

        Constructor for type ulonglong4.

        Args:
            *args:
                Positional arguments. Initialize all or a subset of the member variables
                according to their order of declaration.
            **kwargs:
                Can be used to initialize member variables at construction,
                Just pass an argument expression of the form <member>=<value>
                per member that you want to initialize.
        """
        ulonglong4.__allocate(&self._ptr)
        self._is_ptr_owner = True
        attribs = self.PROPERTIES()
        used_attribs = set()
        if len(args) > len(attribs):
            raise ValueError("More positional arguments specified than this type has properties.")
        for i,v in enumerate(args):
            setattr(self,attribs[i],v)
            used_attribs.add(attribs[i])
        valid_names = ", ".join(["'"+p+"'" for p in attribs])
        for k,v in kwargs.items():
            if k in used_attribs:
                raise KeyError(f"argument '{k}' has already been specified as positional argument.")
            elif k not in attribs:
                raise KeyError(f"'{k}' is no valid property name. Valid names: {valid_names}")
            setattr(self,k,v)
    def get_x(self, i):
        """Get value ``x`` of ``(<chip.ulonglong4*>self._ptr)[i]``.
        """
        return (<chip.ulonglong4*>self._ptr)[i].x
    def set_x(self, i, unsigned long long value):
        """Set value ``x`` of ``(<chip.ulonglong4*>self._ptr)[i]``.
        """
        (<chip.ulonglong4*>self._ptr)[i].x = value
    @property
    def x(self):
        """(undocumented)"""
        return self.get_x(0)
    @x.setter
    def x(self, unsigned long long value):
        self.set_x(0,value)

    def get_y(self, i):
        """Get value ``y`` of ``(<chip.ulonglong4*>self._ptr)[i]``.
        """
        return (<chip.ulonglong4*>self._ptr)[i].y
    def set_y(self, i, unsigned long long value):
        """Set value ``y`` of ``(<chip.ulonglong4*>self._ptr)[i]``.
        """
        (<chip.ulonglong4*>self._ptr)[i].y = value
    @property
    def y(self):
        """(undocumented)"""
        return self.get_y(0)
    @y.setter
    def y(self, unsigned long long value):
        self.set_y(0,value)

    def get_z(self, i):
        """Get value ``z`` of ``(<chip.ulonglong4*>self._ptr)[i]``.
        """
        return (<chip.ulonglong4*>self._ptr)[i].z
    def set_z(self, i, unsigned long long value):
        """Set value ``z`` of ``(<chip.ulonglong4*>self._ptr)[i]``.
        """
        (<chip.ulonglong4*>self._ptr)[i].z = value
    @property
    def z(self):
        """(undocumented)"""
        return self.get_z(0)
    @z.setter
    def z(self, unsigned long long value):
        self.set_z(0,value)

    def get_w(self, i):
        """Get value ``w`` of ``(<chip.ulonglong4*>self._ptr)[i]``.
        """
        return (<chip.ulonglong4*>self._ptr)[i].w
    def set_w(self, i, unsigned long long value):
        """Set value ``w`` of ``(<chip.ulonglong4*>self._ptr)[i]``.
        """
        (<chip.ulonglong4*>self._ptr)[i].w = value
    @property
    def w(self):
        """(undocumented)"""
        return self.get_w(0)
    @w.setter
    def w(self, unsigned long long value):
        self.set_w(0,value)

    @staticmethod
    def PROPERTIES():
        return ["x","y","z","w"]

    def __contains__(self,item):
        properties = self.PROPERTIES()
        return item in properties

    def __getitem__(self,item):
        properties = self.PROPERTIES()
        if isinstance(item,int):
            if item < 0 or item >= len(properties):
                raise IndexError()
            return getattr(self,properties[item])
        raise ValueError("'item' type must be 'int'")


cdef class longlong1(hip._util.types.Pointer):
    """Python wrapper for cdef class chip.longlong1.

    Python wrapper for cdef class chip.longlong1.

    If this type is initialized via its `__init__` method, it allocates a
    member of the underlying C type and destroys it again if the wrapper
    type is deallocated.

    This type also serves as adapter when appearing as argument type in a
    function signature. In this case, the type can further be initialized
    from a number of Python objects:

    * `None`:

      This will set the ``self._ptr`` attribute to ``NULL``.

    * `int`:

      Interprets the integer value as pointer address and writes it to ``self._ptr``.
      No ownership is transferred.

    * `ctypes.c_void_p`:

      Takes the pointer address ``pyobj.value`` and writes it to ``self._ptr``.
      No ownership is transferred.

    * `object` that implements the `CUDA Array Interface <https://numba.readthedocs.io/en/stable/cuda/cuda_array_interface.html>`_ protocol:

      Takes the integer-valued pointer address, i.e. the first entry of the `data` tuple
      from `pyobj`'s member ``__cuda_array_interface__``  and writes it to ``self._ptr``.

    * `object` that implements the Python buffer protocol:

      If the object represents a simple contiguous array,
      writes the `Py_buffer` associated with ``pyobj`` to `self._py_buffer`,
      sets the `self._py_buffer_acquired` flag to `True`, and
      writes `self._py_buffer.buf` to the data pointer `self._ptr`.

    * `hip._util.types.Pointer`:

      Takes the pointer address ``pyobj._ptr`` and writes it to ``self._ptr``.
      No ownership is transferred.

    Type checks are performed in the above order.

    C Attributes:
        _ptr (C type ``void *``, protected):
            Stores a pointer to the data of the original Python object.
        _is_ptr_owner (C type ``bint``, protected):
            If this wrapper is the owner of the underlying data.
        _py_buffer (C type ``Py_buffer`, protected):
            Stores a pointer to the data of the original Python object.
        _py_buffer_acquired (C type ``bint``, protected):
            Stores a pointer to the data of the original Python object.
    """
    # C members declared in pxd file

    def __cinit__(self):
        self._ptr = NULL
        self._is_ptr_owner = False
        self._py_buffer_acquired = False

    cdef chip.longlong1* getElementPtr(self):
        return <chip.longlong1*>self._ptr

    @staticmethod
    cdef longlong1 fromPtr(void* ptr, bint owner=False):
        """Factory function to create ``longlong1`` objects from
        given ``chip.longlong1`` pointer.

        Setting ``owner`` flag to ``True`` causes
        the extension type to free the structure pointed to by ``ptr``
        when the wrapper object is deallocated.
        """
        # Fast call to __new__() that bypasses the __init__() constructor.
        cdef longlong1 wrapper = longlong1.__new__(longlong1)
        wrapper._ptr = ptr
        wrapper._is_ptr_owner = owner
        return wrapper

    @staticmethod
    def fromObj(pyobj):
        """Creates a longlong1 from a Python object.

        Derives a longlong1 from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``longlong1`` reference, this method
        returns it directly. No new ``longlong1`` is created in this case.
        """
        return longlong1.fromPyobj(pyobj)

    @staticmethod
    cdef longlong1 fromPyobj(object pyobj):
        """Creates a longlong1 from a Python object.

        Derives a longlong1 from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``longlong1`` reference, this method
        returns it directly. No new ``longlong1`` is created in this case.

        Args:
            pyobj (object): Must be either `None`; a `hip._util.types.Pointer`; a simple, contiguous buffer according to the buffer protocol;
                            or of type `longlong1`; `int`; or `ctypes.c_void_p`.

        Note:
            This routine does not perform a copy but returns the original ``pyobj``
            if ``pyobj`` is an instance of longlong1!
        """
        cdef longlong1 wrapper

        if isinstance(pyobj,longlong1):
            return pyobj
        else:
            wrapper = longlong1.__new__(longlong1)
            wrapper.init_from_pyobj(pyobj)
            return wrapper

    def __dealloc__(self):
        # Release the buffer handle
        if self._py_buffer_acquired is True:
            cpython.buffer.PyBuffer_Release(&self._py_buffer)
        # De-allocate if not null and flag is set
        if self._ptr is not NULL and self._is_ptr_owner is True:
            stdlib.free(self._ptr)
            self._ptr = NULL

    @staticmethod
    cdef __allocate(void** ptr):
        ptr[0] = stdlib.malloc(sizeof(chip.longlong1))
        string.memset(<void*>ptr[0], 0, sizeof(chip.longlong1))

        if ptr[0] is NULL:
            raise MemoryError

    @staticmethod
    cdef longlong1 new():
        """Factory function to create longlong1 objects with
        newly allocated chip.longlong1"""
        cdef void* ptr
        longlong1.__allocate(&ptr)
        return longlong1.fromPtr(ptr, owner=True)

    @staticmethod
    cdef longlong1 fromValue(chip.longlong1 other):
        """Allocate new C type and copy from ``other``.
        """
        wrapper = longlong1.new()
        string.memcpy(wrapper._ptr, &other, sizeof(chip.longlong1))
        return wrapper

    def c_sizeof(self):
        """Returns the size of the underlying C type in bytes.
        Note:
            Implemented as function to not collide with
            autogenerated property names.
        """
        return sizeof(chip.longlong1)

    def __int__(self):
        """Returns the data's address as long integer.
        """
        return cpython.long.PyLong_FromVoidPtr(self._ptr)

    def __repr__(self):
        return f"<longlong1 object, ptr: {int(self)}>"

    def as_c_void_p(self):
        """Returns the data's address as `ctypes.c_void_p`
        Note:
            Implemented as function to not collide with
            autogenerated property names.
        """
        return ctypes.c_void_p(int(self))

    def __init__(self,*args,**kwargs):
        """Constructor type longlong1.

        Constructor for type longlong1.

        Args:
            *args:
                Positional arguments. Initialize all or a subset of the member variables
                according to their order of declaration.
            **kwargs:
                Can be used to initialize member variables at construction,
                Just pass an argument expression of the form <member>=<value>
                per member that you want to initialize.
        """
        longlong1.__allocate(&self._ptr)
        self._is_ptr_owner = True
        attribs = self.PROPERTIES()
        used_attribs = set()
        if len(args) > len(attribs):
            raise ValueError("More positional arguments specified than this type has properties.")
        for i,v in enumerate(args):
            setattr(self,attribs[i],v)
            used_attribs.add(attribs[i])
        valid_names = ", ".join(["'"+p+"'" for p in attribs])
        for k,v in kwargs.items():
            if k in used_attribs:
                raise KeyError(f"argument '{k}' has already been specified as positional argument.")
            elif k not in attribs:
                raise KeyError(f"'{k}' is no valid property name. Valid names: {valid_names}")
            setattr(self,k,v)
    def get_x(self, i):
        """Get value ``x`` of ``(<chip.longlong1*>self._ptr)[i]``.
        """
        return (<chip.longlong1*>self._ptr)[i].x
    def set_x(self, i, long long value):
        """Set value ``x`` of ``(<chip.longlong1*>self._ptr)[i]``.
        """
        (<chip.longlong1*>self._ptr)[i].x = value
    @property
    def x(self):
        """(undocumented)"""
        return self.get_x(0)
    @x.setter
    def x(self, long long value):
        self.set_x(0,value)

    @staticmethod
    def PROPERTIES():
        return ["x"]

    def __contains__(self,item):
        properties = self.PROPERTIES()
        return item in properties

    def __getitem__(self,item):
        properties = self.PROPERTIES()
        if isinstance(item,int):
            if item < 0 or item >= len(properties):
                raise IndexError()
            return getattr(self,properties[item])
        raise ValueError("'item' type must be 'int'")


cdef class longlong2(hip._util.types.Pointer):
    """Python wrapper for cdef class chip.longlong2.

    Python wrapper for cdef class chip.longlong2.

    If this type is initialized via its `__init__` method, it allocates a
    member of the underlying C type and destroys it again if the wrapper
    type is deallocated.

    This type also serves as adapter when appearing as argument type in a
    function signature. In this case, the type can further be initialized
    from a number of Python objects:

    * `None`:

      This will set the ``self._ptr`` attribute to ``NULL``.

    * `int`:

      Interprets the integer value as pointer address and writes it to ``self._ptr``.
      No ownership is transferred.

    * `ctypes.c_void_p`:

      Takes the pointer address ``pyobj.value`` and writes it to ``self._ptr``.
      No ownership is transferred.

    * `object` that implements the `CUDA Array Interface <https://numba.readthedocs.io/en/stable/cuda/cuda_array_interface.html>`_ protocol:

      Takes the integer-valued pointer address, i.e. the first entry of the `data` tuple
      from `pyobj`'s member ``__cuda_array_interface__``  and writes it to ``self._ptr``.

    * `object` that implements the Python buffer protocol:

      If the object represents a simple contiguous array,
      writes the `Py_buffer` associated with ``pyobj`` to `self._py_buffer`,
      sets the `self._py_buffer_acquired` flag to `True`, and
      writes `self._py_buffer.buf` to the data pointer `self._ptr`.

    * `hip._util.types.Pointer`:

      Takes the pointer address ``pyobj._ptr`` and writes it to ``self._ptr``.
      No ownership is transferred.

    Type checks are performed in the above order.

    C Attributes:
        _ptr (C type ``void *``, protected):
            Stores a pointer to the data of the original Python object.
        _is_ptr_owner (C type ``bint``, protected):
            If this wrapper is the owner of the underlying data.
        _py_buffer (C type ``Py_buffer`, protected):
            Stores a pointer to the data of the original Python object.
        _py_buffer_acquired (C type ``bint``, protected):
            Stores a pointer to the data of the original Python object.
    """
    # C members declared in pxd file

    def __cinit__(self):
        self._ptr = NULL
        self._is_ptr_owner = False
        self._py_buffer_acquired = False

    cdef chip.longlong2* getElementPtr(self):
        return <chip.longlong2*>self._ptr

    @staticmethod
    cdef longlong2 fromPtr(void* ptr, bint owner=False):
        """Factory function to create ``longlong2`` objects from
        given ``chip.longlong2`` pointer.

        Setting ``owner`` flag to ``True`` causes
        the extension type to free the structure pointed to by ``ptr``
        when the wrapper object is deallocated.
        """
        # Fast call to __new__() that bypasses the __init__() constructor.
        cdef longlong2 wrapper = longlong2.__new__(longlong2)
        wrapper._ptr = ptr
        wrapper._is_ptr_owner = owner
        return wrapper

    @staticmethod
    def fromObj(pyobj):
        """Creates a longlong2 from a Python object.

        Derives a longlong2 from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``longlong2`` reference, this method
        returns it directly. No new ``longlong2`` is created in this case.
        """
        return longlong2.fromPyobj(pyobj)

    @staticmethod
    cdef longlong2 fromPyobj(object pyobj):
        """Creates a longlong2 from a Python object.

        Derives a longlong2 from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``longlong2`` reference, this method
        returns it directly. No new ``longlong2`` is created in this case.

        Args:
            pyobj (object): Must be either `None`; a `hip._util.types.Pointer`; a simple, contiguous buffer according to the buffer protocol;
                            or of type `longlong2`; `int`; or `ctypes.c_void_p`.

        Note:
            This routine does not perform a copy but returns the original ``pyobj``
            if ``pyobj`` is an instance of longlong2!
        """
        cdef longlong2 wrapper

        if isinstance(pyobj,longlong2):
            return pyobj
        else:
            wrapper = longlong2.__new__(longlong2)
            wrapper.init_from_pyobj(pyobj)
            return wrapper

    def __dealloc__(self):
        # Release the buffer handle
        if self._py_buffer_acquired is True:
            cpython.buffer.PyBuffer_Release(&self._py_buffer)
        # De-allocate if not null and flag is set
        if self._ptr is not NULL and self._is_ptr_owner is True:
            stdlib.free(self._ptr)
            self._ptr = NULL

    @staticmethod
    cdef __allocate(void** ptr):
        ptr[0] = stdlib.malloc(sizeof(chip.longlong2))
        string.memset(<void*>ptr[0], 0, sizeof(chip.longlong2))

        if ptr[0] is NULL:
            raise MemoryError

    @staticmethod
    cdef longlong2 new():
        """Factory function to create longlong2 objects with
        newly allocated chip.longlong2"""
        cdef void* ptr
        longlong2.__allocate(&ptr)
        return longlong2.fromPtr(ptr, owner=True)

    @staticmethod
    cdef longlong2 fromValue(chip.longlong2 other):
        """Allocate new C type and copy from ``other``.
        """
        wrapper = longlong2.new()
        string.memcpy(wrapper._ptr, &other, sizeof(chip.longlong2))
        return wrapper

    def c_sizeof(self):
        """Returns the size of the underlying C type in bytes.
        Note:
            Implemented as function to not collide with
            autogenerated property names.
        """
        return sizeof(chip.longlong2)

    def __int__(self):
        """Returns the data's address as long integer.
        """
        return cpython.long.PyLong_FromVoidPtr(self._ptr)

    def __repr__(self):
        return f"<longlong2 object, ptr: {int(self)}>"

    def as_c_void_p(self):
        """Returns the data's address as `ctypes.c_void_p`
        Note:
            Implemented as function to not collide with
            autogenerated property names.
        """
        return ctypes.c_void_p(int(self))

    def __init__(self,*args,**kwargs):
        """Constructor type longlong2.

        Constructor for type longlong2.

        Args:
            *args:
                Positional arguments. Initialize all or a subset of the member variables
                according to their order of declaration.
            **kwargs:
                Can be used to initialize member variables at construction,
                Just pass an argument expression of the form <member>=<value>
                per member that you want to initialize.
        """
        longlong2.__allocate(&self._ptr)
        self._is_ptr_owner = True
        attribs = self.PROPERTIES()
        used_attribs = set()
        if len(args) > len(attribs):
            raise ValueError("More positional arguments specified than this type has properties.")
        for i,v in enumerate(args):
            setattr(self,attribs[i],v)
            used_attribs.add(attribs[i])
        valid_names = ", ".join(["'"+p+"'" for p in attribs])
        for k,v in kwargs.items():
            if k in used_attribs:
                raise KeyError(f"argument '{k}' has already been specified as positional argument.")
            elif k not in attribs:
                raise KeyError(f"'{k}' is no valid property name. Valid names: {valid_names}")
            setattr(self,k,v)
    def get_x(self, i):
        """Get value ``x`` of ``(<chip.longlong2*>self._ptr)[i]``.
        """
        return (<chip.longlong2*>self._ptr)[i].x
    def set_x(self, i, long long value):
        """Set value ``x`` of ``(<chip.longlong2*>self._ptr)[i]``.
        """
        (<chip.longlong2*>self._ptr)[i].x = value
    @property
    def x(self):
        """(undocumented)"""
        return self.get_x(0)
    @x.setter
    def x(self, long long value):
        self.set_x(0,value)

    def get_y(self, i):
        """Get value ``y`` of ``(<chip.longlong2*>self._ptr)[i]``.
        """
        return (<chip.longlong2*>self._ptr)[i].y
    def set_y(self, i, long long value):
        """Set value ``y`` of ``(<chip.longlong2*>self._ptr)[i]``.
        """
        (<chip.longlong2*>self._ptr)[i].y = value
    @property
    def y(self):
        """(undocumented)"""
        return self.get_y(0)
    @y.setter
    def y(self, long long value):
        self.set_y(0,value)

    @staticmethod
    def PROPERTIES():
        return ["x","y"]

    def __contains__(self,item):
        properties = self.PROPERTIES()
        return item in properties

    def __getitem__(self,item):
        properties = self.PROPERTIES()
        if isinstance(item,int):
            if item < 0 or item >= len(properties):
                raise IndexError()
            return getattr(self,properties[item])
        raise ValueError("'item' type must be 'int'")


cdef class longlong3(hip._util.types.Pointer):
    """Python wrapper for cdef class chip.longlong3.

    Python wrapper for cdef class chip.longlong3.

    If this type is initialized via its `__init__` method, it allocates a
    member of the underlying C type and destroys it again if the wrapper
    type is deallocated.

    This type also serves as adapter when appearing as argument type in a
    function signature. In this case, the type can further be initialized
    from a number of Python objects:

    * `None`:

      This will set the ``self._ptr`` attribute to ``NULL``.

    * `int`:

      Interprets the integer value as pointer address and writes it to ``self._ptr``.
      No ownership is transferred.

    * `ctypes.c_void_p`:

      Takes the pointer address ``pyobj.value`` and writes it to ``self._ptr``.
      No ownership is transferred.

    * `object` that implements the `CUDA Array Interface <https://numba.readthedocs.io/en/stable/cuda/cuda_array_interface.html>`_ protocol:

      Takes the integer-valued pointer address, i.e. the first entry of the `data` tuple
      from `pyobj`'s member ``__cuda_array_interface__``  and writes it to ``self._ptr``.

    * `object` that implements the Python buffer protocol:

      If the object represents a simple contiguous array,
      writes the `Py_buffer` associated with ``pyobj`` to `self._py_buffer`,
      sets the `self._py_buffer_acquired` flag to `True`, and
      writes `self._py_buffer.buf` to the data pointer `self._ptr`.

    * `hip._util.types.Pointer`:

      Takes the pointer address ``pyobj._ptr`` and writes it to ``self._ptr``.
      No ownership is transferred.

    Type checks are performed in the above order.

    C Attributes:
        _ptr (C type ``void *``, protected):
            Stores a pointer to the data of the original Python object.
        _is_ptr_owner (C type ``bint``, protected):
            If this wrapper is the owner of the underlying data.
        _py_buffer (C type ``Py_buffer`, protected):
            Stores a pointer to the data of the original Python object.
        _py_buffer_acquired (C type ``bint``, protected):
            Stores a pointer to the data of the original Python object.
    """
    # C members declared in pxd file

    def __cinit__(self):
        self._ptr = NULL
        self._is_ptr_owner = False
        self._py_buffer_acquired = False

    cdef chip.longlong3* getElementPtr(self):
        return <chip.longlong3*>self._ptr

    @staticmethod
    cdef longlong3 fromPtr(void* ptr, bint owner=False):
        """Factory function to create ``longlong3`` objects from
        given ``chip.longlong3`` pointer.

        Setting ``owner`` flag to ``True`` causes
        the extension type to free the structure pointed to by ``ptr``
        when the wrapper object is deallocated.
        """
        # Fast call to __new__() that bypasses the __init__() constructor.
        cdef longlong3 wrapper = longlong3.__new__(longlong3)
        wrapper._ptr = ptr
        wrapper._is_ptr_owner = owner
        return wrapper

    @staticmethod
    def fromObj(pyobj):
        """Creates a longlong3 from a Python object.

        Derives a longlong3 from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``longlong3`` reference, this method
        returns it directly. No new ``longlong3`` is created in this case.
        """
        return longlong3.fromPyobj(pyobj)

    @staticmethod
    cdef longlong3 fromPyobj(object pyobj):
        """Creates a longlong3 from a Python object.

        Derives a longlong3 from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``longlong3`` reference, this method
        returns it directly. No new ``longlong3`` is created in this case.

        Args:
            pyobj (object): Must be either `None`; a `hip._util.types.Pointer`; a simple, contiguous buffer according to the buffer protocol;
                            or of type `longlong3`; `int`; or `ctypes.c_void_p`.

        Note:
            This routine does not perform a copy but returns the original ``pyobj``
            if ``pyobj`` is an instance of longlong3!
        """
        cdef longlong3 wrapper

        if isinstance(pyobj,longlong3):
            return pyobj
        else:
            wrapper = longlong3.__new__(longlong3)
            wrapper.init_from_pyobj(pyobj)
            return wrapper

    def __dealloc__(self):
        # Release the buffer handle
        if self._py_buffer_acquired is True:
            cpython.buffer.PyBuffer_Release(&self._py_buffer)
        # De-allocate if not null and flag is set
        if self._ptr is not NULL and self._is_ptr_owner is True:
            stdlib.free(self._ptr)
            self._ptr = NULL

    @staticmethod
    cdef __allocate(void** ptr):
        ptr[0] = stdlib.malloc(sizeof(chip.longlong3))
        string.memset(<void*>ptr[0], 0, sizeof(chip.longlong3))

        if ptr[0] is NULL:
            raise MemoryError

    @staticmethod
    cdef longlong3 new():
        """Factory function to create longlong3 objects with
        newly allocated chip.longlong3"""
        cdef void* ptr
        longlong3.__allocate(&ptr)
        return longlong3.fromPtr(ptr, owner=True)

    @staticmethod
    cdef longlong3 fromValue(chip.longlong3 other):
        """Allocate new C type and copy from ``other``.
        """
        wrapper = longlong3.new()
        string.memcpy(wrapper._ptr, &other, sizeof(chip.longlong3))
        return wrapper

    def c_sizeof(self):
        """Returns the size of the underlying C type in bytes.
        Note:
            Implemented as function to not collide with
            autogenerated property names.
        """
        return sizeof(chip.longlong3)

    def __int__(self):
        """Returns the data's address as long integer.
        """
        return cpython.long.PyLong_FromVoidPtr(self._ptr)

    def __repr__(self):
        return f"<longlong3 object, ptr: {int(self)}>"

    def as_c_void_p(self):
        """Returns the data's address as `ctypes.c_void_p`
        Note:
            Implemented as function to not collide with
            autogenerated property names.
        """
        return ctypes.c_void_p(int(self))

    def __init__(self,*args,**kwargs):
        """Constructor type longlong3.

        Constructor for type longlong3.

        Args:
            *args:
                Positional arguments. Initialize all or a subset of the member variables
                according to their order of declaration.
            **kwargs:
                Can be used to initialize member variables at construction,
                Just pass an argument expression of the form <member>=<value>
                per member that you want to initialize.
        """
        longlong3.__allocate(&self._ptr)
        self._is_ptr_owner = True
        attribs = self.PROPERTIES()
        used_attribs = set()
        if len(args) > len(attribs):
            raise ValueError("More positional arguments specified than this type has properties.")
        for i,v in enumerate(args):
            setattr(self,attribs[i],v)
            used_attribs.add(attribs[i])
        valid_names = ", ".join(["'"+p+"'" for p in attribs])
        for k,v in kwargs.items():
            if k in used_attribs:
                raise KeyError(f"argument '{k}' has already been specified as positional argument.")
            elif k not in attribs:
                raise KeyError(f"'{k}' is no valid property name. Valid names: {valid_names}")
            setattr(self,k,v)
    def get_x(self, i):
        """Get value ``x`` of ``(<chip.longlong3*>self._ptr)[i]``.
        """
        return (<chip.longlong3*>self._ptr)[i].x
    def set_x(self, i, long long value):
        """Set value ``x`` of ``(<chip.longlong3*>self._ptr)[i]``.
        """
        (<chip.longlong3*>self._ptr)[i].x = value
    @property
    def x(self):
        """(undocumented)"""
        return self.get_x(0)
    @x.setter
    def x(self, long long value):
        self.set_x(0,value)

    def get_y(self, i):
        """Get value ``y`` of ``(<chip.longlong3*>self._ptr)[i]``.
        """
        return (<chip.longlong3*>self._ptr)[i].y
    def set_y(self, i, long long value):
        """Set value ``y`` of ``(<chip.longlong3*>self._ptr)[i]``.
        """
        (<chip.longlong3*>self._ptr)[i].y = value
    @property
    def y(self):
        """(undocumented)"""
        return self.get_y(0)
    @y.setter
    def y(self, long long value):
        self.set_y(0,value)

    def get_z(self, i):
        """Get value ``z`` of ``(<chip.longlong3*>self._ptr)[i]``.
        """
        return (<chip.longlong3*>self._ptr)[i].z
    def set_z(self, i, long long value):
        """Set value ``z`` of ``(<chip.longlong3*>self._ptr)[i]``.
        """
        (<chip.longlong3*>self._ptr)[i].z = value
    @property
    def z(self):
        """(undocumented)"""
        return self.get_z(0)
    @z.setter
    def z(self, long long value):
        self.set_z(0,value)

    @staticmethod
    def PROPERTIES():
        return ["x","y","z"]

    def __contains__(self,item):
        properties = self.PROPERTIES()
        return item in properties

    def __getitem__(self,item):
        properties = self.PROPERTIES()
        if isinstance(item,int):
            if item < 0 or item >= len(properties):
                raise IndexError()
            return getattr(self,properties[item])
        raise ValueError("'item' type must be 'int'")


cdef class longlong4(hip._util.types.Pointer):
    """Python wrapper for cdef class chip.longlong4.

    Python wrapper for cdef class chip.longlong4.

    If this type is initialized via its `__init__` method, it allocates a
    member of the underlying C type and destroys it again if the wrapper
    type is deallocated.

    This type also serves as adapter when appearing as argument type in a
    function signature. In this case, the type can further be initialized
    from a number of Python objects:

    * `None`:

      This will set the ``self._ptr`` attribute to ``NULL``.

    * `int`:

      Interprets the integer value as pointer address and writes it to ``self._ptr``.
      No ownership is transferred.

    * `ctypes.c_void_p`:

      Takes the pointer address ``pyobj.value`` and writes it to ``self._ptr``.
      No ownership is transferred.

    * `object` that implements the `CUDA Array Interface <https://numba.readthedocs.io/en/stable/cuda/cuda_array_interface.html>`_ protocol:

      Takes the integer-valued pointer address, i.e. the first entry of the `data` tuple
      from `pyobj`'s member ``__cuda_array_interface__``  and writes it to ``self._ptr``.

    * `object` that implements the Python buffer protocol:

      If the object represents a simple contiguous array,
      writes the `Py_buffer` associated with ``pyobj`` to `self._py_buffer`,
      sets the `self._py_buffer_acquired` flag to `True`, and
      writes `self._py_buffer.buf` to the data pointer `self._ptr`.

    * `hip._util.types.Pointer`:

      Takes the pointer address ``pyobj._ptr`` and writes it to ``self._ptr``.
      No ownership is transferred.

    Type checks are performed in the above order.

    C Attributes:
        _ptr (C type ``void *``, protected):
            Stores a pointer to the data of the original Python object.
        _is_ptr_owner (C type ``bint``, protected):
            If this wrapper is the owner of the underlying data.
        _py_buffer (C type ``Py_buffer`, protected):
            Stores a pointer to the data of the original Python object.
        _py_buffer_acquired (C type ``bint``, protected):
            Stores a pointer to the data of the original Python object.
    """
    # C members declared in pxd file

    def __cinit__(self):
        self._ptr = NULL
        self._is_ptr_owner = False
        self._py_buffer_acquired = False

    cdef chip.longlong4* getElementPtr(self):
        return <chip.longlong4*>self._ptr

    @staticmethod
    cdef longlong4 fromPtr(void* ptr, bint owner=False):
        """Factory function to create ``longlong4`` objects from
        given ``chip.longlong4`` pointer.

        Setting ``owner`` flag to ``True`` causes
        the extension type to free the structure pointed to by ``ptr``
        when the wrapper object is deallocated.
        """
        # Fast call to __new__() that bypasses the __init__() constructor.
        cdef longlong4 wrapper = longlong4.__new__(longlong4)
        wrapper._ptr = ptr
        wrapper._is_ptr_owner = owner
        return wrapper

    @staticmethod
    def fromObj(pyobj):
        """Creates a longlong4 from a Python object.

        Derives a longlong4 from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``longlong4`` reference, this method
        returns it directly. No new ``longlong4`` is created in this case.
        """
        return longlong4.fromPyobj(pyobj)

    @staticmethod
    cdef longlong4 fromPyobj(object pyobj):
        """Creates a longlong4 from a Python object.

        Derives a longlong4 from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``longlong4`` reference, this method
        returns it directly. No new ``longlong4`` is created in this case.

        Args:
            pyobj (object): Must be either `None`; a `hip._util.types.Pointer`; a simple, contiguous buffer according to the buffer protocol;
                            or of type `longlong4`; `int`; or `ctypes.c_void_p`.

        Note:
            This routine does not perform a copy but returns the original ``pyobj``
            if ``pyobj`` is an instance of longlong4!
        """
        cdef longlong4 wrapper

        if isinstance(pyobj,longlong4):
            return pyobj
        else:
            wrapper = longlong4.__new__(longlong4)
            wrapper.init_from_pyobj(pyobj)
            return wrapper

    def __dealloc__(self):
        # Release the buffer handle
        if self._py_buffer_acquired is True:
            cpython.buffer.PyBuffer_Release(&self._py_buffer)
        # De-allocate if not null and flag is set
        if self._ptr is not NULL and self._is_ptr_owner is True:
            stdlib.free(self._ptr)
            self._ptr = NULL

    @staticmethod
    cdef __allocate(void** ptr):
        ptr[0] = stdlib.malloc(sizeof(chip.longlong4))
        string.memset(<void*>ptr[0], 0, sizeof(chip.longlong4))

        if ptr[0] is NULL:
            raise MemoryError

    @staticmethod
    cdef longlong4 new():
        """Factory function to create longlong4 objects with
        newly allocated chip.longlong4"""
        cdef void* ptr
        longlong4.__allocate(&ptr)
        return longlong4.fromPtr(ptr, owner=True)

    @staticmethod
    cdef longlong4 fromValue(chip.longlong4 other):
        """Allocate new C type and copy from ``other``.
        """
        wrapper = longlong4.new()
        string.memcpy(wrapper._ptr, &other, sizeof(chip.longlong4))
        return wrapper

    def c_sizeof(self):
        """Returns the size of the underlying C type in bytes.
        Note:
            Implemented as function to not collide with
            autogenerated property names.
        """
        return sizeof(chip.longlong4)

    def __int__(self):
        """Returns the data's address as long integer.
        """
        return cpython.long.PyLong_FromVoidPtr(self._ptr)

    def __repr__(self):
        return f"<longlong4 object, ptr: {int(self)}>"

    def as_c_void_p(self):
        """Returns the data's address as `ctypes.c_void_p`
        Note:
            Implemented as function to not collide with
            autogenerated property names.
        """
        return ctypes.c_void_p(int(self))

    def __init__(self,*args,**kwargs):
        """Constructor type longlong4.

        Constructor for type longlong4.

        Args:
            *args:
                Positional arguments. Initialize all or a subset of the member variables
                according to their order of declaration.
            **kwargs:
                Can be used to initialize member variables at construction,
                Just pass an argument expression of the form <member>=<value>
                per member that you want to initialize.
        """
        longlong4.__allocate(&self._ptr)
        self._is_ptr_owner = True
        attribs = self.PROPERTIES()
        used_attribs = set()
        if len(args) > len(attribs):
            raise ValueError("More positional arguments specified than this type has properties.")
        for i,v in enumerate(args):
            setattr(self,attribs[i],v)
            used_attribs.add(attribs[i])
        valid_names = ", ".join(["'"+p+"'" for p in attribs])
        for k,v in kwargs.items():
            if k in used_attribs:
                raise KeyError(f"argument '{k}' has already been specified as positional argument.")
            elif k not in attribs:
                raise KeyError(f"'{k}' is no valid property name. Valid names: {valid_names}")
            setattr(self,k,v)
    def get_x(self, i):
        """Get value ``x`` of ``(<chip.longlong4*>self._ptr)[i]``.
        """
        return (<chip.longlong4*>self._ptr)[i].x
    def set_x(self, i, long long value):
        """Set value ``x`` of ``(<chip.longlong4*>self._ptr)[i]``.
        """
        (<chip.longlong4*>self._ptr)[i].x = value
    @property
    def x(self):
        """(undocumented)"""
        return self.get_x(0)
    @x.setter
    def x(self, long long value):
        self.set_x(0,value)

    def get_y(self, i):
        """Get value ``y`` of ``(<chip.longlong4*>self._ptr)[i]``.
        """
        return (<chip.longlong4*>self._ptr)[i].y
    def set_y(self, i, long long value):
        """Set value ``y`` of ``(<chip.longlong4*>self._ptr)[i]``.
        """
        (<chip.longlong4*>self._ptr)[i].y = value
    @property
    def y(self):
        """(undocumented)"""
        return self.get_y(0)
    @y.setter
    def y(self, long long value):
        self.set_y(0,value)

    def get_z(self, i):
        """Get value ``z`` of ``(<chip.longlong4*>self._ptr)[i]``.
        """
        return (<chip.longlong4*>self._ptr)[i].z
    def set_z(self, i, long long value):
        """Set value ``z`` of ``(<chip.longlong4*>self._ptr)[i]``.
        """
        (<chip.longlong4*>self._ptr)[i].z = value
    @property
    def z(self):
        """(undocumented)"""
        return self.get_z(0)
    @z.setter
    def z(self, long long value):
        self.set_z(0,value)

    def get_w(self, i):
        """Get value ``w`` of ``(<chip.longlong4*>self._ptr)[i]``.
        """
        return (<chip.longlong4*>self._ptr)[i].w
    def set_w(self, i, long long value):
        """Set value ``w`` of ``(<chip.longlong4*>self._ptr)[i]``.
        """
        (<chip.longlong4*>self._ptr)[i].w = value
    @property
    def w(self):
        """(undocumented)"""
        return self.get_w(0)
    @w.setter
    def w(self, long long value):
        self.set_w(0,value)

    @staticmethod
    def PROPERTIES():
        return ["x","y","z","w"]

    def __contains__(self,item):
        properties = self.PROPERTIES()
        return item in properties

    def __getitem__(self,item):
        properties = self.PROPERTIES()
        if isinstance(item,int):
            if item < 0 or item >= len(properties):
                raise IndexError()
            return getattr(self,properties[item])
        raise ValueError("'item' type must be 'int'")


cdef class float1(hip._util.types.Pointer):
    """Python wrapper for cdef class chip.float1.

    Python wrapper for cdef class chip.float1.

    If this type is initialized via its `__init__` method, it allocates a
    member of the underlying C type and destroys it again if the wrapper
    type is deallocated.

    This type also serves as adapter when appearing as argument type in a
    function signature. In this case, the type can further be initialized
    from a number of Python objects:

    * `None`:

      This will set the ``self._ptr`` attribute to ``NULL``.

    * `int`:

      Interprets the integer value as pointer address and writes it to ``self._ptr``.
      No ownership is transferred.

    * `ctypes.c_void_p`:

      Takes the pointer address ``pyobj.value`` and writes it to ``self._ptr``.
      No ownership is transferred.

    * `object` that implements the `CUDA Array Interface <https://numba.readthedocs.io/en/stable/cuda/cuda_array_interface.html>`_ protocol:

      Takes the integer-valued pointer address, i.e. the first entry of the `data` tuple
      from `pyobj`'s member ``__cuda_array_interface__``  and writes it to ``self._ptr``.

    * `object` that implements the Python buffer protocol:

      If the object represents a simple contiguous array,
      writes the `Py_buffer` associated with ``pyobj`` to `self._py_buffer`,
      sets the `self._py_buffer_acquired` flag to `True`, and
      writes `self._py_buffer.buf` to the data pointer `self._ptr`.

    * `hip._util.types.Pointer`:

      Takes the pointer address ``pyobj._ptr`` and writes it to ``self._ptr``.
      No ownership is transferred.

    Type checks are performed in the above order.

    C Attributes:
        _ptr (C type ``void *``, protected):
            Stores a pointer to the data of the original Python object.
        _is_ptr_owner (C type ``bint``, protected):
            If this wrapper is the owner of the underlying data.
        _py_buffer (C type ``Py_buffer`, protected):
            Stores a pointer to the data of the original Python object.
        _py_buffer_acquired (C type ``bint``, protected):
            Stores a pointer to the data of the original Python object.
    """
    # C members declared in pxd file

    def __cinit__(self):
        self._ptr = NULL
        self._is_ptr_owner = False
        self._py_buffer_acquired = False

    cdef chip.float1* getElementPtr(self):
        return <chip.float1*>self._ptr

    @staticmethod
    cdef float1 fromPtr(void* ptr, bint owner=False):
        """Factory function to create ``float1`` objects from
        given ``chip.float1`` pointer.

        Setting ``owner`` flag to ``True`` causes
        the extension type to free the structure pointed to by ``ptr``
        when the wrapper object is deallocated.
        """
        # Fast call to __new__() that bypasses the __init__() constructor.
        cdef float1 wrapper = float1.__new__(float1)
        wrapper._ptr = ptr
        wrapper._is_ptr_owner = owner
        return wrapper

    @staticmethod
    def fromObj(pyobj):
        """Creates a float1 from a Python object.

        Derives a float1 from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``float1`` reference, this method
        returns it directly. No new ``float1`` is created in this case.
        """
        return float1.fromPyobj(pyobj)

    @staticmethod
    cdef float1 fromPyobj(object pyobj):
        """Creates a float1 from a Python object.

        Derives a float1 from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``float1`` reference, this method
        returns it directly. No new ``float1`` is created in this case.

        Args:
            pyobj (object): Must be either `None`; a `hip._util.types.Pointer`; a simple, contiguous buffer according to the buffer protocol;
                            or of type `float1`; `int`; or `ctypes.c_void_p`.

        Note:
            This routine does not perform a copy but returns the original ``pyobj``
            if ``pyobj`` is an instance of float1!
        """
        cdef float1 wrapper

        if isinstance(pyobj,float1):
            return pyobj
        else:
            wrapper = float1.__new__(float1)
            wrapper.init_from_pyobj(pyobj)
            return wrapper

    def __dealloc__(self):
        # Release the buffer handle
        if self._py_buffer_acquired is True:
            cpython.buffer.PyBuffer_Release(&self._py_buffer)
        # De-allocate if not null and flag is set
        if self._ptr is not NULL and self._is_ptr_owner is True:
            stdlib.free(self._ptr)
            self._ptr = NULL

    @staticmethod
    cdef __allocate(void** ptr):
        ptr[0] = stdlib.malloc(sizeof(chip.float1))
        string.memset(<void*>ptr[0], 0, sizeof(chip.float1))

        if ptr[0] is NULL:
            raise MemoryError

    @staticmethod
    cdef float1 new():
        """Factory function to create float1 objects with
        newly allocated chip.float1"""
        cdef void* ptr
        float1.__allocate(&ptr)
        return float1.fromPtr(ptr, owner=True)

    @staticmethod
    cdef float1 fromValue(chip.float1 other):
        """Allocate new C type and copy from ``other``.
        """
        wrapper = float1.new()
        string.memcpy(wrapper._ptr, &other, sizeof(chip.float1))
        return wrapper

    def c_sizeof(self):
        """Returns the size of the underlying C type in bytes.
        Note:
            Implemented as function to not collide with
            autogenerated property names.
        """
        return sizeof(chip.float1)

    def __int__(self):
        """Returns the data's address as long integer.
        """
        return cpython.long.PyLong_FromVoidPtr(self._ptr)

    def __repr__(self):
        return f"<float1 object, ptr: {int(self)}>"

    def as_c_void_p(self):
        """Returns the data's address as `ctypes.c_void_p`
        Note:
            Implemented as function to not collide with
            autogenerated property names.
        """
        return ctypes.c_void_p(int(self))

    def __init__(self,*args,**kwargs):
        """Constructor type float1.

        Constructor for type float1.

        Args:
            *args:
                Positional arguments. Initialize all or a subset of the member variables
                according to their order of declaration.
            **kwargs:
                Can be used to initialize member variables at construction,
                Just pass an argument expression of the form <member>=<value>
                per member that you want to initialize.
        """
        float1.__allocate(&self._ptr)
        self._is_ptr_owner = True
        attribs = self.PROPERTIES()
        used_attribs = set()
        if len(args) > len(attribs):
            raise ValueError("More positional arguments specified than this type has properties.")
        for i,v in enumerate(args):
            setattr(self,attribs[i],v)
            used_attribs.add(attribs[i])
        valid_names = ", ".join(["'"+p+"'" for p in attribs])
        for k,v in kwargs.items():
            if k in used_attribs:
                raise KeyError(f"argument '{k}' has already been specified as positional argument.")
            elif k not in attribs:
                raise KeyError(f"'{k}' is no valid property name. Valid names: {valid_names}")
            setattr(self,k,v)
    def get_x(self, i):
        """Get value ``x`` of ``(<chip.float1*>self._ptr)[i]``.
        """
        return (<chip.float1*>self._ptr)[i].x
    def set_x(self, i, float value):
        """Set value ``x`` of ``(<chip.float1*>self._ptr)[i]``.
        """
        (<chip.float1*>self._ptr)[i].x = value
    @property
    def x(self):
        """(undocumented)"""
        return self.get_x(0)
    @x.setter
    def x(self, float value):
        self.set_x(0,value)

    @staticmethod
    def PROPERTIES():
        return ["x"]

    def __contains__(self,item):
        properties = self.PROPERTIES()
        return item in properties

    def __getitem__(self,item):
        properties = self.PROPERTIES()
        if isinstance(item,int):
            if item < 0 or item >= len(properties):
                raise IndexError()
            return getattr(self,properties[item])
        raise ValueError("'item' type must be 'int'")


cdef class float2(hip._util.types.Pointer):
    """Python wrapper for cdef class chip.float2.

    Python wrapper for cdef class chip.float2.

    If this type is initialized via its `__init__` method, it allocates a
    member of the underlying C type and destroys it again if the wrapper
    type is deallocated.

    This type also serves as adapter when appearing as argument type in a
    function signature. In this case, the type can further be initialized
    from a number of Python objects:

    * `None`:

      This will set the ``self._ptr`` attribute to ``NULL``.

    * `int`:

      Interprets the integer value as pointer address and writes it to ``self._ptr``.
      No ownership is transferred.

    * `ctypes.c_void_p`:

      Takes the pointer address ``pyobj.value`` and writes it to ``self._ptr``.
      No ownership is transferred.

    * `object` that implements the `CUDA Array Interface <https://numba.readthedocs.io/en/stable/cuda/cuda_array_interface.html>`_ protocol:

      Takes the integer-valued pointer address, i.e. the first entry of the `data` tuple
      from `pyobj`'s member ``__cuda_array_interface__``  and writes it to ``self._ptr``.

    * `object` that implements the Python buffer protocol:

      If the object represents a simple contiguous array,
      writes the `Py_buffer` associated with ``pyobj`` to `self._py_buffer`,
      sets the `self._py_buffer_acquired` flag to `True`, and
      writes `self._py_buffer.buf` to the data pointer `self._ptr`.

    * `hip._util.types.Pointer`:

      Takes the pointer address ``pyobj._ptr`` and writes it to ``self._ptr``.
      No ownership is transferred.

    Type checks are performed in the above order.

    C Attributes:
        _ptr (C type ``void *``, protected):
            Stores a pointer to the data of the original Python object.
        _is_ptr_owner (C type ``bint``, protected):
            If this wrapper is the owner of the underlying data.
        _py_buffer (C type ``Py_buffer`, protected):
            Stores a pointer to the data of the original Python object.
        _py_buffer_acquired (C type ``bint``, protected):
            Stores a pointer to the data of the original Python object.
    """
    # C members declared in pxd file

    def __cinit__(self):
        self._ptr = NULL
        self._is_ptr_owner = False
        self._py_buffer_acquired = False

    cdef chip.float2* getElementPtr(self):
        return <chip.float2*>self._ptr

    @staticmethod
    cdef float2 fromPtr(void* ptr, bint owner=False):
        """Factory function to create ``float2`` objects from
        given ``chip.float2`` pointer.

        Setting ``owner`` flag to ``True`` causes
        the extension type to free the structure pointed to by ``ptr``
        when the wrapper object is deallocated.
        """
        # Fast call to __new__() that bypasses the __init__() constructor.
        cdef float2 wrapper = float2.__new__(float2)
        wrapper._ptr = ptr
        wrapper._is_ptr_owner = owner
        return wrapper

    @staticmethod
    def fromObj(pyobj):
        """Creates a float2 from a Python object.

        Derives a float2 from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``float2`` reference, this method
        returns it directly. No new ``float2`` is created in this case.
        """
        return float2.fromPyobj(pyobj)

    @staticmethod
    cdef float2 fromPyobj(object pyobj):
        """Creates a float2 from a Python object.

        Derives a float2 from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``float2`` reference, this method
        returns it directly. No new ``float2`` is created in this case.

        Args:
            pyobj (object): Must be either `None`; a `hip._util.types.Pointer`; a simple, contiguous buffer according to the buffer protocol;
                            or of type `float2`; `int`; or `ctypes.c_void_p`.

        Note:
            This routine does not perform a copy but returns the original ``pyobj``
            if ``pyobj`` is an instance of float2!
        """
        cdef float2 wrapper

        if isinstance(pyobj,float2):
            return pyobj
        else:
            wrapper = float2.__new__(float2)
            wrapper.init_from_pyobj(pyobj)
            return wrapper

    def __dealloc__(self):
        # Release the buffer handle
        if self._py_buffer_acquired is True:
            cpython.buffer.PyBuffer_Release(&self._py_buffer)
        # De-allocate if not null and flag is set
        if self._ptr is not NULL and self._is_ptr_owner is True:
            stdlib.free(self._ptr)
            self._ptr = NULL

    @staticmethod
    cdef __allocate(void** ptr):
        ptr[0] = stdlib.malloc(sizeof(chip.float2))
        string.memset(<void*>ptr[0], 0, sizeof(chip.float2))

        if ptr[0] is NULL:
            raise MemoryError

    @staticmethod
    cdef float2 new():
        """Factory function to create float2 objects with
        newly allocated chip.float2"""
        cdef void* ptr
        float2.__allocate(&ptr)
        return float2.fromPtr(ptr, owner=True)

    @staticmethod
    cdef float2 fromValue(chip.float2 other):
        """Allocate new C type and copy from ``other``.
        """
        wrapper = float2.new()
        string.memcpy(wrapper._ptr, &other, sizeof(chip.float2))
        return wrapper

    def c_sizeof(self):
        """Returns the size of the underlying C type in bytes.
        Note:
            Implemented as function to not collide with
            autogenerated property names.
        """
        return sizeof(chip.float2)

    def __int__(self):
        """Returns the data's address as long integer.
        """
        return cpython.long.PyLong_FromVoidPtr(self._ptr)

    def __repr__(self):
        return f"<float2 object, ptr: {int(self)}>"

    def as_c_void_p(self):
        """Returns the data's address as `ctypes.c_void_p`
        Note:
            Implemented as function to not collide with
            autogenerated property names.
        """
        return ctypes.c_void_p(int(self))

    def __init__(self,*args,**kwargs):
        """Constructor type float2.

        Constructor for type float2.

        Args:
            *args:
                Positional arguments. Initialize all or a subset of the member variables
                according to their order of declaration.
            **kwargs:
                Can be used to initialize member variables at construction,
                Just pass an argument expression of the form <member>=<value>
                per member that you want to initialize.
        """
        float2.__allocate(&self._ptr)
        self._is_ptr_owner = True
        attribs = self.PROPERTIES()
        used_attribs = set()
        if len(args) > len(attribs):
            raise ValueError("More positional arguments specified than this type has properties.")
        for i,v in enumerate(args):
            setattr(self,attribs[i],v)
            used_attribs.add(attribs[i])
        valid_names = ", ".join(["'"+p+"'" for p in attribs])
        for k,v in kwargs.items():
            if k in used_attribs:
                raise KeyError(f"argument '{k}' has already been specified as positional argument.")
            elif k not in attribs:
                raise KeyError(f"'{k}' is no valid property name. Valid names: {valid_names}")
            setattr(self,k,v)
    def get_x(self, i):
        """Get value ``x`` of ``(<chip.float2*>self._ptr)[i]``.
        """
        return (<chip.float2*>self._ptr)[i].x
    def set_x(self, i, float value):
        """Set value ``x`` of ``(<chip.float2*>self._ptr)[i]``.
        """
        (<chip.float2*>self._ptr)[i].x = value
    @property
    def x(self):
        """(undocumented)"""
        return self.get_x(0)
    @x.setter
    def x(self, float value):
        self.set_x(0,value)

    def get_y(self, i):
        """Get value ``y`` of ``(<chip.float2*>self._ptr)[i]``.
        """
        return (<chip.float2*>self._ptr)[i].y
    def set_y(self, i, float value):
        """Set value ``y`` of ``(<chip.float2*>self._ptr)[i]``.
        """
        (<chip.float2*>self._ptr)[i].y = value
    @property
    def y(self):
        """(undocumented)"""
        return self.get_y(0)
    @y.setter
    def y(self, float value):
        self.set_y(0,value)

    @staticmethod
    def PROPERTIES():
        return ["x","y"]

    def __contains__(self,item):
        properties = self.PROPERTIES()
        return item in properties

    def __getitem__(self,item):
        properties = self.PROPERTIES()
        if isinstance(item,int):
            if item < 0 or item >= len(properties):
                raise IndexError()
            return getattr(self,properties[item])
        raise ValueError("'item' type must be 'int'")


cdef class float3(hip._util.types.Pointer):
    """Python wrapper for cdef class chip.float3.

    Python wrapper for cdef class chip.float3.

    If this type is initialized via its `__init__` method, it allocates a
    member of the underlying C type and destroys it again if the wrapper
    type is deallocated.

    This type also serves as adapter when appearing as argument type in a
    function signature. In this case, the type can further be initialized
    from a number of Python objects:

    * `None`:

      This will set the ``self._ptr`` attribute to ``NULL``.

    * `int`:

      Interprets the integer value as pointer address and writes it to ``self._ptr``.
      No ownership is transferred.

    * `ctypes.c_void_p`:

      Takes the pointer address ``pyobj.value`` and writes it to ``self._ptr``.
      No ownership is transferred.

    * `object` that implements the `CUDA Array Interface <https://numba.readthedocs.io/en/stable/cuda/cuda_array_interface.html>`_ protocol:

      Takes the integer-valued pointer address, i.e. the first entry of the `data` tuple
      from `pyobj`'s member ``__cuda_array_interface__``  and writes it to ``self._ptr``.

    * `object` that implements the Python buffer protocol:

      If the object represents a simple contiguous array,
      writes the `Py_buffer` associated with ``pyobj`` to `self._py_buffer`,
      sets the `self._py_buffer_acquired` flag to `True`, and
      writes `self._py_buffer.buf` to the data pointer `self._ptr`.

    * `hip._util.types.Pointer`:

      Takes the pointer address ``pyobj._ptr`` and writes it to ``self._ptr``.
      No ownership is transferred.

    Type checks are performed in the above order.

    C Attributes:
        _ptr (C type ``void *``, protected):
            Stores a pointer to the data of the original Python object.
        _is_ptr_owner (C type ``bint``, protected):
            If this wrapper is the owner of the underlying data.
        _py_buffer (C type ``Py_buffer`, protected):
            Stores a pointer to the data of the original Python object.
        _py_buffer_acquired (C type ``bint``, protected):
            Stores a pointer to the data of the original Python object.
    """
    # C members declared in pxd file

    def __cinit__(self):
        self._ptr = NULL
        self._is_ptr_owner = False
        self._py_buffer_acquired = False

    cdef chip.float3* getElementPtr(self):
        return <chip.float3*>self._ptr

    @staticmethod
    cdef float3 fromPtr(void* ptr, bint owner=False):
        """Factory function to create ``float3`` objects from
        given ``chip.float3`` pointer.

        Setting ``owner`` flag to ``True`` causes
        the extension type to free the structure pointed to by ``ptr``
        when the wrapper object is deallocated.
        """
        # Fast call to __new__() that bypasses the __init__() constructor.
        cdef float3 wrapper = float3.__new__(float3)
        wrapper._ptr = ptr
        wrapper._is_ptr_owner = owner
        return wrapper

    @staticmethod
    def fromObj(pyobj):
        """Creates a float3 from a Python object.

        Derives a float3 from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``float3`` reference, this method
        returns it directly. No new ``float3`` is created in this case.
        """
        return float3.fromPyobj(pyobj)

    @staticmethod
    cdef float3 fromPyobj(object pyobj):
        """Creates a float3 from a Python object.

        Derives a float3 from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``float3`` reference, this method
        returns it directly. No new ``float3`` is created in this case.

        Args:
            pyobj (object): Must be either `None`; a `hip._util.types.Pointer`; a simple, contiguous buffer according to the buffer protocol;
                            or of type `float3`; `int`; or `ctypes.c_void_p`.

        Note:
            This routine does not perform a copy but returns the original ``pyobj``
            if ``pyobj`` is an instance of float3!
        """
        cdef float3 wrapper

        if isinstance(pyobj,float3):
            return pyobj
        else:
            wrapper = float3.__new__(float3)
            wrapper.init_from_pyobj(pyobj)
            return wrapper

    def __dealloc__(self):
        # Release the buffer handle
        if self._py_buffer_acquired is True:
            cpython.buffer.PyBuffer_Release(&self._py_buffer)
        # De-allocate if not null and flag is set
        if self._ptr is not NULL and self._is_ptr_owner is True:
            stdlib.free(self._ptr)
            self._ptr = NULL

    @staticmethod
    cdef __allocate(void** ptr):
        ptr[0] = stdlib.malloc(sizeof(chip.float3))
        string.memset(<void*>ptr[0], 0, sizeof(chip.float3))

        if ptr[0] is NULL:
            raise MemoryError

    @staticmethod
    cdef float3 new():
        """Factory function to create float3 objects with
        newly allocated chip.float3"""
        cdef void* ptr
        float3.__allocate(&ptr)
        return float3.fromPtr(ptr, owner=True)

    @staticmethod
    cdef float3 fromValue(chip.float3 other):
        """Allocate new C type and copy from ``other``.
        """
        wrapper = float3.new()
        string.memcpy(wrapper._ptr, &other, sizeof(chip.float3))
        return wrapper

    def c_sizeof(self):
        """Returns the size of the underlying C type in bytes.
        Note:
            Implemented as function to not collide with
            autogenerated property names.
        """
        return sizeof(chip.float3)

    def __int__(self):
        """Returns the data's address as long integer.
        """
        return cpython.long.PyLong_FromVoidPtr(self._ptr)

    def __repr__(self):
        return f"<float3 object, ptr: {int(self)}>"

    def as_c_void_p(self):
        """Returns the data's address as `ctypes.c_void_p`
        Note:
            Implemented as function to not collide with
            autogenerated property names.
        """
        return ctypes.c_void_p(int(self))

    def __init__(self,*args,**kwargs):
        """Constructor type float3.

        Constructor for type float3.

        Args:
            *args:
                Positional arguments. Initialize all or a subset of the member variables
                according to their order of declaration.
            **kwargs:
                Can be used to initialize member variables at construction,
                Just pass an argument expression of the form <member>=<value>
                per member that you want to initialize.
        """
        float3.__allocate(&self._ptr)
        self._is_ptr_owner = True
        attribs = self.PROPERTIES()
        used_attribs = set()
        if len(args) > len(attribs):
            raise ValueError("More positional arguments specified than this type has properties.")
        for i,v in enumerate(args):
            setattr(self,attribs[i],v)
            used_attribs.add(attribs[i])
        valid_names = ", ".join(["'"+p+"'" for p in attribs])
        for k,v in kwargs.items():
            if k in used_attribs:
                raise KeyError(f"argument '{k}' has already been specified as positional argument.")
            elif k not in attribs:
                raise KeyError(f"'{k}' is no valid property name. Valid names: {valid_names}")
            setattr(self,k,v)
    def get_x(self, i):
        """Get value ``x`` of ``(<chip.float3*>self._ptr)[i]``.
        """
        return (<chip.float3*>self._ptr)[i].x
    def set_x(self, i, float value):
        """Set value ``x`` of ``(<chip.float3*>self._ptr)[i]``.
        """
        (<chip.float3*>self._ptr)[i].x = value
    @property
    def x(self):
        """(undocumented)"""
        return self.get_x(0)
    @x.setter
    def x(self, float value):
        self.set_x(0,value)

    def get_y(self, i):
        """Get value ``y`` of ``(<chip.float3*>self._ptr)[i]``.
        """
        return (<chip.float3*>self._ptr)[i].y
    def set_y(self, i, float value):
        """Set value ``y`` of ``(<chip.float3*>self._ptr)[i]``.
        """
        (<chip.float3*>self._ptr)[i].y = value
    @property
    def y(self):
        """(undocumented)"""
        return self.get_y(0)
    @y.setter
    def y(self, float value):
        self.set_y(0,value)

    def get_z(self, i):
        """Get value ``z`` of ``(<chip.float3*>self._ptr)[i]``.
        """
        return (<chip.float3*>self._ptr)[i].z
    def set_z(self, i, float value):
        """Set value ``z`` of ``(<chip.float3*>self._ptr)[i]``.
        """
        (<chip.float3*>self._ptr)[i].z = value
    @property
    def z(self):
        """(undocumented)"""
        return self.get_z(0)
    @z.setter
    def z(self, float value):
        self.set_z(0,value)

    @staticmethod
    def PROPERTIES():
        return ["x","y","z"]

    def __contains__(self,item):
        properties = self.PROPERTIES()
        return item in properties

    def __getitem__(self,item):
        properties = self.PROPERTIES()
        if isinstance(item,int):
            if item < 0 or item >= len(properties):
                raise IndexError()
            return getattr(self,properties[item])
        raise ValueError("'item' type must be 'int'")


cdef class float4(hip._util.types.Pointer):
    """Python wrapper for cdef class chip.float4.

    Python wrapper for cdef class chip.float4.

    If this type is initialized via its `__init__` method, it allocates a
    member of the underlying C type and destroys it again if the wrapper
    type is deallocated.

    This type also serves as adapter when appearing as argument type in a
    function signature. In this case, the type can further be initialized
    from a number of Python objects:

    * `None`:

      This will set the ``self._ptr`` attribute to ``NULL``.

    * `int`:

      Interprets the integer value as pointer address and writes it to ``self._ptr``.
      No ownership is transferred.

    * `ctypes.c_void_p`:

      Takes the pointer address ``pyobj.value`` and writes it to ``self._ptr``.
      No ownership is transferred.

    * `object` that implements the `CUDA Array Interface <https://numba.readthedocs.io/en/stable/cuda/cuda_array_interface.html>`_ protocol:

      Takes the integer-valued pointer address, i.e. the first entry of the `data` tuple
      from `pyobj`'s member ``__cuda_array_interface__``  and writes it to ``self._ptr``.

    * `object` that implements the Python buffer protocol:

      If the object represents a simple contiguous array,
      writes the `Py_buffer` associated with ``pyobj`` to `self._py_buffer`,
      sets the `self._py_buffer_acquired` flag to `True`, and
      writes `self._py_buffer.buf` to the data pointer `self._ptr`.

    * `hip._util.types.Pointer`:

      Takes the pointer address ``pyobj._ptr`` and writes it to ``self._ptr``.
      No ownership is transferred.

    Type checks are performed in the above order.

    C Attributes:
        _ptr (C type ``void *``, protected):
            Stores a pointer to the data of the original Python object.
        _is_ptr_owner (C type ``bint``, protected):
            If this wrapper is the owner of the underlying data.
        _py_buffer (C type ``Py_buffer`, protected):
            Stores a pointer to the data of the original Python object.
        _py_buffer_acquired (C type ``bint``, protected):
            Stores a pointer to the data of the original Python object.
    """
    # C members declared in pxd file

    def __cinit__(self):
        self._ptr = NULL
        self._is_ptr_owner = False
        self._py_buffer_acquired = False

    cdef chip.float4* getElementPtr(self):
        return <chip.float4*>self._ptr

    @staticmethod
    cdef float4 fromPtr(void* ptr, bint owner=False):
        """Factory function to create ``float4`` objects from
        given ``chip.float4`` pointer.

        Setting ``owner`` flag to ``True`` causes
        the extension type to free the structure pointed to by ``ptr``
        when the wrapper object is deallocated.
        """
        # Fast call to __new__() that bypasses the __init__() constructor.
        cdef float4 wrapper = float4.__new__(float4)
        wrapper._ptr = ptr
        wrapper._is_ptr_owner = owner
        return wrapper

    @staticmethod
    def fromObj(pyobj):
        """Creates a float4 from a Python object.

        Derives a float4 from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``float4`` reference, this method
        returns it directly. No new ``float4`` is created in this case.
        """
        return float4.fromPyobj(pyobj)

    @staticmethod
    cdef float4 fromPyobj(object pyobj):
        """Creates a float4 from a Python object.

        Derives a float4 from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``float4`` reference, this method
        returns it directly. No new ``float4`` is created in this case.

        Args:
            pyobj (object): Must be either `None`; a `hip._util.types.Pointer`; a simple, contiguous buffer according to the buffer protocol;
                            or of type `float4`; `int`; or `ctypes.c_void_p`.

        Note:
            This routine does not perform a copy but returns the original ``pyobj``
            if ``pyobj`` is an instance of float4!
        """
        cdef float4 wrapper

        if isinstance(pyobj,float4):
            return pyobj
        else:
            wrapper = float4.__new__(float4)
            wrapper.init_from_pyobj(pyobj)
            return wrapper

    def __dealloc__(self):
        # Release the buffer handle
        if self._py_buffer_acquired is True:
            cpython.buffer.PyBuffer_Release(&self._py_buffer)
        # De-allocate if not null and flag is set
        if self._ptr is not NULL and self._is_ptr_owner is True:
            stdlib.free(self._ptr)
            self._ptr = NULL

    @staticmethod
    cdef __allocate(void** ptr):
        ptr[0] = stdlib.malloc(sizeof(chip.float4))
        string.memset(<void*>ptr[0], 0, sizeof(chip.float4))

        if ptr[0] is NULL:
            raise MemoryError

    @staticmethod
    cdef float4 new():
        """Factory function to create float4 objects with
        newly allocated chip.float4"""
        cdef void* ptr
        float4.__allocate(&ptr)
        return float4.fromPtr(ptr, owner=True)

    @staticmethod
    cdef float4 fromValue(chip.float4 other):
        """Allocate new C type and copy from ``other``.
        """
        wrapper = float4.new()
        string.memcpy(wrapper._ptr, &other, sizeof(chip.float4))
        return wrapper

    def c_sizeof(self):
        """Returns the size of the underlying C type in bytes.
        Note:
            Implemented as function to not collide with
            autogenerated property names.
        """
        return sizeof(chip.float4)

    def __int__(self):
        """Returns the data's address as long integer.
        """
        return cpython.long.PyLong_FromVoidPtr(self._ptr)

    def __repr__(self):
        return f"<float4 object, ptr: {int(self)}>"

    def as_c_void_p(self):
        """Returns the data's address as `ctypes.c_void_p`
        Note:
            Implemented as function to not collide with
            autogenerated property names.
        """
        return ctypes.c_void_p(int(self))

    def __init__(self,*args,**kwargs):
        """Constructor type float4.

        Constructor for type float4.

        Args:
            *args:
                Positional arguments. Initialize all or a subset of the member variables
                according to their order of declaration.
            **kwargs:
                Can be used to initialize member variables at construction,
                Just pass an argument expression of the form <member>=<value>
                per member that you want to initialize.
        """
        float4.__allocate(&self._ptr)
        self._is_ptr_owner = True
        attribs = self.PROPERTIES()
        used_attribs = set()
        if len(args) > len(attribs):
            raise ValueError("More positional arguments specified than this type has properties.")
        for i,v in enumerate(args):
            setattr(self,attribs[i],v)
            used_attribs.add(attribs[i])
        valid_names = ", ".join(["'"+p+"'" for p in attribs])
        for k,v in kwargs.items():
            if k in used_attribs:
                raise KeyError(f"argument '{k}' has already been specified as positional argument.")
            elif k not in attribs:
                raise KeyError(f"'{k}' is no valid property name. Valid names: {valid_names}")
            setattr(self,k,v)
    def get_x(self, i):
        """Get value ``x`` of ``(<chip.float4*>self._ptr)[i]``.
        """
        return (<chip.float4*>self._ptr)[i].x
    def set_x(self, i, float value):
        """Set value ``x`` of ``(<chip.float4*>self._ptr)[i]``.
        """
        (<chip.float4*>self._ptr)[i].x = value
    @property
    def x(self):
        """(undocumented)"""
        return self.get_x(0)
    @x.setter
    def x(self, float value):
        self.set_x(0,value)

    def get_y(self, i):
        """Get value ``y`` of ``(<chip.float4*>self._ptr)[i]``.
        """
        return (<chip.float4*>self._ptr)[i].y
    def set_y(self, i, float value):
        """Set value ``y`` of ``(<chip.float4*>self._ptr)[i]``.
        """
        (<chip.float4*>self._ptr)[i].y = value
    @property
    def y(self):
        """(undocumented)"""
        return self.get_y(0)
    @y.setter
    def y(self, float value):
        self.set_y(0,value)

    def get_z(self, i):
        """Get value ``z`` of ``(<chip.float4*>self._ptr)[i]``.
        """
        return (<chip.float4*>self._ptr)[i].z
    def set_z(self, i, float value):
        """Set value ``z`` of ``(<chip.float4*>self._ptr)[i]``.
        """
        (<chip.float4*>self._ptr)[i].z = value
    @property
    def z(self):
        """(undocumented)"""
        return self.get_z(0)
    @z.setter
    def z(self, float value):
        self.set_z(0,value)

    def get_w(self, i):
        """Get value ``w`` of ``(<chip.float4*>self._ptr)[i]``.
        """
        return (<chip.float4*>self._ptr)[i].w
    def set_w(self, i, float value):
        """Set value ``w`` of ``(<chip.float4*>self._ptr)[i]``.
        """
        (<chip.float4*>self._ptr)[i].w = value
    @property
    def w(self):
        """(undocumented)"""
        return self.get_w(0)
    @w.setter
    def w(self, float value):
        self.set_w(0,value)

    @staticmethod
    def PROPERTIES():
        return ["x","y","z","w"]

    def __contains__(self,item):
        properties = self.PROPERTIES()
        return item in properties

    def __getitem__(self,item):
        properties = self.PROPERTIES()
        if isinstance(item,int):
            if item < 0 or item >= len(properties):
                raise IndexError()
            return getattr(self,properties[item])
        raise ValueError("'item' type must be 'int'")


cdef class double1(hip._util.types.Pointer):
    """Python wrapper for cdef class chip.double1.

    Python wrapper for cdef class chip.double1.

    If this type is initialized via its `__init__` method, it allocates a
    member of the underlying C type and destroys it again if the wrapper
    type is deallocated.

    This type also serves as adapter when appearing as argument type in a
    function signature. In this case, the type can further be initialized
    from a number of Python objects:

    * `None`:

      This will set the ``self._ptr`` attribute to ``NULL``.

    * `int`:

      Interprets the integer value as pointer address and writes it to ``self._ptr``.
      No ownership is transferred.

    * `ctypes.c_void_p`:

      Takes the pointer address ``pyobj.value`` and writes it to ``self._ptr``.
      No ownership is transferred.

    * `object` that implements the `CUDA Array Interface <https://numba.readthedocs.io/en/stable/cuda/cuda_array_interface.html>`_ protocol:

      Takes the integer-valued pointer address, i.e. the first entry of the `data` tuple
      from `pyobj`'s member ``__cuda_array_interface__``  and writes it to ``self._ptr``.

    * `object` that implements the Python buffer protocol:

      If the object represents a simple contiguous array,
      writes the `Py_buffer` associated with ``pyobj`` to `self._py_buffer`,
      sets the `self._py_buffer_acquired` flag to `True`, and
      writes `self._py_buffer.buf` to the data pointer `self._ptr`.

    * `hip._util.types.Pointer`:

      Takes the pointer address ``pyobj._ptr`` and writes it to ``self._ptr``.
      No ownership is transferred.

    Type checks are performed in the above order.

    C Attributes:
        _ptr (C type ``void *``, protected):
            Stores a pointer to the data of the original Python object.
        _is_ptr_owner (C type ``bint``, protected):
            If this wrapper is the owner of the underlying data.
        _py_buffer (C type ``Py_buffer`, protected):
            Stores a pointer to the data of the original Python object.
        _py_buffer_acquired (C type ``bint``, protected):
            Stores a pointer to the data of the original Python object.
    """
    # C members declared in pxd file

    def __cinit__(self):
        self._ptr = NULL
        self._is_ptr_owner = False
        self._py_buffer_acquired = False

    cdef chip.double1* getElementPtr(self):
        return <chip.double1*>self._ptr

    @staticmethod
    cdef double1 fromPtr(void* ptr, bint owner=False):
        """Factory function to create ``double1`` objects from
        given ``chip.double1`` pointer.

        Setting ``owner`` flag to ``True`` causes
        the extension type to free the structure pointed to by ``ptr``
        when the wrapper object is deallocated.
        """
        # Fast call to __new__() that bypasses the __init__() constructor.
        cdef double1 wrapper = double1.__new__(double1)
        wrapper._ptr = ptr
        wrapper._is_ptr_owner = owner
        return wrapper

    @staticmethod
    def fromObj(pyobj):
        """Creates a double1 from a Python object.

        Derives a double1 from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``double1`` reference, this method
        returns it directly. No new ``double1`` is created in this case.
        """
        return double1.fromPyobj(pyobj)

    @staticmethod
    cdef double1 fromPyobj(object pyobj):
        """Creates a double1 from a Python object.

        Derives a double1 from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``double1`` reference, this method
        returns it directly. No new ``double1`` is created in this case.

        Args:
            pyobj (object): Must be either `None`; a `hip._util.types.Pointer`; a simple, contiguous buffer according to the buffer protocol;
                            or of type `double1`; `int`; or `ctypes.c_void_p`.

        Note:
            This routine does not perform a copy but returns the original ``pyobj``
            if ``pyobj`` is an instance of double1!
        """
        cdef double1 wrapper

        if isinstance(pyobj,double1):
            return pyobj
        else:
            wrapper = double1.__new__(double1)
            wrapper.init_from_pyobj(pyobj)
            return wrapper

    def __dealloc__(self):
        # Release the buffer handle
        if self._py_buffer_acquired is True:
            cpython.buffer.PyBuffer_Release(&self._py_buffer)
        # De-allocate if not null and flag is set
        if self._ptr is not NULL and self._is_ptr_owner is True:
            stdlib.free(self._ptr)
            self._ptr = NULL

    @staticmethod
    cdef __allocate(void** ptr):
        ptr[0] = stdlib.malloc(sizeof(chip.double1))
        string.memset(<void*>ptr[0], 0, sizeof(chip.double1))

        if ptr[0] is NULL:
            raise MemoryError

    @staticmethod
    cdef double1 new():
        """Factory function to create double1 objects with
        newly allocated chip.double1"""
        cdef void* ptr
        double1.__allocate(&ptr)
        return double1.fromPtr(ptr, owner=True)

    @staticmethod
    cdef double1 fromValue(chip.double1 other):
        """Allocate new C type and copy from ``other``.
        """
        wrapper = double1.new()
        string.memcpy(wrapper._ptr, &other, sizeof(chip.double1))
        return wrapper

    def c_sizeof(self):
        """Returns the size of the underlying C type in bytes.
        Note:
            Implemented as function to not collide with
            autogenerated property names.
        """
        return sizeof(chip.double1)

    def __int__(self):
        """Returns the data's address as long integer.
        """
        return cpython.long.PyLong_FromVoidPtr(self._ptr)

    def __repr__(self):
        return f"<double1 object, ptr: {int(self)}>"

    def as_c_void_p(self):
        """Returns the data's address as `ctypes.c_void_p`
        Note:
            Implemented as function to not collide with
            autogenerated property names.
        """
        return ctypes.c_void_p(int(self))

    def __init__(self,*args,**kwargs):
        """Constructor type double1.

        Constructor for type double1.

        Args:
            *args:
                Positional arguments. Initialize all or a subset of the member variables
                according to their order of declaration.
            **kwargs:
                Can be used to initialize member variables at construction,
                Just pass an argument expression of the form <member>=<value>
                per member that you want to initialize.
        """
        double1.__allocate(&self._ptr)
        self._is_ptr_owner = True
        attribs = self.PROPERTIES()
        used_attribs = set()
        if len(args) > len(attribs):
            raise ValueError("More positional arguments specified than this type has properties.")
        for i,v in enumerate(args):
            setattr(self,attribs[i],v)
            used_attribs.add(attribs[i])
        valid_names = ", ".join(["'"+p+"'" for p in attribs])
        for k,v in kwargs.items():
            if k in used_attribs:
                raise KeyError(f"argument '{k}' has already been specified as positional argument.")
            elif k not in attribs:
                raise KeyError(f"'{k}' is no valid property name. Valid names: {valid_names}")
            setattr(self,k,v)
    def get_x(self, i):
        """Get value ``x`` of ``(<chip.double1*>self._ptr)[i]``.
        """
        return (<chip.double1*>self._ptr)[i].x
    def set_x(self, i, double value):
        """Set value ``x`` of ``(<chip.double1*>self._ptr)[i]``.
        """
        (<chip.double1*>self._ptr)[i].x = value
    @property
    def x(self):
        """(undocumented)"""
        return self.get_x(0)
    @x.setter
    def x(self, double value):
        self.set_x(0,value)

    @staticmethod
    def PROPERTIES():
        return ["x"]

    def __contains__(self,item):
        properties = self.PROPERTIES()
        return item in properties

    def __getitem__(self,item):
        properties = self.PROPERTIES()
        if isinstance(item,int):
            if item < 0 or item >= len(properties):
                raise IndexError()
            return getattr(self,properties[item])
        raise ValueError("'item' type must be 'int'")


cdef class double2(hip._util.types.Pointer):
    """Python wrapper for cdef class chip.double2.

    Python wrapper for cdef class chip.double2.

    If this type is initialized via its `__init__` method, it allocates a
    member of the underlying C type and destroys it again if the wrapper
    type is deallocated.

    This type also serves as adapter when appearing as argument type in a
    function signature. In this case, the type can further be initialized
    from a number of Python objects:

    * `None`:

      This will set the ``self._ptr`` attribute to ``NULL``.

    * `int`:

      Interprets the integer value as pointer address and writes it to ``self._ptr``.
      No ownership is transferred.

    * `ctypes.c_void_p`:

      Takes the pointer address ``pyobj.value`` and writes it to ``self._ptr``.
      No ownership is transferred.

    * `object` that implements the `CUDA Array Interface <https://numba.readthedocs.io/en/stable/cuda/cuda_array_interface.html>`_ protocol:

      Takes the integer-valued pointer address, i.e. the first entry of the `data` tuple
      from `pyobj`'s member ``__cuda_array_interface__``  and writes it to ``self._ptr``.

    * `object` that implements the Python buffer protocol:

      If the object represents a simple contiguous array,
      writes the `Py_buffer` associated with ``pyobj`` to `self._py_buffer`,
      sets the `self._py_buffer_acquired` flag to `True`, and
      writes `self._py_buffer.buf` to the data pointer `self._ptr`.

    * `hip._util.types.Pointer`:

      Takes the pointer address ``pyobj._ptr`` and writes it to ``self._ptr``.
      No ownership is transferred.

    Type checks are performed in the above order.

    C Attributes:
        _ptr (C type ``void *``, protected):
            Stores a pointer to the data of the original Python object.
        _is_ptr_owner (C type ``bint``, protected):
            If this wrapper is the owner of the underlying data.
        _py_buffer (C type ``Py_buffer`, protected):
            Stores a pointer to the data of the original Python object.
        _py_buffer_acquired (C type ``bint``, protected):
            Stores a pointer to the data of the original Python object.
    """
    # C members declared in pxd file

    def __cinit__(self):
        self._ptr = NULL
        self._is_ptr_owner = False
        self._py_buffer_acquired = False

    cdef chip.double2* getElementPtr(self):
        return <chip.double2*>self._ptr

    @staticmethod
    cdef double2 fromPtr(void* ptr, bint owner=False):
        """Factory function to create ``double2`` objects from
        given ``chip.double2`` pointer.

        Setting ``owner`` flag to ``True`` causes
        the extension type to free the structure pointed to by ``ptr``
        when the wrapper object is deallocated.
        """
        # Fast call to __new__() that bypasses the __init__() constructor.
        cdef double2 wrapper = double2.__new__(double2)
        wrapper._ptr = ptr
        wrapper._is_ptr_owner = owner
        return wrapper

    @staticmethod
    def fromObj(pyobj):
        """Creates a double2 from a Python object.

        Derives a double2 from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``double2`` reference, this method
        returns it directly. No new ``double2`` is created in this case.
        """
        return double2.fromPyobj(pyobj)

    @staticmethod
    cdef double2 fromPyobj(object pyobj):
        """Creates a double2 from a Python object.

        Derives a double2 from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``double2`` reference, this method
        returns it directly. No new ``double2`` is created in this case.

        Args:
            pyobj (object): Must be either `None`; a `hip._util.types.Pointer`; a simple, contiguous buffer according to the buffer protocol;
                            or of type `double2`; `int`; or `ctypes.c_void_p`.

        Note:
            This routine does not perform a copy but returns the original ``pyobj``
            if ``pyobj`` is an instance of double2!
        """
        cdef double2 wrapper

        if isinstance(pyobj,double2):
            return pyobj
        else:
            wrapper = double2.__new__(double2)
            wrapper.init_from_pyobj(pyobj)
            return wrapper

    def __dealloc__(self):
        # Release the buffer handle
        if self._py_buffer_acquired is True:
            cpython.buffer.PyBuffer_Release(&self._py_buffer)
        # De-allocate if not null and flag is set
        if self._ptr is not NULL and self._is_ptr_owner is True:
            stdlib.free(self._ptr)
            self._ptr = NULL

    @staticmethod
    cdef __allocate(void** ptr):
        ptr[0] = stdlib.malloc(sizeof(chip.double2))
        string.memset(<void*>ptr[0], 0, sizeof(chip.double2))

        if ptr[0] is NULL:
            raise MemoryError

    @staticmethod
    cdef double2 new():
        """Factory function to create double2 objects with
        newly allocated chip.double2"""
        cdef void* ptr
        double2.__allocate(&ptr)
        return double2.fromPtr(ptr, owner=True)

    @staticmethod
    cdef double2 fromValue(chip.double2 other):
        """Allocate new C type and copy from ``other``.
        """
        wrapper = double2.new()
        string.memcpy(wrapper._ptr, &other, sizeof(chip.double2))
        return wrapper

    def c_sizeof(self):
        """Returns the size of the underlying C type in bytes.
        Note:
            Implemented as function to not collide with
            autogenerated property names.
        """
        return sizeof(chip.double2)

    def __int__(self):
        """Returns the data's address as long integer.
        """
        return cpython.long.PyLong_FromVoidPtr(self._ptr)

    def __repr__(self):
        return f"<double2 object, ptr: {int(self)}>"

    def as_c_void_p(self):
        """Returns the data's address as `ctypes.c_void_p`
        Note:
            Implemented as function to not collide with
            autogenerated property names.
        """
        return ctypes.c_void_p(int(self))

    def __init__(self,*args,**kwargs):
        """Constructor type double2.

        Constructor for type double2.

        Args:
            *args:
                Positional arguments. Initialize all or a subset of the member variables
                according to their order of declaration.
            **kwargs:
                Can be used to initialize member variables at construction,
                Just pass an argument expression of the form <member>=<value>
                per member that you want to initialize.
        """
        double2.__allocate(&self._ptr)
        self._is_ptr_owner = True
        attribs = self.PROPERTIES()
        used_attribs = set()
        if len(args) > len(attribs):
            raise ValueError("More positional arguments specified than this type has properties.")
        for i,v in enumerate(args):
            setattr(self,attribs[i],v)
            used_attribs.add(attribs[i])
        valid_names = ", ".join(["'"+p+"'" for p in attribs])
        for k,v in kwargs.items():
            if k in used_attribs:
                raise KeyError(f"argument '{k}' has already been specified as positional argument.")
            elif k not in attribs:
                raise KeyError(f"'{k}' is no valid property name. Valid names: {valid_names}")
            setattr(self,k,v)
    def get_x(self, i):
        """Get value ``x`` of ``(<chip.double2*>self._ptr)[i]``.
        """
        return (<chip.double2*>self._ptr)[i].x
    def set_x(self, i, double value):
        """Set value ``x`` of ``(<chip.double2*>self._ptr)[i]``.
        """
        (<chip.double2*>self._ptr)[i].x = value
    @property
    def x(self):
        """(undocumented)"""
        return self.get_x(0)
    @x.setter
    def x(self, double value):
        self.set_x(0,value)

    def get_y(self, i):
        """Get value ``y`` of ``(<chip.double2*>self._ptr)[i]``.
        """
        return (<chip.double2*>self._ptr)[i].y
    def set_y(self, i, double value):
        """Set value ``y`` of ``(<chip.double2*>self._ptr)[i]``.
        """
        (<chip.double2*>self._ptr)[i].y = value
    @property
    def y(self):
        """(undocumented)"""
        return self.get_y(0)
    @y.setter
    def y(self, double value):
        self.set_y(0,value)

    @staticmethod
    def PROPERTIES():
        return ["x","y"]

    def __contains__(self,item):
        properties = self.PROPERTIES()
        return item in properties

    def __getitem__(self,item):
        properties = self.PROPERTIES()
        if isinstance(item,int):
            if item < 0 or item >= len(properties):
                raise IndexError()
            return getattr(self,properties[item])
        raise ValueError("'item' type must be 'int'")


cdef class double3(hip._util.types.Pointer):
    """Python wrapper for cdef class chip.double3.

    Python wrapper for cdef class chip.double3.

    If this type is initialized via its `__init__` method, it allocates a
    member of the underlying C type and destroys it again if the wrapper
    type is deallocated.

    This type also serves as adapter when appearing as argument type in a
    function signature. In this case, the type can further be initialized
    from a number of Python objects:

    * `None`:

      This will set the ``self._ptr`` attribute to ``NULL``.

    * `int`:

      Interprets the integer value as pointer address and writes it to ``self._ptr``.
      No ownership is transferred.

    * `ctypes.c_void_p`:

      Takes the pointer address ``pyobj.value`` and writes it to ``self._ptr``.
      No ownership is transferred.

    * `object` that implements the `CUDA Array Interface <https://numba.readthedocs.io/en/stable/cuda/cuda_array_interface.html>`_ protocol:

      Takes the integer-valued pointer address, i.e. the first entry of the `data` tuple
      from `pyobj`'s member ``__cuda_array_interface__``  and writes it to ``self._ptr``.

    * `object` that implements the Python buffer protocol:

      If the object represents a simple contiguous array,
      writes the `Py_buffer` associated with ``pyobj`` to `self._py_buffer`,
      sets the `self._py_buffer_acquired` flag to `True`, and
      writes `self._py_buffer.buf` to the data pointer `self._ptr`.

    * `hip._util.types.Pointer`:

      Takes the pointer address ``pyobj._ptr`` and writes it to ``self._ptr``.
      No ownership is transferred.

    Type checks are performed in the above order.

    C Attributes:
        _ptr (C type ``void *``, protected):
            Stores a pointer to the data of the original Python object.
        _is_ptr_owner (C type ``bint``, protected):
            If this wrapper is the owner of the underlying data.
        _py_buffer (C type ``Py_buffer`, protected):
            Stores a pointer to the data of the original Python object.
        _py_buffer_acquired (C type ``bint``, protected):
            Stores a pointer to the data of the original Python object.
    """
    # C members declared in pxd file

    def __cinit__(self):
        self._ptr = NULL
        self._is_ptr_owner = False
        self._py_buffer_acquired = False

    cdef chip.double3* getElementPtr(self):
        return <chip.double3*>self._ptr

    @staticmethod
    cdef double3 fromPtr(void* ptr, bint owner=False):
        """Factory function to create ``double3`` objects from
        given ``chip.double3`` pointer.

        Setting ``owner`` flag to ``True`` causes
        the extension type to free the structure pointed to by ``ptr``
        when the wrapper object is deallocated.
        """
        # Fast call to __new__() that bypasses the __init__() constructor.
        cdef double3 wrapper = double3.__new__(double3)
        wrapper._ptr = ptr
        wrapper._is_ptr_owner = owner
        return wrapper

    @staticmethod
    def fromObj(pyobj):
        """Creates a double3 from a Python object.

        Derives a double3 from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``double3`` reference, this method
        returns it directly. No new ``double3`` is created in this case.
        """
        return double3.fromPyobj(pyobj)

    @staticmethod
    cdef double3 fromPyobj(object pyobj):
        """Creates a double3 from a Python object.

        Derives a double3 from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``double3`` reference, this method
        returns it directly. No new ``double3`` is created in this case.

        Args:
            pyobj (object): Must be either `None`; a `hip._util.types.Pointer`; a simple, contiguous buffer according to the buffer protocol;
                            or of type `double3`; `int`; or `ctypes.c_void_p`.

        Note:
            This routine does not perform a copy but returns the original ``pyobj``
            if ``pyobj`` is an instance of double3!
        """
        cdef double3 wrapper

        if isinstance(pyobj,double3):
            return pyobj
        else:
            wrapper = double3.__new__(double3)
            wrapper.init_from_pyobj(pyobj)
            return wrapper

    def __dealloc__(self):
        # Release the buffer handle
        if self._py_buffer_acquired is True:
            cpython.buffer.PyBuffer_Release(&self._py_buffer)
        # De-allocate if not null and flag is set
        if self._ptr is not NULL and self._is_ptr_owner is True:
            stdlib.free(self._ptr)
            self._ptr = NULL

    @staticmethod
    cdef __allocate(void** ptr):
        ptr[0] = stdlib.malloc(sizeof(chip.double3))
        string.memset(<void*>ptr[0], 0, sizeof(chip.double3))

        if ptr[0] is NULL:
            raise MemoryError

    @staticmethod
    cdef double3 new():
        """Factory function to create double3 objects with
        newly allocated chip.double3"""
        cdef void* ptr
        double3.__allocate(&ptr)
        return double3.fromPtr(ptr, owner=True)

    @staticmethod
    cdef double3 fromValue(chip.double3 other):
        """Allocate new C type and copy from ``other``.
        """
        wrapper = double3.new()
        string.memcpy(wrapper._ptr, &other, sizeof(chip.double3))
        return wrapper

    def c_sizeof(self):
        """Returns the size of the underlying C type in bytes.
        Note:
            Implemented as function to not collide with
            autogenerated property names.
        """
        return sizeof(chip.double3)

    def __int__(self):
        """Returns the data's address as long integer.
        """
        return cpython.long.PyLong_FromVoidPtr(self._ptr)

    def __repr__(self):
        return f"<double3 object, ptr: {int(self)}>"

    def as_c_void_p(self):
        """Returns the data's address as `ctypes.c_void_p`
        Note:
            Implemented as function to not collide with
            autogenerated property names.
        """
        return ctypes.c_void_p(int(self))

    def __init__(self,*args,**kwargs):
        """Constructor type double3.

        Constructor for type double3.

        Args:
            *args:
                Positional arguments. Initialize all or a subset of the member variables
                according to their order of declaration.
            **kwargs:
                Can be used to initialize member variables at construction,
                Just pass an argument expression of the form <member>=<value>
                per member that you want to initialize.
        """
        double3.__allocate(&self._ptr)
        self._is_ptr_owner = True
        attribs = self.PROPERTIES()
        used_attribs = set()
        if len(args) > len(attribs):
            raise ValueError("More positional arguments specified than this type has properties.")
        for i,v in enumerate(args):
            setattr(self,attribs[i],v)
            used_attribs.add(attribs[i])
        valid_names = ", ".join(["'"+p+"'" for p in attribs])
        for k,v in kwargs.items():
            if k in used_attribs:
                raise KeyError(f"argument '{k}' has already been specified as positional argument.")
            elif k not in attribs:
                raise KeyError(f"'{k}' is no valid property name. Valid names: {valid_names}")
            setattr(self,k,v)
    def get_x(self, i):
        """Get value ``x`` of ``(<chip.double3*>self._ptr)[i]``.
        """
        return (<chip.double3*>self._ptr)[i].x
    def set_x(self, i, double value):
        """Set value ``x`` of ``(<chip.double3*>self._ptr)[i]``.
        """
        (<chip.double3*>self._ptr)[i].x = value
    @property
    def x(self):
        """(undocumented)"""
        return self.get_x(0)
    @x.setter
    def x(self, double value):
        self.set_x(0,value)

    def get_y(self, i):
        """Get value ``y`` of ``(<chip.double3*>self._ptr)[i]``.
        """
        return (<chip.double3*>self._ptr)[i].y
    def set_y(self, i, double value):
        """Set value ``y`` of ``(<chip.double3*>self._ptr)[i]``.
        """
        (<chip.double3*>self._ptr)[i].y = value
    @property
    def y(self):
        """(undocumented)"""
        return self.get_y(0)
    @y.setter
    def y(self, double value):
        self.set_y(0,value)

    def get_z(self, i):
        """Get value ``z`` of ``(<chip.double3*>self._ptr)[i]``.
        """
        return (<chip.double3*>self._ptr)[i].z
    def set_z(self, i, double value):
        """Set value ``z`` of ``(<chip.double3*>self._ptr)[i]``.
        """
        (<chip.double3*>self._ptr)[i].z = value
    @property
    def z(self):
        """(undocumented)"""
        return self.get_z(0)
    @z.setter
    def z(self, double value):
        self.set_z(0,value)

    @staticmethod
    def PROPERTIES():
        return ["x","y","z"]

    def __contains__(self,item):
        properties = self.PROPERTIES()
        return item in properties

    def __getitem__(self,item):
        properties = self.PROPERTIES()
        if isinstance(item,int):
            if item < 0 or item >= len(properties):
                raise IndexError()
            return getattr(self,properties[item])
        raise ValueError("'item' type must be 'int'")


cdef class double4(hip._util.types.Pointer):
    """Python wrapper for cdef class chip.double4.

    Python wrapper for cdef class chip.double4.

    If this type is initialized via its `__init__` method, it allocates a
    member of the underlying C type and destroys it again if the wrapper
    type is deallocated.

    This type also serves as adapter when appearing as argument type in a
    function signature. In this case, the type can further be initialized
    from a number of Python objects:

    * `None`:

      This will set the ``self._ptr`` attribute to ``NULL``.

    * `int`:

      Interprets the integer value as pointer address and writes it to ``self._ptr``.
      No ownership is transferred.

    * `ctypes.c_void_p`:

      Takes the pointer address ``pyobj.value`` and writes it to ``self._ptr``.
      No ownership is transferred.

    * `object` that implements the `CUDA Array Interface <https://numba.readthedocs.io/en/stable/cuda/cuda_array_interface.html>`_ protocol:

      Takes the integer-valued pointer address, i.e. the first entry of the `data` tuple
      from `pyobj`'s member ``__cuda_array_interface__``  and writes it to ``self._ptr``.

    * `object` that implements the Python buffer protocol:

      If the object represents a simple contiguous array,
      writes the `Py_buffer` associated with ``pyobj`` to `self._py_buffer`,
      sets the `self._py_buffer_acquired` flag to `True`, and
      writes `self._py_buffer.buf` to the data pointer `self._ptr`.

    * `hip._util.types.Pointer`:

      Takes the pointer address ``pyobj._ptr`` and writes it to ``self._ptr``.
      No ownership is transferred.

    Type checks are performed in the above order.

    C Attributes:
        _ptr (C type ``void *``, protected):
            Stores a pointer to the data of the original Python object.
        _is_ptr_owner (C type ``bint``, protected):
            If this wrapper is the owner of the underlying data.
        _py_buffer (C type ``Py_buffer`, protected):
            Stores a pointer to the data of the original Python object.
        _py_buffer_acquired (C type ``bint``, protected):
            Stores a pointer to the data of the original Python object.
    """
    # C members declared in pxd file

    def __cinit__(self):
        self._ptr = NULL
        self._is_ptr_owner = False
        self._py_buffer_acquired = False

    cdef chip.double4* getElementPtr(self):
        return <chip.double4*>self._ptr

    @staticmethod
    cdef double4 fromPtr(void* ptr, bint owner=False):
        """Factory function to create ``double4`` objects from
        given ``chip.double4`` pointer.

        Setting ``owner`` flag to ``True`` causes
        the extension type to free the structure pointed to by ``ptr``
        when the wrapper object is deallocated.
        """
        # Fast call to __new__() that bypasses the __init__() constructor.
        cdef double4 wrapper = double4.__new__(double4)
        wrapper._ptr = ptr
        wrapper._is_ptr_owner = owner
        return wrapper

    @staticmethod
    def fromObj(pyobj):
        """Creates a double4 from a Python object.

        Derives a double4 from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``double4`` reference, this method
        returns it directly. No new ``double4`` is created in this case.
        """
        return double4.fromPyobj(pyobj)

    @staticmethod
    cdef double4 fromPyobj(object pyobj):
        """Creates a double4 from a Python object.

        Derives a double4 from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``double4`` reference, this method
        returns it directly. No new ``double4`` is created in this case.

        Args:
            pyobj (object): Must be either `None`; a `hip._util.types.Pointer`; a simple, contiguous buffer according to the buffer protocol;
                            or of type `double4`; `int`; or `ctypes.c_void_p`.

        Note:
            This routine does not perform a copy but returns the original ``pyobj``
            if ``pyobj`` is an instance of double4!
        """
        cdef double4 wrapper

        if isinstance(pyobj,double4):
            return pyobj
        else:
            wrapper = double4.__new__(double4)
            wrapper.init_from_pyobj(pyobj)
            return wrapper

    def __dealloc__(self):
        # Release the buffer handle
        if self._py_buffer_acquired is True:
            cpython.buffer.PyBuffer_Release(&self._py_buffer)
        # De-allocate if not null and flag is set
        if self._ptr is not NULL and self._is_ptr_owner is True:
            stdlib.free(self._ptr)
            self._ptr = NULL

    @staticmethod
    cdef __allocate(void** ptr):
        ptr[0] = stdlib.malloc(sizeof(chip.double4))
        string.memset(<void*>ptr[0], 0, sizeof(chip.double4))

        if ptr[0] is NULL:
            raise MemoryError

    @staticmethod
    cdef double4 new():
        """Factory function to create double4 objects with
        newly allocated chip.double4"""
        cdef void* ptr
        double4.__allocate(&ptr)
        return double4.fromPtr(ptr, owner=True)

    @staticmethod
    cdef double4 fromValue(chip.double4 other):
        """Allocate new C type and copy from ``other``.
        """
        wrapper = double4.new()
        string.memcpy(wrapper._ptr, &other, sizeof(chip.double4))
        return wrapper

    def c_sizeof(self):
        """Returns the size of the underlying C type in bytes.
        Note:
            Implemented as function to not collide with
            autogenerated property names.
        """
        return sizeof(chip.double4)

    def __int__(self):
        """Returns the data's address as long integer.
        """
        return cpython.long.PyLong_FromVoidPtr(self._ptr)

    def __repr__(self):
        return f"<double4 object, ptr: {int(self)}>"

    def as_c_void_p(self):
        """Returns the data's address as `ctypes.c_void_p`
        Note:
            Implemented as function to not collide with
            autogenerated property names.
        """
        return ctypes.c_void_p(int(self))

    def __init__(self,*args,**kwargs):
        """Constructor type double4.

        Constructor for type double4.

        Args:
            *args:
                Positional arguments. Initialize all or a subset of the member variables
                according to their order of declaration.
            **kwargs:
                Can be used to initialize member variables at construction,
                Just pass an argument expression of the form <member>=<value>
                per member that you want to initialize.
        """
        double4.__allocate(&self._ptr)
        self._is_ptr_owner = True
        attribs = self.PROPERTIES()
        used_attribs = set()
        if len(args) > len(attribs):
            raise ValueError("More positional arguments specified than this type has properties.")
        for i,v in enumerate(args):
            setattr(self,attribs[i],v)
            used_attribs.add(attribs[i])
        valid_names = ", ".join(["'"+p+"'" for p in attribs])
        for k,v in kwargs.items():
            if k in used_attribs:
                raise KeyError(f"argument '{k}' has already been specified as positional argument.")
            elif k not in attribs:
                raise KeyError(f"'{k}' is no valid property name. Valid names: {valid_names}")
            setattr(self,k,v)
    def get_x(self, i):
        """Get value ``x`` of ``(<chip.double4*>self._ptr)[i]``.
        """
        return (<chip.double4*>self._ptr)[i].x
    def set_x(self, i, double value):
        """Set value ``x`` of ``(<chip.double4*>self._ptr)[i]``.
        """
        (<chip.double4*>self._ptr)[i].x = value
    @property
    def x(self):
        """(undocumented)"""
        return self.get_x(0)
    @x.setter
    def x(self, double value):
        self.set_x(0,value)

    def get_y(self, i):
        """Get value ``y`` of ``(<chip.double4*>self._ptr)[i]``.
        """
        return (<chip.double4*>self._ptr)[i].y
    def set_y(self, i, double value):
        """Set value ``y`` of ``(<chip.double4*>self._ptr)[i]``.
        """
        (<chip.double4*>self._ptr)[i].y = value
    @property
    def y(self):
        """(undocumented)"""
        return self.get_y(0)
    @y.setter
    def y(self, double value):
        self.set_y(0,value)

    def get_z(self, i):
        """Get value ``z`` of ``(<chip.double4*>self._ptr)[i]``.
        """
        return (<chip.double4*>self._ptr)[i].z
    def set_z(self, i, double value):
        """Set value ``z`` of ``(<chip.double4*>self._ptr)[i]``.
        """
        (<chip.double4*>self._ptr)[i].z = value
    @property
    def z(self):
        """(undocumented)"""
        return self.get_z(0)
    @z.setter
    def z(self, double value):
        self.set_z(0,value)

    def get_w(self, i):
        """Get value ``w`` of ``(<chip.double4*>self._ptr)[i]``.
        """
        return (<chip.double4*>self._ptr)[i].w
    def set_w(self, i, double value):
        """Set value ``w`` of ``(<chip.double4*>self._ptr)[i]``.
        """
        (<chip.double4*>self._ptr)[i].w = value
    @property
    def w(self):
        """(undocumented)"""
        return self.get_w(0)
    @w.setter
    def w(self, double value):
        self.set_w(0,value)

    @staticmethod
    def PROPERTIES():
        return ["x","y","z","w"]

    def __contains__(self,item):
        properties = self.PROPERTIES()
        return item in properties

    def __getitem__(self,item):
        properties = self.PROPERTIES()
        if isinstance(item,int):
            if item < 0 or item >= len(properties):
                raise IndexError()
            return getattr(self,properties[item])
        raise ValueError("'item' type must be 'int'")


@cython.embedsignature(True)
def hipCreateChannelDesc(int x, int y, int z, int w, object f):
    r"""(No short description, might be part of a group.)

    Args:
        x (`~.int`):
            (undocumented)

        y (`~.int`):
            (undocumented)

        z (`~.int`):
            (undocumented)

        w (`~.int`):
            (undocumented)

        f (`~.hipChannelFormatKind`):
            (undocumented)

    Returns:
        A `~.tuple` of size 1 that contains (in that order):

        * `~.hipError_t`:
                Always returns `~.hipError_t.hipSuccess`.
    """
    if not isinstance(f,_hipChannelFormatKind__Base):
        raise TypeError("argument 'f' must be of type '_hipChannelFormatKind__Base'")
    _hipCreateChannelDesc__retval = hipChannelFormatDesc.fromValue(chip.hipCreateChannelDesc(x,y,z,w,f.value))
    return (hipError_t.hipSuccess,_hipCreateChannelDesc__retval)


cdef class __hip_texture(hip._util.types.Pointer):
    """Python wrapper for cdef class chip.__hip_texture.

    Python wrapper for cdef class chip.__hip_texture.

    If this type is initialized via its `__init__` method, it allocates a
    member of the underlying C type and destroys it again if the wrapper
    type is deallocated.

    This type also serves as adapter when appearing as argument type in a
    function signature. In this case, the type can further be initialized
    from a number of Python objects:

    * `None`:

      This will set the ``self._ptr`` attribute to ``NULL``.

    * `int`:

      Interprets the integer value as pointer address and writes it to ``self._ptr``.
      No ownership is transferred.

    * `ctypes.c_void_p`:

      Takes the pointer address ``pyobj.value`` and writes it to ``self._ptr``.
      No ownership is transferred.

    * `object` that implements the `CUDA Array Interface <https://numba.readthedocs.io/en/stable/cuda/cuda_array_interface.html>`_ protocol:

      Takes the integer-valued pointer address, i.e. the first entry of the `data` tuple
      from `pyobj`'s member ``__cuda_array_interface__``  and writes it to ``self._ptr``.

    * `object` that implements the Python buffer protocol:

      If the object represents a simple contiguous array,
      writes the `Py_buffer` associated with ``pyobj`` to `self._py_buffer`,
      sets the `self._py_buffer_acquired` flag to `True`, and
      writes `self._py_buffer.buf` to the data pointer `self._ptr`.

    * `hip._util.types.Pointer`:

      Takes the pointer address ``pyobj._ptr`` and writes it to ``self._ptr``.
      No ownership is transferred.

    Type checks are performed in the above order.

    C Attributes:
        _ptr (C type ``void *``, protected):
            Stores a pointer to the data of the original Python object.
        _is_ptr_owner (C type ``bint``, protected):
            If this wrapper is the owner of the underlying data.
        _py_buffer (C type ``Py_buffer`, protected):
            Stores a pointer to the data of the original Python object.
        _py_buffer_acquired (C type ``bint``, protected):
            Stores a pointer to the data of the original Python object.
    """
    # C members declared in pxd file

    def __cinit__(self):
        self._ptr = NULL
        self._is_ptr_owner = False
        self._py_buffer_acquired = False

    cdef chip.__hip_texture* getElementPtr(self):
        return <chip.__hip_texture*>self._ptr

    @staticmethod
    cdef __hip_texture fromPtr(void* ptr, bint owner=False):
        """Factory function to create ``__hip_texture`` objects from
        given ``chip.__hip_texture`` pointer.
        """
        # Fast call to __new__() that bypasses the __init__() constructor.
        cdef __hip_texture wrapper = __hip_texture.__new__(__hip_texture)
        wrapper._ptr = ptr
        wrapper._is_ptr_owner = owner
        return wrapper

    @staticmethod
    def fromObj(pyobj):
        """Creates a __hip_texture from a Python object.

        Derives a __hip_texture from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``__hip_texture`` reference, this method
        returns it directly. No new ``__hip_texture`` is created in this case.
        """
        return __hip_texture.fromPyobj(pyobj)

    @staticmethod
    cdef __hip_texture fromPyobj(object pyobj):
        """Creates a __hip_texture from a Python object.

        Derives a __hip_texture from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``__hip_texture`` reference, this method
        returns it directly. No new ``__hip_texture`` is created in this case.

        Args:
            pyobj (object): Must be either `None`; a `hip._util.types.Pointer`; a simple, contiguous buffer according to the buffer protocol;
                            or of type `__hip_texture`; `int`; or `ctypes.c_void_p`.

        Note:
            This routine does not perform a copy but returns the original ``pyobj``
            if ``pyobj`` is an instance of __hip_texture!
        """
        cdef __hip_texture wrapper

        if isinstance(pyobj,__hip_texture):
            return pyobj
        else:
            wrapper = __hip_texture.__new__(__hip_texture)
            wrapper.init_from_pyobj(pyobj)
            return wrapper

    def __dealloc__(self):
        # Release the buffer handle
        if self._py_buffer_acquired is True:
            cpython.buffer.PyBuffer_Release(&self._py_buffer)

    def __int__(self):
        """Returns the data's address as long integer.
        """
        return cpython.long.PyLong_FromVoidPtr(self._ptr)

    def __repr__(self):
        return f"<__hip_texture object, ptr: {int(self)}>"

    def as_c_void_p(self):
        """Returns the data's address as `ctypes.c_void_p`
        Note:
            Implemented as function to not collide with
            autogenerated property names.
        """
        return ctypes.c_void_p(int(self))

    @staticmethod
    def PROPERTIES():
        return []

    def __contains__(self,item):
        properties = self.PROPERTIES()
        return item in properties

    def __getitem__(self,item):
        properties = self.PROPERTIES()
        if isinstance(item,int):
            if item < 0 or item >= len(properties):
                raise IndexError()
            return getattr(self,properties[item])
        raise ValueError("'item' type must be 'int'")


hipTextureObject_t = __hip_texture

class _hipTextureAddressMode__Base(enum.IntEnum):
    """Empty enum base class that allows subclassing.
    """
    pass
class hipTextureAddressMode(_hipTextureAddressMode__Base):
    """hip texture address modes

    Attributes:
        hipAddressModeWrap:
            (undocumented)
        hipAddressModeClamp:
            (undocumented)
        hipAddressModeMirror:
            (undocumented)
        hipAddressModeBorder:
            (undocumented)
    """
    hipAddressModeWrap = chip.hipAddressModeWrap
    hipAddressModeClamp = chip.hipAddressModeClamp
    hipAddressModeMirror = chip.hipAddressModeMirror
    hipAddressModeBorder = chip.hipAddressModeBorder
    @staticmethod
    def ctypes_type():
        """The type of the enum constants as ctypes type."""
        return ctypes.c_uint


class _hipTextureFilterMode__Base(enum.IntEnum):
    """Empty enum base class that allows subclassing.
    """
    pass
class hipTextureFilterMode(_hipTextureFilterMode__Base):
    """hip texture filter modes

    Attributes:
        hipFilterModePoint:
            (undocumented)
        hipFilterModeLinear:
            (undocumented)
    """
    hipFilterModePoint = chip.hipFilterModePoint
    hipFilterModeLinear = chip.hipFilterModeLinear
    @staticmethod
    def ctypes_type():
        """The type of the enum constants as ctypes type."""
        return ctypes.c_uint


class _hipTextureReadMode__Base(enum.IntEnum):
    """Empty enum base class that allows subclassing.
    """
    pass
class hipTextureReadMode(_hipTextureReadMode__Base):
    """hip texture read modes

    Attributes:
        hipReadModeElementType:
            (undocumented)
        hipReadModeNormalizedFloat:
            (undocumented)
    """
    hipReadModeElementType = chip.hipReadModeElementType
    hipReadModeNormalizedFloat = chip.hipReadModeNormalizedFloat
    @staticmethod
    def ctypes_type():
        """The type of the enum constants as ctypes type."""
        return ctypes.c_uint


cdef class textureReference(hip._util.types.Pointer):
    """Python wrapper for cdef class chip.textureReference.

    Python wrapper for cdef class chip.textureReference.

    If this type is initialized via its `__init__` method, it allocates a
    member of the underlying C type and destroys it again if the wrapper
    type is deallocated.

    This type also serves as adapter when appearing as argument type in a
    function signature. In this case, the type can further be initialized
    from a number of Python objects:

    * `None`:

      This will set the ``self._ptr`` attribute to ``NULL``.

    * `int`:

      Interprets the integer value as pointer address and writes it to ``self._ptr``.
      No ownership is transferred.

    * `ctypes.c_void_p`:

      Takes the pointer address ``pyobj.value`` and writes it to ``self._ptr``.
      No ownership is transferred.

    * `object` that implements the `CUDA Array Interface <https://numba.readthedocs.io/en/stable/cuda/cuda_array_interface.html>`_ protocol:

      Takes the integer-valued pointer address, i.e. the first entry of the `data` tuple
      from `pyobj`'s member ``__cuda_array_interface__``  and writes it to ``self._ptr``.

    * `object` that implements the Python buffer protocol:

      If the object represents a simple contiguous array,
      writes the `Py_buffer` associated with ``pyobj`` to `self._py_buffer`,
      sets the `self._py_buffer_acquired` flag to `True`, and
      writes `self._py_buffer.buf` to the data pointer `self._ptr`.

    * `hip._util.types.Pointer`:

      Takes the pointer address ``pyobj._ptr`` and writes it to ``self._ptr``.
      No ownership is transferred.

    Type checks are performed in the above order.

    C Attributes:
        _ptr (C type ``void *``, protected):
            Stores a pointer to the data of the original Python object.
        _is_ptr_owner (C type ``bint``, protected):
            If this wrapper is the owner of the underlying data.
        _py_buffer (C type ``Py_buffer`, protected):
            Stores a pointer to the data of the original Python object.
        _py_buffer_acquired (C type ``bint``, protected):
            Stores a pointer to the data of the original Python object.
    """
    # C members declared in pxd file

    def __cinit__(self):
        self._ptr = NULL
        self._is_ptr_owner = False
        self._py_buffer_acquired = False

    cdef chip.textureReference* getElementPtr(self):
        return <chip.textureReference*>self._ptr

    @staticmethod
    cdef textureReference fromPtr(void* ptr, bint owner=False):
        """Factory function to create ``textureReference`` objects from
        given ``chip.textureReference`` pointer.

        Setting ``owner`` flag to ``True`` causes
        the extension type to free the structure pointed to by ``ptr``
        when the wrapper object is deallocated.
        """
        # Fast call to __new__() that bypasses the __init__() constructor.
        cdef textureReference wrapper = textureReference.__new__(textureReference)
        wrapper._ptr = ptr
        wrapper._is_ptr_owner = owner
        return wrapper

    @staticmethod
    def fromObj(pyobj):
        """Creates a textureReference from a Python object.

        Derives a textureReference from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``textureReference`` reference, this method
        returns it directly. No new ``textureReference`` is created in this case.
        """
        return textureReference.fromPyobj(pyobj)

    @staticmethod
    cdef textureReference fromPyobj(object pyobj):
        """Creates a textureReference from a Python object.

        Derives a textureReference from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``textureReference`` reference, this method
        returns it directly. No new ``textureReference`` is created in this case.

        Args:
            pyobj (object): Must be either `None`; a `hip._util.types.Pointer`; a simple, contiguous buffer according to the buffer protocol;
                            or of type `textureReference`; `int`; or `ctypes.c_void_p`.

        Note:
            This routine does not perform a copy but returns the original ``pyobj``
            if ``pyobj`` is an instance of textureReference!
        """
        cdef textureReference wrapper

        if isinstance(pyobj,textureReference):
            return pyobj
        else:
            wrapper = textureReference.__new__(textureReference)
            wrapper.init_from_pyobj(pyobj)
            return wrapper

    def __dealloc__(self):
        # Release the buffer handle
        if self._py_buffer_acquired is True:
            cpython.buffer.PyBuffer_Release(&self._py_buffer)
        # De-allocate if not null and flag is set
        if self._ptr is not NULL and self._is_ptr_owner is True:
            stdlib.free(self._ptr)
            self._ptr = NULL

    @staticmethod
    cdef __allocate(void** ptr):
        ptr[0] = stdlib.malloc(sizeof(chip.textureReference))
        string.memset(<void*>ptr[0], 0, sizeof(chip.textureReference))

        if ptr[0] is NULL:
            raise MemoryError

    @staticmethod
    cdef textureReference new():
        """Factory function to create textureReference objects with
        newly allocated chip.textureReference"""
        cdef void* ptr
        textureReference.__allocate(&ptr)
        return textureReference.fromPtr(ptr, owner=True)

    @staticmethod
    cdef textureReference fromValue(chip.textureReference other):
        """Allocate new C type and copy from ``other``.
        """
        wrapper = textureReference.new()
        string.memcpy(wrapper._ptr, &other, sizeof(chip.textureReference))
        return wrapper

    def c_sizeof(self):
        """Returns the size of the underlying C type in bytes.
        Note:
            Implemented as function to not collide with
            autogenerated property names.
        """
        return sizeof(chip.textureReference)

    def __int__(self):
        """Returns the data's address as long integer.
        """
        return cpython.long.PyLong_FromVoidPtr(self._ptr)

    def __repr__(self):
        return f"<textureReference object, ptr: {int(self)}>"

    def as_c_void_p(self):
        """Returns the data's address as `ctypes.c_void_p`
        Note:
            Implemented as function to not collide with
            autogenerated property names.
        """
        return ctypes.c_void_p(int(self))

    def __init__(self,**kwargs):
        """Constructor type textureReference.

        Constructor for type textureReference.

        Args:
            **kwargs:
                Can be used to initialize member variables at construction,
                Just pass an argument expression of the form <member>=<value>
                per member that you want to initialize.
        """
        textureReference.__allocate(&self._ptr)
        self._is_ptr_owner = True
        attribs = self.PROPERTIES()
        used_attribs = set()
        valid_names = ", ".join(["'"+p+"'" for p in attribs])
        for k,v in kwargs.items():
            if k in used_attribs:
                raise KeyError(f"argument '{k}' has already been specified as positional argument.")
            elif k not in attribs:
                raise KeyError(f"'{k}' is no valid property name. Valid names: {valid_names}")
            setattr(self,k,v)
    def get_normalized(self, i):
        """Get value ``normalized`` of ``(<chip.textureReference*>self._ptr)[i]``.
        """
        return (<chip.textureReference*>self._ptr)[i].normalized
    def set_normalized(self, i, int value):
        """Set value ``normalized`` of ``(<chip.textureReference*>self._ptr)[i]``.
        """
        (<chip.textureReference*>self._ptr)[i].normalized = value
    @property
    def normalized(self):
        """(undocumented)"""
        return self.get_normalized(0)
    @normalized.setter
    def normalized(self, int value):
        self.set_normalized(0,value)

    def get_readMode(self, i):
        """Get value of ``readMode`` of ``(<chip.textureReference*>self._ptr)[i]``.
        """
        return hipTextureReadMode((<chip.textureReference*>self._ptr)[i].readMode)
    def set_readMode(self, i, value):
        """Set value ``readMode`` of ``(<chip.textureReference*>self._ptr)[i]``.
        """
        if not isinstance(value, hipTextureReadMode):
            raise TypeError("'value' must be of type 'hipTextureReadMode'")
        (<chip.textureReference*>self._ptr)[i].readMode = value.value
    @property
    def readMode(self):
        """(undocumented)"""
        return self.get_readMode(0)
    @readMode.setter
    def readMode(self, value):
        self.set_readMode(0,value)

    def get_filterMode(self, i):
        """Get value of ``filterMode`` of ``(<chip.textureReference*>self._ptr)[i]``.
        """
        return hipTextureFilterMode((<chip.textureReference*>self._ptr)[i].filterMode)
    def set_filterMode(self, i, value):
        """Set value ``filterMode`` of ``(<chip.textureReference*>self._ptr)[i]``.
        """
        if not isinstance(value, hipTextureFilterMode):
            raise TypeError("'value' must be of type 'hipTextureFilterMode'")
        (<chip.textureReference*>self._ptr)[i].filterMode = value.value
    @property
    def filterMode(self):
        """(undocumented)"""
        return self.get_filterMode(0)
    @filterMode.setter
    def filterMode(self, value):
        self.set_filterMode(0,value)

    def get_channelDesc(self, i):
        """Get value of ``channelDesc`` of ``(<chip.textureReference*>self._ptr)[i]``.
        """
        return hipChannelFormatDesc.fromPtr(&(<chip.textureReference*>self._ptr)[i].channelDesc)
    @property
    def channelDesc(self):
        """(undocumented)"""
        return self.get_channelDesc(0)

    def get_sRGB(self, i):
        """Get value ``sRGB`` of ``(<chip.textureReference*>self._ptr)[i]``.
        """
        return (<chip.textureReference*>self._ptr)[i].sRGB
    def set_sRGB(self, i, int value):
        """Set value ``sRGB`` of ``(<chip.textureReference*>self._ptr)[i]``.
        """
        (<chip.textureReference*>self._ptr)[i].sRGB = value
    @property
    def sRGB(self):
        """(undocumented)"""
        return self.get_sRGB(0)
    @sRGB.setter
    def sRGB(self, int value):
        self.set_sRGB(0,value)

    def get_maxAnisotropy(self, i):
        """Get value ``maxAnisotropy`` of ``(<chip.textureReference*>self._ptr)[i]``.
        """
        return (<chip.textureReference*>self._ptr)[i].maxAnisotropy
    def set_maxAnisotropy(self, i, unsigned int value):
        """Set value ``maxAnisotropy`` of ``(<chip.textureReference*>self._ptr)[i]``.
        """
        (<chip.textureReference*>self._ptr)[i].maxAnisotropy = value
    @property
    def maxAnisotropy(self):
        """(undocumented)"""
        return self.get_maxAnisotropy(0)
    @maxAnisotropy.setter
    def maxAnisotropy(self, unsigned int value):
        self.set_maxAnisotropy(0,value)

    def get_mipmapFilterMode(self, i):
        """Get value of ``mipmapFilterMode`` of ``(<chip.textureReference*>self._ptr)[i]``.
        """
        return hipTextureFilterMode((<chip.textureReference*>self._ptr)[i].mipmapFilterMode)
    def set_mipmapFilterMode(self, i, value):
        """Set value ``mipmapFilterMode`` of ``(<chip.textureReference*>self._ptr)[i]``.
        """
        if not isinstance(value, hipTextureFilterMode):
            raise TypeError("'value' must be of type 'hipTextureFilterMode'")
        (<chip.textureReference*>self._ptr)[i].mipmapFilterMode = value.value
    @property
    def mipmapFilterMode(self):
        """(undocumented)"""
        return self.get_mipmapFilterMode(0)
    @mipmapFilterMode.setter
    def mipmapFilterMode(self, value):
        self.set_mipmapFilterMode(0,value)

    def get_mipmapLevelBias(self, i):
        """Get value ``mipmapLevelBias`` of ``(<chip.textureReference*>self._ptr)[i]``.
        """
        return (<chip.textureReference*>self._ptr)[i].mipmapLevelBias
    def set_mipmapLevelBias(self, i, float value):
        """Set value ``mipmapLevelBias`` of ``(<chip.textureReference*>self._ptr)[i]``.
        """
        (<chip.textureReference*>self._ptr)[i].mipmapLevelBias = value
    @property
    def mipmapLevelBias(self):
        """(undocumented)"""
        return self.get_mipmapLevelBias(0)
    @mipmapLevelBias.setter
    def mipmapLevelBias(self, float value):
        self.set_mipmapLevelBias(0,value)

    def get_minMipmapLevelClamp(self, i):
        """Get value ``minMipmapLevelClamp`` of ``(<chip.textureReference*>self._ptr)[i]``.
        """
        return (<chip.textureReference*>self._ptr)[i].minMipmapLevelClamp
    def set_minMipmapLevelClamp(self, i, float value):
        """Set value ``minMipmapLevelClamp`` of ``(<chip.textureReference*>self._ptr)[i]``.
        """
        (<chip.textureReference*>self._ptr)[i].minMipmapLevelClamp = value
    @property
    def minMipmapLevelClamp(self):
        """(undocumented)"""
        return self.get_minMipmapLevelClamp(0)
    @minMipmapLevelClamp.setter
    def minMipmapLevelClamp(self, float value):
        self.set_minMipmapLevelClamp(0,value)

    def get_maxMipmapLevelClamp(self, i):
        """Get value ``maxMipmapLevelClamp`` of ``(<chip.textureReference*>self._ptr)[i]``.
        """
        return (<chip.textureReference*>self._ptr)[i].maxMipmapLevelClamp
    def set_maxMipmapLevelClamp(self, i, float value):
        """Set value ``maxMipmapLevelClamp`` of ``(<chip.textureReference*>self._ptr)[i]``.
        """
        (<chip.textureReference*>self._ptr)[i].maxMipmapLevelClamp = value
    @property
    def maxMipmapLevelClamp(self):
        """(undocumented)"""
        return self.get_maxMipmapLevelClamp(0)
    @maxMipmapLevelClamp.setter
    def maxMipmapLevelClamp(self, float value):
        self.set_maxMipmapLevelClamp(0,value)

    def get_numChannels(self, i):
        """Get value ``numChannels`` of ``(<chip.textureReference*>self._ptr)[i]``.
        """
        return (<chip.textureReference*>self._ptr)[i].numChannels
    def set_numChannels(self, i, int value):
        """Set value ``numChannels`` of ``(<chip.textureReference*>self._ptr)[i]``.
        """
        (<chip.textureReference*>self._ptr)[i].numChannels = value
    @property
    def numChannels(self):
        """(undocumented)"""
        return self.get_numChannels(0)
    @numChannels.setter
    def numChannels(self, int value):
        self.set_numChannels(0,value)

    def get_format(self, i):
        """Get value of ``format`` of ``(<chip.textureReference*>self._ptr)[i]``.
        """
        return hipArray_Format((<chip.textureReference*>self._ptr)[i].format)
    def set_format(self, i, value):
        """Set value ``format`` of ``(<chip.textureReference*>self._ptr)[i]``.
        """
        if not isinstance(value, hipArray_Format):
            raise TypeError("'value' must be of type 'hipArray_Format'")
        (<chip.textureReference*>self._ptr)[i].format = value.value
    @property
    def format(self):
        """(undocumented)"""
        return self.get_format(0)
    @format.setter
    def format(self, value):
        self.set_format(0,value)

    @staticmethod
    def PROPERTIES():
        return ["normalized","readMode","filterMode","channelDesc","sRGB","maxAnisotropy","mipmapFilterMode","mipmapLevelBias","minMipmapLevelClamp","maxMipmapLevelClamp","numChannels","format"]

    def __contains__(self,item):
        properties = self.PROPERTIES()
        return item in properties

    def __getitem__(self,item):
        properties = self.PROPERTIES()
        if isinstance(item,int):
            if item < 0 or item >= len(properties):
                raise IndexError()
            return getattr(self,properties[item])
        raise ValueError("'item' type must be 'int'")


cdef class hipTextureDesc(hip._util.types.Pointer):
    """Python wrapper for cdef class chip.hipTextureDesc.

    Python wrapper for cdef class chip.hipTextureDesc.

    If this type is initialized via its `__init__` method, it allocates a
    member of the underlying C type and destroys it again if the wrapper
    type is deallocated.

    This type also serves as adapter when appearing as argument type in a
    function signature. In this case, the type can further be initialized
    from a number of Python objects:

    * `None`:

      This will set the ``self._ptr`` attribute to ``NULL``.

    * `int`:

      Interprets the integer value as pointer address and writes it to ``self._ptr``.
      No ownership is transferred.

    * `ctypes.c_void_p`:

      Takes the pointer address ``pyobj.value`` and writes it to ``self._ptr``.
      No ownership is transferred.

    * `object` that implements the `CUDA Array Interface <https://numba.readthedocs.io/en/stable/cuda/cuda_array_interface.html>`_ protocol:

      Takes the integer-valued pointer address, i.e. the first entry of the `data` tuple
      from `pyobj`'s member ``__cuda_array_interface__``  and writes it to ``self._ptr``.

    * `object` that implements the Python buffer protocol:

      If the object represents a simple contiguous array,
      writes the `Py_buffer` associated with ``pyobj`` to `self._py_buffer`,
      sets the `self._py_buffer_acquired` flag to `True`, and
      writes `self._py_buffer.buf` to the data pointer `self._ptr`.

    * `hip._util.types.Pointer`:

      Takes the pointer address ``pyobj._ptr`` and writes it to ``self._ptr``.
      No ownership is transferred.

    Type checks are performed in the above order.

    C Attributes:
        _ptr (C type ``void *``, protected):
            Stores a pointer to the data of the original Python object.
        _is_ptr_owner (C type ``bint``, protected):
            If this wrapper is the owner of the underlying data.
        _py_buffer (C type ``Py_buffer`, protected):
            Stores a pointer to the data of the original Python object.
        _py_buffer_acquired (C type ``bint``, protected):
            Stores a pointer to the data of the original Python object.
    """
    # C members declared in pxd file

    def __cinit__(self):
        self._ptr = NULL
        self._is_ptr_owner = False
        self._py_buffer_acquired = False

    cdef chip.hipTextureDesc* getElementPtr(self):
        return <chip.hipTextureDesc*>self._ptr

    @staticmethod
    cdef hipTextureDesc fromPtr(void* ptr, bint owner=False):
        """Factory function to create ``hipTextureDesc`` objects from
        given ``chip.hipTextureDesc`` pointer.

        Setting ``owner`` flag to ``True`` causes
        the extension type to free the structure pointed to by ``ptr``
        when the wrapper object is deallocated.
        """
        # Fast call to __new__() that bypasses the __init__() constructor.
        cdef hipTextureDesc wrapper = hipTextureDesc.__new__(hipTextureDesc)
        wrapper._ptr = ptr
        wrapper._is_ptr_owner = owner
        return wrapper

    @staticmethod
    def fromObj(pyobj):
        """Creates a hipTextureDesc from a Python object.

        Derives a hipTextureDesc from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``hipTextureDesc`` reference, this method
        returns it directly. No new ``hipTextureDesc`` is created in this case.
        """
        return hipTextureDesc.fromPyobj(pyobj)

    @staticmethod
    cdef hipTextureDesc fromPyobj(object pyobj):
        """Creates a hipTextureDesc from a Python object.

        Derives a hipTextureDesc from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``hipTextureDesc`` reference, this method
        returns it directly. No new ``hipTextureDesc`` is created in this case.

        Args:
            pyobj (object): Must be either `None`; a `hip._util.types.Pointer`; a simple, contiguous buffer according to the buffer protocol;
                            or of type `hipTextureDesc`; `int`; or `ctypes.c_void_p`.

        Note:
            This routine does not perform a copy but returns the original ``pyobj``
            if ``pyobj`` is an instance of hipTextureDesc!
        """
        cdef hipTextureDesc wrapper

        if isinstance(pyobj,hipTextureDesc):
            return pyobj
        else:
            wrapper = hipTextureDesc.__new__(hipTextureDesc)
            wrapper.init_from_pyobj(pyobj)
            return wrapper

    def __dealloc__(self):
        # Release the buffer handle
        if self._py_buffer_acquired is True:
            cpython.buffer.PyBuffer_Release(&self._py_buffer)
        # De-allocate if not null and flag is set
        if self._ptr is not NULL and self._is_ptr_owner is True:
            stdlib.free(self._ptr)
            self._ptr = NULL

    @staticmethod
    cdef __allocate(void** ptr):
        ptr[0] = stdlib.malloc(sizeof(chip.hipTextureDesc))
        string.memset(<void*>ptr[0], 0, sizeof(chip.hipTextureDesc))

        if ptr[0] is NULL:
            raise MemoryError

    @staticmethod
    cdef hipTextureDesc new():
        """Factory function to create hipTextureDesc objects with
        newly allocated chip.hipTextureDesc"""
        cdef void* ptr
        hipTextureDesc.__allocate(&ptr)
        return hipTextureDesc.fromPtr(ptr, owner=True)

    @staticmethod
    cdef hipTextureDesc fromValue(chip.hipTextureDesc other):
        """Allocate new C type and copy from ``other``.
        """
        wrapper = hipTextureDesc.new()
        string.memcpy(wrapper._ptr, &other, sizeof(chip.hipTextureDesc))
        return wrapper

    def c_sizeof(self):
        """Returns the size of the underlying C type in bytes.
        Note:
            Implemented as function to not collide with
            autogenerated property names.
        """
        return sizeof(chip.hipTextureDesc)

    def __int__(self):
        """Returns the data's address as long integer.
        """
        return cpython.long.PyLong_FromVoidPtr(self._ptr)

    def __repr__(self):
        return f"<hipTextureDesc object, ptr: {int(self)}>"

    def as_c_void_p(self):
        """Returns the data's address as `ctypes.c_void_p`
        Note:
            Implemented as function to not collide with
            autogenerated property names.
        """
        return ctypes.c_void_p(int(self))

    def __init__(self,**kwargs):
        """Constructor type hipTextureDesc.

        Constructor for type hipTextureDesc.

        Args:
            **kwargs:
                Can be used to initialize member variables at construction,
                Just pass an argument expression of the form <member>=<value>
                per member that you want to initialize.
        """
        hipTextureDesc.__allocate(&self._ptr)
        self._is_ptr_owner = True
        attribs = self.PROPERTIES()
        used_attribs = set()
        valid_names = ", ".join(["'"+p+"'" for p in attribs])
        for k,v in kwargs.items():
            if k in used_attribs:
                raise KeyError(f"argument '{k}' has already been specified as positional argument.")
            elif k not in attribs:
                raise KeyError(f"'{k}' is no valid property name. Valid names: {valid_names}")
            setattr(self,k,v)
    def get_filterMode(self, i):
        """Get value of ``filterMode`` of ``(<chip.hipTextureDesc*>self._ptr)[i]``.
        """
        return hipTextureFilterMode((<chip.hipTextureDesc*>self._ptr)[i].filterMode)
    def set_filterMode(self, i, value):
        """Set value ``filterMode`` of ``(<chip.hipTextureDesc*>self._ptr)[i]``.
        """
        if not isinstance(value, hipTextureFilterMode):
            raise TypeError("'value' must be of type 'hipTextureFilterMode'")
        (<chip.hipTextureDesc*>self._ptr)[i].filterMode = value.value
    @property
    def filterMode(self):
        """(undocumented)"""
        return self.get_filterMode(0)
    @filterMode.setter
    def filterMode(self, value):
        self.set_filterMode(0,value)

    def get_readMode(self, i):
        """Get value of ``readMode`` of ``(<chip.hipTextureDesc*>self._ptr)[i]``.
        """
        return hipTextureReadMode((<chip.hipTextureDesc*>self._ptr)[i].readMode)
    def set_readMode(self, i, value):
        """Set value ``readMode`` of ``(<chip.hipTextureDesc*>self._ptr)[i]``.
        """
        if not isinstance(value, hipTextureReadMode):
            raise TypeError("'value' must be of type 'hipTextureReadMode'")
        (<chip.hipTextureDesc*>self._ptr)[i].readMode = value.value
    @property
    def readMode(self):
        """(undocumented)"""
        return self.get_readMode(0)
    @readMode.setter
    def readMode(self, value):
        self.set_readMode(0,value)

    def get_sRGB(self, i):
        """Get value ``sRGB`` of ``(<chip.hipTextureDesc*>self._ptr)[i]``.
        """
        return (<chip.hipTextureDesc*>self._ptr)[i].sRGB
    def set_sRGB(self, i, int value):
        """Set value ``sRGB`` of ``(<chip.hipTextureDesc*>self._ptr)[i]``.
        """
        (<chip.hipTextureDesc*>self._ptr)[i].sRGB = value
    @property
    def sRGB(self):
        """(undocumented)"""
        return self.get_sRGB(0)
    @sRGB.setter
    def sRGB(self, int value):
        self.set_sRGB(0,value)

    def get_borderColor(self, i):
        """Get value of ``borderColor`` of ``(<chip.hipTextureDesc*>self._ptr)[i]``.
        """
        return (<chip.hipTextureDesc*>self._ptr)[i].borderColor
    # TODO add setters
    #def set_borderColor(self, i, float[4] value):
    #    """Set value ``borderColor`` of ``(<chip.hipTextureDesc*>self._ptr)[i]``.
    #    """
    #    (<chip.hipTextureDesc*>self._ptr)[i].borderColor = value
    @property
    def borderColor(self):
        """(undocumented)"""
        return self.get_borderColor(0)
    # TODO add setters
    #@borderColor.setter
    #def borderColor(self, float[4] value):
    #    self.set_borderColor(0,value)

    def get_normalizedCoords(self, i):
        """Get value ``normalizedCoords`` of ``(<chip.hipTextureDesc*>self._ptr)[i]``.
        """
        return (<chip.hipTextureDesc*>self._ptr)[i].normalizedCoords
    def set_normalizedCoords(self, i, int value):
        """Set value ``normalizedCoords`` of ``(<chip.hipTextureDesc*>self._ptr)[i]``.
        """
        (<chip.hipTextureDesc*>self._ptr)[i].normalizedCoords = value
    @property
    def normalizedCoords(self):
        """(undocumented)"""
        return self.get_normalizedCoords(0)
    @normalizedCoords.setter
    def normalizedCoords(self, int value):
        self.set_normalizedCoords(0,value)

    def get_maxAnisotropy(self, i):
        """Get value ``maxAnisotropy`` of ``(<chip.hipTextureDesc*>self._ptr)[i]``.
        """
        return (<chip.hipTextureDesc*>self._ptr)[i].maxAnisotropy
    def set_maxAnisotropy(self, i, unsigned int value):
        """Set value ``maxAnisotropy`` of ``(<chip.hipTextureDesc*>self._ptr)[i]``.
        """
        (<chip.hipTextureDesc*>self._ptr)[i].maxAnisotropy = value
    @property
    def maxAnisotropy(self):
        """(undocumented)"""
        return self.get_maxAnisotropy(0)
    @maxAnisotropy.setter
    def maxAnisotropy(self, unsigned int value):
        self.set_maxAnisotropy(0,value)

    def get_mipmapFilterMode(self, i):
        """Get value of ``mipmapFilterMode`` of ``(<chip.hipTextureDesc*>self._ptr)[i]``.
        """
        return hipTextureFilterMode((<chip.hipTextureDesc*>self._ptr)[i].mipmapFilterMode)
    def set_mipmapFilterMode(self, i, value):
        """Set value ``mipmapFilterMode`` of ``(<chip.hipTextureDesc*>self._ptr)[i]``.
        """
        if not isinstance(value, hipTextureFilterMode):
            raise TypeError("'value' must be of type 'hipTextureFilterMode'")
        (<chip.hipTextureDesc*>self._ptr)[i].mipmapFilterMode = value.value
    @property
    def mipmapFilterMode(self):
        """(undocumented)"""
        return self.get_mipmapFilterMode(0)
    @mipmapFilterMode.setter
    def mipmapFilterMode(self, value):
        self.set_mipmapFilterMode(0,value)

    def get_mipmapLevelBias(self, i):
        """Get value ``mipmapLevelBias`` of ``(<chip.hipTextureDesc*>self._ptr)[i]``.
        """
        return (<chip.hipTextureDesc*>self._ptr)[i].mipmapLevelBias
    def set_mipmapLevelBias(self, i, float value):
        """Set value ``mipmapLevelBias`` of ``(<chip.hipTextureDesc*>self._ptr)[i]``.
        """
        (<chip.hipTextureDesc*>self._ptr)[i].mipmapLevelBias = value
    @property
    def mipmapLevelBias(self):
        """(undocumented)"""
        return self.get_mipmapLevelBias(0)
    @mipmapLevelBias.setter
    def mipmapLevelBias(self, float value):
        self.set_mipmapLevelBias(0,value)

    def get_minMipmapLevelClamp(self, i):
        """Get value ``minMipmapLevelClamp`` of ``(<chip.hipTextureDesc*>self._ptr)[i]``.
        """
        return (<chip.hipTextureDesc*>self._ptr)[i].minMipmapLevelClamp
    def set_minMipmapLevelClamp(self, i, float value):
        """Set value ``minMipmapLevelClamp`` of ``(<chip.hipTextureDesc*>self._ptr)[i]``.
        """
        (<chip.hipTextureDesc*>self._ptr)[i].minMipmapLevelClamp = value
    @property
    def minMipmapLevelClamp(self):
        """(undocumented)"""
        return self.get_minMipmapLevelClamp(0)
    @minMipmapLevelClamp.setter
    def minMipmapLevelClamp(self, float value):
        self.set_minMipmapLevelClamp(0,value)

    def get_maxMipmapLevelClamp(self, i):
        """Get value ``maxMipmapLevelClamp`` of ``(<chip.hipTextureDesc*>self._ptr)[i]``.
        """
        return (<chip.hipTextureDesc*>self._ptr)[i].maxMipmapLevelClamp
    def set_maxMipmapLevelClamp(self, i, float value):
        """Set value ``maxMipmapLevelClamp`` of ``(<chip.hipTextureDesc*>self._ptr)[i]``.
        """
        (<chip.hipTextureDesc*>self._ptr)[i].maxMipmapLevelClamp = value
    @property
    def maxMipmapLevelClamp(self):
        """(undocumented)"""
        return self.get_maxMipmapLevelClamp(0)
    @maxMipmapLevelClamp.setter
    def maxMipmapLevelClamp(self, float value):
        self.set_maxMipmapLevelClamp(0,value)

    @staticmethod
    def PROPERTIES():
        return ["filterMode","readMode","sRGB","borderColor","normalizedCoords","maxAnisotropy","mipmapFilterMode","mipmapLevelBias","minMipmapLevelClamp","maxMipmapLevelClamp"]

    def __contains__(self,item):
        properties = self.PROPERTIES()
        return item in properties

    def __getitem__(self,item):
        properties = self.PROPERTIES()
        if isinstance(item,int):
            if item < 0 or item >= len(properties):
                raise IndexError()
            return getattr(self,properties[item])
        raise ValueError("'item' type must be 'int'")


cdef class __hip_surface(hip._util.types.Pointer):
    """Python wrapper for cdef class chip.__hip_surface.

    Python wrapper for cdef class chip.__hip_surface.

    If this type is initialized via its `__init__` method, it allocates a
    member of the underlying C type and destroys it again if the wrapper
    type is deallocated.

    This type also serves as adapter when appearing as argument type in a
    function signature. In this case, the type can further be initialized
    from a number of Python objects:

    * `None`:

      This will set the ``self._ptr`` attribute to ``NULL``.

    * `int`:

      Interprets the integer value as pointer address and writes it to ``self._ptr``.
      No ownership is transferred.

    * `ctypes.c_void_p`:

      Takes the pointer address ``pyobj.value`` and writes it to ``self._ptr``.
      No ownership is transferred.

    * `object` that implements the `CUDA Array Interface <https://numba.readthedocs.io/en/stable/cuda/cuda_array_interface.html>`_ protocol:

      Takes the integer-valued pointer address, i.e. the first entry of the `data` tuple
      from `pyobj`'s member ``__cuda_array_interface__``  and writes it to ``self._ptr``.

    * `object` that implements the Python buffer protocol:

      If the object represents a simple contiguous array,
      writes the `Py_buffer` associated with ``pyobj`` to `self._py_buffer`,
      sets the `self._py_buffer_acquired` flag to `True`, and
      writes `self._py_buffer.buf` to the data pointer `self._ptr`.

    * `hip._util.types.Pointer`:

      Takes the pointer address ``pyobj._ptr`` and writes it to ``self._ptr``.
      No ownership is transferred.

    Type checks are performed in the above order.

    C Attributes:
        _ptr (C type ``void *``, protected):
            Stores a pointer to the data of the original Python object.
        _is_ptr_owner (C type ``bint``, protected):
            If this wrapper is the owner of the underlying data.
        _py_buffer (C type ``Py_buffer`, protected):
            Stores a pointer to the data of the original Python object.
        _py_buffer_acquired (C type ``bint``, protected):
            Stores a pointer to the data of the original Python object.
    """
    # C members declared in pxd file

    def __cinit__(self):
        self._ptr = NULL
        self._is_ptr_owner = False
        self._py_buffer_acquired = False

    cdef chip.__hip_surface* getElementPtr(self):
        return <chip.__hip_surface*>self._ptr

    @staticmethod
    cdef __hip_surface fromPtr(void* ptr, bint owner=False):
        """Factory function to create ``__hip_surface`` objects from
        given ``chip.__hip_surface`` pointer.
        """
        # Fast call to __new__() that bypasses the __init__() constructor.
        cdef __hip_surface wrapper = __hip_surface.__new__(__hip_surface)
        wrapper._ptr = ptr
        wrapper._is_ptr_owner = owner
        return wrapper

    @staticmethod
    def fromObj(pyobj):
        """Creates a __hip_surface from a Python object.

        Derives a __hip_surface from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``__hip_surface`` reference, this method
        returns it directly. No new ``__hip_surface`` is created in this case.
        """
        return __hip_surface.fromPyobj(pyobj)

    @staticmethod
    cdef __hip_surface fromPyobj(object pyobj):
        """Creates a __hip_surface from a Python object.

        Derives a __hip_surface from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``__hip_surface`` reference, this method
        returns it directly. No new ``__hip_surface`` is created in this case.

        Args:
            pyobj (object): Must be either `None`; a `hip._util.types.Pointer`; a simple, contiguous buffer according to the buffer protocol;
                            or of type `__hip_surface`; `int`; or `ctypes.c_void_p`.

        Note:
            This routine does not perform a copy but returns the original ``pyobj``
            if ``pyobj`` is an instance of __hip_surface!
        """
        cdef __hip_surface wrapper

        if isinstance(pyobj,__hip_surface):
            return pyobj
        else:
            wrapper = __hip_surface.__new__(__hip_surface)
            wrapper.init_from_pyobj(pyobj)
            return wrapper

    def __dealloc__(self):
        # Release the buffer handle
        if self._py_buffer_acquired is True:
            cpython.buffer.PyBuffer_Release(&self._py_buffer)

    def __int__(self):
        """Returns the data's address as long integer.
        """
        return cpython.long.PyLong_FromVoidPtr(self._ptr)

    def __repr__(self):
        return f"<__hip_surface object, ptr: {int(self)}>"

    def as_c_void_p(self):
        """Returns the data's address as `ctypes.c_void_p`
        Note:
            Implemented as function to not collide with
            autogenerated property names.
        """
        return ctypes.c_void_p(int(self))

    @staticmethod
    def PROPERTIES():
        return []

    def __contains__(self,item):
        properties = self.PROPERTIES()
        return item in properties

    def __getitem__(self,item):
        properties = self.PROPERTIES()
        if isinstance(item,int):
            if item < 0 or item >= len(properties):
                raise IndexError()
            return getattr(self,properties[item])
        raise ValueError("'item' type must be 'int'")


hipSurfaceObject_t = __hip_surface

cdef class surfaceReference(hip._util.types.Pointer):
    """Python wrapper for cdef class chip.surfaceReference.

    Python wrapper for cdef class chip.surfaceReference.

    If this type is initialized via its `__init__` method, it allocates a
    member of the underlying C type and destroys it again if the wrapper
    type is deallocated.

    This type also serves as adapter when appearing as argument type in a
    function signature. In this case, the type can further be initialized
    from a number of Python objects:

    * `None`:

      This will set the ``self._ptr`` attribute to ``NULL``.

    * `int`:

      Interprets the integer value as pointer address and writes it to ``self._ptr``.
      No ownership is transferred.

    * `ctypes.c_void_p`:

      Takes the pointer address ``pyobj.value`` and writes it to ``self._ptr``.
      No ownership is transferred.

    * `object` that implements the `CUDA Array Interface <https://numba.readthedocs.io/en/stable/cuda/cuda_array_interface.html>`_ protocol:

      Takes the integer-valued pointer address, i.e. the first entry of the `data` tuple
      from `pyobj`'s member ``__cuda_array_interface__``  and writes it to ``self._ptr``.

    * `object` that implements the Python buffer protocol:

      If the object represents a simple contiguous array,
      writes the `Py_buffer` associated with ``pyobj`` to `self._py_buffer`,
      sets the `self._py_buffer_acquired` flag to `True`, and
      writes `self._py_buffer.buf` to the data pointer `self._ptr`.

    * `hip._util.types.Pointer`:

      Takes the pointer address ``pyobj._ptr`` and writes it to ``self._ptr``.
      No ownership is transferred.

    Type checks are performed in the above order.

    C Attributes:
        _ptr (C type ``void *``, protected):
            Stores a pointer to the data of the original Python object.
        _is_ptr_owner (C type ``bint``, protected):
            If this wrapper is the owner of the underlying data.
        _py_buffer (C type ``Py_buffer`, protected):
            Stores a pointer to the data of the original Python object.
        _py_buffer_acquired (C type ``bint``, protected):
            Stores a pointer to the data of the original Python object.
    """
    # C members declared in pxd file

    def __cinit__(self):
        self._ptr = NULL
        self._is_ptr_owner = False
        self._py_buffer_acquired = False

    cdef chip.surfaceReference* getElementPtr(self):
        return <chip.surfaceReference*>self._ptr

    @staticmethod
    cdef surfaceReference fromPtr(void* ptr, bint owner=False):
        """Factory function to create ``surfaceReference`` objects from
        given ``chip.surfaceReference`` pointer.

        Setting ``owner`` flag to ``True`` causes
        the extension type to free the structure pointed to by ``ptr``
        when the wrapper object is deallocated.
        """
        # Fast call to __new__() that bypasses the __init__() constructor.
        cdef surfaceReference wrapper = surfaceReference.__new__(surfaceReference)
        wrapper._ptr = ptr
        wrapper._is_ptr_owner = owner
        return wrapper

    @staticmethod
    def fromObj(pyobj):
        """Creates a surfaceReference from a Python object.

        Derives a surfaceReference from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``surfaceReference`` reference, this method
        returns it directly. No new ``surfaceReference`` is created in this case.
        """
        return surfaceReference.fromPyobj(pyobj)

    @staticmethod
    cdef surfaceReference fromPyobj(object pyobj):
        """Creates a surfaceReference from a Python object.

        Derives a surfaceReference from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``surfaceReference`` reference, this method
        returns it directly. No new ``surfaceReference`` is created in this case.

        Args:
            pyobj (object): Must be either `None`; a `hip._util.types.Pointer`; a simple, contiguous buffer according to the buffer protocol;
                            or of type `surfaceReference`; `int`; or `ctypes.c_void_p`.

        Note:
            This routine does not perform a copy but returns the original ``pyobj``
            if ``pyobj`` is an instance of surfaceReference!
        """
        cdef surfaceReference wrapper

        if isinstance(pyobj,surfaceReference):
            return pyobj
        else:
            wrapper = surfaceReference.__new__(surfaceReference)
            wrapper.init_from_pyobj(pyobj)
            return wrapper

    def __dealloc__(self):
        # Release the buffer handle
        if self._py_buffer_acquired is True:
            cpython.buffer.PyBuffer_Release(&self._py_buffer)
        # De-allocate if not null and flag is set
        if self._ptr is not NULL and self._is_ptr_owner is True:
            stdlib.free(self._ptr)
            self._ptr = NULL

    @staticmethod
    cdef __allocate(void** ptr):
        ptr[0] = stdlib.malloc(sizeof(chip.surfaceReference))
        string.memset(<void*>ptr[0], 0, sizeof(chip.surfaceReference))

        if ptr[0] is NULL:
            raise MemoryError

    @staticmethod
    cdef surfaceReference new():
        """Factory function to create surfaceReference objects with
        newly allocated chip.surfaceReference"""
        cdef void* ptr
        surfaceReference.__allocate(&ptr)
        return surfaceReference.fromPtr(ptr, owner=True)

    @staticmethod
    cdef surfaceReference fromValue(chip.surfaceReference other):
        """Allocate new C type and copy from ``other``.
        """
        wrapper = surfaceReference.new()
        string.memcpy(wrapper._ptr, &other, sizeof(chip.surfaceReference))
        return wrapper

    def c_sizeof(self):
        """Returns the size of the underlying C type in bytes.
        Note:
            Implemented as function to not collide with
            autogenerated property names.
        """
        return sizeof(chip.surfaceReference)

    def __int__(self):
        """Returns the data's address as long integer.
        """
        return cpython.long.PyLong_FromVoidPtr(self._ptr)

    def __repr__(self):
        return f"<surfaceReference object, ptr: {int(self)}>"

    def as_c_void_p(self):
        """Returns the data's address as `ctypes.c_void_p`
        Note:
            Implemented as function to not collide with
            autogenerated property names.
        """
        return ctypes.c_void_p(int(self))

    def __init__(self,**kwargs):
        """Constructor type surfaceReference.

        Constructor for type surfaceReference.

        Args:
            **kwargs:
                Can be used to initialize member variables at construction,
                Just pass an argument expression of the form <member>=<value>
                per member that you want to initialize.
        """
        surfaceReference.__allocate(&self._ptr)
        self._is_ptr_owner = True
        attribs = self.PROPERTIES()
        used_attribs = set()
        valid_names = ", ".join(["'"+p+"'" for p in attribs])
        for k,v in kwargs.items():
            if k in used_attribs:
                raise KeyError(f"argument '{k}' has already been specified as positional argument.")
            elif k not in attribs:
                raise KeyError(f"'{k}' is no valid property name. Valid names: {valid_names}")
            setattr(self,k,v)
    @staticmethod
    def PROPERTIES():
        return []

    def __contains__(self,item):
        properties = self.PROPERTIES()
        return item in properties

    def __getitem__(self,item):
        properties = self.PROPERTIES()
        if isinstance(item,int):
            if item < 0 or item >= len(properties):
                raise IndexError()
            return getattr(self,properties[item])
        raise ValueError("'item' type must be 'int'")


class _hipSurfaceBoundaryMode__Base(enum.IntEnum):
    """Empty enum base class that allows subclassing.
    """
    pass
class hipSurfaceBoundaryMode(_hipSurfaceBoundaryMode__Base):
    """hip surface boundary modes

    Attributes:
        hipBoundaryModeZero:
            (undocumented)
        hipBoundaryModeTrap:
            (undocumented)
        hipBoundaryModeClamp:
            (undocumented)
    """
    hipBoundaryModeZero = chip.hipBoundaryModeZero
    hipBoundaryModeTrap = chip.hipBoundaryModeTrap
    hipBoundaryModeClamp = chip.hipBoundaryModeClamp
    @staticmethod
    def ctypes_type():
        """The type of the enum constants as ctypes type."""
        return ctypes.c_uint


cdef class ihipCtx_t(hip._util.types.Pointer):
    """Python wrapper for cdef class chip.ihipCtx_t.

    Python wrapper for cdef class chip.ihipCtx_t.

    If this type is initialized via its `__init__` method, it allocates a
    member of the underlying C type and destroys it again if the wrapper
    type is deallocated.

    This type also serves as adapter when appearing as argument type in a
    function signature. In this case, the type can further be initialized
    from a number of Python objects:

    * `None`:

      This will set the ``self._ptr`` attribute to ``NULL``.

    * `int`:

      Interprets the integer value as pointer address and writes it to ``self._ptr``.
      No ownership is transferred.

    * `ctypes.c_void_p`:

      Takes the pointer address ``pyobj.value`` and writes it to ``self._ptr``.
      No ownership is transferred.

    * `object` that implements the `CUDA Array Interface <https://numba.readthedocs.io/en/stable/cuda/cuda_array_interface.html>`_ protocol:

      Takes the integer-valued pointer address, i.e. the first entry of the `data` tuple
      from `pyobj`'s member ``__cuda_array_interface__``  and writes it to ``self._ptr``.

    * `object` that implements the Python buffer protocol:

      If the object represents a simple contiguous array,
      writes the `Py_buffer` associated with ``pyobj`` to `self._py_buffer`,
      sets the `self._py_buffer_acquired` flag to `True`, and
      writes `self._py_buffer.buf` to the data pointer `self._ptr`.

    * `hip._util.types.Pointer`:

      Takes the pointer address ``pyobj._ptr`` and writes it to ``self._ptr``.
      No ownership is transferred.

    Type checks are performed in the above order.

    C Attributes:
        _ptr (C type ``void *``, protected):
            Stores a pointer to the data of the original Python object.
        _is_ptr_owner (C type ``bint``, protected):
            If this wrapper is the owner of the underlying data.
        _py_buffer (C type ``Py_buffer`, protected):
            Stores a pointer to the data of the original Python object.
        _py_buffer_acquired (C type ``bint``, protected):
            Stores a pointer to the data of the original Python object.
    """
    # C members declared in pxd file

    def __cinit__(self):
        self._ptr = NULL
        self._is_ptr_owner = False
        self._py_buffer_acquired = False

    cdef chip.ihipCtx_t* getElementPtr(self):
        return <chip.ihipCtx_t*>self._ptr

    @staticmethod
    cdef ihipCtx_t fromPtr(void* ptr, bint owner=False):
        """Factory function to create ``ihipCtx_t`` objects from
        given ``chip.ihipCtx_t`` pointer.
        """
        # Fast call to __new__() that bypasses the __init__() constructor.
        cdef ihipCtx_t wrapper = ihipCtx_t.__new__(ihipCtx_t)
        wrapper._ptr = ptr
        wrapper._is_ptr_owner = owner
        return wrapper

    @staticmethod
    def fromObj(pyobj):
        """Creates a ihipCtx_t from a Python object.

        Derives a ihipCtx_t from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``ihipCtx_t`` reference, this method
        returns it directly. No new ``ihipCtx_t`` is created in this case.
        """
        return ihipCtx_t.fromPyobj(pyobj)

    @staticmethod
    cdef ihipCtx_t fromPyobj(object pyobj):
        """Creates a ihipCtx_t from a Python object.

        Derives a ihipCtx_t from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``ihipCtx_t`` reference, this method
        returns it directly. No new ``ihipCtx_t`` is created in this case.

        Args:
            pyobj (object): Must be either `None`; a `hip._util.types.Pointer`; a simple, contiguous buffer according to the buffer protocol;
                            or of type `ihipCtx_t`; `int`; or `ctypes.c_void_p`.

        Note:
            This routine does not perform a copy but returns the original ``pyobj``
            if ``pyobj`` is an instance of ihipCtx_t!
        """
        cdef ihipCtx_t wrapper

        if isinstance(pyobj,ihipCtx_t):
            return pyobj
        else:
            wrapper = ihipCtx_t.__new__(ihipCtx_t)
            wrapper.init_from_pyobj(pyobj)
            return wrapper

    def __dealloc__(self):
        # Release the buffer handle
        if self._py_buffer_acquired is True:
            cpython.buffer.PyBuffer_Release(&self._py_buffer)

    def __int__(self):
        """Returns the data's address as long integer.
        """
        return cpython.long.PyLong_FromVoidPtr(self._ptr)

    def __repr__(self):
        return f"<ihipCtx_t object, ptr: {int(self)}>"

    def as_c_void_p(self):
        """Returns the data's address as `ctypes.c_void_p`
        Note:
            Implemented as function to not collide with
            autogenerated property names.
        """
        return ctypes.c_void_p(int(self))

    @staticmethod
    def PROPERTIES():
        return []

    def __contains__(self,item):
        properties = self.PROPERTIES()
        return item in properties

    def __getitem__(self,item):
        properties = self.PROPERTIES()
        if isinstance(item,int):
            if item < 0 or item >= len(properties):
                raise IndexError()
            return getattr(self,properties[item])
        raise ValueError("'item' type must be 'int'")


hipCtx_t = ihipCtx_t

class _hipDeviceP2PAttr__Base(enum.IntEnum):
    """Empty enum base class that allows subclassing.
    """
    pass
class hipDeviceP2PAttr(_hipDeviceP2PAttr__Base):
    """hipDeviceP2PAttr

    Attributes:
        hipDevP2PAttrPerformanceRank:
            (undocumented)
        hipDevP2PAttrAccessSupported:
            (undocumented)
        hipDevP2PAttrNativeAtomicSupported:
            (undocumented)
        hipDevP2PAttrHipArrayAccessSupported:
            (undocumented)
    """
    hipDevP2PAttrPerformanceRank = chip.hipDevP2PAttrPerformanceRank
    hipDevP2PAttrAccessSupported = chip.hipDevP2PAttrAccessSupported
    hipDevP2PAttrNativeAtomicSupported = chip.hipDevP2PAttrNativeAtomicSupported
    hipDevP2PAttrHipArrayAccessSupported = chip.hipDevP2PAttrHipArrayAccessSupported
    @staticmethod
    def ctypes_type():
        """The type of the enum constants as ctypes type."""
        return ctypes.c_uint


cdef class ihipStream_t(hip._util.types.Pointer):
    """Python wrapper for cdef class chip.ihipStream_t.

    Python wrapper for cdef class chip.ihipStream_t.

    If this type is initialized via its `__init__` method, it allocates a
    member of the underlying C type and destroys it again if the wrapper
    type is deallocated.

    This type also serves as adapter when appearing as argument type in a
    function signature. In this case, the type can further be initialized
    from a number of Python objects:

    * `None`:

      This will set the ``self._ptr`` attribute to ``NULL``.

    * `int`:

      Interprets the integer value as pointer address and writes it to ``self._ptr``.
      No ownership is transferred.

    * `ctypes.c_void_p`:

      Takes the pointer address ``pyobj.value`` and writes it to ``self._ptr``.
      No ownership is transferred.

    * `object` that implements the `CUDA Array Interface <https://numba.readthedocs.io/en/stable/cuda/cuda_array_interface.html>`_ protocol:

      Takes the integer-valued pointer address, i.e. the first entry of the `data` tuple
      from `pyobj`'s member ``__cuda_array_interface__``  and writes it to ``self._ptr``.

    * `object` that implements the Python buffer protocol:

      If the object represents a simple contiguous array,
      writes the `Py_buffer` associated with ``pyobj`` to `self._py_buffer`,
      sets the `self._py_buffer_acquired` flag to `True`, and
      writes `self._py_buffer.buf` to the data pointer `self._ptr`.

    * `hip._util.types.Pointer`:

      Takes the pointer address ``pyobj._ptr`` and writes it to ``self._ptr``.
      No ownership is transferred.

    Type checks are performed in the above order.

    C Attributes:
        _ptr (C type ``void *``, protected):
            Stores a pointer to the data of the original Python object.
        _is_ptr_owner (C type ``bint``, protected):
            If this wrapper is the owner of the underlying data.
        _py_buffer (C type ``Py_buffer`, protected):
            Stores a pointer to the data of the original Python object.
        _py_buffer_acquired (C type ``bint``, protected):
            Stores a pointer to the data of the original Python object.
    """
    # C members declared in pxd file

    def __cinit__(self):
        self._ptr = NULL
        self._is_ptr_owner = False
        self._py_buffer_acquired = False

    cdef chip.ihipStream_t* getElementPtr(self):
        return <chip.ihipStream_t*>self._ptr

    @staticmethod
    cdef ihipStream_t fromPtr(void* ptr, bint owner=False):
        """Factory function to create ``ihipStream_t`` objects from
        given ``chip.ihipStream_t`` pointer.
        """
        # Fast call to __new__() that bypasses the __init__() constructor.
        cdef ihipStream_t wrapper = ihipStream_t.__new__(ihipStream_t)
        wrapper._ptr = ptr
        wrapper._is_ptr_owner = owner
        return wrapper

    @staticmethod
    def fromObj(pyobj):
        """Creates a ihipStream_t from a Python object.

        Derives a ihipStream_t from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``ihipStream_t`` reference, this method
        returns it directly. No new ``ihipStream_t`` is created in this case.
        """
        return ihipStream_t.fromPyobj(pyobj)

    @staticmethod
    cdef ihipStream_t fromPyobj(object pyobj):
        """Creates a ihipStream_t from a Python object.

        Derives a ihipStream_t from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``ihipStream_t`` reference, this method
        returns it directly. No new ``ihipStream_t`` is created in this case.

        Args:
            pyobj (object): Must be either `None`; a `hip._util.types.Pointer`; a simple, contiguous buffer according to the buffer protocol;
                            or of type `ihipStream_t`; `int`; or `ctypes.c_void_p`.

        Note:
            This routine does not perform a copy but returns the original ``pyobj``
            if ``pyobj`` is an instance of ihipStream_t!
        """
        cdef ihipStream_t wrapper

        if isinstance(pyobj,ihipStream_t):
            return pyobj
        else:
            wrapper = ihipStream_t.__new__(ihipStream_t)
            wrapper.init_from_pyobj(pyobj)
            return wrapper

    def __dealloc__(self):
        # Release the buffer handle
        if self._py_buffer_acquired is True:
            cpython.buffer.PyBuffer_Release(&self._py_buffer)

    def __int__(self):
        """Returns the data's address as long integer.
        """
        return cpython.long.PyLong_FromVoidPtr(self._ptr)

    def __repr__(self):
        return f"<ihipStream_t object, ptr: {int(self)}>"

    def as_c_void_p(self):
        """Returns the data's address as `ctypes.c_void_p`
        Note:
            Implemented as function to not collide with
            autogenerated property names.
        """
        return ctypes.c_void_p(int(self))

    @staticmethod
    def PROPERTIES():
        return []

    def __contains__(self,item):
        properties = self.PROPERTIES()
        return item in properties

    def __getitem__(self,item):
        properties = self.PROPERTIES()
        if isinstance(item,int):
            if item < 0 or item >= len(properties):
                raise IndexError()
            return getattr(self,properties[item])
        raise ValueError("'item' type must be 'int'")


hipStream_t = ihipStream_t

cdef class hipIpcMemHandle_st(hip._util.types.Pointer):
    """Python wrapper for cdef class chip.hipIpcMemHandle_st.

    Python wrapper for cdef class chip.hipIpcMemHandle_st.

    If this type is initialized via its `__init__` method, it allocates a
    member of the underlying C type and destroys it again if the wrapper
    type is deallocated.

    This type also serves as adapter when appearing as argument type in a
    function signature. In this case, the type can further be initialized
    from a number of Python objects:

    * `None`:

      This will set the ``self._ptr`` attribute to ``NULL``.

    * `int`:

      Interprets the integer value as pointer address and writes it to ``self._ptr``.
      No ownership is transferred.

    * `ctypes.c_void_p`:

      Takes the pointer address ``pyobj.value`` and writes it to ``self._ptr``.
      No ownership is transferred.

    * `object` that implements the `CUDA Array Interface <https://numba.readthedocs.io/en/stable/cuda/cuda_array_interface.html>`_ protocol:

      Takes the integer-valued pointer address, i.e. the first entry of the `data` tuple
      from `pyobj`'s member ``__cuda_array_interface__``  and writes it to ``self._ptr``.

    * `object` that implements the Python buffer protocol:

      If the object represents a simple contiguous array,
      writes the `Py_buffer` associated with ``pyobj`` to `self._py_buffer`,
      sets the `self._py_buffer_acquired` flag to `True`, and
      writes `self._py_buffer.buf` to the data pointer `self._ptr`.

    * `hip._util.types.Pointer`:

      Takes the pointer address ``pyobj._ptr`` and writes it to ``self._ptr``.
      No ownership is transferred.

    Type checks are performed in the above order.

    C Attributes:
        _ptr (C type ``void *``, protected):
            Stores a pointer to the data of the original Python object.
        _is_ptr_owner (C type ``bint``, protected):
            If this wrapper is the owner of the underlying data.
        _py_buffer (C type ``Py_buffer`, protected):
            Stores a pointer to the data of the original Python object.
        _py_buffer_acquired (C type ``bint``, protected):
            Stores a pointer to the data of the original Python object.
    """
    # C members declared in pxd file

    def __cinit__(self):
        self._ptr = NULL
        self._is_ptr_owner = False
        self._py_buffer_acquired = False

    cdef chip.hipIpcMemHandle_st* getElementPtr(self):
        return <chip.hipIpcMemHandle_st*>self._ptr

    @staticmethod
    cdef hipIpcMemHandle_st fromPtr(void* ptr, bint owner=False):
        """Factory function to create ``hipIpcMemHandle_st`` objects from
        given ``chip.hipIpcMemHandle_st`` pointer.

        Setting ``owner`` flag to ``True`` causes
        the extension type to free the structure pointed to by ``ptr``
        when the wrapper object is deallocated.
        """
        # Fast call to __new__() that bypasses the __init__() constructor.
        cdef hipIpcMemHandle_st wrapper = hipIpcMemHandle_st.__new__(hipIpcMemHandle_st)
        wrapper._ptr = ptr
        wrapper._is_ptr_owner = owner
        return wrapper

    @staticmethod
    def fromObj(pyobj):
        """Creates a hipIpcMemHandle_st from a Python object.

        Derives a hipIpcMemHandle_st from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``hipIpcMemHandle_st`` reference, this method
        returns it directly. No new ``hipIpcMemHandle_st`` is created in this case.
        """
        return hipIpcMemHandle_st.fromPyobj(pyobj)

    @staticmethod
    cdef hipIpcMemHandle_st fromPyobj(object pyobj):
        """Creates a hipIpcMemHandle_st from a Python object.

        Derives a hipIpcMemHandle_st from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``hipIpcMemHandle_st`` reference, this method
        returns it directly. No new ``hipIpcMemHandle_st`` is created in this case.

        Args:
            pyobj (object): Must be either `None`; a `hip._util.types.Pointer`; a simple, contiguous buffer according to the buffer protocol;
                            or of type `hipIpcMemHandle_st`; `int`; or `ctypes.c_void_p`.

        Note:
            This routine does not perform a copy but returns the original ``pyobj``
            if ``pyobj`` is an instance of hipIpcMemHandle_st!
        """
        cdef hipIpcMemHandle_st wrapper

        if isinstance(pyobj,hipIpcMemHandle_st):
            return pyobj
        else:
            wrapper = hipIpcMemHandle_st.__new__(hipIpcMemHandle_st)
            wrapper.init_from_pyobj(pyobj)
            return wrapper

    def __dealloc__(self):
        # Release the buffer handle
        if self._py_buffer_acquired is True:
            cpython.buffer.PyBuffer_Release(&self._py_buffer)
        # De-allocate if not null and flag is set
        if self._ptr is not NULL and self._is_ptr_owner is True:
            stdlib.free(self._ptr)
            self._ptr = NULL

    @staticmethod
    cdef __allocate(void** ptr):
        ptr[0] = stdlib.malloc(sizeof(chip.hipIpcMemHandle_st))
        string.memset(<void*>ptr[0], 0, sizeof(chip.hipIpcMemHandle_st))

        if ptr[0] is NULL:
            raise MemoryError

    @staticmethod
    cdef hipIpcMemHandle_st new():
        """Factory function to create hipIpcMemHandle_st objects with
        newly allocated chip.hipIpcMemHandle_st"""
        cdef void* ptr
        hipIpcMemHandle_st.__allocate(&ptr)
        return hipIpcMemHandle_st.fromPtr(ptr, owner=True)

    @staticmethod
    cdef hipIpcMemHandle_st fromValue(chip.hipIpcMemHandle_st other):
        """Allocate new C type and copy from ``other``.
        """
        wrapper = hipIpcMemHandle_st.new()
        string.memcpy(wrapper._ptr, &other, sizeof(chip.hipIpcMemHandle_st))
        return wrapper

    def c_sizeof(self):
        """Returns the size of the underlying C type in bytes.
        Note:
            Implemented as function to not collide with
            autogenerated property names.
        """
        return sizeof(chip.hipIpcMemHandle_st)

    def __int__(self):
        """Returns the data's address as long integer.
        """
        return cpython.long.PyLong_FromVoidPtr(self._ptr)

    def __repr__(self):
        return f"<hipIpcMemHandle_st object, ptr: {int(self)}>"

    def as_c_void_p(self):
        """Returns the data's address as `ctypes.c_void_p`
        Note:
            Implemented as function to not collide with
            autogenerated property names.
        """
        return ctypes.c_void_p(int(self))

    def __init__(self,*args,**kwargs):
        """Constructor type hipIpcMemHandle_st.

        Constructor for type hipIpcMemHandle_st.

        Args:
            *args:
                Positional arguments. Initialize all or a subset of the member variables
                according to their order of declaration.
            **kwargs:
                Can be used to initialize member variables at construction,
                Just pass an argument expression of the form <member>=<value>
                per member that you want to initialize.
        """
        hipIpcMemHandle_st.__allocate(&self._ptr)
        self._is_ptr_owner = True
        attribs = self.PROPERTIES()
        used_attribs = set()
        if len(args) > len(attribs):
            raise ValueError("More positional arguments specified than this type has properties.")
        for i,v in enumerate(args):
            setattr(self,attribs[i],v)
            used_attribs.add(attribs[i])
        valid_names = ", ".join(["'"+p+"'" for p in attribs])
        for k,v in kwargs.items():
            if k in used_attribs:
                raise KeyError(f"argument '{k}' has already been specified as positional argument.")
            elif k not in attribs:
                raise KeyError(f"'{k}' is no valid property name. Valid names: {valid_names}")
            setattr(self,k,v)
    def get_reserved(self, i):
        """Get value of ``reserved`` of ``(<chip.hipIpcMemHandle_st*>self._ptr)[i]``.
        """
        return (<chip.hipIpcMemHandle_st*>self._ptr)[i].reserved
    # TODO add setters
    #def set_reserved(self, i, char[64] value):
    #    """Set value ``reserved`` of ``(<chip.hipIpcMemHandle_st*>self._ptr)[i]``.
    #    """
    #    (<chip.hipIpcMemHandle_st*>self._ptr)[i].reserved = value
    @property
    def reserved(self):
        """(undocumented)"""
        return self.get_reserved(0)
    # TODO add setters
    #@reserved.setter
    #def reserved(self, char[64] value):
    #    self.set_reserved(0,value)

    @staticmethod
    def PROPERTIES():
        return ["reserved"]

    def __contains__(self,item):
        properties = self.PROPERTIES()
        return item in properties

    def __getitem__(self,item):
        properties = self.PROPERTIES()
        if isinstance(item,int):
            if item < 0 or item >= len(properties):
                raise IndexError()
            return getattr(self,properties[item])
        raise ValueError("'item' type must be 'int'")


hipIpcMemHandle_t = hipIpcMemHandle_st

cdef class hipIpcEventHandle_st(hip._util.types.Pointer):
    """Python wrapper for cdef class chip.hipIpcEventHandle_st.

    Python wrapper for cdef class chip.hipIpcEventHandle_st.

    If this type is initialized via its `__init__` method, it allocates a
    member of the underlying C type and destroys it again if the wrapper
    type is deallocated.

    This type also serves as adapter when appearing as argument type in a
    function signature. In this case, the type can further be initialized
    from a number of Python objects:

    * `None`:

      This will set the ``self._ptr`` attribute to ``NULL``.

    * `int`:

      Interprets the integer value as pointer address and writes it to ``self._ptr``.
      No ownership is transferred.

    * `ctypes.c_void_p`:

      Takes the pointer address ``pyobj.value`` and writes it to ``self._ptr``.
      No ownership is transferred.

    * `object` that implements the `CUDA Array Interface <https://numba.readthedocs.io/en/stable/cuda/cuda_array_interface.html>`_ protocol:

      Takes the integer-valued pointer address, i.e. the first entry of the `data` tuple
      from `pyobj`'s member ``__cuda_array_interface__``  and writes it to ``self._ptr``.

    * `object` that implements the Python buffer protocol:

      If the object represents a simple contiguous array,
      writes the `Py_buffer` associated with ``pyobj`` to `self._py_buffer`,
      sets the `self._py_buffer_acquired` flag to `True`, and
      writes `self._py_buffer.buf` to the data pointer `self._ptr`.

    * `hip._util.types.Pointer`:

      Takes the pointer address ``pyobj._ptr`` and writes it to ``self._ptr``.
      No ownership is transferred.

    Type checks are performed in the above order.

    C Attributes:
        _ptr (C type ``void *``, protected):
            Stores a pointer to the data of the original Python object.
        _is_ptr_owner (C type ``bint``, protected):
            If this wrapper is the owner of the underlying data.
        _py_buffer (C type ``Py_buffer`, protected):
            Stores a pointer to the data of the original Python object.
        _py_buffer_acquired (C type ``bint``, protected):
            Stores a pointer to the data of the original Python object.
    """
    # C members declared in pxd file

    def __cinit__(self):
        self._ptr = NULL
        self._is_ptr_owner = False
        self._py_buffer_acquired = False

    cdef chip.hipIpcEventHandle_st* getElementPtr(self):
        return <chip.hipIpcEventHandle_st*>self._ptr

    @staticmethod
    cdef hipIpcEventHandle_st fromPtr(void* ptr, bint owner=False):
        """Factory function to create ``hipIpcEventHandle_st`` objects from
        given ``chip.hipIpcEventHandle_st`` pointer.

        Setting ``owner`` flag to ``True`` causes
        the extension type to free the structure pointed to by ``ptr``
        when the wrapper object is deallocated.
        """
        # Fast call to __new__() that bypasses the __init__() constructor.
        cdef hipIpcEventHandle_st wrapper = hipIpcEventHandle_st.__new__(hipIpcEventHandle_st)
        wrapper._ptr = ptr
        wrapper._is_ptr_owner = owner
        return wrapper

    @staticmethod
    def fromObj(pyobj):
        """Creates a hipIpcEventHandle_st from a Python object.

        Derives a hipIpcEventHandle_st from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``hipIpcEventHandle_st`` reference, this method
        returns it directly. No new ``hipIpcEventHandle_st`` is created in this case.
        """
        return hipIpcEventHandle_st.fromPyobj(pyobj)

    @staticmethod
    cdef hipIpcEventHandle_st fromPyobj(object pyobj):
        """Creates a hipIpcEventHandle_st from a Python object.

        Derives a hipIpcEventHandle_st from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``hipIpcEventHandle_st`` reference, this method
        returns it directly. No new ``hipIpcEventHandle_st`` is created in this case.

        Args:
            pyobj (object): Must be either `None`; a `hip._util.types.Pointer`; a simple, contiguous buffer according to the buffer protocol;
                            or of type `hipIpcEventHandle_st`; `int`; or `ctypes.c_void_p`.

        Note:
            This routine does not perform a copy but returns the original ``pyobj``
            if ``pyobj`` is an instance of hipIpcEventHandle_st!
        """
        cdef hipIpcEventHandle_st wrapper

        if isinstance(pyobj,hipIpcEventHandle_st):
            return pyobj
        else:
            wrapper = hipIpcEventHandle_st.__new__(hipIpcEventHandle_st)
            wrapper.init_from_pyobj(pyobj)
            return wrapper

    def __dealloc__(self):
        # Release the buffer handle
        if self._py_buffer_acquired is True:
            cpython.buffer.PyBuffer_Release(&self._py_buffer)
        # De-allocate if not null and flag is set
        if self._ptr is not NULL and self._is_ptr_owner is True:
            stdlib.free(self._ptr)
            self._ptr = NULL

    @staticmethod
    cdef __allocate(void** ptr):
        ptr[0] = stdlib.malloc(sizeof(chip.hipIpcEventHandle_st))
        string.memset(<void*>ptr[0], 0, sizeof(chip.hipIpcEventHandle_st))

        if ptr[0] is NULL:
            raise MemoryError

    @staticmethod
    cdef hipIpcEventHandle_st new():
        """Factory function to create hipIpcEventHandle_st objects with
        newly allocated chip.hipIpcEventHandle_st"""
        cdef void* ptr
        hipIpcEventHandle_st.__allocate(&ptr)
        return hipIpcEventHandle_st.fromPtr(ptr, owner=True)

    @staticmethod
    cdef hipIpcEventHandle_st fromValue(chip.hipIpcEventHandle_st other):
        """Allocate new C type and copy from ``other``.
        """
        wrapper = hipIpcEventHandle_st.new()
        string.memcpy(wrapper._ptr, &other, sizeof(chip.hipIpcEventHandle_st))
        return wrapper

    def c_sizeof(self):
        """Returns the size of the underlying C type in bytes.
        Note:
            Implemented as function to not collide with
            autogenerated property names.
        """
        return sizeof(chip.hipIpcEventHandle_st)

    def __int__(self):
        """Returns the data's address as long integer.
        """
        return cpython.long.PyLong_FromVoidPtr(self._ptr)

    def __repr__(self):
        return f"<hipIpcEventHandle_st object, ptr: {int(self)}>"

    def as_c_void_p(self):
        """Returns the data's address as `ctypes.c_void_p`
        Note:
            Implemented as function to not collide with
            autogenerated property names.
        """
        return ctypes.c_void_p(int(self))

    def __init__(self,*args,**kwargs):
        """Constructor type hipIpcEventHandle_st.

        Constructor for type hipIpcEventHandle_st.

        Args:
            *args:
                Positional arguments. Initialize all or a subset of the member variables
                according to their order of declaration.
            **kwargs:
                Can be used to initialize member variables at construction,
                Just pass an argument expression of the form <member>=<value>
                per member that you want to initialize.
        """
        hipIpcEventHandle_st.__allocate(&self._ptr)
        self._is_ptr_owner = True
        attribs = self.PROPERTIES()
        used_attribs = set()
        if len(args) > len(attribs):
            raise ValueError("More positional arguments specified than this type has properties.")
        for i,v in enumerate(args):
            setattr(self,attribs[i],v)
            used_attribs.add(attribs[i])
        valid_names = ", ".join(["'"+p+"'" for p in attribs])
        for k,v in kwargs.items():
            if k in used_attribs:
                raise KeyError(f"argument '{k}' has already been specified as positional argument.")
            elif k not in attribs:
                raise KeyError(f"'{k}' is no valid property name. Valid names: {valid_names}")
            setattr(self,k,v)
    def get_reserved(self, i):
        """Get value of ``reserved`` of ``(<chip.hipIpcEventHandle_st*>self._ptr)[i]``.
        """
        return (<chip.hipIpcEventHandle_st*>self._ptr)[i].reserved
    # TODO add setters
    #def set_reserved(self, i, char[64] value):
    #    """Set value ``reserved`` of ``(<chip.hipIpcEventHandle_st*>self._ptr)[i]``.
    #    """
    #    (<chip.hipIpcEventHandle_st*>self._ptr)[i].reserved = value
    @property
    def reserved(self):
        """(undocumented)"""
        return self.get_reserved(0)
    # TODO add setters
    #@reserved.setter
    #def reserved(self, char[64] value):
    #    self.set_reserved(0,value)

    @staticmethod
    def PROPERTIES():
        return ["reserved"]

    def __contains__(self,item):
        properties = self.PROPERTIES()
        return item in properties

    def __getitem__(self,item):
        properties = self.PROPERTIES()
        if isinstance(item,int):
            if item < 0 or item >= len(properties):
                raise IndexError()
            return getattr(self,properties[item])
        raise ValueError("'item' type must be 'int'")


hipIpcEventHandle_t = hipIpcEventHandle_st

cdef class ihipModule_t(hip._util.types.Pointer):
    """Python wrapper for cdef class chip.ihipModule_t.

    Python wrapper for cdef class chip.ihipModule_t.

    If this type is initialized via its `__init__` method, it allocates a
    member of the underlying C type and destroys it again if the wrapper
    type is deallocated.

    This type also serves as adapter when appearing as argument type in a
    function signature. In this case, the type can further be initialized
    from a number of Python objects:

    * `None`:

      This will set the ``self._ptr`` attribute to ``NULL``.

    * `int`:

      Interprets the integer value as pointer address and writes it to ``self._ptr``.
      No ownership is transferred.

    * `ctypes.c_void_p`:

      Takes the pointer address ``pyobj.value`` and writes it to ``self._ptr``.
      No ownership is transferred.

    * `object` that implements the `CUDA Array Interface <https://numba.readthedocs.io/en/stable/cuda/cuda_array_interface.html>`_ protocol:

      Takes the integer-valued pointer address, i.e. the first entry of the `data` tuple
      from `pyobj`'s member ``__cuda_array_interface__``  and writes it to ``self._ptr``.

    * `object` that implements the Python buffer protocol:

      If the object represents a simple contiguous array,
      writes the `Py_buffer` associated with ``pyobj`` to `self._py_buffer`,
      sets the `self._py_buffer_acquired` flag to `True`, and
      writes `self._py_buffer.buf` to the data pointer `self._ptr`.

    * `hip._util.types.Pointer`:

      Takes the pointer address ``pyobj._ptr`` and writes it to ``self._ptr``.
      No ownership is transferred.

    Type checks are performed in the above order.

    C Attributes:
        _ptr (C type ``void *``, protected):
            Stores a pointer to the data of the original Python object.
        _is_ptr_owner (C type ``bint``, protected):
            If this wrapper is the owner of the underlying data.
        _py_buffer (C type ``Py_buffer`, protected):
            Stores a pointer to the data of the original Python object.
        _py_buffer_acquired (C type ``bint``, protected):
            Stores a pointer to the data of the original Python object.
    """
    # C members declared in pxd file

    def __cinit__(self):
        self._ptr = NULL
        self._is_ptr_owner = False
        self._py_buffer_acquired = False

    cdef chip.ihipModule_t* getElementPtr(self):
        return <chip.ihipModule_t*>self._ptr

    @staticmethod
    cdef ihipModule_t fromPtr(void* ptr, bint owner=False):
        """Factory function to create ``ihipModule_t`` objects from
        given ``chip.ihipModule_t`` pointer.
        """
        # Fast call to __new__() that bypasses the __init__() constructor.
        cdef ihipModule_t wrapper = ihipModule_t.__new__(ihipModule_t)
        wrapper._ptr = ptr
        wrapper._is_ptr_owner = owner
        return wrapper

    @staticmethod
    def fromObj(pyobj):
        """Creates a ihipModule_t from a Python object.

        Derives a ihipModule_t from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``ihipModule_t`` reference, this method
        returns it directly. No new ``ihipModule_t`` is created in this case.
        """
        return ihipModule_t.fromPyobj(pyobj)

    @staticmethod
    cdef ihipModule_t fromPyobj(object pyobj):
        """Creates a ihipModule_t from a Python object.

        Derives a ihipModule_t from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``ihipModule_t`` reference, this method
        returns it directly. No new ``ihipModule_t`` is created in this case.

        Args:
            pyobj (object): Must be either `None`; a `hip._util.types.Pointer`; a simple, contiguous buffer according to the buffer protocol;
                            or of type `ihipModule_t`; `int`; or `ctypes.c_void_p`.

        Note:
            This routine does not perform a copy but returns the original ``pyobj``
            if ``pyobj`` is an instance of ihipModule_t!
        """
        cdef ihipModule_t wrapper

        if isinstance(pyobj,ihipModule_t):
            return pyobj
        else:
            wrapper = ihipModule_t.__new__(ihipModule_t)
            wrapper.init_from_pyobj(pyobj)
            return wrapper

    def __dealloc__(self):
        # Release the buffer handle
        if self._py_buffer_acquired is True:
            cpython.buffer.PyBuffer_Release(&self._py_buffer)

    def __int__(self):
        """Returns the data's address as long integer.
        """
        return cpython.long.PyLong_FromVoidPtr(self._ptr)

    def __repr__(self):
        return f"<ihipModule_t object, ptr: {int(self)}>"

    def as_c_void_p(self):
        """Returns the data's address as `ctypes.c_void_p`
        Note:
            Implemented as function to not collide with
            autogenerated property names.
        """
        return ctypes.c_void_p(int(self))

    @staticmethod
    def PROPERTIES():
        return []

    def __contains__(self,item):
        properties = self.PROPERTIES()
        return item in properties

    def __getitem__(self,item):
        properties = self.PROPERTIES()
        if isinstance(item,int):
            if item < 0 or item >= len(properties):
                raise IndexError()
            return getattr(self,properties[item])
        raise ValueError("'item' type must be 'int'")


hipModule_t = ihipModule_t

cdef class ihipModuleSymbol_t(hip._util.types.Pointer):
    """Python wrapper for cdef class chip.ihipModuleSymbol_t.

    Python wrapper for cdef class chip.ihipModuleSymbol_t.

    If this type is initialized via its `__init__` method, it allocates a
    member of the underlying C type and destroys it again if the wrapper
    type is deallocated.

    This type also serves as adapter when appearing as argument type in a
    function signature. In this case, the type can further be initialized
    from a number of Python objects:

    * `None`:

      This will set the ``self._ptr`` attribute to ``NULL``.

    * `int`:

      Interprets the integer value as pointer address and writes it to ``self._ptr``.
      No ownership is transferred.

    * `ctypes.c_void_p`:

      Takes the pointer address ``pyobj.value`` and writes it to ``self._ptr``.
      No ownership is transferred.

    * `object` that implements the `CUDA Array Interface <https://numba.readthedocs.io/en/stable/cuda/cuda_array_interface.html>`_ protocol:

      Takes the integer-valued pointer address, i.e. the first entry of the `data` tuple
      from `pyobj`'s member ``__cuda_array_interface__``  and writes it to ``self._ptr``.

    * `object` that implements the Python buffer protocol:

      If the object represents a simple contiguous array,
      writes the `Py_buffer` associated with ``pyobj`` to `self._py_buffer`,
      sets the `self._py_buffer_acquired` flag to `True`, and
      writes `self._py_buffer.buf` to the data pointer `self._ptr`.

    * `hip._util.types.Pointer`:

      Takes the pointer address ``pyobj._ptr`` and writes it to ``self._ptr``.
      No ownership is transferred.

    Type checks are performed in the above order.

    C Attributes:
        _ptr (C type ``void *``, protected):
            Stores a pointer to the data of the original Python object.
        _is_ptr_owner (C type ``bint``, protected):
            If this wrapper is the owner of the underlying data.
        _py_buffer (C type ``Py_buffer`, protected):
            Stores a pointer to the data of the original Python object.
        _py_buffer_acquired (C type ``bint``, protected):
            Stores a pointer to the data of the original Python object.
    """
    # C members declared in pxd file

    def __cinit__(self):
        self._ptr = NULL
        self._is_ptr_owner = False
        self._py_buffer_acquired = False

    cdef chip.ihipModuleSymbol_t* getElementPtr(self):
        return <chip.ihipModuleSymbol_t*>self._ptr

    @staticmethod
    cdef ihipModuleSymbol_t fromPtr(void* ptr, bint owner=False):
        """Factory function to create ``ihipModuleSymbol_t`` objects from
        given ``chip.ihipModuleSymbol_t`` pointer.
        """
        # Fast call to __new__() that bypasses the __init__() constructor.
        cdef ihipModuleSymbol_t wrapper = ihipModuleSymbol_t.__new__(ihipModuleSymbol_t)
        wrapper._ptr = ptr
        wrapper._is_ptr_owner = owner
        return wrapper

    @staticmethod
    def fromObj(pyobj):
        """Creates a ihipModuleSymbol_t from a Python object.

        Derives a ihipModuleSymbol_t from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``ihipModuleSymbol_t`` reference, this method
        returns it directly. No new ``ihipModuleSymbol_t`` is created in this case.
        """
        return ihipModuleSymbol_t.fromPyobj(pyobj)

    @staticmethod
    cdef ihipModuleSymbol_t fromPyobj(object pyobj):
        """Creates a ihipModuleSymbol_t from a Python object.

        Derives a ihipModuleSymbol_t from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``ihipModuleSymbol_t`` reference, this method
        returns it directly. No new ``ihipModuleSymbol_t`` is created in this case.

        Args:
            pyobj (object): Must be either `None`; a `hip._util.types.Pointer`; a simple, contiguous buffer according to the buffer protocol;
                            or of type `ihipModuleSymbol_t`; `int`; or `ctypes.c_void_p`.

        Note:
            This routine does not perform a copy but returns the original ``pyobj``
            if ``pyobj`` is an instance of ihipModuleSymbol_t!
        """
        cdef ihipModuleSymbol_t wrapper

        if isinstance(pyobj,ihipModuleSymbol_t):
            return pyobj
        else:
            wrapper = ihipModuleSymbol_t.__new__(ihipModuleSymbol_t)
            wrapper.init_from_pyobj(pyobj)
            return wrapper

    def __dealloc__(self):
        # Release the buffer handle
        if self._py_buffer_acquired is True:
            cpython.buffer.PyBuffer_Release(&self._py_buffer)

    def __int__(self):
        """Returns the data's address as long integer.
        """
        return cpython.long.PyLong_FromVoidPtr(self._ptr)

    def __repr__(self):
        return f"<ihipModuleSymbol_t object, ptr: {int(self)}>"

    def as_c_void_p(self):
        """Returns the data's address as `ctypes.c_void_p`
        Note:
            Implemented as function to not collide with
            autogenerated property names.
        """
        return ctypes.c_void_p(int(self))

    @staticmethod
    def PROPERTIES():
        return []

    def __contains__(self,item):
        properties = self.PROPERTIES()
        return item in properties

    def __getitem__(self,item):
        properties = self.PROPERTIES()
        if isinstance(item,int):
            if item < 0 or item >= len(properties):
                raise IndexError()
            return getattr(self,properties[item])
        raise ValueError("'item' type must be 'int'")


hipFunction_t = ihipModuleSymbol_t

cdef class ihipMemPoolHandle_t(hip._util.types.Pointer):
    """Python wrapper for cdef class chip.ihipMemPoolHandle_t.

    Python wrapper for cdef class chip.ihipMemPoolHandle_t.

    If this type is initialized via its `__init__` method, it allocates a
    member of the underlying C type and destroys it again if the wrapper
    type is deallocated.

    This type also serves as adapter when appearing as argument type in a
    function signature. In this case, the type can further be initialized
    from a number of Python objects:

    * `None`:

      This will set the ``self._ptr`` attribute to ``NULL``.

    * `int`:

      Interprets the integer value as pointer address and writes it to ``self._ptr``.
      No ownership is transferred.

    * `ctypes.c_void_p`:

      Takes the pointer address ``pyobj.value`` and writes it to ``self._ptr``.
      No ownership is transferred.

    * `object` that implements the `CUDA Array Interface <https://numba.readthedocs.io/en/stable/cuda/cuda_array_interface.html>`_ protocol:

      Takes the integer-valued pointer address, i.e. the first entry of the `data` tuple
      from `pyobj`'s member ``__cuda_array_interface__``  and writes it to ``self._ptr``.

    * `object` that implements the Python buffer protocol:

      If the object represents a simple contiguous array,
      writes the `Py_buffer` associated with ``pyobj`` to `self._py_buffer`,
      sets the `self._py_buffer_acquired` flag to `True`, and
      writes `self._py_buffer.buf` to the data pointer `self._ptr`.

    * `hip._util.types.Pointer`:

      Takes the pointer address ``pyobj._ptr`` and writes it to ``self._ptr``.
      No ownership is transferred.

    Type checks are performed in the above order.

    C Attributes:
        _ptr (C type ``void *``, protected):
            Stores a pointer to the data of the original Python object.
        _is_ptr_owner (C type ``bint``, protected):
            If this wrapper is the owner of the underlying data.
        _py_buffer (C type ``Py_buffer`, protected):
            Stores a pointer to the data of the original Python object.
        _py_buffer_acquired (C type ``bint``, protected):
            Stores a pointer to the data of the original Python object.
    """
    # C members declared in pxd file

    def __cinit__(self):
        self._ptr = NULL
        self._is_ptr_owner = False
        self._py_buffer_acquired = False

    cdef chip.ihipMemPoolHandle_t* getElementPtr(self):
        return <chip.ihipMemPoolHandle_t*>self._ptr

    @staticmethod
    cdef ihipMemPoolHandle_t fromPtr(void* ptr, bint owner=False):
        """Factory function to create ``ihipMemPoolHandle_t`` objects from
        given ``chip.ihipMemPoolHandle_t`` pointer.
        """
        # Fast call to __new__() that bypasses the __init__() constructor.
        cdef ihipMemPoolHandle_t wrapper = ihipMemPoolHandle_t.__new__(ihipMemPoolHandle_t)
        wrapper._ptr = ptr
        wrapper._is_ptr_owner = owner
        return wrapper

    @staticmethod
    def fromObj(pyobj):
        """Creates a ihipMemPoolHandle_t from a Python object.

        Derives a ihipMemPoolHandle_t from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``ihipMemPoolHandle_t`` reference, this method
        returns it directly. No new ``ihipMemPoolHandle_t`` is created in this case.
        """
        return ihipMemPoolHandle_t.fromPyobj(pyobj)

    @staticmethod
    cdef ihipMemPoolHandle_t fromPyobj(object pyobj):
        """Creates a ihipMemPoolHandle_t from a Python object.

        Derives a ihipMemPoolHandle_t from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``ihipMemPoolHandle_t`` reference, this method
        returns it directly. No new ``ihipMemPoolHandle_t`` is created in this case.

        Args:
            pyobj (object): Must be either `None`; a `hip._util.types.Pointer`; a simple, contiguous buffer according to the buffer protocol;
                            or of type `ihipMemPoolHandle_t`; `int`; or `ctypes.c_void_p`.

        Note:
            This routine does not perform a copy but returns the original ``pyobj``
            if ``pyobj`` is an instance of ihipMemPoolHandle_t!
        """
        cdef ihipMemPoolHandle_t wrapper

        if isinstance(pyobj,ihipMemPoolHandle_t):
            return pyobj
        else:
            wrapper = ihipMemPoolHandle_t.__new__(ihipMemPoolHandle_t)
            wrapper.init_from_pyobj(pyobj)
            return wrapper

    def __dealloc__(self):
        # Release the buffer handle
        if self._py_buffer_acquired is True:
            cpython.buffer.PyBuffer_Release(&self._py_buffer)

    def __int__(self):
        """Returns the data's address as long integer.
        """
        return cpython.long.PyLong_FromVoidPtr(self._ptr)

    def __repr__(self):
        return f"<ihipMemPoolHandle_t object, ptr: {int(self)}>"

    def as_c_void_p(self):
        """Returns the data's address as `ctypes.c_void_p`
        Note:
            Implemented as function to not collide with
            autogenerated property names.
        """
        return ctypes.c_void_p(int(self))

    @staticmethod
    def PROPERTIES():
        return []

    def __contains__(self,item):
        properties = self.PROPERTIES()
        return item in properties

    def __getitem__(self,item):
        properties = self.PROPERTIES()
        if isinstance(item,int):
            if item < 0 or item >= len(properties):
                raise IndexError()
            return getattr(self,properties[item])
        raise ValueError("'item' type must be 'int'")


hipMemPool_t = ihipMemPoolHandle_t

cdef class hipFuncAttributes(hip._util.types.Pointer):
    """Python wrapper for cdef class chip.hipFuncAttributes.

    Python wrapper for cdef class chip.hipFuncAttributes.

    If this type is initialized via its `__init__` method, it allocates a
    member of the underlying C type and destroys it again if the wrapper
    type is deallocated.

    This type also serves as adapter when appearing as argument type in a
    function signature. In this case, the type can further be initialized
    from a number of Python objects:

    * `None`:

      This will set the ``self._ptr`` attribute to ``NULL``.

    * `int`:

      Interprets the integer value as pointer address and writes it to ``self._ptr``.
      No ownership is transferred.

    * `ctypes.c_void_p`:

      Takes the pointer address ``pyobj.value`` and writes it to ``self._ptr``.
      No ownership is transferred.

    * `object` that implements the `CUDA Array Interface <https://numba.readthedocs.io/en/stable/cuda/cuda_array_interface.html>`_ protocol:

      Takes the integer-valued pointer address, i.e. the first entry of the `data` tuple
      from `pyobj`'s member ``__cuda_array_interface__``  and writes it to ``self._ptr``.

    * `object` that implements the Python buffer protocol:

      If the object represents a simple contiguous array,
      writes the `Py_buffer` associated with ``pyobj`` to `self._py_buffer`,
      sets the `self._py_buffer_acquired` flag to `True`, and
      writes `self._py_buffer.buf` to the data pointer `self._ptr`.

    * `hip._util.types.Pointer`:

      Takes the pointer address ``pyobj._ptr`` and writes it to ``self._ptr``.
      No ownership is transferred.

    Type checks are performed in the above order.

    C Attributes:
        _ptr (C type ``void *``, protected):
            Stores a pointer to the data of the original Python object.
        _is_ptr_owner (C type ``bint``, protected):
            If this wrapper is the owner of the underlying data.
        _py_buffer (C type ``Py_buffer`, protected):
            Stores a pointer to the data of the original Python object.
        _py_buffer_acquired (C type ``bint``, protected):
            Stores a pointer to the data of the original Python object.
    """
    # C members declared in pxd file

    def __cinit__(self):
        self._ptr = NULL
        self._is_ptr_owner = False
        self._py_buffer_acquired = False

    cdef chip.hipFuncAttributes* getElementPtr(self):
        return <chip.hipFuncAttributes*>self._ptr

    @staticmethod
    cdef hipFuncAttributes fromPtr(void* ptr, bint owner=False):
        """Factory function to create ``hipFuncAttributes`` objects from
        given ``chip.hipFuncAttributes`` pointer.

        Setting ``owner`` flag to ``True`` causes
        the extension type to free the structure pointed to by ``ptr``
        when the wrapper object is deallocated.
        """
        # Fast call to __new__() that bypasses the __init__() constructor.
        cdef hipFuncAttributes wrapper = hipFuncAttributes.__new__(hipFuncAttributes)
        wrapper._ptr = ptr
        wrapper._is_ptr_owner = owner
        return wrapper

    @staticmethod
    def fromObj(pyobj):
        """Creates a hipFuncAttributes from a Python object.

        Derives a hipFuncAttributes from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``hipFuncAttributes`` reference, this method
        returns it directly. No new ``hipFuncAttributes`` is created in this case.
        """
        return hipFuncAttributes.fromPyobj(pyobj)

    @staticmethod
    cdef hipFuncAttributes fromPyobj(object pyobj):
        """Creates a hipFuncAttributes from a Python object.

        Derives a hipFuncAttributes from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``hipFuncAttributes`` reference, this method
        returns it directly. No new ``hipFuncAttributes`` is created in this case.

        Args:
            pyobj (object): Must be either `None`; a `hip._util.types.Pointer`; a simple, contiguous buffer according to the buffer protocol;
                            or of type `hipFuncAttributes`; `int`; or `ctypes.c_void_p`.

        Note:
            This routine does not perform a copy but returns the original ``pyobj``
            if ``pyobj`` is an instance of hipFuncAttributes!
        """
        cdef hipFuncAttributes wrapper

        if isinstance(pyobj,hipFuncAttributes):
            return pyobj
        else:
            wrapper = hipFuncAttributes.__new__(hipFuncAttributes)
            wrapper.init_from_pyobj(pyobj)
            return wrapper

    def __dealloc__(self):
        # Release the buffer handle
        if self._py_buffer_acquired is True:
            cpython.buffer.PyBuffer_Release(&self._py_buffer)
        # De-allocate if not null and flag is set
        if self._ptr is not NULL and self._is_ptr_owner is True:
            stdlib.free(self._ptr)
            self._ptr = NULL

    @staticmethod
    cdef __allocate(void** ptr):
        ptr[0] = stdlib.malloc(sizeof(chip.hipFuncAttributes))
        string.memset(<void*>ptr[0], 0, sizeof(chip.hipFuncAttributes))

        if ptr[0] is NULL:
            raise MemoryError

    @staticmethod
    cdef hipFuncAttributes new():
        """Factory function to create hipFuncAttributes objects with
        newly allocated chip.hipFuncAttributes"""
        cdef void* ptr
        hipFuncAttributes.__allocate(&ptr)
        return hipFuncAttributes.fromPtr(ptr, owner=True)

    @staticmethod
    cdef hipFuncAttributes fromValue(chip.hipFuncAttributes other):
        """Allocate new C type and copy from ``other``.
        """
        wrapper = hipFuncAttributes.new()
        string.memcpy(wrapper._ptr, &other, sizeof(chip.hipFuncAttributes))
        return wrapper

    def c_sizeof(self):
        """Returns the size of the underlying C type in bytes.
        Note:
            Implemented as function to not collide with
            autogenerated property names.
        """
        return sizeof(chip.hipFuncAttributes)

    def __int__(self):
        """Returns the data's address as long integer.
        """
        return cpython.long.PyLong_FromVoidPtr(self._ptr)

    def __repr__(self):
        return f"<hipFuncAttributes object, ptr: {int(self)}>"

    def as_c_void_p(self):
        """Returns the data's address as `ctypes.c_void_p`
        Note:
            Implemented as function to not collide with
            autogenerated property names.
        """
        return ctypes.c_void_p(int(self))

    def __init__(self,*args,**kwargs):
        """Constructor type hipFuncAttributes.

        Constructor for type hipFuncAttributes.

        Args:
            *args:
                Positional arguments. Initialize all or a subset of the member variables
                according to their order of declaration.
            **kwargs:
                Can be used to initialize member variables at construction,
                Just pass an argument expression of the form <member>=<value>
                per member that you want to initialize.
        """
        hipFuncAttributes.__allocate(&self._ptr)
        self._is_ptr_owner = True
        attribs = self.PROPERTIES()
        used_attribs = set()
        if len(args) > len(attribs):
            raise ValueError("More positional arguments specified than this type has properties.")
        for i,v in enumerate(args):
            setattr(self,attribs[i],v)
            used_attribs.add(attribs[i])
        valid_names = ", ".join(["'"+p+"'" for p in attribs])
        for k,v in kwargs.items():
            if k in used_attribs:
                raise KeyError(f"argument '{k}' has already been specified as positional argument.")
            elif k not in attribs:
                raise KeyError(f"'{k}' is no valid property name. Valid names: {valid_names}")
            setattr(self,k,v)
    def get_binaryVersion(self, i):
        """Get value ``binaryVersion`` of ``(<chip.hipFuncAttributes*>self._ptr)[i]``.
        """
        return (<chip.hipFuncAttributes*>self._ptr)[i].binaryVersion
    def set_binaryVersion(self, i, int value):
        """Set value ``binaryVersion`` of ``(<chip.hipFuncAttributes*>self._ptr)[i]``.
        """
        (<chip.hipFuncAttributes*>self._ptr)[i].binaryVersion = value
    @property
    def binaryVersion(self):
        """(undocumented)"""
        return self.get_binaryVersion(0)
    @binaryVersion.setter
    def binaryVersion(self, int value):
        self.set_binaryVersion(0,value)

    def get_cacheModeCA(self, i):
        """Get value ``cacheModeCA`` of ``(<chip.hipFuncAttributes*>self._ptr)[i]``.
        """
        return (<chip.hipFuncAttributes*>self._ptr)[i].cacheModeCA
    def set_cacheModeCA(self, i, int value):
        """Set value ``cacheModeCA`` of ``(<chip.hipFuncAttributes*>self._ptr)[i]``.
        """
        (<chip.hipFuncAttributes*>self._ptr)[i].cacheModeCA = value
    @property
    def cacheModeCA(self):
        """(undocumented)"""
        return self.get_cacheModeCA(0)
    @cacheModeCA.setter
    def cacheModeCA(self, int value):
        self.set_cacheModeCA(0,value)

    def get_constSizeBytes(self, i):
        """Get value ``constSizeBytes`` of ``(<chip.hipFuncAttributes*>self._ptr)[i]``.
        """
        return (<chip.hipFuncAttributes*>self._ptr)[i].constSizeBytes
    def set_constSizeBytes(self, i, unsigned long value):
        """Set value ``constSizeBytes`` of ``(<chip.hipFuncAttributes*>self._ptr)[i]``.
        """
        (<chip.hipFuncAttributes*>self._ptr)[i].constSizeBytes = value
    @property
    def constSizeBytes(self):
        """(undocumented)"""
        return self.get_constSizeBytes(0)
    @constSizeBytes.setter
    def constSizeBytes(self, unsigned long value):
        self.set_constSizeBytes(0,value)

    def get_localSizeBytes(self, i):
        """Get value ``localSizeBytes`` of ``(<chip.hipFuncAttributes*>self._ptr)[i]``.
        """
        return (<chip.hipFuncAttributes*>self._ptr)[i].localSizeBytes
    def set_localSizeBytes(self, i, unsigned long value):
        """Set value ``localSizeBytes`` of ``(<chip.hipFuncAttributes*>self._ptr)[i]``.
        """
        (<chip.hipFuncAttributes*>self._ptr)[i].localSizeBytes = value
    @property
    def localSizeBytes(self):
        """(undocumented)"""
        return self.get_localSizeBytes(0)
    @localSizeBytes.setter
    def localSizeBytes(self, unsigned long value):
        self.set_localSizeBytes(0,value)

    def get_maxDynamicSharedSizeBytes(self, i):
        """Get value ``maxDynamicSharedSizeBytes`` of ``(<chip.hipFuncAttributes*>self._ptr)[i]``.
        """
        return (<chip.hipFuncAttributes*>self._ptr)[i].maxDynamicSharedSizeBytes
    def set_maxDynamicSharedSizeBytes(self, i, int value):
        """Set value ``maxDynamicSharedSizeBytes`` of ``(<chip.hipFuncAttributes*>self._ptr)[i]``.
        """
        (<chip.hipFuncAttributes*>self._ptr)[i].maxDynamicSharedSizeBytes = value
    @property
    def maxDynamicSharedSizeBytes(self):
        """(undocumented)"""
        return self.get_maxDynamicSharedSizeBytes(0)
    @maxDynamicSharedSizeBytes.setter
    def maxDynamicSharedSizeBytes(self, int value):
        self.set_maxDynamicSharedSizeBytes(0,value)

    def get_maxThreadsPerBlock(self, i):
        """Get value ``maxThreadsPerBlock`` of ``(<chip.hipFuncAttributes*>self._ptr)[i]``.
        """
        return (<chip.hipFuncAttributes*>self._ptr)[i].maxThreadsPerBlock
    def set_maxThreadsPerBlock(self, i, int value):
        """Set value ``maxThreadsPerBlock`` of ``(<chip.hipFuncAttributes*>self._ptr)[i]``.
        """
        (<chip.hipFuncAttributes*>self._ptr)[i].maxThreadsPerBlock = value
    @property
    def maxThreadsPerBlock(self):
        """(undocumented)"""
        return self.get_maxThreadsPerBlock(0)
    @maxThreadsPerBlock.setter
    def maxThreadsPerBlock(self, int value):
        self.set_maxThreadsPerBlock(0,value)

    def get_numRegs(self, i):
        """Get value ``numRegs`` of ``(<chip.hipFuncAttributes*>self._ptr)[i]``.
        """
        return (<chip.hipFuncAttributes*>self._ptr)[i].numRegs
    def set_numRegs(self, i, int value):
        """Set value ``numRegs`` of ``(<chip.hipFuncAttributes*>self._ptr)[i]``.
        """
        (<chip.hipFuncAttributes*>self._ptr)[i].numRegs = value
    @property
    def numRegs(self):
        """(undocumented)"""
        return self.get_numRegs(0)
    @numRegs.setter
    def numRegs(self, int value):
        self.set_numRegs(0,value)

    def get_preferredShmemCarveout(self, i):
        """Get value ``preferredShmemCarveout`` of ``(<chip.hipFuncAttributes*>self._ptr)[i]``.
        """
        return (<chip.hipFuncAttributes*>self._ptr)[i].preferredShmemCarveout
    def set_preferredShmemCarveout(self, i, int value):
        """Set value ``preferredShmemCarveout`` of ``(<chip.hipFuncAttributes*>self._ptr)[i]``.
        """
        (<chip.hipFuncAttributes*>self._ptr)[i].preferredShmemCarveout = value
    @property
    def preferredShmemCarveout(self):
        """(undocumented)"""
        return self.get_preferredShmemCarveout(0)
    @preferredShmemCarveout.setter
    def preferredShmemCarveout(self, int value):
        self.set_preferredShmemCarveout(0,value)

    def get_ptxVersion(self, i):
        """Get value ``ptxVersion`` of ``(<chip.hipFuncAttributes*>self._ptr)[i]``.
        """
        return (<chip.hipFuncAttributes*>self._ptr)[i].ptxVersion
    def set_ptxVersion(self, i, int value):
        """Set value ``ptxVersion`` of ``(<chip.hipFuncAttributes*>self._ptr)[i]``.
        """
        (<chip.hipFuncAttributes*>self._ptr)[i].ptxVersion = value
    @property
    def ptxVersion(self):
        """(undocumented)"""
        return self.get_ptxVersion(0)
    @ptxVersion.setter
    def ptxVersion(self, int value):
        self.set_ptxVersion(0,value)

    def get_sharedSizeBytes(self, i):
        """Get value ``sharedSizeBytes`` of ``(<chip.hipFuncAttributes*>self._ptr)[i]``.
        """
        return (<chip.hipFuncAttributes*>self._ptr)[i].sharedSizeBytes
    def set_sharedSizeBytes(self, i, unsigned long value):
        """Set value ``sharedSizeBytes`` of ``(<chip.hipFuncAttributes*>self._ptr)[i]``.
        """
        (<chip.hipFuncAttributes*>self._ptr)[i].sharedSizeBytes = value
    @property
    def sharedSizeBytes(self):
        """(undocumented)"""
        return self.get_sharedSizeBytes(0)
    @sharedSizeBytes.setter
    def sharedSizeBytes(self, unsigned long value):
        self.set_sharedSizeBytes(0,value)

    @staticmethod
    def PROPERTIES():
        return ["binaryVersion","cacheModeCA","constSizeBytes","localSizeBytes","maxDynamicSharedSizeBytes","maxThreadsPerBlock","numRegs","preferredShmemCarveout","ptxVersion","sharedSizeBytes"]

    def __contains__(self,item):
        properties = self.PROPERTIES()
        return item in properties

    def __getitem__(self,item):
        properties = self.PROPERTIES()
        if isinstance(item,int):
            if item < 0 or item >= len(properties):
                raise IndexError()
            return getattr(self,properties[item])
        raise ValueError("'item' type must be 'int'")


cdef class ihipEvent_t(hip._util.types.Pointer):
    """Python wrapper for cdef class chip.ihipEvent_t.

    Python wrapper for cdef class chip.ihipEvent_t.

    If this type is initialized via its `__init__` method, it allocates a
    member of the underlying C type and destroys it again if the wrapper
    type is deallocated.

    This type also serves as adapter when appearing as argument type in a
    function signature. In this case, the type can further be initialized
    from a number of Python objects:

    * `None`:

      This will set the ``self._ptr`` attribute to ``NULL``.

    * `int`:

      Interprets the integer value as pointer address and writes it to ``self._ptr``.
      No ownership is transferred.

    * `ctypes.c_void_p`:

      Takes the pointer address ``pyobj.value`` and writes it to ``self._ptr``.
      No ownership is transferred.

    * `object` that implements the `CUDA Array Interface <https://numba.readthedocs.io/en/stable/cuda/cuda_array_interface.html>`_ protocol:

      Takes the integer-valued pointer address, i.e. the first entry of the `data` tuple
      from `pyobj`'s member ``__cuda_array_interface__``  and writes it to ``self._ptr``.

    * `object` that implements the Python buffer protocol:

      If the object represents a simple contiguous array,
      writes the `Py_buffer` associated with ``pyobj`` to `self._py_buffer`,
      sets the `self._py_buffer_acquired` flag to `True`, and
      writes `self._py_buffer.buf` to the data pointer `self._ptr`.

    * `hip._util.types.Pointer`:

      Takes the pointer address ``pyobj._ptr`` and writes it to ``self._ptr``.
      No ownership is transferred.

    Type checks are performed in the above order.

    C Attributes:
        _ptr (C type ``void *``, protected):
            Stores a pointer to the data of the original Python object.
        _is_ptr_owner (C type ``bint``, protected):
            If this wrapper is the owner of the underlying data.
        _py_buffer (C type ``Py_buffer`, protected):
            Stores a pointer to the data of the original Python object.
        _py_buffer_acquired (C type ``bint``, protected):
            Stores a pointer to the data of the original Python object.
    """
    # C members declared in pxd file

    def __cinit__(self):
        self._ptr = NULL
        self._is_ptr_owner = False
        self._py_buffer_acquired = False

    cdef chip.ihipEvent_t* getElementPtr(self):
        return <chip.ihipEvent_t*>self._ptr

    @staticmethod
    cdef ihipEvent_t fromPtr(void* ptr, bint owner=False):
        """Factory function to create ``ihipEvent_t`` objects from
        given ``chip.ihipEvent_t`` pointer.
        """
        # Fast call to __new__() that bypasses the __init__() constructor.
        cdef ihipEvent_t wrapper = ihipEvent_t.__new__(ihipEvent_t)
        wrapper._ptr = ptr
        wrapper._is_ptr_owner = owner
        return wrapper

    @staticmethod
    def fromObj(pyobj):
        """Creates a ihipEvent_t from a Python object.

        Derives a ihipEvent_t from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``ihipEvent_t`` reference, this method
        returns it directly. No new ``ihipEvent_t`` is created in this case.
        """
        return ihipEvent_t.fromPyobj(pyobj)

    @staticmethod
    cdef ihipEvent_t fromPyobj(object pyobj):
        """Creates a ihipEvent_t from a Python object.

        Derives a ihipEvent_t from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``ihipEvent_t`` reference, this method
        returns it directly. No new ``ihipEvent_t`` is created in this case.

        Args:
            pyobj (object): Must be either `None`; a `hip._util.types.Pointer`; a simple, contiguous buffer according to the buffer protocol;
                            or of type `ihipEvent_t`; `int`; or `ctypes.c_void_p`.

        Note:
            This routine does not perform a copy but returns the original ``pyobj``
            if ``pyobj`` is an instance of ihipEvent_t!
        """
        cdef ihipEvent_t wrapper

        if isinstance(pyobj,ihipEvent_t):
            return pyobj
        else:
            wrapper = ihipEvent_t.__new__(ihipEvent_t)
            wrapper.init_from_pyobj(pyobj)
            return wrapper

    def __dealloc__(self):
        # Release the buffer handle
        if self._py_buffer_acquired is True:
            cpython.buffer.PyBuffer_Release(&self._py_buffer)

    def __int__(self):
        """Returns the data's address as long integer.
        """
        return cpython.long.PyLong_FromVoidPtr(self._ptr)

    def __repr__(self):
        return f"<ihipEvent_t object, ptr: {int(self)}>"

    def as_c_void_p(self):
        """Returns the data's address as `ctypes.c_void_p`
        Note:
            Implemented as function to not collide with
            autogenerated property names.
        """
        return ctypes.c_void_p(int(self))

    @staticmethod
    def PROPERTIES():
        return []

    def __contains__(self,item):
        properties = self.PROPERTIES()
        return item in properties

    def __getitem__(self,item):
        properties = self.PROPERTIES()
        if isinstance(item,int):
            if item < 0 or item >= len(properties):
                raise IndexError()
            return getattr(self,properties[item])
        raise ValueError("'item' type must be 'int'")


hipEvent_t = ihipEvent_t

class _hipLimit_t__Base(enum.IntEnum):
    """Empty enum base class that allows subclassing.
    """
    pass
class hipLimit_t(_hipLimit_t__Base):
    """hipLimit

    Attributes:
        hipLimitStackSize:
            Limit of stack size in bytes on the current device, per thread. The size is in units of 256 dwords, up to the limit of (128K - 16)
        hipLimitPrintfFifoSize:
            Size limit in bytes of fifo used by printf call on the device. Currently not supported
        hipLimitMallocHeapSize:
            Limit of heap size in bytes on the current device, should be less than the global memory size on the device
        hipLimitRange:
            Supported limit range
    """
    hipLimitStackSize = chip.hipLimitStackSize
    hipLimitPrintfFifoSize = chip.hipLimitPrintfFifoSize
    hipLimitMallocHeapSize = chip.hipLimitMallocHeapSize
    hipLimitRange = chip.hipLimitRange
    @staticmethod
    def ctypes_type():
        """The type of the enum constants as ctypes type."""
        return ctypes.c_uint


class _hipMemoryAdvise__Base(enum.IntEnum):
    """Empty enum base class that allows subclassing.
    """
    pass
class hipMemoryAdvise(_hipMemoryAdvise__Base):
    """HIP Memory Advise values

    Attributes:
        hipMemAdviseSetReadMostly:
            Data will mostly be read and only occassionally be written to
        hipMemAdviseUnsetReadMostly:
            Undo the effect of hipMemAdviseSetReadMostly
        hipMemAdviseSetPreferredLocation:
            Set the preferred location for the data as the specified device
        hipMemAdviseUnsetPreferredLocation:
            Clear the preferred location for the data
        hipMemAdviseSetAccessedBy:
            Data will be accessed by the specified device so prevent page faults as much as possible
        hipMemAdviseUnsetAccessedBy:
            Let HIP to decide on the page faulting policy for the specified device
        hipMemAdviseSetCoarseGrain:
            The default memory model is fine-grain. That allows coherent operations between host and device, while executing kernels. The coarse-grain can be used for data that only needs to be coherent at dispatch boundaries for better performance
        hipMemAdviseUnsetCoarseGrain:
            Restores cache coherency policy back to fine-grain
    """
    hipMemAdviseSetReadMostly = chip.hipMemAdviseSetReadMostly
    hipMemAdviseUnsetReadMostly = chip.hipMemAdviseUnsetReadMostly
    hipMemAdviseSetPreferredLocation = chip.hipMemAdviseSetPreferredLocation
    hipMemAdviseUnsetPreferredLocation = chip.hipMemAdviseUnsetPreferredLocation
    hipMemAdviseSetAccessedBy = chip.hipMemAdviseSetAccessedBy
    hipMemAdviseUnsetAccessedBy = chip.hipMemAdviseUnsetAccessedBy
    hipMemAdviseSetCoarseGrain = chip.hipMemAdviseSetCoarseGrain
    hipMemAdviseUnsetCoarseGrain = chip.hipMemAdviseUnsetCoarseGrain
    @staticmethod
    def ctypes_type():
        """The type of the enum constants as ctypes type."""
        return ctypes.c_uint


class _hipMemRangeCoherencyMode__Base(enum.IntEnum):
    """Empty enum base class that allows subclassing.
    """
    pass
class hipMemRangeCoherencyMode(_hipMemRangeCoherencyMode__Base):
    """HIP Coherency Mode

    Attributes:
        hipMemRangeCoherencyModeFineGrain:
            Updates to memory with this attribute can be done coherently from all devices
        hipMemRangeCoherencyModeCoarseGrain:
            Writes to memory with this attribute can be performed by a single device at a time
        hipMemRangeCoherencyModeIndeterminate:
            Memory region queried contains subregions with both hipMemRangeCoherencyModeFineGrain and hipMemRangeCoherencyModeCoarseGrain attributes
    """
    hipMemRangeCoherencyModeFineGrain = chip.hipMemRangeCoherencyModeFineGrain
    hipMemRangeCoherencyModeCoarseGrain = chip.hipMemRangeCoherencyModeCoarseGrain
    hipMemRangeCoherencyModeIndeterminate = chip.hipMemRangeCoherencyModeIndeterminate
    @staticmethod
    def ctypes_type():
        """The type of the enum constants as ctypes type."""
        return ctypes.c_uint


class _hipMemRangeAttribute__Base(enum.IntEnum):
    """Empty enum base class that allows subclassing.
    """
    pass
class hipMemRangeAttribute(_hipMemRangeAttribute__Base):
    """HIP range attributes

    Attributes:
        hipMemRangeAttributeReadMostly:
            Whether the range will mostly be read and only occassionally be written to
        hipMemRangeAttributePreferredLocation:
            The preferred location of the range
        hipMemRangeAttributeAccessedBy:
            Memory range has hipMemAdviseSetAccessedBy set for the specified device
        hipMemRangeAttributeLastPrefetchLocation:
            The last location to where the range was prefetched
        hipMemRangeAttributeCoherencyMode:
            Returns coherency mode hipMemRangeCoherencyMode for the range
    """
    hipMemRangeAttributeReadMostly = chip.hipMemRangeAttributeReadMostly
    hipMemRangeAttributePreferredLocation = chip.hipMemRangeAttributePreferredLocation
    hipMemRangeAttributeAccessedBy = chip.hipMemRangeAttributeAccessedBy
    hipMemRangeAttributeLastPrefetchLocation = chip.hipMemRangeAttributeLastPrefetchLocation
    hipMemRangeAttributeCoherencyMode = chip.hipMemRangeAttributeCoherencyMode
    @staticmethod
    def ctypes_type():
        """The type of the enum constants as ctypes type."""
        return ctypes.c_uint


class _hipMemPoolAttr__Base(enum.IntEnum):
    """Empty enum base class that allows subclassing.
    """
    pass
class hipMemPoolAttr(_hipMemPoolAttr__Base):
    """HIP memory pool attributes

    Attributes:
        hipMemPoolReuseFollowEventDependencies:
            (value type = int) Allow hipMemAllocAsync to use memory asynchronously freed in another streams as long as a stream ordering dependency of the allocating stream on the free action exists. hip events and null stream interactions can create the required stream ordered dependencies. (default enabled)
        hipMemPoolReuseAllowOpportunistic:
            (value type = int) Allow reuse of already completed frees when there is no dependency between the free and allocation. (default enabled)
        hipMemPoolReuseAllowInternalDependencies:
            (value type = int) Allow hipMemAllocAsync to insert new stream dependencies in order to establish the stream ordering required to reuse a piece of memory released by cuFreeAsync (default enabled).
        hipMemPoolAttrReleaseThreshold:
            (value type = uint64_t) Amount of reserved memory in bytes to hold onto before trying to release memory back to the OS. When more than the release threshold bytes of memory are held by the memory pool, the allocator will try to release memory back to the OS on the next call to stream, event or context synchronize. (default 0)
        hipMemPoolAttrReservedMemCurrent:
            (value type = uint64_t) Amount of backing memory currently allocated for the mempool.
        hipMemPoolAttrReservedMemHigh:
            (value type = uint64_t) High watermark of backing memory allocated for the mempool since the last time it was reset. High watermark can only be reset to zero.
        hipMemPoolAttrUsedMemCurrent:
            (value type = uint64_t) Amount of memory from the pool that is currently in use by the application.
        hipMemPoolAttrUsedMemHigh:
            (value type = uint64_t) High watermark of the amount of memory from the pool that was in use by the application since the last time it was reset. High watermark can only be reset to zero.
    """
    hipMemPoolReuseFollowEventDependencies = chip.hipMemPoolReuseFollowEventDependencies
    hipMemPoolReuseAllowOpportunistic = chip.hipMemPoolReuseAllowOpportunistic
    hipMemPoolReuseAllowInternalDependencies = chip.hipMemPoolReuseAllowInternalDependencies
    hipMemPoolAttrReleaseThreshold = chip.hipMemPoolAttrReleaseThreshold
    hipMemPoolAttrReservedMemCurrent = chip.hipMemPoolAttrReservedMemCurrent
    hipMemPoolAttrReservedMemHigh = chip.hipMemPoolAttrReservedMemHigh
    hipMemPoolAttrUsedMemCurrent = chip.hipMemPoolAttrUsedMemCurrent
    hipMemPoolAttrUsedMemHigh = chip.hipMemPoolAttrUsedMemHigh
    @staticmethod
    def ctypes_type():
        """The type of the enum constants as ctypes type."""
        return ctypes.c_uint


class _hipMemLocationType__Base(enum.IntEnum):
    """Empty enum base class that allows subclassing.
    """
    pass
class hipMemLocationType(_hipMemLocationType__Base):
    """Specifies the type of location

    Attributes:
        hipMemLocationTypeInvalid:
            (undocumented)
        hipMemLocationTypeDevice:
            Device location, thus it's HIP device ID
    """
    hipMemLocationTypeInvalid = chip.hipMemLocationTypeInvalid
    hipMemLocationTypeDevice = chip.hipMemLocationTypeDevice
    @staticmethod
    def ctypes_type():
        """The type of the enum constants as ctypes type."""
        return ctypes.c_uint


cdef class hipMemLocation(hip._util.types.Pointer):
    """Python wrapper for cdef class chip.hipMemLocation.

    Python wrapper for cdef class chip.hipMemLocation.

    If this type is initialized via its `__init__` method, it allocates a
    member of the underlying C type and destroys it again if the wrapper
    type is deallocated.

    This type also serves as adapter when appearing as argument type in a
    function signature. In this case, the type can further be initialized
    from a number of Python objects:

    * `None`:

      This will set the ``self._ptr`` attribute to ``NULL``.

    * `int`:

      Interprets the integer value as pointer address and writes it to ``self._ptr``.
      No ownership is transferred.

    * `ctypes.c_void_p`:

      Takes the pointer address ``pyobj.value`` and writes it to ``self._ptr``.
      No ownership is transferred.

    * `object` that implements the `CUDA Array Interface <https://numba.readthedocs.io/en/stable/cuda/cuda_array_interface.html>`_ protocol:

      Takes the integer-valued pointer address, i.e. the first entry of the `data` tuple
      from `pyobj`'s member ``__cuda_array_interface__``  and writes it to ``self._ptr``.

    * `object` that implements the Python buffer protocol:

      If the object represents a simple contiguous array,
      writes the `Py_buffer` associated with ``pyobj`` to `self._py_buffer`,
      sets the `self._py_buffer_acquired` flag to `True`, and
      writes `self._py_buffer.buf` to the data pointer `self._ptr`.

    * `hip._util.types.Pointer`:

      Takes the pointer address ``pyobj._ptr`` and writes it to ``self._ptr``.
      No ownership is transferred.

    Type checks are performed in the above order.

    C Attributes:
        _ptr (C type ``void *``, protected):
            Stores a pointer to the data of the original Python object.
        _is_ptr_owner (C type ``bint``, protected):
            If this wrapper is the owner of the underlying data.
        _py_buffer (C type ``Py_buffer`, protected):
            Stores a pointer to the data of the original Python object.
        _py_buffer_acquired (C type ``bint``, protected):
            Stores a pointer to the data of the original Python object.
    """
    # C members declared in pxd file

    def __cinit__(self):
        self._ptr = NULL
        self._is_ptr_owner = False
        self._py_buffer_acquired = False

    cdef chip.hipMemLocation* getElementPtr(self):
        return <chip.hipMemLocation*>self._ptr

    @staticmethod
    cdef hipMemLocation fromPtr(void* ptr, bint owner=False):
        """Factory function to create ``hipMemLocation`` objects from
        given ``chip.hipMemLocation`` pointer.

        Setting ``owner`` flag to ``True`` causes
        the extension type to free the structure pointed to by ``ptr``
        when the wrapper object is deallocated.
        """
        # Fast call to __new__() that bypasses the __init__() constructor.
        cdef hipMemLocation wrapper = hipMemLocation.__new__(hipMemLocation)
        wrapper._ptr = ptr
        wrapper._is_ptr_owner = owner
        return wrapper

    @staticmethod
    def fromObj(pyobj):
        """Creates a hipMemLocation from a Python object.

        Derives a hipMemLocation from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``hipMemLocation`` reference, this method
        returns it directly. No new ``hipMemLocation`` is created in this case.
        """
        return hipMemLocation.fromPyobj(pyobj)

    @staticmethod
    cdef hipMemLocation fromPyobj(object pyobj):
        """Creates a hipMemLocation from a Python object.

        Derives a hipMemLocation from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``hipMemLocation`` reference, this method
        returns it directly. No new ``hipMemLocation`` is created in this case.

        Args:
            pyobj (object): Must be either `None`; a `hip._util.types.Pointer`; a simple, contiguous buffer according to the buffer protocol;
                            or of type `hipMemLocation`; `int`; or `ctypes.c_void_p`.

        Note:
            This routine does not perform a copy but returns the original ``pyobj``
            if ``pyobj`` is an instance of hipMemLocation!
        """
        cdef hipMemLocation wrapper

        if isinstance(pyobj,hipMemLocation):
            return pyobj
        else:
            wrapper = hipMemLocation.__new__(hipMemLocation)
            wrapper.init_from_pyobj(pyobj)
            return wrapper

    def __dealloc__(self):
        # Release the buffer handle
        if self._py_buffer_acquired is True:
            cpython.buffer.PyBuffer_Release(&self._py_buffer)
        # De-allocate if not null and flag is set
        if self._ptr is not NULL and self._is_ptr_owner is True:
            stdlib.free(self._ptr)
            self._ptr = NULL

    @staticmethod
    cdef __allocate(void** ptr):
        ptr[0] = stdlib.malloc(sizeof(chip.hipMemLocation))
        string.memset(<void*>ptr[0], 0, sizeof(chip.hipMemLocation))

        if ptr[0] is NULL:
            raise MemoryError

    @staticmethod
    cdef hipMemLocation new():
        """Factory function to create hipMemLocation objects with
        newly allocated chip.hipMemLocation"""
        cdef void* ptr
        hipMemLocation.__allocate(&ptr)
        return hipMemLocation.fromPtr(ptr, owner=True)

    @staticmethod
    cdef hipMemLocation fromValue(chip.hipMemLocation other):
        """Allocate new C type and copy from ``other``.
        """
        wrapper = hipMemLocation.new()
        string.memcpy(wrapper._ptr, &other, sizeof(chip.hipMemLocation))
        return wrapper

    def c_sizeof(self):
        """Returns the size of the underlying C type in bytes.
        Note:
            Implemented as function to not collide with
            autogenerated property names.
        """
        return sizeof(chip.hipMemLocation)

    def __int__(self):
        """Returns the data's address as long integer.
        """
        return cpython.long.PyLong_FromVoidPtr(self._ptr)

    def __repr__(self):
        return f"<hipMemLocation object, ptr: {int(self)}>"

    def as_c_void_p(self):
        """Returns the data's address as `ctypes.c_void_p`
        Note:
            Implemented as function to not collide with
            autogenerated property names.
        """
        return ctypes.c_void_p(int(self))

    def __init__(self,*args,**kwargs):
        """Constructor type hipMemLocation.

        Constructor for type hipMemLocation.

        Args:
            *args:
                Positional arguments. Initialize all or a subset of the member variables
                according to their order of declaration.
            **kwargs:
                Can be used to initialize member variables at construction,
                Just pass an argument expression of the form <member>=<value>
                per member that you want to initialize.
        """
        hipMemLocation.__allocate(&self._ptr)
        self._is_ptr_owner = True
        attribs = self.PROPERTIES()
        used_attribs = set()
        if len(args) > len(attribs):
            raise ValueError("More positional arguments specified than this type has properties.")
        for i,v in enumerate(args):
            setattr(self,attribs[i],v)
            used_attribs.add(attribs[i])
        valid_names = ", ".join(["'"+p+"'" for p in attribs])
        for k,v in kwargs.items():
            if k in used_attribs:
                raise KeyError(f"argument '{k}' has already been specified as positional argument.")
            elif k not in attribs:
                raise KeyError(f"'{k}' is no valid property name. Valid names: {valid_names}")
            setattr(self,k,v)
    def get_type(self, i):
        """Get value of ``type`` of ``(<chip.hipMemLocation*>self._ptr)[i]``.
        """
        return hipMemLocationType((<chip.hipMemLocation*>self._ptr)[i].type)
    def set_type(self, i, value):
        """Set value ``type`` of ``(<chip.hipMemLocation*>self._ptr)[i]``.
        """
        if not isinstance(value, hipMemLocationType):
            raise TypeError("'value' must be of type 'hipMemLocationType'")
        (<chip.hipMemLocation*>self._ptr)[i].type = value.value
    @property
    def type(self):
        """Specifies the location type, which describes the meaning of id"""
        return self.get_type(0)
    @type.setter
    def type(self, value):
        self.set_type(0,value)

    def get_id(self, i):
        """Get value ``id`` of ``(<chip.hipMemLocation*>self._ptr)[i]``.
        """
        return (<chip.hipMemLocation*>self._ptr)[i].id
    def set_id(self, i, int value):
        """Set value ``id`` of ``(<chip.hipMemLocation*>self._ptr)[i]``.
        """
        (<chip.hipMemLocation*>self._ptr)[i].id = value
    @property
    def id(self):
        """Identifier for the provided location type hipMemLocationType"""
        return self.get_id(0)
    @id.setter
    def id(self, int value):
        self.set_id(0,value)

    @staticmethod
    def PROPERTIES():
        return ["type","id"]

    def __contains__(self,item):
        properties = self.PROPERTIES()
        return item in properties

    def __getitem__(self,item):
        properties = self.PROPERTIES()
        if isinstance(item,int):
            if item < 0 or item >= len(properties):
                raise IndexError()
            return getattr(self,properties[item])
        raise ValueError("'item' type must be 'int'")


class _hipMemAccessFlags__Base(enum.IntEnum):
    """Empty enum base class that allows subclassing.
    """
    pass
class hipMemAccessFlags(_hipMemAccessFlags__Base):
    """Specifies the memory protection flags for mapping

    Attributes:
        hipMemAccessFlagsProtNone:
            Default, make the address range not accessible
        hipMemAccessFlagsProtRead:
            Set the address range read accessible
        hipMemAccessFlagsProtReadWrite:
            Set the address range read-write accessible
    """
    hipMemAccessFlagsProtNone = chip.hipMemAccessFlagsProtNone
    hipMemAccessFlagsProtRead = chip.hipMemAccessFlagsProtRead
    hipMemAccessFlagsProtReadWrite = chip.hipMemAccessFlagsProtReadWrite
    @staticmethod
    def ctypes_type():
        """The type of the enum constants as ctypes type."""
        return ctypes.c_uint


cdef class hipMemAccessDesc(hip._util.types.Pointer):
    """Python wrapper for cdef class chip.hipMemAccessDesc.

    Python wrapper for cdef class chip.hipMemAccessDesc.

    If this type is initialized via its `__init__` method, it allocates a
    member of the underlying C type and destroys it again if the wrapper
    type is deallocated.

    This type also serves as adapter when appearing as argument type in a
    function signature. In this case, the type can further be initialized
    from a number of Python objects:

    * `None`:

      This will set the ``self._ptr`` attribute to ``NULL``.

    * `int`:

      Interprets the integer value as pointer address and writes it to ``self._ptr``.
      No ownership is transferred.

    * `ctypes.c_void_p`:

      Takes the pointer address ``pyobj.value`` and writes it to ``self._ptr``.
      No ownership is transferred.

    * `object` that implements the `CUDA Array Interface <https://numba.readthedocs.io/en/stable/cuda/cuda_array_interface.html>`_ protocol:

      Takes the integer-valued pointer address, i.e. the first entry of the `data` tuple
      from `pyobj`'s member ``__cuda_array_interface__``  and writes it to ``self._ptr``.

    * `object` that implements the Python buffer protocol:

      If the object represents a simple contiguous array,
      writes the `Py_buffer` associated with ``pyobj`` to `self._py_buffer`,
      sets the `self._py_buffer_acquired` flag to `True`, and
      writes `self._py_buffer.buf` to the data pointer `self._ptr`.

    * `hip._util.types.Pointer`:

      Takes the pointer address ``pyobj._ptr`` and writes it to ``self._ptr``.
      No ownership is transferred.

    Type checks are performed in the above order.

    C Attributes:
        _ptr (C type ``void *``, protected):
            Stores a pointer to the data of the original Python object.
        _is_ptr_owner (C type ``bint``, protected):
            If this wrapper is the owner of the underlying data.
        _py_buffer (C type ``Py_buffer`, protected):
            Stores a pointer to the data of the original Python object.
        _py_buffer_acquired (C type ``bint``, protected):
            Stores a pointer to the data of the original Python object.
    """
    # C members declared in pxd file

    def __cinit__(self):
        self._ptr = NULL
        self._is_ptr_owner = False
        self._py_buffer_acquired = False

    cdef chip.hipMemAccessDesc* getElementPtr(self):
        return <chip.hipMemAccessDesc*>self._ptr

    @staticmethod
    cdef hipMemAccessDesc fromPtr(void* ptr, bint owner=False):
        """Factory function to create ``hipMemAccessDesc`` objects from
        given ``chip.hipMemAccessDesc`` pointer.

        Setting ``owner`` flag to ``True`` causes
        the extension type to free the structure pointed to by ``ptr``
        when the wrapper object is deallocated.
        """
        # Fast call to __new__() that bypasses the __init__() constructor.
        cdef hipMemAccessDesc wrapper = hipMemAccessDesc.__new__(hipMemAccessDesc)
        wrapper._ptr = ptr
        wrapper._is_ptr_owner = owner
        return wrapper

    @staticmethod
    def fromObj(pyobj):
        """Creates a hipMemAccessDesc from a Python object.

        Derives a hipMemAccessDesc from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``hipMemAccessDesc`` reference, this method
        returns it directly. No new ``hipMemAccessDesc`` is created in this case.
        """
        return hipMemAccessDesc.fromPyobj(pyobj)

    @staticmethod
    cdef hipMemAccessDesc fromPyobj(object pyobj):
        """Creates a hipMemAccessDesc from a Python object.

        Derives a hipMemAccessDesc from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``hipMemAccessDesc`` reference, this method
        returns it directly. No new ``hipMemAccessDesc`` is created in this case.

        Args:
            pyobj (object): Must be either `None`; a `hip._util.types.Pointer`; a simple, contiguous buffer according to the buffer protocol;
                            or of type `hipMemAccessDesc`; `int`; or `ctypes.c_void_p`.

        Note:
            This routine does not perform a copy but returns the original ``pyobj``
            if ``pyobj`` is an instance of hipMemAccessDesc!
        """
        cdef hipMemAccessDesc wrapper

        if isinstance(pyobj,hipMemAccessDesc):
            return pyobj
        else:
            wrapper = hipMemAccessDesc.__new__(hipMemAccessDesc)
            wrapper.init_from_pyobj(pyobj)
            return wrapper

    def __dealloc__(self):
        # Release the buffer handle
        if self._py_buffer_acquired is True:
            cpython.buffer.PyBuffer_Release(&self._py_buffer)
        # De-allocate if not null and flag is set
        if self._ptr is not NULL and self._is_ptr_owner is True:
            stdlib.free(self._ptr)
            self._ptr = NULL

    @staticmethod
    cdef __allocate(void** ptr):
        ptr[0] = stdlib.malloc(sizeof(chip.hipMemAccessDesc))
        string.memset(<void*>ptr[0], 0, sizeof(chip.hipMemAccessDesc))

        if ptr[0] is NULL:
            raise MemoryError

    @staticmethod
    cdef hipMemAccessDesc new():
        """Factory function to create hipMemAccessDesc objects with
        newly allocated chip.hipMemAccessDesc"""
        cdef void* ptr
        hipMemAccessDesc.__allocate(&ptr)
        return hipMemAccessDesc.fromPtr(ptr, owner=True)

    @staticmethod
    cdef hipMemAccessDesc fromValue(chip.hipMemAccessDesc other):
        """Allocate new C type and copy from ``other``.
        """
        wrapper = hipMemAccessDesc.new()
        string.memcpy(wrapper._ptr, &other, sizeof(chip.hipMemAccessDesc))
        return wrapper

    def c_sizeof(self):
        """Returns the size of the underlying C type in bytes.
        Note:
            Implemented as function to not collide with
            autogenerated property names.
        """
        return sizeof(chip.hipMemAccessDesc)

    def __int__(self):
        """Returns the data's address as long integer.
        """
        return cpython.long.PyLong_FromVoidPtr(self._ptr)

    def __repr__(self):
        return f"<hipMemAccessDesc object, ptr: {int(self)}>"

    def as_c_void_p(self):
        """Returns the data's address as `ctypes.c_void_p`
        Note:
            Implemented as function to not collide with
            autogenerated property names.
        """
        return ctypes.c_void_p(int(self))

    def __init__(self,*args,**kwargs):
        """Constructor type hipMemAccessDesc.

        Constructor for type hipMemAccessDesc.

        Args:
            *args:
                Positional arguments. Initialize all or a subset of the member variables
                according to their order of declaration.
            **kwargs:
                Can be used to initialize member variables at construction,
                Just pass an argument expression of the form <member>=<value>
                per member that you want to initialize.
        """
        hipMemAccessDesc.__allocate(&self._ptr)
        self._is_ptr_owner = True
        attribs = self.PROPERTIES()
        used_attribs = set()
        if len(args) > len(attribs):
            raise ValueError("More positional arguments specified than this type has properties.")
        for i,v in enumerate(args):
            setattr(self,attribs[i],v)
            used_attribs.add(attribs[i])
        valid_names = ", ".join(["'"+p+"'" for p in attribs])
        for k,v in kwargs.items():
            if k in used_attribs:
                raise KeyError(f"argument '{k}' has already been specified as positional argument.")
            elif k not in attribs:
                raise KeyError(f"'{k}' is no valid property name. Valid names: {valid_names}")
            setattr(self,k,v)
    def get_location(self, i):
        """Get value of ``location`` of ``(<chip.hipMemAccessDesc*>self._ptr)[i]``.
        """
        return hipMemLocation.fromPtr(&(<chip.hipMemAccessDesc*>self._ptr)[i].location)
    @property
    def location(self):
        """Location on which the accessibility has to change"""
        return self.get_location(0)

    def get_flags(self, i):
        """Get value of ``flags`` of ``(<chip.hipMemAccessDesc*>self._ptr)[i]``.
        """
        return hipMemAccessFlags((<chip.hipMemAccessDesc*>self._ptr)[i].flags)
    def set_flags(self, i, value):
        """Set value ``flags`` of ``(<chip.hipMemAccessDesc*>self._ptr)[i]``.
        """
        if not isinstance(value, hipMemAccessFlags):
            raise TypeError("'value' must be of type 'hipMemAccessFlags'")
        (<chip.hipMemAccessDesc*>self._ptr)[i].flags = value.value
    @property
    def flags(self):
        """Accessibility flags to set"""
        return self.get_flags(0)
    @flags.setter
    def flags(self, value):
        self.set_flags(0,value)

    @staticmethod
    def PROPERTIES():
        return ["location","flags"]

    def __contains__(self,item):
        properties = self.PROPERTIES()
        return item in properties

    def __getitem__(self,item):
        properties = self.PROPERTIES()
        if isinstance(item,int):
            if item < 0 or item >= len(properties):
                raise IndexError()
            return getattr(self,properties[item])
        raise ValueError("'item' type must be 'int'")


class _hipMemAllocationType__Base(enum.IntEnum):
    """Empty enum base class that allows subclassing.
    """
    pass
class hipMemAllocationType(_hipMemAllocationType__Base):
    """Defines the allocation types

    Attributes:
        hipMemAllocationTypeInvalid:
            (undocumented)
        hipMemAllocationTypePinned:
            This allocation type is 'pinned', i.e. cannot migrate from its current location while the application is actively using it
        hipMemAllocationTypeMax:
            This allocation type is 'pinned', i.e. cannot migrate from its current location while the application is actively using it
    """
    hipMemAllocationTypeInvalid = chip.hipMemAllocationTypeInvalid
    hipMemAllocationTypePinned = chip.hipMemAllocationTypePinned
    hipMemAllocationTypeMax = chip.hipMemAllocationTypeMax
    @staticmethod
    def ctypes_type():
        """The type of the enum constants as ctypes type."""
        return ctypes.c_uint


class _hipMemAllocationHandleType__Base(enum.IntEnum):
    """Empty enum base class that allows subclassing.
    """
    pass
class hipMemAllocationHandleType(_hipMemAllocationHandleType__Base):
    """Flags for specifying handle types for memory pool allocations

    Attributes:
        hipMemHandleTypeNone:
            Does not allow any export mechanism
        hipMemHandleTypePosixFileDescriptor:
            Allows a file descriptor for exporting. Permitted only on POSIX systems
        hipMemHandleTypeWin32:
            Allows a Win32 NT handle for exporting. (HANDLE)
        hipMemHandleTypeWin32Kmt:
            Allows a Win32 KMT handle for exporting. (D3DKMT_HANDLE)
    """
    hipMemHandleTypeNone = chip.hipMemHandleTypeNone
    hipMemHandleTypePosixFileDescriptor = chip.hipMemHandleTypePosixFileDescriptor
    hipMemHandleTypeWin32 = chip.hipMemHandleTypeWin32
    hipMemHandleTypeWin32Kmt = chip.hipMemHandleTypeWin32Kmt
    @staticmethod
    def ctypes_type():
        """The type of the enum constants as ctypes type."""
        return ctypes.c_uint


cdef class hipMemPoolProps(hip._util.types.Pointer):
    """Python wrapper for cdef class chip.hipMemPoolProps.

    Python wrapper for cdef class chip.hipMemPoolProps.

    If this type is initialized via its `__init__` method, it allocates a
    member of the underlying C type and destroys it again if the wrapper
    type is deallocated.

    This type also serves as adapter when appearing as argument type in a
    function signature. In this case, the type can further be initialized
    from a number of Python objects:

    * `None`:

      This will set the ``self._ptr`` attribute to ``NULL``.

    * `int`:

      Interprets the integer value as pointer address and writes it to ``self._ptr``.
      No ownership is transferred.

    * `ctypes.c_void_p`:

      Takes the pointer address ``pyobj.value`` and writes it to ``self._ptr``.
      No ownership is transferred.

    * `object` that implements the `CUDA Array Interface <https://numba.readthedocs.io/en/stable/cuda/cuda_array_interface.html>`_ protocol:

      Takes the integer-valued pointer address, i.e. the first entry of the `data` tuple
      from `pyobj`'s member ``__cuda_array_interface__``  and writes it to ``self._ptr``.

    * `object` that implements the Python buffer protocol:

      If the object represents a simple contiguous array,
      writes the `Py_buffer` associated with ``pyobj`` to `self._py_buffer`,
      sets the `self._py_buffer_acquired` flag to `True`, and
      writes `self._py_buffer.buf` to the data pointer `self._ptr`.

    * `hip._util.types.Pointer`:

      Takes the pointer address ``pyobj._ptr`` and writes it to ``self._ptr``.
      No ownership is transferred.

    Type checks are performed in the above order.

    C Attributes:
        _ptr (C type ``void *``, protected):
            Stores a pointer to the data of the original Python object.
        _is_ptr_owner (C type ``bint``, protected):
            If this wrapper is the owner of the underlying data.
        _py_buffer (C type ``Py_buffer`, protected):
            Stores a pointer to the data of the original Python object.
        _py_buffer_acquired (C type ``bint``, protected):
            Stores a pointer to the data of the original Python object.
    """
    # C members declared in pxd file

    def __cinit__(self):
        self._ptr = NULL
        self._is_ptr_owner = False
        self._py_buffer_acquired = False

    cdef chip.hipMemPoolProps* getElementPtr(self):
        return <chip.hipMemPoolProps*>self._ptr

    @staticmethod
    cdef hipMemPoolProps fromPtr(void* ptr, bint owner=False):
        """Factory function to create ``hipMemPoolProps`` objects from
        given ``chip.hipMemPoolProps`` pointer.

        Setting ``owner`` flag to ``True`` causes
        the extension type to free the structure pointed to by ``ptr``
        when the wrapper object is deallocated.
        """
        # Fast call to __new__() that bypasses the __init__() constructor.
        cdef hipMemPoolProps wrapper = hipMemPoolProps.__new__(hipMemPoolProps)
        wrapper._ptr = ptr
        wrapper._is_ptr_owner = owner
        return wrapper

    @staticmethod
    def fromObj(pyobj):
        """Creates a hipMemPoolProps from a Python object.

        Derives a hipMemPoolProps from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``hipMemPoolProps`` reference, this method
        returns it directly. No new ``hipMemPoolProps`` is created in this case.
        """
        return hipMemPoolProps.fromPyobj(pyobj)

    @staticmethod
    cdef hipMemPoolProps fromPyobj(object pyobj):
        """Creates a hipMemPoolProps from a Python object.

        Derives a hipMemPoolProps from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``hipMemPoolProps`` reference, this method
        returns it directly. No new ``hipMemPoolProps`` is created in this case.

        Args:
            pyobj (object): Must be either `None`; a `hip._util.types.Pointer`; a simple, contiguous buffer according to the buffer protocol;
                            or of type `hipMemPoolProps`; `int`; or `ctypes.c_void_p`.

        Note:
            This routine does not perform a copy but returns the original ``pyobj``
            if ``pyobj`` is an instance of hipMemPoolProps!
        """
        cdef hipMemPoolProps wrapper

        if isinstance(pyobj,hipMemPoolProps):
            return pyobj
        else:
            wrapper = hipMemPoolProps.__new__(hipMemPoolProps)
            wrapper.init_from_pyobj(pyobj)
            return wrapper

    def __dealloc__(self):
        # Release the buffer handle
        if self._py_buffer_acquired is True:
            cpython.buffer.PyBuffer_Release(&self._py_buffer)
        # De-allocate if not null and flag is set
        if self._ptr is not NULL and self._is_ptr_owner is True:
            stdlib.free(self._ptr)
            self._ptr = NULL

    @staticmethod
    cdef __allocate(void** ptr):
        ptr[0] = stdlib.malloc(sizeof(chip.hipMemPoolProps))
        string.memset(<void*>ptr[0], 0, sizeof(chip.hipMemPoolProps))

        if ptr[0] is NULL:
            raise MemoryError

    @staticmethod
    cdef hipMemPoolProps new():
        """Factory function to create hipMemPoolProps objects with
        newly allocated chip.hipMemPoolProps"""
        cdef void* ptr
        hipMemPoolProps.__allocate(&ptr)
        return hipMemPoolProps.fromPtr(ptr, owner=True)

    @staticmethod
    cdef hipMemPoolProps fromValue(chip.hipMemPoolProps other):
        """Allocate new C type and copy from ``other``.
        """
        wrapper = hipMemPoolProps.new()
        string.memcpy(wrapper._ptr, &other, sizeof(chip.hipMemPoolProps))
        return wrapper

    def c_sizeof(self):
        """Returns the size of the underlying C type in bytes.
        Note:
            Implemented as function to not collide with
            autogenerated property names.
        """
        return sizeof(chip.hipMemPoolProps)

    def __int__(self):
        """Returns the data's address as long integer.
        """
        return cpython.long.PyLong_FromVoidPtr(self._ptr)

    def __repr__(self):
        return f"<hipMemPoolProps object, ptr: {int(self)}>"

    def as_c_void_p(self):
        """Returns the data's address as `ctypes.c_void_p`
        Note:
            Implemented as function to not collide with
            autogenerated property names.
        """
        return ctypes.c_void_p(int(self))

    def __init__(self,*args,**kwargs):
        """Constructor type hipMemPoolProps.

        Constructor for type hipMemPoolProps.

        Args:
            *args:
                Positional arguments. Initialize all or a subset of the member variables
                according to their order of declaration.
            **kwargs:
                Can be used to initialize member variables at construction,
                Just pass an argument expression of the form <member>=<value>
                per member that you want to initialize.
        """
        hipMemPoolProps.__allocate(&self._ptr)
        self._is_ptr_owner = True
        attribs = self.PROPERTIES()
        used_attribs = set()
        if len(args) > len(attribs):
            raise ValueError("More positional arguments specified than this type has properties.")
        for i,v in enumerate(args):
            setattr(self,attribs[i],v)
            used_attribs.add(attribs[i])
        valid_names = ", ".join(["'"+p+"'" for p in attribs])
        for k,v in kwargs.items():
            if k in used_attribs:
                raise KeyError(f"argument '{k}' has already been specified as positional argument.")
            elif k not in attribs:
                raise KeyError(f"'{k}' is no valid property name. Valid names: {valid_names}")
            setattr(self,k,v)
    def get_allocType(self, i):
        """Get value of ``allocType`` of ``(<chip.hipMemPoolProps*>self._ptr)[i]``.
        """
        return hipMemAllocationType((<chip.hipMemPoolProps*>self._ptr)[i].allocType)
    def set_allocType(self, i, value):
        """Set value ``allocType`` of ``(<chip.hipMemPoolProps*>self._ptr)[i]``.
        """
        if not isinstance(value, hipMemAllocationType):
            raise TypeError("'value' must be of type 'hipMemAllocationType'")
        (<chip.hipMemPoolProps*>self._ptr)[i].allocType = value.value
    @property
    def allocType(self):
        """Allocation type. Currently must be specified as hipMemAllocationTypePinned"""
        return self.get_allocType(0)
    @allocType.setter
    def allocType(self, value):
        self.set_allocType(0,value)

    def get_handleTypes(self, i):
        """Get value of ``handleTypes`` of ``(<chip.hipMemPoolProps*>self._ptr)[i]``.
        """
        return hipMemAllocationHandleType((<chip.hipMemPoolProps*>self._ptr)[i].handleTypes)
    def set_handleTypes(self, i, value):
        """Set value ``handleTypes`` of ``(<chip.hipMemPoolProps*>self._ptr)[i]``.
        """
        if not isinstance(value, hipMemAllocationHandleType):
            raise TypeError("'value' must be of type 'hipMemAllocationHandleType'")
        (<chip.hipMemPoolProps*>self._ptr)[i].handleTypes = value.value
    @property
    def handleTypes(self):
        """Handle types that will be supported by allocations from the pool"""
        return self.get_handleTypes(0)
    @handleTypes.setter
    def handleTypes(self, value):
        self.set_handleTypes(0,value)

    def get_location(self, i):
        """Get value of ``location`` of ``(<chip.hipMemPoolProps*>self._ptr)[i]``.
        """
        return hipMemLocation.fromPtr(&(<chip.hipMemPoolProps*>self._ptr)[i].location)
    @property
    def location(self):
        """Location where allocations should reside"""
        return self.get_location(0)

    def get_win32SecurityAttributes(self, i):
        """Get value ``win32SecurityAttributes`` of ``(<chip.hipMemPoolProps*>self._ptr)[i]``.
        """
        return hip._util.types.Pointer.fromPtr((<chip.hipMemPoolProps*>self._ptr)[i].win32SecurityAttributes)
    def set_win32SecurityAttributes(self, i, object value):
        """Set value ``win32SecurityAttributes`` of ``(<chip.hipMemPoolProps*>self._ptr)[i]``.

        Note:
            This can be dangerous if the pointer is from a python object
            that is later on garbage collected.
        """
        (<chip.hipMemPoolProps*>self._ptr)[i].win32SecurityAttributes = <void *>cpython.long.PyLong_AsVoidPtr(int(hip._util.types.Pointer.fromPyobj(value)))
    @property
    def win32SecurityAttributes(self):
        """Windows-specific LPSECURITYATTRIBUTES required when hipMemHandleTypeWin32 is specified
        Note:
            Setting this win32SecurityAttributes can be dangerous if the underlying pointer is from a python object that
            is later on garbage collected.
        """
        return self.get_win32SecurityAttributes(0)
    @win32SecurityAttributes.setter
    def win32SecurityAttributes(self, object value):
        self.set_win32SecurityAttributes(0,value)

    def get_maxSize(self, i):
        """Get value ``maxSize`` of ``(<chip.hipMemPoolProps*>self._ptr)[i]``.
        """
        return (<chip.hipMemPoolProps*>self._ptr)[i].maxSize
    def set_maxSize(self, i, unsigned long value):
        """Set value ``maxSize`` of ``(<chip.hipMemPoolProps*>self._ptr)[i]``.
        """
        (<chip.hipMemPoolProps*>self._ptr)[i].maxSize = value
    @property
    def maxSize(self):
        """Maximum pool size. When set to 0, defaults to a system dependent value"""
        return self.get_maxSize(0)
    @maxSize.setter
    def maxSize(self, unsigned long value):
        self.set_maxSize(0,value)

    def get_reserved(self, i):
        """Get value of ``reserved`` of ``(<chip.hipMemPoolProps*>self._ptr)[i]``.
        """
        return (<chip.hipMemPoolProps*>self._ptr)[i].reserved
    # TODO add setters
    #def set_reserved(self, i, unsigned char[56] value):
    #    """Set value ``reserved`` of ``(<chip.hipMemPoolProps*>self._ptr)[i]``.
    #    """
    #    (<chip.hipMemPoolProps*>self._ptr)[i].reserved = value
    @property
    def reserved(self):
        """Reserved for future use, must be 0"""
        return self.get_reserved(0)
    # TODO add setters
    #@reserved.setter
    #def reserved(self, unsigned char[56] value):
    #    self.set_reserved(0,value)

    @staticmethod
    def PROPERTIES():
        return ["allocType","handleTypes","location","win32SecurityAttributes","maxSize","reserved"]

    def __contains__(self,item):
        properties = self.PROPERTIES()
        return item in properties

    def __getitem__(self,item):
        properties = self.PROPERTIES()
        if isinstance(item,int):
            if item < 0 or item >= len(properties):
                raise IndexError()
            return getattr(self,properties[item])
        raise ValueError("'item' type must be 'int'")


cdef class hipMemPoolPtrExportData(hip._util.types.Pointer):
    """Python wrapper for cdef class chip.hipMemPoolPtrExportData.

    Python wrapper for cdef class chip.hipMemPoolPtrExportData.

    If this type is initialized via its `__init__` method, it allocates a
    member of the underlying C type and destroys it again if the wrapper
    type is deallocated.

    This type also serves as adapter when appearing as argument type in a
    function signature. In this case, the type can further be initialized
    from a number of Python objects:

    * `None`:

      This will set the ``self._ptr`` attribute to ``NULL``.

    * `int`:

      Interprets the integer value as pointer address and writes it to ``self._ptr``.
      No ownership is transferred.

    * `ctypes.c_void_p`:

      Takes the pointer address ``pyobj.value`` and writes it to ``self._ptr``.
      No ownership is transferred.

    * `object` that implements the `CUDA Array Interface <https://numba.readthedocs.io/en/stable/cuda/cuda_array_interface.html>`_ protocol:

      Takes the integer-valued pointer address, i.e. the first entry of the `data` tuple
      from `pyobj`'s member ``__cuda_array_interface__``  and writes it to ``self._ptr``.

    * `object` that implements the Python buffer protocol:

      If the object represents a simple contiguous array,
      writes the `Py_buffer` associated with ``pyobj`` to `self._py_buffer`,
      sets the `self._py_buffer_acquired` flag to `True`, and
      writes `self._py_buffer.buf` to the data pointer `self._ptr`.

    * `hip._util.types.Pointer`:

      Takes the pointer address ``pyobj._ptr`` and writes it to ``self._ptr``.
      No ownership is transferred.

    Type checks are performed in the above order.

    C Attributes:
        _ptr (C type ``void *``, protected):
            Stores a pointer to the data of the original Python object.
        _is_ptr_owner (C type ``bint``, protected):
            If this wrapper is the owner of the underlying data.
        _py_buffer (C type ``Py_buffer`, protected):
            Stores a pointer to the data of the original Python object.
        _py_buffer_acquired (C type ``bint``, protected):
            Stores a pointer to the data of the original Python object.
    """
    # C members declared in pxd file

    def __cinit__(self):
        self._ptr = NULL
        self._is_ptr_owner = False
        self._py_buffer_acquired = False

    cdef chip.hipMemPoolPtrExportData* getElementPtr(self):
        return <chip.hipMemPoolPtrExportData*>self._ptr

    @staticmethod
    cdef hipMemPoolPtrExportData fromPtr(void* ptr, bint owner=False):
        """Factory function to create ``hipMemPoolPtrExportData`` objects from
        given ``chip.hipMemPoolPtrExportData`` pointer.

        Setting ``owner`` flag to ``True`` causes
        the extension type to free the structure pointed to by ``ptr``
        when the wrapper object is deallocated.
        """
        # Fast call to __new__() that bypasses the __init__() constructor.
        cdef hipMemPoolPtrExportData wrapper = hipMemPoolPtrExportData.__new__(hipMemPoolPtrExportData)
        wrapper._ptr = ptr
        wrapper._is_ptr_owner = owner
        return wrapper

    @staticmethod
    def fromObj(pyobj):
        """Creates a hipMemPoolPtrExportData from a Python object.

        Derives a hipMemPoolPtrExportData from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``hipMemPoolPtrExportData`` reference, this method
        returns it directly. No new ``hipMemPoolPtrExportData`` is created in this case.
        """
        return hipMemPoolPtrExportData.fromPyobj(pyobj)

    @staticmethod
    cdef hipMemPoolPtrExportData fromPyobj(object pyobj):
        """Creates a hipMemPoolPtrExportData from a Python object.

        Derives a hipMemPoolPtrExportData from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``hipMemPoolPtrExportData`` reference, this method
        returns it directly. No new ``hipMemPoolPtrExportData`` is created in this case.

        Args:
            pyobj (object): Must be either `None`; a `hip._util.types.Pointer`; a simple, contiguous buffer according to the buffer protocol;
                            or of type `hipMemPoolPtrExportData`; `int`; or `ctypes.c_void_p`.

        Note:
            This routine does not perform a copy but returns the original ``pyobj``
            if ``pyobj`` is an instance of hipMemPoolPtrExportData!
        """
        cdef hipMemPoolPtrExportData wrapper

        if isinstance(pyobj,hipMemPoolPtrExportData):
            return pyobj
        else:
            wrapper = hipMemPoolPtrExportData.__new__(hipMemPoolPtrExportData)
            wrapper.init_from_pyobj(pyobj)
            return wrapper

    def __dealloc__(self):
        # Release the buffer handle
        if self._py_buffer_acquired is True:
            cpython.buffer.PyBuffer_Release(&self._py_buffer)
        # De-allocate if not null and flag is set
        if self._ptr is not NULL and self._is_ptr_owner is True:
            stdlib.free(self._ptr)
            self._ptr = NULL

    @staticmethod
    cdef __allocate(void** ptr):
        ptr[0] = stdlib.malloc(sizeof(chip.hipMemPoolPtrExportData))
        string.memset(<void*>ptr[0], 0, sizeof(chip.hipMemPoolPtrExportData))

        if ptr[0] is NULL:
            raise MemoryError

    @staticmethod
    cdef hipMemPoolPtrExportData new():
        """Factory function to create hipMemPoolPtrExportData objects with
        newly allocated chip.hipMemPoolPtrExportData"""
        cdef void* ptr
        hipMemPoolPtrExportData.__allocate(&ptr)
        return hipMemPoolPtrExportData.fromPtr(ptr, owner=True)

    @staticmethod
    cdef hipMemPoolPtrExportData fromValue(chip.hipMemPoolPtrExportData other):
        """Allocate new C type and copy from ``other``.
        """
        wrapper = hipMemPoolPtrExportData.new()
        string.memcpy(wrapper._ptr, &other, sizeof(chip.hipMemPoolPtrExportData))
        return wrapper

    def c_sizeof(self):
        """Returns the size of the underlying C type in bytes.
        Note:
            Implemented as function to not collide with
            autogenerated property names.
        """
        return sizeof(chip.hipMemPoolPtrExportData)

    def __int__(self):
        """Returns the data's address as long integer.
        """
        return cpython.long.PyLong_FromVoidPtr(self._ptr)

    def __repr__(self):
        return f"<hipMemPoolPtrExportData object, ptr: {int(self)}>"

    def as_c_void_p(self):
        """Returns the data's address as `ctypes.c_void_p`
        Note:
            Implemented as function to not collide with
            autogenerated property names.
        """
        return ctypes.c_void_p(int(self))

    def __init__(self,*args,**kwargs):
        """Constructor type hipMemPoolPtrExportData.

        Constructor for type hipMemPoolPtrExportData.

        Args:
            *args:
                Positional arguments. Initialize all or a subset of the member variables
                according to their order of declaration.
            **kwargs:
                Can be used to initialize member variables at construction,
                Just pass an argument expression of the form <member>=<value>
                per member that you want to initialize.
        """
        hipMemPoolPtrExportData.__allocate(&self._ptr)
        self._is_ptr_owner = True
        attribs = self.PROPERTIES()
        used_attribs = set()
        if len(args) > len(attribs):
            raise ValueError("More positional arguments specified than this type has properties.")
        for i,v in enumerate(args):
            setattr(self,attribs[i],v)
            used_attribs.add(attribs[i])
        valid_names = ", ".join(["'"+p+"'" for p in attribs])
        for k,v in kwargs.items():
            if k in used_attribs:
                raise KeyError(f"argument '{k}' has already been specified as positional argument.")
            elif k not in attribs:
                raise KeyError(f"'{k}' is no valid property name. Valid names: {valid_names}")
            setattr(self,k,v)
    def get_reserved(self, i):
        """Get value of ``reserved`` of ``(<chip.hipMemPoolPtrExportData*>self._ptr)[i]``.
        """
        return (<chip.hipMemPoolPtrExportData*>self._ptr)[i].reserved
    # TODO add setters
    #def set_reserved(self, i, unsigned char[64] value):
    #    """Set value ``reserved`` of ``(<chip.hipMemPoolPtrExportData*>self._ptr)[i]``.
    #    """
    #    (<chip.hipMemPoolPtrExportData*>self._ptr)[i].reserved = value
    @property
    def reserved(self):
        """(undocumented)"""
        return self.get_reserved(0)
    # TODO add setters
    #@reserved.setter
    #def reserved(self, unsigned char[64] value):
    #    self.set_reserved(0,value)

    @staticmethod
    def PROPERTIES():
        return ["reserved"]

    def __contains__(self,item):
        properties = self.PROPERTIES()
        return item in properties

    def __getitem__(self,item):
        properties = self.PROPERTIES()
        if isinstance(item,int):
            if item < 0 or item >= len(properties):
                raise IndexError()
            return getattr(self,properties[item])
        raise ValueError("'item' type must be 'int'")


class _hipJitOption__Base(enum.IntEnum):
    """Empty enum base class that allows subclassing.
    """
    pass
class hipJitOption(_hipJitOption__Base):
    """hipJitOption

    Attributes:
        hipJitOptionMaxRegisters:
            (undocumented)
        hipJitOptionThreadsPerBlock:
            (undocumented)
        hipJitOptionWallTime:
            (undocumented)
        hipJitOptionInfoLogBuffer:
            (undocumented)
        hipJitOptionInfoLogBufferSizeBytes:
            (undocumented)
        hipJitOptionErrorLogBuffer:
            (undocumented)
        hipJitOptionErrorLogBufferSizeBytes:
            (undocumented)
        hipJitOptionOptimizationLevel:
            (undocumented)
        hipJitOptionTargetFromContext:
            (undocumented)
        hipJitOptionTarget:
            (undocumented)
        hipJitOptionFallbackStrategy:
            (undocumented)
        hipJitOptionGenerateDebugInfo:
            (undocumented)
        hipJitOptionLogVerbose:
            (undocumented)
        hipJitOptionGenerateLineInfo:
            (undocumented)
        hipJitOptionCacheMode:
            (undocumented)
        hipJitOptionSm3xOpt:
            (undocumented)
        hipJitOptionFastCompile:
            (undocumented)
        hipJitOptionNumOptions:
            (undocumented)
    """
    hipJitOptionMaxRegisters = chip.hipJitOptionMaxRegisters
    hipJitOptionThreadsPerBlock = chip.hipJitOptionThreadsPerBlock
    hipJitOptionWallTime = chip.hipJitOptionWallTime
    hipJitOptionInfoLogBuffer = chip.hipJitOptionInfoLogBuffer
    hipJitOptionInfoLogBufferSizeBytes = chip.hipJitOptionInfoLogBufferSizeBytes
    hipJitOptionErrorLogBuffer = chip.hipJitOptionErrorLogBuffer
    hipJitOptionErrorLogBufferSizeBytes = chip.hipJitOptionErrorLogBufferSizeBytes
    hipJitOptionOptimizationLevel = chip.hipJitOptionOptimizationLevel
    hipJitOptionTargetFromContext = chip.hipJitOptionTargetFromContext
    hipJitOptionTarget = chip.hipJitOptionTarget
    hipJitOptionFallbackStrategy = chip.hipJitOptionFallbackStrategy
    hipJitOptionGenerateDebugInfo = chip.hipJitOptionGenerateDebugInfo
    hipJitOptionLogVerbose = chip.hipJitOptionLogVerbose
    hipJitOptionGenerateLineInfo = chip.hipJitOptionGenerateLineInfo
    hipJitOptionCacheMode = chip.hipJitOptionCacheMode
    hipJitOptionSm3xOpt = chip.hipJitOptionSm3xOpt
    hipJitOptionFastCompile = chip.hipJitOptionFastCompile
    hipJitOptionNumOptions = chip.hipJitOptionNumOptions
    @staticmethod
    def ctypes_type():
        """The type of the enum constants as ctypes type."""
        return ctypes.c_uint


class _hipFuncAttribute__Base(enum.IntEnum):
    """Empty enum base class that allows subclassing.
    """
    pass
class hipFuncAttribute(_hipFuncAttribute__Base):
    """

    Attributes:
        hipFuncAttributeMaxDynamicSharedMemorySize:
            (undocumented)
        hipFuncAttributePreferredSharedMemoryCarveout:
            (undocumented)
        hipFuncAttributeMax:
            (undocumented)
    """
    hipFuncAttributeMaxDynamicSharedMemorySize = chip.hipFuncAttributeMaxDynamicSharedMemorySize
    hipFuncAttributePreferredSharedMemoryCarveout = chip.hipFuncAttributePreferredSharedMemoryCarveout
    hipFuncAttributeMax = chip.hipFuncAttributeMax
    @staticmethod
    def ctypes_type():
        """The type of the enum constants as ctypes type."""
        return ctypes.c_uint


class _hipFuncCache_t__Base(enum.IntEnum):
    """Empty enum base class that allows subclassing.
    """
    pass
class hipFuncCache_t(_hipFuncCache_t__Base):
    """

    Attributes:
        hipFuncCachePreferNone:
            no preference for shared memory or L1 (default)
        hipFuncCachePreferShared:
            prefer larger shared memory and smaller L1 cache
        hipFuncCachePreferL1:
            prefer larger L1 cache and smaller shared memory
        hipFuncCachePreferEqual:
            prefer equal size L1 cache and shared memory
    """
    hipFuncCachePreferNone = chip.hipFuncCachePreferNone
    hipFuncCachePreferShared = chip.hipFuncCachePreferShared
    hipFuncCachePreferL1 = chip.hipFuncCachePreferL1
    hipFuncCachePreferEqual = chip.hipFuncCachePreferEqual
    @staticmethod
    def ctypes_type():
        """The type of the enum constants as ctypes type."""
        return ctypes.c_uint


class _hipSharedMemConfig__Base(enum.IntEnum):
    """Empty enum base class that allows subclassing.
    """
    pass
class hipSharedMemConfig(_hipSharedMemConfig__Base):
    """

    Attributes:
        hipSharedMemBankSizeDefault:
            The compiler selects a device-specific value for the banking.
        hipSharedMemBankSizeFourByte:
            Shared mem is banked at 4-bytes intervals and performs best when adjacent threads access data 4 bytes apart.
        hipSharedMemBankSizeEightByte:
            Shared mem is banked at 8-byte intervals and performs best when adjacent threads access data 4 bytes apart.
    """
    hipSharedMemBankSizeDefault = chip.hipSharedMemBankSizeDefault
    hipSharedMemBankSizeFourByte = chip.hipSharedMemBankSizeFourByte
    hipSharedMemBankSizeEightByte = chip.hipSharedMemBankSizeEightByte
    @staticmethod
    def ctypes_type():
        """The type of the enum constants as ctypes type."""
        return ctypes.c_uint


cdef class dim3(hip._util.types.Pointer):
    """Python wrapper for cdef class chip.dim3.

    Python wrapper for cdef class chip.dim3.

    If this type is initialized via its `__init__` method, it allocates a
    member of the underlying C type and destroys it again if the wrapper
    type is deallocated.

    This type also serves as adapter when appearing as argument type in a
    function signature. In this case, the type can further be initialized
    from a number of Python objects:

    * `None`:

      This will set the ``self._ptr`` attribute to ``NULL``.

    * `int`:

      Interprets the integer value as pointer address and writes it to ``self._ptr``.
      No ownership is transferred.

    * `ctypes.c_void_p`:

      Takes the pointer address ``pyobj.value`` and writes it to ``self._ptr``.
      No ownership is transferred.

    * `object` that implements the `CUDA Array Interface <https://numba.readthedocs.io/en/stable/cuda/cuda_array_interface.html>`_ protocol:

      Takes the integer-valued pointer address, i.e. the first entry of the `data` tuple
      from `pyobj`'s member ``__cuda_array_interface__``  and writes it to ``self._ptr``.

    * `object` that implements the Python buffer protocol:

      If the object represents a simple contiguous array,
      writes the `Py_buffer` associated with ``pyobj`` to `self._py_buffer`,
      sets the `self._py_buffer_acquired` flag to `True`, and
      writes `self._py_buffer.buf` to the data pointer `self._ptr`.

    * `hip._util.types.Pointer`:

      Takes the pointer address ``pyobj._ptr`` and writes it to ``self._ptr``.
      No ownership is transferred.

    Type checks are performed in the above order.

    C Attributes:
        _ptr (C type ``void *``, protected):
            Stores a pointer to the data of the original Python object.
        _is_ptr_owner (C type ``bint``, protected):
            If this wrapper is the owner of the underlying data.
        _py_buffer (C type ``Py_buffer`, protected):
            Stores a pointer to the data of the original Python object.
        _py_buffer_acquired (C type ``bint``, protected):
            Stores a pointer to the data of the original Python object.
    """
    # C members declared in pxd file

    def __cinit__(self):
        self._ptr = NULL
        self._is_ptr_owner = False
        self._py_buffer_acquired = False

    cdef chip.dim3* getElementPtr(self):
        return <chip.dim3*>self._ptr

    @staticmethod
    cdef dim3 fromPtr(void* ptr, bint owner=False):
        """Factory function to create ``dim3`` objects from
        given ``chip.dim3`` pointer.

        Setting ``owner`` flag to ``True`` causes
        the extension type to free the structure pointed to by ``ptr``
        when the wrapper object is deallocated.
        """
        # Fast call to __new__() that bypasses the __init__() constructor.
        cdef dim3 wrapper = dim3.__new__(dim3)
        wrapper._ptr = ptr
        wrapper._is_ptr_owner = owner
        return wrapper

    @staticmethod
    def fromObj(pyobj):
        """Creates a dim3 from a Python object.

        Derives a dim3 from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``dim3`` reference, this method
        returns it directly. No new ``dim3`` is created in this case.
        """
        return dim3.fromPyobj(pyobj)

    @staticmethod
    cdef dim3 fromPyobj(object pyobj):
        """Creates a dim3 from a Python object.

        Derives a dim3 from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``dim3`` reference, this method
        returns it directly. No new ``dim3`` is created in this case.

        Args:
            pyobj (object): Must be either `None`; a `hip._util.types.Pointer`; a simple, contiguous buffer according to the buffer protocol;
                            or of type `dim3`; `int`; or `ctypes.c_void_p`.

        Note:
            This routine does not perform a copy but returns the original ``pyobj``
            if ``pyobj`` is an instance of dim3!
        """
        cdef dim3 wrapper

        if isinstance(pyobj,dim3):
            return pyobj
        else:
            wrapper = dim3.__new__(dim3)
            wrapper.init_from_pyobj(pyobj)
            return wrapper

    def __dealloc__(self):
        # Release the buffer handle
        if self._py_buffer_acquired is True:
            cpython.buffer.PyBuffer_Release(&self._py_buffer)
        # De-allocate if not null and flag is set
        if self._ptr is not NULL and self._is_ptr_owner is True:
            stdlib.free(self._ptr)
            self._ptr = NULL

    @staticmethod
    cdef __allocate(void** ptr):
        ptr[0] = stdlib.malloc(sizeof(chip.dim3))
        string.memset(<void*>ptr[0], 0, sizeof(chip.dim3))

        if ptr[0] is NULL:
            raise MemoryError

    @staticmethod
    cdef dim3 new():
        """Factory function to create dim3 objects with
        newly allocated chip.dim3"""
        cdef void* ptr
        dim3.__allocate(&ptr)
        return dim3.fromPtr(ptr, owner=True)

    @staticmethod
    cdef dim3 fromValue(chip.dim3 other):
        """Allocate new C type and copy from ``other``.
        """
        wrapper = dim3.new()
        string.memcpy(wrapper._ptr, &other, sizeof(chip.dim3))
        return wrapper

    def c_sizeof(self):
        """Returns the size of the underlying C type in bytes.
        Note:
            Implemented as function to not collide with
            autogenerated property names.
        """
        return sizeof(chip.dim3)

    def __int__(self):
        """Returns the data's address as long integer.
        """
        return cpython.long.PyLong_FromVoidPtr(self._ptr)

    def __repr__(self):
        return f"<dim3 object, ptr: {int(self)}>"

    def as_c_void_p(self):
        """Returns the data's address as `ctypes.c_void_p`
        Note:
            Implemented as function to not collide with
            autogenerated property names.
        """
        return ctypes.c_void_p(int(self))

    def __init__(self,*args,**kwargs):
        """Constructor type dim3.

        Constructor for type dim3.

        Args:
            *args:
                Positional arguments. Initialize all or a subset of the member variables
                according to their order of declaration.
            **kwargs:
                Can be used to initialize member variables at construction,
                Just pass an argument expression of the form <member>=<value>
                per member that you want to initialize.
        """
        dim3.__allocate(&self._ptr)
        self._is_ptr_owner = True
        self.x = 1
        self.y = 1
        self.z = 1
        attribs = self.PROPERTIES()
        used_attribs = set()
        if len(args) > len(attribs):
            raise ValueError("More positional arguments specified than this type has properties.")
        for i,v in enumerate(args):
            setattr(self,attribs[i],v)
            used_attribs.add(attribs[i])
        valid_names = ", ".join(["'"+p+"'" for p in attribs])
        for k,v in kwargs.items():
            if k in used_attribs:
                raise KeyError(f"argument '{k}' has already been specified as positional argument.")
            elif k not in attribs:
                raise KeyError(f"'{k}' is no valid property name. Valid names: {valid_names}")
            setattr(self,k,v)
    def get_x(self, i):
        """Get value ``x`` of ``(<chip.dim3*>self._ptr)[i]``.
        """
        return (<chip.dim3*>self._ptr)[i].x
    def set_x(self, i, unsigned int value):
        """Set value ``x`` of ``(<chip.dim3*>self._ptr)[i]``.
        """
        (<chip.dim3*>self._ptr)[i].x = value
    @property
    def x(self):
        """x"""
        return self.get_x(0)
    @x.setter
    def x(self, unsigned int value):
        self.set_x(0,value)

    def get_y(self, i):
        """Get value ``y`` of ``(<chip.dim3*>self._ptr)[i]``.
        """
        return (<chip.dim3*>self._ptr)[i].y
    def set_y(self, i, unsigned int value):
        """Set value ``y`` of ``(<chip.dim3*>self._ptr)[i]``.
        """
        (<chip.dim3*>self._ptr)[i].y = value
    @property
    def y(self):
        """y"""
        return self.get_y(0)
    @y.setter
    def y(self, unsigned int value):
        self.set_y(0,value)

    def get_z(self, i):
        """Get value ``z`` of ``(<chip.dim3*>self._ptr)[i]``.
        """
        return (<chip.dim3*>self._ptr)[i].z
    def set_z(self, i, unsigned int value):
        """Set value ``z`` of ``(<chip.dim3*>self._ptr)[i]``.
        """
        (<chip.dim3*>self._ptr)[i].z = value
    @property
    def z(self):
        """z"""
        return self.get_z(0)
    @z.setter
    def z(self, unsigned int value):
        self.set_z(0,value)

    @staticmethod
    def PROPERTIES():
        return ["x","y","z"]

    def __contains__(self,item):
        properties = self.PROPERTIES()
        return item in properties

    def __getitem__(self,item):
        properties = self.PROPERTIES()
        if isinstance(item,int):
            if item < 0 or item >= len(properties):
                raise IndexError()
            return getattr(self,properties[item])
        raise ValueError("'item' type must be 'int'")


cdef class hipLaunchParams_t(hip._util.types.Pointer):
    """Python wrapper for cdef class chip.hipLaunchParams_t.

    Python wrapper for cdef class chip.hipLaunchParams_t.

    If this type is initialized via its `__init__` method, it allocates a
    member of the underlying C type and destroys it again if the wrapper
    type is deallocated.

    This type also serves as adapter when appearing as argument type in a
    function signature. In this case, the type can further be initialized
    from a number of Python objects:

    * `None`:

      This will set the ``self._ptr`` attribute to ``NULL``.

    * `int`:

      Interprets the integer value as pointer address and writes it to ``self._ptr``.
      No ownership is transferred.

    * `ctypes.c_void_p`:

      Takes the pointer address ``pyobj.value`` and writes it to ``self._ptr``.
      No ownership is transferred.

    * `object` that implements the `CUDA Array Interface <https://numba.readthedocs.io/en/stable/cuda/cuda_array_interface.html>`_ protocol:

      Takes the integer-valued pointer address, i.e. the first entry of the `data` tuple
      from `pyobj`'s member ``__cuda_array_interface__``  and writes it to ``self._ptr``.

    * `object` that implements the Python buffer protocol:

      If the object represents a simple contiguous array,
      writes the `Py_buffer` associated with ``pyobj`` to `self._py_buffer`,
      sets the `self._py_buffer_acquired` flag to `True`, and
      writes `self._py_buffer.buf` to the data pointer `self._ptr`.

    * `hip._util.types.Pointer`:

      Takes the pointer address ``pyobj._ptr`` and writes it to ``self._ptr``.
      No ownership is transferred.

    Type checks are performed in the above order.

    C Attributes:
        _ptr (C type ``void *``, protected):
            Stores a pointer to the data of the original Python object.
        _is_ptr_owner (C type ``bint``, protected):
            If this wrapper is the owner of the underlying data.
        _py_buffer (C type ``Py_buffer`, protected):
            Stores a pointer to the data of the original Python object.
        _py_buffer_acquired (C type ``bint``, protected):
            Stores a pointer to the data of the original Python object.
    """
    # C members declared in pxd file

    def __cinit__(self):
        self._ptr = NULL
        self._is_ptr_owner = False
        self._py_buffer_acquired = False

    cdef chip.hipLaunchParams_t* getElementPtr(self):
        return <chip.hipLaunchParams_t*>self._ptr

    @staticmethod
    cdef hipLaunchParams_t fromPtr(void* ptr, bint owner=False):
        """Factory function to create ``hipLaunchParams_t`` objects from
        given ``chip.hipLaunchParams_t`` pointer.

        Setting ``owner`` flag to ``True`` causes
        the extension type to free the structure pointed to by ``ptr``
        when the wrapper object is deallocated.
        """
        # Fast call to __new__() that bypasses the __init__() constructor.
        cdef hipLaunchParams_t wrapper = hipLaunchParams_t.__new__(hipLaunchParams_t)
        wrapper._ptr = ptr
        wrapper._is_ptr_owner = owner
        return wrapper

    @staticmethod
    def fromObj(pyobj):
        """Creates a hipLaunchParams_t from a Python object.

        Derives a hipLaunchParams_t from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``hipLaunchParams_t`` reference, this method
        returns it directly. No new ``hipLaunchParams_t`` is created in this case.
        """
        return hipLaunchParams_t.fromPyobj(pyobj)

    @staticmethod
    cdef hipLaunchParams_t fromPyobj(object pyobj):
        """Creates a hipLaunchParams_t from a Python object.

        Derives a hipLaunchParams_t from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``hipLaunchParams_t`` reference, this method
        returns it directly. No new ``hipLaunchParams_t`` is created in this case.

        Args:
            pyobj (object): Must be either `None`; a `hip._util.types.Pointer`; a simple, contiguous buffer according to the buffer protocol;
                            or of type `hipLaunchParams_t`; `int`; or `ctypes.c_void_p`.

        Note:
            This routine does not perform a copy but returns the original ``pyobj``
            if ``pyobj`` is an instance of hipLaunchParams_t!
        """
        cdef hipLaunchParams_t wrapper

        if isinstance(pyobj,hipLaunchParams_t):
            return pyobj
        else:
            wrapper = hipLaunchParams_t.__new__(hipLaunchParams_t)
            wrapper.init_from_pyobj(pyobj)
            return wrapper

    def __dealloc__(self):
        # Release the buffer handle
        if self._py_buffer_acquired is True:
            cpython.buffer.PyBuffer_Release(&self._py_buffer)
        # De-allocate if not null and flag is set
        if self._ptr is not NULL and self._is_ptr_owner is True:
            stdlib.free(self._ptr)
            self._ptr = NULL

    @staticmethod
    cdef __allocate(void** ptr):
        ptr[0] = stdlib.malloc(sizeof(chip.hipLaunchParams_t))
        string.memset(<void*>ptr[0], 0, sizeof(chip.hipLaunchParams_t))

        if ptr[0] is NULL:
            raise MemoryError

    @staticmethod
    cdef hipLaunchParams_t new():
        """Factory function to create hipLaunchParams_t objects with
        newly allocated chip.hipLaunchParams_t"""
        cdef void* ptr
        hipLaunchParams_t.__allocate(&ptr)
        return hipLaunchParams_t.fromPtr(ptr, owner=True)

    @staticmethod
    cdef hipLaunchParams_t fromValue(chip.hipLaunchParams_t other):
        """Allocate new C type and copy from ``other``.
        """
        wrapper = hipLaunchParams_t.new()
        string.memcpy(wrapper._ptr, &other, sizeof(chip.hipLaunchParams_t))
        return wrapper

    def c_sizeof(self):
        """Returns the size of the underlying C type in bytes.
        Note:
            Implemented as function to not collide with
            autogenerated property names.
        """
        return sizeof(chip.hipLaunchParams_t)

    def __int__(self):
        """Returns the data's address as long integer.
        """
        return cpython.long.PyLong_FromVoidPtr(self._ptr)

    def __repr__(self):
        return f"<hipLaunchParams_t object, ptr: {int(self)}>"

    def as_c_void_p(self):
        """Returns the data's address as `ctypes.c_void_p`
        Note:
            Implemented as function to not collide with
            autogenerated property names.
        """
        return ctypes.c_void_p(int(self))

    def __init__(self,**kwargs):
        """Constructor type hipLaunchParams_t.

        Constructor for type hipLaunchParams_t.

        Args:
            **kwargs:
                Can be used to initialize member variables at construction,
                Just pass an argument expression of the form <member>=<value>
                per member that you want to initialize.
        """
        hipLaunchParams_t.__allocate(&self._ptr)
        self._is_ptr_owner = True
        attribs = self.PROPERTIES()
        used_attribs = set()
        valid_names = ", ".join(["'"+p+"'" for p in attribs])
        for k,v in kwargs.items():
            if k in used_attribs:
                raise KeyError(f"argument '{k}' has already been specified as positional argument.")
            elif k not in attribs:
                raise KeyError(f"'{k}' is no valid property name. Valid names: {valid_names}")
            setattr(self,k,v)
    def get_func(self, i):
        """Get value ``func`` of ``(<chip.hipLaunchParams_t*>self._ptr)[i]``.
        """
        return hip._util.types.Pointer.fromPtr((<chip.hipLaunchParams_t*>self._ptr)[i].func)
    def set_func(self, i, object value):
        """Set value ``func`` of ``(<chip.hipLaunchParams_t*>self._ptr)[i]``.

        Note:
            This can be dangerous if the pointer is from a python object
            that is later on garbage collected.
        """
        (<chip.hipLaunchParams_t*>self._ptr)[i].func = <void *>cpython.long.PyLong_AsVoidPtr(int(hip._util.types.Pointer.fromPyobj(value)))
    @property
    def func(self):
        """Device function symbol
        Note:
            Setting this func can be dangerous if the underlying pointer is from a python object that
            is later on garbage collected.
        """
        return self.get_func(0)
    @func.setter
    def func(self, object value):
        self.set_func(0,value)

    def get_gridDim(self, i):
        """Get value of ``gridDim`` of ``(<chip.hipLaunchParams_t*>self._ptr)[i]``.
        """
        return dim3.fromPtr(&(<chip.hipLaunchParams_t*>self._ptr)[i].gridDim)
    @property
    def gridDim(self):
        """Grid dimentions"""
        return self.get_gridDim(0)

    def get_blockDim(self, i):
        """Get value of ``blockDim`` of ``(<chip.hipLaunchParams_t*>self._ptr)[i]``.
        """
        return dim3.fromPtr(&(<chip.hipLaunchParams_t*>self._ptr)[i].blockDim)
    @property
    def blockDim(self):
        """Block dimentions"""
        return self.get_blockDim(0)

    def get_args(self, i):
        """Get value ``args`` of ``(<chip.hipLaunchParams_t*>self._ptr)[i]``.
        """
        return hip._util.types.Pointer.fromPtr((<chip.hipLaunchParams_t*>self._ptr)[i].args)
    def set_args(self, i, object value):
        """Set value ``args`` of ``(<chip.hipLaunchParams_t*>self._ptr)[i]``.

        Note:
            This can be dangerous if the pointer is from a python object
            that is later on garbage collected.
        """
        (<chip.hipLaunchParams_t*>self._ptr)[i].args = <void **>cpython.long.PyLong_AsVoidPtr(int(hip._util.types.Pointer.fromPyobj(value)))
    @property
    def args(self):
        """Arguments
        Note:
            Setting this args can be dangerous if the underlying pointer is from a python object that
            is later on garbage collected.
        """
        return self.get_args(0)
    @args.setter
    def args(self, object value):
        self.set_args(0,value)

    def get_sharedMem(self, i):
        """Get value ``sharedMem`` of ``(<chip.hipLaunchParams_t*>self._ptr)[i]``.
        """
        return (<chip.hipLaunchParams_t*>self._ptr)[i].sharedMem
    def set_sharedMem(self, i, unsigned long value):
        """Set value ``sharedMem`` of ``(<chip.hipLaunchParams_t*>self._ptr)[i]``.
        """
        (<chip.hipLaunchParams_t*>self._ptr)[i].sharedMem = value
    @property
    def sharedMem(self):
        """Shared memory"""
        return self.get_sharedMem(0)
    @sharedMem.setter
    def sharedMem(self, unsigned long value):
        self.set_sharedMem(0,value)

    @staticmethod
    def PROPERTIES():
        return ["func","gridDim","blockDim","args","sharedMem"]

    def __contains__(self,item):
        properties = self.PROPERTIES()
        return item in properties

    def __getitem__(self,item):
        properties = self.PROPERTIES()
        if isinstance(item,int):
            if item < 0 or item >= len(properties):
                raise IndexError()
            return getattr(self,properties[item])
        raise ValueError("'item' type must be 'int'")


hipLaunchParams = hipLaunchParams_t

cdef class hipFunctionLaunchParams_t(hip._util.types.Pointer):
    """Python wrapper for cdef class chip.hipFunctionLaunchParams_t.

    Python wrapper for cdef class chip.hipFunctionLaunchParams_t.

    If this type is initialized via its `__init__` method, it allocates a
    member of the underlying C type and destroys it again if the wrapper
    type is deallocated.

    This type also serves as adapter when appearing as argument type in a
    function signature. In this case, the type can further be initialized
    from a number of Python objects:

    * `None`:

      This will set the ``self._ptr`` attribute to ``NULL``.

    * `int`:

      Interprets the integer value as pointer address and writes it to ``self._ptr``.
      No ownership is transferred.

    * `ctypes.c_void_p`:

      Takes the pointer address ``pyobj.value`` and writes it to ``self._ptr``.
      No ownership is transferred.

    * `object` that implements the `CUDA Array Interface <https://numba.readthedocs.io/en/stable/cuda/cuda_array_interface.html>`_ protocol:

      Takes the integer-valued pointer address, i.e. the first entry of the `data` tuple
      from `pyobj`'s member ``__cuda_array_interface__``  and writes it to ``self._ptr``.

    * `object` that implements the Python buffer protocol:

      If the object represents a simple contiguous array,
      writes the `Py_buffer` associated with ``pyobj`` to `self._py_buffer`,
      sets the `self._py_buffer_acquired` flag to `True`, and
      writes `self._py_buffer.buf` to the data pointer `self._ptr`.

    * `hip._util.types.Pointer`:

      Takes the pointer address ``pyobj._ptr`` and writes it to ``self._ptr``.
      No ownership is transferred.

    Type checks are performed in the above order.

    C Attributes:
        _ptr (C type ``void *``, protected):
            Stores a pointer to the data of the original Python object.
        _is_ptr_owner (C type ``bint``, protected):
            If this wrapper is the owner of the underlying data.
        _py_buffer (C type ``Py_buffer`, protected):
            Stores a pointer to the data of the original Python object.
        _py_buffer_acquired (C type ``bint``, protected):
            Stores a pointer to the data of the original Python object.
    """
    # C members declared in pxd file

    def __cinit__(self):
        self._ptr = NULL
        self._is_ptr_owner = False
        self._py_buffer_acquired = False

    cdef chip.hipFunctionLaunchParams_t* getElementPtr(self):
        return <chip.hipFunctionLaunchParams_t*>self._ptr

    @staticmethod
    cdef hipFunctionLaunchParams_t fromPtr(void* ptr, bint owner=False):
        """Factory function to create ``hipFunctionLaunchParams_t`` objects from
        given ``chip.hipFunctionLaunchParams_t`` pointer.

        Setting ``owner`` flag to ``True`` causes
        the extension type to free the structure pointed to by ``ptr``
        when the wrapper object is deallocated.
        """
        # Fast call to __new__() that bypasses the __init__() constructor.
        cdef hipFunctionLaunchParams_t wrapper = hipFunctionLaunchParams_t.__new__(hipFunctionLaunchParams_t)
        wrapper._ptr = ptr
        wrapper._is_ptr_owner = owner
        return wrapper

    @staticmethod
    def fromObj(pyobj):
        """Creates a hipFunctionLaunchParams_t from a Python object.

        Derives a hipFunctionLaunchParams_t from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``hipFunctionLaunchParams_t`` reference, this method
        returns it directly. No new ``hipFunctionLaunchParams_t`` is created in this case.
        """
        return hipFunctionLaunchParams_t.fromPyobj(pyobj)

    @staticmethod
    cdef hipFunctionLaunchParams_t fromPyobj(object pyobj):
        """Creates a hipFunctionLaunchParams_t from a Python object.

        Derives a hipFunctionLaunchParams_t from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``hipFunctionLaunchParams_t`` reference, this method
        returns it directly. No new ``hipFunctionLaunchParams_t`` is created in this case.

        Args:
            pyobj (object): Must be either `None`; a `hip._util.types.Pointer`; a simple, contiguous buffer according to the buffer protocol;
                            or of type `hipFunctionLaunchParams_t`; `int`; or `ctypes.c_void_p`.

        Note:
            This routine does not perform a copy but returns the original ``pyobj``
            if ``pyobj`` is an instance of hipFunctionLaunchParams_t!
        """
        cdef hipFunctionLaunchParams_t wrapper

        if isinstance(pyobj,hipFunctionLaunchParams_t):
            return pyobj
        else:
            wrapper = hipFunctionLaunchParams_t.__new__(hipFunctionLaunchParams_t)
            wrapper.init_from_pyobj(pyobj)
            return wrapper

    def __dealloc__(self):
        # Release the buffer handle
        if self._py_buffer_acquired is True:
            cpython.buffer.PyBuffer_Release(&self._py_buffer)
        # De-allocate if not null and flag is set
        if self._ptr is not NULL and self._is_ptr_owner is True:
            stdlib.free(self._ptr)
            self._ptr = NULL

    @staticmethod
    cdef __allocate(void** ptr):
        ptr[0] = stdlib.malloc(sizeof(chip.hipFunctionLaunchParams_t))
        string.memset(<void*>ptr[0], 0, sizeof(chip.hipFunctionLaunchParams_t))

        if ptr[0] is NULL:
            raise MemoryError

    @staticmethod
    cdef hipFunctionLaunchParams_t new():
        """Factory function to create hipFunctionLaunchParams_t objects with
        newly allocated chip.hipFunctionLaunchParams_t"""
        cdef void* ptr
        hipFunctionLaunchParams_t.__allocate(&ptr)
        return hipFunctionLaunchParams_t.fromPtr(ptr, owner=True)

    @staticmethod
    cdef hipFunctionLaunchParams_t fromValue(chip.hipFunctionLaunchParams_t other):
        """Allocate new C type and copy from ``other``.
        """
        wrapper = hipFunctionLaunchParams_t.new()
        string.memcpy(wrapper._ptr, &other, sizeof(chip.hipFunctionLaunchParams_t))
        return wrapper

    def c_sizeof(self):
        """Returns the size of the underlying C type in bytes.
        Note:
            Implemented as function to not collide with
            autogenerated property names.
        """
        return sizeof(chip.hipFunctionLaunchParams_t)

    def __int__(self):
        """Returns the data's address as long integer.
        """
        return cpython.long.PyLong_FromVoidPtr(self._ptr)

    def __repr__(self):
        return f"<hipFunctionLaunchParams_t object, ptr: {int(self)}>"

    def as_c_void_p(self):
        """Returns the data's address as `ctypes.c_void_p`
        Note:
            Implemented as function to not collide with
            autogenerated property names.
        """
        return ctypes.c_void_p(int(self))

    def __init__(self,**kwargs):
        """Constructor type hipFunctionLaunchParams_t.

        Constructor for type hipFunctionLaunchParams_t.

        Args:
            **kwargs:
                Can be used to initialize member variables at construction,
                Just pass an argument expression of the form <member>=<value>
                per member that you want to initialize.
        """
        hipFunctionLaunchParams_t.__allocate(&self._ptr)
        self._is_ptr_owner = True
        attribs = self.PROPERTIES()
        used_attribs = set()
        valid_names = ", ".join(["'"+p+"'" for p in attribs])
        for k,v in kwargs.items():
            if k in used_attribs:
                raise KeyError(f"argument '{k}' has already been specified as positional argument.")
            elif k not in attribs:
                raise KeyError(f"'{k}' is no valid property name. Valid names: {valid_names}")
            setattr(self,k,v)
    def get_gridDimX(self, i):
        """Get value ``gridDimX`` of ``(<chip.hipFunctionLaunchParams_t*>self._ptr)[i]``.
        """
        return (<chip.hipFunctionLaunchParams_t*>self._ptr)[i].gridDimX
    def set_gridDimX(self, i, unsigned int value):
        """Set value ``gridDimX`` of ``(<chip.hipFunctionLaunchParams_t*>self._ptr)[i]``.
        """
        (<chip.hipFunctionLaunchParams_t*>self._ptr)[i].gridDimX = value
    @property
    def gridDimX(self):
        """Width(X) of grid in blocks"""
        return self.get_gridDimX(0)
    @gridDimX.setter
    def gridDimX(self, unsigned int value):
        self.set_gridDimX(0,value)

    def get_gridDimY(self, i):
        """Get value ``gridDimY`` of ``(<chip.hipFunctionLaunchParams_t*>self._ptr)[i]``.
        """
        return (<chip.hipFunctionLaunchParams_t*>self._ptr)[i].gridDimY
    def set_gridDimY(self, i, unsigned int value):
        """Set value ``gridDimY`` of ``(<chip.hipFunctionLaunchParams_t*>self._ptr)[i]``.
        """
        (<chip.hipFunctionLaunchParams_t*>self._ptr)[i].gridDimY = value
    @property
    def gridDimY(self):
        """Height(Y) of grid in blocks"""
        return self.get_gridDimY(0)
    @gridDimY.setter
    def gridDimY(self, unsigned int value):
        self.set_gridDimY(0,value)

    def get_gridDimZ(self, i):
        """Get value ``gridDimZ`` of ``(<chip.hipFunctionLaunchParams_t*>self._ptr)[i]``.
        """
        return (<chip.hipFunctionLaunchParams_t*>self._ptr)[i].gridDimZ
    def set_gridDimZ(self, i, unsigned int value):
        """Set value ``gridDimZ`` of ``(<chip.hipFunctionLaunchParams_t*>self._ptr)[i]``.
        """
        (<chip.hipFunctionLaunchParams_t*>self._ptr)[i].gridDimZ = value
    @property
    def gridDimZ(self):
        """Depth(Z) of grid in blocks"""
        return self.get_gridDimZ(0)
    @gridDimZ.setter
    def gridDimZ(self, unsigned int value):
        self.set_gridDimZ(0,value)

    def get_blockDimX(self, i):
        """Get value ``blockDimX`` of ``(<chip.hipFunctionLaunchParams_t*>self._ptr)[i]``.
        """
        return (<chip.hipFunctionLaunchParams_t*>self._ptr)[i].blockDimX
    def set_blockDimX(self, i, unsigned int value):
        """Set value ``blockDimX`` of ``(<chip.hipFunctionLaunchParams_t*>self._ptr)[i]``.
        """
        (<chip.hipFunctionLaunchParams_t*>self._ptr)[i].blockDimX = value
    @property
    def blockDimX(self):
        """X dimension of each thread block"""
        return self.get_blockDimX(0)
    @blockDimX.setter
    def blockDimX(self, unsigned int value):
        self.set_blockDimX(0,value)

    def get_blockDimY(self, i):
        """Get value ``blockDimY`` of ``(<chip.hipFunctionLaunchParams_t*>self._ptr)[i]``.
        """
        return (<chip.hipFunctionLaunchParams_t*>self._ptr)[i].blockDimY
    def set_blockDimY(self, i, unsigned int value):
        """Set value ``blockDimY`` of ``(<chip.hipFunctionLaunchParams_t*>self._ptr)[i]``.
        """
        (<chip.hipFunctionLaunchParams_t*>self._ptr)[i].blockDimY = value
    @property
    def blockDimY(self):
        """Y dimension of each thread block"""
        return self.get_blockDimY(0)
    @blockDimY.setter
    def blockDimY(self, unsigned int value):
        self.set_blockDimY(0,value)

    def get_blockDimZ(self, i):
        """Get value ``blockDimZ`` of ``(<chip.hipFunctionLaunchParams_t*>self._ptr)[i]``.
        """
        return (<chip.hipFunctionLaunchParams_t*>self._ptr)[i].blockDimZ
    def set_blockDimZ(self, i, unsigned int value):
        """Set value ``blockDimZ`` of ``(<chip.hipFunctionLaunchParams_t*>self._ptr)[i]``.
        """
        (<chip.hipFunctionLaunchParams_t*>self._ptr)[i].blockDimZ = value
    @property
    def blockDimZ(self):
        """Z dimension of each thread block"""
        return self.get_blockDimZ(0)
    @blockDimZ.setter
    def blockDimZ(self, unsigned int value):
        self.set_blockDimZ(0,value)

    def get_sharedMemBytes(self, i):
        """Get value ``sharedMemBytes`` of ``(<chip.hipFunctionLaunchParams_t*>self._ptr)[i]``.
        """
        return (<chip.hipFunctionLaunchParams_t*>self._ptr)[i].sharedMemBytes
    def set_sharedMemBytes(self, i, unsigned int value):
        """Set value ``sharedMemBytes`` of ``(<chip.hipFunctionLaunchParams_t*>self._ptr)[i]``.
        """
        (<chip.hipFunctionLaunchParams_t*>self._ptr)[i].sharedMemBytes = value
    @property
    def sharedMemBytes(self):
        """Shared memory"""
        return self.get_sharedMemBytes(0)
    @sharedMemBytes.setter
    def sharedMemBytes(self, unsigned int value):
        self.set_sharedMemBytes(0,value)

    def get_kernelParams(self, i):
        """Get value ``kernelParams`` of ``(<chip.hipFunctionLaunchParams_t*>self._ptr)[i]``.
        """
        return hip._util.types.Pointer.fromPtr((<chip.hipFunctionLaunchParams_t*>self._ptr)[i].kernelParams)
    def set_kernelParams(self, i, object value):
        """Set value ``kernelParams`` of ``(<chip.hipFunctionLaunchParams_t*>self._ptr)[i]``.

        Note:
            This can be dangerous if the pointer is from a python object
            that is later on garbage collected.
        """
        (<chip.hipFunctionLaunchParams_t*>self._ptr)[i].kernelParams = <void **>cpython.long.PyLong_AsVoidPtr(int(hip._util.types.Pointer.fromPyobj(value)))
    @property
    def kernelParams(self):
        """Kernel parameters
        Note:
            Setting this kernelParams can be dangerous if the underlying pointer is from a python object that
            is later on garbage collected.
        """
        return self.get_kernelParams(0)
    @kernelParams.setter
    def kernelParams(self, object value):
        self.set_kernelParams(0,value)

    @staticmethod
    def PROPERTIES():
        return ["gridDimX","gridDimY","gridDimZ","blockDimX","blockDimY","blockDimZ","sharedMemBytes","kernelParams"]

    def __contains__(self,item):
        properties = self.PROPERTIES()
        return item in properties

    def __getitem__(self,item):
        properties = self.PROPERTIES()
        if isinstance(item,int):
            if item < 0 or item >= len(properties):
                raise IndexError()
            return getattr(self,properties[item])
        raise ValueError("'item' type must be 'int'")


hipFunctionLaunchParams = hipFunctionLaunchParams_t

class _hipExternalMemoryHandleType_enum__Base(enum.IntEnum):
    """Empty enum base class that allows subclassing.
    """
    pass
class hipExternalMemoryHandleType_enum(_hipExternalMemoryHandleType_enum__Base):
    """hipExternalMemoryHandleType_enum

    Attributes:
        hipExternalMemoryHandleTypeOpaqueFd:
            (undocumented)
        hipExternalMemoryHandleTypeOpaqueWin32:
            (undocumented)
        hipExternalMemoryHandleTypeOpaqueWin32Kmt:
            (undocumented)
        hipExternalMemoryHandleTypeD3D12Heap:
            (undocumented)
        hipExternalMemoryHandleTypeD3D12Resource:
            (undocumented)
        hipExternalMemoryHandleTypeD3D11Resource:
            (undocumented)
        hipExternalMemoryHandleTypeD3D11ResourceKmt:
            (undocumented)
        hipExternalMemoryHandleTypeNvSciBuf:
            (undocumented)
    """
    hipExternalMemoryHandleTypeOpaqueFd = chip.hipExternalMemoryHandleTypeOpaqueFd
    hipExternalMemoryHandleTypeOpaqueWin32 = chip.hipExternalMemoryHandleTypeOpaqueWin32
    hipExternalMemoryHandleTypeOpaqueWin32Kmt = chip.hipExternalMemoryHandleTypeOpaqueWin32Kmt
    hipExternalMemoryHandleTypeD3D12Heap = chip.hipExternalMemoryHandleTypeD3D12Heap
    hipExternalMemoryHandleTypeD3D12Resource = chip.hipExternalMemoryHandleTypeD3D12Resource
    hipExternalMemoryHandleTypeD3D11Resource = chip.hipExternalMemoryHandleTypeD3D11Resource
    hipExternalMemoryHandleTypeD3D11ResourceKmt = chip.hipExternalMemoryHandleTypeD3D11ResourceKmt
    hipExternalMemoryHandleTypeNvSciBuf = chip.hipExternalMemoryHandleTypeNvSciBuf
    @staticmethod
    def ctypes_type():
        """The type of the enum constants as ctypes type."""
        return ctypes.c_uint


hipExternalMemoryHandleType = hipExternalMemoryHandleType_enum

cdef class hipExternalMemoryHandleDesc_st_union_0_struct_0(hip._util.types.Pointer):
    """Python wrapper for cdef class chip.hipExternalMemoryHandleDesc_st_union_0_struct_0.

    Python wrapper for cdef class chip.hipExternalMemoryHandleDesc_st_union_0_struct_0.

    If this type is initialized via its `__init__` method, it allocates a
    member of the underlying C type and destroys it again if the wrapper
    type is deallocated.

    This type also serves as adapter when appearing as argument type in a
    function signature. In this case, the type can further be initialized
    from a number of Python objects:

    * `None`:

      This will set the ``self._ptr`` attribute to ``NULL``.

    * `int`:

      Interprets the integer value as pointer address and writes it to ``self._ptr``.
      No ownership is transferred.

    * `ctypes.c_void_p`:

      Takes the pointer address ``pyobj.value`` and writes it to ``self._ptr``.
      No ownership is transferred.

    * `object` that implements the `CUDA Array Interface <https://numba.readthedocs.io/en/stable/cuda/cuda_array_interface.html>`_ protocol:

      Takes the integer-valued pointer address, i.e. the first entry of the `data` tuple
      from `pyobj`'s member ``__cuda_array_interface__``  and writes it to ``self._ptr``.

    * `object` that implements the Python buffer protocol:

      If the object represents a simple contiguous array,
      writes the `Py_buffer` associated with ``pyobj`` to `self._py_buffer`,
      sets the `self._py_buffer_acquired` flag to `True`, and
      writes `self._py_buffer.buf` to the data pointer `self._ptr`.

    * `hip._util.types.Pointer`:

      Takes the pointer address ``pyobj._ptr`` and writes it to ``self._ptr``.
      No ownership is transferred.

    Type checks are performed in the above order.

    C Attributes:
        _ptr (C type ``void *``, protected):
            Stores a pointer to the data of the original Python object.
        _is_ptr_owner (C type ``bint``, protected):
            If this wrapper is the owner of the underlying data.
        _py_buffer (C type ``Py_buffer`, protected):
            Stores a pointer to the data of the original Python object.
        _py_buffer_acquired (C type ``bint``, protected):
            Stores a pointer to the data of the original Python object.
    """
    # C members declared in pxd file

    def __cinit__(self):
        self._ptr = NULL
        self._is_ptr_owner = False
        self._py_buffer_acquired = False

    cdef chip.hipExternalMemoryHandleDesc_st_union_0_struct_0* getElementPtr(self):
        return <chip.hipExternalMemoryHandleDesc_st_union_0_struct_0*>self._ptr

    @staticmethod
    cdef hipExternalMemoryHandleDesc_st_union_0_struct_0 fromPtr(void* ptr, bint owner=False):
        """Factory function to create ``hipExternalMemoryHandleDesc_st_union_0_struct_0`` objects from
        given ``chip.hipExternalMemoryHandleDesc_st_union_0_struct_0`` pointer.

        Setting ``owner`` flag to ``True`` causes
        the extension type to free the structure pointed to by ``ptr``
        when the wrapper object is deallocated.
        """
        # Fast call to __new__() that bypasses the __init__() constructor.
        cdef hipExternalMemoryHandleDesc_st_union_0_struct_0 wrapper = hipExternalMemoryHandleDesc_st_union_0_struct_0.__new__(hipExternalMemoryHandleDesc_st_union_0_struct_0)
        wrapper._ptr = ptr
        wrapper._is_ptr_owner = owner
        return wrapper

    @staticmethod
    def fromObj(pyobj):
        """Creates a hipExternalMemoryHandleDesc_st_union_0_struct_0 from a Python object.

        Derives a hipExternalMemoryHandleDesc_st_union_0_struct_0 from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``hipExternalMemoryHandleDesc_st_union_0_struct_0`` reference, this method
        returns it directly. No new ``hipExternalMemoryHandleDesc_st_union_0_struct_0`` is created in this case.
        """
        return hipExternalMemoryHandleDesc_st_union_0_struct_0.fromPyobj(pyobj)

    @staticmethod
    cdef hipExternalMemoryHandleDesc_st_union_0_struct_0 fromPyobj(object pyobj):
        """Creates a hipExternalMemoryHandleDesc_st_union_0_struct_0 from a Python object.

        Derives a hipExternalMemoryHandleDesc_st_union_0_struct_0 from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``hipExternalMemoryHandleDesc_st_union_0_struct_0`` reference, this method
        returns it directly. No new ``hipExternalMemoryHandleDesc_st_union_0_struct_0`` is created in this case.

        Args:
            pyobj (object): Must be either `None`; a `hip._util.types.Pointer`; a simple, contiguous buffer according to the buffer protocol;
                            or of type `hipExternalMemoryHandleDesc_st_union_0_struct_0`; `int`; or `ctypes.c_void_p`.

        Note:
            This routine does not perform a copy but returns the original ``pyobj``
            if ``pyobj`` is an instance of hipExternalMemoryHandleDesc_st_union_0_struct_0!
        """
        cdef hipExternalMemoryHandleDesc_st_union_0_struct_0 wrapper

        if isinstance(pyobj,hipExternalMemoryHandleDesc_st_union_0_struct_0):
            return pyobj
        else:
            wrapper = hipExternalMemoryHandleDesc_st_union_0_struct_0.__new__(hipExternalMemoryHandleDesc_st_union_0_struct_0)
            wrapper.init_from_pyobj(pyobj)
            return wrapper

    def __dealloc__(self):
        # Release the buffer handle
        if self._py_buffer_acquired is True:
            cpython.buffer.PyBuffer_Release(&self._py_buffer)
        # De-allocate if not null and flag is set
        if self._ptr is not NULL and self._is_ptr_owner is True:
            stdlib.free(self._ptr)
            self._ptr = NULL

    @staticmethod
    cdef __allocate(void** ptr):
        ptr[0] = stdlib.malloc(sizeof(chip.hipExternalMemoryHandleDesc_st_union_0_struct_0))
        string.memset(<void*>ptr[0], 0, sizeof(chip.hipExternalMemoryHandleDesc_st_union_0_struct_0))

        if ptr[0] is NULL:
            raise MemoryError

    @staticmethod
    cdef hipExternalMemoryHandleDesc_st_union_0_struct_0 new():
        """Factory function to create hipExternalMemoryHandleDesc_st_union_0_struct_0 objects with
        newly allocated chip.hipExternalMemoryHandleDesc_st_union_0_struct_0"""
        cdef void* ptr
        hipExternalMemoryHandleDesc_st_union_0_struct_0.__allocate(&ptr)
        return hipExternalMemoryHandleDesc_st_union_0_struct_0.fromPtr(ptr, owner=True)

    @staticmethod
    cdef hipExternalMemoryHandleDesc_st_union_0_struct_0 fromValue(chip.hipExternalMemoryHandleDesc_st_union_0_struct_0 other):
        """Allocate new C type and copy from ``other``.
        """
        wrapper = hipExternalMemoryHandleDesc_st_union_0_struct_0.new()
        string.memcpy(wrapper._ptr, &other, sizeof(chip.hipExternalMemoryHandleDesc_st_union_0_struct_0))
        return wrapper

    def c_sizeof(self):
        """Returns the size of the underlying C type in bytes.
        Note:
            Implemented as function to not collide with
            autogenerated property names.
        """
        return sizeof(chip.hipExternalMemoryHandleDesc_st_union_0_struct_0)

    def __int__(self):
        """Returns the data's address as long integer.
        """
        return cpython.long.PyLong_FromVoidPtr(self._ptr)

    def __repr__(self):
        return f"<hipExternalMemoryHandleDesc_st_union_0_struct_0 object, ptr: {int(self)}>"

    def as_c_void_p(self):
        """Returns the data's address as `ctypes.c_void_p`
        Note:
            Implemented as function to not collide with
            autogenerated property names.
        """
        return ctypes.c_void_p(int(self))

    def __init__(self,*args,**kwargs):
        """Constructor type hipExternalMemoryHandleDesc_st_union_0_struct_0.

        Constructor for type hipExternalMemoryHandleDesc_st_union_0_struct_0.

        Args:
            *args:
                Positional arguments. Initialize all or a subset of the member variables
                according to their order of declaration.
            **kwargs:
                Can be used to initialize member variables at construction,
                Just pass an argument expression of the form <member>=<value>
                per member that you want to initialize.
        """
        hipExternalMemoryHandleDesc_st_union_0_struct_0.__allocate(&self._ptr)
        self._is_ptr_owner = True
        attribs = self.PROPERTIES()
        used_attribs = set()
        if len(args) > len(attribs):
            raise ValueError("More positional arguments specified than this type has properties.")
        for i,v in enumerate(args):
            setattr(self,attribs[i],v)
            used_attribs.add(attribs[i])
        valid_names = ", ".join(["'"+p+"'" for p in attribs])
        for k,v in kwargs.items():
            if k in used_attribs:
                raise KeyError(f"argument '{k}' has already been specified as positional argument.")
            elif k not in attribs:
                raise KeyError(f"'{k}' is no valid property name. Valid names: {valid_names}")
            setattr(self,k,v)
    def get_handle(self, i):
        """Get value ``handle`` of ``(<chip.hipExternalMemoryHandleDesc_st_union_0_struct_0*>self._ptr)[i]``.
        """
        return hip._util.types.Pointer.fromPtr((<chip.hipExternalMemoryHandleDesc_st_union_0_struct_0*>self._ptr)[i].handle)
    def set_handle(self, i, object value):
        """Set value ``handle`` of ``(<chip.hipExternalMemoryHandleDesc_st_union_0_struct_0*>self._ptr)[i]``.

        Note:
            This can be dangerous if the pointer is from a python object
            that is later on garbage collected.
        """
        (<chip.hipExternalMemoryHandleDesc_st_union_0_struct_0*>self._ptr)[i].handle = <void *>cpython.long.PyLong_AsVoidPtr(int(hip._util.types.Pointer.fromPyobj(value)))
    @property
    def handle(self):
        """(undocumented)
        Note:
            Setting this handle can be dangerous if the underlying pointer is from a python object that
            is later on garbage collected.
        """
        return self.get_handle(0)
    @handle.setter
    def handle(self, object value):
        self.set_handle(0,value)

    def get_name(self, i):
        """Get value ``name`` of ``(<chip.hipExternalMemoryHandleDesc_st_union_0_struct_0*>self._ptr)[i]``.
        """
        return hip._util.types.Pointer.fromPtr((<chip.hipExternalMemoryHandleDesc_st_union_0_struct_0*>self._ptr)[i].name)
    def set_name(self, i, object value):
        """Set value ``name`` of ``(<chip.hipExternalMemoryHandleDesc_st_union_0_struct_0*>self._ptr)[i]``.

        Note:
            This can be dangerous if the pointer is from a python object
            that is later on garbage collected.
        """
        (<chip.hipExternalMemoryHandleDesc_st_union_0_struct_0*>self._ptr)[i].name = <const void *>cpython.long.PyLong_AsVoidPtr(int(hip._util.types.Pointer.fromPyobj(value)))
    @property
    def name(self):
        """(undocumented)
        Note:
            Setting this name can be dangerous if the underlying pointer is from a python object that
            is later on garbage collected.
        """
        return self.get_name(0)
    @name.setter
    def name(self, object value):
        self.set_name(0,value)

    @staticmethod
    def PROPERTIES():
        return ["handle","name"]

    def __contains__(self,item):
        properties = self.PROPERTIES()
        return item in properties

    def __getitem__(self,item):
        properties = self.PROPERTIES()
        if isinstance(item,int):
            if item < 0 or item >= len(properties):
                raise IndexError()
            return getattr(self,properties[item])
        raise ValueError("'item' type must be 'int'")


cdef class hipExternalMemoryHandleDesc_st_union_0(hip._util.types.Pointer):
    """Python wrapper for cdef class chip.hipExternalMemoryHandleDesc_st_union_0.

    Python wrapper for cdef class chip.hipExternalMemoryHandleDesc_st_union_0.

    If this type is initialized via its `__init__` method, it allocates a
    member of the underlying C type and destroys it again if the wrapper
    type is deallocated.

    This type also serves as adapter when appearing as argument type in a
    function signature. In this case, the type can further be initialized
    from a number of Python objects:

    * `None`:

      This will set the ``self._ptr`` attribute to ``NULL``.

    * `int`:

      Interprets the integer value as pointer address and writes it to ``self._ptr``.
      No ownership is transferred.

    * `ctypes.c_void_p`:

      Takes the pointer address ``pyobj.value`` and writes it to ``self._ptr``.
      No ownership is transferred.

    * `object` that implements the `CUDA Array Interface <https://numba.readthedocs.io/en/stable/cuda/cuda_array_interface.html>`_ protocol:

      Takes the integer-valued pointer address, i.e. the first entry of the `data` tuple
      from `pyobj`'s member ``__cuda_array_interface__``  and writes it to ``self._ptr``.

    * `object` that implements the Python buffer protocol:

      If the object represents a simple contiguous array,
      writes the `Py_buffer` associated with ``pyobj`` to `self._py_buffer`,
      sets the `self._py_buffer_acquired` flag to `True`, and
      writes `self._py_buffer.buf` to the data pointer `self._ptr`.

    * `hip._util.types.Pointer`:

      Takes the pointer address ``pyobj._ptr`` and writes it to ``self._ptr``.
      No ownership is transferred.

    Type checks are performed in the above order.

    C Attributes:
        _ptr (C type ``void *``, protected):
            Stores a pointer to the data of the original Python object.
        _is_ptr_owner (C type ``bint``, protected):
            If this wrapper is the owner of the underlying data.
        _py_buffer (C type ``Py_buffer`, protected):
            Stores a pointer to the data of the original Python object.
        _py_buffer_acquired (C type ``bint``, protected):
            Stores a pointer to the data of the original Python object.
    """
    # C members declared in pxd file

    def __cinit__(self):
        self._ptr = NULL
        self._is_ptr_owner = False
        self._py_buffer_acquired = False

    cdef chip.hipExternalMemoryHandleDesc_st_union_0* getElementPtr(self):
        return <chip.hipExternalMemoryHandleDesc_st_union_0*>self._ptr

    @staticmethod
    cdef hipExternalMemoryHandleDesc_st_union_0 fromPtr(void* ptr, bint owner=False):
        """Factory function to create ``hipExternalMemoryHandleDesc_st_union_0`` objects from
        given ``chip.hipExternalMemoryHandleDesc_st_union_0`` pointer.

        Setting ``owner`` flag to ``True`` causes
        the extension type to free the structure pointed to by ``ptr``
        when the wrapper object is deallocated.
        """
        # Fast call to __new__() that bypasses the __init__() constructor.
        cdef hipExternalMemoryHandleDesc_st_union_0 wrapper = hipExternalMemoryHandleDesc_st_union_0.__new__(hipExternalMemoryHandleDesc_st_union_0)
        wrapper._ptr = ptr
        wrapper._is_ptr_owner = owner
        return wrapper

    @staticmethod
    def fromObj(pyobj):
        """Creates a hipExternalMemoryHandleDesc_st_union_0 from a Python object.

        Derives a hipExternalMemoryHandleDesc_st_union_0 from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``hipExternalMemoryHandleDesc_st_union_0`` reference, this method
        returns it directly. No new ``hipExternalMemoryHandleDesc_st_union_0`` is created in this case.
        """
        return hipExternalMemoryHandleDesc_st_union_0.fromPyobj(pyobj)

    @staticmethod
    cdef hipExternalMemoryHandleDesc_st_union_0 fromPyobj(object pyobj):
        """Creates a hipExternalMemoryHandleDesc_st_union_0 from a Python object.

        Derives a hipExternalMemoryHandleDesc_st_union_0 from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``hipExternalMemoryHandleDesc_st_union_0`` reference, this method
        returns it directly. No new ``hipExternalMemoryHandleDesc_st_union_0`` is created in this case.

        Args:
            pyobj (object): Must be either `None`; a `hip._util.types.Pointer`; a simple, contiguous buffer according to the buffer protocol;
                            or of type `hipExternalMemoryHandleDesc_st_union_0`; `int`; or `ctypes.c_void_p`.

        Note:
            This routine does not perform a copy but returns the original ``pyobj``
            if ``pyobj`` is an instance of hipExternalMemoryHandleDesc_st_union_0!
        """
        cdef hipExternalMemoryHandleDesc_st_union_0 wrapper

        if isinstance(pyobj,hipExternalMemoryHandleDesc_st_union_0):
            return pyobj
        else:
            wrapper = hipExternalMemoryHandleDesc_st_union_0.__new__(hipExternalMemoryHandleDesc_st_union_0)
            wrapper.init_from_pyobj(pyobj)
            return wrapper

    def __dealloc__(self):
        # Release the buffer handle
        if self._py_buffer_acquired is True:
            cpython.buffer.PyBuffer_Release(&self._py_buffer)
        # De-allocate if not null and flag is set
        if self._ptr is not NULL and self._is_ptr_owner is True:
            stdlib.free(self._ptr)
            self._ptr = NULL

    @staticmethod
    cdef __allocate(void** ptr):
        ptr[0] = stdlib.malloc(sizeof(chip.hipExternalMemoryHandleDesc_st_union_0))
        string.memset(<void*>ptr[0], 0, sizeof(chip.hipExternalMemoryHandleDesc_st_union_0))

        if ptr[0] is NULL:
            raise MemoryError

    @staticmethod
    cdef hipExternalMemoryHandleDesc_st_union_0 new():
        """Factory function to create hipExternalMemoryHandleDesc_st_union_0 objects with
        newly allocated chip.hipExternalMemoryHandleDesc_st_union_0"""
        cdef void* ptr
        hipExternalMemoryHandleDesc_st_union_0.__allocate(&ptr)
        return hipExternalMemoryHandleDesc_st_union_0.fromPtr(ptr, owner=True)

    @staticmethod
    cdef hipExternalMemoryHandleDesc_st_union_0 fromValue(chip.hipExternalMemoryHandleDesc_st_union_0 other):
        """Allocate new C type and copy from ``other``.
        """
        wrapper = hipExternalMemoryHandleDesc_st_union_0.new()
        string.memcpy(wrapper._ptr, &other, sizeof(chip.hipExternalMemoryHandleDesc_st_union_0))
        return wrapper

    def c_sizeof(self):
        """Returns the size of the underlying C type in bytes.
        Note:
            Implemented as function to not collide with
            autogenerated property names.
        """
        return sizeof(chip.hipExternalMemoryHandleDesc_st_union_0)

    def __int__(self):
        """Returns the data's address as long integer.
        """
        return cpython.long.PyLong_FromVoidPtr(self._ptr)

    def __repr__(self):
        return f"<hipExternalMemoryHandleDesc_st_union_0 object, ptr: {int(self)}>"

    def as_c_void_p(self):
        """Returns the data's address as `ctypes.c_void_p`
        Note:
            Implemented as function to not collide with
            autogenerated property names.
        """
        return ctypes.c_void_p(int(self))

    def __init__(self,**kwargs):
        """Constructor type hipExternalMemoryHandleDesc_st_union_0.

        Constructor for type hipExternalMemoryHandleDesc_st_union_0.

        Args:
            **kwargs:
                Can be used to initialize member variables at construction,
                Just pass an argument expression of the form <member>=<value>
                per member that you want to initialize.
        """
        hipExternalMemoryHandleDesc_st_union_0.__allocate(&self._ptr)
        self._is_ptr_owner = True
        attribs = self.PROPERTIES()
        used_attribs = set()
        if len(kwargs) > 1:
            raise ValueError("Not more than one attribute might specified for Python types derived from C union types.")
        valid_names = ", ".join(["'"+p+"'" for p in attribs])
        for k,v in kwargs.items():
            if k in used_attribs:
                raise KeyError(f"argument '{k}' has already been specified as positional argument.")
            elif k not in attribs:
                raise KeyError(f"'{k}' is no valid property name. Valid names: {valid_names}")
            setattr(self,k,v)
    def get_fd(self, i):
        """Get value ``fd`` of ``(<chip.hipExternalMemoryHandleDesc_st_union_0*>self._ptr)[i]``.
        """
        return (<chip.hipExternalMemoryHandleDesc_st_union_0*>self._ptr)[i].fd
    def set_fd(self, i, int value):
        """Set value ``fd`` of ``(<chip.hipExternalMemoryHandleDesc_st_union_0*>self._ptr)[i]``.
        """
        (<chip.hipExternalMemoryHandleDesc_st_union_0*>self._ptr)[i].fd = value
    @property
    def fd(self):
        """(undocumented)"""
        return self.get_fd(0)
    @fd.setter
    def fd(self, int value):
        self.set_fd(0,value)

    def get_win32(self, i):
        """Get value of ``win32`` of ``(<chip.hipExternalMemoryHandleDesc_st_union_0*>self._ptr)[i]``.
        """
        return hipExternalMemoryHandleDesc_st_union_0_struct_0.fromPtr(&(<chip.hipExternalMemoryHandleDesc_st_union_0*>self._ptr)[i].win32)
    @property
    def win32(self):
        """(undocumented)"""
        return self.get_win32(0)

    def get_nvSciBufObject(self, i):
        """Get value ``nvSciBufObject`` of ``(<chip.hipExternalMemoryHandleDesc_st_union_0*>self._ptr)[i]``.
        """
        return hip._util.types.Pointer.fromPtr((<chip.hipExternalMemoryHandleDesc_st_union_0*>self._ptr)[i].nvSciBufObject)
    def set_nvSciBufObject(self, i, object value):
        """Set value ``nvSciBufObject`` of ``(<chip.hipExternalMemoryHandleDesc_st_union_0*>self._ptr)[i]``.

        Note:
            This can be dangerous if the pointer is from a python object
            that is later on garbage collected.
        """
        (<chip.hipExternalMemoryHandleDesc_st_union_0*>self._ptr)[i].nvSciBufObject = <const void *>cpython.long.PyLong_AsVoidPtr(int(hip._util.types.Pointer.fromPyobj(value)))
    @property
    def nvSciBufObject(self):
        """(undocumented)
        Note:
            Setting this nvSciBufObject can be dangerous if the underlying pointer is from a python object that
            is later on garbage collected.
        """
        return self.get_nvSciBufObject(0)
    @nvSciBufObject.setter
    def nvSciBufObject(self, object value):
        self.set_nvSciBufObject(0,value)

    @staticmethod
    def PROPERTIES():
        return ["fd","win32","nvSciBufObject"]


cdef class hipExternalMemoryHandleDesc_st(hip._util.types.Pointer):
    """Python wrapper for cdef class chip.hipExternalMemoryHandleDesc_st.

    Python wrapper for cdef class chip.hipExternalMemoryHandleDesc_st.

    If this type is initialized via its `__init__` method, it allocates a
    member of the underlying C type and destroys it again if the wrapper
    type is deallocated.

    This type also serves as adapter when appearing as argument type in a
    function signature. In this case, the type can further be initialized
    from a number of Python objects:

    * `None`:

      This will set the ``self._ptr`` attribute to ``NULL``.

    * `int`:

      Interprets the integer value as pointer address and writes it to ``self._ptr``.
      No ownership is transferred.

    * `ctypes.c_void_p`:

      Takes the pointer address ``pyobj.value`` and writes it to ``self._ptr``.
      No ownership is transferred.

    * `object` that implements the `CUDA Array Interface <https://numba.readthedocs.io/en/stable/cuda/cuda_array_interface.html>`_ protocol:

      Takes the integer-valued pointer address, i.e. the first entry of the `data` tuple
      from `pyobj`'s member ``__cuda_array_interface__``  and writes it to ``self._ptr``.

    * `object` that implements the Python buffer protocol:

      If the object represents a simple contiguous array,
      writes the `Py_buffer` associated with ``pyobj`` to `self._py_buffer`,
      sets the `self._py_buffer_acquired` flag to `True`, and
      writes `self._py_buffer.buf` to the data pointer `self._ptr`.

    * `hip._util.types.Pointer`:

      Takes the pointer address ``pyobj._ptr`` and writes it to ``self._ptr``.
      No ownership is transferred.

    Type checks are performed in the above order.

    C Attributes:
        _ptr (C type ``void *``, protected):
            Stores a pointer to the data of the original Python object.
        _is_ptr_owner (C type ``bint``, protected):
            If this wrapper is the owner of the underlying data.
        _py_buffer (C type ``Py_buffer`, protected):
            Stores a pointer to the data of the original Python object.
        _py_buffer_acquired (C type ``bint``, protected):
            Stores a pointer to the data of the original Python object.
    """
    # C members declared in pxd file

    def __cinit__(self):
        self._ptr = NULL
        self._is_ptr_owner = False
        self._py_buffer_acquired = False

    cdef chip.hipExternalMemoryHandleDesc_st* getElementPtr(self):
        return <chip.hipExternalMemoryHandleDesc_st*>self._ptr

    @staticmethod
    cdef hipExternalMemoryHandleDesc_st fromPtr(void* ptr, bint owner=False):
        """Factory function to create ``hipExternalMemoryHandleDesc_st`` objects from
        given ``chip.hipExternalMemoryHandleDesc_st`` pointer.

        Setting ``owner`` flag to ``True`` causes
        the extension type to free the structure pointed to by ``ptr``
        when the wrapper object is deallocated.
        """
        # Fast call to __new__() that bypasses the __init__() constructor.
        cdef hipExternalMemoryHandleDesc_st wrapper = hipExternalMemoryHandleDesc_st.__new__(hipExternalMemoryHandleDesc_st)
        wrapper._ptr = ptr
        wrapper._is_ptr_owner = owner
        return wrapper

    @staticmethod
    def fromObj(pyobj):
        """Creates a hipExternalMemoryHandleDesc_st from a Python object.

        Derives a hipExternalMemoryHandleDesc_st from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``hipExternalMemoryHandleDesc_st`` reference, this method
        returns it directly. No new ``hipExternalMemoryHandleDesc_st`` is created in this case.
        """
        return hipExternalMemoryHandleDesc_st.fromPyobj(pyobj)

    @staticmethod
    cdef hipExternalMemoryHandleDesc_st fromPyobj(object pyobj):
        """Creates a hipExternalMemoryHandleDesc_st from a Python object.

        Derives a hipExternalMemoryHandleDesc_st from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``hipExternalMemoryHandleDesc_st`` reference, this method
        returns it directly. No new ``hipExternalMemoryHandleDesc_st`` is created in this case.

        Args:
            pyobj (object): Must be either `None`; a `hip._util.types.Pointer`; a simple, contiguous buffer according to the buffer protocol;
                            or of type `hipExternalMemoryHandleDesc_st`; `int`; or `ctypes.c_void_p`.

        Note:
            This routine does not perform a copy but returns the original ``pyobj``
            if ``pyobj`` is an instance of hipExternalMemoryHandleDesc_st!
        """
        cdef hipExternalMemoryHandleDesc_st wrapper

        if isinstance(pyobj,hipExternalMemoryHandleDesc_st):
            return pyobj
        else:
            wrapper = hipExternalMemoryHandleDesc_st.__new__(hipExternalMemoryHandleDesc_st)
            wrapper.init_from_pyobj(pyobj)
            return wrapper

    def __dealloc__(self):
        # Release the buffer handle
        if self._py_buffer_acquired is True:
            cpython.buffer.PyBuffer_Release(&self._py_buffer)
        # De-allocate if not null and flag is set
        if self._ptr is not NULL and self._is_ptr_owner is True:
            stdlib.free(self._ptr)
            self._ptr = NULL

    @staticmethod
    cdef __allocate(void** ptr):
        ptr[0] = stdlib.malloc(sizeof(chip.hipExternalMemoryHandleDesc_st))
        string.memset(<void*>ptr[0], 0, sizeof(chip.hipExternalMemoryHandleDesc_st))

        if ptr[0] is NULL:
            raise MemoryError

    @staticmethod
    cdef hipExternalMemoryHandleDesc_st new():
        """Factory function to create hipExternalMemoryHandleDesc_st objects with
        newly allocated chip.hipExternalMemoryHandleDesc_st"""
        cdef void* ptr
        hipExternalMemoryHandleDesc_st.__allocate(&ptr)
        return hipExternalMemoryHandleDesc_st.fromPtr(ptr, owner=True)

    @staticmethod
    cdef hipExternalMemoryHandleDesc_st fromValue(chip.hipExternalMemoryHandleDesc_st other):
        """Allocate new C type and copy from ``other``.
        """
        wrapper = hipExternalMemoryHandleDesc_st.new()
        string.memcpy(wrapper._ptr, &other, sizeof(chip.hipExternalMemoryHandleDesc_st))
        return wrapper

    def c_sizeof(self):
        """Returns the size of the underlying C type in bytes.
        Note:
            Implemented as function to not collide with
            autogenerated property names.
        """
        return sizeof(chip.hipExternalMemoryHandleDesc_st)

    def __int__(self):
        """Returns the data's address as long integer.
        """
        return cpython.long.PyLong_FromVoidPtr(self._ptr)

    def __repr__(self):
        return f"<hipExternalMemoryHandleDesc_st object, ptr: {int(self)}>"

    def as_c_void_p(self):
        """Returns the data's address as `ctypes.c_void_p`
        Note:
            Implemented as function to not collide with
            autogenerated property names.
        """
        return ctypes.c_void_p(int(self))

    def __init__(self,*args,**kwargs):
        """Constructor type hipExternalMemoryHandleDesc_st.

        Constructor for type hipExternalMemoryHandleDesc_st.

        Args:
            *args:
                Positional arguments. Initialize all or a subset of the member variables
                according to their order of declaration.
            **kwargs:
                Can be used to initialize member variables at construction,
                Just pass an argument expression of the form <member>=<value>
                per member that you want to initialize.
        """
        hipExternalMemoryHandleDesc_st.__allocate(&self._ptr)
        self._is_ptr_owner = True
        attribs = self.PROPERTIES()
        used_attribs = set()
        if len(args) > len(attribs):
            raise ValueError("More positional arguments specified than this type has properties.")
        for i,v in enumerate(args):
            setattr(self,attribs[i],v)
            used_attribs.add(attribs[i])
        valid_names = ", ".join(["'"+p+"'" for p in attribs])
        for k,v in kwargs.items():
            if k in used_attribs:
                raise KeyError(f"argument '{k}' has already been specified as positional argument.")
            elif k not in attribs:
                raise KeyError(f"'{k}' is no valid property name. Valid names: {valid_names}")
            setattr(self,k,v)
    def get_type(self, i):
        """Get value of ``type`` of ``(<chip.hipExternalMemoryHandleDesc_st*>self._ptr)[i]``.
        """
        return hipExternalMemoryHandleType_enum((<chip.hipExternalMemoryHandleDesc_st*>self._ptr)[i].type)
    def set_type(self, i, value):
        """Set value ``type`` of ``(<chip.hipExternalMemoryHandleDesc_st*>self._ptr)[i]``.
        """
        if not isinstance(value, hipExternalMemoryHandleType_enum):
            raise TypeError("'value' must be of type 'hipExternalMemoryHandleType_enum'")
        (<chip.hipExternalMemoryHandleDesc_st*>self._ptr)[i].type = value.value
    @property
    def type(self):
        """(undocumented)"""
        return self.get_type(0)
    @type.setter
    def type(self, value):
        self.set_type(0,value)

    def get_handle(self, i):
        """Get value of ``handle`` of ``(<chip.hipExternalMemoryHandleDesc_st*>self._ptr)[i]``.
        """
        return hipExternalMemoryHandleDesc_st_union_0.fromPtr(&(<chip.hipExternalMemoryHandleDesc_st*>self._ptr)[i].handle)
    @property
    def handle(self):
        """(undocumented)"""
        return self.get_handle(0)

    def get_size(self, i):
        """Get value ``size`` of ``(<chip.hipExternalMemoryHandleDesc_st*>self._ptr)[i]``.
        """
        return (<chip.hipExternalMemoryHandleDesc_st*>self._ptr)[i].size
    def set_size(self, i, unsigned long long value):
        """Set value ``size`` of ``(<chip.hipExternalMemoryHandleDesc_st*>self._ptr)[i]``.
        """
        (<chip.hipExternalMemoryHandleDesc_st*>self._ptr)[i].size = value
    @property
    def size(self):
        """(undocumented)"""
        return self.get_size(0)
    @size.setter
    def size(self, unsigned long long value):
        self.set_size(0,value)

    def get_flags(self, i):
        """Get value ``flags`` of ``(<chip.hipExternalMemoryHandleDesc_st*>self._ptr)[i]``.
        """
        return (<chip.hipExternalMemoryHandleDesc_st*>self._ptr)[i].flags
    def set_flags(self, i, unsigned int value):
        """Set value ``flags`` of ``(<chip.hipExternalMemoryHandleDesc_st*>self._ptr)[i]``.
        """
        (<chip.hipExternalMemoryHandleDesc_st*>self._ptr)[i].flags = value
    @property
    def flags(self):
        """(undocumented)"""
        return self.get_flags(0)
    @flags.setter
    def flags(self, unsigned int value):
        self.set_flags(0,value)

    def get_reserved(self, i):
        """Get value of ``reserved`` of ``(<chip.hipExternalMemoryHandleDesc_st*>self._ptr)[i]``.
        """
        return (<chip.hipExternalMemoryHandleDesc_st*>self._ptr)[i].reserved
    # TODO add setters
    #def set_reserved(self, i, unsigned int[16] value):
    #    """Set value ``reserved`` of ``(<chip.hipExternalMemoryHandleDesc_st*>self._ptr)[i]``.
    #    """
    #    (<chip.hipExternalMemoryHandleDesc_st*>self._ptr)[i].reserved = value
    @property
    def reserved(self):
        """(undocumented)"""
        return self.get_reserved(0)
    # TODO add setters
    #@reserved.setter
    #def reserved(self, unsigned int[16] value):
    #    self.set_reserved(0,value)

    @staticmethod
    def PROPERTIES():
        return ["type","handle","size","flags","reserved"]

    def __contains__(self,item):
        properties = self.PROPERTIES()
        return item in properties

    def __getitem__(self,item):
        properties = self.PROPERTIES()
        if isinstance(item,int):
            if item < 0 or item >= len(properties):
                raise IndexError()
            return getattr(self,properties[item])
        raise ValueError("'item' type must be 'int'")


hipExternalMemoryHandleDesc = hipExternalMemoryHandleDesc_st

cdef class hipExternalMemoryBufferDesc_st(hip._util.types.Pointer):
    """Python wrapper for cdef class chip.hipExternalMemoryBufferDesc_st.

    Python wrapper for cdef class chip.hipExternalMemoryBufferDesc_st.

    If this type is initialized via its `__init__` method, it allocates a
    member of the underlying C type and destroys it again if the wrapper
    type is deallocated.

    This type also serves as adapter when appearing as argument type in a
    function signature. In this case, the type can further be initialized
    from a number of Python objects:

    * `None`:

      This will set the ``self._ptr`` attribute to ``NULL``.

    * `int`:

      Interprets the integer value as pointer address and writes it to ``self._ptr``.
      No ownership is transferred.

    * `ctypes.c_void_p`:

      Takes the pointer address ``pyobj.value`` and writes it to ``self._ptr``.
      No ownership is transferred.

    * `object` that implements the `CUDA Array Interface <https://numba.readthedocs.io/en/stable/cuda/cuda_array_interface.html>`_ protocol:

      Takes the integer-valued pointer address, i.e. the first entry of the `data` tuple
      from `pyobj`'s member ``__cuda_array_interface__``  and writes it to ``self._ptr``.

    * `object` that implements the Python buffer protocol:

      If the object represents a simple contiguous array,
      writes the `Py_buffer` associated with ``pyobj`` to `self._py_buffer`,
      sets the `self._py_buffer_acquired` flag to `True`, and
      writes `self._py_buffer.buf` to the data pointer `self._ptr`.

    * `hip._util.types.Pointer`:

      Takes the pointer address ``pyobj._ptr`` and writes it to ``self._ptr``.
      No ownership is transferred.

    Type checks are performed in the above order.

    C Attributes:
        _ptr (C type ``void *``, protected):
            Stores a pointer to the data of the original Python object.
        _is_ptr_owner (C type ``bint``, protected):
            If this wrapper is the owner of the underlying data.
        _py_buffer (C type ``Py_buffer`, protected):
            Stores a pointer to the data of the original Python object.
        _py_buffer_acquired (C type ``bint``, protected):
            Stores a pointer to the data of the original Python object.
    """
    # C members declared in pxd file

    def __cinit__(self):
        self._ptr = NULL
        self._is_ptr_owner = False
        self._py_buffer_acquired = False

    cdef chip.hipExternalMemoryBufferDesc_st* getElementPtr(self):
        return <chip.hipExternalMemoryBufferDesc_st*>self._ptr

    @staticmethod
    cdef hipExternalMemoryBufferDesc_st fromPtr(void* ptr, bint owner=False):
        """Factory function to create ``hipExternalMemoryBufferDesc_st`` objects from
        given ``chip.hipExternalMemoryBufferDesc_st`` pointer.

        Setting ``owner`` flag to ``True`` causes
        the extension type to free the structure pointed to by ``ptr``
        when the wrapper object is deallocated.
        """
        # Fast call to __new__() that bypasses the __init__() constructor.
        cdef hipExternalMemoryBufferDesc_st wrapper = hipExternalMemoryBufferDesc_st.__new__(hipExternalMemoryBufferDesc_st)
        wrapper._ptr = ptr
        wrapper._is_ptr_owner = owner
        return wrapper

    @staticmethod
    def fromObj(pyobj):
        """Creates a hipExternalMemoryBufferDesc_st from a Python object.

        Derives a hipExternalMemoryBufferDesc_st from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``hipExternalMemoryBufferDesc_st`` reference, this method
        returns it directly. No new ``hipExternalMemoryBufferDesc_st`` is created in this case.
        """
        return hipExternalMemoryBufferDesc_st.fromPyobj(pyobj)

    @staticmethod
    cdef hipExternalMemoryBufferDesc_st fromPyobj(object pyobj):
        """Creates a hipExternalMemoryBufferDesc_st from a Python object.

        Derives a hipExternalMemoryBufferDesc_st from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``hipExternalMemoryBufferDesc_st`` reference, this method
        returns it directly. No new ``hipExternalMemoryBufferDesc_st`` is created in this case.

        Args:
            pyobj (object): Must be either `None`; a `hip._util.types.Pointer`; a simple, contiguous buffer according to the buffer protocol;
                            or of type `hipExternalMemoryBufferDesc_st`; `int`; or `ctypes.c_void_p`.

        Note:
            This routine does not perform a copy but returns the original ``pyobj``
            if ``pyobj`` is an instance of hipExternalMemoryBufferDesc_st!
        """
        cdef hipExternalMemoryBufferDesc_st wrapper

        if isinstance(pyobj,hipExternalMemoryBufferDesc_st):
            return pyobj
        else:
            wrapper = hipExternalMemoryBufferDesc_st.__new__(hipExternalMemoryBufferDesc_st)
            wrapper.init_from_pyobj(pyobj)
            return wrapper

    def __dealloc__(self):
        # Release the buffer handle
        if self._py_buffer_acquired is True:
            cpython.buffer.PyBuffer_Release(&self._py_buffer)
        # De-allocate if not null and flag is set
        if self._ptr is not NULL and self._is_ptr_owner is True:
            stdlib.free(self._ptr)
            self._ptr = NULL

    @staticmethod
    cdef __allocate(void** ptr):
        ptr[0] = stdlib.malloc(sizeof(chip.hipExternalMemoryBufferDesc_st))
        string.memset(<void*>ptr[0], 0, sizeof(chip.hipExternalMemoryBufferDesc_st))

        if ptr[0] is NULL:
            raise MemoryError

    @staticmethod
    cdef hipExternalMemoryBufferDesc_st new():
        """Factory function to create hipExternalMemoryBufferDesc_st objects with
        newly allocated chip.hipExternalMemoryBufferDesc_st"""
        cdef void* ptr
        hipExternalMemoryBufferDesc_st.__allocate(&ptr)
        return hipExternalMemoryBufferDesc_st.fromPtr(ptr, owner=True)

    @staticmethod
    cdef hipExternalMemoryBufferDesc_st fromValue(chip.hipExternalMemoryBufferDesc_st other):
        """Allocate new C type and copy from ``other``.
        """
        wrapper = hipExternalMemoryBufferDesc_st.new()
        string.memcpy(wrapper._ptr, &other, sizeof(chip.hipExternalMemoryBufferDesc_st))
        return wrapper

    def c_sizeof(self):
        """Returns the size of the underlying C type in bytes.
        Note:
            Implemented as function to not collide with
            autogenerated property names.
        """
        return sizeof(chip.hipExternalMemoryBufferDesc_st)

    def __int__(self):
        """Returns the data's address as long integer.
        """
        return cpython.long.PyLong_FromVoidPtr(self._ptr)

    def __repr__(self):
        return f"<hipExternalMemoryBufferDesc_st object, ptr: {int(self)}>"

    def as_c_void_p(self):
        """Returns the data's address as `ctypes.c_void_p`
        Note:
            Implemented as function to not collide with
            autogenerated property names.
        """
        return ctypes.c_void_p(int(self))

    def __init__(self,*args,**kwargs):
        """Constructor type hipExternalMemoryBufferDesc_st.

        Constructor for type hipExternalMemoryBufferDesc_st.

        Args:
            *args:
                Positional arguments. Initialize all or a subset of the member variables
                according to their order of declaration.
            **kwargs:
                Can be used to initialize member variables at construction,
                Just pass an argument expression of the form <member>=<value>
                per member that you want to initialize.
        """
        hipExternalMemoryBufferDesc_st.__allocate(&self._ptr)
        self._is_ptr_owner = True
        attribs = self.PROPERTIES()
        used_attribs = set()
        if len(args) > len(attribs):
            raise ValueError("More positional arguments specified than this type has properties.")
        for i,v in enumerate(args):
            setattr(self,attribs[i],v)
            used_attribs.add(attribs[i])
        valid_names = ", ".join(["'"+p+"'" for p in attribs])
        for k,v in kwargs.items():
            if k in used_attribs:
                raise KeyError(f"argument '{k}' has already been specified as positional argument.")
            elif k not in attribs:
                raise KeyError(f"'{k}' is no valid property name. Valid names: {valid_names}")
            setattr(self,k,v)
    def get_offset(self, i):
        """Get value ``offset`` of ``(<chip.hipExternalMemoryBufferDesc_st*>self._ptr)[i]``.
        """
        return (<chip.hipExternalMemoryBufferDesc_st*>self._ptr)[i].offset
    def set_offset(self, i, unsigned long long value):
        """Set value ``offset`` of ``(<chip.hipExternalMemoryBufferDesc_st*>self._ptr)[i]``.
        """
        (<chip.hipExternalMemoryBufferDesc_st*>self._ptr)[i].offset = value
    @property
    def offset(self):
        """(undocumented)"""
        return self.get_offset(0)
    @offset.setter
    def offset(self, unsigned long long value):
        self.set_offset(0,value)

    def get_size(self, i):
        """Get value ``size`` of ``(<chip.hipExternalMemoryBufferDesc_st*>self._ptr)[i]``.
        """
        return (<chip.hipExternalMemoryBufferDesc_st*>self._ptr)[i].size
    def set_size(self, i, unsigned long long value):
        """Set value ``size`` of ``(<chip.hipExternalMemoryBufferDesc_st*>self._ptr)[i]``.
        """
        (<chip.hipExternalMemoryBufferDesc_st*>self._ptr)[i].size = value
    @property
    def size(self):
        """(undocumented)"""
        return self.get_size(0)
    @size.setter
    def size(self, unsigned long long value):
        self.set_size(0,value)

    def get_flags(self, i):
        """Get value ``flags`` of ``(<chip.hipExternalMemoryBufferDesc_st*>self._ptr)[i]``.
        """
        return (<chip.hipExternalMemoryBufferDesc_st*>self._ptr)[i].flags
    def set_flags(self, i, unsigned int value):
        """Set value ``flags`` of ``(<chip.hipExternalMemoryBufferDesc_st*>self._ptr)[i]``.
        """
        (<chip.hipExternalMemoryBufferDesc_st*>self._ptr)[i].flags = value
    @property
    def flags(self):
        """(undocumented)"""
        return self.get_flags(0)
    @flags.setter
    def flags(self, unsigned int value):
        self.set_flags(0,value)

    def get_reserved(self, i):
        """Get value of ``reserved`` of ``(<chip.hipExternalMemoryBufferDesc_st*>self._ptr)[i]``.
        """
        return (<chip.hipExternalMemoryBufferDesc_st*>self._ptr)[i].reserved
    # TODO add setters
    #def set_reserved(self, i, unsigned int[16] value):
    #    """Set value ``reserved`` of ``(<chip.hipExternalMemoryBufferDesc_st*>self._ptr)[i]``.
    #    """
    #    (<chip.hipExternalMemoryBufferDesc_st*>self._ptr)[i].reserved = value
    @property
    def reserved(self):
        """(undocumented)"""
        return self.get_reserved(0)
    # TODO add setters
    #@reserved.setter
    #def reserved(self, unsigned int[16] value):
    #    self.set_reserved(0,value)

    @staticmethod
    def PROPERTIES():
        return ["offset","size","flags","reserved"]

    def __contains__(self,item):
        properties = self.PROPERTIES()
        return item in properties

    def __getitem__(self,item):
        properties = self.PROPERTIES()
        if isinstance(item,int):
            if item < 0 or item >= len(properties):
                raise IndexError()
            return getattr(self,properties[item])
        raise ValueError("'item' type must be 'int'")


hipExternalMemoryBufferDesc = hipExternalMemoryBufferDesc_st

cdef class hipExternalMemoryMipmappedArrayDesc_st(hip._util.types.Pointer):
    """Python wrapper for cdef class chip.hipExternalMemoryMipmappedArrayDesc_st.

    Python wrapper for cdef class chip.hipExternalMemoryMipmappedArrayDesc_st.

    If this type is initialized via its `__init__` method, it allocates a
    member of the underlying C type and destroys it again if the wrapper
    type is deallocated.

    This type also serves as adapter when appearing as argument type in a
    function signature. In this case, the type can further be initialized
    from a number of Python objects:

    * `None`:

      This will set the ``self._ptr`` attribute to ``NULL``.

    * `int`:

      Interprets the integer value as pointer address and writes it to ``self._ptr``.
      No ownership is transferred.

    * `ctypes.c_void_p`:

      Takes the pointer address ``pyobj.value`` and writes it to ``self._ptr``.
      No ownership is transferred.

    * `object` that implements the `CUDA Array Interface <https://numba.readthedocs.io/en/stable/cuda/cuda_array_interface.html>`_ protocol:

      Takes the integer-valued pointer address, i.e. the first entry of the `data` tuple
      from `pyobj`'s member ``__cuda_array_interface__``  and writes it to ``self._ptr``.

    * `object` that implements the Python buffer protocol:

      If the object represents a simple contiguous array,
      writes the `Py_buffer` associated with ``pyobj`` to `self._py_buffer`,
      sets the `self._py_buffer_acquired` flag to `True`, and
      writes `self._py_buffer.buf` to the data pointer `self._ptr`.

    * `hip._util.types.Pointer`:

      Takes the pointer address ``pyobj._ptr`` and writes it to ``self._ptr``.
      No ownership is transferred.

    Type checks are performed in the above order.

    C Attributes:
        _ptr (C type ``void *``, protected):
            Stores a pointer to the data of the original Python object.
        _is_ptr_owner (C type ``bint``, protected):
            If this wrapper is the owner of the underlying data.
        _py_buffer (C type ``Py_buffer`, protected):
            Stores a pointer to the data of the original Python object.
        _py_buffer_acquired (C type ``bint``, protected):
            Stores a pointer to the data of the original Python object.
    """
    # C members declared in pxd file

    def __cinit__(self):
        self._ptr = NULL
        self._is_ptr_owner = False
        self._py_buffer_acquired = False

    cdef chip.hipExternalMemoryMipmappedArrayDesc_st* getElementPtr(self):
        return <chip.hipExternalMemoryMipmappedArrayDesc_st*>self._ptr

    @staticmethod
    cdef hipExternalMemoryMipmappedArrayDesc_st fromPtr(void* ptr, bint owner=False):
        """Factory function to create ``hipExternalMemoryMipmappedArrayDesc_st`` objects from
        given ``chip.hipExternalMemoryMipmappedArrayDesc_st`` pointer.

        Setting ``owner`` flag to ``True`` causes
        the extension type to free the structure pointed to by ``ptr``
        when the wrapper object is deallocated.
        """
        # Fast call to __new__() that bypasses the __init__() constructor.
        cdef hipExternalMemoryMipmappedArrayDesc_st wrapper = hipExternalMemoryMipmappedArrayDesc_st.__new__(hipExternalMemoryMipmappedArrayDesc_st)
        wrapper._ptr = ptr
        wrapper._is_ptr_owner = owner
        return wrapper

    @staticmethod
    def fromObj(pyobj):
        """Creates a hipExternalMemoryMipmappedArrayDesc_st from a Python object.

        Derives a hipExternalMemoryMipmappedArrayDesc_st from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``hipExternalMemoryMipmappedArrayDesc_st`` reference, this method
        returns it directly. No new ``hipExternalMemoryMipmappedArrayDesc_st`` is created in this case.
        """
        return hipExternalMemoryMipmappedArrayDesc_st.fromPyobj(pyobj)

    @staticmethod
    cdef hipExternalMemoryMipmappedArrayDesc_st fromPyobj(object pyobj):
        """Creates a hipExternalMemoryMipmappedArrayDesc_st from a Python object.

        Derives a hipExternalMemoryMipmappedArrayDesc_st from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``hipExternalMemoryMipmappedArrayDesc_st`` reference, this method
        returns it directly. No new ``hipExternalMemoryMipmappedArrayDesc_st`` is created in this case.

        Args:
            pyobj (object): Must be either `None`; a `hip._util.types.Pointer`; a simple, contiguous buffer according to the buffer protocol;
                            or of type `hipExternalMemoryMipmappedArrayDesc_st`; `int`; or `ctypes.c_void_p`.

        Note:
            This routine does not perform a copy but returns the original ``pyobj``
            if ``pyobj`` is an instance of hipExternalMemoryMipmappedArrayDesc_st!
        """
        cdef hipExternalMemoryMipmappedArrayDesc_st wrapper

        if isinstance(pyobj,hipExternalMemoryMipmappedArrayDesc_st):
            return pyobj
        else:
            wrapper = hipExternalMemoryMipmappedArrayDesc_st.__new__(hipExternalMemoryMipmappedArrayDesc_st)
            wrapper.init_from_pyobj(pyobj)
            return wrapper

    def __dealloc__(self):
        # Release the buffer handle
        if self._py_buffer_acquired is True:
            cpython.buffer.PyBuffer_Release(&self._py_buffer)
        # De-allocate if not null and flag is set
        if self._ptr is not NULL and self._is_ptr_owner is True:
            stdlib.free(self._ptr)
            self._ptr = NULL

    @staticmethod
    cdef __allocate(void** ptr):
        ptr[0] = stdlib.malloc(sizeof(chip.hipExternalMemoryMipmappedArrayDesc_st))
        string.memset(<void*>ptr[0], 0, sizeof(chip.hipExternalMemoryMipmappedArrayDesc_st))

        if ptr[0] is NULL:
            raise MemoryError

    @staticmethod
    cdef hipExternalMemoryMipmappedArrayDesc_st new():
        """Factory function to create hipExternalMemoryMipmappedArrayDesc_st objects with
        newly allocated chip.hipExternalMemoryMipmappedArrayDesc_st"""
        cdef void* ptr
        hipExternalMemoryMipmappedArrayDesc_st.__allocate(&ptr)
        return hipExternalMemoryMipmappedArrayDesc_st.fromPtr(ptr, owner=True)

    @staticmethod
    cdef hipExternalMemoryMipmappedArrayDesc_st fromValue(chip.hipExternalMemoryMipmappedArrayDesc_st other):
        """Allocate new C type and copy from ``other``.
        """
        wrapper = hipExternalMemoryMipmappedArrayDesc_st.new()
        string.memcpy(wrapper._ptr, &other, sizeof(chip.hipExternalMemoryMipmappedArrayDesc_st))
        return wrapper

    def c_sizeof(self):
        """Returns the size of the underlying C type in bytes.
        Note:
            Implemented as function to not collide with
            autogenerated property names.
        """
        return sizeof(chip.hipExternalMemoryMipmappedArrayDesc_st)

    def __int__(self):
        """Returns the data's address as long integer.
        """
        return cpython.long.PyLong_FromVoidPtr(self._ptr)

    def __repr__(self):
        return f"<hipExternalMemoryMipmappedArrayDesc_st object, ptr: {int(self)}>"

    def as_c_void_p(self):
        """Returns the data's address as `ctypes.c_void_p`
        Note:
            Implemented as function to not collide with
            autogenerated property names.
        """
        return ctypes.c_void_p(int(self))

    def __init__(self,*args,**kwargs):
        """Constructor type hipExternalMemoryMipmappedArrayDesc_st.

        Constructor for type hipExternalMemoryMipmappedArrayDesc_st.

        Args:
            *args:
                Positional arguments. Initialize all or a subset of the member variables
                according to their order of declaration.
            **kwargs:
                Can be used to initialize member variables at construction,
                Just pass an argument expression of the form <member>=<value>
                per member that you want to initialize.
        """
        hipExternalMemoryMipmappedArrayDesc_st.__allocate(&self._ptr)
        self._is_ptr_owner = True
        attribs = self.PROPERTIES()
        used_attribs = set()
        if len(args) > len(attribs):
            raise ValueError("More positional arguments specified than this type has properties.")
        for i,v in enumerate(args):
            setattr(self,attribs[i],v)
            used_attribs.add(attribs[i])
        valid_names = ", ".join(["'"+p+"'" for p in attribs])
        for k,v in kwargs.items():
            if k in used_attribs:
                raise KeyError(f"argument '{k}' has already been specified as positional argument.")
            elif k not in attribs:
                raise KeyError(f"'{k}' is no valid property name. Valid names: {valid_names}")
            setattr(self,k,v)
    def get_offset(self, i):
        """Get value ``offset`` of ``(<chip.hipExternalMemoryMipmappedArrayDesc_st*>self._ptr)[i]``.
        """
        return (<chip.hipExternalMemoryMipmappedArrayDesc_st*>self._ptr)[i].offset
    def set_offset(self, i, unsigned long long value):
        """Set value ``offset`` of ``(<chip.hipExternalMemoryMipmappedArrayDesc_st*>self._ptr)[i]``.
        """
        (<chip.hipExternalMemoryMipmappedArrayDesc_st*>self._ptr)[i].offset = value
    @property
    def offset(self):
        """(undocumented)"""
        return self.get_offset(0)
    @offset.setter
    def offset(self, unsigned long long value):
        self.set_offset(0,value)

    def get_formatDesc(self, i):
        """Get value of ``formatDesc`` of ``(<chip.hipExternalMemoryMipmappedArrayDesc_st*>self._ptr)[i]``.
        """
        return hipChannelFormatDesc.fromPtr(&(<chip.hipExternalMemoryMipmappedArrayDesc_st*>self._ptr)[i].formatDesc)
    @property
    def formatDesc(self):
        """(undocumented)"""
        return self.get_formatDesc(0)

    def get_extent(self, i):
        """Get value of ``extent`` of ``(<chip.hipExternalMemoryMipmappedArrayDesc_st*>self._ptr)[i]``.
        """
        return hipExtent.fromPtr(&(<chip.hipExternalMemoryMipmappedArrayDesc_st*>self._ptr)[i].extent)
    @property
    def extent(self):
        """(undocumented)"""
        return self.get_extent(0)

    def get_flags(self, i):
        """Get value ``flags`` of ``(<chip.hipExternalMemoryMipmappedArrayDesc_st*>self._ptr)[i]``.
        """
        return (<chip.hipExternalMemoryMipmappedArrayDesc_st*>self._ptr)[i].flags
    def set_flags(self, i, unsigned int value):
        """Set value ``flags`` of ``(<chip.hipExternalMemoryMipmappedArrayDesc_st*>self._ptr)[i]``.
        """
        (<chip.hipExternalMemoryMipmappedArrayDesc_st*>self._ptr)[i].flags = value
    @property
    def flags(self):
        """(undocumented)"""
        return self.get_flags(0)
    @flags.setter
    def flags(self, unsigned int value):
        self.set_flags(0,value)

    def get_numLevels(self, i):
        """Get value ``numLevels`` of ``(<chip.hipExternalMemoryMipmappedArrayDesc_st*>self._ptr)[i]``.
        """
        return (<chip.hipExternalMemoryMipmappedArrayDesc_st*>self._ptr)[i].numLevels
    def set_numLevels(self, i, unsigned int value):
        """Set value ``numLevels`` of ``(<chip.hipExternalMemoryMipmappedArrayDesc_st*>self._ptr)[i]``.
        """
        (<chip.hipExternalMemoryMipmappedArrayDesc_st*>self._ptr)[i].numLevels = value
    @property
    def numLevels(self):
        """(undocumented)"""
        return self.get_numLevels(0)
    @numLevels.setter
    def numLevels(self, unsigned int value):
        self.set_numLevels(0,value)

    @staticmethod
    def PROPERTIES():
        return ["offset","formatDesc","extent","flags","numLevels"]

    def __contains__(self,item):
        properties = self.PROPERTIES()
        return item in properties

    def __getitem__(self,item):
        properties = self.PROPERTIES()
        if isinstance(item,int):
            if item < 0 or item >= len(properties):
                raise IndexError()
            return getattr(self,properties[item])
        raise ValueError("'item' type must be 'int'")


hipExternalMemoryMipmappedArrayDesc = hipExternalMemoryMipmappedArrayDesc_st

class _hipExternalSemaphoreHandleType_enum__Base(enum.IntEnum):
    """Empty enum base class that allows subclassing.
    """
    pass
class hipExternalSemaphoreHandleType_enum(_hipExternalSemaphoreHandleType_enum__Base):
    """hipExternalSemaphoreHandleType_enum

    Attributes:
        hipExternalSemaphoreHandleTypeOpaqueFd:
            (undocumented)
        hipExternalSemaphoreHandleTypeOpaqueWin32:
            (undocumented)
        hipExternalSemaphoreHandleTypeOpaqueWin32Kmt:
            (undocumented)
        hipExternalSemaphoreHandleTypeD3D12Fence:
            (undocumented)
        hipExternalSemaphoreHandleTypeD3D11Fence:
            (undocumented)
        hipExternalSemaphoreHandleTypeNvSciSync:
            (undocumented)
        hipExternalSemaphoreHandleTypeKeyedMutex:
            (undocumented)
        hipExternalSemaphoreHandleTypeKeyedMutexKmt:
            (undocumented)
        hipExternalSemaphoreHandleTypeTimelineSemaphoreFd:
            (undocumented)
        hipExternalSemaphoreHandleTypeTimelineSemaphoreWin32:
            (undocumented)
    """
    hipExternalSemaphoreHandleTypeOpaqueFd = chip.hipExternalSemaphoreHandleTypeOpaqueFd
    hipExternalSemaphoreHandleTypeOpaqueWin32 = chip.hipExternalSemaphoreHandleTypeOpaqueWin32
    hipExternalSemaphoreHandleTypeOpaqueWin32Kmt = chip.hipExternalSemaphoreHandleTypeOpaqueWin32Kmt
    hipExternalSemaphoreHandleTypeD3D12Fence = chip.hipExternalSemaphoreHandleTypeD3D12Fence
    hipExternalSemaphoreHandleTypeD3D11Fence = chip.hipExternalSemaphoreHandleTypeD3D11Fence
    hipExternalSemaphoreHandleTypeNvSciSync = chip.hipExternalSemaphoreHandleTypeNvSciSync
    hipExternalSemaphoreHandleTypeKeyedMutex = chip.hipExternalSemaphoreHandleTypeKeyedMutex
    hipExternalSemaphoreHandleTypeKeyedMutexKmt = chip.hipExternalSemaphoreHandleTypeKeyedMutexKmt
    hipExternalSemaphoreHandleTypeTimelineSemaphoreFd = chip.hipExternalSemaphoreHandleTypeTimelineSemaphoreFd
    hipExternalSemaphoreHandleTypeTimelineSemaphoreWin32 = chip.hipExternalSemaphoreHandleTypeTimelineSemaphoreWin32
    @staticmethod
    def ctypes_type():
        """The type of the enum constants as ctypes type."""
        return ctypes.c_uint


hipExternalSemaphoreHandleType = hipExternalSemaphoreHandleType_enum

cdef class hipExternalSemaphoreHandleDesc_st_union_0_struct_0(hip._util.types.Pointer):
    """Python wrapper for cdef class chip.hipExternalSemaphoreHandleDesc_st_union_0_struct_0.

    Python wrapper for cdef class chip.hipExternalSemaphoreHandleDesc_st_union_0_struct_0.

    If this type is initialized via its `__init__` method, it allocates a
    member of the underlying C type and destroys it again if the wrapper
    type is deallocated.

    This type also serves as adapter when appearing as argument type in a
    function signature. In this case, the type can further be initialized
    from a number of Python objects:

    * `None`:

      This will set the ``self._ptr`` attribute to ``NULL``.

    * `int`:

      Interprets the integer value as pointer address and writes it to ``self._ptr``.
      No ownership is transferred.

    * `ctypes.c_void_p`:

      Takes the pointer address ``pyobj.value`` and writes it to ``self._ptr``.
      No ownership is transferred.

    * `object` that implements the `CUDA Array Interface <https://numba.readthedocs.io/en/stable/cuda/cuda_array_interface.html>`_ protocol:

      Takes the integer-valued pointer address, i.e. the first entry of the `data` tuple
      from `pyobj`'s member ``__cuda_array_interface__``  and writes it to ``self._ptr``.

    * `object` that implements the Python buffer protocol:

      If the object represents a simple contiguous array,
      writes the `Py_buffer` associated with ``pyobj`` to `self._py_buffer`,
      sets the `self._py_buffer_acquired` flag to `True`, and
      writes `self._py_buffer.buf` to the data pointer `self._ptr`.

    * `hip._util.types.Pointer`:

      Takes the pointer address ``pyobj._ptr`` and writes it to ``self._ptr``.
      No ownership is transferred.

    Type checks are performed in the above order.

    C Attributes:
        _ptr (C type ``void *``, protected):
            Stores a pointer to the data of the original Python object.
        _is_ptr_owner (C type ``bint``, protected):
            If this wrapper is the owner of the underlying data.
        _py_buffer (C type ``Py_buffer`, protected):
            Stores a pointer to the data of the original Python object.
        _py_buffer_acquired (C type ``bint``, protected):
            Stores a pointer to the data of the original Python object.
    """
    # C members declared in pxd file

    def __cinit__(self):
        self._ptr = NULL
        self._is_ptr_owner = False
        self._py_buffer_acquired = False

    cdef chip.hipExternalSemaphoreHandleDesc_st_union_0_struct_0* getElementPtr(self):
        return <chip.hipExternalSemaphoreHandleDesc_st_union_0_struct_0*>self._ptr

    @staticmethod
    cdef hipExternalSemaphoreHandleDesc_st_union_0_struct_0 fromPtr(void* ptr, bint owner=False):
        """Factory function to create ``hipExternalSemaphoreHandleDesc_st_union_0_struct_0`` objects from
        given ``chip.hipExternalSemaphoreHandleDesc_st_union_0_struct_0`` pointer.

        Setting ``owner`` flag to ``True`` causes
        the extension type to free the structure pointed to by ``ptr``
        when the wrapper object is deallocated.
        """
        # Fast call to __new__() that bypasses the __init__() constructor.
        cdef hipExternalSemaphoreHandleDesc_st_union_0_struct_0 wrapper = hipExternalSemaphoreHandleDesc_st_union_0_struct_0.__new__(hipExternalSemaphoreHandleDesc_st_union_0_struct_0)
        wrapper._ptr = ptr
        wrapper._is_ptr_owner = owner
        return wrapper

    @staticmethod
    def fromObj(pyobj):
        """Creates a hipExternalSemaphoreHandleDesc_st_union_0_struct_0 from a Python object.

        Derives a hipExternalSemaphoreHandleDesc_st_union_0_struct_0 from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``hipExternalSemaphoreHandleDesc_st_union_0_struct_0`` reference, this method
        returns it directly. No new ``hipExternalSemaphoreHandleDesc_st_union_0_struct_0`` is created in this case.
        """
        return hipExternalSemaphoreHandleDesc_st_union_0_struct_0.fromPyobj(pyobj)

    @staticmethod
    cdef hipExternalSemaphoreHandleDesc_st_union_0_struct_0 fromPyobj(object pyobj):
        """Creates a hipExternalSemaphoreHandleDesc_st_union_0_struct_0 from a Python object.

        Derives a hipExternalSemaphoreHandleDesc_st_union_0_struct_0 from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``hipExternalSemaphoreHandleDesc_st_union_0_struct_0`` reference, this method
        returns it directly. No new ``hipExternalSemaphoreHandleDesc_st_union_0_struct_0`` is created in this case.

        Args:
            pyobj (object): Must be either `None`; a `hip._util.types.Pointer`; a simple, contiguous buffer according to the buffer protocol;
                            or of type `hipExternalSemaphoreHandleDesc_st_union_0_struct_0`; `int`; or `ctypes.c_void_p`.

        Note:
            This routine does not perform a copy but returns the original ``pyobj``
            if ``pyobj`` is an instance of hipExternalSemaphoreHandleDesc_st_union_0_struct_0!
        """
        cdef hipExternalSemaphoreHandleDesc_st_union_0_struct_0 wrapper

        if isinstance(pyobj,hipExternalSemaphoreHandleDesc_st_union_0_struct_0):
            return pyobj
        else:
            wrapper = hipExternalSemaphoreHandleDesc_st_union_0_struct_0.__new__(hipExternalSemaphoreHandleDesc_st_union_0_struct_0)
            wrapper.init_from_pyobj(pyobj)
            return wrapper

    def __dealloc__(self):
        # Release the buffer handle
        if self._py_buffer_acquired is True:
            cpython.buffer.PyBuffer_Release(&self._py_buffer)
        # De-allocate if not null and flag is set
        if self._ptr is not NULL and self._is_ptr_owner is True:
            stdlib.free(self._ptr)
            self._ptr = NULL

    @staticmethod
    cdef __allocate(void** ptr):
        ptr[0] = stdlib.malloc(sizeof(chip.hipExternalSemaphoreHandleDesc_st_union_0_struct_0))
        string.memset(<void*>ptr[0], 0, sizeof(chip.hipExternalSemaphoreHandleDesc_st_union_0_struct_0))

        if ptr[0] is NULL:
            raise MemoryError

    @staticmethod
    cdef hipExternalSemaphoreHandleDesc_st_union_0_struct_0 new():
        """Factory function to create hipExternalSemaphoreHandleDesc_st_union_0_struct_0 objects with
        newly allocated chip.hipExternalSemaphoreHandleDesc_st_union_0_struct_0"""
        cdef void* ptr
        hipExternalSemaphoreHandleDesc_st_union_0_struct_0.__allocate(&ptr)
        return hipExternalSemaphoreHandleDesc_st_union_0_struct_0.fromPtr(ptr, owner=True)

    @staticmethod
    cdef hipExternalSemaphoreHandleDesc_st_union_0_struct_0 fromValue(chip.hipExternalSemaphoreHandleDesc_st_union_0_struct_0 other):
        """Allocate new C type and copy from ``other``.
        """
        wrapper = hipExternalSemaphoreHandleDesc_st_union_0_struct_0.new()
        string.memcpy(wrapper._ptr, &other, sizeof(chip.hipExternalSemaphoreHandleDesc_st_union_0_struct_0))
        return wrapper

    def c_sizeof(self):
        """Returns the size of the underlying C type in bytes.
        Note:
            Implemented as function to not collide with
            autogenerated property names.
        """
        return sizeof(chip.hipExternalSemaphoreHandleDesc_st_union_0_struct_0)

    def __int__(self):
        """Returns the data's address as long integer.
        """
        return cpython.long.PyLong_FromVoidPtr(self._ptr)

    def __repr__(self):
        return f"<hipExternalSemaphoreHandleDesc_st_union_0_struct_0 object, ptr: {int(self)}>"

    def as_c_void_p(self):
        """Returns the data's address as `ctypes.c_void_p`
        Note:
            Implemented as function to not collide with
            autogenerated property names.
        """
        return ctypes.c_void_p(int(self))

    def __init__(self,*args,**kwargs):
        """Constructor type hipExternalSemaphoreHandleDesc_st_union_0_struct_0.

        Constructor for type hipExternalSemaphoreHandleDesc_st_union_0_struct_0.

        Args:
            *args:
                Positional arguments. Initialize all or a subset of the member variables
                according to their order of declaration.
            **kwargs:
                Can be used to initialize member variables at construction,
                Just pass an argument expression of the form <member>=<value>
                per member that you want to initialize.
        """
        hipExternalSemaphoreHandleDesc_st_union_0_struct_0.__allocate(&self._ptr)
        self._is_ptr_owner = True
        attribs = self.PROPERTIES()
        used_attribs = set()
        if len(args) > len(attribs):
            raise ValueError("More positional arguments specified than this type has properties.")
        for i,v in enumerate(args):
            setattr(self,attribs[i],v)
            used_attribs.add(attribs[i])
        valid_names = ", ".join(["'"+p+"'" for p in attribs])
        for k,v in kwargs.items():
            if k in used_attribs:
                raise KeyError(f"argument '{k}' has already been specified as positional argument.")
            elif k not in attribs:
                raise KeyError(f"'{k}' is no valid property name. Valid names: {valid_names}")
            setattr(self,k,v)
    def get_handle(self, i):
        """Get value ``handle`` of ``(<chip.hipExternalSemaphoreHandleDesc_st_union_0_struct_0*>self._ptr)[i]``.
        """
        return hip._util.types.Pointer.fromPtr((<chip.hipExternalSemaphoreHandleDesc_st_union_0_struct_0*>self._ptr)[i].handle)
    def set_handle(self, i, object value):
        """Set value ``handle`` of ``(<chip.hipExternalSemaphoreHandleDesc_st_union_0_struct_0*>self._ptr)[i]``.

        Note:
            This can be dangerous if the pointer is from a python object
            that is later on garbage collected.
        """
        (<chip.hipExternalSemaphoreHandleDesc_st_union_0_struct_0*>self._ptr)[i].handle = <void *>cpython.long.PyLong_AsVoidPtr(int(hip._util.types.Pointer.fromPyobj(value)))
    @property
    def handle(self):
        """(undocumented)
        Note:
            Setting this handle can be dangerous if the underlying pointer is from a python object that
            is later on garbage collected.
        """
        return self.get_handle(0)
    @handle.setter
    def handle(self, object value):
        self.set_handle(0,value)

    def get_name(self, i):
        """Get value ``name`` of ``(<chip.hipExternalSemaphoreHandleDesc_st_union_0_struct_0*>self._ptr)[i]``.
        """
        return hip._util.types.Pointer.fromPtr((<chip.hipExternalSemaphoreHandleDesc_st_union_0_struct_0*>self._ptr)[i].name)
    def set_name(self, i, object value):
        """Set value ``name`` of ``(<chip.hipExternalSemaphoreHandleDesc_st_union_0_struct_0*>self._ptr)[i]``.

        Note:
            This can be dangerous if the pointer is from a python object
            that is later on garbage collected.
        """
        (<chip.hipExternalSemaphoreHandleDesc_st_union_0_struct_0*>self._ptr)[i].name = <const void *>cpython.long.PyLong_AsVoidPtr(int(hip._util.types.Pointer.fromPyobj(value)))
    @property
    def name(self):
        """(undocumented)
        Note:
            Setting this name can be dangerous if the underlying pointer is from a python object that
            is later on garbage collected.
        """
        return self.get_name(0)
    @name.setter
    def name(self, object value):
        self.set_name(0,value)

    @staticmethod
    def PROPERTIES():
        return ["handle","name"]

    def __contains__(self,item):
        properties = self.PROPERTIES()
        return item in properties

    def __getitem__(self,item):
        properties = self.PROPERTIES()
        if isinstance(item,int):
            if item < 0 or item >= len(properties):
                raise IndexError()
            return getattr(self,properties[item])
        raise ValueError("'item' type must be 'int'")


cdef class hipExternalSemaphoreHandleDesc_st_union_0(hip._util.types.Pointer):
    """Python wrapper for cdef class chip.hipExternalSemaphoreHandleDesc_st_union_0.

    Python wrapper for cdef class chip.hipExternalSemaphoreHandleDesc_st_union_0.

    If this type is initialized via its `__init__` method, it allocates a
    member of the underlying C type and destroys it again if the wrapper
    type is deallocated.

    This type also serves as adapter when appearing as argument type in a
    function signature. In this case, the type can further be initialized
    from a number of Python objects:

    * `None`:

      This will set the ``self._ptr`` attribute to ``NULL``.

    * `int`:

      Interprets the integer value as pointer address and writes it to ``self._ptr``.
      No ownership is transferred.

    * `ctypes.c_void_p`:

      Takes the pointer address ``pyobj.value`` and writes it to ``self._ptr``.
      No ownership is transferred.

    * `object` that implements the `CUDA Array Interface <https://numba.readthedocs.io/en/stable/cuda/cuda_array_interface.html>`_ protocol:

      Takes the integer-valued pointer address, i.e. the first entry of the `data` tuple
      from `pyobj`'s member ``__cuda_array_interface__``  and writes it to ``self._ptr``.

    * `object` that implements the Python buffer protocol:

      If the object represents a simple contiguous array,
      writes the `Py_buffer` associated with ``pyobj`` to `self._py_buffer`,
      sets the `self._py_buffer_acquired` flag to `True`, and
      writes `self._py_buffer.buf` to the data pointer `self._ptr`.

    * `hip._util.types.Pointer`:

      Takes the pointer address ``pyobj._ptr`` and writes it to ``self._ptr``.
      No ownership is transferred.

    Type checks are performed in the above order.

    C Attributes:
        _ptr (C type ``void *``, protected):
            Stores a pointer to the data of the original Python object.
        _is_ptr_owner (C type ``bint``, protected):
            If this wrapper is the owner of the underlying data.
        _py_buffer (C type ``Py_buffer`, protected):
            Stores a pointer to the data of the original Python object.
        _py_buffer_acquired (C type ``bint``, protected):
            Stores a pointer to the data of the original Python object.
    """
    # C members declared in pxd file

    def __cinit__(self):
        self._ptr = NULL
        self._is_ptr_owner = False
        self._py_buffer_acquired = False

    cdef chip.hipExternalSemaphoreHandleDesc_st_union_0* getElementPtr(self):
        return <chip.hipExternalSemaphoreHandleDesc_st_union_0*>self._ptr

    @staticmethod
    cdef hipExternalSemaphoreHandleDesc_st_union_0 fromPtr(void* ptr, bint owner=False):
        """Factory function to create ``hipExternalSemaphoreHandleDesc_st_union_0`` objects from
        given ``chip.hipExternalSemaphoreHandleDesc_st_union_0`` pointer.

        Setting ``owner`` flag to ``True`` causes
        the extension type to free the structure pointed to by ``ptr``
        when the wrapper object is deallocated.
        """
        # Fast call to __new__() that bypasses the __init__() constructor.
        cdef hipExternalSemaphoreHandleDesc_st_union_0 wrapper = hipExternalSemaphoreHandleDesc_st_union_0.__new__(hipExternalSemaphoreHandleDesc_st_union_0)
        wrapper._ptr = ptr
        wrapper._is_ptr_owner = owner
        return wrapper

    @staticmethod
    def fromObj(pyobj):
        """Creates a hipExternalSemaphoreHandleDesc_st_union_0 from a Python object.

        Derives a hipExternalSemaphoreHandleDesc_st_union_0 from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``hipExternalSemaphoreHandleDesc_st_union_0`` reference, this method
        returns it directly. No new ``hipExternalSemaphoreHandleDesc_st_union_0`` is created in this case.
        """
        return hipExternalSemaphoreHandleDesc_st_union_0.fromPyobj(pyobj)

    @staticmethod
    cdef hipExternalSemaphoreHandleDesc_st_union_0 fromPyobj(object pyobj):
        """Creates a hipExternalSemaphoreHandleDesc_st_union_0 from a Python object.

        Derives a hipExternalSemaphoreHandleDesc_st_union_0 from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``hipExternalSemaphoreHandleDesc_st_union_0`` reference, this method
        returns it directly. No new ``hipExternalSemaphoreHandleDesc_st_union_0`` is created in this case.

        Args:
            pyobj (object): Must be either `None`; a `hip._util.types.Pointer`; a simple, contiguous buffer according to the buffer protocol;
                            or of type `hipExternalSemaphoreHandleDesc_st_union_0`; `int`; or `ctypes.c_void_p`.

        Note:
            This routine does not perform a copy but returns the original ``pyobj``
            if ``pyobj`` is an instance of hipExternalSemaphoreHandleDesc_st_union_0!
        """
        cdef hipExternalSemaphoreHandleDesc_st_union_0 wrapper

        if isinstance(pyobj,hipExternalSemaphoreHandleDesc_st_union_0):
            return pyobj
        else:
            wrapper = hipExternalSemaphoreHandleDesc_st_union_0.__new__(hipExternalSemaphoreHandleDesc_st_union_0)
            wrapper.init_from_pyobj(pyobj)
            return wrapper

    def __dealloc__(self):
        # Release the buffer handle
        if self._py_buffer_acquired is True:
            cpython.buffer.PyBuffer_Release(&self._py_buffer)
        # De-allocate if not null and flag is set
        if self._ptr is not NULL and self._is_ptr_owner is True:
            stdlib.free(self._ptr)
            self._ptr = NULL

    @staticmethod
    cdef __allocate(void** ptr):
        ptr[0] = stdlib.malloc(sizeof(chip.hipExternalSemaphoreHandleDesc_st_union_0))
        string.memset(<void*>ptr[0], 0, sizeof(chip.hipExternalSemaphoreHandleDesc_st_union_0))

        if ptr[0] is NULL:
            raise MemoryError

    @staticmethod
    cdef hipExternalSemaphoreHandleDesc_st_union_0 new():
        """Factory function to create hipExternalSemaphoreHandleDesc_st_union_0 objects with
        newly allocated chip.hipExternalSemaphoreHandleDesc_st_union_0"""
        cdef void* ptr
        hipExternalSemaphoreHandleDesc_st_union_0.__allocate(&ptr)
        return hipExternalSemaphoreHandleDesc_st_union_0.fromPtr(ptr, owner=True)

    @staticmethod
    cdef hipExternalSemaphoreHandleDesc_st_union_0 fromValue(chip.hipExternalSemaphoreHandleDesc_st_union_0 other):
        """Allocate new C type and copy from ``other``.
        """
        wrapper = hipExternalSemaphoreHandleDesc_st_union_0.new()
        string.memcpy(wrapper._ptr, &other, sizeof(chip.hipExternalSemaphoreHandleDesc_st_union_0))
        return wrapper

    def c_sizeof(self):
        """Returns the size of the underlying C type in bytes.
        Note:
            Implemented as function to not collide with
            autogenerated property names.
        """
        return sizeof(chip.hipExternalSemaphoreHandleDesc_st_union_0)

    def __int__(self):
        """Returns the data's address as long integer.
        """
        return cpython.long.PyLong_FromVoidPtr(self._ptr)

    def __repr__(self):
        return f"<hipExternalSemaphoreHandleDesc_st_union_0 object, ptr: {int(self)}>"

    def as_c_void_p(self):
        """Returns the data's address as `ctypes.c_void_p`
        Note:
            Implemented as function to not collide with
            autogenerated property names.
        """
        return ctypes.c_void_p(int(self))

    def __init__(self,**kwargs):
        """Constructor type hipExternalSemaphoreHandleDesc_st_union_0.

        Constructor for type hipExternalSemaphoreHandleDesc_st_union_0.

        Args:
            **kwargs:
                Can be used to initialize member variables at construction,
                Just pass an argument expression of the form <member>=<value>
                per member that you want to initialize.
        """
        hipExternalSemaphoreHandleDesc_st_union_0.__allocate(&self._ptr)
        self._is_ptr_owner = True
        attribs = self.PROPERTIES()
        used_attribs = set()
        if len(kwargs) > 1:
            raise ValueError("Not more than one attribute might specified for Python types derived from C union types.")
        valid_names = ", ".join(["'"+p+"'" for p in attribs])
        for k,v in kwargs.items():
            if k in used_attribs:
                raise KeyError(f"argument '{k}' has already been specified as positional argument.")
            elif k not in attribs:
                raise KeyError(f"'{k}' is no valid property name. Valid names: {valid_names}")
            setattr(self,k,v)
    def get_fd(self, i):
        """Get value ``fd`` of ``(<chip.hipExternalSemaphoreHandleDesc_st_union_0*>self._ptr)[i]``.
        """
        return (<chip.hipExternalSemaphoreHandleDesc_st_union_0*>self._ptr)[i].fd
    def set_fd(self, i, int value):
        """Set value ``fd`` of ``(<chip.hipExternalSemaphoreHandleDesc_st_union_0*>self._ptr)[i]``.
        """
        (<chip.hipExternalSemaphoreHandleDesc_st_union_0*>self._ptr)[i].fd = value
    @property
    def fd(self):
        """(undocumented)"""
        return self.get_fd(0)
    @fd.setter
    def fd(self, int value):
        self.set_fd(0,value)

    def get_win32(self, i):
        """Get value of ``win32`` of ``(<chip.hipExternalSemaphoreHandleDesc_st_union_0*>self._ptr)[i]``.
        """
        return hipExternalSemaphoreHandleDesc_st_union_0_struct_0.fromPtr(&(<chip.hipExternalSemaphoreHandleDesc_st_union_0*>self._ptr)[i].win32)
    @property
    def win32(self):
        """(undocumented)"""
        return self.get_win32(0)

    def get_NvSciSyncObj(self, i):
        """Get value ``NvSciSyncObj`` of ``(<chip.hipExternalSemaphoreHandleDesc_st_union_0*>self._ptr)[i]``.
        """
        return hip._util.types.Pointer.fromPtr((<chip.hipExternalSemaphoreHandleDesc_st_union_0*>self._ptr)[i].NvSciSyncObj)
    def set_NvSciSyncObj(self, i, object value):
        """Set value ``NvSciSyncObj`` of ``(<chip.hipExternalSemaphoreHandleDesc_st_union_0*>self._ptr)[i]``.

        Note:
            This can be dangerous if the pointer is from a python object
            that is later on garbage collected.
        """
        (<chip.hipExternalSemaphoreHandleDesc_st_union_0*>self._ptr)[i].NvSciSyncObj = <const void *>cpython.long.PyLong_AsVoidPtr(int(hip._util.types.Pointer.fromPyobj(value)))
    @property
    def NvSciSyncObj(self):
        """(undocumented)
        Note:
            Setting this NvSciSyncObj can be dangerous if the underlying pointer is from a python object that
            is later on garbage collected.
        """
        return self.get_NvSciSyncObj(0)
    @NvSciSyncObj.setter
    def NvSciSyncObj(self, object value):
        self.set_NvSciSyncObj(0,value)

    @staticmethod
    def PROPERTIES():
        return ["fd","win32","NvSciSyncObj"]


cdef class hipExternalSemaphoreHandleDesc_st(hip._util.types.Pointer):
    """Python wrapper for cdef class chip.hipExternalSemaphoreHandleDesc_st.

    Python wrapper for cdef class chip.hipExternalSemaphoreHandleDesc_st.

    If this type is initialized via its `__init__` method, it allocates a
    member of the underlying C type and destroys it again if the wrapper
    type is deallocated.

    This type also serves as adapter when appearing as argument type in a
    function signature. In this case, the type can further be initialized
    from a number of Python objects:

    * `None`:

      This will set the ``self._ptr`` attribute to ``NULL``.

    * `int`:

      Interprets the integer value as pointer address and writes it to ``self._ptr``.
      No ownership is transferred.

    * `ctypes.c_void_p`:

      Takes the pointer address ``pyobj.value`` and writes it to ``self._ptr``.
      No ownership is transferred.

    * `object` that implements the `CUDA Array Interface <https://numba.readthedocs.io/en/stable/cuda/cuda_array_interface.html>`_ protocol:

      Takes the integer-valued pointer address, i.e. the first entry of the `data` tuple
      from `pyobj`'s member ``__cuda_array_interface__``  and writes it to ``self._ptr``.

    * `object` that implements the Python buffer protocol:

      If the object represents a simple contiguous array,
      writes the `Py_buffer` associated with ``pyobj`` to `self._py_buffer`,
      sets the `self._py_buffer_acquired` flag to `True`, and
      writes `self._py_buffer.buf` to the data pointer `self._ptr`.

    * `hip._util.types.Pointer`:

      Takes the pointer address ``pyobj._ptr`` and writes it to ``self._ptr``.
      No ownership is transferred.

    Type checks are performed in the above order.

    C Attributes:
        _ptr (C type ``void *``, protected):
            Stores a pointer to the data of the original Python object.
        _is_ptr_owner (C type ``bint``, protected):
            If this wrapper is the owner of the underlying data.
        _py_buffer (C type ``Py_buffer`, protected):
            Stores a pointer to the data of the original Python object.
        _py_buffer_acquired (C type ``bint``, protected):
            Stores a pointer to the data of the original Python object.
    """
    # C members declared in pxd file

    def __cinit__(self):
        self._ptr = NULL
        self._is_ptr_owner = False
        self._py_buffer_acquired = False

    cdef chip.hipExternalSemaphoreHandleDesc_st* getElementPtr(self):
        return <chip.hipExternalSemaphoreHandleDesc_st*>self._ptr

    @staticmethod
    cdef hipExternalSemaphoreHandleDesc_st fromPtr(void* ptr, bint owner=False):
        """Factory function to create ``hipExternalSemaphoreHandleDesc_st`` objects from
        given ``chip.hipExternalSemaphoreHandleDesc_st`` pointer.

        Setting ``owner`` flag to ``True`` causes
        the extension type to free the structure pointed to by ``ptr``
        when the wrapper object is deallocated.
        """
        # Fast call to __new__() that bypasses the __init__() constructor.
        cdef hipExternalSemaphoreHandleDesc_st wrapper = hipExternalSemaphoreHandleDesc_st.__new__(hipExternalSemaphoreHandleDesc_st)
        wrapper._ptr = ptr
        wrapper._is_ptr_owner = owner
        return wrapper

    @staticmethod
    def fromObj(pyobj):
        """Creates a hipExternalSemaphoreHandleDesc_st from a Python object.

        Derives a hipExternalSemaphoreHandleDesc_st from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``hipExternalSemaphoreHandleDesc_st`` reference, this method
        returns it directly. No new ``hipExternalSemaphoreHandleDesc_st`` is created in this case.
        """
        return hipExternalSemaphoreHandleDesc_st.fromPyobj(pyobj)

    @staticmethod
    cdef hipExternalSemaphoreHandleDesc_st fromPyobj(object pyobj):
        """Creates a hipExternalSemaphoreHandleDesc_st from a Python object.

        Derives a hipExternalSemaphoreHandleDesc_st from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``hipExternalSemaphoreHandleDesc_st`` reference, this method
        returns it directly. No new ``hipExternalSemaphoreHandleDesc_st`` is created in this case.

        Args:
            pyobj (object): Must be either `None`; a `hip._util.types.Pointer`; a simple, contiguous buffer according to the buffer protocol;
                            or of type `hipExternalSemaphoreHandleDesc_st`; `int`; or `ctypes.c_void_p`.

        Note:
            This routine does not perform a copy but returns the original ``pyobj``
            if ``pyobj`` is an instance of hipExternalSemaphoreHandleDesc_st!
        """
        cdef hipExternalSemaphoreHandleDesc_st wrapper

        if isinstance(pyobj,hipExternalSemaphoreHandleDesc_st):
            return pyobj
        else:
            wrapper = hipExternalSemaphoreHandleDesc_st.__new__(hipExternalSemaphoreHandleDesc_st)
            wrapper.init_from_pyobj(pyobj)
            return wrapper

    def __dealloc__(self):
        # Release the buffer handle
        if self._py_buffer_acquired is True:
            cpython.buffer.PyBuffer_Release(&self._py_buffer)
        # De-allocate if not null and flag is set
        if self._ptr is not NULL and self._is_ptr_owner is True:
            stdlib.free(self._ptr)
            self._ptr = NULL

    @staticmethod
    cdef __allocate(void** ptr):
        ptr[0] = stdlib.malloc(sizeof(chip.hipExternalSemaphoreHandleDesc_st))
        string.memset(<void*>ptr[0], 0, sizeof(chip.hipExternalSemaphoreHandleDesc_st))

        if ptr[0] is NULL:
            raise MemoryError

    @staticmethod
    cdef hipExternalSemaphoreHandleDesc_st new():
        """Factory function to create hipExternalSemaphoreHandleDesc_st objects with
        newly allocated chip.hipExternalSemaphoreHandleDesc_st"""
        cdef void* ptr
        hipExternalSemaphoreHandleDesc_st.__allocate(&ptr)
        return hipExternalSemaphoreHandleDesc_st.fromPtr(ptr, owner=True)

    @staticmethod
    cdef hipExternalSemaphoreHandleDesc_st fromValue(chip.hipExternalSemaphoreHandleDesc_st other):
        """Allocate new C type and copy from ``other``.
        """
        wrapper = hipExternalSemaphoreHandleDesc_st.new()
        string.memcpy(wrapper._ptr, &other, sizeof(chip.hipExternalSemaphoreHandleDesc_st))
        return wrapper

    def c_sizeof(self):
        """Returns the size of the underlying C type in bytes.
        Note:
            Implemented as function to not collide with
            autogenerated property names.
        """
        return sizeof(chip.hipExternalSemaphoreHandleDesc_st)

    def __int__(self):
        """Returns the data's address as long integer.
        """
        return cpython.long.PyLong_FromVoidPtr(self._ptr)

    def __repr__(self):
        return f"<hipExternalSemaphoreHandleDesc_st object, ptr: {int(self)}>"

    def as_c_void_p(self):
        """Returns the data's address as `ctypes.c_void_p`
        Note:
            Implemented as function to not collide with
            autogenerated property names.
        """
        return ctypes.c_void_p(int(self))

    def __init__(self,*args,**kwargs):
        """Constructor type hipExternalSemaphoreHandleDesc_st.

        Constructor for type hipExternalSemaphoreHandleDesc_st.

        Args:
            *args:
                Positional arguments. Initialize all or a subset of the member variables
                according to their order of declaration.
            **kwargs:
                Can be used to initialize member variables at construction,
                Just pass an argument expression of the form <member>=<value>
                per member that you want to initialize.
        """
        hipExternalSemaphoreHandleDesc_st.__allocate(&self._ptr)
        self._is_ptr_owner = True
        attribs = self.PROPERTIES()
        used_attribs = set()
        if len(args) > len(attribs):
            raise ValueError("More positional arguments specified than this type has properties.")
        for i,v in enumerate(args):
            setattr(self,attribs[i],v)
            used_attribs.add(attribs[i])
        valid_names = ", ".join(["'"+p+"'" for p in attribs])
        for k,v in kwargs.items():
            if k in used_attribs:
                raise KeyError(f"argument '{k}' has already been specified as positional argument.")
            elif k not in attribs:
                raise KeyError(f"'{k}' is no valid property name. Valid names: {valid_names}")
            setattr(self,k,v)
    def get_type(self, i):
        """Get value of ``type`` of ``(<chip.hipExternalSemaphoreHandleDesc_st*>self._ptr)[i]``.
        """
        return hipExternalSemaphoreHandleType_enum((<chip.hipExternalSemaphoreHandleDesc_st*>self._ptr)[i].type)
    def set_type(self, i, value):
        """Set value ``type`` of ``(<chip.hipExternalSemaphoreHandleDesc_st*>self._ptr)[i]``.
        """
        if not isinstance(value, hipExternalSemaphoreHandleType_enum):
            raise TypeError("'value' must be of type 'hipExternalSemaphoreHandleType_enum'")
        (<chip.hipExternalSemaphoreHandleDesc_st*>self._ptr)[i].type = value.value
    @property
    def type(self):
        """(undocumented)"""
        return self.get_type(0)
    @type.setter
    def type(self, value):
        self.set_type(0,value)

    def get_handle(self, i):
        """Get value of ``handle`` of ``(<chip.hipExternalSemaphoreHandleDesc_st*>self._ptr)[i]``.
        """
        return hipExternalSemaphoreHandleDesc_st_union_0.fromPtr(&(<chip.hipExternalSemaphoreHandleDesc_st*>self._ptr)[i].handle)
    @property
    def handle(self):
        """(undocumented)"""
        return self.get_handle(0)

    def get_flags(self, i):
        """Get value ``flags`` of ``(<chip.hipExternalSemaphoreHandleDesc_st*>self._ptr)[i]``.
        """
        return (<chip.hipExternalSemaphoreHandleDesc_st*>self._ptr)[i].flags
    def set_flags(self, i, unsigned int value):
        """Set value ``flags`` of ``(<chip.hipExternalSemaphoreHandleDesc_st*>self._ptr)[i]``.
        """
        (<chip.hipExternalSemaphoreHandleDesc_st*>self._ptr)[i].flags = value
    @property
    def flags(self):
        """(undocumented)"""
        return self.get_flags(0)
    @flags.setter
    def flags(self, unsigned int value):
        self.set_flags(0,value)

    def get_reserved(self, i):
        """Get value of ``reserved`` of ``(<chip.hipExternalSemaphoreHandleDesc_st*>self._ptr)[i]``.
        """
        return (<chip.hipExternalSemaphoreHandleDesc_st*>self._ptr)[i].reserved
    # TODO add setters
    #def set_reserved(self, i, unsigned int[16] value):
    #    """Set value ``reserved`` of ``(<chip.hipExternalSemaphoreHandleDesc_st*>self._ptr)[i]``.
    #    """
    #    (<chip.hipExternalSemaphoreHandleDesc_st*>self._ptr)[i].reserved = value
    @property
    def reserved(self):
        """(undocumented)"""
        return self.get_reserved(0)
    # TODO add setters
    #@reserved.setter
    #def reserved(self, unsigned int[16] value):
    #    self.set_reserved(0,value)

    @staticmethod
    def PROPERTIES():
        return ["type","handle","flags","reserved"]

    def __contains__(self,item):
        properties = self.PROPERTIES()
        return item in properties

    def __getitem__(self,item):
        properties = self.PROPERTIES()
        if isinstance(item,int):
            if item < 0 or item >= len(properties):
                raise IndexError()
            return getattr(self,properties[item])
        raise ValueError("'item' type must be 'int'")


hipExternalSemaphoreHandleDesc = hipExternalSemaphoreHandleDesc_st

cdef class hipExternalSemaphoreSignalParams_st_struct_0_struct_0(hip._util.types.Pointer):
    """Python wrapper for cdef class chip.hipExternalSemaphoreSignalParams_st_struct_0_struct_0.

    Python wrapper for cdef class chip.hipExternalSemaphoreSignalParams_st_struct_0_struct_0.

    If this type is initialized via its `__init__` method, it allocates a
    member of the underlying C type and destroys it again if the wrapper
    type is deallocated.

    This type also serves as adapter when appearing as argument type in a
    function signature. In this case, the type can further be initialized
    from a number of Python objects:

    * `None`:

      This will set the ``self._ptr`` attribute to ``NULL``.

    * `int`:

      Interprets the integer value as pointer address and writes it to ``self._ptr``.
      No ownership is transferred.

    * `ctypes.c_void_p`:

      Takes the pointer address ``pyobj.value`` and writes it to ``self._ptr``.
      No ownership is transferred.

    * `object` that implements the `CUDA Array Interface <https://numba.readthedocs.io/en/stable/cuda/cuda_array_interface.html>`_ protocol:

      Takes the integer-valued pointer address, i.e. the first entry of the `data` tuple
      from `pyobj`'s member ``__cuda_array_interface__``  and writes it to ``self._ptr``.

    * `object` that implements the Python buffer protocol:

      If the object represents a simple contiguous array,
      writes the `Py_buffer` associated with ``pyobj`` to `self._py_buffer`,
      sets the `self._py_buffer_acquired` flag to `True`, and
      writes `self._py_buffer.buf` to the data pointer `self._ptr`.

    * `hip._util.types.Pointer`:

      Takes the pointer address ``pyobj._ptr`` and writes it to ``self._ptr``.
      No ownership is transferred.

    Type checks are performed in the above order.

    C Attributes:
        _ptr (C type ``void *``, protected):
            Stores a pointer to the data of the original Python object.
        _is_ptr_owner (C type ``bint``, protected):
            If this wrapper is the owner of the underlying data.
        _py_buffer (C type ``Py_buffer`, protected):
            Stores a pointer to the data of the original Python object.
        _py_buffer_acquired (C type ``bint``, protected):
            Stores a pointer to the data of the original Python object.
    """
    # C members declared in pxd file

    def __cinit__(self):
        self._ptr = NULL
        self._is_ptr_owner = False
        self._py_buffer_acquired = False

    cdef chip.hipExternalSemaphoreSignalParams_st_struct_0_struct_0* getElementPtr(self):
        return <chip.hipExternalSemaphoreSignalParams_st_struct_0_struct_0*>self._ptr

    @staticmethod
    cdef hipExternalSemaphoreSignalParams_st_struct_0_struct_0 fromPtr(void* ptr, bint owner=False):
        """Factory function to create ``hipExternalSemaphoreSignalParams_st_struct_0_struct_0`` objects from
        given ``chip.hipExternalSemaphoreSignalParams_st_struct_0_struct_0`` pointer.

        Setting ``owner`` flag to ``True`` causes
        the extension type to free the structure pointed to by ``ptr``
        when the wrapper object is deallocated.
        """
        # Fast call to __new__() that bypasses the __init__() constructor.
        cdef hipExternalSemaphoreSignalParams_st_struct_0_struct_0 wrapper = hipExternalSemaphoreSignalParams_st_struct_0_struct_0.__new__(hipExternalSemaphoreSignalParams_st_struct_0_struct_0)
        wrapper._ptr = ptr
        wrapper._is_ptr_owner = owner
        return wrapper

    @staticmethod
    def fromObj(pyobj):
        """Creates a hipExternalSemaphoreSignalParams_st_struct_0_struct_0 from a Python object.

        Derives a hipExternalSemaphoreSignalParams_st_struct_0_struct_0 from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``hipExternalSemaphoreSignalParams_st_struct_0_struct_0`` reference, this method
        returns it directly. No new ``hipExternalSemaphoreSignalParams_st_struct_0_struct_0`` is created in this case.
        """
        return hipExternalSemaphoreSignalParams_st_struct_0_struct_0.fromPyobj(pyobj)

    @staticmethod
    cdef hipExternalSemaphoreSignalParams_st_struct_0_struct_0 fromPyobj(object pyobj):
        """Creates a hipExternalSemaphoreSignalParams_st_struct_0_struct_0 from a Python object.

        Derives a hipExternalSemaphoreSignalParams_st_struct_0_struct_0 from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``hipExternalSemaphoreSignalParams_st_struct_0_struct_0`` reference, this method
        returns it directly. No new ``hipExternalSemaphoreSignalParams_st_struct_0_struct_0`` is created in this case.

        Args:
            pyobj (object): Must be either `None`; a `hip._util.types.Pointer`; a simple, contiguous buffer according to the buffer protocol;
                            or of type `hipExternalSemaphoreSignalParams_st_struct_0_struct_0`; `int`; or `ctypes.c_void_p`.

        Note:
            This routine does not perform a copy but returns the original ``pyobj``
            if ``pyobj`` is an instance of hipExternalSemaphoreSignalParams_st_struct_0_struct_0!
        """
        cdef hipExternalSemaphoreSignalParams_st_struct_0_struct_0 wrapper

        if isinstance(pyobj,hipExternalSemaphoreSignalParams_st_struct_0_struct_0):
            return pyobj
        else:
            wrapper = hipExternalSemaphoreSignalParams_st_struct_0_struct_0.__new__(hipExternalSemaphoreSignalParams_st_struct_0_struct_0)
            wrapper.init_from_pyobj(pyobj)
            return wrapper

    def __dealloc__(self):
        # Release the buffer handle
        if self._py_buffer_acquired is True:
            cpython.buffer.PyBuffer_Release(&self._py_buffer)
        # De-allocate if not null and flag is set
        if self._ptr is not NULL and self._is_ptr_owner is True:
            stdlib.free(self._ptr)
            self._ptr = NULL

    @staticmethod
    cdef __allocate(void** ptr):
        ptr[0] = stdlib.malloc(sizeof(chip.hipExternalSemaphoreSignalParams_st_struct_0_struct_0))
        string.memset(<void*>ptr[0], 0, sizeof(chip.hipExternalSemaphoreSignalParams_st_struct_0_struct_0))

        if ptr[0] is NULL:
            raise MemoryError

    @staticmethod
    cdef hipExternalSemaphoreSignalParams_st_struct_0_struct_0 new():
        """Factory function to create hipExternalSemaphoreSignalParams_st_struct_0_struct_0 objects with
        newly allocated chip.hipExternalSemaphoreSignalParams_st_struct_0_struct_0"""
        cdef void* ptr
        hipExternalSemaphoreSignalParams_st_struct_0_struct_0.__allocate(&ptr)
        return hipExternalSemaphoreSignalParams_st_struct_0_struct_0.fromPtr(ptr, owner=True)

    @staticmethod
    cdef hipExternalSemaphoreSignalParams_st_struct_0_struct_0 fromValue(chip.hipExternalSemaphoreSignalParams_st_struct_0_struct_0 other):
        """Allocate new C type and copy from ``other``.
        """
        wrapper = hipExternalSemaphoreSignalParams_st_struct_0_struct_0.new()
        string.memcpy(wrapper._ptr, &other, sizeof(chip.hipExternalSemaphoreSignalParams_st_struct_0_struct_0))
        return wrapper

    def c_sizeof(self):
        """Returns the size of the underlying C type in bytes.
        Note:
            Implemented as function to not collide with
            autogenerated property names.
        """
        return sizeof(chip.hipExternalSemaphoreSignalParams_st_struct_0_struct_0)

    def __int__(self):
        """Returns the data's address as long integer.
        """
        return cpython.long.PyLong_FromVoidPtr(self._ptr)

    def __repr__(self):
        return f"<hipExternalSemaphoreSignalParams_st_struct_0_struct_0 object, ptr: {int(self)}>"

    def as_c_void_p(self):
        """Returns the data's address as `ctypes.c_void_p`
        Note:
            Implemented as function to not collide with
            autogenerated property names.
        """
        return ctypes.c_void_p(int(self))

    def __init__(self,*args,**kwargs):
        """Constructor type hipExternalSemaphoreSignalParams_st_struct_0_struct_0.

        Constructor for type hipExternalSemaphoreSignalParams_st_struct_0_struct_0.

        Args:
            *args:
                Positional arguments. Initialize all or a subset of the member variables
                according to their order of declaration.
            **kwargs:
                Can be used to initialize member variables at construction,
                Just pass an argument expression of the form <member>=<value>
                per member that you want to initialize.
        """
        hipExternalSemaphoreSignalParams_st_struct_0_struct_0.__allocate(&self._ptr)
        self._is_ptr_owner = True
        attribs = self.PROPERTIES()
        used_attribs = set()
        if len(args) > len(attribs):
            raise ValueError("More positional arguments specified than this type has properties.")
        for i,v in enumerate(args):
            setattr(self,attribs[i],v)
            used_attribs.add(attribs[i])
        valid_names = ", ".join(["'"+p+"'" for p in attribs])
        for k,v in kwargs.items():
            if k in used_attribs:
                raise KeyError(f"argument '{k}' has already been specified as positional argument.")
            elif k not in attribs:
                raise KeyError(f"'{k}' is no valid property name. Valid names: {valid_names}")
            setattr(self,k,v)
    def get_value(self, i):
        """Get value ``value`` of ``(<chip.hipExternalSemaphoreSignalParams_st_struct_0_struct_0*>self._ptr)[i]``.
        """
        return (<chip.hipExternalSemaphoreSignalParams_st_struct_0_struct_0*>self._ptr)[i].value
    def set_value(self, i, unsigned long long value):
        """Set value ``value`` of ``(<chip.hipExternalSemaphoreSignalParams_st_struct_0_struct_0*>self._ptr)[i]``.
        """
        (<chip.hipExternalSemaphoreSignalParams_st_struct_0_struct_0*>self._ptr)[i].value = value
    @property
    def value(self):
        """(undocumented)"""
        return self.get_value(0)
    @value.setter
    def value(self, unsigned long long value):
        self.set_value(0,value)

    @staticmethod
    def PROPERTIES():
        return ["value"]

    def __contains__(self,item):
        properties = self.PROPERTIES()
        return item in properties

    def __getitem__(self,item):
        properties = self.PROPERTIES()
        if isinstance(item,int):
            if item < 0 or item >= len(properties):
                raise IndexError()
            return getattr(self,properties[item])
        raise ValueError("'item' type must be 'int'")


cdef class hipExternalSemaphoreSignalParams_st_struct_0_union_0(hip._util.types.Pointer):
    """Python wrapper for cdef class chip.hipExternalSemaphoreSignalParams_st_struct_0_union_0.

    Python wrapper for cdef class chip.hipExternalSemaphoreSignalParams_st_struct_0_union_0.

    If this type is initialized via its `__init__` method, it allocates a
    member of the underlying C type and destroys it again if the wrapper
    type is deallocated.

    This type also serves as adapter when appearing as argument type in a
    function signature. In this case, the type can further be initialized
    from a number of Python objects:

    * `None`:

      This will set the ``self._ptr`` attribute to ``NULL``.

    * `int`:

      Interprets the integer value as pointer address and writes it to ``self._ptr``.
      No ownership is transferred.

    * `ctypes.c_void_p`:

      Takes the pointer address ``pyobj.value`` and writes it to ``self._ptr``.
      No ownership is transferred.

    * `object` that implements the `CUDA Array Interface <https://numba.readthedocs.io/en/stable/cuda/cuda_array_interface.html>`_ protocol:

      Takes the integer-valued pointer address, i.e. the first entry of the `data` tuple
      from `pyobj`'s member ``__cuda_array_interface__``  and writes it to ``self._ptr``.

    * `object` that implements the Python buffer protocol:

      If the object represents a simple contiguous array,
      writes the `Py_buffer` associated with ``pyobj`` to `self._py_buffer`,
      sets the `self._py_buffer_acquired` flag to `True`, and
      writes `self._py_buffer.buf` to the data pointer `self._ptr`.

    * `hip._util.types.Pointer`:

      Takes the pointer address ``pyobj._ptr`` and writes it to ``self._ptr``.
      No ownership is transferred.

    Type checks are performed in the above order.

    C Attributes:
        _ptr (C type ``void *``, protected):
            Stores a pointer to the data of the original Python object.
        _is_ptr_owner (C type ``bint``, protected):
            If this wrapper is the owner of the underlying data.
        _py_buffer (C type ``Py_buffer`, protected):
            Stores a pointer to the data of the original Python object.
        _py_buffer_acquired (C type ``bint``, protected):
            Stores a pointer to the data of the original Python object.
    """
    # C members declared in pxd file

    def __cinit__(self):
        self._ptr = NULL
        self._is_ptr_owner = False
        self._py_buffer_acquired = False

    cdef chip.hipExternalSemaphoreSignalParams_st_struct_0_union_0* getElementPtr(self):
        return <chip.hipExternalSemaphoreSignalParams_st_struct_0_union_0*>self._ptr

    @staticmethod
    cdef hipExternalSemaphoreSignalParams_st_struct_0_union_0 fromPtr(void* ptr, bint owner=False):
        """Factory function to create ``hipExternalSemaphoreSignalParams_st_struct_0_union_0`` objects from
        given ``chip.hipExternalSemaphoreSignalParams_st_struct_0_union_0`` pointer.

        Setting ``owner`` flag to ``True`` causes
        the extension type to free the structure pointed to by ``ptr``
        when the wrapper object is deallocated.
        """
        # Fast call to __new__() that bypasses the __init__() constructor.
        cdef hipExternalSemaphoreSignalParams_st_struct_0_union_0 wrapper = hipExternalSemaphoreSignalParams_st_struct_0_union_0.__new__(hipExternalSemaphoreSignalParams_st_struct_0_union_0)
        wrapper._ptr = ptr
        wrapper._is_ptr_owner = owner
        return wrapper

    @staticmethod
    def fromObj(pyobj):
        """Creates a hipExternalSemaphoreSignalParams_st_struct_0_union_0 from a Python object.

        Derives a hipExternalSemaphoreSignalParams_st_struct_0_union_0 from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``hipExternalSemaphoreSignalParams_st_struct_0_union_0`` reference, this method
        returns it directly. No new ``hipExternalSemaphoreSignalParams_st_struct_0_union_0`` is created in this case.
        """
        return hipExternalSemaphoreSignalParams_st_struct_0_union_0.fromPyobj(pyobj)

    @staticmethod
    cdef hipExternalSemaphoreSignalParams_st_struct_0_union_0 fromPyobj(object pyobj):
        """Creates a hipExternalSemaphoreSignalParams_st_struct_0_union_0 from a Python object.

        Derives a hipExternalSemaphoreSignalParams_st_struct_0_union_0 from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``hipExternalSemaphoreSignalParams_st_struct_0_union_0`` reference, this method
        returns it directly. No new ``hipExternalSemaphoreSignalParams_st_struct_0_union_0`` is created in this case.

        Args:
            pyobj (object): Must be either `None`; a `hip._util.types.Pointer`; a simple, contiguous buffer according to the buffer protocol;
                            or of type `hipExternalSemaphoreSignalParams_st_struct_0_union_0`; `int`; or `ctypes.c_void_p`.

        Note:
            This routine does not perform a copy but returns the original ``pyobj``
            if ``pyobj`` is an instance of hipExternalSemaphoreSignalParams_st_struct_0_union_0!
        """
        cdef hipExternalSemaphoreSignalParams_st_struct_0_union_0 wrapper

        if isinstance(pyobj,hipExternalSemaphoreSignalParams_st_struct_0_union_0):
            return pyobj
        else:
            wrapper = hipExternalSemaphoreSignalParams_st_struct_0_union_0.__new__(hipExternalSemaphoreSignalParams_st_struct_0_union_0)
            wrapper.init_from_pyobj(pyobj)
            return wrapper

    def __dealloc__(self):
        # Release the buffer handle
        if self._py_buffer_acquired is True:
            cpython.buffer.PyBuffer_Release(&self._py_buffer)
        # De-allocate if not null and flag is set
        if self._ptr is not NULL and self._is_ptr_owner is True:
            stdlib.free(self._ptr)
            self._ptr = NULL

    @staticmethod
    cdef __allocate(void** ptr):
        ptr[0] = stdlib.malloc(sizeof(chip.hipExternalSemaphoreSignalParams_st_struct_0_union_0))
        string.memset(<void*>ptr[0], 0, sizeof(chip.hipExternalSemaphoreSignalParams_st_struct_0_union_0))

        if ptr[0] is NULL:
            raise MemoryError

    @staticmethod
    cdef hipExternalSemaphoreSignalParams_st_struct_0_union_0 new():
        """Factory function to create hipExternalSemaphoreSignalParams_st_struct_0_union_0 objects with
        newly allocated chip.hipExternalSemaphoreSignalParams_st_struct_0_union_0"""
        cdef void* ptr
        hipExternalSemaphoreSignalParams_st_struct_0_union_0.__allocate(&ptr)
        return hipExternalSemaphoreSignalParams_st_struct_0_union_0.fromPtr(ptr, owner=True)

    @staticmethod
    cdef hipExternalSemaphoreSignalParams_st_struct_0_union_0 fromValue(chip.hipExternalSemaphoreSignalParams_st_struct_0_union_0 other):
        """Allocate new C type and copy from ``other``.
        """
        wrapper = hipExternalSemaphoreSignalParams_st_struct_0_union_0.new()
        string.memcpy(wrapper._ptr, &other, sizeof(chip.hipExternalSemaphoreSignalParams_st_struct_0_union_0))
        return wrapper

    def c_sizeof(self):
        """Returns the size of the underlying C type in bytes.
        Note:
            Implemented as function to not collide with
            autogenerated property names.
        """
        return sizeof(chip.hipExternalSemaphoreSignalParams_st_struct_0_union_0)

    def __int__(self):
        """Returns the data's address as long integer.
        """
        return cpython.long.PyLong_FromVoidPtr(self._ptr)

    def __repr__(self):
        return f"<hipExternalSemaphoreSignalParams_st_struct_0_union_0 object, ptr: {int(self)}>"

    def as_c_void_p(self):
        """Returns the data's address as `ctypes.c_void_p`
        Note:
            Implemented as function to not collide with
            autogenerated property names.
        """
        return ctypes.c_void_p(int(self))

    def __init__(self,**kwargs):
        """Constructor type hipExternalSemaphoreSignalParams_st_struct_0_union_0.

        Constructor for type hipExternalSemaphoreSignalParams_st_struct_0_union_0.

        Args:
            **kwargs:
                Can be used to initialize member variables at construction,
                Just pass an argument expression of the form <member>=<value>
                per member that you want to initialize.
        """
        hipExternalSemaphoreSignalParams_st_struct_0_union_0.__allocate(&self._ptr)
        self._is_ptr_owner = True
        attribs = self.PROPERTIES()
        used_attribs = set()
        if len(kwargs) > 1:
            raise ValueError("Not more than one attribute might specified for Python types derived from C union types.")
        valid_names = ", ".join(["'"+p+"'" for p in attribs])
        for k,v in kwargs.items():
            if k in used_attribs:
                raise KeyError(f"argument '{k}' has already been specified as positional argument.")
            elif k not in attribs:
                raise KeyError(f"'{k}' is no valid property name. Valid names: {valid_names}")
            setattr(self,k,v)
    def get_fence(self, i):
        """Get value ``fence`` of ``(<chip.hipExternalSemaphoreSignalParams_st_struct_0_union_0*>self._ptr)[i]``.
        """
        return hip._util.types.Pointer.fromPtr((<chip.hipExternalSemaphoreSignalParams_st_struct_0_union_0*>self._ptr)[i].fence)
    def set_fence(self, i, object value):
        """Set value ``fence`` of ``(<chip.hipExternalSemaphoreSignalParams_st_struct_0_union_0*>self._ptr)[i]``.

        Note:
            This can be dangerous if the pointer is from a python object
            that is later on garbage collected.
        """
        (<chip.hipExternalSemaphoreSignalParams_st_struct_0_union_0*>self._ptr)[i].fence = <void *>cpython.long.PyLong_AsVoidPtr(int(hip._util.types.Pointer.fromPyobj(value)))
    @property
    def fence(self):
        """(undocumented)
        Note:
            Setting this fence can be dangerous if the underlying pointer is from a python object that
            is later on garbage collected.
        """
        return self.get_fence(0)
    @fence.setter
    def fence(self, object value):
        self.set_fence(0,value)

    def get_reserved(self, i):
        """Get value ``reserved`` of ``(<chip.hipExternalSemaphoreSignalParams_st_struct_0_union_0*>self._ptr)[i]``.
        """
        return (<chip.hipExternalSemaphoreSignalParams_st_struct_0_union_0*>self._ptr)[i].reserved
    def set_reserved(self, i, unsigned long long value):
        """Set value ``reserved`` of ``(<chip.hipExternalSemaphoreSignalParams_st_struct_0_union_0*>self._ptr)[i]``.
        """
        (<chip.hipExternalSemaphoreSignalParams_st_struct_0_union_0*>self._ptr)[i].reserved = value
    @property
    def reserved(self):
        """(undocumented)"""
        return self.get_reserved(0)
    @reserved.setter
    def reserved(self, unsigned long long value):
        self.set_reserved(0,value)

    @staticmethod
    def PROPERTIES():
        return ["fence","reserved"]


cdef class hipExternalSemaphoreSignalParams_st_struct_0_struct_1(hip._util.types.Pointer):
    """Python wrapper for cdef class chip.hipExternalSemaphoreSignalParams_st_struct_0_struct_1.

    Python wrapper for cdef class chip.hipExternalSemaphoreSignalParams_st_struct_0_struct_1.

    If this type is initialized via its `__init__` method, it allocates a
    member of the underlying C type and destroys it again if the wrapper
    type is deallocated.

    This type also serves as adapter when appearing as argument type in a
    function signature. In this case, the type can further be initialized
    from a number of Python objects:

    * `None`:

      This will set the ``self._ptr`` attribute to ``NULL``.

    * `int`:

      Interprets the integer value as pointer address and writes it to ``self._ptr``.
      No ownership is transferred.

    * `ctypes.c_void_p`:

      Takes the pointer address ``pyobj.value`` and writes it to ``self._ptr``.
      No ownership is transferred.

    * `object` that implements the `CUDA Array Interface <https://numba.readthedocs.io/en/stable/cuda/cuda_array_interface.html>`_ protocol:

      Takes the integer-valued pointer address, i.e. the first entry of the `data` tuple
      from `pyobj`'s member ``__cuda_array_interface__``  and writes it to ``self._ptr``.

    * `object` that implements the Python buffer protocol:

      If the object represents a simple contiguous array,
      writes the `Py_buffer` associated with ``pyobj`` to `self._py_buffer`,
      sets the `self._py_buffer_acquired` flag to `True`, and
      writes `self._py_buffer.buf` to the data pointer `self._ptr`.

    * `hip._util.types.Pointer`:

      Takes the pointer address ``pyobj._ptr`` and writes it to ``self._ptr``.
      No ownership is transferred.

    Type checks are performed in the above order.

    C Attributes:
        _ptr (C type ``void *``, protected):
            Stores a pointer to the data of the original Python object.
        _is_ptr_owner (C type ``bint``, protected):
            If this wrapper is the owner of the underlying data.
        _py_buffer (C type ``Py_buffer`, protected):
            Stores a pointer to the data of the original Python object.
        _py_buffer_acquired (C type ``bint``, protected):
            Stores a pointer to the data of the original Python object.
    """
    # C members declared in pxd file

    def __cinit__(self):
        self._ptr = NULL
        self._is_ptr_owner = False
        self._py_buffer_acquired = False

    cdef chip.hipExternalSemaphoreSignalParams_st_struct_0_struct_1* getElementPtr(self):
        return <chip.hipExternalSemaphoreSignalParams_st_struct_0_struct_1*>self._ptr

    @staticmethod
    cdef hipExternalSemaphoreSignalParams_st_struct_0_struct_1 fromPtr(void* ptr, bint owner=False):
        """Factory function to create ``hipExternalSemaphoreSignalParams_st_struct_0_struct_1`` objects from
        given ``chip.hipExternalSemaphoreSignalParams_st_struct_0_struct_1`` pointer.

        Setting ``owner`` flag to ``True`` causes
        the extension type to free the structure pointed to by ``ptr``
        when the wrapper object is deallocated.
        """
        # Fast call to __new__() that bypasses the __init__() constructor.
        cdef hipExternalSemaphoreSignalParams_st_struct_0_struct_1 wrapper = hipExternalSemaphoreSignalParams_st_struct_0_struct_1.__new__(hipExternalSemaphoreSignalParams_st_struct_0_struct_1)
        wrapper._ptr = ptr
        wrapper._is_ptr_owner = owner
        return wrapper

    @staticmethod
    def fromObj(pyobj):
        """Creates a hipExternalSemaphoreSignalParams_st_struct_0_struct_1 from a Python object.

        Derives a hipExternalSemaphoreSignalParams_st_struct_0_struct_1 from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``hipExternalSemaphoreSignalParams_st_struct_0_struct_1`` reference, this method
        returns it directly. No new ``hipExternalSemaphoreSignalParams_st_struct_0_struct_1`` is created in this case.
        """
        return hipExternalSemaphoreSignalParams_st_struct_0_struct_1.fromPyobj(pyobj)

    @staticmethod
    cdef hipExternalSemaphoreSignalParams_st_struct_0_struct_1 fromPyobj(object pyobj):
        """Creates a hipExternalSemaphoreSignalParams_st_struct_0_struct_1 from a Python object.

        Derives a hipExternalSemaphoreSignalParams_st_struct_0_struct_1 from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``hipExternalSemaphoreSignalParams_st_struct_0_struct_1`` reference, this method
        returns it directly. No new ``hipExternalSemaphoreSignalParams_st_struct_0_struct_1`` is created in this case.

        Args:
            pyobj (object): Must be either `None`; a `hip._util.types.Pointer`; a simple, contiguous buffer according to the buffer protocol;
                            or of type `hipExternalSemaphoreSignalParams_st_struct_0_struct_1`; `int`; or `ctypes.c_void_p`.

        Note:
            This routine does not perform a copy but returns the original ``pyobj``
            if ``pyobj`` is an instance of hipExternalSemaphoreSignalParams_st_struct_0_struct_1!
        """
        cdef hipExternalSemaphoreSignalParams_st_struct_0_struct_1 wrapper

        if isinstance(pyobj,hipExternalSemaphoreSignalParams_st_struct_0_struct_1):
            return pyobj
        else:
            wrapper = hipExternalSemaphoreSignalParams_st_struct_0_struct_1.__new__(hipExternalSemaphoreSignalParams_st_struct_0_struct_1)
            wrapper.init_from_pyobj(pyobj)
            return wrapper

    def __dealloc__(self):
        # Release the buffer handle
        if self._py_buffer_acquired is True:
            cpython.buffer.PyBuffer_Release(&self._py_buffer)
        # De-allocate if not null and flag is set
        if self._ptr is not NULL and self._is_ptr_owner is True:
            stdlib.free(self._ptr)
            self._ptr = NULL

    @staticmethod
    cdef __allocate(void** ptr):
        ptr[0] = stdlib.malloc(sizeof(chip.hipExternalSemaphoreSignalParams_st_struct_0_struct_1))
        string.memset(<void*>ptr[0], 0, sizeof(chip.hipExternalSemaphoreSignalParams_st_struct_0_struct_1))

        if ptr[0] is NULL:
            raise MemoryError

    @staticmethod
    cdef hipExternalSemaphoreSignalParams_st_struct_0_struct_1 new():
        """Factory function to create hipExternalSemaphoreSignalParams_st_struct_0_struct_1 objects with
        newly allocated chip.hipExternalSemaphoreSignalParams_st_struct_0_struct_1"""
        cdef void* ptr
        hipExternalSemaphoreSignalParams_st_struct_0_struct_1.__allocate(&ptr)
        return hipExternalSemaphoreSignalParams_st_struct_0_struct_1.fromPtr(ptr, owner=True)

    @staticmethod
    cdef hipExternalSemaphoreSignalParams_st_struct_0_struct_1 fromValue(chip.hipExternalSemaphoreSignalParams_st_struct_0_struct_1 other):
        """Allocate new C type and copy from ``other``.
        """
        wrapper = hipExternalSemaphoreSignalParams_st_struct_0_struct_1.new()
        string.memcpy(wrapper._ptr, &other, sizeof(chip.hipExternalSemaphoreSignalParams_st_struct_0_struct_1))
        return wrapper

    def c_sizeof(self):
        """Returns the size of the underlying C type in bytes.
        Note:
            Implemented as function to not collide with
            autogenerated property names.
        """
        return sizeof(chip.hipExternalSemaphoreSignalParams_st_struct_0_struct_1)

    def __int__(self):
        """Returns the data's address as long integer.
        """
        return cpython.long.PyLong_FromVoidPtr(self._ptr)

    def __repr__(self):
        return f"<hipExternalSemaphoreSignalParams_st_struct_0_struct_1 object, ptr: {int(self)}>"

    def as_c_void_p(self):
        """Returns the data's address as `ctypes.c_void_p`
        Note:
            Implemented as function to not collide with
            autogenerated property names.
        """
        return ctypes.c_void_p(int(self))

    def __init__(self,*args,**kwargs):
        """Constructor type hipExternalSemaphoreSignalParams_st_struct_0_struct_1.

        Constructor for type hipExternalSemaphoreSignalParams_st_struct_0_struct_1.

        Args:
            *args:
                Positional arguments. Initialize all or a subset of the member variables
                according to their order of declaration.
            **kwargs:
                Can be used to initialize member variables at construction,
                Just pass an argument expression of the form <member>=<value>
                per member that you want to initialize.
        """
        hipExternalSemaphoreSignalParams_st_struct_0_struct_1.__allocate(&self._ptr)
        self._is_ptr_owner = True
        attribs = self.PROPERTIES()
        used_attribs = set()
        if len(args) > len(attribs):
            raise ValueError("More positional arguments specified than this type has properties.")
        for i,v in enumerate(args):
            setattr(self,attribs[i],v)
            used_attribs.add(attribs[i])
        valid_names = ", ".join(["'"+p+"'" for p in attribs])
        for k,v in kwargs.items():
            if k in used_attribs:
                raise KeyError(f"argument '{k}' has already been specified as positional argument.")
            elif k not in attribs:
                raise KeyError(f"'{k}' is no valid property name. Valid names: {valid_names}")
            setattr(self,k,v)
    def get_key(self, i):
        """Get value ``key`` of ``(<chip.hipExternalSemaphoreSignalParams_st_struct_0_struct_1*>self._ptr)[i]``.
        """
        return (<chip.hipExternalSemaphoreSignalParams_st_struct_0_struct_1*>self._ptr)[i].key
    def set_key(self, i, unsigned long long value):
        """Set value ``key`` of ``(<chip.hipExternalSemaphoreSignalParams_st_struct_0_struct_1*>self._ptr)[i]``.
        """
        (<chip.hipExternalSemaphoreSignalParams_st_struct_0_struct_1*>self._ptr)[i].key = value
    @property
    def key(self):
        """(undocumented)"""
        return self.get_key(0)
    @key.setter
    def key(self, unsigned long long value):
        self.set_key(0,value)

    @staticmethod
    def PROPERTIES():
        return ["key"]

    def __contains__(self,item):
        properties = self.PROPERTIES()
        return item in properties

    def __getitem__(self,item):
        properties = self.PROPERTIES()
        if isinstance(item,int):
            if item < 0 or item >= len(properties):
                raise IndexError()
            return getattr(self,properties[item])
        raise ValueError("'item' type must be 'int'")


cdef class hipExternalSemaphoreSignalParams_st_struct_0(hip._util.types.Pointer):
    """Python wrapper for cdef class chip.hipExternalSemaphoreSignalParams_st_struct_0.

    Python wrapper for cdef class chip.hipExternalSemaphoreSignalParams_st_struct_0.

    If this type is initialized via its `__init__` method, it allocates a
    member of the underlying C type and destroys it again if the wrapper
    type is deallocated.

    This type also serves as adapter when appearing as argument type in a
    function signature. In this case, the type can further be initialized
    from a number of Python objects:

    * `None`:

      This will set the ``self._ptr`` attribute to ``NULL``.

    * `int`:

      Interprets the integer value as pointer address and writes it to ``self._ptr``.
      No ownership is transferred.

    * `ctypes.c_void_p`:

      Takes the pointer address ``pyobj.value`` and writes it to ``self._ptr``.
      No ownership is transferred.

    * `object` that implements the `CUDA Array Interface <https://numba.readthedocs.io/en/stable/cuda/cuda_array_interface.html>`_ protocol:

      Takes the integer-valued pointer address, i.e. the first entry of the `data` tuple
      from `pyobj`'s member ``__cuda_array_interface__``  and writes it to ``self._ptr``.

    * `object` that implements the Python buffer protocol:

      If the object represents a simple contiguous array,
      writes the `Py_buffer` associated with ``pyobj`` to `self._py_buffer`,
      sets the `self._py_buffer_acquired` flag to `True`, and
      writes `self._py_buffer.buf` to the data pointer `self._ptr`.

    * `hip._util.types.Pointer`:

      Takes the pointer address ``pyobj._ptr`` and writes it to ``self._ptr``.
      No ownership is transferred.

    Type checks are performed in the above order.

    C Attributes:
        _ptr (C type ``void *``, protected):
            Stores a pointer to the data of the original Python object.
        _is_ptr_owner (C type ``bint``, protected):
            If this wrapper is the owner of the underlying data.
        _py_buffer (C type ``Py_buffer`, protected):
            Stores a pointer to the data of the original Python object.
        _py_buffer_acquired (C type ``bint``, protected):
            Stores a pointer to the data of the original Python object.
    """
    # C members declared in pxd file

    def __cinit__(self):
        self._ptr = NULL
        self._is_ptr_owner = False
        self._py_buffer_acquired = False

    cdef chip.hipExternalSemaphoreSignalParams_st_struct_0* getElementPtr(self):
        return <chip.hipExternalSemaphoreSignalParams_st_struct_0*>self._ptr

    @staticmethod
    cdef hipExternalSemaphoreSignalParams_st_struct_0 fromPtr(void* ptr, bint owner=False):
        """Factory function to create ``hipExternalSemaphoreSignalParams_st_struct_0`` objects from
        given ``chip.hipExternalSemaphoreSignalParams_st_struct_0`` pointer.

        Setting ``owner`` flag to ``True`` causes
        the extension type to free the structure pointed to by ``ptr``
        when the wrapper object is deallocated.
        """
        # Fast call to __new__() that bypasses the __init__() constructor.
        cdef hipExternalSemaphoreSignalParams_st_struct_0 wrapper = hipExternalSemaphoreSignalParams_st_struct_0.__new__(hipExternalSemaphoreSignalParams_st_struct_0)
        wrapper._ptr = ptr
        wrapper._is_ptr_owner = owner
        return wrapper

    @staticmethod
    def fromObj(pyobj):
        """Creates a hipExternalSemaphoreSignalParams_st_struct_0 from a Python object.

        Derives a hipExternalSemaphoreSignalParams_st_struct_0 from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``hipExternalSemaphoreSignalParams_st_struct_0`` reference, this method
        returns it directly. No new ``hipExternalSemaphoreSignalParams_st_struct_0`` is created in this case.
        """
        return hipExternalSemaphoreSignalParams_st_struct_0.fromPyobj(pyobj)

    @staticmethod
    cdef hipExternalSemaphoreSignalParams_st_struct_0 fromPyobj(object pyobj):
        """Creates a hipExternalSemaphoreSignalParams_st_struct_0 from a Python object.

        Derives a hipExternalSemaphoreSignalParams_st_struct_0 from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``hipExternalSemaphoreSignalParams_st_struct_0`` reference, this method
        returns it directly. No new ``hipExternalSemaphoreSignalParams_st_struct_0`` is created in this case.

        Args:
            pyobj (object): Must be either `None`; a `hip._util.types.Pointer`; a simple, contiguous buffer according to the buffer protocol;
                            or of type `hipExternalSemaphoreSignalParams_st_struct_0`; `int`; or `ctypes.c_void_p`.

        Note:
            This routine does not perform a copy but returns the original ``pyobj``
            if ``pyobj`` is an instance of hipExternalSemaphoreSignalParams_st_struct_0!
        """
        cdef hipExternalSemaphoreSignalParams_st_struct_0 wrapper

        if isinstance(pyobj,hipExternalSemaphoreSignalParams_st_struct_0):
            return pyobj
        else:
            wrapper = hipExternalSemaphoreSignalParams_st_struct_0.__new__(hipExternalSemaphoreSignalParams_st_struct_0)
            wrapper.init_from_pyobj(pyobj)
            return wrapper

    def __dealloc__(self):
        # Release the buffer handle
        if self._py_buffer_acquired is True:
            cpython.buffer.PyBuffer_Release(&self._py_buffer)
        # De-allocate if not null and flag is set
        if self._ptr is not NULL and self._is_ptr_owner is True:
            stdlib.free(self._ptr)
            self._ptr = NULL

    @staticmethod
    cdef __allocate(void** ptr):
        ptr[0] = stdlib.malloc(sizeof(chip.hipExternalSemaphoreSignalParams_st_struct_0))
        string.memset(<void*>ptr[0], 0, sizeof(chip.hipExternalSemaphoreSignalParams_st_struct_0))

        if ptr[0] is NULL:
            raise MemoryError

    @staticmethod
    cdef hipExternalSemaphoreSignalParams_st_struct_0 new():
        """Factory function to create hipExternalSemaphoreSignalParams_st_struct_0 objects with
        newly allocated chip.hipExternalSemaphoreSignalParams_st_struct_0"""
        cdef void* ptr
        hipExternalSemaphoreSignalParams_st_struct_0.__allocate(&ptr)
        return hipExternalSemaphoreSignalParams_st_struct_0.fromPtr(ptr, owner=True)

    @staticmethod
    cdef hipExternalSemaphoreSignalParams_st_struct_0 fromValue(chip.hipExternalSemaphoreSignalParams_st_struct_0 other):
        """Allocate new C type and copy from ``other``.
        """
        wrapper = hipExternalSemaphoreSignalParams_st_struct_0.new()
        string.memcpy(wrapper._ptr, &other, sizeof(chip.hipExternalSemaphoreSignalParams_st_struct_0))
        return wrapper

    def c_sizeof(self):
        """Returns the size of the underlying C type in bytes.
        Note:
            Implemented as function to not collide with
            autogenerated property names.
        """
        return sizeof(chip.hipExternalSemaphoreSignalParams_st_struct_0)

    def __int__(self):
        """Returns the data's address as long integer.
        """
        return cpython.long.PyLong_FromVoidPtr(self._ptr)

    def __repr__(self):
        return f"<hipExternalSemaphoreSignalParams_st_struct_0 object, ptr: {int(self)}>"

    def as_c_void_p(self):
        """Returns the data's address as `ctypes.c_void_p`
        Note:
            Implemented as function to not collide with
            autogenerated property names.
        """
        return ctypes.c_void_p(int(self))

    def __init__(self,*args,**kwargs):
        """Constructor type hipExternalSemaphoreSignalParams_st_struct_0.

        Constructor for type hipExternalSemaphoreSignalParams_st_struct_0.

        Args:
            *args:
                Positional arguments. Initialize all or a subset of the member variables
                according to their order of declaration.
            **kwargs:
                Can be used to initialize member variables at construction,
                Just pass an argument expression of the form <member>=<value>
                per member that you want to initialize.
        """
        hipExternalSemaphoreSignalParams_st_struct_0.__allocate(&self._ptr)
        self._is_ptr_owner = True
        attribs = self.PROPERTIES()
        used_attribs = set()
        if len(args) > len(attribs):
            raise ValueError("More positional arguments specified than this type has properties.")
        for i,v in enumerate(args):
            setattr(self,attribs[i],v)
            used_attribs.add(attribs[i])
        valid_names = ", ".join(["'"+p+"'" for p in attribs])
        for k,v in kwargs.items():
            if k in used_attribs:
                raise KeyError(f"argument '{k}' has already been specified as positional argument.")
            elif k not in attribs:
                raise KeyError(f"'{k}' is no valid property name. Valid names: {valid_names}")
            setattr(self,k,v)
    def get_fence(self, i):
        """Get value of ``fence`` of ``(<chip.hipExternalSemaphoreSignalParams_st_struct_0*>self._ptr)[i]``.
        """
        return hipExternalSemaphoreSignalParams_st_struct_0_struct_0.fromPtr(&(<chip.hipExternalSemaphoreSignalParams_st_struct_0*>self._ptr)[i].fence)
    @property
    def fence(self):
        """(undocumented)"""
        return self.get_fence(0)

    def get_nvSciSync(self, i):
        """Get value of ``nvSciSync`` of ``(<chip.hipExternalSemaphoreSignalParams_st_struct_0*>self._ptr)[i]``.
        """
        return hipExternalSemaphoreSignalParams_st_struct_0_union_0.fromPtr(&(<chip.hipExternalSemaphoreSignalParams_st_struct_0*>self._ptr)[i].nvSciSync)
    @property
    def nvSciSync(self):
        """(undocumented)"""
        return self.get_nvSciSync(0)

    def get_keyedMutex(self, i):
        """Get value of ``keyedMutex`` of ``(<chip.hipExternalSemaphoreSignalParams_st_struct_0*>self._ptr)[i]``.
        """
        return hipExternalSemaphoreSignalParams_st_struct_0_struct_1.fromPtr(&(<chip.hipExternalSemaphoreSignalParams_st_struct_0*>self._ptr)[i].keyedMutex)
    @property
    def keyedMutex(self):
        """(undocumented)"""
        return self.get_keyedMutex(0)

    def get_reserved(self, i):
        """Get value of ``reserved`` of ``(<chip.hipExternalSemaphoreSignalParams_st_struct_0*>self._ptr)[i]``.
        """
        return (<chip.hipExternalSemaphoreSignalParams_st_struct_0*>self._ptr)[i].reserved
    # TODO add setters
    #def set_reserved(self, i, unsigned int[12] value):
    #    """Set value ``reserved`` of ``(<chip.hipExternalSemaphoreSignalParams_st_struct_0*>self._ptr)[i]``.
    #    """
    #    (<chip.hipExternalSemaphoreSignalParams_st_struct_0*>self._ptr)[i].reserved = value
    @property
    def reserved(self):
        """(undocumented)"""
        return self.get_reserved(0)
    # TODO add setters
    #@reserved.setter
    #def reserved(self, unsigned int[12] value):
    #    self.set_reserved(0,value)

    @staticmethod
    def PROPERTIES():
        return ["fence","nvSciSync","keyedMutex","reserved"]

    def __contains__(self,item):
        properties = self.PROPERTIES()
        return item in properties

    def __getitem__(self,item):
        properties = self.PROPERTIES()
        if isinstance(item,int):
            if item < 0 or item >= len(properties):
                raise IndexError()
            return getattr(self,properties[item])
        raise ValueError("'item' type must be 'int'")


cdef class hipExternalSemaphoreSignalParams_st(hip._util.types.Pointer):
    """Python wrapper for cdef class chip.hipExternalSemaphoreSignalParams_st.

    Python wrapper for cdef class chip.hipExternalSemaphoreSignalParams_st.

    If this type is initialized via its `__init__` method, it allocates a
    member of the underlying C type and destroys it again if the wrapper
    type is deallocated.

    This type also serves as adapter when appearing as argument type in a
    function signature. In this case, the type can further be initialized
    from a number of Python objects:

    * `None`:

      This will set the ``self._ptr`` attribute to ``NULL``.

    * `int`:

      Interprets the integer value as pointer address and writes it to ``self._ptr``.
      No ownership is transferred.

    * `ctypes.c_void_p`:

      Takes the pointer address ``pyobj.value`` and writes it to ``self._ptr``.
      No ownership is transferred.

    * `object` that implements the `CUDA Array Interface <https://numba.readthedocs.io/en/stable/cuda/cuda_array_interface.html>`_ protocol:

      Takes the integer-valued pointer address, i.e. the first entry of the `data` tuple
      from `pyobj`'s member ``__cuda_array_interface__``  and writes it to ``self._ptr``.

    * `object` that implements the Python buffer protocol:

      If the object represents a simple contiguous array,
      writes the `Py_buffer` associated with ``pyobj`` to `self._py_buffer`,
      sets the `self._py_buffer_acquired` flag to `True`, and
      writes `self._py_buffer.buf` to the data pointer `self._ptr`.

    * `hip._util.types.Pointer`:

      Takes the pointer address ``pyobj._ptr`` and writes it to ``self._ptr``.
      No ownership is transferred.

    Type checks are performed in the above order.

    C Attributes:
        _ptr (C type ``void *``, protected):
            Stores a pointer to the data of the original Python object.
        _is_ptr_owner (C type ``bint``, protected):
            If this wrapper is the owner of the underlying data.
        _py_buffer (C type ``Py_buffer`, protected):
            Stores a pointer to the data of the original Python object.
        _py_buffer_acquired (C type ``bint``, protected):
            Stores a pointer to the data of the original Python object.
    """
    # C members declared in pxd file

    def __cinit__(self):
        self._ptr = NULL
        self._is_ptr_owner = False
        self._py_buffer_acquired = False

    cdef chip.hipExternalSemaphoreSignalParams_st* getElementPtr(self):
        return <chip.hipExternalSemaphoreSignalParams_st*>self._ptr

    @staticmethod
    cdef hipExternalSemaphoreSignalParams_st fromPtr(void* ptr, bint owner=False):
        """Factory function to create ``hipExternalSemaphoreSignalParams_st`` objects from
        given ``chip.hipExternalSemaphoreSignalParams_st`` pointer.

        Setting ``owner`` flag to ``True`` causes
        the extension type to free the structure pointed to by ``ptr``
        when the wrapper object is deallocated.
        """
        # Fast call to __new__() that bypasses the __init__() constructor.
        cdef hipExternalSemaphoreSignalParams_st wrapper = hipExternalSemaphoreSignalParams_st.__new__(hipExternalSemaphoreSignalParams_st)
        wrapper._ptr = ptr
        wrapper._is_ptr_owner = owner
        return wrapper

    @staticmethod
    def fromObj(pyobj):
        """Creates a hipExternalSemaphoreSignalParams_st from a Python object.

        Derives a hipExternalSemaphoreSignalParams_st from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``hipExternalSemaphoreSignalParams_st`` reference, this method
        returns it directly. No new ``hipExternalSemaphoreSignalParams_st`` is created in this case.
        """
        return hipExternalSemaphoreSignalParams_st.fromPyobj(pyobj)

    @staticmethod
    cdef hipExternalSemaphoreSignalParams_st fromPyobj(object pyobj):
        """Creates a hipExternalSemaphoreSignalParams_st from a Python object.

        Derives a hipExternalSemaphoreSignalParams_st from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``hipExternalSemaphoreSignalParams_st`` reference, this method
        returns it directly. No new ``hipExternalSemaphoreSignalParams_st`` is created in this case.

        Args:
            pyobj (object): Must be either `None`; a `hip._util.types.Pointer`; a simple, contiguous buffer according to the buffer protocol;
                            or of type `hipExternalSemaphoreSignalParams_st`; `int`; or `ctypes.c_void_p`.

        Note:
            This routine does not perform a copy but returns the original ``pyobj``
            if ``pyobj`` is an instance of hipExternalSemaphoreSignalParams_st!
        """
        cdef hipExternalSemaphoreSignalParams_st wrapper

        if isinstance(pyobj,hipExternalSemaphoreSignalParams_st):
            return pyobj
        else:
            wrapper = hipExternalSemaphoreSignalParams_st.__new__(hipExternalSemaphoreSignalParams_st)
            wrapper.init_from_pyobj(pyobj)
            return wrapper

    def __dealloc__(self):
        # Release the buffer handle
        if self._py_buffer_acquired is True:
            cpython.buffer.PyBuffer_Release(&self._py_buffer)
        # De-allocate if not null and flag is set
        if self._ptr is not NULL and self._is_ptr_owner is True:
            stdlib.free(self._ptr)
            self._ptr = NULL

    @staticmethod
    cdef __allocate(void** ptr):
        ptr[0] = stdlib.malloc(sizeof(chip.hipExternalSemaphoreSignalParams_st))
        string.memset(<void*>ptr[0], 0, sizeof(chip.hipExternalSemaphoreSignalParams_st))

        if ptr[0] is NULL:
            raise MemoryError

    @staticmethod
    cdef hipExternalSemaphoreSignalParams_st new():
        """Factory function to create hipExternalSemaphoreSignalParams_st objects with
        newly allocated chip.hipExternalSemaphoreSignalParams_st"""
        cdef void* ptr
        hipExternalSemaphoreSignalParams_st.__allocate(&ptr)
        return hipExternalSemaphoreSignalParams_st.fromPtr(ptr, owner=True)

    @staticmethod
    cdef hipExternalSemaphoreSignalParams_st fromValue(chip.hipExternalSemaphoreSignalParams_st other):
        """Allocate new C type and copy from ``other``.
        """
        wrapper = hipExternalSemaphoreSignalParams_st.new()
        string.memcpy(wrapper._ptr, &other, sizeof(chip.hipExternalSemaphoreSignalParams_st))
        return wrapper

    def c_sizeof(self):
        """Returns the size of the underlying C type in bytes.
        Note:
            Implemented as function to not collide with
            autogenerated property names.
        """
        return sizeof(chip.hipExternalSemaphoreSignalParams_st)

    def __int__(self):
        """Returns the data's address as long integer.
        """
        return cpython.long.PyLong_FromVoidPtr(self._ptr)

    def __repr__(self):
        return f"<hipExternalSemaphoreSignalParams_st object, ptr: {int(self)}>"

    def as_c_void_p(self):
        """Returns the data's address as `ctypes.c_void_p`
        Note:
            Implemented as function to not collide with
            autogenerated property names.
        """
        return ctypes.c_void_p(int(self))

    def __init__(self,*args,**kwargs):
        """Constructor type hipExternalSemaphoreSignalParams_st.

        Constructor for type hipExternalSemaphoreSignalParams_st.

        Args:
            *args:
                Positional arguments. Initialize all or a subset of the member variables
                according to their order of declaration.
            **kwargs:
                Can be used to initialize member variables at construction,
                Just pass an argument expression of the form <member>=<value>
                per member that you want to initialize.
        """
        hipExternalSemaphoreSignalParams_st.__allocate(&self._ptr)
        self._is_ptr_owner = True
        attribs = self.PROPERTIES()
        used_attribs = set()
        if len(args) > len(attribs):
            raise ValueError("More positional arguments specified than this type has properties.")
        for i,v in enumerate(args):
            setattr(self,attribs[i],v)
            used_attribs.add(attribs[i])
        valid_names = ", ".join(["'"+p+"'" for p in attribs])
        for k,v in kwargs.items():
            if k in used_attribs:
                raise KeyError(f"argument '{k}' has already been specified as positional argument.")
            elif k not in attribs:
                raise KeyError(f"'{k}' is no valid property name. Valid names: {valid_names}")
            setattr(self,k,v)
    def get_params(self, i):
        """Get value of ``params`` of ``(<chip.hipExternalSemaphoreSignalParams_st*>self._ptr)[i]``.
        """
        return hipExternalSemaphoreSignalParams_st_struct_0.fromPtr(&(<chip.hipExternalSemaphoreSignalParams_st*>self._ptr)[i].params)
    @property
    def params(self):
        """(undocumented)"""
        return self.get_params(0)

    def get_flags(self, i):
        """Get value ``flags`` of ``(<chip.hipExternalSemaphoreSignalParams_st*>self._ptr)[i]``.
        """
        return (<chip.hipExternalSemaphoreSignalParams_st*>self._ptr)[i].flags
    def set_flags(self, i, unsigned int value):
        """Set value ``flags`` of ``(<chip.hipExternalSemaphoreSignalParams_st*>self._ptr)[i]``.
        """
        (<chip.hipExternalSemaphoreSignalParams_st*>self._ptr)[i].flags = value
    @property
    def flags(self):
        """(undocumented)"""
        return self.get_flags(0)
    @flags.setter
    def flags(self, unsigned int value):
        self.set_flags(0,value)

    def get_reserved(self, i):
        """Get value of ``reserved`` of ``(<chip.hipExternalSemaphoreSignalParams_st*>self._ptr)[i]``.
        """
        return (<chip.hipExternalSemaphoreSignalParams_st*>self._ptr)[i].reserved
    # TODO add setters
    #def set_reserved(self, i, unsigned int[16] value):
    #    """Set value ``reserved`` of ``(<chip.hipExternalSemaphoreSignalParams_st*>self._ptr)[i]``.
    #    """
    #    (<chip.hipExternalSemaphoreSignalParams_st*>self._ptr)[i].reserved = value
    @property
    def reserved(self):
        """(undocumented)"""
        return self.get_reserved(0)
    # TODO add setters
    #@reserved.setter
    #def reserved(self, unsigned int[16] value):
    #    self.set_reserved(0,value)

    @staticmethod
    def PROPERTIES():
        return ["params","flags","reserved"]

    def __contains__(self,item):
        properties = self.PROPERTIES()
        return item in properties

    def __getitem__(self,item):
        properties = self.PROPERTIES()
        if isinstance(item,int):
            if item < 0 or item >= len(properties):
                raise IndexError()
            return getattr(self,properties[item])
        raise ValueError("'item' type must be 'int'")


hipExternalSemaphoreSignalParams = hipExternalSemaphoreSignalParams_st

cdef class hipExternalSemaphoreWaitParams_st_struct_0_struct_0(hip._util.types.Pointer):
    """Python wrapper for cdef class chip.hipExternalSemaphoreWaitParams_st_struct_0_struct_0.

    Python wrapper for cdef class chip.hipExternalSemaphoreWaitParams_st_struct_0_struct_0.

    If this type is initialized via its `__init__` method, it allocates a
    member of the underlying C type and destroys it again if the wrapper
    type is deallocated.

    This type also serves as adapter when appearing as argument type in a
    function signature. In this case, the type can further be initialized
    from a number of Python objects:

    * `None`:

      This will set the ``self._ptr`` attribute to ``NULL``.

    * `int`:

      Interprets the integer value as pointer address and writes it to ``self._ptr``.
      No ownership is transferred.

    * `ctypes.c_void_p`:

      Takes the pointer address ``pyobj.value`` and writes it to ``self._ptr``.
      No ownership is transferred.

    * `object` that implements the `CUDA Array Interface <https://numba.readthedocs.io/en/stable/cuda/cuda_array_interface.html>`_ protocol:

      Takes the integer-valued pointer address, i.e. the first entry of the `data` tuple
      from `pyobj`'s member ``__cuda_array_interface__``  and writes it to ``self._ptr``.

    * `object` that implements the Python buffer protocol:

      If the object represents a simple contiguous array,
      writes the `Py_buffer` associated with ``pyobj`` to `self._py_buffer`,
      sets the `self._py_buffer_acquired` flag to `True`, and
      writes `self._py_buffer.buf` to the data pointer `self._ptr`.

    * `hip._util.types.Pointer`:

      Takes the pointer address ``pyobj._ptr`` and writes it to ``self._ptr``.
      No ownership is transferred.

    Type checks are performed in the above order.

    C Attributes:
        _ptr (C type ``void *``, protected):
            Stores a pointer to the data of the original Python object.
        _is_ptr_owner (C type ``bint``, protected):
            If this wrapper is the owner of the underlying data.
        _py_buffer (C type ``Py_buffer`, protected):
            Stores a pointer to the data of the original Python object.
        _py_buffer_acquired (C type ``bint``, protected):
            Stores a pointer to the data of the original Python object.
    """
    # C members declared in pxd file

    def __cinit__(self):
        self._ptr = NULL
        self._is_ptr_owner = False
        self._py_buffer_acquired = False

    cdef chip.hipExternalSemaphoreWaitParams_st_struct_0_struct_0* getElementPtr(self):
        return <chip.hipExternalSemaphoreWaitParams_st_struct_0_struct_0*>self._ptr

    @staticmethod
    cdef hipExternalSemaphoreWaitParams_st_struct_0_struct_0 fromPtr(void* ptr, bint owner=False):
        """Factory function to create ``hipExternalSemaphoreWaitParams_st_struct_0_struct_0`` objects from
        given ``chip.hipExternalSemaphoreWaitParams_st_struct_0_struct_0`` pointer.

        Setting ``owner`` flag to ``True`` causes
        the extension type to free the structure pointed to by ``ptr``
        when the wrapper object is deallocated.
        """
        # Fast call to __new__() that bypasses the __init__() constructor.
        cdef hipExternalSemaphoreWaitParams_st_struct_0_struct_0 wrapper = hipExternalSemaphoreWaitParams_st_struct_0_struct_0.__new__(hipExternalSemaphoreWaitParams_st_struct_0_struct_0)
        wrapper._ptr = ptr
        wrapper._is_ptr_owner = owner
        return wrapper

    @staticmethod
    def fromObj(pyobj):
        """Creates a hipExternalSemaphoreWaitParams_st_struct_0_struct_0 from a Python object.

        Derives a hipExternalSemaphoreWaitParams_st_struct_0_struct_0 from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``hipExternalSemaphoreWaitParams_st_struct_0_struct_0`` reference, this method
        returns it directly. No new ``hipExternalSemaphoreWaitParams_st_struct_0_struct_0`` is created in this case.
        """
        return hipExternalSemaphoreWaitParams_st_struct_0_struct_0.fromPyobj(pyobj)

    @staticmethod
    cdef hipExternalSemaphoreWaitParams_st_struct_0_struct_0 fromPyobj(object pyobj):
        """Creates a hipExternalSemaphoreWaitParams_st_struct_0_struct_0 from a Python object.

        Derives a hipExternalSemaphoreWaitParams_st_struct_0_struct_0 from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``hipExternalSemaphoreWaitParams_st_struct_0_struct_0`` reference, this method
        returns it directly. No new ``hipExternalSemaphoreWaitParams_st_struct_0_struct_0`` is created in this case.

        Args:
            pyobj (object): Must be either `None`; a `hip._util.types.Pointer`; a simple, contiguous buffer according to the buffer protocol;
                            or of type `hipExternalSemaphoreWaitParams_st_struct_0_struct_0`; `int`; or `ctypes.c_void_p`.

        Note:
            This routine does not perform a copy but returns the original ``pyobj``
            if ``pyobj`` is an instance of hipExternalSemaphoreWaitParams_st_struct_0_struct_0!
        """
        cdef hipExternalSemaphoreWaitParams_st_struct_0_struct_0 wrapper

        if isinstance(pyobj,hipExternalSemaphoreWaitParams_st_struct_0_struct_0):
            return pyobj
        else:
            wrapper = hipExternalSemaphoreWaitParams_st_struct_0_struct_0.__new__(hipExternalSemaphoreWaitParams_st_struct_0_struct_0)
            wrapper.init_from_pyobj(pyobj)
            return wrapper

    def __dealloc__(self):
        # Release the buffer handle
        if self._py_buffer_acquired is True:
            cpython.buffer.PyBuffer_Release(&self._py_buffer)
        # De-allocate if not null and flag is set
        if self._ptr is not NULL and self._is_ptr_owner is True:
            stdlib.free(self._ptr)
            self._ptr = NULL

    @staticmethod
    cdef __allocate(void** ptr):
        ptr[0] = stdlib.malloc(sizeof(chip.hipExternalSemaphoreWaitParams_st_struct_0_struct_0))
        string.memset(<void*>ptr[0], 0, sizeof(chip.hipExternalSemaphoreWaitParams_st_struct_0_struct_0))

        if ptr[0] is NULL:
            raise MemoryError

    @staticmethod
    cdef hipExternalSemaphoreWaitParams_st_struct_0_struct_0 new():
        """Factory function to create hipExternalSemaphoreWaitParams_st_struct_0_struct_0 objects with
        newly allocated chip.hipExternalSemaphoreWaitParams_st_struct_0_struct_0"""
        cdef void* ptr
        hipExternalSemaphoreWaitParams_st_struct_0_struct_0.__allocate(&ptr)
        return hipExternalSemaphoreWaitParams_st_struct_0_struct_0.fromPtr(ptr, owner=True)

    @staticmethod
    cdef hipExternalSemaphoreWaitParams_st_struct_0_struct_0 fromValue(chip.hipExternalSemaphoreWaitParams_st_struct_0_struct_0 other):
        """Allocate new C type and copy from ``other``.
        """
        wrapper = hipExternalSemaphoreWaitParams_st_struct_0_struct_0.new()
        string.memcpy(wrapper._ptr, &other, sizeof(chip.hipExternalSemaphoreWaitParams_st_struct_0_struct_0))
        return wrapper

    def c_sizeof(self):
        """Returns the size of the underlying C type in bytes.
        Note:
            Implemented as function to not collide with
            autogenerated property names.
        """
        return sizeof(chip.hipExternalSemaphoreWaitParams_st_struct_0_struct_0)

    def __int__(self):
        """Returns the data's address as long integer.
        """
        return cpython.long.PyLong_FromVoidPtr(self._ptr)

    def __repr__(self):
        return f"<hipExternalSemaphoreWaitParams_st_struct_0_struct_0 object, ptr: {int(self)}>"

    def as_c_void_p(self):
        """Returns the data's address as `ctypes.c_void_p`
        Note:
            Implemented as function to not collide with
            autogenerated property names.
        """
        return ctypes.c_void_p(int(self))

    def __init__(self,*args,**kwargs):
        """Constructor type hipExternalSemaphoreWaitParams_st_struct_0_struct_0.

        Constructor for type hipExternalSemaphoreWaitParams_st_struct_0_struct_0.

        Args:
            *args:
                Positional arguments. Initialize all or a subset of the member variables
                according to their order of declaration.
            **kwargs:
                Can be used to initialize member variables at construction,
                Just pass an argument expression of the form <member>=<value>
                per member that you want to initialize.
        """
        hipExternalSemaphoreWaitParams_st_struct_0_struct_0.__allocate(&self._ptr)
        self._is_ptr_owner = True
        attribs = self.PROPERTIES()
        used_attribs = set()
        if len(args) > len(attribs):
            raise ValueError("More positional arguments specified than this type has properties.")
        for i,v in enumerate(args):
            setattr(self,attribs[i],v)
            used_attribs.add(attribs[i])
        valid_names = ", ".join(["'"+p+"'" for p in attribs])
        for k,v in kwargs.items():
            if k in used_attribs:
                raise KeyError(f"argument '{k}' has already been specified as positional argument.")
            elif k not in attribs:
                raise KeyError(f"'{k}' is no valid property name. Valid names: {valid_names}")
            setattr(self,k,v)
    def get_value(self, i):
        """Get value ``value`` of ``(<chip.hipExternalSemaphoreWaitParams_st_struct_0_struct_0*>self._ptr)[i]``.
        """
        return (<chip.hipExternalSemaphoreWaitParams_st_struct_0_struct_0*>self._ptr)[i].value
    def set_value(self, i, unsigned long long value):
        """Set value ``value`` of ``(<chip.hipExternalSemaphoreWaitParams_st_struct_0_struct_0*>self._ptr)[i]``.
        """
        (<chip.hipExternalSemaphoreWaitParams_st_struct_0_struct_0*>self._ptr)[i].value = value
    @property
    def value(self):
        """(undocumented)"""
        return self.get_value(0)
    @value.setter
    def value(self, unsigned long long value):
        self.set_value(0,value)

    @staticmethod
    def PROPERTIES():
        return ["value"]

    def __contains__(self,item):
        properties = self.PROPERTIES()
        return item in properties

    def __getitem__(self,item):
        properties = self.PROPERTIES()
        if isinstance(item,int):
            if item < 0 or item >= len(properties):
                raise IndexError()
            return getattr(self,properties[item])
        raise ValueError("'item' type must be 'int'")


cdef class hipExternalSemaphoreWaitParams_st_struct_0_union_0(hip._util.types.Pointer):
    """Python wrapper for cdef class chip.hipExternalSemaphoreWaitParams_st_struct_0_union_0.

    Python wrapper for cdef class chip.hipExternalSemaphoreWaitParams_st_struct_0_union_0.

    If this type is initialized via its `__init__` method, it allocates a
    member of the underlying C type and destroys it again if the wrapper
    type is deallocated.

    This type also serves as adapter when appearing as argument type in a
    function signature. In this case, the type can further be initialized
    from a number of Python objects:

    * `None`:

      This will set the ``self._ptr`` attribute to ``NULL``.

    * `int`:

      Interprets the integer value as pointer address and writes it to ``self._ptr``.
      No ownership is transferred.

    * `ctypes.c_void_p`:

      Takes the pointer address ``pyobj.value`` and writes it to ``self._ptr``.
      No ownership is transferred.

    * `object` that implements the `CUDA Array Interface <https://numba.readthedocs.io/en/stable/cuda/cuda_array_interface.html>`_ protocol:

      Takes the integer-valued pointer address, i.e. the first entry of the `data` tuple
      from `pyobj`'s member ``__cuda_array_interface__``  and writes it to ``self._ptr``.

    * `object` that implements the Python buffer protocol:

      If the object represents a simple contiguous array,
      writes the `Py_buffer` associated with ``pyobj`` to `self._py_buffer`,
      sets the `self._py_buffer_acquired` flag to `True`, and
      writes `self._py_buffer.buf` to the data pointer `self._ptr`.

    * `hip._util.types.Pointer`:

      Takes the pointer address ``pyobj._ptr`` and writes it to ``self._ptr``.
      No ownership is transferred.

    Type checks are performed in the above order.

    C Attributes:
        _ptr (C type ``void *``, protected):
            Stores a pointer to the data of the original Python object.
        _is_ptr_owner (C type ``bint``, protected):
            If this wrapper is the owner of the underlying data.
        _py_buffer (C type ``Py_buffer`, protected):
            Stores a pointer to the data of the original Python object.
        _py_buffer_acquired (C type ``bint``, protected):
            Stores a pointer to the data of the original Python object.
    """
    # C members declared in pxd file

    def __cinit__(self):
        self._ptr = NULL
        self._is_ptr_owner = False
        self._py_buffer_acquired = False

    cdef chip.hipExternalSemaphoreWaitParams_st_struct_0_union_0* getElementPtr(self):
        return <chip.hipExternalSemaphoreWaitParams_st_struct_0_union_0*>self._ptr

    @staticmethod
    cdef hipExternalSemaphoreWaitParams_st_struct_0_union_0 fromPtr(void* ptr, bint owner=False):
        """Factory function to create ``hipExternalSemaphoreWaitParams_st_struct_0_union_0`` objects from
        given ``chip.hipExternalSemaphoreWaitParams_st_struct_0_union_0`` pointer.

        Setting ``owner`` flag to ``True`` causes
        the extension type to free the structure pointed to by ``ptr``
        when the wrapper object is deallocated.
        """
        # Fast call to __new__() that bypasses the __init__() constructor.
        cdef hipExternalSemaphoreWaitParams_st_struct_0_union_0 wrapper = hipExternalSemaphoreWaitParams_st_struct_0_union_0.__new__(hipExternalSemaphoreWaitParams_st_struct_0_union_0)
        wrapper._ptr = ptr
        wrapper._is_ptr_owner = owner
        return wrapper

    @staticmethod
    def fromObj(pyobj):
        """Creates a hipExternalSemaphoreWaitParams_st_struct_0_union_0 from a Python object.

        Derives a hipExternalSemaphoreWaitParams_st_struct_0_union_0 from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``hipExternalSemaphoreWaitParams_st_struct_0_union_0`` reference, this method
        returns it directly. No new ``hipExternalSemaphoreWaitParams_st_struct_0_union_0`` is created in this case.
        """
        return hipExternalSemaphoreWaitParams_st_struct_0_union_0.fromPyobj(pyobj)

    @staticmethod
    cdef hipExternalSemaphoreWaitParams_st_struct_0_union_0 fromPyobj(object pyobj):
        """Creates a hipExternalSemaphoreWaitParams_st_struct_0_union_0 from a Python object.

        Derives a hipExternalSemaphoreWaitParams_st_struct_0_union_0 from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``hipExternalSemaphoreWaitParams_st_struct_0_union_0`` reference, this method
        returns it directly. No new ``hipExternalSemaphoreWaitParams_st_struct_0_union_0`` is created in this case.

        Args:
            pyobj (object): Must be either `None`; a `hip._util.types.Pointer`; a simple, contiguous buffer according to the buffer protocol;
                            or of type `hipExternalSemaphoreWaitParams_st_struct_0_union_0`; `int`; or `ctypes.c_void_p`.

        Note:
            This routine does not perform a copy but returns the original ``pyobj``
            if ``pyobj`` is an instance of hipExternalSemaphoreWaitParams_st_struct_0_union_0!
        """
        cdef hipExternalSemaphoreWaitParams_st_struct_0_union_0 wrapper

        if isinstance(pyobj,hipExternalSemaphoreWaitParams_st_struct_0_union_0):
            return pyobj
        else:
            wrapper = hipExternalSemaphoreWaitParams_st_struct_0_union_0.__new__(hipExternalSemaphoreWaitParams_st_struct_0_union_0)
            wrapper.init_from_pyobj(pyobj)
            return wrapper

    def __dealloc__(self):
        # Release the buffer handle
        if self._py_buffer_acquired is True:
            cpython.buffer.PyBuffer_Release(&self._py_buffer)
        # De-allocate if not null and flag is set
        if self._ptr is not NULL and self._is_ptr_owner is True:
            stdlib.free(self._ptr)
            self._ptr = NULL

    @staticmethod
    cdef __allocate(void** ptr):
        ptr[0] = stdlib.malloc(sizeof(chip.hipExternalSemaphoreWaitParams_st_struct_0_union_0))
        string.memset(<void*>ptr[0], 0, sizeof(chip.hipExternalSemaphoreWaitParams_st_struct_0_union_0))

        if ptr[0] is NULL:
            raise MemoryError

    @staticmethod
    cdef hipExternalSemaphoreWaitParams_st_struct_0_union_0 new():
        """Factory function to create hipExternalSemaphoreWaitParams_st_struct_0_union_0 objects with
        newly allocated chip.hipExternalSemaphoreWaitParams_st_struct_0_union_0"""
        cdef void* ptr
        hipExternalSemaphoreWaitParams_st_struct_0_union_0.__allocate(&ptr)
        return hipExternalSemaphoreWaitParams_st_struct_0_union_0.fromPtr(ptr, owner=True)

    @staticmethod
    cdef hipExternalSemaphoreWaitParams_st_struct_0_union_0 fromValue(chip.hipExternalSemaphoreWaitParams_st_struct_0_union_0 other):
        """Allocate new C type and copy from ``other``.
        """
        wrapper = hipExternalSemaphoreWaitParams_st_struct_0_union_0.new()
        string.memcpy(wrapper._ptr, &other, sizeof(chip.hipExternalSemaphoreWaitParams_st_struct_0_union_0))
        return wrapper

    def c_sizeof(self):
        """Returns the size of the underlying C type in bytes.
        Note:
            Implemented as function to not collide with
            autogenerated property names.
        """
        return sizeof(chip.hipExternalSemaphoreWaitParams_st_struct_0_union_0)

    def __int__(self):
        """Returns the data's address as long integer.
        """
        return cpython.long.PyLong_FromVoidPtr(self._ptr)

    def __repr__(self):
        return f"<hipExternalSemaphoreWaitParams_st_struct_0_union_0 object, ptr: {int(self)}>"

    def as_c_void_p(self):
        """Returns the data's address as `ctypes.c_void_p`
        Note:
            Implemented as function to not collide with
            autogenerated property names.
        """
        return ctypes.c_void_p(int(self))

    def __init__(self,**kwargs):
        """Constructor type hipExternalSemaphoreWaitParams_st_struct_0_union_0.

        Constructor for type hipExternalSemaphoreWaitParams_st_struct_0_union_0.

        Args:
            **kwargs:
                Can be used to initialize member variables at construction,
                Just pass an argument expression of the form <member>=<value>
                per member that you want to initialize.
        """
        hipExternalSemaphoreWaitParams_st_struct_0_union_0.__allocate(&self._ptr)
        self._is_ptr_owner = True
        attribs = self.PROPERTIES()
        used_attribs = set()
        if len(kwargs) > 1:
            raise ValueError("Not more than one attribute might specified for Python types derived from C union types.")
        valid_names = ", ".join(["'"+p+"'" for p in attribs])
        for k,v in kwargs.items():
            if k in used_attribs:
                raise KeyError(f"argument '{k}' has already been specified as positional argument.")
            elif k not in attribs:
                raise KeyError(f"'{k}' is no valid property name. Valid names: {valid_names}")
            setattr(self,k,v)
    def get_fence(self, i):
        """Get value ``fence`` of ``(<chip.hipExternalSemaphoreWaitParams_st_struct_0_union_0*>self._ptr)[i]``.
        """
        return hip._util.types.Pointer.fromPtr((<chip.hipExternalSemaphoreWaitParams_st_struct_0_union_0*>self._ptr)[i].fence)
    def set_fence(self, i, object value):
        """Set value ``fence`` of ``(<chip.hipExternalSemaphoreWaitParams_st_struct_0_union_0*>self._ptr)[i]``.

        Note:
            This can be dangerous if the pointer is from a python object
            that is later on garbage collected.
        """
        (<chip.hipExternalSemaphoreWaitParams_st_struct_0_union_0*>self._ptr)[i].fence = <void *>cpython.long.PyLong_AsVoidPtr(int(hip._util.types.Pointer.fromPyobj(value)))
    @property
    def fence(self):
        """(undocumented)
        Note:
            Setting this fence can be dangerous if the underlying pointer is from a python object that
            is later on garbage collected.
        """
        return self.get_fence(0)
    @fence.setter
    def fence(self, object value):
        self.set_fence(0,value)

    def get_reserved(self, i):
        """Get value ``reserved`` of ``(<chip.hipExternalSemaphoreWaitParams_st_struct_0_union_0*>self._ptr)[i]``.
        """
        return (<chip.hipExternalSemaphoreWaitParams_st_struct_0_union_0*>self._ptr)[i].reserved
    def set_reserved(self, i, unsigned long long value):
        """Set value ``reserved`` of ``(<chip.hipExternalSemaphoreWaitParams_st_struct_0_union_0*>self._ptr)[i]``.
        """
        (<chip.hipExternalSemaphoreWaitParams_st_struct_0_union_0*>self._ptr)[i].reserved = value
    @property
    def reserved(self):
        """(undocumented)"""
        return self.get_reserved(0)
    @reserved.setter
    def reserved(self, unsigned long long value):
        self.set_reserved(0,value)

    @staticmethod
    def PROPERTIES():
        return ["fence","reserved"]


cdef class hipExternalSemaphoreWaitParams_st_struct_0_struct_1(hip._util.types.Pointer):
    """Python wrapper for cdef class chip.hipExternalSemaphoreWaitParams_st_struct_0_struct_1.

    Python wrapper for cdef class chip.hipExternalSemaphoreWaitParams_st_struct_0_struct_1.

    If this type is initialized via its `__init__` method, it allocates a
    member of the underlying C type and destroys it again if the wrapper
    type is deallocated.

    This type also serves as adapter when appearing as argument type in a
    function signature. In this case, the type can further be initialized
    from a number of Python objects:

    * `None`:

      This will set the ``self._ptr`` attribute to ``NULL``.

    * `int`:

      Interprets the integer value as pointer address and writes it to ``self._ptr``.
      No ownership is transferred.

    * `ctypes.c_void_p`:

      Takes the pointer address ``pyobj.value`` and writes it to ``self._ptr``.
      No ownership is transferred.

    * `object` that implements the `CUDA Array Interface <https://numba.readthedocs.io/en/stable/cuda/cuda_array_interface.html>`_ protocol:

      Takes the integer-valued pointer address, i.e. the first entry of the `data` tuple
      from `pyobj`'s member ``__cuda_array_interface__``  and writes it to ``self._ptr``.

    * `object` that implements the Python buffer protocol:

      If the object represents a simple contiguous array,
      writes the `Py_buffer` associated with ``pyobj`` to `self._py_buffer`,
      sets the `self._py_buffer_acquired` flag to `True`, and
      writes `self._py_buffer.buf` to the data pointer `self._ptr`.

    * `hip._util.types.Pointer`:

      Takes the pointer address ``pyobj._ptr`` and writes it to ``self._ptr``.
      No ownership is transferred.

    Type checks are performed in the above order.

    C Attributes:
        _ptr (C type ``void *``, protected):
            Stores a pointer to the data of the original Python object.
        _is_ptr_owner (C type ``bint``, protected):
            If this wrapper is the owner of the underlying data.
        _py_buffer (C type ``Py_buffer`, protected):
            Stores a pointer to the data of the original Python object.
        _py_buffer_acquired (C type ``bint``, protected):
            Stores a pointer to the data of the original Python object.
    """
    # C members declared in pxd file

    def __cinit__(self):
        self._ptr = NULL
        self._is_ptr_owner = False
        self._py_buffer_acquired = False

    cdef chip.hipExternalSemaphoreWaitParams_st_struct_0_struct_1* getElementPtr(self):
        return <chip.hipExternalSemaphoreWaitParams_st_struct_0_struct_1*>self._ptr

    @staticmethod
    cdef hipExternalSemaphoreWaitParams_st_struct_0_struct_1 fromPtr(void* ptr, bint owner=False):
        """Factory function to create ``hipExternalSemaphoreWaitParams_st_struct_0_struct_1`` objects from
        given ``chip.hipExternalSemaphoreWaitParams_st_struct_0_struct_1`` pointer.

        Setting ``owner`` flag to ``True`` causes
        the extension type to free the structure pointed to by ``ptr``
        when the wrapper object is deallocated.
        """
        # Fast call to __new__() that bypasses the __init__() constructor.
        cdef hipExternalSemaphoreWaitParams_st_struct_0_struct_1 wrapper = hipExternalSemaphoreWaitParams_st_struct_0_struct_1.__new__(hipExternalSemaphoreWaitParams_st_struct_0_struct_1)
        wrapper._ptr = ptr
        wrapper._is_ptr_owner = owner
        return wrapper

    @staticmethod
    def fromObj(pyobj):
        """Creates a hipExternalSemaphoreWaitParams_st_struct_0_struct_1 from a Python object.

        Derives a hipExternalSemaphoreWaitParams_st_struct_0_struct_1 from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``hipExternalSemaphoreWaitParams_st_struct_0_struct_1`` reference, this method
        returns it directly. No new ``hipExternalSemaphoreWaitParams_st_struct_0_struct_1`` is created in this case.
        """
        return hipExternalSemaphoreWaitParams_st_struct_0_struct_1.fromPyobj(pyobj)

    @staticmethod
    cdef hipExternalSemaphoreWaitParams_st_struct_0_struct_1 fromPyobj(object pyobj):
        """Creates a hipExternalSemaphoreWaitParams_st_struct_0_struct_1 from a Python object.

        Derives a hipExternalSemaphoreWaitParams_st_struct_0_struct_1 from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``hipExternalSemaphoreWaitParams_st_struct_0_struct_1`` reference, this method
        returns it directly. No new ``hipExternalSemaphoreWaitParams_st_struct_0_struct_1`` is created in this case.

        Args:
            pyobj (object): Must be either `None`; a `hip._util.types.Pointer`; a simple, contiguous buffer according to the buffer protocol;
                            or of type `hipExternalSemaphoreWaitParams_st_struct_0_struct_1`; `int`; or `ctypes.c_void_p`.

        Note:
            This routine does not perform a copy but returns the original ``pyobj``
            if ``pyobj`` is an instance of hipExternalSemaphoreWaitParams_st_struct_0_struct_1!
        """
        cdef hipExternalSemaphoreWaitParams_st_struct_0_struct_1 wrapper

        if isinstance(pyobj,hipExternalSemaphoreWaitParams_st_struct_0_struct_1):
            return pyobj
        else:
            wrapper = hipExternalSemaphoreWaitParams_st_struct_0_struct_1.__new__(hipExternalSemaphoreWaitParams_st_struct_0_struct_1)
            wrapper.init_from_pyobj(pyobj)
            return wrapper

    def __dealloc__(self):
        # Release the buffer handle
        if self._py_buffer_acquired is True:
            cpython.buffer.PyBuffer_Release(&self._py_buffer)
        # De-allocate if not null and flag is set
        if self._ptr is not NULL and self._is_ptr_owner is True:
            stdlib.free(self._ptr)
            self._ptr = NULL

    @staticmethod
    cdef __allocate(void** ptr):
        ptr[0] = stdlib.malloc(sizeof(chip.hipExternalSemaphoreWaitParams_st_struct_0_struct_1))
        string.memset(<void*>ptr[0], 0, sizeof(chip.hipExternalSemaphoreWaitParams_st_struct_0_struct_1))

        if ptr[0] is NULL:
            raise MemoryError

    @staticmethod
    cdef hipExternalSemaphoreWaitParams_st_struct_0_struct_1 new():
        """Factory function to create hipExternalSemaphoreWaitParams_st_struct_0_struct_1 objects with
        newly allocated chip.hipExternalSemaphoreWaitParams_st_struct_0_struct_1"""
        cdef void* ptr
        hipExternalSemaphoreWaitParams_st_struct_0_struct_1.__allocate(&ptr)
        return hipExternalSemaphoreWaitParams_st_struct_0_struct_1.fromPtr(ptr, owner=True)

    @staticmethod
    cdef hipExternalSemaphoreWaitParams_st_struct_0_struct_1 fromValue(chip.hipExternalSemaphoreWaitParams_st_struct_0_struct_1 other):
        """Allocate new C type and copy from ``other``.
        """
        wrapper = hipExternalSemaphoreWaitParams_st_struct_0_struct_1.new()
        string.memcpy(wrapper._ptr, &other, sizeof(chip.hipExternalSemaphoreWaitParams_st_struct_0_struct_1))
        return wrapper

    def c_sizeof(self):
        """Returns the size of the underlying C type in bytes.
        Note:
            Implemented as function to not collide with
            autogenerated property names.
        """
        return sizeof(chip.hipExternalSemaphoreWaitParams_st_struct_0_struct_1)

    def __int__(self):
        """Returns the data's address as long integer.
        """
        return cpython.long.PyLong_FromVoidPtr(self._ptr)

    def __repr__(self):
        return f"<hipExternalSemaphoreWaitParams_st_struct_0_struct_1 object, ptr: {int(self)}>"

    def as_c_void_p(self):
        """Returns the data's address as `ctypes.c_void_p`
        Note:
            Implemented as function to not collide with
            autogenerated property names.
        """
        return ctypes.c_void_p(int(self))

    def __init__(self,*args,**kwargs):
        """Constructor type hipExternalSemaphoreWaitParams_st_struct_0_struct_1.

        Constructor for type hipExternalSemaphoreWaitParams_st_struct_0_struct_1.

        Args:
            *args:
                Positional arguments. Initialize all or a subset of the member variables
                according to their order of declaration.
            **kwargs:
                Can be used to initialize member variables at construction,
                Just pass an argument expression of the form <member>=<value>
                per member that you want to initialize.
        """
        hipExternalSemaphoreWaitParams_st_struct_0_struct_1.__allocate(&self._ptr)
        self._is_ptr_owner = True
        attribs = self.PROPERTIES()
        used_attribs = set()
        if len(args) > len(attribs):
            raise ValueError("More positional arguments specified than this type has properties.")
        for i,v in enumerate(args):
            setattr(self,attribs[i],v)
            used_attribs.add(attribs[i])
        valid_names = ", ".join(["'"+p+"'" for p in attribs])
        for k,v in kwargs.items():
            if k in used_attribs:
                raise KeyError(f"argument '{k}' has already been specified as positional argument.")
            elif k not in attribs:
                raise KeyError(f"'{k}' is no valid property name. Valid names: {valid_names}")
            setattr(self,k,v)
    def get_key(self, i):
        """Get value ``key`` of ``(<chip.hipExternalSemaphoreWaitParams_st_struct_0_struct_1*>self._ptr)[i]``.
        """
        return (<chip.hipExternalSemaphoreWaitParams_st_struct_0_struct_1*>self._ptr)[i].key
    def set_key(self, i, unsigned long long value):
        """Set value ``key`` of ``(<chip.hipExternalSemaphoreWaitParams_st_struct_0_struct_1*>self._ptr)[i]``.
        """
        (<chip.hipExternalSemaphoreWaitParams_st_struct_0_struct_1*>self._ptr)[i].key = value
    @property
    def key(self):
        """(undocumented)"""
        return self.get_key(0)
    @key.setter
    def key(self, unsigned long long value):
        self.set_key(0,value)

    def get_timeoutMs(self, i):
        """Get value ``timeoutMs`` of ``(<chip.hipExternalSemaphoreWaitParams_st_struct_0_struct_1*>self._ptr)[i]``.
        """
        return (<chip.hipExternalSemaphoreWaitParams_st_struct_0_struct_1*>self._ptr)[i].timeoutMs
    def set_timeoutMs(self, i, unsigned int value):
        """Set value ``timeoutMs`` of ``(<chip.hipExternalSemaphoreWaitParams_st_struct_0_struct_1*>self._ptr)[i]``.
        """
        (<chip.hipExternalSemaphoreWaitParams_st_struct_0_struct_1*>self._ptr)[i].timeoutMs = value
    @property
    def timeoutMs(self):
        """(undocumented)"""
        return self.get_timeoutMs(0)
    @timeoutMs.setter
    def timeoutMs(self, unsigned int value):
        self.set_timeoutMs(0,value)

    @staticmethod
    def PROPERTIES():
        return ["key","timeoutMs"]

    def __contains__(self,item):
        properties = self.PROPERTIES()
        return item in properties

    def __getitem__(self,item):
        properties = self.PROPERTIES()
        if isinstance(item,int):
            if item < 0 or item >= len(properties):
                raise IndexError()
            return getattr(self,properties[item])
        raise ValueError("'item' type must be 'int'")


cdef class hipExternalSemaphoreWaitParams_st_struct_0(hip._util.types.Pointer):
    """Python wrapper for cdef class chip.hipExternalSemaphoreWaitParams_st_struct_0.

    Python wrapper for cdef class chip.hipExternalSemaphoreWaitParams_st_struct_0.

    If this type is initialized via its `__init__` method, it allocates a
    member of the underlying C type and destroys it again if the wrapper
    type is deallocated.

    This type also serves as adapter when appearing as argument type in a
    function signature. In this case, the type can further be initialized
    from a number of Python objects:

    * `None`:

      This will set the ``self._ptr`` attribute to ``NULL``.

    * `int`:

      Interprets the integer value as pointer address and writes it to ``self._ptr``.
      No ownership is transferred.

    * `ctypes.c_void_p`:

      Takes the pointer address ``pyobj.value`` and writes it to ``self._ptr``.
      No ownership is transferred.

    * `object` that implements the `CUDA Array Interface <https://numba.readthedocs.io/en/stable/cuda/cuda_array_interface.html>`_ protocol:

      Takes the integer-valued pointer address, i.e. the first entry of the `data` tuple
      from `pyobj`'s member ``__cuda_array_interface__``  and writes it to ``self._ptr``.

    * `object` that implements the Python buffer protocol:

      If the object represents a simple contiguous array,
      writes the `Py_buffer` associated with ``pyobj`` to `self._py_buffer`,
      sets the `self._py_buffer_acquired` flag to `True`, and
      writes `self._py_buffer.buf` to the data pointer `self._ptr`.

    * `hip._util.types.Pointer`:

      Takes the pointer address ``pyobj._ptr`` and writes it to ``self._ptr``.
      No ownership is transferred.

    Type checks are performed in the above order.

    C Attributes:
        _ptr (C type ``void *``, protected):
            Stores a pointer to the data of the original Python object.
        _is_ptr_owner (C type ``bint``, protected):
            If this wrapper is the owner of the underlying data.
        _py_buffer (C type ``Py_buffer`, protected):
            Stores a pointer to the data of the original Python object.
        _py_buffer_acquired (C type ``bint``, protected):
            Stores a pointer to the data of the original Python object.
    """
    # C members declared in pxd file

    def __cinit__(self):
        self._ptr = NULL
        self._is_ptr_owner = False
        self._py_buffer_acquired = False

    cdef chip.hipExternalSemaphoreWaitParams_st_struct_0* getElementPtr(self):
        return <chip.hipExternalSemaphoreWaitParams_st_struct_0*>self._ptr

    @staticmethod
    cdef hipExternalSemaphoreWaitParams_st_struct_0 fromPtr(void* ptr, bint owner=False):
        """Factory function to create ``hipExternalSemaphoreWaitParams_st_struct_0`` objects from
        given ``chip.hipExternalSemaphoreWaitParams_st_struct_0`` pointer.

        Setting ``owner`` flag to ``True`` causes
        the extension type to free the structure pointed to by ``ptr``
        when the wrapper object is deallocated.
        """
        # Fast call to __new__() that bypasses the __init__() constructor.
        cdef hipExternalSemaphoreWaitParams_st_struct_0 wrapper = hipExternalSemaphoreWaitParams_st_struct_0.__new__(hipExternalSemaphoreWaitParams_st_struct_0)
        wrapper._ptr = ptr
        wrapper._is_ptr_owner = owner
        return wrapper

    @staticmethod
    def fromObj(pyobj):
        """Creates a hipExternalSemaphoreWaitParams_st_struct_0 from a Python object.

        Derives a hipExternalSemaphoreWaitParams_st_struct_0 from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``hipExternalSemaphoreWaitParams_st_struct_0`` reference, this method
        returns it directly. No new ``hipExternalSemaphoreWaitParams_st_struct_0`` is created in this case.
        """
        return hipExternalSemaphoreWaitParams_st_struct_0.fromPyobj(pyobj)

    @staticmethod
    cdef hipExternalSemaphoreWaitParams_st_struct_0 fromPyobj(object pyobj):
        """Creates a hipExternalSemaphoreWaitParams_st_struct_0 from a Python object.

        Derives a hipExternalSemaphoreWaitParams_st_struct_0 from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``hipExternalSemaphoreWaitParams_st_struct_0`` reference, this method
        returns it directly. No new ``hipExternalSemaphoreWaitParams_st_struct_0`` is created in this case.

        Args:
            pyobj (object): Must be either `None`; a `hip._util.types.Pointer`; a simple, contiguous buffer according to the buffer protocol;
                            or of type `hipExternalSemaphoreWaitParams_st_struct_0`; `int`; or `ctypes.c_void_p`.

        Note:
            This routine does not perform a copy but returns the original ``pyobj``
            if ``pyobj`` is an instance of hipExternalSemaphoreWaitParams_st_struct_0!
        """
        cdef hipExternalSemaphoreWaitParams_st_struct_0 wrapper

        if isinstance(pyobj,hipExternalSemaphoreWaitParams_st_struct_0):
            return pyobj
        else:
            wrapper = hipExternalSemaphoreWaitParams_st_struct_0.__new__(hipExternalSemaphoreWaitParams_st_struct_0)
            wrapper.init_from_pyobj(pyobj)
            return wrapper

    def __dealloc__(self):
        # Release the buffer handle
        if self._py_buffer_acquired is True:
            cpython.buffer.PyBuffer_Release(&self._py_buffer)
        # De-allocate if not null and flag is set
        if self._ptr is not NULL and self._is_ptr_owner is True:
            stdlib.free(self._ptr)
            self._ptr = NULL

    @staticmethod
    cdef __allocate(void** ptr):
        ptr[0] = stdlib.malloc(sizeof(chip.hipExternalSemaphoreWaitParams_st_struct_0))
        string.memset(<void*>ptr[0], 0, sizeof(chip.hipExternalSemaphoreWaitParams_st_struct_0))

        if ptr[0] is NULL:
            raise MemoryError

    @staticmethod
    cdef hipExternalSemaphoreWaitParams_st_struct_0 new():
        """Factory function to create hipExternalSemaphoreWaitParams_st_struct_0 objects with
        newly allocated chip.hipExternalSemaphoreWaitParams_st_struct_0"""
        cdef void* ptr
        hipExternalSemaphoreWaitParams_st_struct_0.__allocate(&ptr)
        return hipExternalSemaphoreWaitParams_st_struct_0.fromPtr(ptr, owner=True)

    @staticmethod
    cdef hipExternalSemaphoreWaitParams_st_struct_0 fromValue(chip.hipExternalSemaphoreWaitParams_st_struct_0 other):
        """Allocate new C type and copy from ``other``.
        """
        wrapper = hipExternalSemaphoreWaitParams_st_struct_0.new()
        string.memcpy(wrapper._ptr, &other, sizeof(chip.hipExternalSemaphoreWaitParams_st_struct_0))
        return wrapper

    def c_sizeof(self):
        """Returns the size of the underlying C type in bytes.
        Note:
            Implemented as function to not collide with
            autogenerated property names.
        """
        return sizeof(chip.hipExternalSemaphoreWaitParams_st_struct_0)

    def __int__(self):
        """Returns the data's address as long integer.
        """
        return cpython.long.PyLong_FromVoidPtr(self._ptr)

    def __repr__(self):
        return f"<hipExternalSemaphoreWaitParams_st_struct_0 object, ptr: {int(self)}>"

    def as_c_void_p(self):
        """Returns the data's address as `ctypes.c_void_p`
        Note:
            Implemented as function to not collide with
            autogenerated property names.
        """
        return ctypes.c_void_p(int(self))

    def __init__(self,*args,**kwargs):
        """Constructor type hipExternalSemaphoreWaitParams_st_struct_0.

        Constructor for type hipExternalSemaphoreWaitParams_st_struct_0.

        Args:
            *args:
                Positional arguments. Initialize all or a subset of the member variables
                according to their order of declaration.
            **kwargs:
                Can be used to initialize member variables at construction,
                Just pass an argument expression of the form <member>=<value>
                per member that you want to initialize.
        """
        hipExternalSemaphoreWaitParams_st_struct_0.__allocate(&self._ptr)
        self._is_ptr_owner = True
        attribs = self.PROPERTIES()
        used_attribs = set()
        if len(args) > len(attribs):
            raise ValueError("More positional arguments specified than this type has properties.")
        for i,v in enumerate(args):
            setattr(self,attribs[i],v)
            used_attribs.add(attribs[i])
        valid_names = ", ".join(["'"+p+"'" for p in attribs])
        for k,v in kwargs.items():
            if k in used_attribs:
                raise KeyError(f"argument '{k}' has already been specified as positional argument.")
            elif k not in attribs:
                raise KeyError(f"'{k}' is no valid property name. Valid names: {valid_names}")
            setattr(self,k,v)
    def get_fence(self, i):
        """Get value of ``fence`` of ``(<chip.hipExternalSemaphoreWaitParams_st_struct_0*>self._ptr)[i]``.
        """
        return hipExternalSemaphoreWaitParams_st_struct_0_struct_0.fromPtr(&(<chip.hipExternalSemaphoreWaitParams_st_struct_0*>self._ptr)[i].fence)
    @property
    def fence(self):
        """(undocumented)"""
        return self.get_fence(0)

    def get_nvSciSync(self, i):
        """Get value of ``nvSciSync`` of ``(<chip.hipExternalSemaphoreWaitParams_st_struct_0*>self._ptr)[i]``.
        """
        return hipExternalSemaphoreWaitParams_st_struct_0_union_0.fromPtr(&(<chip.hipExternalSemaphoreWaitParams_st_struct_0*>self._ptr)[i].nvSciSync)
    @property
    def nvSciSync(self):
        """(undocumented)"""
        return self.get_nvSciSync(0)

    def get_keyedMutex(self, i):
        """Get value of ``keyedMutex`` of ``(<chip.hipExternalSemaphoreWaitParams_st_struct_0*>self._ptr)[i]``.
        """
        return hipExternalSemaphoreWaitParams_st_struct_0_struct_1.fromPtr(&(<chip.hipExternalSemaphoreWaitParams_st_struct_0*>self._ptr)[i].keyedMutex)
    @property
    def keyedMutex(self):
        """(undocumented)"""
        return self.get_keyedMutex(0)

    def get_reserved(self, i):
        """Get value of ``reserved`` of ``(<chip.hipExternalSemaphoreWaitParams_st_struct_0*>self._ptr)[i]``.
        """
        return (<chip.hipExternalSemaphoreWaitParams_st_struct_0*>self._ptr)[i].reserved
    # TODO add setters
    #def set_reserved(self, i, unsigned int[10] value):
    #    """Set value ``reserved`` of ``(<chip.hipExternalSemaphoreWaitParams_st_struct_0*>self._ptr)[i]``.
    #    """
    #    (<chip.hipExternalSemaphoreWaitParams_st_struct_0*>self._ptr)[i].reserved = value
    @property
    def reserved(self):
        """(undocumented)"""
        return self.get_reserved(0)
    # TODO add setters
    #@reserved.setter
    #def reserved(self, unsigned int[10] value):
    #    self.set_reserved(0,value)

    @staticmethod
    def PROPERTIES():
        return ["fence","nvSciSync","keyedMutex","reserved"]

    def __contains__(self,item):
        properties = self.PROPERTIES()
        return item in properties

    def __getitem__(self,item):
        properties = self.PROPERTIES()
        if isinstance(item,int):
            if item < 0 or item >= len(properties):
                raise IndexError()
            return getattr(self,properties[item])
        raise ValueError("'item' type must be 'int'")


cdef class hipExternalSemaphoreWaitParams_st(hip._util.types.Pointer):
    """Python wrapper for cdef class chip.hipExternalSemaphoreWaitParams_st.

    Python wrapper for cdef class chip.hipExternalSemaphoreWaitParams_st.

    If this type is initialized via its `__init__` method, it allocates a
    member of the underlying C type and destroys it again if the wrapper
    type is deallocated.

    This type also serves as adapter when appearing as argument type in a
    function signature. In this case, the type can further be initialized
    from a number of Python objects:

    * `None`:

      This will set the ``self._ptr`` attribute to ``NULL``.

    * `int`:

      Interprets the integer value as pointer address and writes it to ``self._ptr``.
      No ownership is transferred.

    * `ctypes.c_void_p`:

      Takes the pointer address ``pyobj.value`` and writes it to ``self._ptr``.
      No ownership is transferred.

    * `object` that implements the `CUDA Array Interface <https://numba.readthedocs.io/en/stable/cuda/cuda_array_interface.html>`_ protocol:

      Takes the integer-valued pointer address, i.e. the first entry of the `data` tuple
      from `pyobj`'s member ``__cuda_array_interface__``  and writes it to ``self._ptr``.

    * `object` that implements the Python buffer protocol:

      If the object represents a simple contiguous array,
      writes the `Py_buffer` associated with ``pyobj`` to `self._py_buffer`,
      sets the `self._py_buffer_acquired` flag to `True`, and
      writes `self._py_buffer.buf` to the data pointer `self._ptr`.

    * `hip._util.types.Pointer`:

      Takes the pointer address ``pyobj._ptr`` and writes it to ``self._ptr``.
      No ownership is transferred.

    Type checks are performed in the above order.

    C Attributes:
        _ptr (C type ``void *``, protected):
            Stores a pointer to the data of the original Python object.
        _is_ptr_owner (C type ``bint``, protected):
            If this wrapper is the owner of the underlying data.
        _py_buffer (C type ``Py_buffer`, protected):
            Stores a pointer to the data of the original Python object.
        _py_buffer_acquired (C type ``bint``, protected):
            Stores a pointer to the data of the original Python object.
    """
    # C members declared in pxd file

    def __cinit__(self):
        self._ptr = NULL
        self._is_ptr_owner = False
        self._py_buffer_acquired = False

    cdef chip.hipExternalSemaphoreWaitParams_st* getElementPtr(self):
        return <chip.hipExternalSemaphoreWaitParams_st*>self._ptr

    @staticmethod
    cdef hipExternalSemaphoreWaitParams_st fromPtr(void* ptr, bint owner=False):
        """Factory function to create ``hipExternalSemaphoreWaitParams_st`` objects from
        given ``chip.hipExternalSemaphoreWaitParams_st`` pointer.

        Setting ``owner`` flag to ``True`` causes
        the extension type to free the structure pointed to by ``ptr``
        when the wrapper object is deallocated.
        """
        # Fast call to __new__() that bypasses the __init__() constructor.
        cdef hipExternalSemaphoreWaitParams_st wrapper = hipExternalSemaphoreWaitParams_st.__new__(hipExternalSemaphoreWaitParams_st)
        wrapper._ptr = ptr
        wrapper._is_ptr_owner = owner
        return wrapper

    @staticmethod
    def fromObj(pyobj):
        """Creates a hipExternalSemaphoreWaitParams_st from a Python object.

        Derives a hipExternalSemaphoreWaitParams_st from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``hipExternalSemaphoreWaitParams_st`` reference, this method
        returns it directly. No new ``hipExternalSemaphoreWaitParams_st`` is created in this case.
        """
        return hipExternalSemaphoreWaitParams_st.fromPyobj(pyobj)

    @staticmethod
    cdef hipExternalSemaphoreWaitParams_st fromPyobj(object pyobj):
        """Creates a hipExternalSemaphoreWaitParams_st from a Python object.

        Derives a hipExternalSemaphoreWaitParams_st from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``hipExternalSemaphoreWaitParams_st`` reference, this method
        returns it directly. No new ``hipExternalSemaphoreWaitParams_st`` is created in this case.

        Args:
            pyobj (object): Must be either `None`; a `hip._util.types.Pointer`; a simple, contiguous buffer according to the buffer protocol;
                            or of type `hipExternalSemaphoreWaitParams_st`; `int`; or `ctypes.c_void_p`.

        Note:
            This routine does not perform a copy but returns the original ``pyobj``
            if ``pyobj`` is an instance of hipExternalSemaphoreWaitParams_st!
        """
        cdef hipExternalSemaphoreWaitParams_st wrapper

        if isinstance(pyobj,hipExternalSemaphoreWaitParams_st):
            return pyobj
        else:
            wrapper = hipExternalSemaphoreWaitParams_st.__new__(hipExternalSemaphoreWaitParams_st)
            wrapper.init_from_pyobj(pyobj)
            return wrapper

    def __dealloc__(self):
        # Release the buffer handle
        if self._py_buffer_acquired is True:
            cpython.buffer.PyBuffer_Release(&self._py_buffer)
        # De-allocate if not null and flag is set
        if self._ptr is not NULL and self._is_ptr_owner is True:
            stdlib.free(self._ptr)
            self._ptr = NULL

    @staticmethod
    cdef __allocate(void** ptr):
        ptr[0] = stdlib.malloc(sizeof(chip.hipExternalSemaphoreWaitParams_st))
        string.memset(<void*>ptr[0], 0, sizeof(chip.hipExternalSemaphoreWaitParams_st))

        if ptr[0] is NULL:
            raise MemoryError

    @staticmethod
    cdef hipExternalSemaphoreWaitParams_st new():
        """Factory function to create hipExternalSemaphoreWaitParams_st objects with
        newly allocated chip.hipExternalSemaphoreWaitParams_st"""
        cdef void* ptr
        hipExternalSemaphoreWaitParams_st.__allocate(&ptr)
        return hipExternalSemaphoreWaitParams_st.fromPtr(ptr, owner=True)

    @staticmethod
    cdef hipExternalSemaphoreWaitParams_st fromValue(chip.hipExternalSemaphoreWaitParams_st other):
        """Allocate new C type and copy from ``other``.
        """
        wrapper = hipExternalSemaphoreWaitParams_st.new()
        string.memcpy(wrapper._ptr, &other, sizeof(chip.hipExternalSemaphoreWaitParams_st))
        return wrapper

    def c_sizeof(self):
        """Returns the size of the underlying C type in bytes.
        Note:
            Implemented as function to not collide with
            autogenerated property names.
        """
        return sizeof(chip.hipExternalSemaphoreWaitParams_st)

    def __int__(self):
        """Returns the data's address as long integer.
        """
        return cpython.long.PyLong_FromVoidPtr(self._ptr)

    def __repr__(self):
        return f"<hipExternalSemaphoreWaitParams_st object, ptr: {int(self)}>"

    def as_c_void_p(self):
        """Returns the data's address as `ctypes.c_void_p`
        Note:
            Implemented as function to not collide with
            autogenerated property names.
        """
        return ctypes.c_void_p(int(self))

    def __init__(self,*args,**kwargs):
        """Constructor type hipExternalSemaphoreWaitParams_st.

        Constructor for type hipExternalSemaphoreWaitParams_st.

        Args:
            *args:
                Positional arguments. Initialize all or a subset of the member variables
                according to their order of declaration.
            **kwargs:
                Can be used to initialize member variables at construction,
                Just pass an argument expression of the form <member>=<value>
                per member that you want to initialize.
        """
        hipExternalSemaphoreWaitParams_st.__allocate(&self._ptr)
        self._is_ptr_owner = True
        attribs = self.PROPERTIES()
        used_attribs = set()
        if len(args) > len(attribs):
            raise ValueError("More positional arguments specified than this type has properties.")
        for i,v in enumerate(args):
            setattr(self,attribs[i],v)
            used_attribs.add(attribs[i])
        valid_names = ", ".join(["'"+p+"'" for p in attribs])
        for k,v in kwargs.items():
            if k in used_attribs:
                raise KeyError(f"argument '{k}' has already been specified as positional argument.")
            elif k not in attribs:
                raise KeyError(f"'{k}' is no valid property name. Valid names: {valid_names}")
            setattr(self,k,v)
    def get_params(self, i):
        """Get value of ``params`` of ``(<chip.hipExternalSemaphoreWaitParams_st*>self._ptr)[i]``.
        """
        return hipExternalSemaphoreWaitParams_st_struct_0.fromPtr(&(<chip.hipExternalSemaphoreWaitParams_st*>self._ptr)[i].params)
    @property
    def params(self):
        """(undocumented)"""
        return self.get_params(0)

    def get_flags(self, i):
        """Get value ``flags`` of ``(<chip.hipExternalSemaphoreWaitParams_st*>self._ptr)[i]``.
        """
        return (<chip.hipExternalSemaphoreWaitParams_st*>self._ptr)[i].flags
    def set_flags(self, i, unsigned int value):
        """Set value ``flags`` of ``(<chip.hipExternalSemaphoreWaitParams_st*>self._ptr)[i]``.
        """
        (<chip.hipExternalSemaphoreWaitParams_st*>self._ptr)[i].flags = value
    @property
    def flags(self):
        """(undocumented)"""
        return self.get_flags(0)
    @flags.setter
    def flags(self, unsigned int value):
        self.set_flags(0,value)

    def get_reserved(self, i):
        """Get value of ``reserved`` of ``(<chip.hipExternalSemaphoreWaitParams_st*>self._ptr)[i]``.
        """
        return (<chip.hipExternalSemaphoreWaitParams_st*>self._ptr)[i].reserved
    # TODO add setters
    #def set_reserved(self, i, unsigned int[16] value):
    #    """Set value ``reserved`` of ``(<chip.hipExternalSemaphoreWaitParams_st*>self._ptr)[i]``.
    #    """
    #    (<chip.hipExternalSemaphoreWaitParams_st*>self._ptr)[i].reserved = value
    @property
    def reserved(self):
        """(undocumented)"""
        return self.get_reserved(0)
    # TODO add setters
    #@reserved.setter
    #def reserved(self, unsigned int[16] value):
    #    self.set_reserved(0,value)

    @staticmethod
    def PROPERTIES():
        return ["params","flags","reserved"]

    def __contains__(self,item):
        properties = self.PROPERTIES()
        return item in properties

    def __getitem__(self,item):
        properties = self.PROPERTIES()
        if isinstance(item,int):
            if item < 0 or item >= len(properties):
                raise IndexError()
            return getattr(self,properties[item])
        raise ValueError("'item' type must be 'int'")


hipExternalSemaphoreWaitParams = hipExternalSemaphoreWaitParams_st

class _hipGraphicsRegisterFlags__Base(enum.IntEnum):
    """Empty enum base class that allows subclassing.
    """
    pass
class hipGraphicsRegisterFlags(_hipGraphicsRegisterFlags__Base):
    """HIP Access falgs for Interop resources.

    Attributes:
        hipGraphicsRegisterFlagsNone:
            (undocumented)
        hipGraphicsRegisterFlagsReadOnly:
            HIP will not write to this registered resource
        hipGraphicsRegisterFlagsWriteDiscard:
            (undocumented)
        hipGraphicsRegisterFlagsSurfaceLoadStore:
            HIP will bind this resource to a surface
        hipGraphicsRegisterFlagsTextureGather:
            (undocumented)
    """
    hipGraphicsRegisterFlagsNone = chip.hipGraphicsRegisterFlagsNone
    hipGraphicsRegisterFlagsReadOnly = chip.hipGraphicsRegisterFlagsReadOnly
    hipGraphicsRegisterFlagsWriteDiscard = chip.hipGraphicsRegisterFlagsWriteDiscard
    hipGraphicsRegisterFlagsSurfaceLoadStore = chip.hipGraphicsRegisterFlagsSurfaceLoadStore
    hipGraphicsRegisterFlagsTextureGather = chip.hipGraphicsRegisterFlagsTextureGather
    @staticmethod
    def ctypes_type():
        """The type of the enum constants as ctypes type."""
        return ctypes.c_uint


cdef class _hipGraphicsResource(hip._util.types.Pointer):
    """Python wrapper for cdef class chip._hipGraphicsResource.

    Python wrapper for cdef class chip._hipGraphicsResource.

    If this type is initialized via its `__init__` method, it allocates a
    member of the underlying C type and destroys it again if the wrapper
    type is deallocated.

    This type also serves as adapter when appearing as argument type in a
    function signature. In this case, the type can further be initialized
    from a number of Python objects:

    * `None`:

      This will set the ``self._ptr`` attribute to ``NULL``.

    * `int`:

      Interprets the integer value as pointer address and writes it to ``self._ptr``.
      No ownership is transferred.

    * `ctypes.c_void_p`:

      Takes the pointer address ``pyobj.value`` and writes it to ``self._ptr``.
      No ownership is transferred.

    * `object` that implements the `CUDA Array Interface <https://numba.readthedocs.io/en/stable/cuda/cuda_array_interface.html>`_ protocol:

      Takes the integer-valued pointer address, i.e. the first entry of the `data` tuple
      from `pyobj`'s member ``__cuda_array_interface__``  and writes it to ``self._ptr``.

    * `object` that implements the Python buffer protocol:

      If the object represents a simple contiguous array,
      writes the `Py_buffer` associated with ``pyobj`` to `self._py_buffer`,
      sets the `self._py_buffer_acquired` flag to `True`, and
      writes `self._py_buffer.buf` to the data pointer `self._ptr`.

    * `hip._util.types.Pointer`:

      Takes the pointer address ``pyobj._ptr`` and writes it to ``self._ptr``.
      No ownership is transferred.

    Type checks are performed in the above order.

    C Attributes:
        _ptr (C type ``void *``, protected):
            Stores a pointer to the data of the original Python object.
        _is_ptr_owner (C type ``bint``, protected):
            If this wrapper is the owner of the underlying data.
        _py_buffer (C type ``Py_buffer`, protected):
            Stores a pointer to the data of the original Python object.
        _py_buffer_acquired (C type ``bint``, protected):
            Stores a pointer to the data of the original Python object.
    """
    # C members declared in pxd file

    def __cinit__(self):
        self._ptr = NULL
        self._is_ptr_owner = False
        self._py_buffer_acquired = False

    cdef chip._hipGraphicsResource* getElementPtr(self):
        return <chip._hipGraphicsResource*>self._ptr

    @staticmethod
    cdef _hipGraphicsResource fromPtr(void* ptr, bint owner=False):
        """Factory function to create ``_hipGraphicsResource`` objects from
        given ``chip._hipGraphicsResource`` pointer.
        """
        # Fast call to __new__() that bypasses the __init__() constructor.
        cdef _hipGraphicsResource wrapper = _hipGraphicsResource.__new__(_hipGraphicsResource)
        wrapper._ptr = ptr
        wrapper._is_ptr_owner = owner
        return wrapper

    @staticmethod
    def fromObj(pyobj):
        """Creates a _hipGraphicsResource from a Python object.

        Derives a _hipGraphicsResource from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``_hipGraphicsResource`` reference, this method
        returns it directly. No new ``_hipGraphicsResource`` is created in this case.
        """
        return _hipGraphicsResource.fromPyobj(pyobj)

    @staticmethod
    cdef _hipGraphicsResource fromPyobj(object pyobj):
        """Creates a _hipGraphicsResource from a Python object.

        Derives a _hipGraphicsResource from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``_hipGraphicsResource`` reference, this method
        returns it directly. No new ``_hipGraphicsResource`` is created in this case.

        Args:
            pyobj (object): Must be either `None`; a `hip._util.types.Pointer`; a simple, contiguous buffer according to the buffer protocol;
                            or of type `_hipGraphicsResource`; `int`; or `ctypes.c_void_p`.

        Note:
            This routine does not perform a copy but returns the original ``pyobj``
            if ``pyobj`` is an instance of _hipGraphicsResource!
        """
        cdef _hipGraphicsResource wrapper

        if isinstance(pyobj,_hipGraphicsResource):
            return pyobj
        else:
            wrapper = _hipGraphicsResource.__new__(_hipGraphicsResource)
            wrapper.init_from_pyobj(pyobj)
            return wrapper

    def __dealloc__(self):
        # Release the buffer handle
        if self._py_buffer_acquired is True:
            cpython.buffer.PyBuffer_Release(&self._py_buffer)

    def __int__(self):
        """Returns the data's address as long integer.
        """
        return cpython.long.PyLong_FromVoidPtr(self._ptr)

    def __repr__(self):
        return f"<_hipGraphicsResource object, ptr: {int(self)}>"

    def as_c_void_p(self):
        """Returns the data's address as `ctypes.c_void_p`
        Note:
            Implemented as function to not collide with
            autogenerated property names.
        """
        return ctypes.c_void_p(int(self))

    @staticmethod
    def PROPERTIES():
        return []

    def __contains__(self,item):
        properties = self.PROPERTIES()
        return item in properties

    def __getitem__(self,item):
        properties = self.PROPERTIES()
        if isinstance(item,int):
            if item < 0 or item >= len(properties):
                raise IndexError()
            return getattr(self,properties[item])
        raise ValueError("'item' type must be 'int'")


hipGraphicsResource = _hipGraphicsResource

hipGraphicsResource_t = _hipGraphicsResource

cdef class ihipGraph(hip._util.types.Pointer):
    """Python wrapper for cdef class chip.ihipGraph.

    Python wrapper for cdef class chip.ihipGraph.

    If this type is initialized via its `__init__` method, it allocates a
    member of the underlying C type and destroys it again if the wrapper
    type is deallocated.

    This type also serves as adapter when appearing as argument type in a
    function signature. In this case, the type can further be initialized
    from a number of Python objects:

    * `None`:

      This will set the ``self._ptr`` attribute to ``NULL``.

    * `int`:

      Interprets the integer value as pointer address and writes it to ``self._ptr``.
      No ownership is transferred.

    * `ctypes.c_void_p`:

      Takes the pointer address ``pyobj.value`` and writes it to ``self._ptr``.
      No ownership is transferred.

    * `object` that implements the `CUDA Array Interface <https://numba.readthedocs.io/en/stable/cuda/cuda_array_interface.html>`_ protocol:

      Takes the integer-valued pointer address, i.e. the first entry of the `data` tuple
      from `pyobj`'s member ``__cuda_array_interface__``  and writes it to ``self._ptr``.

    * `object` that implements the Python buffer protocol:

      If the object represents a simple contiguous array,
      writes the `Py_buffer` associated with ``pyobj`` to `self._py_buffer`,
      sets the `self._py_buffer_acquired` flag to `True`, and
      writes `self._py_buffer.buf` to the data pointer `self._ptr`.

    * `hip._util.types.Pointer`:

      Takes the pointer address ``pyobj._ptr`` and writes it to ``self._ptr``.
      No ownership is transferred.

    Type checks are performed in the above order.

    C Attributes:
        _ptr (C type ``void *``, protected):
            Stores a pointer to the data of the original Python object.
        _is_ptr_owner (C type ``bint``, protected):
            If this wrapper is the owner of the underlying data.
        _py_buffer (C type ``Py_buffer`, protected):
            Stores a pointer to the data of the original Python object.
        _py_buffer_acquired (C type ``bint``, protected):
            Stores a pointer to the data of the original Python object.
    """
    # C members declared in pxd file

    def __cinit__(self):
        self._ptr = NULL
        self._is_ptr_owner = False
        self._py_buffer_acquired = False

    cdef chip.ihipGraph* getElementPtr(self):
        return <chip.ihipGraph*>self._ptr

    @staticmethod
    cdef ihipGraph fromPtr(void* ptr, bint owner=False):
        """Factory function to create ``ihipGraph`` objects from
        given ``chip.ihipGraph`` pointer.
        """
        # Fast call to __new__() that bypasses the __init__() constructor.
        cdef ihipGraph wrapper = ihipGraph.__new__(ihipGraph)
        wrapper._ptr = ptr
        wrapper._is_ptr_owner = owner
        return wrapper

    @staticmethod
    def fromObj(pyobj):
        """Creates a ihipGraph from a Python object.

        Derives a ihipGraph from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``ihipGraph`` reference, this method
        returns it directly. No new ``ihipGraph`` is created in this case.
        """
        return ihipGraph.fromPyobj(pyobj)

    @staticmethod
    cdef ihipGraph fromPyobj(object pyobj):
        """Creates a ihipGraph from a Python object.

        Derives a ihipGraph from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``ihipGraph`` reference, this method
        returns it directly. No new ``ihipGraph`` is created in this case.

        Args:
            pyobj (object): Must be either `None`; a `hip._util.types.Pointer`; a simple, contiguous buffer according to the buffer protocol;
                            or of type `ihipGraph`; `int`; or `ctypes.c_void_p`.

        Note:
            This routine does not perform a copy but returns the original ``pyobj``
            if ``pyobj`` is an instance of ihipGraph!
        """
        cdef ihipGraph wrapper

        if isinstance(pyobj,ihipGraph):
            return pyobj
        else:
            wrapper = ihipGraph.__new__(ihipGraph)
            wrapper.init_from_pyobj(pyobj)
            return wrapper

    def __dealloc__(self):
        # Release the buffer handle
        if self._py_buffer_acquired is True:
            cpython.buffer.PyBuffer_Release(&self._py_buffer)

    def __int__(self):
        """Returns the data's address as long integer.
        """
        return cpython.long.PyLong_FromVoidPtr(self._ptr)

    def __repr__(self):
        return f"<ihipGraph object, ptr: {int(self)}>"

    def as_c_void_p(self):
        """Returns the data's address as `ctypes.c_void_p`
        Note:
            Implemented as function to not collide with
            autogenerated property names.
        """
        return ctypes.c_void_p(int(self))

    @staticmethod
    def PROPERTIES():
        return []

    def __contains__(self,item):
        properties = self.PROPERTIES()
        return item in properties

    def __getitem__(self,item):
        properties = self.PROPERTIES()
        if isinstance(item,int):
            if item < 0 or item >= len(properties):
                raise IndexError()
            return getattr(self,properties[item])
        raise ValueError("'item' type must be 'int'")


hipGraph_t = ihipGraph

cdef class hipGraphNode(hip._util.types.Pointer):
    """Python wrapper for cdef class chip.hipGraphNode.

    Python wrapper for cdef class chip.hipGraphNode.

    If this type is initialized via its `__init__` method, it allocates a
    member of the underlying C type and destroys it again if the wrapper
    type is deallocated.

    This type also serves as adapter when appearing as argument type in a
    function signature. In this case, the type can further be initialized
    from a number of Python objects:

    * `None`:

      This will set the ``self._ptr`` attribute to ``NULL``.

    * `int`:

      Interprets the integer value as pointer address and writes it to ``self._ptr``.
      No ownership is transferred.

    * `ctypes.c_void_p`:

      Takes the pointer address ``pyobj.value`` and writes it to ``self._ptr``.
      No ownership is transferred.

    * `object` that implements the `CUDA Array Interface <https://numba.readthedocs.io/en/stable/cuda/cuda_array_interface.html>`_ protocol:

      Takes the integer-valued pointer address, i.e. the first entry of the `data` tuple
      from `pyobj`'s member ``__cuda_array_interface__``  and writes it to ``self._ptr``.

    * `object` that implements the Python buffer protocol:

      If the object represents a simple contiguous array,
      writes the `Py_buffer` associated with ``pyobj`` to `self._py_buffer`,
      sets the `self._py_buffer_acquired` flag to `True`, and
      writes `self._py_buffer.buf` to the data pointer `self._ptr`.

    * `hip._util.types.Pointer`:

      Takes the pointer address ``pyobj._ptr`` and writes it to ``self._ptr``.
      No ownership is transferred.

    Type checks are performed in the above order.

    C Attributes:
        _ptr (C type ``void *``, protected):
            Stores a pointer to the data of the original Python object.
        _is_ptr_owner (C type ``bint``, protected):
            If this wrapper is the owner of the underlying data.
        _py_buffer (C type ``Py_buffer`, protected):
            Stores a pointer to the data of the original Python object.
        _py_buffer_acquired (C type ``bint``, protected):
            Stores a pointer to the data of the original Python object.
    """
    # C members declared in pxd file

    def __cinit__(self):
        self._ptr = NULL
        self._is_ptr_owner = False
        self._py_buffer_acquired = False

    cdef chip.hipGraphNode* getElementPtr(self):
        return <chip.hipGraphNode*>self._ptr

    @staticmethod
    cdef hipGraphNode fromPtr(void* ptr, bint owner=False):
        """Factory function to create ``hipGraphNode`` objects from
        given ``chip.hipGraphNode`` pointer.
        """
        # Fast call to __new__() that bypasses the __init__() constructor.
        cdef hipGraphNode wrapper = hipGraphNode.__new__(hipGraphNode)
        wrapper._ptr = ptr
        wrapper._is_ptr_owner = owner
        return wrapper

    @staticmethod
    def fromObj(pyobj):
        """Creates a hipGraphNode from a Python object.

        Derives a hipGraphNode from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``hipGraphNode`` reference, this method
        returns it directly. No new ``hipGraphNode`` is created in this case.
        """
        return hipGraphNode.fromPyobj(pyobj)

    @staticmethod
    cdef hipGraphNode fromPyobj(object pyobj):
        """Creates a hipGraphNode from a Python object.

        Derives a hipGraphNode from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``hipGraphNode`` reference, this method
        returns it directly. No new ``hipGraphNode`` is created in this case.

        Args:
            pyobj (object): Must be either `None`; a `hip._util.types.Pointer`; a simple, contiguous buffer according to the buffer protocol;
                            or of type `hipGraphNode`; `int`; or `ctypes.c_void_p`.

        Note:
            This routine does not perform a copy but returns the original ``pyobj``
            if ``pyobj`` is an instance of hipGraphNode!
        """
        cdef hipGraphNode wrapper

        if isinstance(pyobj,hipGraphNode):
            return pyobj
        else:
            wrapper = hipGraphNode.__new__(hipGraphNode)
            wrapper.init_from_pyobj(pyobj)
            return wrapper

    def __dealloc__(self):
        # Release the buffer handle
        if self._py_buffer_acquired is True:
            cpython.buffer.PyBuffer_Release(&self._py_buffer)

    def __int__(self):
        """Returns the data's address as long integer.
        """
        return cpython.long.PyLong_FromVoidPtr(self._ptr)

    def __repr__(self):
        return f"<hipGraphNode object, ptr: {int(self)}>"

    def as_c_void_p(self):
        """Returns the data's address as `ctypes.c_void_p`
        Note:
            Implemented as function to not collide with
            autogenerated property names.
        """
        return ctypes.c_void_p(int(self))

    @staticmethod
    def PROPERTIES():
        return []

    def __contains__(self,item):
        properties = self.PROPERTIES()
        return item in properties

    def __getitem__(self,item):
        properties = self.PROPERTIES()
        if isinstance(item,int):
            if item < 0 or item >= len(properties):
                raise IndexError()
            return getattr(self,properties[item])
        raise ValueError("'item' type must be 'int'")


hipGraphNode_t = hipGraphNode

cdef class hipGraphExec(hip._util.types.Pointer):
    """Python wrapper for cdef class chip.hipGraphExec.

    Python wrapper for cdef class chip.hipGraphExec.

    If this type is initialized via its `__init__` method, it allocates a
    member of the underlying C type and destroys it again if the wrapper
    type is deallocated.

    This type also serves as adapter when appearing as argument type in a
    function signature. In this case, the type can further be initialized
    from a number of Python objects:

    * `None`:

      This will set the ``self._ptr`` attribute to ``NULL``.

    * `int`:

      Interprets the integer value as pointer address and writes it to ``self._ptr``.
      No ownership is transferred.

    * `ctypes.c_void_p`:

      Takes the pointer address ``pyobj.value`` and writes it to ``self._ptr``.
      No ownership is transferred.

    * `object` that implements the `CUDA Array Interface <https://numba.readthedocs.io/en/stable/cuda/cuda_array_interface.html>`_ protocol:

      Takes the integer-valued pointer address, i.e. the first entry of the `data` tuple
      from `pyobj`'s member ``__cuda_array_interface__``  and writes it to ``self._ptr``.

    * `object` that implements the Python buffer protocol:

      If the object represents a simple contiguous array,
      writes the `Py_buffer` associated with ``pyobj`` to `self._py_buffer`,
      sets the `self._py_buffer_acquired` flag to `True`, and
      writes `self._py_buffer.buf` to the data pointer `self._ptr`.

    * `hip._util.types.Pointer`:

      Takes the pointer address ``pyobj._ptr`` and writes it to ``self._ptr``.
      No ownership is transferred.

    Type checks are performed in the above order.

    C Attributes:
        _ptr (C type ``void *``, protected):
            Stores a pointer to the data of the original Python object.
        _is_ptr_owner (C type ``bint``, protected):
            If this wrapper is the owner of the underlying data.
        _py_buffer (C type ``Py_buffer`, protected):
            Stores a pointer to the data of the original Python object.
        _py_buffer_acquired (C type ``bint``, protected):
            Stores a pointer to the data of the original Python object.
    """
    # C members declared in pxd file

    def __cinit__(self):
        self._ptr = NULL
        self._is_ptr_owner = False
        self._py_buffer_acquired = False

    cdef chip.hipGraphExec* getElementPtr(self):
        return <chip.hipGraphExec*>self._ptr

    @staticmethod
    cdef hipGraphExec fromPtr(void* ptr, bint owner=False):
        """Factory function to create ``hipGraphExec`` objects from
        given ``chip.hipGraphExec`` pointer.
        """
        # Fast call to __new__() that bypasses the __init__() constructor.
        cdef hipGraphExec wrapper = hipGraphExec.__new__(hipGraphExec)
        wrapper._ptr = ptr
        wrapper._is_ptr_owner = owner
        return wrapper

    @staticmethod
    def fromObj(pyobj):
        """Creates a hipGraphExec from a Python object.

        Derives a hipGraphExec from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``hipGraphExec`` reference, this method
        returns it directly. No new ``hipGraphExec`` is created in this case.
        """
        return hipGraphExec.fromPyobj(pyobj)

    @staticmethod
    cdef hipGraphExec fromPyobj(object pyobj):
        """Creates a hipGraphExec from a Python object.

        Derives a hipGraphExec from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``hipGraphExec`` reference, this method
        returns it directly. No new ``hipGraphExec`` is created in this case.

        Args:
            pyobj (object): Must be either `None`; a `hip._util.types.Pointer`; a simple, contiguous buffer according to the buffer protocol;
                            or of type `hipGraphExec`; `int`; or `ctypes.c_void_p`.

        Note:
            This routine does not perform a copy but returns the original ``pyobj``
            if ``pyobj`` is an instance of hipGraphExec!
        """
        cdef hipGraphExec wrapper

        if isinstance(pyobj,hipGraphExec):
            return pyobj
        else:
            wrapper = hipGraphExec.__new__(hipGraphExec)
            wrapper.init_from_pyobj(pyobj)
            return wrapper

    def __dealloc__(self):
        # Release the buffer handle
        if self._py_buffer_acquired is True:
            cpython.buffer.PyBuffer_Release(&self._py_buffer)

    def __int__(self):
        """Returns the data's address as long integer.
        """
        return cpython.long.PyLong_FromVoidPtr(self._ptr)

    def __repr__(self):
        return f"<hipGraphExec object, ptr: {int(self)}>"

    def as_c_void_p(self):
        """Returns the data's address as `ctypes.c_void_p`
        Note:
            Implemented as function to not collide with
            autogenerated property names.
        """
        return ctypes.c_void_p(int(self))

    @staticmethod
    def PROPERTIES():
        return []

    def __contains__(self,item):
        properties = self.PROPERTIES()
        return item in properties

    def __getitem__(self,item):
        properties = self.PROPERTIES()
        if isinstance(item,int):
            if item < 0 or item >= len(properties):
                raise IndexError()
            return getattr(self,properties[item])
        raise ValueError("'item' type must be 'int'")


hipGraphExec_t = hipGraphExec

cdef class hipUserObject(hip._util.types.Pointer):
    """Python wrapper for cdef class chip.hipUserObject.

    Python wrapper for cdef class chip.hipUserObject.

    If this type is initialized via its `__init__` method, it allocates a
    member of the underlying C type and destroys it again if the wrapper
    type is deallocated.

    This type also serves as adapter when appearing as argument type in a
    function signature. In this case, the type can further be initialized
    from a number of Python objects:

    * `None`:

      This will set the ``self._ptr`` attribute to ``NULL``.

    * `int`:

      Interprets the integer value as pointer address and writes it to ``self._ptr``.
      No ownership is transferred.

    * `ctypes.c_void_p`:

      Takes the pointer address ``pyobj.value`` and writes it to ``self._ptr``.
      No ownership is transferred.

    * `object` that implements the `CUDA Array Interface <https://numba.readthedocs.io/en/stable/cuda/cuda_array_interface.html>`_ protocol:

      Takes the integer-valued pointer address, i.e. the first entry of the `data` tuple
      from `pyobj`'s member ``__cuda_array_interface__``  and writes it to ``self._ptr``.

    * `object` that implements the Python buffer protocol:

      If the object represents a simple contiguous array,
      writes the `Py_buffer` associated with ``pyobj`` to `self._py_buffer`,
      sets the `self._py_buffer_acquired` flag to `True`, and
      writes `self._py_buffer.buf` to the data pointer `self._ptr`.

    * `hip._util.types.Pointer`:

      Takes the pointer address ``pyobj._ptr`` and writes it to ``self._ptr``.
      No ownership is transferred.

    Type checks are performed in the above order.

    C Attributes:
        _ptr (C type ``void *``, protected):
            Stores a pointer to the data of the original Python object.
        _is_ptr_owner (C type ``bint``, protected):
            If this wrapper is the owner of the underlying data.
        _py_buffer (C type ``Py_buffer`, protected):
            Stores a pointer to the data of the original Python object.
        _py_buffer_acquired (C type ``bint``, protected):
            Stores a pointer to the data of the original Python object.
    """
    # C members declared in pxd file

    def __cinit__(self):
        self._ptr = NULL
        self._is_ptr_owner = False
        self._py_buffer_acquired = False

    cdef chip.hipUserObject* getElementPtr(self):
        return <chip.hipUserObject*>self._ptr

    @staticmethod
    cdef hipUserObject fromPtr(void* ptr, bint owner=False):
        """Factory function to create ``hipUserObject`` objects from
        given ``chip.hipUserObject`` pointer.
        """
        # Fast call to __new__() that bypasses the __init__() constructor.
        cdef hipUserObject wrapper = hipUserObject.__new__(hipUserObject)
        wrapper._ptr = ptr
        wrapper._is_ptr_owner = owner
        return wrapper

    @staticmethod
    def fromObj(pyobj):
        """Creates a hipUserObject from a Python object.

        Derives a hipUserObject from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``hipUserObject`` reference, this method
        returns it directly. No new ``hipUserObject`` is created in this case.
        """
        return hipUserObject.fromPyobj(pyobj)

    @staticmethod
    cdef hipUserObject fromPyobj(object pyobj):
        """Creates a hipUserObject from a Python object.

        Derives a hipUserObject from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``hipUserObject`` reference, this method
        returns it directly. No new ``hipUserObject`` is created in this case.

        Args:
            pyobj (object): Must be either `None`; a `hip._util.types.Pointer`; a simple, contiguous buffer according to the buffer protocol;
                            or of type `hipUserObject`; `int`; or `ctypes.c_void_p`.

        Note:
            This routine does not perform a copy but returns the original ``pyobj``
            if ``pyobj`` is an instance of hipUserObject!
        """
        cdef hipUserObject wrapper

        if isinstance(pyobj,hipUserObject):
            return pyobj
        else:
            wrapper = hipUserObject.__new__(hipUserObject)
            wrapper.init_from_pyobj(pyobj)
            return wrapper

    def __dealloc__(self):
        # Release the buffer handle
        if self._py_buffer_acquired is True:
            cpython.buffer.PyBuffer_Release(&self._py_buffer)

    def __int__(self):
        """Returns the data's address as long integer.
        """
        return cpython.long.PyLong_FromVoidPtr(self._ptr)

    def __repr__(self):
        return f"<hipUserObject object, ptr: {int(self)}>"

    def as_c_void_p(self):
        """Returns the data's address as `ctypes.c_void_p`
        Note:
            Implemented as function to not collide with
            autogenerated property names.
        """
        return ctypes.c_void_p(int(self))

    @staticmethod
    def PROPERTIES():
        return []

    def __contains__(self,item):
        properties = self.PROPERTIES()
        return item in properties

    def __getitem__(self,item):
        properties = self.PROPERTIES()
        if isinstance(item,int):
            if item < 0 or item >= len(properties):
                raise IndexError()
            return getattr(self,properties[item])
        raise ValueError("'item' type must be 'int'")


hipUserObject_t = hipUserObject

class _hipGraphNodeType__Base(enum.IntEnum):
    """Empty enum base class that allows subclassing.
    """
    pass
class hipGraphNodeType(_hipGraphNodeType__Base):
    """hipGraphNodeType

    Attributes:
        hipGraphNodeTypeKernel:
            GPU kernel node
        hipGraphNodeTypeMemcpy:
            Memcpy node
        hipGraphNodeTypeMemset:
            Memset node
        hipGraphNodeTypeHost:
            Host (executable) node
        hipGraphNodeTypeGraph:
            Node which executes an embedded graph
        hipGraphNodeTypeEmpty:
            Empty (no-op) node
        hipGraphNodeTypeWaitEvent:
            External event wait node
        hipGraphNodeTypeEventRecord:
            External event record node
        hipGraphNodeTypeExtSemaphoreSignal:
            External Semaphore signal node
        hipGraphNodeTypeExtSemaphoreWait:
            External Semaphore wait node
        hipGraphNodeTypeMemAlloc:
            Memory alloc node
        hipGraphNodeTypeMemFree:
            Memory free node
        hipGraphNodeTypeMemcpyFromSymbol:
            MemcpyFromSymbol node
        hipGraphNodeTypeMemcpyToSymbol:
            MemcpyToSymbol node
        hipGraphNodeTypeCount:
            (undocumented)
    """
    hipGraphNodeTypeKernel = chip.hipGraphNodeTypeKernel
    hipGraphNodeTypeMemcpy = chip.hipGraphNodeTypeMemcpy
    hipGraphNodeTypeMemset = chip.hipGraphNodeTypeMemset
    hipGraphNodeTypeHost = chip.hipGraphNodeTypeHost
    hipGraphNodeTypeGraph = chip.hipGraphNodeTypeGraph
    hipGraphNodeTypeEmpty = chip.hipGraphNodeTypeEmpty
    hipGraphNodeTypeWaitEvent = chip.hipGraphNodeTypeWaitEvent
    hipGraphNodeTypeEventRecord = chip.hipGraphNodeTypeEventRecord
    hipGraphNodeTypeExtSemaphoreSignal = chip.hipGraphNodeTypeExtSemaphoreSignal
    hipGraphNodeTypeExtSemaphoreWait = chip.hipGraphNodeTypeExtSemaphoreWait
    hipGraphNodeTypeMemAlloc = chip.hipGraphNodeTypeMemAlloc
    hipGraphNodeTypeMemFree = chip.hipGraphNodeTypeMemFree
    hipGraphNodeTypeMemcpyFromSymbol = chip.hipGraphNodeTypeMemcpyFromSymbol
    hipGraphNodeTypeMemcpyToSymbol = chip.hipGraphNodeTypeMemcpyToSymbol
    hipGraphNodeTypeCount = chip.hipGraphNodeTypeCount
    @staticmethod
    def ctypes_type():
        """The type of the enum constants as ctypes type."""
        return ctypes.c_uint


cdef class hipHostFn_t(hip._util.types.Pointer):
    """Python wrapper for cdef class chip.hipHostFn_t.

    Python wrapper for cdef class chip.hipHostFn_t.

    If this type is initialized via its `__init__` method, it allocates a
    member of the underlying C type and destroys it again if the wrapper
    type is deallocated.

    This type also serves as adapter when appearing as argument type in a
    function signature. In this case, the type can further be initialized
    from a number of Python objects:

    * `None`:

      This will set the ``self._ptr`` attribute to ``NULL``.

    * `int`:

      Interprets the integer value as pointer address and writes it to ``self._ptr``.
      No ownership is transferred.

    * `ctypes.c_void_p`:

      Takes the pointer address ``pyobj.value`` and writes it to ``self._ptr``.
      No ownership is transferred.

    * `object` that implements the `CUDA Array Interface <https://numba.readthedocs.io/en/stable/cuda/cuda_array_interface.html>`_ protocol:

      Takes the integer-valued pointer address, i.e. the first entry of the `data` tuple
      from `pyobj`'s member ``__cuda_array_interface__``  and writes it to ``self._ptr``.

    * `object` that implements the Python buffer protocol:

      If the object represents a simple contiguous array,
      writes the `Py_buffer` associated with ``pyobj`` to `self._py_buffer`,
      sets the `self._py_buffer_acquired` flag to `True`, and
      writes `self._py_buffer.buf` to the data pointer `self._ptr`.

    * `hip._util.types.Pointer`:

      Takes the pointer address ``pyobj._ptr`` and writes it to ``self._ptr``.
      No ownership is transferred.

    Type checks are performed in the above order.

    C Attributes:
        _ptr (C type ``void *``, protected):
            Stores a pointer to the data of the original Python object.
        _is_ptr_owner (C type ``bint``, protected):
            If this wrapper is the owner of the underlying data.
        _py_buffer (C type ``Py_buffer`, protected):
            Stores a pointer to the data of the original Python object.
        _py_buffer_acquired (C type ``bint``, protected):
            Stores a pointer to the data of the original Python object.
    """
    # C members declared in pxd file

    def __cinit__(self):
        self._ptr = NULL
        self._is_ptr_owner = False
        self._py_buffer_acquired = False

    cdef chip.hipHostFn_t getElementPtr(self):
        return <chip.hipHostFn_t>self._ptr

    @staticmethod
    cdef hipHostFn_t fromPtr(void* ptr, bint owner=False):
        """Factory function to create ``hipHostFn_t`` objects from
        given ``chip.hipHostFn_t`` pointer.
        """
        # Fast call to __new__() that bypasses the __init__() constructor.
        cdef hipHostFn_t wrapper = hipHostFn_t.__new__(hipHostFn_t)
        wrapper._ptr = ptr
        wrapper._is_ptr_owner = owner
        return wrapper

    @staticmethod
    def fromObj(pyobj):
        """Creates a hipHostFn_t from a Python object.

        Derives a hipHostFn_t from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``hipHostFn_t`` reference, this method
        returns it directly. No new ``hipHostFn_t`` is created in this case.
        """
        return hipHostFn_t.fromPyobj(pyobj)

    @staticmethod
    cdef hipHostFn_t fromPyobj(object pyobj):
        """Creates a hipHostFn_t from a Python object.

        Derives a hipHostFn_t from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``hipHostFn_t`` reference, this method
        returns it directly. No new ``hipHostFn_t`` is created in this case.

        Args:
            pyobj (object): Must be either `None`; a `hip._util.types.Pointer`; a simple, contiguous buffer according to the buffer protocol;
                            or of type `hipHostFn_t`; `int`; or `ctypes.c_void_p`.

        Note:
            This routine does not perform a copy but returns the original ``pyobj``
            if ``pyobj`` is an instance of hipHostFn_t!
        """
        cdef hipHostFn_t wrapper

        if isinstance(pyobj,hipHostFn_t):
            return pyobj
        else:
            wrapper = hipHostFn_t.__new__(hipHostFn_t)
            wrapper.init_from_pyobj(pyobj)
            return wrapper

    def __dealloc__(self):
        # Release the buffer handle
        if self._py_buffer_acquired is True:
            cpython.buffer.PyBuffer_Release(&self._py_buffer)

    def __int__(self):
        """Returns the data's address as long integer.
        """
        return cpython.long.PyLong_FromVoidPtr(self._ptr)

    def __repr__(self):
        return f"<hipHostFn_t object, ptr: {int(self)}>"

    def as_c_void_p(self):
        """Returns the data's address as `ctypes.c_void_p`
        Note:
            Implemented as function to not collide with
            autogenerated property names.
        """
        return ctypes.c_void_p(int(self))


cdef class hipHostNodeParams(hip._util.types.Pointer):
    """Python wrapper for cdef class chip.hipHostNodeParams.

    Python wrapper for cdef class chip.hipHostNodeParams.

    If this type is initialized via its `__init__` method, it allocates a
    member of the underlying C type and destroys it again if the wrapper
    type is deallocated.

    This type also serves as adapter when appearing as argument type in a
    function signature. In this case, the type can further be initialized
    from a number of Python objects:

    * `None`:

      This will set the ``self._ptr`` attribute to ``NULL``.

    * `int`:

      Interprets the integer value as pointer address and writes it to ``self._ptr``.
      No ownership is transferred.

    * `ctypes.c_void_p`:

      Takes the pointer address ``pyobj.value`` and writes it to ``self._ptr``.
      No ownership is transferred.

    * `object` that implements the `CUDA Array Interface <https://numba.readthedocs.io/en/stable/cuda/cuda_array_interface.html>`_ protocol:

      Takes the integer-valued pointer address, i.e. the first entry of the `data` tuple
      from `pyobj`'s member ``__cuda_array_interface__``  and writes it to ``self._ptr``.

    * `object` that implements the Python buffer protocol:

      If the object represents a simple contiguous array,
      writes the `Py_buffer` associated with ``pyobj`` to `self._py_buffer`,
      sets the `self._py_buffer_acquired` flag to `True`, and
      writes `self._py_buffer.buf` to the data pointer `self._ptr`.

    * `hip._util.types.Pointer`:

      Takes the pointer address ``pyobj._ptr`` and writes it to ``self._ptr``.
      No ownership is transferred.

    Type checks are performed in the above order.

    C Attributes:
        _ptr (C type ``void *``, protected):
            Stores a pointer to the data of the original Python object.
        _is_ptr_owner (C type ``bint``, protected):
            If this wrapper is the owner of the underlying data.
        _py_buffer (C type ``Py_buffer`, protected):
            Stores a pointer to the data of the original Python object.
        _py_buffer_acquired (C type ``bint``, protected):
            Stores a pointer to the data of the original Python object.
    """
    # C members declared in pxd file

    def __cinit__(self):
        self._ptr = NULL
        self._is_ptr_owner = False
        self._py_buffer_acquired = False

    cdef chip.hipHostNodeParams* getElementPtr(self):
        return <chip.hipHostNodeParams*>self._ptr

    @staticmethod
    cdef hipHostNodeParams fromPtr(void* ptr, bint owner=False):
        """Factory function to create ``hipHostNodeParams`` objects from
        given ``chip.hipHostNodeParams`` pointer.

        Setting ``owner`` flag to ``True`` causes
        the extension type to free the structure pointed to by ``ptr``
        when the wrapper object is deallocated.
        """
        # Fast call to __new__() that bypasses the __init__() constructor.
        cdef hipHostNodeParams wrapper = hipHostNodeParams.__new__(hipHostNodeParams)
        wrapper._ptr = ptr
        wrapper._is_ptr_owner = owner
        return wrapper

    @staticmethod
    def fromObj(pyobj):
        """Creates a hipHostNodeParams from a Python object.

        Derives a hipHostNodeParams from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``hipHostNodeParams`` reference, this method
        returns it directly. No new ``hipHostNodeParams`` is created in this case.
        """
        return hipHostNodeParams.fromPyobj(pyobj)

    @staticmethod
    cdef hipHostNodeParams fromPyobj(object pyobj):
        """Creates a hipHostNodeParams from a Python object.

        Derives a hipHostNodeParams from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``hipHostNodeParams`` reference, this method
        returns it directly. No new ``hipHostNodeParams`` is created in this case.

        Args:
            pyobj (object): Must be either `None`; a `hip._util.types.Pointer`; a simple, contiguous buffer according to the buffer protocol;
                            or of type `hipHostNodeParams`; `int`; or `ctypes.c_void_p`.

        Note:
            This routine does not perform a copy but returns the original ``pyobj``
            if ``pyobj`` is an instance of hipHostNodeParams!
        """
        cdef hipHostNodeParams wrapper

        if isinstance(pyobj,hipHostNodeParams):
            return pyobj
        else:
            wrapper = hipHostNodeParams.__new__(hipHostNodeParams)
            wrapper.init_from_pyobj(pyobj)
            return wrapper

    def __dealloc__(self):
        # Release the buffer handle
        if self._py_buffer_acquired is True:
            cpython.buffer.PyBuffer_Release(&self._py_buffer)
        # De-allocate if not null and flag is set
        if self._ptr is not NULL and self._is_ptr_owner is True:
            stdlib.free(self._ptr)
            self._ptr = NULL

    @staticmethod
    cdef __allocate(void** ptr):
        ptr[0] = stdlib.malloc(sizeof(chip.hipHostNodeParams))
        string.memset(<void*>ptr[0], 0, sizeof(chip.hipHostNodeParams))

        if ptr[0] is NULL:
            raise MemoryError

    @staticmethod
    cdef hipHostNodeParams new():
        """Factory function to create hipHostNodeParams objects with
        newly allocated chip.hipHostNodeParams"""
        cdef void* ptr
        hipHostNodeParams.__allocate(&ptr)
        return hipHostNodeParams.fromPtr(ptr, owner=True)

    @staticmethod
    cdef hipHostNodeParams fromValue(chip.hipHostNodeParams other):
        """Allocate new C type and copy from ``other``.
        """
        wrapper = hipHostNodeParams.new()
        string.memcpy(wrapper._ptr, &other, sizeof(chip.hipHostNodeParams))
        return wrapper

    def c_sizeof(self):
        """Returns the size of the underlying C type in bytes.
        Note:
            Implemented as function to not collide with
            autogenerated property names.
        """
        return sizeof(chip.hipHostNodeParams)

    def __int__(self):
        """Returns the data's address as long integer.
        """
        return cpython.long.PyLong_FromVoidPtr(self._ptr)

    def __repr__(self):
        return f"<hipHostNodeParams object, ptr: {int(self)}>"

    def as_c_void_p(self):
        """Returns the data's address as `ctypes.c_void_p`
        Note:
            Implemented as function to not collide with
            autogenerated property names.
        """
        return ctypes.c_void_p(int(self))

    def __init__(self,**kwargs):
        """Constructor type hipHostNodeParams.

        Constructor for type hipHostNodeParams.

        Args:
            **kwargs:
                Can be used to initialize member variables at construction,
                Just pass an argument expression of the form <member>=<value>
                per member that you want to initialize.
        """
        hipHostNodeParams.__allocate(&self._ptr)
        self._is_ptr_owner = True
        attribs = self.PROPERTIES()
        used_attribs = set()
        valid_names = ", ".join(["'"+p+"'" for p in attribs])
        for k,v in kwargs.items():
            if k in used_attribs:
                raise KeyError(f"argument '{k}' has already been specified as positional argument.")
            elif k not in attribs:
                raise KeyError(f"'{k}' is no valid property name. Valid names: {valid_names}")
            setattr(self,k,v)
    def get_userData(self, i):
        """Get value ``userData`` of ``(<chip.hipHostNodeParams*>self._ptr)[i]``.
        """
        return hip._util.types.Pointer.fromPtr((<chip.hipHostNodeParams*>self._ptr)[i].userData)
    def set_userData(self, i, object value):
        """Set value ``userData`` of ``(<chip.hipHostNodeParams*>self._ptr)[i]``.

        Note:
            This can be dangerous if the pointer is from a python object
            that is later on garbage collected.
        """
        (<chip.hipHostNodeParams*>self._ptr)[i].userData = <void *>cpython.long.PyLong_AsVoidPtr(int(hip._util.types.Pointer.fromPyobj(value)))
    @property
    def userData(self):
        """(undocumented)
        Note:
            Setting this userData can be dangerous if the underlying pointer is from a python object that
            is later on garbage collected.
        """
        return self.get_userData(0)
    @userData.setter
    def userData(self, object value):
        self.set_userData(0,value)

    @staticmethod
    def PROPERTIES():
        return ["userData"]

    def __contains__(self,item):
        properties = self.PROPERTIES()
        return item in properties

    def __getitem__(self,item):
        properties = self.PROPERTIES()
        if isinstance(item,int):
            if item < 0 or item >= len(properties):
                raise IndexError()
            return getattr(self,properties[item])
        raise ValueError("'item' type must be 'int'")


cdef class hipKernelNodeParams(hip._util.types.Pointer):
    """Python wrapper for cdef class chip.hipKernelNodeParams.

    Python wrapper for cdef class chip.hipKernelNodeParams.

    If this type is initialized via its `__init__` method, it allocates a
    member of the underlying C type and destroys it again if the wrapper
    type is deallocated.

    This type also serves as adapter when appearing as argument type in a
    function signature. In this case, the type can further be initialized
    from a number of Python objects:

    * `None`:

      This will set the ``self._ptr`` attribute to ``NULL``.

    * `int`:

      Interprets the integer value as pointer address and writes it to ``self._ptr``.
      No ownership is transferred.

    * `ctypes.c_void_p`:

      Takes the pointer address ``pyobj.value`` and writes it to ``self._ptr``.
      No ownership is transferred.

    * `object` that implements the `CUDA Array Interface <https://numba.readthedocs.io/en/stable/cuda/cuda_array_interface.html>`_ protocol:

      Takes the integer-valued pointer address, i.e. the first entry of the `data` tuple
      from `pyobj`'s member ``__cuda_array_interface__``  and writes it to ``self._ptr``.

    * `object` that implements the Python buffer protocol:

      If the object represents a simple contiguous array,
      writes the `Py_buffer` associated with ``pyobj`` to `self._py_buffer`,
      sets the `self._py_buffer_acquired` flag to `True`, and
      writes `self._py_buffer.buf` to the data pointer `self._ptr`.

    * `hip._util.types.Pointer`:

      Takes the pointer address ``pyobj._ptr`` and writes it to ``self._ptr``.
      No ownership is transferred.

    Type checks are performed in the above order.

    C Attributes:
        _ptr (C type ``void *``, protected):
            Stores a pointer to the data of the original Python object.
        _is_ptr_owner (C type ``bint``, protected):
            If this wrapper is the owner of the underlying data.
        _py_buffer (C type ``Py_buffer`, protected):
            Stores a pointer to the data of the original Python object.
        _py_buffer_acquired (C type ``bint``, protected):
            Stores a pointer to the data of the original Python object.
    """
    # C members declared in pxd file

    def __cinit__(self):
        self._ptr = NULL
        self._is_ptr_owner = False
        self._py_buffer_acquired = False

    cdef chip.hipKernelNodeParams* getElementPtr(self):
        return <chip.hipKernelNodeParams*>self._ptr

    @staticmethod
    cdef hipKernelNodeParams fromPtr(void* ptr, bint owner=False):
        """Factory function to create ``hipKernelNodeParams`` objects from
        given ``chip.hipKernelNodeParams`` pointer.

        Setting ``owner`` flag to ``True`` causes
        the extension type to free the structure pointed to by ``ptr``
        when the wrapper object is deallocated.
        """
        # Fast call to __new__() that bypasses the __init__() constructor.
        cdef hipKernelNodeParams wrapper = hipKernelNodeParams.__new__(hipKernelNodeParams)
        wrapper._ptr = ptr
        wrapper._is_ptr_owner = owner
        return wrapper

    @staticmethod
    def fromObj(pyobj):
        """Creates a hipKernelNodeParams from a Python object.

        Derives a hipKernelNodeParams from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``hipKernelNodeParams`` reference, this method
        returns it directly. No new ``hipKernelNodeParams`` is created in this case.
        """
        return hipKernelNodeParams.fromPyobj(pyobj)

    @staticmethod
    cdef hipKernelNodeParams fromPyobj(object pyobj):
        """Creates a hipKernelNodeParams from a Python object.

        Derives a hipKernelNodeParams from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``hipKernelNodeParams`` reference, this method
        returns it directly. No new ``hipKernelNodeParams`` is created in this case.

        Args:
            pyobj (object): Must be either `None`; a `hip._util.types.Pointer`; a simple, contiguous buffer according to the buffer protocol;
                            or of type `hipKernelNodeParams`; `int`; or `ctypes.c_void_p`.

        Note:
            This routine does not perform a copy but returns the original ``pyobj``
            if ``pyobj`` is an instance of hipKernelNodeParams!
        """
        cdef hipKernelNodeParams wrapper

        if isinstance(pyobj,hipKernelNodeParams):
            return pyobj
        else:
            wrapper = hipKernelNodeParams.__new__(hipKernelNodeParams)
            wrapper.init_from_pyobj(pyobj)
            return wrapper

    def __dealloc__(self):
        # Release the buffer handle
        if self._py_buffer_acquired is True:
            cpython.buffer.PyBuffer_Release(&self._py_buffer)
        # De-allocate if not null and flag is set
        if self._ptr is not NULL and self._is_ptr_owner is True:
            stdlib.free(self._ptr)
            self._ptr = NULL

    @staticmethod
    cdef __allocate(void** ptr):
        ptr[0] = stdlib.malloc(sizeof(chip.hipKernelNodeParams))
        string.memset(<void*>ptr[0], 0, sizeof(chip.hipKernelNodeParams))

        if ptr[0] is NULL:
            raise MemoryError

    @staticmethod
    cdef hipKernelNodeParams new():
        """Factory function to create hipKernelNodeParams objects with
        newly allocated chip.hipKernelNodeParams"""
        cdef void* ptr
        hipKernelNodeParams.__allocate(&ptr)
        return hipKernelNodeParams.fromPtr(ptr, owner=True)

    @staticmethod
    cdef hipKernelNodeParams fromValue(chip.hipKernelNodeParams other):
        """Allocate new C type and copy from ``other``.
        """
        wrapper = hipKernelNodeParams.new()
        string.memcpy(wrapper._ptr, &other, sizeof(chip.hipKernelNodeParams))
        return wrapper

    def c_sizeof(self):
        """Returns the size of the underlying C type in bytes.
        Note:
            Implemented as function to not collide with
            autogenerated property names.
        """
        return sizeof(chip.hipKernelNodeParams)

    def __int__(self):
        """Returns the data's address as long integer.
        """
        return cpython.long.PyLong_FromVoidPtr(self._ptr)

    def __repr__(self):
        return f"<hipKernelNodeParams object, ptr: {int(self)}>"

    def as_c_void_p(self):
        """Returns the data's address as `ctypes.c_void_p`
        Note:
            Implemented as function to not collide with
            autogenerated property names.
        """
        return ctypes.c_void_p(int(self))

    def __init__(self,*args,**kwargs):
        """Constructor type hipKernelNodeParams.

        Constructor for type hipKernelNodeParams.

        Args:
            *args:
                Positional arguments. Initialize all or a subset of the member variables
                according to their order of declaration.
            **kwargs:
                Can be used to initialize member variables at construction,
                Just pass an argument expression of the form <member>=<value>
                per member that you want to initialize.
        """
        hipKernelNodeParams.__allocate(&self._ptr)
        self._is_ptr_owner = True
        attribs = self.PROPERTIES()
        used_attribs = set()
        if len(args) > len(attribs):
            raise ValueError("More positional arguments specified than this type has properties.")
        for i,v in enumerate(args):
            setattr(self,attribs[i],v)
            used_attribs.add(attribs[i])
        valid_names = ", ".join(["'"+p+"'" for p in attribs])
        for k,v in kwargs.items():
            if k in used_attribs:
                raise KeyError(f"argument '{k}' has already been specified as positional argument.")
            elif k not in attribs:
                raise KeyError(f"'{k}' is no valid property name. Valid names: {valid_names}")
            setattr(self,k,v)
    def get_blockDim(self, i):
        """Get value of ``blockDim`` of ``(<chip.hipKernelNodeParams*>self._ptr)[i]``.
        """
        return dim3.fromPtr(&(<chip.hipKernelNodeParams*>self._ptr)[i].blockDim)
    @property
    def blockDim(self):
        """(undocumented)"""
        return self.get_blockDim(0)

    def get_extra(self, i):
        """Get value ``extra`` of ``(<chip.hipKernelNodeParams*>self._ptr)[i]``.
        """
        return hip._util.types.Pointer.fromPtr((<chip.hipKernelNodeParams*>self._ptr)[i].extra)
    def set_extra(self, i, object value):
        """Set value ``extra`` of ``(<chip.hipKernelNodeParams*>self._ptr)[i]``.

        Note:
            This can be dangerous if the pointer is from a python object
            that is later on garbage collected.
        """
        (<chip.hipKernelNodeParams*>self._ptr)[i].extra = <void **>cpython.long.PyLong_AsVoidPtr(int(hip._util.types.Pointer.fromPyobj(value)))
    @property
    def extra(self):
        """(undocumented)
        Note:
            Setting this extra can be dangerous if the underlying pointer is from a python object that
            is later on garbage collected.
        """
        return self.get_extra(0)
    @extra.setter
    def extra(self, object value):
        self.set_extra(0,value)

    def get_func(self, i):
        """Get value ``func`` of ``(<chip.hipKernelNodeParams*>self._ptr)[i]``.
        """
        return hip._util.types.Pointer.fromPtr((<chip.hipKernelNodeParams*>self._ptr)[i].func)
    def set_func(self, i, object value):
        """Set value ``func`` of ``(<chip.hipKernelNodeParams*>self._ptr)[i]``.

        Note:
            This can be dangerous if the pointer is from a python object
            that is later on garbage collected.
        """
        (<chip.hipKernelNodeParams*>self._ptr)[i].func = <void *>cpython.long.PyLong_AsVoidPtr(int(hip._util.types.Pointer.fromPyobj(value)))
    @property
    def func(self):
        """(undocumented)
        Note:
            Setting this func can be dangerous if the underlying pointer is from a python object that
            is later on garbage collected.
        """
        return self.get_func(0)
    @func.setter
    def func(self, object value):
        self.set_func(0,value)

    def get_gridDim(self, i):
        """Get value of ``gridDim`` of ``(<chip.hipKernelNodeParams*>self._ptr)[i]``.
        """
        return dim3.fromPtr(&(<chip.hipKernelNodeParams*>self._ptr)[i].gridDim)
    @property
    def gridDim(self):
        """(undocumented)"""
        return self.get_gridDim(0)

    def get_kernelParams(self, i):
        """Get value ``kernelParams`` of ``(<chip.hipKernelNodeParams*>self._ptr)[i]``.
        """
        return hip._util.types.Pointer.fromPtr((<chip.hipKernelNodeParams*>self._ptr)[i].kernelParams)
    def set_kernelParams(self, i, object value):
        """Set value ``kernelParams`` of ``(<chip.hipKernelNodeParams*>self._ptr)[i]``.

        Note:
            This can be dangerous if the pointer is from a python object
            that is later on garbage collected.
        """
        (<chip.hipKernelNodeParams*>self._ptr)[i].kernelParams = <void **>cpython.long.PyLong_AsVoidPtr(int(hip._util.types.Pointer.fromPyobj(value)))
    @property
    def kernelParams(self):
        """(undocumented)
        Note:
            Setting this kernelParams can be dangerous if the underlying pointer is from a python object that
            is later on garbage collected.
        """
        return self.get_kernelParams(0)
    @kernelParams.setter
    def kernelParams(self, object value):
        self.set_kernelParams(0,value)

    def get_sharedMemBytes(self, i):
        """Get value ``sharedMemBytes`` of ``(<chip.hipKernelNodeParams*>self._ptr)[i]``.
        """
        return (<chip.hipKernelNodeParams*>self._ptr)[i].sharedMemBytes
    def set_sharedMemBytes(self, i, unsigned int value):
        """Set value ``sharedMemBytes`` of ``(<chip.hipKernelNodeParams*>self._ptr)[i]``.
        """
        (<chip.hipKernelNodeParams*>self._ptr)[i].sharedMemBytes = value
    @property
    def sharedMemBytes(self):
        """(undocumented)"""
        return self.get_sharedMemBytes(0)
    @sharedMemBytes.setter
    def sharedMemBytes(self, unsigned int value):
        self.set_sharedMemBytes(0,value)

    @staticmethod
    def PROPERTIES():
        return ["blockDim","extra","func","gridDim","kernelParams","sharedMemBytes"]

    def __contains__(self,item):
        properties = self.PROPERTIES()
        return item in properties

    def __getitem__(self,item):
        properties = self.PROPERTIES()
        if isinstance(item,int):
            if item < 0 or item >= len(properties):
                raise IndexError()
            return getattr(self,properties[item])
        raise ValueError("'item' type must be 'int'")


cdef class hipMemsetParams(hip._util.types.Pointer):
    """Python wrapper for cdef class chip.hipMemsetParams.

    Python wrapper for cdef class chip.hipMemsetParams.

    If this type is initialized via its `__init__` method, it allocates a
    member of the underlying C type and destroys it again if the wrapper
    type is deallocated.

    This type also serves as adapter when appearing as argument type in a
    function signature. In this case, the type can further be initialized
    from a number of Python objects:

    * `None`:

      This will set the ``self._ptr`` attribute to ``NULL``.

    * `int`:

      Interprets the integer value as pointer address and writes it to ``self._ptr``.
      No ownership is transferred.

    * `ctypes.c_void_p`:

      Takes the pointer address ``pyobj.value`` and writes it to ``self._ptr``.
      No ownership is transferred.

    * `object` that implements the `CUDA Array Interface <https://numba.readthedocs.io/en/stable/cuda/cuda_array_interface.html>`_ protocol:

      Takes the integer-valued pointer address, i.e. the first entry of the `data` tuple
      from `pyobj`'s member ``__cuda_array_interface__``  and writes it to ``self._ptr``.

    * `object` that implements the Python buffer protocol:

      If the object represents a simple contiguous array,
      writes the `Py_buffer` associated with ``pyobj`` to `self._py_buffer`,
      sets the `self._py_buffer_acquired` flag to `True`, and
      writes `self._py_buffer.buf` to the data pointer `self._ptr`.

    * `hip._util.types.Pointer`:

      Takes the pointer address ``pyobj._ptr`` and writes it to ``self._ptr``.
      No ownership is transferred.

    Type checks are performed in the above order.

    C Attributes:
        _ptr (C type ``void *``, protected):
            Stores a pointer to the data of the original Python object.
        _is_ptr_owner (C type ``bint``, protected):
            If this wrapper is the owner of the underlying data.
        _py_buffer (C type ``Py_buffer`, protected):
            Stores a pointer to the data of the original Python object.
        _py_buffer_acquired (C type ``bint``, protected):
            Stores a pointer to the data of the original Python object.
    """
    # C members declared in pxd file

    def __cinit__(self):
        self._ptr = NULL
        self._is_ptr_owner = False
        self._py_buffer_acquired = False

    cdef chip.hipMemsetParams* getElementPtr(self):
        return <chip.hipMemsetParams*>self._ptr

    @staticmethod
    cdef hipMemsetParams fromPtr(void* ptr, bint owner=False):
        """Factory function to create ``hipMemsetParams`` objects from
        given ``chip.hipMemsetParams`` pointer.

        Setting ``owner`` flag to ``True`` causes
        the extension type to free the structure pointed to by ``ptr``
        when the wrapper object is deallocated.
        """
        # Fast call to __new__() that bypasses the __init__() constructor.
        cdef hipMemsetParams wrapper = hipMemsetParams.__new__(hipMemsetParams)
        wrapper._ptr = ptr
        wrapper._is_ptr_owner = owner
        return wrapper

    @staticmethod
    def fromObj(pyobj):
        """Creates a hipMemsetParams from a Python object.

        Derives a hipMemsetParams from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``hipMemsetParams`` reference, this method
        returns it directly. No new ``hipMemsetParams`` is created in this case.
        """
        return hipMemsetParams.fromPyobj(pyobj)

    @staticmethod
    cdef hipMemsetParams fromPyobj(object pyobj):
        """Creates a hipMemsetParams from a Python object.

        Derives a hipMemsetParams from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``hipMemsetParams`` reference, this method
        returns it directly. No new ``hipMemsetParams`` is created in this case.

        Args:
            pyobj (object): Must be either `None`; a `hip._util.types.Pointer`; a simple, contiguous buffer according to the buffer protocol;
                            or of type `hipMemsetParams`; `int`; or `ctypes.c_void_p`.

        Note:
            This routine does not perform a copy but returns the original ``pyobj``
            if ``pyobj`` is an instance of hipMemsetParams!
        """
        cdef hipMemsetParams wrapper

        if isinstance(pyobj,hipMemsetParams):
            return pyobj
        else:
            wrapper = hipMemsetParams.__new__(hipMemsetParams)
            wrapper.init_from_pyobj(pyobj)
            return wrapper

    def __dealloc__(self):
        # Release the buffer handle
        if self._py_buffer_acquired is True:
            cpython.buffer.PyBuffer_Release(&self._py_buffer)
        # De-allocate if not null and flag is set
        if self._ptr is not NULL and self._is_ptr_owner is True:
            stdlib.free(self._ptr)
            self._ptr = NULL

    @staticmethod
    cdef __allocate(void** ptr):
        ptr[0] = stdlib.malloc(sizeof(chip.hipMemsetParams))
        string.memset(<void*>ptr[0], 0, sizeof(chip.hipMemsetParams))

        if ptr[0] is NULL:
            raise MemoryError

    @staticmethod
    cdef hipMemsetParams new():
        """Factory function to create hipMemsetParams objects with
        newly allocated chip.hipMemsetParams"""
        cdef void* ptr
        hipMemsetParams.__allocate(&ptr)
        return hipMemsetParams.fromPtr(ptr, owner=True)

    @staticmethod
    cdef hipMemsetParams fromValue(chip.hipMemsetParams other):
        """Allocate new C type and copy from ``other``.
        """
        wrapper = hipMemsetParams.new()
        string.memcpy(wrapper._ptr, &other, sizeof(chip.hipMemsetParams))
        return wrapper

    def c_sizeof(self):
        """Returns the size of the underlying C type in bytes.
        Note:
            Implemented as function to not collide with
            autogenerated property names.
        """
        return sizeof(chip.hipMemsetParams)

    def __int__(self):
        """Returns the data's address as long integer.
        """
        return cpython.long.PyLong_FromVoidPtr(self._ptr)

    def __repr__(self):
        return f"<hipMemsetParams object, ptr: {int(self)}>"

    def as_c_void_p(self):
        """Returns the data's address as `ctypes.c_void_p`
        Note:
            Implemented as function to not collide with
            autogenerated property names.
        """
        return ctypes.c_void_p(int(self))

    def __init__(self,*args,**kwargs):
        """Constructor type hipMemsetParams.

        Constructor for type hipMemsetParams.

        Args:
            *args:
                Positional arguments. Initialize all or a subset of the member variables
                according to their order of declaration.
            **kwargs:
                Can be used to initialize member variables at construction,
                Just pass an argument expression of the form <member>=<value>
                per member that you want to initialize.
        """
        hipMemsetParams.__allocate(&self._ptr)
        self._is_ptr_owner = True
        attribs = self.PROPERTIES()
        used_attribs = set()
        if len(args) > len(attribs):
            raise ValueError("More positional arguments specified than this type has properties.")
        for i,v in enumerate(args):
            setattr(self,attribs[i],v)
            used_attribs.add(attribs[i])
        valid_names = ", ".join(["'"+p+"'" for p in attribs])
        for k,v in kwargs.items():
            if k in used_attribs:
                raise KeyError(f"argument '{k}' has already been specified as positional argument.")
            elif k not in attribs:
                raise KeyError(f"'{k}' is no valid property name. Valid names: {valid_names}")
            setattr(self,k,v)
    def get_dst(self, i):
        """Get value ``dst`` of ``(<chip.hipMemsetParams*>self._ptr)[i]``.
        """
        return hip._util.types.Pointer.fromPtr((<chip.hipMemsetParams*>self._ptr)[i].dst)
    def set_dst(self, i, object value):
        """Set value ``dst`` of ``(<chip.hipMemsetParams*>self._ptr)[i]``.

        Note:
            This can be dangerous if the pointer is from a python object
            that is later on garbage collected.
        """
        (<chip.hipMemsetParams*>self._ptr)[i].dst = <void *>cpython.long.PyLong_AsVoidPtr(int(hip._util.types.Pointer.fromPyobj(value)))
    @property
    def dst(self):
        """(undocumented)
        Note:
            Setting this dst can be dangerous if the underlying pointer is from a python object that
            is later on garbage collected.
        """
        return self.get_dst(0)
    @dst.setter
    def dst(self, object value):
        self.set_dst(0,value)

    def get_elementSize(self, i):
        """Get value ``elementSize`` of ``(<chip.hipMemsetParams*>self._ptr)[i]``.
        """
        return (<chip.hipMemsetParams*>self._ptr)[i].elementSize
    def set_elementSize(self, i, unsigned int value):
        """Set value ``elementSize`` of ``(<chip.hipMemsetParams*>self._ptr)[i]``.
        """
        (<chip.hipMemsetParams*>self._ptr)[i].elementSize = value
    @property
    def elementSize(self):
        """(undocumented)"""
        return self.get_elementSize(0)
    @elementSize.setter
    def elementSize(self, unsigned int value):
        self.set_elementSize(0,value)

    def get_height(self, i):
        """Get value ``height`` of ``(<chip.hipMemsetParams*>self._ptr)[i]``.
        """
        return (<chip.hipMemsetParams*>self._ptr)[i].height
    def set_height(self, i, unsigned long value):
        """Set value ``height`` of ``(<chip.hipMemsetParams*>self._ptr)[i]``.
        """
        (<chip.hipMemsetParams*>self._ptr)[i].height = value
    @property
    def height(self):
        """(undocumented)"""
        return self.get_height(0)
    @height.setter
    def height(self, unsigned long value):
        self.set_height(0,value)

    def get_pitch(self, i):
        """Get value ``pitch`` of ``(<chip.hipMemsetParams*>self._ptr)[i]``.
        """
        return (<chip.hipMemsetParams*>self._ptr)[i].pitch
    def set_pitch(self, i, unsigned long value):
        """Set value ``pitch`` of ``(<chip.hipMemsetParams*>self._ptr)[i]``.
        """
        (<chip.hipMemsetParams*>self._ptr)[i].pitch = value
    @property
    def pitch(self):
        """(undocumented)"""
        return self.get_pitch(0)
    @pitch.setter
    def pitch(self, unsigned long value):
        self.set_pitch(0,value)

    def get_value(self, i):
        """Get value ``value`` of ``(<chip.hipMemsetParams*>self._ptr)[i]``.
        """
        return (<chip.hipMemsetParams*>self._ptr)[i].value
    def set_value(self, i, unsigned int value):
        """Set value ``value`` of ``(<chip.hipMemsetParams*>self._ptr)[i]``.
        """
        (<chip.hipMemsetParams*>self._ptr)[i].value = value
    @property
    def value(self):
        """(undocumented)"""
        return self.get_value(0)
    @value.setter
    def value(self, unsigned int value):
        self.set_value(0,value)

    def get_width(self, i):
        """Get value ``width`` of ``(<chip.hipMemsetParams*>self._ptr)[i]``.
        """
        return (<chip.hipMemsetParams*>self._ptr)[i].width
    def set_width(self, i, unsigned long value):
        """Set value ``width`` of ``(<chip.hipMemsetParams*>self._ptr)[i]``.
        """
        (<chip.hipMemsetParams*>self._ptr)[i].width = value
    @property
    def width(self):
        """(undocumented)"""
        return self.get_width(0)
    @width.setter
    def width(self, unsigned long value):
        self.set_width(0,value)

    @staticmethod
    def PROPERTIES():
        return ["dst","elementSize","height","pitch","value","width"]

    def __contains__(self,item):
        properties = self.PROPERTIES()
        return item in properties

    def __getitem__(self,item):
        properties = self.PROPERTIES()
        if isinstance(item,int):
            if item < 0 or item >= len(properties):
                raise IndexError()
            return getattr(self,properties[item])
        raise ValueError("'item' type must be 'int'")


cdef class hipMemAllocNodeParams(hip._util.types.Pointer):
    """Python wrapper for cdef class chip.hipMemAllocNodeParams.

    Python wrapper for cdef class chip.hipMemAllocNodeParams.

    If this type is initialized via its `__init__` method, it allocates a
    member of the underlying C type and destroys it again if the wrapper
    type is deallocated.

    This type also serves as adapter when appearing as argument type in a
    function signature. In this case, the type can further be initialized
    from a number of Python objects:

    * `None`:

      This will set the ``self._ptr`` attribute to ``NULL``.

    * `int`:

      Interprets the integer value as pointer address and writes it to ``self._ptr``.
      No ownership is transferred.

    * `ctypes.c_void_p`:

      Takes the pointer address ``pyobj.value`` and writes it to ``self._ptr``.
      No ownership is transferred.

    * `object` that implements the `CUDA Array Interface <https://numba.readthedocs.io/en/stable/cuda/cuda_array_interface.html>`_ protocol:

      Takes the integer-valued pointer address, i.e. the first entry of the `data` tuple
      from `pyobj`'s member ``__cuda_array_interface__``  and writes it to ``self._ptr``.

    * `object` that implements the Python buffer protocol:

      If the object represents a simple contiguous array,
      writes the `Py_buffer` associated with ``pyobj`` to `self._py_buffer`,
      sets the `self._py_buffer_acquired` flag to `True`, and
      writes `self._py_buffer.buf` to the data pointer `self._ptr`.

    * `hip._util.types.Pointer`:

      Takes the pointer address ``pyobj._ptr`` and writes it to ``self._ptr``.
      No ownership is transferred.

    Type checks are performed in the above order.

    C Attributes:
        _ptr (C type ``void *``, protected):
            Stores a pointer to the data of the original Python object.
        _is_ptr_owner (C type ``bint``, protected):
            If this wrapper is the owner of the underlying data.
        _py_buffer (C type ``Py_buffer`, protected):
            Stores a pointer to the data of the original Python object.
        _py_buffer_acquired (C type ``bint``, protected):
            Stores a pointer to the data of the original Python object.
    """
    # C members declared in pxd file

    def __cinit__(self):
        self._ptr = NULL
        self._is_ptr_owner = False
        self._py_buffer_acquired = False

    cdef chip.hipMemAllocNodeParams* getElementPtr(self):
        return <chip.hipMemAllocNodeParams*>self._ptr

    @staticmethod
    cdef hipMemAllocNodeParams fromPtr(void* ptr, bint owner=False):
        """Factory function to create ``hipMemAllocNodeParams`` objects from
        given ``chip.hipMemAllocNodeParams`` pointer.

        Setting ``owner`` flag to ``True`` causes
        the extension type to free the structure pointed to by ``ptr``
        when the wrapper object is deallocated.
        """
        # Fast call to __new__() that bypasses the __init__() constructor.
        cdef hipMemAllocNodeParams wrapper = hipMemAllocNodeParams.__new__(hipMemAllocNodeParams)
        wrapper._ptr = ptr
        wrapper._is_ptr_owner = owner
        return wrapper

    @staticmethod
    def fromObj(pyobj):
        """Creates a hipMemAllocNodeParams from a Python object.

        Derives a hipMemAllocNodeParams from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``hipMemAllocNodeParams`` reference, this method
        returns it directly. No new ``hipMemAllocNodeParams`` is created in this case.
        """
        return hipMemAllocNodeParams.fromPyobj(pyobj)

    @staticmethod
    cdef hipMemAllocNodeParams fromPyobj(object pyobj):
        """Creates a hipMemAllocNodeParams from a Python object.

        Derives a hipMemAllocNodeParams from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``hipMemAllocNodeParams`` reference, this method
        returns it directly. No new ``hipMemAllocNodeParams`` is created in this case.

        Args:
            pyobj (object): Must be either `None`; a `hip._util.types.Pointer`; a simple, contiguous buffer according to the buffer protocol;
                            or of type `hipMemAllocNodeParams`; `int`; or `ctypes.c_void_p`.

        Note:
            This routine does not perform a copy but returns the original ``pyobj``
            if ``pyobj`` is an instance of hipMemAllocNodeParams!
        """
        cdef hipMemAllocNodeParams wrapper

        if isinstance(pyobj,hipMemAllocNodeParams):
            return pyobj
        else:
            wrapper = hipMemAllocNodeParams.__new__(hipMemAllocNodeParams)
            wrapper.init_from_pyobj(pyobj)
            return wrapper

    def __dealloc__(self):
        # Release the buffer handle
        if self._py_buffer_acquired is True:
            cpython.buffer.PyBuffer_Release(&self._py_buffer)
        # De-allocate if not null and flag is set
        if self._ptr is not NULL and self._is_ptr_owner is True:
            stdlib.free(self._ptr)
            self._ptr = NULL

    @staticmethod
    cdef __allocate(void** ptr):
        ptr[0] = stdlib.malloc(sizeof(chip.hipMemAllocNodeParams))
        string.memset(<void*>ptr[0], 0, sizeof(chip.hipMemAllocNodeParams))

        if ptr[0] is NULL:
            raise MemoryError

    @staticmethod
    cdef hipMemAllocNodeParams new():
        """Factory function to create hipMemAllocNodeParams objects with
        newly allocated chip.hipMemAllocNodeParams"""
        cdef void* ptr
        hipMemAllocNodeParams.__allocate(&ptr)
        return hipMemAllocNodeParams.fromPtr(ptr, owner=True)

    @staticmethod
    cdef hipMemAllocNodeParams fromValue(chip.hipMemAllocNodeParams other):
        """Allocate new C type and copy from ``other``.
        """
        wrapper = hipMemAllocNodeParams.new()
        string.memcpy(wrapper._ptr, &other, sizeof(chip.hipMemAllocNodeParams))
        return wrapper

    def c_sizeof(self):
        """Returns the size of the underlying C type in bytes.
        Note:
            Implemented as function to not collide with
            autogenerated property names.
        """
        return sizeof(chip.hipMemAllocNodeParams)

    def __int__(self):
        """Returns the data's address as long integer.
        """
        return cpython.long.PyLong_FromVoidPtr(self._ptr)

    def __repr__(self):
        return f"<hipMemAllocNodeParams object, ptr: {int(self)}>"

    def as_c_void_p(self):
        """Returns the data's address as `ctypes.c_void_p`
        Note:
            Implemented as function to not collide with
            autogenerated property names.
        """
        return ctypes.c_void_p(int(self))

    def __init__(self,**kwargs):
        """Constructor type hipMemAllocNodeParams.

        Constructor for type hipMemAllocNodeParams.

        Args:
            **kwargs:
                Can be used to initialize member variables at construction,
                Just pass an argument expression of the form <member>=<value>
                per member that you want to initialize.
        """
        hipMemAllocNodeParams.__allocate(&self._ptr)
        self._is_ptr_owner = True
        attribs = self.PROPERTIES()
        used_attribs = set()
        valid_names = ", ".join(["'"+p+"'" for p in attribs])
        for k,v in kwargs.items():
            if k in used_attribs:
                raise KeyError(f"argument '{k}' has already been specified as positional argument.")
            elif k not in attribs:
                raise KeyError(f"'{k}' is no valid property name. Valid names: {valid_names}")
            setattr(self,k,v)
    def get_poolProps(self, i):
        """Get value of ``poolProps`` of ``(<chip.hipMemAllocNodeParams*>self._ptr)[i]``.
        """
        return hipMemPoolProps.fromPtr(&(<chip.hipMemAllocNodeParams*>self._ptr)[i].poolProps)
    @property
    def poolProps(self):
        """Pool properties, which contain where the location should reside"""
        return self.get_poolProps(0)

    def get_accessDescCount(self, i):
        """Get value ``accessDescCount`` of ``(<chip.hipMemAllocNodeParams*>self._ptr)[i]``.
        """
        return (<chip.hipMemAllocNodeParams*>self._ptr)[i].accessDescCount
    def set_accessDescCount(self, i, unsigned long value):
        """Set value ``accessDescCount`` of ``(<chip.hipMemAllocNodeParams*>self._ptr)[i]``.
        """
        (<chip.hipMemAllocNodeParams*>self._ptr)[i].accessDescCount = value
    @property
    def accessDescCount(self):
        """The number of access descriptors"""
        return self.get_accessDescCount(0)
    @accessDescCount.setter
    def accessDescCount(self, unsigned long value):
        self.set_accessDescCount(0,value)

    def get_bytesize(self, i):
        """Get value ``bytesize`` of ``(<chip.hipMemAllocNodeParams*>self._ptr)[i]``.
        """
        return (<chip.hipMemAllocNodeParams*>self._ptr)[i].bytesize
    def set_bytesize(self, i, unsigned long value):
        """Set value ``bytesize`` of ``(<chip.hipMemAllocNodeParams*>self._ptr)[i]``.
        """
        (<chip.hipMemAllocNodeParams*>self._ptr)[i].bytesize = value
    @property
    def bytesize(self):
        """The size of the requested allocation in bytes"""
        return self.get_bytesize(0)
    @bytesize.setter
    def bytesize(self, unsigned long value):
        self.set_bytesize(0,value)

    def get_dptr(self, i):
        """Get value ``dptr`` of ``(<chip.hipMemAllocNodeParams*>self._ptr)[i]``.
        """
        return hip._util.types.Pointer.fromPtr((<chip.hipMemAllocNodeParams*>self._ptr)[i].dptr)
    def set_dptr(self, i, object value):
        """Set value ``dptr`` of ``(<chip.hipMemAllocNodeParams*>self._ptr)[i]``.

        Note:
            This can be dangerous if the pointer is from a python object
            that is later on garbage collected.
        """
        (<chip.hipMemAllocNodeParams*>self._ptr)[i].dptr = <void *>cpython.long.PyLong_AsVoidPtr(int(hip._util.types.Pointer.fromPyobj(value)))
    @property
    def dptr(self):
        """Returned device address of the allocation
        Note:
            Setting this dptr can be dangerous if the underlying pointer is from a python object that
            is later on garbage collected.
        """
        return self.get_dptr(0)
    @dptr.setter
    def dptr(self, object value):
        self.set_dptr(0,value)

    @staticmethod
    def PROPERTIES():
        return ["poolProps","accessDescCount","bytesize","dptr"]

    def __contains__(self,item):
        properties = self.PROPERTIES()
        return item in properties

    def __getitem__(self,item):
        properties = self.PROPERTIES()
        if isinstance(item,int):
            if item < 0 or item >= len(properties):
                raise IndexError()
            return getattr(self,properties[item])
        raise ValueError("'item' type must be 'int'")


class _hipAccessProperty__Base(enum.IntEnum):
    """Empty enum base class that allows subclassing.
    """
    pass
class hipAccessProperty(_hipAccessProperty__Base):
    """hipAccessProperty

    Attributes:
        hipAccessPropertyNormal:
            (undocumented)
        hipAccessPropertyStreaming:
            (undocumented)
        hipAccessPropertyPersisting:
            (undocumented)
    """
    hipAccessPropertyNormal = chip.hipAccessPropertyNormal
    hipAccessPropertyStreaming = chip.hipAccessPropertyStreaming
    hipAccessPropertyPersisting = chip.hipAccessPropertyPersisting
    @staticmethod
    def ctypes_type():
        """The type of the enum constants as ctypes type."""
        return ctypes.c_uint


cdef class hipAccessPolicyWindow(hip._util.types.Pointer):
    """Python wrapper for cdef class chip.hipAccessPolicyWindow.

    Python wrapper for cdef class chip.hipAccessPolicyWindow.

    If this type is initialized via its `__init__` method, it allocates a
    member of the underlying C type and destroys it again if the wrapper
    type is deallocated.

    This type also serves as adapter when appearing as argument type in a
    function signature. In this case, the type can further be initialized
    from a number of Python objects:

    * `None`:

      This will set the ``self._ptr`` attribute to ``NULL``.

    * `int`:

      Interprets the integer value as pointer address and writes it to ``self._ptr``.
      No ownership is transferred.

    * `ctypes.c_void_p`:

      Takes the pointer address ``pyobj.value`` and writes it to ``self._ptr``.
      No ownership is transferred.

    * `object` that implements the `CUDA Array Interface <https://numba.readthedocs.io/en/stable/cuda/cuda_array_interface.html>`_ protocol:

      Takes the integer-valued pointer address, i.e. the first entry of the `data` tuple
      from `pyobj`'s member ``__cuda_array_interface__``  and writes it to ``self._ptr``.

    * `object` that implements the Python buffer protocol:

      If the object represents a simple contiguous array,
      writes the `Py_buffer` associated with ``pyobj`` to `self._py_buffer`,
      sets the `self._py_buffer_acquired` flag to `True`, and
      writes `self._py_buffer.buf` to the data pointer `self._ptr`.

    * `hip._util.types.Pointer`:

      Takes the pointer address ``pyobj._ptr`` and writes it to ``self._ptr``.
      No ownership is transferred.

    Type checks are performed in the above order.

    C Attributes:
        _ptr (C type ``void *``, protected):
            Stores a pointer to the data of the original Python object.
        _is_ptr_owner (C type ``bint``, protected):
            If this wrapper is the owner of the underlying data.
        _py_buffer (C type ``Py_buffer`, protected):
            Stores a pointer to the data of the original Python object.
        _py_buffer_acquired (C type ``bint``, protected):
            Stores a pointer to the data of the original Python object.
    """
    # C members declared in pxd file

    def __cinit__(self):
        self._ptr = NULL
        self._is_ptr_owner = False
        self._py_buffer_acquired = False

    cdef chip.hipAccessPolicyWindow* getElementPtr(self):
        return <chip.hipAccessPolicyWindow*>self._ptr

    @staticmethod
    cdef hipAccessPolicyWindow fromPtr(void* ptr, bint owner=False):
        """Factory function to create ``hipAccessPolicyWindow`` objects from
        given ``chip.hipAccessPolicyWindow`` pointer.

        Setting ``owner`` flag to ``True`` causes
        the extension type to free the structure pointed to by ``ptr``
        when the wrapper object is deallocated.
        """
        # Fast call to __new__() that bypasses the __init__() constructor.
        cdef hipAccessPolicyWindow wrapper = hipAccessPolicyWindow.__new__(hipAccessPolicyWindow)
        wrapper._ptr = ptr
        wrapper._is_ptr_owner = owner
        return wrapper

    @staticmethod
    def fromObj(pyobj):
        """Creates a hipAccessPolicyWindow from a Python object.

        Derives a hipAccessPolicyWindow from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``hipAccessPolicyWindow`` reference, this method
        returns it directly. No new ``hipAccessPolicyWindow`` is created in this case.
        """
        return hipAccessPolicyWindow.fromPyobj(pyobj)

    @staticmethod
    cdef hipAccessPolicyWindow fromPyobj(object pyobj):
        """Creates a hipAccessPolicyWindow from a Python object.

        Derives a hipAccessPolicyWindow from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``hipAccessPolicyWindow`` reference, this method
        returns it directly. No new ``hipAccessPolicyWindow`` is created in this case.

        Args:
            pyobj (object): Must be either `None`; a `hip._util.types.Pointer`; a simple, contiguous buffer according to the buffer protocol;
                            or of type `hipAccessPolicyWindow`; `int`; or `ctypes.c_void_p`.

        Note:
            This routine does not perform a copy but returns the original ``pyobj``
            if ``pyobj`` is an instance of hipAccessPolicyWindow!
        """
        cdef hipAccessPolicyWindow wrapper

        if isinstance(pyobj,hipAccessPolicyWindow):
            return pyobj
        else:
            wrapper = hipAccessPolicyWindow.__new__(hipAccessPolicyWindow)
            wrapper.init_from_pyobj(pyobj)
            return wrapper

    def __dealloc__(self):
        # Release the buffer handle
        if self._py_buffer_acquired is True:
            cpython.buffer.PyBuffer_Release(&self._py_buffer)
        # De-allocate if not null and flag is set
        if self._ptr is not NULL and self._is_ptr_owner is True:
            stdlib.free(self._ptr)
            self._ptr = NULL

    @staticmethod
    cdef __allocate(void** ptr):
        ptr[0] = stdlib.malloc(sizeof(chip.hipAccessPolicyWindow))
        string.memset(<void*>ptr[0], 0, sizeof(chip.hipAccessPolicyWindow))

        if ptr[0] is NULL:
            raise MemoryError

    @staticmethod
    cdef hipAccessPolicyWindow new():
        """Factory function to create hipAccessPolicyWindow objects with
        newly allocated chip.hipAccessPolicyWindow"""
        cdef void* ptr
        hipAccessPolicyWindow.__allocate(&ptr)
        return hipAccessPolicyWindow.fromPtr(ptr, owner=True)

    @staticmethod
    cdef hipAccessPolicyWindow fromValue(chip.hipAccessPolicyWindow other):
        """Allocate new C type and copy from ``other``.
        """
        wrapper = hipAccessPolicyWindow.new()
        string.memcpy(wrapper._ptr, &other, sizeof(chip.hipAccessPolicyWindow))
        return wrapper

    def c_sizeof(self):
        """Returns the size of the underlying C type in bytes.
        Note:
            Implemented as function to not collide with
            autogenerated property names.
        """
        return sizeof(chip.hipAccessPolicyWindow)

    def __int__(self):
        """Returns the data's address as long integer.
        """
        return cpython.long.PyLong_FromVoidPtr(self._ptr)

    def __repr__(self):
        return f"<hipAccessPolicyWindow object, ptr: {int(self)}>"

    def as_c_void_p(self):
        """Returns the data's address as `ctypes.c_void_p`
        Note:
            Implemented as function to not collide with
            autogenerated property names.
        """
        return ctypes.c_void_p(int(self))

    def __init__(self,*args,**kwargs):
        """Constructor type hipAccessPolicyWindow.

        Constructor for type hipAccessPolicyWindow.

        Args:
            *args:
                Positional arguments. Initialize all or a subset of the member variables
                according to their order of declaration.
            **kwargs:
                Can be used to initialize member variables at construction,
                Just pass an argument expression of the form <member>=<value>
                per member that you want to initialize.
        """
        hipAccessPolicyWindow.__allocate(&self._ptr)
        self._is_ptr_owner = True
        attribs = self.PROPERTIES()
        used_attribs = set()
        if len(args) > len(attribs):
            raise ValueError("More positional arguments specified than this type has properties.")
        for i,v in enumerate(args):
            setattr(self,attribs[i],v)
            used_attribs.add(attribs[i])
        valid_names = ", ".join(["'"+p+"'" for p in attribs])
        for k,v in kwargs.items():
            if k in used_attribs:
                raise KeyError(f"argument '{k}' has already been specified as positional argument.")
            elif k not in attribs:
                raise KeyError(f"'{k}' is no valid property name. Valid names: {valid_names}")
            setattr(self,k,v)
    def get_base_ptr(self, i):
        """Get value ``base_ptr`` of ``(<chip.hipAccessPolicyWindow*>self._ptr)[i]``.
        """
        return hip._util.types.Pointer.fromPtr((<chip.hipAccessPolicyWindow*>self._ptr)[i].base_ptr)
    def set_base_ptr(self, i, object value):
        """Set value ``base_ptr`` of ``(<chip.hipAccessPolicyWindow*>self._ptr)[i]``.

        Note:
            This can be dangerous if the pointer is from a python object
            that is later on garbage collected.
        """
        (<chip.hipAccessPolicyWindow*>self._ptr)[i].base_ptr = <void *>cpython.long.PyLong_AsVoidPtr(int(hip._util.types.Pointer.fromPyobj(value)))
    @property
    def base_ptr(self):
        """(undocumented)
        Note:
            Setting this base_ptr can be dangerous if the underlying pointer is from a python object that
            is later on garbage collected.
        """
        return self.get_base_ptr(0)
    @base_ptr.setter
    def base_ptr(self, object value):
        self.set_base_ptr(0,value)

    def get_hitProp(self, i):
        """Get value of ``hitProp`` of ``(<chip.hipAccessPolicyWindow*>self._ptr)[i]``.
        """
        return hipAccessProperty((<chip.hipAccessPolicyWindow*>self._ptr)[i].hitProp)
    def set_hitProp(self, i, value):
        """Set value ``hitProp`` of ``(<chip.hipAccessPolicyWindow*>self._ptr)[i]``.
        """
        if not isinstance(value, hipAccessProperty):
            raise TypeError("'value' must be of type 'hipAccessProperty'")
        (<chip.hipAccessPolicyWindow*>self._ptr)[i].hitProp = value.value
    @property
    def hitProp(self):
        """(undocumented)"""
        return self.get_hitProp(0)
    @hitProp.setter
    def hitProp(self, value):
        self.set_hitProp(0,value)

    def get_hitRatio(self, i):
        """Get value ``hitRatio`` of ``(<chip.hipAccessPolicyWindow*>self._ptr)[i]``.
        """
        return (<chip.hipAccessPolicyWindow*>self._ptr)[i].hitRatio
    def set_hitRatio(self, i, float value):
        """Set value ``hitRatio`` of ``(<chip.hipAccessPolicyWindow*>self._ptr)[i]``.
        """
        (<chip.hipAccessPolicyWindow*>self._ptr)[i].hitRatio = value
    @property
    def hitRatio(self):
        """(undocumented)"""
        return self.get_hitRatio(0)
    @hitRatio.setter
    def hitRatio(self, float value):
        self.set_hitRatio(0,value)

    def get_missProp(self, i):
        """Get value of ``missProp`` of ``(<chip.hipAccessPolicyWindow*>self._ptr)[i]``.
        """
        return hipAccessProperty((<chip.hipAccessPolicyWindow*>self._ptr)[i].missProp)
    def set_missProp(self, i, value):
        """Set value ``missProp`` of ``(<chip.hipAccessPolicyWindow*>self._ptr)[i]``.
        """
        if not isinstance(value, hipAccessProperty):
            raise TypeError("'value' must be of type 'hipAccessProperty'")
        (<chip.hipAccessPolicyWindow*>self._ptr)[i].missProp = value.value
    @property
    def missProp(self):
        """(undocumented)"""
        return self.get_missProp(0)
    @missProp.setter
    def missProp(self, value):
        self.set_missProp(0,value)

    def get_num_bytes(self, i):
        """Get value ``num_bytes`` of ``(<chip.hipAccessPolicyWindow*>self._ptr)[i]``.
        """
        return (<chip.hipAccessPolicyWindow*>self._ptr)[i].num_bytes
    def set_num_bytes(self, i, unsigned long value):
        """Set value ``num_bytes`` of ``(<chip.hipAccessPolicyWindow*>self._ptr)[i]``.
        """
        (<chip.hipAccessPolicyWindow*>self._ptr)[i].num_bytes = value
    @property
    def num_bytes(self):
        """(undocumented)"""
        return self.get_num_bytes(0)
    @num_bytes.setter
    def num_bytes(self, unsigned long value):
        self.set_num_bytes(0,value)

    @staticmethod
    def PROPERTIES():
        return ["base_ptr","hitProp","hitRatio","missProp","num_bytes"]

    def __contains__(self,item):
        properties = self.PROPERTIES()
        return item in properties

    def __getitem__(self,item):
        properties = self.PROPERTIES()
        if isinstance(item,int):
            if item < 0 or item >= len(properties):
                raise IndexError()
            return getattr(self,properties[item])
        raise ValueError("'item' type must be 'int'")


class _hipLaunchAttributeID__Base(enum.IntEnum):
    """Empty enum base class that allows subclassing.
    """
    pass
class hipLaunchAttributeID(_hipLaunchAttributeID__Base):
    """Launch Attribute ID

    Attributes:
        hipLaunchAttributeAccessPolicyWindow:
            Valid for Streams, graph nodes, launches
        hipLaunchAttributeCooperative:
            Valid for graph nodes, launches
        hipLaunchAttributePriority:
            Valid for graph node, streams, launches
    """
    hipLaunchAttributeAccessPolicyWindow = chip.hipLaunchAttributeAccessPolicyWindow
    hipLaunchAttributeCooperative = chip.hipLaunchAttributeCooperative
    hipLaunchAttributePriority = chip.hipLaunchAttributePriority
    @staticmethod
    def ctypes_type():
        """The type of the enum constants as ctypes type."""
        return ctypes.c_uint


cdef class hipLaunchAttributeValue(hip._util.types.Pointer):
    """Python wrapper for cdef class chip.hipLaunchAttributeValue.

    Python wrapper for cdef class chip.hipLaunchAttributeValue.

    If this type is initialized via its `__init__` method, it allocates a
    member of the underlying C type and destroys it again if the wrapper
    type is deallocated.

    This type also serves as adapter when appearing as argument type in a
    function signature. In this case, the type can further be initialized
    from a number of Python objects:

    * `None`:

      This will set the ``self._ptr`` attribute to ``NULL``.

    * `int`:

      Interprets the integer value as pointer address and writes it to ``self._ptr``.
      No ownership is transferred.

    * `ctypes.c_void_p`:

      Takes the pointer address ``pyobj.value`` and writes it to ``self._ptr``.
      No ownership is transferred.

    * `object` that implements the `CUDA Array Interface <https://numba.readthedocs.io/en/stable/cuda/cuda_array_interface.html>`_ protocol:

      Takes the integer-valued pointer address, i.e. the first entry of the `data` tuple
      from `pyobj`'s member ``__cuda_array_interface__``  and writes it to ``self._ptr``.

    * `object` that implements the Python buffer protocol:

      If the object represents a simple contiguous array,
      writes the `Py_buffer` associated with ``pyobj`` to `self._py_buffer`,
      sets the `self._py_buffer_acquired` flag to `True`, and
      writes `self._py_buffer.buf` to the data pointer `self._ptr`.

    * `hip._util.types.Pointer`:

      Takes the pointer address ``pyobj._ptr`` and writes it to ``self._ptr``.
      No ownership is transferred.

    Type checks are performed in the above order.

    C Attributes:
        _ptr (C type ``void *``, protected):
            Stores a pointer to the data of the original Python object.
        _is_ptr_owner (C type ``bint``, protected):
            If this wrapper is the owner of the underlying data.
        _py_buffer (C type ``Py_buffer`, protected):
            Stores a pointer to the data of the original Python object.
        _py_buffer_acquired (C type ``bint``, protected):
            Stores a pointer to the data of the original Python object.
    """
    # C members declared in pxd file

    def __cinit__(self):
        self._ptr = NULL
        self._is_ptr_owner = False
        self._py_buffer_acquired = False

    cdef chip.hipLaunchAttributeValue* getElementPtr(self):
        return <chip.hipLaunchAttributeValue*>self._ptr

    @staticmethod
    cdef hipLaunchAttributeValue fromPtr(void* ptr, bint owner=False):
        """Factory function to create ``hipLaunchAttributeValue`` objects from
        given ``chip.hipLaunchAttributeValue`` pointer.

        Setting ``owner`` flag to ``True`` causes
        the extension type to free the structure pointed to by ``ptr``
        when the wrapper object is deallocated.
        """
        # Fast call to __new__() that bypasses the __init__() constructor.
        cdef hipLaunchAttributeValue wrapper = hipLaunchAttributeValue.__new__(hipLaunchAttributeValue)
        wrapper._ptr = ptr
        wrapper._is_ptr_owner = owner
        return wrapper

    @staticmethod
    def fromObj(pyobj):
        """Creates a hipLaunchAttributeValue from a Python object.

        Derives a hipLaunchAttributeValue from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``hipLaunchAttributeValue`` reference, this method
        returns it directly. No new ``hipLaunchAttributeValue`` is created in this case.
        """
        return hipLaunchAttributeValue.fromPyobj(pyobj)

    @staticmethod
    cdef hipLaunchAttributeValue fromPyobj(object pyobj):
        """Creates a hipLaunchAttributeValue from a Python object.

        Derives a hipLaunchAttributeValue from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``hipLaunchAttributeValue`` reference, this method
        returns it directly. No new ``hipLaunchAttributeValue`` is created in this case.

        Args:
            pyobj (object): Must be either `None`; a `hip._util.types.Pointer`; a simple, contiguous buffer according to the buffer protocol;
                            or of type `hipLaunchAttributeValue`; `int`; or `ctypes.c_void_p`.

        Note:
            This routine does not perform a copy but returns the original ``pyobj``
            if ``pyobj`` is an instance of hipLaunchAttributeValue!
        """
        cdef hipLaunchAttributeValue wrapper

        if isinstance(pyobj,hipLaunchAttributeValue):
            return pyobj
        else:
            wrapper = hipLaunchAttributeValue.__new__(hipLaunchAttributeValue)
            wrapper.init_from_pyobj(pyobj)
            return wrapper

    def __dealloc__(self):
        # Release the buffer handle
        if self._py_buffer_acquired is True:
            cpython.buffer.PyBuffer_Release(&self._py_buffer)
        # De-allocate if not null and flag is set
        if self._ptr is not NULL and self._is_ptr_owner is True:
            stdlib.free(self._ptr)
            self._ptr = NULL

    @staticmethod
    cdef __allocate(void** ptr):
        ptr[0] = stdlib.malloc(sizeof(chip.hipLaunchAttributeValue))
        string.memset(<void*>ptr[0], 0, sizeof(chip.hipLaunchAttributeValue))

        if ptr[0] is NULL:
            raise MemoryError

    @staticmethod
    cdef hipLaunchAttributeValue new():
        """Factory function to create hipLaunchAttributeValue objects with
        newly allocated chip.hipLaunchAttributeValue"""
        cdef void* ptr
        hipLaunchAttributeValue.__allocate(&ptr)
        return hipLaunchAttributeValue.fromPtr(ptr, owner=True)

    @staticmethod
    cdef hipLaunchAttributeValue fromValue(chip.hipLaunchAttributeValue other):
        """Allocate new C type and copy from ``other``.
        """
        wrapper = hipLaunchAttributeValue.new()
        string.memcpy(wrapper._ptr, &other, sizeof(chip.hipLaunchAttributeValue))
        return wrapper

    def c_sizeof(self):
        """Returns the size of the underlying C type in bytes.
        Note:
            Implemented as function to not collide with
            autogenerated property names.
        """
        return sizeof(chip.hipLaunchAttributeValue)

    def __int__(self):
        """Returns the data's address as long integer.
        """
        return cpython.long.PyLong_FromVoidPtr(self._ptr)

    def __repr__(self):
        return f"<hipLaunchAttributeValue object, ptr: {int(self)}>"

    def as_c_void_p(self):
        """Returns the data's address as `ctypes.c_void_p`
        Note:
            Implemented as function to not collide with
            autogenerated property names.
        """
        return ctypes.c_void_p(int(self))

    def __init__(self,**kwargs):
        """Constructor type hipLaunchAttributeValue.

        Constructor for type hipLaunchAttributeValue.

        Args:
            **kwargs:
                Can be used to initialize member variables at construction,
                Just pass an argument expression of the form <member>=<value>
                per member that you want to initialize.
        """
        hipLaunchAttributeValue.__allocate(&self._ptr)
        self._is_ptr_owner = True
        attribs = self.PROPERTIES()
        used_attribs = set()
        if len(kwargs) > 1:
            raise ValueError("Not more than one attribute might specified for Python types derived from C union types.")
        valid_names = ", ".join(["'"+p+"'" for p in attribs])
        for k,v in kwargs.items():
            if k in used_attribs:
                raise KeyError(f"argument '{k}' has already been specified as positional argument.")
            elif k not in attribs:
                raise KeyError(f"'{k}' is no valid property name. Valid names: {valid_names}")
            setattr(self,k,v)
    def get_accessPolicyWindow(self, i):
        """Get value of ``accessPolicyWindow`` of ``(<chip.hipLaunchAttributeValue*>self._ptr)[i]``.
        """
        return hipAccessPolicyWindow.fromPtr(&(<chip.hipLaunchAttributeValue*>self._ptr)[i].accessPolicyWindow)
    @property
    def accessPolicyWindow(self):
        """Value of launch attribute:: hipLaunchAttributePolicyWindow."""
        return self.get_accessPolicyWindow(0)

    def get_cooperative(self, i):
        """Get value ``cooperative`` of ``(<chip.hipLaunchAttributeValue*>self._ptr)[i]``.
        """
        return (<chip.hipLaunchAttributeValue*>self._ptr)[i].cooperative
    def set_cooperative(self, i, int value):
        """Set value ``cooperative`` of ``(<chip.hipLaunchAttributeValue*>self._ptr)[i]``.
        """
        (<chip.hipLaunchAttributeValue*>self._ptr)[i].cooperative = value
    @property
    def cooperative(self):
        """Value of launch attribute `~.hipLaunchAttributeCooperative`"""
        return self.get_cooperative(0)
    @cooperative.setter
    def cooperative(self, int value):
        self.set_cooperative(0,value)

    def get_priority(self, i):
        """Get value ``priority`` of ``(<chip.hipLaunchAttributeValue*>self._ptr)[i]``.
        """
        return (<chip.hipLaunchAttributeValue*>self._ptr)[i].priority
    def set_priority(self, i, int value):
        """Set value ``priority`` of ``(<chip.hipLaunchAttributeValue*>self._ptr)[i]``.
        """
        (<chip.hipLaunchAttributeValue*>self._ptr)[i].priority = value
    @property
    def priority(self):
        """Value of launch attribute :: hipLaunchAttributePriority. Execution priority of kernel."""
        return self.get_priority(0)
    @priority.setter
    def priority(self, int value):
        self.set_priority(0,value)

    @staticmethod
    def PROPERTIES():
        return ["accessPolicyWindow","cooperative","priority"]


cdef class HIP_MEMSET_NODE_PARAMS(hip._util.types.Pointer):
    """Python wrapper for cdef class chip.HIP_MEMSET_NODE_PARAMS.

    Python wrapper for cdef class chip.HIP_MEMSET_NODE_PARAMS.

    If this type is initialized via its `__init__` method, it allocates a
    member of the underlying C type and destroys it again if the wrapper
    type is deallocated.

    This type also serves as adapter when appearing as argument type in a
    function signature. In this case, the type can further be initialized
    from a number of Python objects:

    * `None`:

      This will set the ``self._ptr`` attribute to ``NULL``.

    * `int`:

      Interprets the integer value as pointer address and writes it to ``self._ptr``.
      No ownership is transferred.

    * `ctypes.c_void_p`:

      Takes the pointer address ``pyobj.value`` and writes it to ``self._ptr``.
      No ownership is transferred.

    * `object` that implements the `CUDA Array Interface <https://numba.readthedocs.io/en/stable/cuda/cuda_array_interface.html>`_ protocol:

      Takes the integer-valued pointer address, i.e. the first entry of the `data` tuple
      from `pyobj`'s member ``__cuda_array_interface__``  and writes it to ``self._ptr``.

    * `object` that implements the Python buffer protocol:

      If the object represents a simple contiguous array,
      writes the `Py_buffer` associated with ``pyobj`` to `self._py_buffer`,
      sets the `self._py_buffer_acquired` flag to `True`, and
      writes `self._py_buffer.buf` to the data pointer `self._ptr`.

    * `hip._util.types.Pointer`:

      Takes the pointer address ``pyobj._ptr`` and writes it to ``self._ptr``.
      No ownership is transferred.

    Type checks are performed in the above order.

    C Attributes:
        _ptr (C type ``void *``, protected):
            Stores a pointer to the data of the original Python object.
        _is_ptr_owner (C type ``bint``, protected):
            If this wrapper is the owner of the underlying data.
        _py_buffer (C type ``Py_buffer`, protected):
            Stores a pointer to the data of the original Python object.
        _py_buffer_acquired (C type ``bint``, protected):
            Stores a pointer to the data of the original Python object.
    """
    # C members declared in pxd file

    def __cinit__(self):
        self._ptr = NULL
        self._is_ptr_owner = False
        self._py_buffer_acquired = False

    cdef chip.HIP_MEMSET_NODE_PARAMS* getElementPtr(self):
        return <chip.HIP_MEMSET_NODE_PARAMS*>self._ptr

    @staticmethod
    cdef HIP_MEMSET_NODE_PARAMS fromPtr(void* ptr, bint owner=False):
        """Factory function to create ``HIP_MEMSET_NODE_PARAMS`` objects from
        given ``chip.HIP_MEMSET_NODE_PARAMS`` pointer.

        Setting ``owner`` flag to ``True`` causes
        the extension type to free the structure pointed to by ``ptr``
        when the wrapper object is deallocated.
        """
        # Fast call to __new__() that bypasses the __init__() constructor.
        cdef HIP_MEMSET_NODE_PARAMS wrapper = HIP_MEMSET_NODE_PARAMS.__new__(HIP_MEMSET_NODE_PARAMS)
        wrapper._ptr = ptr
        wrapper._is_ptr_owner = owner
        return wrapper

    @staticmethod
    def fromObj(pyobj):
        """Creates a HIP_MEMSET_NODE_PARAMS from a Python object.

        Derives a HIP_MEMSET_NODE_PARAMS from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``HIP_MEMSET_NODE_PARAMS`` reference, this method
        returns it directly. No new ``HIP_MEMSET_NODE_PARAMS`` is created in this case.
        """
        return HIP_MEMSET_NODE_PARAMS.fromPyobj(pyobj)

    @staticmethod
    cdef HIP_MEMSET_NODE_PARAMS fromPyobj(object pyobj):
        """Creates a HIP_MEMSET_NODE_PARAMS from a Python object.

        Derives a HIP_MEMSET_NODE_PARAMS from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``HIP_MEMSET_NODE_PARAMS`` reference, this method
        returns it directly. No new ``HIP_MEMSET_NODE_PARAMS`` is created in this case.

        Args:
            pyobj (object): Must be either `None`; a `hip._util.types.Pointer`; a simple, contiguous buffer according to the buffer protocol;
                            or of type `HIP_MEMSET_NODE_PARAMS`; `int`; or `ctypes.c_void_p`.

        Note:
            This routine does not perform a copy but returns the original ``pyobj``
            if ``pyobj`` is an instance of HIP_MEMSET_NODE_PARAMS!
        """
        cdef HIP_MEMSET_NODE_PARAMS wrapper

        if isinstance(pyobj,HIP_MEMSET_NODE_PARAMS):
            return pyobj
        else:
            wrapper = HIP_MEMSET_NODE_PARAMS.__new__(HIP_MEMSET_NODE_PARAMS)
            wrapper.init_from_pyobj(pyobj)
            return wrapper

    def __dealloc__(self):
        # Release the buffer handle
        if self._py_buffer_acquired is True:
            cpython.buffer.PyBuffer_Release(&self._py_buffer)
        # De-allocate if not null and flag is set
        if self._ptr is not NULL and self._is_ptr_owner is True:
            stdlib.free(self._ptr)
            self._ptr = NULL

    @staticmethod
    cdef __allocate(void** ptr):
        ptr[0] = stdlib.malloc(sizeof(chip.HIP_MEMSET_NODE_PARAMS))
        string.memset(<void*>ptr[0], 0, sizeof(chip.HIP_MEMSET_NODE_PARAMS))

        if ptr[0] is NULL:
            raise MemoryError

    @staticmethod
    cdef HIP_MEMSET_NODE_PARAMS new():
        """Factory function to create HIP_MEMSET_NODE_PARAMS objects with
        newly allocated chip.HIP_MEMSET_NODE_PARAMS"""
        cdef void* ptr
        HIP_MEMSET_NODE_PARAMS.__allocate(&ptr)
        return HIP_MEMSET_NODE_PARAMS.fromPtr(ptr, owner=True)

    @staticmethod
    cdef HIP_MEMSET_NODE_PARAMS fromValue(chip.HIP_MEMSET_NODE_PARAMS other):
        """Allocate new C type and copy from ``other``.
        """
        wrapper = HIP_MEMSET_NODE_PARAMS.new()
        string.memcpy(wrapper._ptr, &other, sizeof(chip.HIP_MEMSET_NODE_PARAMS))
        return wrapper

    def c_sizeof(self):
        """Returns the size of the underlying C type in bytes.
        Note:
            Implemented as function to not collide with
            autogenerated property names.
        """
        return sizeof(chip.HIP_MEMSET_NODE_PARAMS)

    def __int__(self):
        """Returns the data's address as long integer.
        """
        return cpython.long.PyLong_FromVoidPtr(self._ptr)

    def __repr__(self):
        return f"<HIP_MEMSET_NODE_PARAMS object, ptr: {int(self)}>"

    def as_c_void_p(self):
        """Returns the data's address as `ctypes.c_void_p`
        Note:
            Implemented as function to not collide with
            autogenerated property names.
        """
        return ctypes.c_void_p(int(self))

    def __init__(self,*args,**kwargs):
        """Constructor type HIP_MEMSET_NODE_PARAMS.

        Constructor for type HIP_MEMSET_NODE_PARAMS.

        Args:
            *args:
                Positional arguments. Initialize all or a subset of the member variables
                according to their order of declaration.
            **kwargs:
                Can be used to initialize member variables at construction,
                Just pass an argument expression of the form <member>=<value>
                per member that you want to initialize.
        """
        HIP_MEMSET_NODE_PARAMS.__allocate(&self._ptr)
        self._is_ptr_owner = True
        attribs = self.PROPERTIES()
        used_attribs = set()
        if len(args) > len(attribs):
            raise ValueError("More positional arguments specified than this type has properties.")
        for i,v in enumerate(args):
            setattr(self,attribs[i],v)
            used_attribs.add(attribs[i])
        valid_names = ", ".join(["'"+p+"'" for p in attribs])
        for k,v in kwargs.items():
            if k in used_attribs:
                raise KeyError(f"argument '{k}' has already been specified as positional argument.")
            elif k not in attribs:
                raise KeyError(f"'{k}' is no valid property name. Valid names: {valid_names}")
            setattr(self,k,v)
    def get_dst(self, i):
        """Get value ``dst`` of ``(<chip.HIP_MEMSET_NODE_PARAMS*>self._ptr)[i]``.
        """
        return hip._util.types.Pointer.fromPtr((<chip.HIP_MEMSET_NODE_PARAMS*>self._ptr)[i].dst)
    def set_dst(self, i, object value):
        """Set value ``dst`` of ``(<chip.HIP_MEMSET_NODE_PARAMS*>self._ptr)[i]``.

        Note:
            This can be dangerous if the pointer is from a python object
            that is later on garbage collected.
        """
        (<chip.HIP_MEMSET_NODE_PARAMS*>self._ptr)[i].dst = <void *>cpython.long.PyLong_AsVoidPtr(int(hip._util.types.Pointer.fromPyobj(value)))
    @property
    def dst(self):
        """Destination pointer on device
        Note:
            Setting this dst can be dangerous if the underlying pointer is from a python object that
            is later on garbage collected.
        """
        return self.get_dst(0)
    @dst.setter
    def dst(self, object value):
        self.set_dst(0,value)

    def get_pitch(self, i):
        """Get value ``pitch`` of ``(<chip.HIP_MEMSET_NODE_PARAMS*>self._ptr)[i]``.
        """
        return (<chip.HIP_MEMSET_NODE_PARAMS*>self._ptr)[i].pitch
    def set_pitch(self, i, unsigned long value):
        """Set value ``pitch`` of ``(<chip.HIP_MEMSET_NODE_PARAMS*>self._ptr)[i]``.
        """
        (<chip.HIP_MEMSET_NODE_PARAMS*>self._ptr)[i].pitch = value
    @property
    def pitch(self):
        """Destination device pointer pitch. Unused if height equals 1"""
        return self.get_pitch(0)
    @pitch.setter
    def pitch(self, unsigned long value):
        self.set_pitch(0,value)

    def get_value(self, i):
        """Get value ``value`` of ``(<chip.HIP_MEMSET_NODE_PARAMS*>self._ptr)[i]``.
        """
        return (<chip.HIP_MEMSET_NODE_PARAMS*>self._ptr)[i].value
    def set_value(self, i, unsigned int value):
        """Set value ``value`` of ``(<chip.HIP_MEMSET_NODE_PARAMS*>self._ptr)[i]``.
        """
        (<chip.HIP_MEMSET_NODE_PARAMS*>self._ptr)[i].value = value
    @property
    def value(self):
        """Value of memset to be set"""
        return self.get_value(0)
    @value.setter
    def value(self, unsigned int value):
        self.set_value(0,value)

    def get_elementSize(self, i):
        """Get value ``elementSize`` of ``(<chip.HIP_MEMSET_NODE_PARAMS*>self._ptr)[i]``.
        """
        return (<chip.HIP_MEMSET_NODE_PARAMS*>self._ptr)[i].elementSize
    def set_elementSize(self, i, unsigned int value):
        """Set value ``elementSize`` of ``(<chip.HIP_MEMSET_NODE_PARAMS*>self._ptr)[i]``.
        """
        (<chip.HIP_MEMSET_NODE_PARAMS*>self._ptr)[i].elementSize = value
    @property
    def elementSize(self):
        """Element in bytes. Must be 1, 2, or 4."""
        return self.get_elementSize(0)
    @elementSize.setter
    def elementSize(self, unsigned int value):
        self.set_elementSize(0,value)

    def get_width(self, i):
        """Get value ``width`` of ``(<chip.HIP_MEMSET_NODE_PARAMS*>self._ptr)[i]``.
        """
        return (<chip.HIP_MEMSET_NODE_PARAMS*>self._ptr)[i].width
    def set_width(self, i, unsigned long value):
        """Set value ``width`` of ``(<chip.HIP_MEMSET_NODE_PARAMS*>self._ptr)[i]``.
        """
        (<chip.HIP_MEMSET_NODE_PARAMS*>self._ptr)[i].width = value
    @property
    def width(self):
        """Width of a row"""
        return self.get_width(0)
    @width.setter
    def width(self, unsigned long value):
        self.set_width(0,value)

    def get_height(self, i):
        """Get value ``height`` of ``(<chip.HIP_MEMSET_NODE_PARAMS*>self._ptr)[i]``.
        """
        return (<chip.HIP_MEMSET_NODE_PARAMS*>self._ptr)[i].height
    def set_height(self, i, unsigned long value):
        """Set value ``height`` of ``(<chip.HIP_MEMSET_NODE_PARAMS*>self._ptr)[i]``.
        """
        (<chip.HIP_MEMSET_NODE_PARAMS*>self._ptr)[i].height = value
    @property
    def height(self):
        """Number of rows"""
        return self.get_height(0)
    @height.setter
    def height(self, unsigned long value):
        self.set_height(0,value)

    @staticmethod
    def PROPERTIES():
        return ["dst","pitch","value","elementSize","width","height"]

    def __contains__(self,item):
        properties = self.PROPERTIES()
        return item in properties

    def __getitem__(self,item):
        properties = self.PROPERTIES()
        if isinstance(item,int):
            if item < 0 or item >= len(properties):
                raise IndexError()
            return getattr(self,properties[item])
        raise ValueError("'item' type must be 'int'")


class _hipGraphExecUpdateResult__Base(enum.IntEnum):
    """Empty enum base class that allows subclassing.
    """
    pass
class hipGraphExecUpdateResult(_hipGraphExecUpdateResult__Base):
    """Graph execution update result

    Attributes:
        hipGraphExecUpdateSuccess:
            The update succeeded
        hipGraphExecUpdateError:
            The update failed for an unexpected reason which is described in the return value of the function
        hipGraphExecUpdateErrorTopologyChanged:
            The update failed because the topology changed
        hipGraphExecUpdateErrorNodeTypeChanged:
            The update failed because a node type changed
        hipGraphExecUpdateErrorFunctionChanged:
            (undocumented)
        hipGraphExecUpdateErrorParametersChanged:
            (undocumented)
        hipGraphExecUpdateErrorNotSupported:
            (undocumented)
        hipGraphExecUpdateErrorUnsupportedFunctionChange:
            (undocumented)
    """
    hipGraphExecUpdateSuccess = chip.hipGraphExecUpdateSuccess
    hipGraphExecUpdateError = chip.hipGraphExecUpdateError
    hipGraphExecUpdateErrorTopologyChanged = chip.hipGraphExecUpdateErrorTopologyChanged
    hipGraphExecUpdateErrorNodeTypeChanged = chip.hipGraphExecUpdateErrorNodeTypeChanged
    hipGraphExecUpdateErrorFunctionChanged = chip.hipGraphExecUpdateErrorFunctionChanged
    hipGraphExecUpdateErrorParametersChanged = chip.hipGraphExecUpdateErrorParametersChanged
    hipGraphExecUpdateErrorNotSupported = chip.hipGraphExecUpdateErrorNotSupported
    hipGraphExecUpdateErrorUnsupportedFunctionChange = chip.hipGraphExecUpdateErrorUnsupportedFunctionChange
    @staticmethod
    def ctypes_type():
        """The type of the enum constants as ctypes type."""
        return ctypes.c_uint


class _hipStreamCaptureMode__Base(enum.IntEnum):
    """Empty enum base class that allows subclassing.
    """
    pass
class hipStreamCaptureMode(_hipStreamCaptureMode__Base):
    """hipStreamCaptureMode

    Attributes:
        hipStreamCaptureModeGlobal:
            (undocumented)
        hipStreamCaptureModeThreadLocal:
            (undocumented)
        hipStreamCaptureModeRelaxed:
            (undocumented)
    """
    hipStreamCaptureModeGlobal = chip.hipStreamCaptureModeGlobal
    hipStreamCaptureModeThreadLocal = chip.hipStreamCaptureModeThreadLocal
    hipStreamCaptureModeRelaxed = chip.hipStreamCaptureModeRelaxed
    @staticmethod
    def ctypes_type():
        """The type of the enum constants as ctypes type."""
        return ctypes.c_uint


class _hipStreamCaptureStatus__Base(enum.IntEnum):
    """Empty enum base class that allows subclassing.
    """
    pass
class hipStreamCaptureStatus(_hipStreamCaptureStatus__Base):
    """hipStreamCaptureStatus

    Attributes:
        hipStreamCaptureStatusNone:
            Stream is not capturing
        hipStreamCaptureStatusActive:
            Stream is actively capturing
        hipStreamCaptureStatusInvalidated:
            Stream is part of a capture sequence that has been invalidated, but not terminated
    """
    hipStreamCaptureStatusNone = chip.hipStreamCaptureStatusNone
    hipStreamCaptureStatusActive = chip.hipStreamCaptureStatusActive
    hipStreamCaptureStatusInvalidated = chip.hipStreamCaptureStatusInvalidated
    @staticmethod
    def ctypes_type():
        """The type of the enum constants as ctypes type."""
        return ctypes.c_uint


class _hipStreamUpdateCaptureDependenciesFlags__Base(enum.IntEnum):
    """Empty enum base class that allows subclassing.
    """
    pass
class hipStreamUpdateCaptureDependenciesFlags(_hipStreamUpdateCaptureDependenciesFlags__Base):
    """hipStreamUpdateCaptureDependenciesFlags

    Attributes:
        hipStreamAddCaptureDependencies:
            Add new nodes to the dependency set
        hipStreamSetCaptureDependencies:
            Replace the dependency set with the new nodes
    """
    hipStreamAddCaptureDependencies = chip.hipStreamAddCaptureDependencies
    hipStreamSetCaptureDependencies = chip.hipStreamSetCaptureDependencies
    @staticmethod
    def ctypes_type():
        """The type of the enum constants as ctypes type."""
        return ctypes.c_uint


class _hipGraphMemAttributeType__Base(enum.IntEnum):
    """Empty enum base class that allows subclassing.
    """
    pass
class hipGraphMemAttributeType(_hipGraphMemAttributeType__Base):
    """hipGraphMemAttributeType

    Attributes:
        hipGraphMemAttrUsedMemCurrent:
            Amount of memory, in bytes, currently associated with graphs
        hipGraphMemAttrUsedMemHigh:
            High watermark of memory, in bytes, associated with graphs since the last time.
        hipGraphMemAttrReservedMemCurrent:
            Amount of memory, in bytes, currently allocated for graphs.
        hipGraphMemAttrReservedMemHigh:
            High watermark of memory, in bytes, currently allocated for graphs
    """
    hipGraphMemAttrUsedMemCurrent = chip.hipGraphMemAttrUsedMemCurrent
    hipGraphMemAttrUsedMemHigh = chip.hipGraphMemAttrUsedMemHigh
    hipGraphMemAttrReservedMemCurrent = chip.hipGraphMemAttrReservedMemCurrent
    hipGraphMemAttrReservedMemHigh = chip.hipGraphMemAttrReservedMemHigh
    @staticmethod
    def ctypes_type():
        """The type of the enum constants as ctypes type."""
        return ctypes.c_uint


class _hipUserObjectFlags__Base(enum.IntEnum):
    """Empty enum base class that allows subclassing.
    """
    pass
class hipUserObjectFlags(_hipUserObjectFlags__Base):
    """hipUserObjectFlags

    Attributes:
        hipUserObjectNoDestructorSync:
            Destructor execution is not synchronized.
    """
    hipUserObjectNoDestructorSync = chip.hipUserObjectNoDestructorSync
    @staticmethod
    def ctypes_type():
        """The type of the enum constants as ctypes type."""
        return ctypes.c_uint


class _hipUserObjectRetainFlags__Base(enum.IntEnum):
    """Empty enum base class that allows subclassing.
    """
    pass
class hipUserObjectRetainFlags(_hipUserObjectRetainFlags__Base):
    """hipUserObjectRetainFlags

    Attributes:
        hipGraphUserObjectMove:
            Add new reference or retain.
    """
    hipGraphUserObjectMove = chip.hipGraphUserObjectMove
    @staticmethod
    def ctypes_type():
        """The type of the enum constants as ctypes type."""
        return ctypes.c_uint


class _hipGraphInstantiateFlags__Base(enum.IntEnum):
    """Empty enum base class that allows subclassing.
    """
    pass
class hipGraphInstantiateFlags(_hipGraphInstantiateFlags__Base):
    """hipGraphInstantiateFlags

    Attributes:
        hipGraphInstantiateFlagAutoFreeOnLaunch:
            (undocumented)
        hipGraphInstantiateFlagUpload:
            (undocumented)
        hipGraphInstantiateFlagDeviceLaunch:
            (undocumented)
        hipGraphInstantiateFlagUseNodePriority:
            (undocumented)
    """
    hipGraphInstantiateFlagAutoFreeOnLaunch = chip.hipGraphInstantiateFlagAutoFreeOnLaunch
    hipGraphInstantiateFlagUpload = chip.hipGraphInstantiateFlagUpload
    hipGraphInstantiateFlagDeviceLaunch = chip.hipGraphInstantiateFlagDeviceLaunch
    hipGraphInstantiateFlagUseNodePriority = chip.hipGraphInstantiateFlagUseNodePriority
    @staticmethod
    def ctypes_type():
        """The type of the enum constants as ctypes type."""
        return ctypes.c_uint


class _hipGraphDebugDotFlags__Base(enum.IntEnum):
    """Empty enum base class that allows subclassing.
    """
    pass
class hipGraphDebugDotFlags(_hipGraphDebugDotFlags__Base):
    """hipGraphDebugDotFlags

    Attributes:
        hipGraphDebugDotFlagsVerbose:
            (undocumented)
        hipGraphDebugDotFlagsKernelNodeParams:
            Adds hipKernelNodeParams to output
        hipGraphDebugDotFlagsMemcpyNodeParams:
            Adds hipMemcpy3DParms to output
        hipGraphDebugDotFlagsMemsetNodeParams:
            Adds hipMemsetParams to output
        hipGraphDebugDotFlagsHostNodeParams:
            Adds hipHostNodeParams to output
        hipGraphDebugDotFlagsEventNodeParams:
            (undocumented)
        hipGraphDebugDotFlagsExtSemasSignalNodeParams:
            (undocumented)
        hipGraphDebugDotFlagsExtSemasWaitNodeParams:
            (undocumented)
        hipGraphDebugDotFlagsKernelNodeAttributes:
            (undocumented)
        hipGraphDebugDotFlagsHandles:
            (undocumented)
    """
    hipGraphDebugDotFlagsVerbose = chip.hipGraphDebugDotFlagsVerbose
    hipGraphDebugDotFlagsKernelNodeParams = chip.hipGraphDebugDotFlagsKernelNodeParams
    hipGraphDebugDotFlagsMemcpyNodeParams = chip.hipGraphDebugDotFlagsMemcpyNodeParams
    hipGraphDebugDotFlagsMemsetNodeParams = chip.hipGraphDebugDotFlagsMemsetNodeParams
    hipGraphDebugDotFlagsHostNodeParams = chip.hipGraphDebugDotFlagsHostNodeParams
    hipGraphDebugDotFlagsEventNodeParams = chip.hipGraphDebugDotFlagsEventNodeParams
    hipGraphDebugDotFlagsExtSemasSignalNodeParams = chip.hipGraphDebugDotFlagsExtSemasSignalNodeParams
    hipGraphDebugDotFlagsExtSemasWaitNodeParams = chip.hipGraphDebugDotFlagsExtSemasWaitNodeParams
    hipGraphDebugDotFlagsKernelNodeAttributes = chip.hipGraphDebugDotFlagsKernelNodeAttributes
    hipGraphDebugDotFlagsHandles = chip.hipGraphDebugDotFlagsHandles
    @staticmethod
    def ctypes_type():
        """The type of the enum constants as ctypes type."""
        return ctypes.c_uint


class _hipGraphInstantiateResult__Base(enum.IntEnum):
    """Empty enum base class that allows subclassing.
    """
    pass
class hipGraphInstantiateResult(_hipGraphInstantiateResult__Base):
    """hipGraphInstantiateWithParams results

    Attributes:
        hipGraphInstantiateSuccess:
            Instantiation Success
        hipGraphInstantiateError:
            Instantiation failed for an unexpected reason which is described in the return value of the function
        hipGraphInstantiateInvalidStructure:
            Instantiation failed due to invalid structure, such as cycles
        hipGraphInstantiateNodeOperationNotSupported:
            Instantiation for device launch failed because the graph contained an unsupported operation
        hipGraphInstantiateMultipleDevicesNotSupported:
            Instantiation for device launch failed due to the nodes belonging to different contexts
    """
    hipGraphInstantiateSuccess = chip.hipGraphInstantiateSuccess
    hipGraphInstantiateError = chip.hipGraphInstantiateError
    hipGraphInstantiateInvalidStructure = chip.hipGraphInstantiateInvalidStructure
    hipGraphInstantiateNodeOperationNotSupported = chip.hipGraphInstantiateNodeOperationNotSupported
    hipGraphInstantiateMultipleDevicesNotSupported = chip.hipGraphInstantiateMultipleDevicesNotSupported
    @staticmethod
    def ctypes_type():
        """The type of the enum constants as ctypes type."""
        return ctypes.c_uint


cdef class hipGraphInstantiateParams(hip._util.types.Pointer):
    """Python wrapper for cdef class chip.hipGraphInstantiateParams.

    Python wrapper for cdef class chip.hipGraphInstantiateParams.

    If this type is initialized via its `__init__` method, it allocates a
    member of the underlying C type and destroys it again if the wrapper
    type is deallocated.

    This type also serves as adapter when appearing as argument type in a
    function signature. In this case, the type can further be initialized
    from a number of Python objects:

    * `None`:

      This will set the ``self._ptr`` attribute to ``NULL``.

    * `int`:

      Interprets the integer value as pointer address and writes it to ``self._ptr``.
      No ownership is transferred.

    * `ctypes.c_void_p`:

      Takes the pointer address ``pyobj.value`` and writes it to ``self._ptr``.
      No ownership is transferred.

    * `object` that implements the `CUDA Array Interface <https://numba.readthedocs.io/en/stable/cuda/cuda_array_interface.html>`_ protocol:

      Takes the integer-valued pointer address, i.e. the first entry of the `data` tuple
      from `pyobj`'s member ``__cuda_array_interface__``  and writes it to ``self._ptr``.

    * `object` that implements the Python buffer protocol:

      If the object represents a simple contiguous array,
      writes the `Py_buffer` associated with ``pyobj`` to `self._py_buffer`,
      sets the `self._py_buffer_acquired` flag to `True`, and
      writes `self._py_buffer.buf` to the data pointer `self._ptr`.

    * `hip._util.types.Pointer`:

      Takes the pointer address ``pyobj._ptr`` and writes it to ``self._ptr``.
      No ownership is transferred.

    Type checks are performed in the above order.

    C Attributes:
        _ptr (C type ``void *``, protected):
            Stores a pointer to the data of the original Python object.
        _is_ptr_owner (C type ``bint``, protected):
            If this wrapper is the owner of the underlying data.
        _py_buffer (C type ``Py_buffer`, protected):
            Stores a pointer to the data of the original Python object.
        _py_buffer_acquired (C type ``bint``, protected):
            Stores a pointer to the data of the original Python object.
    """
    # C members declared in pxd file

    def __cinit__(self):
        self._ptr = NULL
        self._is_ptr_owner = False
        self._py_buffer_acquired = False

    cdef chip.hipGraphInstantiateParams* getElementPtr(self):
        return <chip.hipGraphInstantiateParams*>self._ptr

    @staticmethod
    cdef hipGraphInstantiateParams fromPtr(void* ptr, bint owner=False):
        """Factory function to create ``hipGraphInstantiateParams`` objects from
        given ``chip.hipGraphInstantiateParams`` pointer.

        Setting ``owner`` flag to ``True`` causes
        the extension type to free the structure pointed to by ``ptr``
        when the wrapper object is deallocated.
        """
        # Fast call to __new__() that bypasses the __init__() constructor.
        cdef hipGraphInstantiateParams wrapper = hipGraphInstantiateParams.__new__(hipGraphInstantiateParams)
        wrapper._ptr = ptr
        wrapper._is_ptr_owner = owner
        return wrapper

    @staticmethod
    def fromObj(pyobj):
        """Creates a hipGraphInstantiateParams from a Python object.

        Derives a hipGraphInstantiateParams from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``hipGraphInstantiateParams`` reference, this method
        returns it directly. No new ``hipGraphInstantiateParams`` is created in this case.
        """
        return hipGraphInstantiateParams.fromPyobj(pyobj)

    @staticmethod
    cdef hipGraphInstantiateParams fromPyobj(object pyobj):
        """Creates a hipGraphInstantiateParams from a Python object.

        Derives a hipGraphInstantiateParams from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``hipGraphInstantiateParams`` reference, this method
        returns it directly. No new ``hipGraphInstantiateParams`` is created in this case.

        Args:
            pyobj (object): Must be either `None`; a `hip._util.types.Pointer`; a simple, contiguous buffer according to the buffer protocol;
                            or of type `hipGraphInstantiateParams`; `int`; or `ctypes.c_void_p`.

        Note:
            This routine does not perform a copy but returns the original ``pyobj``
            if ``pyobj`` is an instance of hipGraphInstantiateParams!
        """
        cdef hipGraphInstantiateParams wrapper

        if isinstance(pyobj,hipGraphInstantiateParams):
            return pyobj
        else:
            wrapper = hipGraphInstantiateParams.__new__(hipGraphInstantiateParams)
            wrapper.init_from_pyobj(pyobj)
            return wrapper

    def __dealloc__(self):
        # Release the buffer handle
        if self._py_buffer_acquired is True:
            cpython.buffer.PyBuffer_Release(&self._py_buffer)
        # De-allocate if not null and flag is set
        if self._ptr is not NULL and self._is_ptr_owner is True:
            stdlib.free(self._ptr)
            self._ptr = NULL

    @staticmethod
    cdef __allocate(void** ptr):
        ptr[0] = stdlib.malloc(sizeof(chip.hipGraphInstantiateParams))
        string.memset(<void*>ptr[0], 0, sizeof(chip.hipGraphInstantiateParams))

        if ptr[0] is NULL:
            raise MemoryError

    @staticmethod
    cdef hipGraphInstantiateParams new():
        """Factory function to create hipGraphInstantiateParams objects with
        newly allocated chip.hipGraphInstantiateParams"""
        cdef void* ptr
        hipGraphInstantiateParams.__allocate(&ptr)
        return hipGraphInstantiateParams.fromPtr(ptr, owner=True)

    @staticmethod
    cdef hipGraphInstantiateParams fromValue(chip.hipGraphInstantiateParams other):
        """Allocate new C type and copy from ``other``.
        """
        wrapper = hipGraphInstantiateParams.new()
        string.memcpy(wrapper._ptr, &other, sizeof(chip.hipGraphInstantiateParams))
        return wrapper

    def c_sizeof(self):
        """Returns the size of the underlying C type in bytes.
        Note:
            Implemented as function to not collide with
            autogenerated property names.
        """
        return sizeof(chip.hipGraphInstantiateParams)

    def __int__(self):
        """Returns the data's address as long integer.
        """
        return cpython.long.PyLong_FromVoidPtr(self._ptr)

    def __repr__(self):
        return f"<hipGraphInstantiateParams object, ptr: {int(self)}>"

    def as_c_void_p(self):
        """Returns the data's address as `ctypes.c_void_p`
        Note:
            Implemented as function to not collide with
            autogenerated property names.
        """
        return ctypes.c_void_p(int(self))

    def __init__(self,**kwargs):
        """Constructor type hipGraphInstantiateParams.

        Constructor for type hipGraphInstantiateParams.

        Args:
            **kwargs:
                Can be used to initialize member variables at construction,
                Just pass an argument expression of the form <member>=<value>
                per member that you want to initialize.
        """
        hipGraphInstantiateParams.__allocate(&self._ptr)
        self._is_ptr_owner = True
        attribs = self.PROPERTIES()
        used_attribs = set()
        valid_names = ", ".join(["'"+p+"'" for p in attribs])
        for k,v in kwargs.items():
            if k in used_attribs:
                raise KeyError(f"argument '{k}' has already been specified as positional argument.")
            elif k not in attribs:
                raise KeyError(f"'{k}' is no valid property name. Valid names: {valid_names}")
            setattr(self,k,v)
    def get_flags(self, i):
        """Get value ``flags`` of ``(<chip.hipGraphInstantiateParams*>self._ptr)[i]``.
        """
        return (<chip.hipGraphInstantiateParams*>self._ptr)[i].flags
    def set_flags(self, i, unsigned long long value):
        """Set value ``flags`` of ``(<chip.hipGraphInstantiateParams*>self._ptr)[i]``.
        """
        (<chip.hipGraphInstantiateParams*>self._ptr)[i].flags = value
    @property
    def flags(self):
        """Instantiation flags"""
        return self.get_flags(0)
    @flags.setter
    def flags(self, unsigned long long value):
        self.set_flags(0,value)

    def get_result_out(self, i):
        """Get value of ``result_out`` of ``(<chip.hipGraphInstantiateParams*>self._ptr)[i]``.
        """
        return hipGraphInstantiateResult((<chip.hipGraphInstantiateParams*>self._ptr)[i].result_out)
    def set_result_out(self, i, value):
        """Set value ``result_out`` of ``(<chip.hipGraphInstantiateParams*>self._ptr)[i]``.
        """
        if not isinstance(value, hipGraphInstantiateResult):
            raise TypeError("'value' must be of type 'hipGraphInstantiateResult'")
        (<chip.hipGraphInstantiateParams*>self._ptr)[i].result_out = value.value
    @property
    def result_out(self):
        """Whether instantiation was successful. If it failed, the reason why"""
        return self.get_result_out(0)
    @result_out.setter
    def result_out(self, value):
        self.set_result_out(0,value)

    @staticmethod
    def PROPERTIES():
        return ["flags","result_out"]

    def __contains__(self,item):
        properties = self.PROPERTIES()
        return item in properties

    def __getitem__(self,item):
        properties = self.PROPERTIES()
        if isinstance(item,int):
            if item < 0 or item >= len(properties):
                raise IndexError()
            return getattr(self,properties[item])
        raise ValueError("'item' type must be 'int'")


cdef class hipMemAllocationProp_struct_0(hip._util.types.Pointer):
    """Python wrapper for cdef class chip.hipMemAllocationProp_struct_0.

    Python wrapper for cdef class chip.hipMemAllocationProp_struct_0.

    If this type is initialized via its `__init__` method, it allocates a
    member of the underlying C type and destroys it again if the wrapper
    type is deallocated.

    This type also serves as adapter when appearing as argument type in a
    function signature. In this case, the type can further be initialized
    from a number of Python objects:

    * `None`:

      This will set the ``self._ptr`` attribute to ``NULL``.

    * `int`:

      Interprets the integer value as pointer address and writes it to ``self._ptr``.
      No ownership is transferred.

    * `ctypes.c_void_p`:

      Takes the pointer address ``pyobj.value`` and writes it to ``self._ptr``.
      No ownership is transferred.

    * `object` that implements the `CUDA Array Interface <https://numba.readthedocs.io/en/stable/cuda/cuda_array_interface.html>`_ protocol:

      Takes the integer-valued pointer address, i.e. the first entry of the `data` tuple
      from `pyobj`'s member ``__cuda_array_interface__``  and writes it to ``self._ptr``.

    * `object` that implements the Python buffer protocol:

      If the object represents a simple contiguous array,
      writes the `Py_buffer` associated with ``pyobj`` to `self._py_buffer`,
      sets the `self._py_buffer_acquired` flag to `True`, and
      writes `self._py_buffer.buf` to the data pointer `self._ptr`.

    * `hip._util.types.Pointer`:

      Takes the pointer address ``pyobj._ptr`` and writes it to ``self._ptr``.
      No ownership is transferred.

    Type checks are performed in the above order.

    C Attributes:
        _ptr (C type ``void *``, protected):
            Stores a pointer to the data of the original Python object.
        _is_ptr_owner (C type ``bint``, protected):
            If this wrapper is the owner of the underlying data.
        _py_buffer (C type ``Py_buffer`, protected):
            Stores a pointer to the data of the original Python object.
        _py_buffer_acquired (C type ``bint``, protected):
            Stores a pointer to the data of the original Python object.
    """
    # C members declared in pxd file

    def __cinit__(self):
        self._ptr = NULL
        self._is_ptr_owner = False
        self._py_buffer_acquired = False

    cdef chip.hipMemAllocationProp_struct_0* getElementPtr(self):
        return <chip.hipMemAllocationProp_struct_0*>self._ptr

    @staticmethod
    cdef hipMemAllocationProp_struct_0 fromPtr(void* ptr, bint owner=False):
        """Factory function to create ``hipMemAllocationProp_struct_0`` objects from
        given ``chip.hipMemAllocationProp_struct_0`` pointer.

        Setting ``owner`` flag to ``True`` causes
        the extension type to free the structure pointed to by ``ptr``
        when the wrapper object is deallocated.
        """
        # Fast call to __new__() that bypasses the __init__() constructor.
        cdef hipMemAllocationProp_struct_0 wrapper = hipMemAllocationProp_struct_0.__new__(hipMemAllocationProp_struct_0)
        wrapper._ptr = ptr
        wrapper._is_ptr_owner = owner
        return wrapper

    @staticmethod
    def fromObj(pyobj):
        """Creates a hipMemAllocationProp_struct_0 from a Python object.

        Derives a hipMemAllocationProp_struct_0 from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``hipMemAllocationProp_struct_0`` reference, this method
        returns it directly. No new ``hipMemAllocationProp_struct_0`` is created in this case.
        """
        return hipMemAllocationProp_struct_0.fromPyobj(pyobj)

    @staticmethod
    cdef hipMemAllocationProp_struct_0 fromPyobj(object pyobj):
        """Creates a hipMemAllocationProp_struct_0 from a Python object.

        Derives a hipMemAllocationProp_struct_0 from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``hipMemAllocationProp_struct_0`` reference, this method
        returns it directly. No new ``hipMemAllocationProp_struct_0`` is created in this case.

        Args:
            pyobj (object): Must be either `None`; a `hip._util.types.Pointer`; a simple, contiguous buffer according to the buffer protocol;
                            or of type `hipMemAllocationProp_struct_0`; `int`; or `ctypes.c_void_p`.

        Note:
            This routine does not perform a copy but returns the original ``pyobj``
            if ``pyobj`` is an instance of hipMemAllocationProp_struct_0!
        """
        cdef hipMemAllocationProp_struct_0 wrapper

        if isinstance(pyobj,hipMemAllocationProp_struct_0):
            return pyobj
        else:
            wrapper = hipMemAllocationProp_struct_0.__new__(hipMemAllocationProp_struct_0)
            wrapper.init_from_pyobj(pyobj)
            return wrapper

    def __dealloc__(self):
        # Release the buffer handle
        if self._py_buffer_acquired is True:
            cpython.buffer.PyBuffer_Release(&self._py_buffer)
        # De-allocate if not null and flag is set
        if self._ptr is not NULL and self._is_ptr_owner is True:
            stdlib.free(self._ptr)
            self._ptr = NULL

    @staticmethod
    cdef __allocate(void** ptr):
        ptr[0] = stdlib.malloc(sizeof(chip.hipMemAllocationProp_struct_0))
        string.memset(<void*>ptr[0], 0, sizeof(chip.hipMemAllocationProp_struct_0))

        if ptr[0] is NULL:
            raise MemoryError

    @staticmethod
    cdef hipMemAllocationProp_struct_0 new():
        """Factory function to create hipMemAllocationProp_struct_0 objects with
        newly allocated chip.hipMemAllocationProp_struct_0"""
        cdef void* ptr
        hipMemAllocationProp_struct_0.__allocate(&ptr)
        return hipMemAllocationProp_struct_0.fromPtr(ptr, owner=True)

    @staticmethod
    cdef hipMemAllocationProp_struct_0 fromValue(chip.hipMemAllocationProp_struct_0 other):
        """Allocate new C type and copy from ``other``.
        """
        wrapper = hipMemAllocationProp_struct_0.new()
        string.memcpy(wrapper._ptr, &other, sizeof(chip.hipMemAllocationProp_struct_0))
        return wrapper

    def c_sizeof(self):
        """Returns the size of the underlying C type in bytes.
        Note:
            Implemented as function to not collide with
            autogenerated property names.
        """
        return sizeof(chip.hipMemAllocationProp_struct_0)

    def __int__(self):
        """Returns the data's address as long integer.
        """
        return cpython.long.PyLong_FromVoidPtr(self._ptr)

    def __repr__(self):
        return f"<hipMemAllocationProp_struct_0 object, ptr: {int(self)}>"

    def as_c_void_p(self):
        """Returns the data's address as `ctypes.c_void_p`
        Note:
            Implemented as function to not collide with
            autogenerated property names.
        """
        return ctypes.c_void_p(int(self))

    def __init__(self,*args,**kwargs):
        """Constructor type hipMemAllocationProp_struct_0.

        Constructor for type hipMemAllocationProp_struct_0.

        Args:
            *args:
                Positional arguments. Initialize all or a subset of the member variables
                according to their order of declaration.
            **kwargs:
                Can be used to initialize member variables at construction,
                Just pass an argument expression of the form <member>=<value>
                per member that you want to initialize.
        """
        hipMemAllocationProp_struct_0.__allocate(&self._ptr)
        self._is_ptr_owner = True
        attribs = self.PROPERTIES()
        used_attribs = set()
        if len(args) > len(attribs):
            raise ValueError("More positional arguments specified than this type has properties.")
        for i,v in enumerate(args):
            setattr(self,attribs[i],v)
            used_attribs.add(attribs[i])
        valid_names = ", ".join(["'"+p+"'" for p in attribs])
        for k,v in kwargs.items():
            if k in used_attribs:
                raise KeyError(f"argument '{k}' has already been specified as positional argument.")
            elif k not in attribs:
                raise KeyError(f"'{k}' is no valid property name. Valid names: {valid_names}")
            setattr(self,k,v)
    def get_compressionType(self, i):
        """Get value ``compressionType`` of ``(<chip.hipMemAllocationProp_struct_0*>self._ptr)[i]``.
        """
        return (<chip.hipMemAllocationProp_struct_0*>self._ptr)[i].compressionType
    def set_compressionType(self, i, unsigned char value):
        """Set value ``compressionType`` of ``(<chip.hipMemAllocationProp_struct_0*>self._ptr)[i]``.
        """
        (<chip.hipMemAllocationProp_struct_0*>self._ptr)[i].compressionType = value
    @property
    def compressionType(self):
        """Compression type"""
        return self.get_compressionType(0)
    @compressionType.setter
    def compressionType(self, unsigned char value):
        self.set_compressionType(0,value)

    def get_gpuDirectRDMACapable(self, i):
        """Get value ``gpuDirectRDMACapable`` of ``(<chip.hipMemAllocationProp_struct_0*>self._ptr)[i]``.
        """
        return (<chip.hipMemAllocationProp_struct_0*>self._ptr)[i].gpuDirectRDMACapable
    def set_gpuDirectRDMACapable(self, i, unsigned char value):
        """Set value ``gpuDirectRDMACapable`` of ``(<chip.hipMemAllocationProp_struct_0*>self._ptr)[i]``.
        """
        (<chip.hipMemAllocationProp_struct_0*>self._ptr)[i].gpuDirectRDMACapable = value
    @property
    def gpuDirectRDMACapable(self):
        """RDMA capable"""
        return self.get_gpuDirectRDMACapable(0)
    @gpuDirectRDMACapable.setter
    def gpuDirectRDMACapable(self, unsigned char value):
        self.set_gpuDirectRDMACapable(0,value)

    def get_usage(self, i):
        """Get value ``usage`` of ``(<chip.hipMemAllocationProp_struct_0*>self._ptr)[i]``.
        """
        return (<chip.hipMemAllocationProp_struct_0*>self._ptr)[i].usage
    def set_usage(self, i, unsigned short value):
        """Set value ``usage`` of ``(<chip.hipMemAllocationProp_struct_0*>self._ptr)[i]``.
        """
        (<chip.hipMemAllocationProp_struct_0*>self._ptr)[i].usage = value
    @property
    def usage(self):
        """Usage"""
        return self.get_usage(0)
    @usage.setter
    def usage(self, unsigned short value):
        self.set_usage(0,value)

    @staticmethod
    def PROPERTIES():
        return ["compressionType","gpuDirectRDMACapable","usage"]

    def __contains__(self,item):
        properties = self.PROPERTIES()
        return item in properties

    def __getitem__(self,item):
        properties = self.PROPERTIES()
        if isinstance(item,int):
            if item < 0 or item >= len(properties):
                raise IndexError()
            return getattr(self,properties[item])
        raise ValueError("'item' type must be 'int'")


cdef class hipMemAllocationProp(hip._util.types.Pointer):
    """Python wrapper for cdef class chip.hipMemAllocationProp.

    Python wrapper for cdef class chip.hipMemAllocationProp.

    If this type is initialized via its `__init__` method, it allocates a
    member of the underlying C type and destroys it again if the wrapper
    type is deallocated.

    This type also serves as adapter when appearing as argument type in a
    function signature. In this case, the type can further be initialized
    from a number of Python objects:

    * `None`:

      This will set the ``self._ptr`` attribute to ``NULL``.

    * `int`:

      Interprets the integer value as pointer address and writes it to ``self._ptr``.
      No ownership is transferred.

    * `ctypes.c_void_p`:

      Takes the pointer address ``pyobj.value`` and writes it to ``self._ptr``.
      No ownership is transferred.

    * `object` that implements the `CUDA Array Interface <https://numba.readthedocs.io/en/stable/cuda/cuda_array_interface.html>`_ protocol:

      Takes the integer-valued pointer address, i.e. the first entry of the `data` tuple
      from `pyobj`'s member ``__cuda_array_interface__``  and writes it to ``self._ptr``.

    * `object` that implements the Python buffer protocol:

      If the object represents a simple contiguous array,
      writes the `Py_buffer` associated with ``pyobj`` to `self._py_buffer`,
      sets the `self._py_buffer_acquired` flag to `True`, and
      writes `self._py_buffer.buf` to the data pointer `self._ptr`.

    * `hip._util.types.Pointer`:

      Takes the pointer address ``pyobj._ptr`` and writes it to ``self._ptr``.
      No ownership is transferred.

    Type checks are performed in the above order.

    C Attributes:
        _ptr (C type ``void *``, protected):
            Stores a pointer to the data of the original Python object.
        _is_ptr_owner (C type ``bint``, protected):
            If this wrapper is the owner of the underlying data.
        _py_buffer (C type ``Py_buffer`, protected):
            Stores a pointer to the data of the original Python object.
        _py_buffer_acquired (C type ``bint``, protected):
            Stores a pointer to the data of the original Python object.
    """
    # C members declared in pxd file

    def __cinit__(self):
        self._ptr = NULL
        self._is_ptr_owner = False
        self._py_buffer_acquired = False

    cdef chip.hipMemAllocationProp* getElementPtr(self):
        return <chip.hipMemAllocationProp*>self._ptr

    @staticmethod
    cdef hipMemAllocationProp fromPtr(void* ptr, bint owner=False):
        """Factory function to create ``hipMemAllocationProp`` objects from
        given ``chip.hipMemAllocationProp`` pointer.

        Setting ``owner`` flag to ``True`` causes
        the extension type to free the structure pointed to by ``ptr``
        when the wrapper object is deallocated.
        """
        # Fast call to __new__() that bypasses the __init__() constructor.
        cdef hipMemAllocationProp wrapper = hipMemAllocationProp.__new__(hipMemAllocationProp)
        wrapper._ptr = ptr
        wrapper._is_ptr_owner = owner
        return wrapper

    @staticmethod
    def fromObj(pyobj):
        """Creates a hipMemAllocationProp from a Python object.

        Derives a hipMemAllocationProp from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``hipMemAllocationProp`` reference, this method
        returns it directly. No new ``hipMemAllocationProp`` is created in this case.
        """
        return hipMemAllocationProp.fromPyobj(pyobj)

    @staticmethod
    cdef hipMemAllocationProp fromPyobj(object pyobj):
        """Creates a hipMemAllocationProp from a Python object.

        Derives a hipMemAllocationProp from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``hipMemAllocationProp`` reference, this method
        returns it directly. No new ``hipMemAllocationProp`` is created in this case.

        Args:
            pyobj (object): Must be either `None`; a `hip._util.types.Pointer`; a simple, contiguous buffer according to the buffer protocol;
                            or of type `hipMemAllocationProp`; `int`; or `ctypes.c_void_p`.

        Note:
            This routine does not perform a copy but returns the original ``pyobj``
            if ``pyobj`` is an instance of hipMemAllocationProp!
        """
        cdef hipMemAllocationProp wrapper

        if isinstance(pyobj,hipMemAllocationProp):
            return pyobj
        else:
            wrapper = hipMemAllocationProp.__new__(hipMemAllocationProp)
            wrapper.init_from_pyobj(pyobj)
            return wrapper

    def __dealloc__(self):
        # Release the buffer handle
        if self._py_buffer_acquired is True:
            cpython.buffer.PyBuffer_Release(&self._py_buffer)
        # De-allocate if not null and flag is set
        if self._ptr is not NULL and self._is_ptr_owner is True:
            stdlib.free(self._ptr)
            self._ptr = NULL

    @staticmethod
    cdef __allocate(void** ptr):
        ptr[0] = stdlib.malloc(sizeof(chip.hipMemAllocationProp))
        string.memset(<void*>ptr[0], 0, sizeof(chip.hipMemAllocationProp))

        if ptr[0] is NULL:
            raise MemoryError

    @staticmethod
    cdef hipMemAllocationProp new():
        """Factory function to create hipMemAllocationProp objects with
        newly allocated chip.hipMemAllocationProp"""
        cdef void* ptr
        hipMemAllocationProp.__allocate(&ptr)
        return hipMemAllocationProp.fromPtr(ptr, owner=True)

    @staticmethod
    cdef hipMemAllocationProp fromValue(chip.hipMemAllocationProp other):
        """Allocate new C type and copy from ``other``.
        """
        wrapper = hipMemAllocationProp.new()
        string.memcpy(wrapper._ptr, &other, sizeof(chip.hipMemAllocationProp))
        return wrapper

    def c_sizeof(self):
        """Returns the size of the underlying C type in bytes.
        Note:
            Implemented as function to not collide with
            autogenerated property names.
        """
        return sizeof(chip.hipMemAllocationProp)

    def __int__(self):
        """Returns the data's address as long integer.
        """
        return cpython.long.PyLong_FromVoidPtr(self._ptr)

    def __repr__(self):
        return f"<hipMemAllocationProp object, ptr: {int(self)}>"

    def as_c_void_p(self):
        """Returns the data's address as `ctypes.c_void_p`
        Note:
            Implemented as function to not collide with
            autogenerated property names.
        """
        return ctypes.c_void_p(int(self))

    def __init__(self,*args,**kwargs):
        """Constructor type hipMemAllocationProp.

        Constructor for type hipMemAllocationProp.

        Args:
            *args:
                Positional arguments. Initialize all or a subset of the member variables
                according to their order of declaration.
            **kwargs:
                Can be used to initialize member variables at construction,
                Just pass an argument expression of the form <member>=<value>
                per member that you want to initialize.
        """
        hipMemAllocationProp.__allocate(&self._ptr)
        self._is_ptr_owner = True
        attribs = self.PROPERTIES()
        used_attribs = set()
        if len(args) > len(attribs):
            raise ValueError("More positional arguments specified than this type has properties.")
        for i,v in enumerate(args):
            setattr(self,attribs[i],v)
            used_attribs.add(attribs[i])
        valid_names = ", ".join(["'"+p+"'" for p in attribs])
        for k,v in kwargs.items():
            if k in used_attribs:
                raise KeyError(f"argument '{k}' has already been specified as positional argument.")
            elif k not in attribs:
                raise KeyError(f"'{k}' is no valid property name. Valid names: {valid_names}")
            setattr(self,k,v)
    def get_type(self, i):
        """Get value of ``type`` of ``(<chip.hipMemAllocationProp*>self._ptr)[i]``.
        """
        return hipMemAllocationType((<chip.hipMemAllocationProp*>self._ptr)[i].type)
    def set_type(self, i, value):
        """Set value ``type`` of ``(<chip.hipMemAllocationProp*>self._ptr)[i]``.
        """
        if not isinstance(value, hipMemAllocationType):
            raise TypeError("'value' must be of type 'hipMemAllocationType'")
        (<chip.hipMemAllocationProp*>self._ptr)[i].type = value.value
    @property
    def type(self):
        """Memory allocation type"""
        return self.get_type(0)
    @type.setter
    def type(self, value):
        self.set_type(0,value)

    def get_requestedHandleType(self, i):
        """Get value of ``requestedHandleType`` of ``(<chip.hipMemAllocationProp*>self._ptr)[i]``.
        """
        return hipMemAllocationHandleType((<chip.hipMemAllocationProp*>self._ptr)[i].requestedHandleType)
    def set_requestedHandleType(self, i, value):
        """Set value ``requestedHandleType`` of ``(<chip.hipMemAllocationProp*>self._ptr)[i]``.
        """
        if not isinstance(value, hipMemAllocationHandleType):
            raise TypeError("'value' must be of type 'hipMemAllocationHandleType'")
        (<chip.hipMemAllocationProp*>self._ptr)[i].requestedHandleType = value.value
    @property
    def requestedHandleType(self):
        """Requested handle type"""
        return self.get_requestedHandleType(0)
    @requestedHandleType.setter
    def requestedHandleType(self, value):
        self.set_requestedHandleType(0,value)

    def get_location(self, i):
        """Get value of ``location`` of ``(<chip.hipMemAllocationProp*>self._ptr)[i]``.
        """
        return hipMemLocation.fromPtr(&(<chip.hipMemAllocationProp*>self._ptr)[i].location)
    @property
    def location(self):
        """Memory location"""
        return self.get_location(0)

    def get_win32HandleMetaData(self, i):
        """Get value ``win32HandleMetaData`` of ``(<chip.hipMemAllocationProp*>self._ptr)[i]``.
        """
        return hip._util.types.Pointer.fromPtr((<chip.hipMemAllocationProp*>self._ptr)[i].win32HandleMetaData)
    def set_win32HandleMetaData(self, i, object value):
        """Set value ``win32HandleMetaData`` of ``(<chip.hipMemAllocationProp*>self._ptr)[i]``.

        Note:
            This can be dangerous if the pointer is from a python object
            that is later on garbage collected.
        """
        (<chip.hipMemAllocationProp*>self._ptr)[i].win32HandleMetaData = <void *>cpython.long.PyLong_AsVoidPtr(int(hip._util.types.Pointer.fromPyobj(value)))
    @property
    def win32HandleMetaData(self):
        """Metadata for Win32 handles
        Note:
            Setting this win32HandleMetaData can be dangerous if the underlying pointer is from a python object that
            is later on garbage collected.
        """
        return self.get_win32HandleMetaData(0)
    @win32HandleMetaData.setter
    def win32HandleMetaData(self, object value):
        self.set_win32HandleMetaData(0,value)

    def get_allocFlags(self, i):
        """Get value of ``allocFlags`` of ``(<chip.hipMemAllocationProp*>self._ptr)[i]``.
        """
        return hipMemAllocationProp_struct_0.fromPtr(&(<chip.hipMemAllocationProp*>self._ptr)[i].allocFlags)
    @property
    def allocFlags(self):
        """(undocumented)"""
        return self.get_allocFlags(0)

    @staticmethod
    def PROPERTIES():
        return ["type","requestedHandleType","location","win32HandleMetaData","allocFlags"]

    def __contains__(self,item):
        properties = self.PROPERTIES()
        return item in properties

    def __getitem__(self,item):
        properties = self.PROPERTIES()
        if isinstance(item,int):
            if item < 0 or item >= len(properties):
                raise IndexError()
            return getattr(self,properties[item])
        raise ValueError("'item' type must be 'int'")


cdef class hipExternalSemaphoreSignalNodeParams(hip._util.types.Pointer):
    """Python wrapper for cdef class chip.hipExternalSemaphoreSignalNodeParams.

    Python wrapper for cdef class chip.hipExternalSemaphoreSignalNodeParams.

    If this type is initialized via its `__init__` method, it allocates a
    member of the underlying C type and destroys it again if the wrapper
    type is deallocated.

    This type also serves as adapter when appearing as argument type in a
    function signature. In this case, the type can further be initialized
    from a number of Python objects:

    * `None`:

      This will set the ``self._ptr`` attribute to ``NULL``.

    * `int`:

      Interprets the integer value as pointer address and writes it to ``self._ptr``.
      No ownership is transferred.

    * `ctypes.c_void_p`:

      Takes the pointer address ``pyobj.value`` and writes it to ``self._ptr``.
      No ownership is transferred.

    * `object` that implements the `CUDA Array Interface <https://numba.readthedocs.io/en/stable/cuda/cuda_array_interface.html>`_ protocol:

      Takes the integer-valued pointer address, i.e. the first entry of the `data` tuple
      from `pyobj`'s member ``__cuda_array_interface__``  and writes it to ``self._ptr``.

    * `object` that implements the Python buffer protocol:

      If the object represents a simple contiguous array,
      writes the `Py_buffer` associated with ``pyobj`` to `self._py_buffer`,
      sets the `self._py_buffer_acquired` flag to `True`, and
      writes `self._py_buffer.buf` to the data pointer `self._ptr`.

    * `hip._util.types.Pointer`:

      Takes the pointer address ``pyobj._ptr`` and writes it to ``self._ptr``.
      No ownership is transferred.

    Type checks are performed in the above order.

    C Attributes:
        _ptr (C type ``void *``, protected):
            Stores a pointer to the data of the original Python object.
        _is_ptr_owner (C type ``bint``, protected):
            If this wrapper is the owner of the underlying data.
        _py_buffer (C type ``Py_buffer`, protected):
            Stores a pointer to the data of the original Python object.
        _py_buffer_acquired (C type ``bint``, protected):
            Stores a pointer to the data of the original Python object.
    """
    # C members declared in pxd file

    def __cinit__(self):
        self._ptr = NULL
        self._is_ptr_owner = False
        self._py_buffer_acquired = False

    cdef chip.hipExternalSemaphoreSignalNodeParams* getElementPtr(self):
        return <chip.hipExternalSemaphoreSignalNodeParams*>self._ptr

    @staticmethod
    cdef hipExternalSemaphoreSignalNodeParams fromPtr(void* ptr, bint owner=False):
        """Factory function to create ``hipExternalSemaphoreSignalNodeParams`` objects from
        given ``chip.hipExternalSemaphoreSignalNodeParams`` pointer.

        Setting ``owner`` flag to ``True`` causes
        the extension type to free the structure pointed to by ``ptr``
        when the wrapper object is deallocated.
        """
        # Fast call to __new__() that bypasses the __init__() constructor.
        cdef hipExternalSemaphoreSignalNodeParams wrapper = hipExternalSemaphoreSignalNodeParams.__new__(hipExternalSemaphoreSignalNodeParams)
        wrapper._ptr = ptr
        wrapper._is_ptr_owner = owner
        return wrapper

    @staticmethod
    def fromObj(pyobj):
        """Creates a hipExternalSemaphoreSignalNodeParams from a Python object.

        Derives a hipExternalSemaphoreSignalNodeParams from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``hipExternalSemaphoreSignalNodeParams`` reference, this method
        returns it directly. No new ``hipExternalSemaphoreSignalNodeParams`` is created in this case.
        """
        return hipExternalSemaphoreSignalNodeParams.fromPyobj(pyobj)

    @staticmethod
    cdef hipExternalSemaphoreSignalNodeParams fromPyobj(object pyobj):
        """Creates a hipExternalSemaphoreSignalNodeParams from a Python object.

        Derives a hipExternalSemaphoreSignalNodeParams from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``hipExternalSemaphoreSignalNodeParams`` reference, this method
        returns it directly. No new ``hipExternalSemaphoreSignalNodeParams`` is created in this case.

        Args:
            pyobj (object): Must be either `None`; a `hip._util.types.Pointer`; a simple, contiguous buffer according to the buffer protocol;
                            or of type `hipExternalSemaphoreSignalNodeParams`; `int`; or `ctypes.c_void_p`.

        Note:
            This routine does not perform a copy but returns the original ``pyobj``
            if ``pyobj`` is an instance of hipExternalSemaphoreSignalNodeParams!
        """
        cdef hipExternalSemaphoreSignalNodeParams wrapper

        if isinstance(pyobj,hipExternalSemaphoreSignalNodeParams):
            return pyobj
        else:
            wrapper = hipExternalSemaphoreSignalNodeParams.__new__(hipExternalSemaphoreSignalNodeParams)
            wrapper.init_from_pyobj(pyobj)
            return wrapper

    def __dealloc__(self):
        # Release the buffer handle
        if self._py_buffer_acquired is True:
            cpython.buffer.PyBuffer_Release(&self._py_buffer)
        # De-allocate if not null and flag is set
        if self._ptr is not NULL and self._is_ptr_owner is True:
            stdlib.free(self._ptr)
            self._ptr = NULL

    @staticmethod
    cdef __allocate(void** ptr):
        ptr[0] = stdlib.malloc(sizeof(chip.hipExternalSemaphoreSignalNodeParams))
        string.memset(<void*>ptr[0], 0, sizeof(chip.hipExternalSemaphoreSignalNodeParams))

        if ptr[0] is NULL:
            raise MemoryError

    @staticmethod
    cdef hipExternalSemaphoreSignalNodeParams new():
        """Factory function to create hipExternalSemaphoreSignalNodeParams objects with
        newly allocated chip.hipExternalSemaphoreSignalNodeParams"""
        cdef void* ptr
        hipExternalSemaphoreSignalNodeParams.__allocate(&ptr)
        return hipExternalSemaphoreSignalNodeParams.fromPtr(ptr, owner=True)

    @staticmethod
    cdef hipExternalSemaphoreSignalNodeParams fromValue(chip.hipExternalSemaphoreSignalNodeParams other):
        """Allocate new C type and copy from ``other``.
        """
        wrapper = hipExternalSemaphoreSignalNodeParams.new()
        string.memcpy(wrapper._ptr, &other, sizeof(chip.hipExternalSemaphoreSignalNodeParams))
        return wrapper

    def c_sizeof(self):
        """Returns the size of the underlying C type in bytes.
        Note:
            Implemented as function to not collide with
            autogenerated property names.
        """
        return sizeof(chip.hipExternalSemaphoreSignalNodeParams)

    def __int__(self):
        """Returns the data's address as long integer.
        """
        return cpython.long.PyLong_FromVoidPtr(self._ptr)

    def __repr__(self):
        return f"<hipExternalSemaphoreSignalNodeParams object, ptr: {int(self)}>"

    def as_c_void_p(self):
        """Returns the data's address as `ctypes.c_void_p`
        Note:
            Implemented as function to not collide with
            autogenerated property names.
        """
        return ctypes.c_void_p(int(self))

    def __init__(self,**kwargs):
        """Constructor type hipExternalSemaphoreSignalNodeParams.

        Constructor for type hipExternalSemaphoreSignalNodeParams.

        Args:
            **kwargs:
                Can be used to initialize member variables at construction,
                Just pass an argument expression of the form <member>=<value>
                per member that you want to initialize.
        """
        hipExternalSemaphoreSignalNodeParams.__allocate(&self._ptr)
        self._is_ptr_owner = True
        attribs = self.PROPERTIES()
        used_attribs = set()
        valid_names = ", ".join(["'"+p+"'" for p in attribs])
        for k,v in kwargs.items():
            if k in used_attribs:
                raise KeyError(f"argument '{k}' has already been specified as positional argument.")
            elif k not in attribs:
                raise KeyError(f"'{k}' is no valid property name. Valid names: {valid_names}")
            setattr(self,k,v)
    def get_extSemArray(self, i):
        """Get value ``extSemArray`` of ``(<chip.hipExternalSemaphoreSignalNodeParams*>self._ptr)[i]``.
        """
        return hip._util.types.Pointer.fromPtr((<chip.hipExternalSemaphoreSignalNodeParams*>self._ptr)[i].extSemArray)
    def set_extSemArray(self, i, object value):
        """Set value ``extSemArray`` of ``(<chip.hipExternalSemaphoreSignalNodeParams*>self._ptr)[i]``.

        Note:
            This can be dangerous if the pointer is from a python object
            that is later on garbage collected.
        """
        (<chip.hipExternalSemaphoreSignalNodeParams*>self._ptr)[i].extSemArray = <void **>cpython.long.PyLong_AsVoidPtr(int(hip._util.types.Pointer.fromPyobj(value)))
    @property
    def extSemArray(self):
        """(undocumented)
        Note:
            Setting this extSemArray can be dangerous if the underlying pointer is from a python object that
            is later on garbage collected.
        """
        return self.get_extSemArray(0)
    @extSemArray.setter
    def extSemArray(self, object value):
        self.set_extSemArray(0,value)

    def get_numExtSems(self, i):
        """Get value ``numExtSems`` of ``(<chip.hipExternalSemaphoreSignalNodeParams*>self._ptr)[i]``.
        """
        return (<chip.hipExternalSemaphoreSignalNodeParams*>self._ptr)[i].numExtSems
    def set_numExtSems(self, i, unsigned int value):
        """Set value ``numExtSems`` of ``(<chip.hipExternalSemaphoreSignalNodeParams*>self._ptr)[i]``.
        """
        (<chip.hipExternalSemaphoreSignalNodeParams*>self._ptr)[i].numExtSems = value
    @property
    def numExtSems(self):
        """(undocumented)"""
        return self.get_numExtSems(0)
    @numExtSems.setter
    def numExtSems(self, unsigned int value):
        self.set_numExtSems(0,value)

    @staticmethod
    def PROPERTIES():
        return ["extSemArray","numExtSems"]

    def __contains__(self,item):
        properties = self.PROPERTIES()
        return item in properties

    def __getitem__(self,item):
        properties = self.PROPERTIES()
        if isinstance(item,int):
            if item < 0 or item >= len(properties):
                raise IndexError()
            return getattr(self,properties[item])
        raise ValueError("'item' type must be 'int'")


cdef class hipExternalSemaphoreWaitNodeParams(hip._util.types.Pointer):
    """Python wrapper for cdef class chip.hipExternalSemaphoreWaitNodeParams.

    Python wrapper for cdef class chip.hipExternalSemaphoreWaitNodeParams.

    If this type is initialized via its `__init__` method, it allocates a
    member of the underlying C type and destroys it again if the wrapper
    type is deallocated.

    This type also serves as adapter when appearing as argument type in a
    function signature. In this case, the type can further be initialized
    from a number of Python objects:

    * `None`:

      This will set the ``self._ptr`` attribute to ``NULL``.

    * `int`:

      Interprets the integer value as pointer address and writes it to ``self._ptr``.
      No ownership is transferred.

    * `ctypes.c_void_p`:

      Takes the pointer address ``pyobj.value`` and writes it to ``self._ptr``.
      No ownership is transferred.

    * `object` that implements the `CUDA Array Interface <https://numba.readthedocs.io/en/stable/cuda/cuda_array_interface.html>`_ protocol:

      Takes the integer-valued pointer address, i.e. the first entry of the `data` tuple
      from `pyobj`'s member ``__cuda_array_interface__``  and writes it to ``self._ptr``.

    * `object` that implements the Python buffer protocol:

      If the object represents a simple contiguous array,
      writes the `Py_buffer` associated with ``pyobj`` to `self._py_buffer`,
      sets the `self._py_buffer_acquired` flag to `True`, and
      writes `self._py_buffer.buf` to the data pointer `self._ptr`.

    * `hip._util.types.Pointer`:

      Takes the pointer address ``pyobj._ptr`` and writes it to ``self._ptr``.
      No ownership is transferred.

    Type checks are performed in the above order.

    C Attributes:
        _ptr (C type ``void *``, protected):
            Stores a pointer to the data of the original Python object.
        _is_ptr_owner (C type ``bint``, protected):
            If this wrapper is the owner of the underlying data.
        _py_buffer (C type ``Py_buffer`, protected):
            Stores a pointer to the data of the original Python object.
        _py_buffer_acquired (C type ``bint``, protected):
            Stores a pointer to the data of the original Python object.
    """
    # C members declared in pxd file

    def __cinit__(self):
        self._ptr = NULL
        self._is_ptr_owner = False
        self._py_buffer_acquired = False

    cdef chip.hipExternalSemaphoreWaitNodeParams* getElementPtr(self):
        return <chip.hipExternalSemaphoreWaitNodeParams*>self._ptr

    @staticmethod
    cdef hipExternalSemaphoreWaitNodeParams fromPtr(void* ptr, bint owner=False):
        """Factory function to create ``hipExternalSemaphoreWaitNodeParams`` objects from
        given ``chip.hipExternalSemaphoreWaitNodeParams`` pointer.

        Setting ``owner`` flag to ``True`` causes
        the extension type to free the structure pointed to by ``ptr``
        when the wrapper object is deallocated.
        """
        # Fast call to __new__() that bypasses the __init__() constructor.
        cdef hipExternalSemaphoreWaitNodeParams wrapper = hipExternalSemaphoreWaitNodeParams.__new__(hipExternalSemaphoreWaitNodeParams)
        wrapper._ptr = ptr
        wrapper._is_ptr_owner = owner
        return wrapper

    @staticmethod
    def fromObj(pyobj):
        """Creates a hipExternalSemaphoreWaitNodeParams from a Python object.

        Derives a hipExternalSemaphoreWaitNodeParams from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``hipExternalSemaphoreWaitNodeParams`` reference, this method
        returns it directly. No new ``hipExternalSemaphoreWaitNodeParams`` is created in this case.
        """
        return hipExternalSemaphoreWaitNodeParams.fromPyobj(pyobj)

    @staticmethod
    cdef hipExternalSemaphoreWaitNodeParams fromPyobj(object pyobj):
        """Creates a hipExternalSemaphoreWaitNodeParams from a Python object.

        Derives a hipExternalSemaphoreWaitNodeParams from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``hipExternalSemaphoreWaitNodeParams`` reference, this method
        returns it directly. No new ``hipExternalSemaphoreWaitNodeParams`` is created in this case.

        Args:
            pyobj (object): Must be either `None`; a `hip._util.types.Pointer`; a simple, contiguous buffer according to the buffer protocol;
                            or of type `hipExternalSemaphoreWaitNodeParams`; `int`; or `ctypes.c_void_p`.

        Note:
            This routine does not perform a copy but returns the original ``pyobj``
            if ``pyobj`` is an instance of hipExternalSemaphoreWaitNodeParams!
        """
        cdef hipExternalSemaphoreWaitNodeParams wrapper

        if isinstance(pyobj,hipExternalSemaphoreWaitNodeParams):
            return pyobj
        else:
            wrapper = hipExternalSemaphoreWaitNodeParams.__new__(hipExternalSemaphoreWaitNodeParams)
            wrapper.init_from_pyobj(pyobj)
            return wrapper

    def __dealloc__(self):
        # Release the buffer handle
        if self._py_buffer_acquired is True:
            cpython.buffer.PyBuffer_Release(&self._py_buffer)
        # De-allocate if not null and flag is set
        if self._ptr is not NULL and self._is_ptr_owner is True:
            stdlib.free(self._ptr)
            self._ptr = NULL

    @staticmethod
    cdef __allocate(void** ptr):
        ptr[0] = stdlib.malloc(sizeof(chip.hipExternalSemaphoreWaitNodeParams))
        string.memset(<void*>ptr[0], 0, sizeof(chip.hipExternalSemaphoreWaitNodeParams))

        if ptr[0] is NULL:
            raise MemoryError

    @staticmethod
    cdef hipExternalSemaphoreWaitNodeParams new():
        """Factory function to create hipExternalSemaphoreWaitNodeParams objects with
        newly allocated chip.hipExternalSemaphoreWaitNodeParams"""
        cdef void* ptr
        hipExternalSemaphoreWaitNodeParams.__allocate(&ptr)
        return hipExternalSemaphoreWaitNodeParams.fromPtr(ptr, owner=True)

    @staticmethod
    cdef hipExternalSemaphoreWaitNodeParams fromValue(chip.hipExternalSemaphoreWaitNodeParams other):
        """Allocate new C type and copy from ``other``.
        """
        wrapper = hipExternalSemaphoreWaitNodeParams.new()
        string.memcpy(wrapper._ptr, &other, sizeof(chip.hipExternalSemaphoreWaitNodeParams))
        return wrapper

    def c_sizeof(self):
        """Returns the size of the underlying C type in bytes.
        Note:
            Implemented as function to not collide with
            autogenerated property names.
        """
        return sizeof(chip.hipExternalSemaphoreWaitNodeParams)

    def __int__(self):
        """Returns the data's address as long integer.
        """
        return cpython.long.PyLong_FromVoidPtr(self._ptr)

    def __repr__(self):
        return f"<hipExternalSemaphoreWaitNodeParams object, ptr: {int(self)}>"

    def as_c_void_p(self):
        """Returns the data's address as `ctypes.c_void_p`
        Note:
            Implemented as function to not collide with
            autogenerated property names.
        """
        return ctypes.c_void_p(int(self))

    def __init__(self,**kwargs):
        """Constructor type hipExternalSemaphoreWaitNodeParams.

        Constructor for type hipExternalSemaphoreWaitNodeParams.

        Args:
            **kwargs:
                Can be used to initialize member variables at construction,
                Just pass an argument expression of the form <member>=<value>
                per member that you want to initialize.
        """
        hipExternalSemaphoreWaitNodeParams.__allocate(&self._ptr)
        self._is_ptr_owner = True
        attribs = self.PROPERTIES()
        used_attribs = set()
        valid_names = ", ".join(["'"+p+"'" for p in attribs])
        for k,v in kwargs.items():
            if k in used_attribs:
                raise KeyError(f"argument '{k}' has already been specified as positional argument.")
            elif k not in attribs:
                raise KeyError(f"'{k}' is no valid property name. Valid names: {valid_names}")
            setattr(self,k,v)
    def get_extSemArray(self, i):
        """Get value ``extSemArray`` of ``(<chip.hipExternalSemaphoreWaitNodeParams*>self._ptr)[i]``.
        """
        return hip._util.types.Pointer.fromPtr((<chip.hipExternalSemaphoreWaitNodeParams*>self._ptr)[i].extSemArray)
    def set_extSemArray(self, i, object value):
        """Set value ``extSemArray`` of ``(<chip.hipExternalSemaphoreWaitNodeParams*>self._ptr)[i]``.

        Note:
            This can be dangerous if the pointer is from a python object
            that is later on garbage collected.
        """
        (<chip.hipExternalSemaphoreWaitNodeParams*>self._ptr)[i].extSemArray = <void **>cpython.long.PyLong_AsVoidPtr(int(hip._util.types.Pointer.fromPyobj(value)))
    @property
    def extSemArray(self):
        """(undocumented)
        Note:
            Setting this extSemArray can be dangerous if the underlying pointer is from a python object that
            is later on garbage collected.
        """
        return self.get_extSemArray(0)
    @extSemArray.setter
    def extSemArray(self, object value):
        self.set_extSemArray(0,value)

    def get_numExtSems(self, i):
        """Get value ``numExtSems`` of ``(<chip.hipExternalSemaphoreWaitNodeParams*>self._ptr)[i]``.
        """
        return (<chip.hipExternalSemaphoreWaitNodeParams*>self._ptr)[i].numExtSems
    def set_numExtSems(self, i, unsigned int value):
        """Set value ``numExtSems`` of ``(<chip.hipExternalSemaphoreWaitNodeParams*>self._ptr)[i]``.
        """
        (<chip.hipExternalSemaphoreWaitNodeParams*>self._ptr)[i].numExtSems = value
    @property
    def numExtSems(self):
        """(undocumented)"""
        return self.get_numExtSems(0)
    @numExtSems.setter
    def numExtSems(self, unsigned int value):
        self.set_numExtSems(0,value)

    @staticmethod
    def PROPERTIES():
        return ["extSemArray","numExtSems"]

    def __contains__(self,item):
        properties = self.PROPERTIES()
        return item in properties

    def __getitem__(self,item):
        properties = self.PROPERTIES()
        if isinstance(item,int):
            if item < 0 or item >= len(properties):
                raise IndexError()
            return getattr(self,properties[item])
        raise ValueError("'item' type must be 'int'")


cdef class ihipMemGenericAllocationHandle(hip._util.types.Pointer):
    """Python wrapper for cdef class chip.ihipMemGenericAllocationHandle.

    Python wrapper for cdef class chip.ihipMemGenericAllocationHandle.

    If this type is initialized via its `__init__` method, it allocates a
    member of the underlying C type and destroys it again if the wrapper
    type is deallocated.

    This type also serves as adapter when appearing as argument type in a
    function signature. In this case, the type can further be initialized
    from a number of Python objects:

    * `None`:

      This will set the ``self._ptr`` attribute to ``NULL``.

    * `int`:

      Interprets the integer value as pointer address and writes it to ``self._ptr``.
      No ownership is transferred.

    * `ctypes.c_void_p`:

      Takes the pointer address ``pyobj.value`` and writes it to ``self._ptr``.
      No ownership is transferred.

    * `object` that implements the `CUDA Array Interface <https://numba.readthedocs.io/en/stable/cuda/cuda_array_interface.html>`_ protocol:

      Takes the integer-valued pointer address, i.e. the first entry of the `data` tuple
      from `pyobj`'s member ``__cuda_array_interface__``  and writes it to ``self._ptr``.

    * `object` that implements the Python buffer protocol:

      If the object represents a simple contiguous array,
      writes the `Py_buffer` associated with ``pyobj`` to `self._py_buffer`,
      sets the `self._py_buffer_acquired` flag to `True`, and
      writes `self._py_buffer.buf` to the data pointer `self._ptr`.

    * `hip._util.types.Pointer`:

      Takes the pointer address ``pyobj._ptr`` and writes it to ``self._ptr``.
      No ownership is transferred.

    Type checks are performed in the above order.

    C Attributes:
        _ptr (C type ``void *``, protected):
            Stores a pointer to the data of the original Python object.
        _is_ptr_owner (C type ``bint``, protected):
            If this wrapper is the owner of the underlying data.
        _py_buffer (C type ``Py_buffer`, protected):
            Stores a pointer to the data of the original Python object.
        _py_buffer_acquired (C type ``bint``, protected):
            Stores a pointer to the data of the original Python object.
    """
    # C members declared in pxd file

    def __cinit__(self):
        self._ptr = NULL
        self._is_ptr_owner = False
        self._py_buffer_acquired = False

    cdef chip.ihipMemGenericAllocationHandle* getElementPtr(self):
        return <chip.ihipMemGenericAllocationHandle*>self._ptr

    @staticmethod
    cdef ihipMemGenericAllocationHandle fromPtr(void* ptr, bint owner=False):
        """Factory function to create ``ihipMemGenericAllocationHandle`` objects from
        given ``chip.ihipMemGenericAllocationHandle`` pointer.
        """
        # Fast call to __new__() that bypasses the __init__() constructor.
        cdef ihipMemGenericAllocationHandle wrapper = ihipMemGenericAllocationHandle.__new__(ihipMemGenericAllocationHandle)
        wrapper._ptr = ptr
        wrapper._is_ptr_owner = owner
        return wrapper

    @staticmethod
    def fromObj(pyobj):
        """Creates a ihipMemGenericAllocationHandle from a Python object.

        Derives a ihipMemGenericAllocationHandle from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``ihipMemGenericAllocationHandle`` reference, this method
        returns it directly. No new ``ihipMemGenericAllocationHandle`` is created in this case.
        """
        return ihipMemGenericAllocationHandle.fromPyobj(pyobj)

    @staticmethod
    cdef ihipMemGenericAllocationHandle fromPyobj(object pyobj):
        """Creates a ihipMemGenericAllocationHandle from a Python object.

        Derives a ihipMemGenericAllocationHandle from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``ihipMemGenericAllocationHandle`` reference, this method
        returns it directly. No new ``ihipMemGenericAllocationHandle`` is created in this case.

        Args:
            pyobj (object): Must be either `None`; a `hip._util.types.Pointer`; a simple, contiguous buffer according to the buffer protocol;
                            or of type `ihipMemGenericAllocationHandle`; `int`; or `ctypes.c_void_p`.

        Note:
            This routine does not perform a copy but returns the original ``pyobj``
            if ``pyobj`` is an instance of ihipMemGenericAllocationHandle!
        """
        cdef ihipMemGenericAllocationHandle wrapper

        if isinstance(pyobj,ihipMemGenericAllocationHandle):
            return pyobj
        else:
            wrapper = ihipMemGenericAllocationHandle.__new__(ihipMemGenericAllocationHandle)
            wrapper.init_from_pyobj(pyobj)
            return wrapper

    def __dealloc__(self):
        # Release the buffer handle
        if self._py_buffer_acquired is True:
            cpython.buffer.PyBuffer_Release(&self._py_buffer)

    def __int__(self):
        """Returns the data's address as long integer.
        """
        return cpython.long.PyLong_FromVoidPtr(self._ptr)

    def __repr__(self):
        return f"<ihipMemGenericAllocationHandle object, ptr: {int(self)}>"

    def as_c_void_p(self):
        """Returns the data's address as `ctypes.c_void_p`
        Note:
            Implemented as function to not collide with
            autogenerated property names.
        """
        return ctypes.c_void_p(int(self))

    @staticmethod
    def PROPERTIES():
        return []

    def __contains__(self,item):
        properties = self.PROPERTIES()
        return item in properties

    def __getitem__(self,item):
        properties = self.PROPERTIES()
        if isinstance(item,int):
            if item < 0 or item >= len(properties):
                raise IndexError()
            return getattr(self,properties[item])
        raise ValueError("'item' type must be 'int'")


hipMemGenericAllocationHandle_t = ihipMemGenericAllocationHandle

class _hipMemAllocationGranularity_flags__Base(enum.IntEnum):
    """Empty enum base class that allows subclassing.
    """
    pass
class hipMemAllocationGranularity_flags(_hipMemAllocationGranularity_flags__Base):
    """Flags for granularity

    Attributes:
        hipMemAllocationGranularityMinimum:
            Minimum granularity
        hipMemAllocationGranularityRecommended:
            Recommended granularity for performance
    """
    hipMemAllocationGranularityMinimum = chip.hipMemAllocationGranularityMinimum
    hipMemAllocationGranularityRecommended = chip.hipMemAllocationGranularityRecommended
    @staticmethod
    def ctypes_type():
        """The type of the enum constants as ctypes type."""
        return ctypes.c_uint


class _hipMemHandleType__Base(enum.IntEnum):
    """Empty enum base class that allows subclassing.
    """
    pass
class hipMemHandleType(_hipMemHandleType__Base):
    """Memory handle type

    Attributes:
        hipMemHandleTypeGeneric:
            Generic handle type
    """
    hipMemHandleTypeGeneric = chip.hipMemHandleTypeGeneric
    @staticmethod
    def ctypes_type():
        """The type of the enum constants as ctypes type."""
        return ctypes.c_uint


class _hipMemOperationType__Base(enum.IntEnum):
    """Empty enum base class that allows subclassing.
    """
    pass
class hipMemOperationType(_hipMemOperationType__Base):
    """Memory operation types

    Attributes:
        hipMemOperationTypeMap:
            Map operation
        hipMemOperationTypeUnmap:
            Unmap operation
    """
    hipMemOperationTypeMap = chip.hipMemOperationTypeMap
    hipMemOperationTypeUnmap = chip.hipMemOperationTypeUnmap
    @staticmethod
    def ctypes_type():
        """The type of the enum constants as ctypes type."""
        return ctypes.c_uint


class _hipArraySparseSubresourceType__Base(enum.IntEnum):
    """Empty enum base class that allows subclassing.
    """
    pass
class hipArraySparseSubresourceType(_hipArraySparseSubresourceType__Base):
    """Subresource types for sparse arrays

    Attributes:
        hipArraySparseSubresourceTypeSparseLevel:
            Sparse level
        hipArraySparseSubresourceTypeMiptail:
            Miptail
    """
    hipArraySparseSubresourceTypeSparseLevel = chip.hipArraySparseSubresourceTypeSparseLevel
    hipArraySparseSubresourceTypeMiptail = chip.hipArraySparseSubresourceTypeMiptail
    @staticmethod
    def ctypes_type():
        """The type of the enum constants as ctypes type."""
        return ctypes.c_uint


cdef class hipArrayMapInfo_union_0(hip._util.types.Pointer):
    """Python wrapper for cdef class chip.hipArrayMapInfo_union_0.

    Python wrapper for cdef class chip.hipArrayMapInfo_union_0.

    If this type is initialized via its `__init__` method, it allocates a
    member of the underlying C type and destroys it again if the wrapper
    type is deallocated.

    This type also serves as adapter when appearing as argument type in a
    function signature. In this case, the type can further be initialized
    from a number of Python objects:

    * `None`:

      This will set the ``self._ptr`` attribute to ``NULL``.

    * `int`:

      Interprets the integer value as pointer address and writes it to ``self._ptr``.
      No ownership is transferred.

    * `ctypes.c_void_p`:

      Takes the pointer address ``pyobj.value`` and writes it to ``self._ptr``.
      No ownership is transferred.

    * `object` that implements the `CUDA Array Interface <https://numba.readthedocs.io/en/stable/cuda/cuda_array_interface.html>`_ protocol:

      Takes the integer-valued pointer address, i.e. the first entry of the `data` tuple
      from `pyobj`'s member ``__cuda_array_interface__``  and writes it to ``self._ptr``.

    * `object` that implements the Python buffer protocol:

      If the object represents a simple contiguous array,
      writes the `Py_buffer` associated with ``pyobj`` to `self._py_buffer`,
      sets the `self._py_buffer_acquired` flag to `True`, and
      writes `self._py_buffer.buf` to the data pointer `self._ptr`.

    * `hip._util.types.Pointer`:

      Takes the pointer address ``pyobj._ptr`` and writes it to ``self._ptr``.
      No ownership is transferred.

    Type checks are performed in the above order.

    C Attributes:
        _ptr (C type ``void *``, protected):
            Stores a pointer to the data of the original Python object.
        _is_ptr_owner (C type ``bint``, protected):
            If this wrapper is the owner of the underlying data.
        _py_buffer (C type ``Py_buffer`, protected):
            Stores a pointer to the data of the original Python object.
        _py_buffer_acquired (C type ``bint``, protected):
            Stores a pointer to the data of the original Python object.
    """
    # C members declared in pxd file

    def __cinit__(self):
        self._ptr = NULL
        self._is_ptr_owner = False
        self._py_buffer_acquired = False

    cdef chip.hipArrayMapInfo_union_0* getElementPtr(self):
        return <chip.hipArrayMapInfo_union_0*>self._ptr

    @staticmethod
    cdef hipArrayMapInfo_union_0 fromPtr(void* ptr, bint owner=False):
        """Factory function to create ``hipArrayMapInfo_union_0`` objects from
        given ``chip.hipArrayMapInfo_union_0`` pointer.

        Setting ``owner`` flag to ``True`` causes
        the extension type to free the structure pointed to by ``ptr``
        when the wrapper object is deallocated.
        """
        # Fast call to __new__() that bypasses the __init__() constructor.
        cdef hipArrayMapInfo_union_0 wrapper = hipArrayMapInfo_union_0.__new__(hipArrayMapInfo_union_0)
        wrapper._ptr = ptr
        wrapper._is_ptr_owner = owner
        return wrapper

    @staticmethod
    def fromObj(pyobj):
        """Creates a hipArrayMapInfo_union_0 from a Python object.

        Derives a hipArrayMapInfo_union_0 from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``hipArrayMapInfo_union_0`` reference, this method
        returns it directly. No new ``hipArrayMapInfo_union_0`` is created in this case.
        """
        return hipArrayMapInfo_union_0.fromPyobj(pyobj)

    @staticmethod
    cdef hipArrayMapInfo_union_0 fromPyobj(object pyobj):
        """Creates a hipArrayMapInfo_union_0 from a Python object.

        Derives a hipArrayMapInfo_union_0 from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``hipArrayMapInfo_union_0`` reference, this method
        returns it directly. No new ``hipArrayMapInfo_union_0`` is created in this case.

        Args:
            pyobj (object): Must be either `None`; a `hip._util.types.Pointer`; a simple, contiguous buffer according to the buffer protocol;
                            or of type `hipArrayMapInfo_union_0`; `int`; or `ctypes.c_void_p`.

        Note:
            This routine does not perform a copy but returns the original ``pyobj``
            if ``pyobj`` is an instance of hipArrayMapInfo_union_0!
        """
        cdef hipArrayMapInfo_union_0 wrapper

        if isinstance(pyobj,hipArrayMapInfo_union_0):
            return pyobj
        else:
            wrapper = hipArrayMapInfo_union_0.__new__(hipArrayMapInfo_union_0)
            wrapper.init_from_pyobj(pyobj)
            return wrapper

    def __dealloc__(self):
        # Release the buffer handle
        if self._py_buffer_acquired is True:
            cpython.buffer.PyBuffer_Release(&self._py_buffer)
        # De-allocate if not null and flag is set
        if self._ptr is not NULL and self._is_ptr_owner is True:
            stdlib.free(self._ptr)
            self._ptr = NULL

    @staticmethod
    cdef __allocate(void** ptr):
        ptr[0] = stdlib.malloc(sizeof(chip.hipArrayMapInfo_union_0))
        string.memset(<void*>ptr[0], 0, sizeof(chip.hipArrayMapInfo_union_0))

        if ptr[0] is NULL:
            raise MemoryError

    @staticmethod
    cdef hipArrayMapInfo_union_0 new():
        """Factory function to create hipArrayMapInfo_union_0 objects with
        newly allocated chip.hipArrayMapInfo_union_0"""
        cdef void* ptr
        hipArrayMapInfo_union_0.__allocate(&ptr)
        return hipArrayMapInfo_union_0.fromPtr(ptr, owner=True)

    @staticmethod
    cdef hipArrayMapInfo_union_0 fromValue(chip.hipArrayMapInfo_union_0 other):
        """Allocate new C type and copy from ``other``.
        """
        wrapper = hipArrayMapInfo_union_0.new()
        string.memcpy(wrapper._ptr, &other, sizeof(chip.hipArrayMapInfo_union_0))
        return wrapper

    def c_sizeof(self):
        """Returns the size of the underlying C type in bytes.
        Note:
            Implemented as function to not collide with
            autogenerated property names.
        """
        return sizeof(chip.hipArrayMapInfo_union_0)

    def __int__(self):
        """Returns the data's address as long integer.
        """
        return cpython.long.PyLong_FromVoidPtr(self._ptr)

    def __repr__(self):
        return f"<hipArrayMapInfo_union_0 object, ptr: {int(self)}>"

    def as_c_void_p(self):
        """Returns the data's address as `ctypes.c_void_p`
        Note:
            Implemented as function to not collide with
            autogenerated property names.
        """
        return ctypes.c_void_p(int(self))

    def __init__(self,**kwargs):
        """Constructor type hipArrayMapInfo_union_0.

        Constructor for type hipArrayMapInfo_union_0.

        Args:
            **kwargs:
                Can be used to initialize member variables at construction,
                Just pass an argument expression of the form <member>=<value>
                per member that you want to initialize.
        """
        hipArrayMapInfo_union_0.__allocate(&self._ptr)
        self._is_ptr_owner = True
        attribs = self.PROPERTIES()
        used_attribs = set()
        if len(kwargs) > 1:
            raise ValueError("Not more than one attribute might specified for Python types derived from C union types.")
        valid_names = ", ".join(["'"+p+"'" for p in attribs])
        for k,v in kwargs.items():
            if k in used_attribs:
                raise KeyError(f"argument '{k}' has already been specified as positional argument.")
            elif k not in attribs:
                raise KeyError(f"'{k}' is no valid property name. Valid names: {valid_names}")
            setattr(self,k,v)
    def get_mipmap(self, i):
        """Get value of ``mipmap`` of ``(<chip.hipArrayMapInfo_union_0*>self._ptr)[i]``.
        """
        return hipMipmappedArray.fromPtr(&(<chip.hipArrayMapInfo_union_0*>self._ptr)[i].mipmap)
    @property
    def mipmap(self):
        """(undocumented)"""
        return self.get_mipmap(0)

    @staticmethod
    def PROPERTIES():
        return ["mipmap"]


cdef class hipArrayMapInfo_union_1_struct_0(hip._util.types.Pointer):
    """Python wrapper for cdef class chip.hipArrayMapInfo_union_1_struct_0.

    Python wrapper for cdef class chip.hipArrayMapInfo_union_1_struct_0.

    If this type is initialized via its `__init__` method, it allocates a
    member of the underlying C type and destroys it again if the wrapper
    type is deallocated.

    This type also serves as adapter when appearing as argument type in a
    function signature. In this case, the type can further be initialized
    from a number of Python objects:

    * `None`:

      This will set the ``self._ptr`` attribute to ``NULL``.

    * `int`:

      Interprets the integer value as pointer address and writes it to ``self._ptr``.
      No ownership is transferred.

    * `ctypes.c_void_p`:

      Takes the pointer address ``pyobj.value`` and writes it to ``self._ptr``.
      No ownership is transferred.

    * `object` that implements the `CUDA Array Interface <https://numba.readthedocs.io/en/stable/cuda/cuda_array_interface.html>`_ protocol:

      Takes the integer-valued pointer address, i.e. the first entry of the `data` tuple
      from `pyobj`'s member ``__cuda_array_interface__``  and writes it to ``self._ptr``.

    * `object` that implements the Python buffer protocol:

      If the object represents a simple contiguous array,
      writes the `Py_buffer` associated with ``pyobj`` to `self._py_buffer`,
      sets the `self._py_buffer_acquired` flag to `True`, and
      writes `self._py_buffer.buf` to the data pointer `self._ptr`.

    * `hip._util.types.Pointer`:

      Takes the pointer address ``pyobj._ptr`` and writes it to ``self._ptr``.
      No ownership is transferred.

    Type checks are performed in the above order.

    C Attributes:
        _ptr (C type ``void *``, protected):
            Stores a pointer to the data of the original Python object.
        _is_ptr_owner (C type ``bint``, protected):
            If this wrapper is the owner of the underlying data.
        _py_buffer (C type ``Py_buffer`, protected):
            Stores a pointer to the data of the original Python object.
        _py_buffer_acquired (C type ``bint``, protected):
            Stores a pointer to the data of the original Python object.
    """
    # C members declared in pxd file

    def __cinit__(self):
        self._ptr = NULL
        self._is_ptr_owner = False
        self._py_buffer_acquired = False

    cdef chip.hipArrayMapInfo_union_1_struct_0* getElementPtr(self):
        return <chip.hipArrayMapInfo_union_1_struct_0*>self._ptr

    @staticmethod
    cdef hipArrayMapInfo_union_1_struct_0 fromPtr(void* ptr, bint owner=False):
        """Factory function to create ``hipArrayMapInfo_union_1_struct_0`` objects from
        given ``chip.hipArrayMapInfo_union_1_struct_0`` pointer.

        Setting ``owner`` flag to ``True`` causes
        the extension type to free the structure pointed to by ``ptr``
        when the wrapper object is deallocated.
        """
        # Fast call to __new__() that bypasses the __init__() constructor.
        cdef hipArrayMapInfo_union_1_struct_0 wrapper = hipArrayMapInfo_union_1_struct_0.__new__(hipArrayMapInfo_union_1_struct_0)
        wrapper._ptr = ptr
        wrapper._is_ptr_owner = owner
        return wrapper

    @staticmethod
    def fromObj(pyobj):
        """Creates a hipArrayMapInfo_union_1_struct_0 from a Python object.

        Derives a hipArrayMapInfo_union_1_struct_0 from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``hipArrayMapInfo_union_1_struct_0`` reference, this method
        returns it directly. No new ``hipArrayMapInfo_union_1_struct_0`` is created in this case.
        """
        return hipArrayMapInfo_union_1_struct_0.fromPyobj(pyobj)

    @staticmethod
    cdef hipArrayMapInfo_union_1_struct_0 fromPyobj(object pyobj):
        """Creates a hipArrayMapInfo_union_1_struct_0 from a Python object.

        Derives a hipArrayMapInfo_union_1_struct_0 from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``hipArrayMapInfo_union_1_struct_0`` reference, this method
        returns it directly. No new ``hipArrayMapInfo_union_1_struct_0`` is created in this case.

        Args:
            pyobj (object): Must be either `None`; a `hip._util.types.Pointer`; a simple, contiguous buffer according to the buffer protocol;
                            or of type `hipArrayMapInfo_union_1_struct_0`; `int`; or `ctypes.c_void_p`.

        Note:
            This routine does not perform a copy but returns the original ``pyobj``
            if ``pyobj`` is an instance of hipArrayMapInfo_union_1_struct_0!
        """
        cdef hipArrayMapInfo_union_1_struct_0 wrapper

        if isinstance(pyobj,hipArrayMapInfo_union_1_struct_0):
            return pyobj
        else:
            wrapper = hipArrayMapInfo_union_1_struct_0.__new__(hipArrayMapInfo_union_1_struct_0)
            wrapper.init_from_pyobj(pyobj)
            return wrapper

    def __dealloc__(self):
        # Release the buffer handle
        if self._py_buffer_acquired is True:
            cpython.buffer.PyBuffer_Release(&self._py_buffer)
        # De-allocate if not null and flag is set
        if self._ptr is not NULL and self._is_ptr_owner is True:
            stdlib.free(self._ptr)
            self._ptr = NULL

    @staticmethod
    cdef __allocate(void** ptr):
        ptr[0] = stdlib.malloc(sizeof(chip.hipArrayMapInfo_union_1_struct_0))
        string.memset(<void*>ptr[0], 0, sizeof(chip.hipArrayMapInfo_union_1_struct_0))

        if ptr[0] is NULL:
            raise MemoryError

    @staticmethod
    cdef hipArrayMapInfo_union_1_struct_0 new():
        """Factory function to create hipArrayMapInfo_union_1_struct_0 objects with
        newly allocated chip.hipArrayMapInfo_union_1_struct_0"""
        cdef void* ptr
        hipArrayMapInfo_union_1_struct_0.__allocate(&ptr)
        return hipArrayMapInfo_union_1_struct_0.fromPtr(ptr, owner=True)

    @staticmethod
    cdef hipArrayMapInfo_union_1_struct_0 fromValue(chip.hipArrayMapInfo_union_1_struct_0 other):
        """Allocate new C type and copy from ``other``.
        """
        wrapper = hipArrayMapInfo_union_1_struct_0.new()
        string.memcpy(wrapper._ptr, &other, sizeof(chip.hipArrayMapInfo_union_1_struct_0))
        return wrapper

    def c_sizeof(self):
        """Returns the size of the underlying C type in bytes.
        Note:
            Implemented as function to not collide with
            autogenerated property names.
        """
        return sizeof(chip.hipArrayMapInfo_union_1_struct_0)

    def __int__(self):
        """Returns the data's address as long integer.
        """
        return cpython.long.PyLong_FromVoidPtr(self._ptr)

    def __repr__(self):
        return f"<hipArrayMapInfo_union_1_struct_0 object, ptr: {int(self)}>"

    def as_c_void_p(self):
        """Returns the data's address as `ctypes.c_void_p`
        Note:
            Implemented as function to not collide with
            autogenerated property names.
        """
        return ctypes.c_void_p(int(self))

    def __init__(self,*args,**kwargs):
        """Constructor type hipArrayMapInfo_union_1_struct_0.

        Constructor for type hipArrayMapInfo_union_1_struct_0.

        Args:
            *args:
                Positional arguments. Initialize all or a subset of the member variables
                according to their order of declaration.
            **kwargs:
                Can be used to initialize member variables at construction,
                Just pass an argument expression of the form <member>=<value>
                per member that you want to initialize.
        """
        hipArrayMapInfo_union_1_struct_0.__allocate(&self._ptr)
        self._is_ptr_owner = True
        attribs = self.PROPERTIES()
        used_attribs = set()
        if len(args) > len(attribs):
            raise ValueError("More positional arguments specified than this type has properties.")
        for i,v in enumerate(args):
            setattr(self,attribs[i],v)
            used_attribs.add(attribs[i])
        valid_names = ", ".join(["'"+p+"'" for p in attribs])
        for k,v in kwargs.items():
            if k in used_attribs:
                raise KeyError(f"argument '{k}' has already been specified as positional argument.")
            elif k not in attribs:
                raise KeyError(f"'{k}' is no valid property name. Valid names: {valid_names}")
            setattr(self,k,v)
    def get_level(self, i):
        """Get value ``level`` of ``(<chip.hipArrayMapInfo_union_1_struct_0*>self._ptr)[i]``.
        """
        return (<chip.hipArrayMapInfo_union_1_struct_0*>self._ptr)[i].level
    def set_level(self, i, unsigned int value):
        """Set value ``level`` of ``(<chip.hipArrayMapInfo_union_1_struct_0*>self._ptr)[i]``.
        """
        (<chip.hipArrayMapInfo_union_1_struct_0*>self._ptr)[i].level = value
    @property
    def level(self):
        """For mipmapped arrays must be a valid mipmap level. For arrays must be zero"""
        return self.get_level(0)
    @level.setter
    def level(self, unsigned int value):
        self.set_level(0,value)

    def get_layer(self, i):
        """Get value ``layer`` of ``(<chip.hipArrayMapInfo_union_1_struct_0*>self._ptr)[i]``.
        """
        return (<chip.hipArrayMapInfo_union_1_struct_0*>self._ptr)[i].layer
    def set_layer(self, i, unsigned int value):
        """Set value ``layer`` of ``(<chip.hipArrayMapInfo_union_1_struct_0*>self._ptr)[i]``.
        """
        (<chip.hipArrayMapInfo_union_1_struct_0*>self._ptr)[i].layer = value
    @property
    def layer(self):
        """For layered arrays must be a valid layer index. Otherwise, must be zero"""
        return self.get_layer(0)
    @layer.setter
    def layer(self, unsigned int value):
        self.set_layer(0,value)

    def get_offsetX(self, i):
        """Get value ``offsetX`` of ``(<chip.hipArrayMapInfo_union_1_struct_0*>self._ptr)[i]``.
        """
        return (<chip.hipArrayMapInfo_union_1_struct_0*>self._ptr)[i].offsetX
    def set_offsetX(self, i, unsigned int value):
        """Set value ``offsetX`` of ``(<chip.hipArrayMapInfo_union_1_struct_0*>self._ptr)[i]``.
        """
        (<chip.hipArrayMapInfo_union_1_struct_0*>self._ptr)[i].offsetX = value
    @property
    def offsetX(self):
        """X offset in elements"""
        return self.get_offsetX(0)
    @offsetX.setter
    def offsetX(self, unsigned int value):
        self.set_offsetX(0,value)

    def get_offsetY(self, i):
        """Get value ``offsetY`` of ``(<chip.hipArrayMapInfo_union_1_struct_0*>self._ptr)[i]``.
        """
        return (<chip.hipArrayMapInfo_union_1_struct_0*>self._ptr)[i].offsetY
    def set_offsetY(self, i, unsigned int value):
        """Set value ``offsetY`` of ``(<chip.hipArrayMapInfo_union_1_struct_0*>self._ptr)[i]``.
        """
        (<chip.hipArrayMapInfo_union_1_struct_0*>self._ptr)[i].offsetY = value
    @property
    def offsetY(self):
        """Y offset in elements"""
        return self.get_offsetY(0)
    @offsetY.setter
    def offsetY(self, unsigned int value):
        self.set_offsetY(0,value)

    def get_offsetZ(self, i):
        """Get value ``offsetZ`` of ``(<chip.hipArrayMapInfo_union_1_struct_0*>self._ptr)[i]``.
        """
        return (<chip.hipArrayMapInfo_union_1_struct_0*>self._ptr)[i].offsetZ
    def set_offsetZ(self, i, unsigned int value):
        """Set value ``offsetZ`` of ``(<chip.hipArrayMapInfo_union_1_struct_0*>self._ptr)[i]``.
        """
        (<chip.hipArrayMapInfo_union_1_struct_0*>self._ptr)[i].offsetZ = value
    @property
    def offsetZ(self):
        """Z offset in elements"""
        return self.get_offsetZ(0)
    @offsetZ.setter
    def offsetZ(self, unsigned int value):
        self.set_offsetZ(0,value)

    def get_extentWidth(self, i):
        """Get value ``extentWidth`` of ``(<chip.hipArrayMapInfo_union_1_struct_0*>self._ptr)[i]``.
        """
        return (<chip.hipArrayMapInfo_union_1_struct_0*>self._ptr)[i].extentWidth
    def set_extentWidth(self, i, unsigned int value):
        """Set value ``extentWidth`` of ``(<chip.hipArrayMapInfo_union_1_struct_0*>self._ptr)[i]``.
        """
        (<chip.hipArrayMapInfo_union_1_struct_0*>self._ptr)[i].extentWidth = value
    @property
    def extentWidth(self):
        """Width in elements"""
        return self.get_extentWidth(0)
    @extentWidth.setter
    def extentWidth(self, unsigned int value):
        self.set_extentWidth(0,value)

    def get_extentHeight(self, i):
        """Get value ``extentHeight`` of ``(<chip.hipArrayMapInfo_union_1_struct_0*>self._ptr)[i]``.
        """
        return (<chip.hipArrayMapInfo_union_1_struct_0*>self._ptr)[i].extentHeight
    def set_extentHeight(self, i, unsigned int value):
        """Set value ``extentHeight`` of ``(<chip.hipArrayMapInfo_union_1_struct_0*>self._ptr)[i]``.
        """
        (<chip.hipArrayMapInfo_union_1_struct_0*>self._ptr)[i].extentHeight = value
    @property
    def extentHeight(self):
        """Height in elements"""
        return self.get_extentHeight(0)
    @extentHeight.setter
    def extentHeight(self, unsigned int value):
        self.set_extentHeight(0,value)

    def get_extentDepth(self, i):
        """Get value ``extentDepth`` of ``(<chip.hipArrayMapInfo_union_1_struct_0*>self._ptr)[i]``.
        """
        return (<chip.hipArrayMapInfo_union_1_struct_0*>self._ptr)[i].extentDepth
    def set_extentDepth(self, i, unsigned int value):
        """Set value ``extentDepth`` of ``(<chip.hipArrayMapInfo_union_1_struct_0*>self._ptr)[i]``.
        """
        (<chip.hipArrayMapInfo_union_1_struct_0*>self._ptr)[i].extentDepth = value
    @property
    def extentDepth(self):
        """Depth in elements"""
        return self.get_extentDepth(0)
    @extentDepth.setter
    def extentDepth(self, unsigned int value):
        self.set_extentDepth(0,value)

    @staticmethod
    def PROPERTIES():
        return ["level","layer","offsetX","offsetY","offsetZ","extentWidth","extentHeight","extentDepth"]

    def __contains__(self,item):
        properties = self.PROPERTIES()
        return item in properties

    def __getitem__(self,item):
        properties = self.PROPERTIES()
        if isinstance(item,int):
            if item < 0 or item >= len(properties):
                raise IndexError()
            return getattr(self,properties[item])
        raise ValueError("'item' type must be 'int'")


cdef class hipArrayMapInfo_union_1_struct_1(hip._util.types.Pointer):
    """Python wrapper for cdef class chip.hipArrayMapInfo_union_1_struct_1.

    Python wrapper for cdef class chip.hipArrayMapInfo_union_1_struct_1.

    If this type is initialized via its `__init__` method, it allocates a
    member of the underlying C type and destroys it again if the wrapper
    type is deallocated.

    This type also serves as adapter when appearing as argument type in a
    function signature. In this case, the type can further be initialized
    from a number of Python objects:

    * `None`:

      This will set the ``self._ptr`` attribute to ``NULL``.

    * `int`:

      Interprets the integer value as pointer address and writes it to ``self._ptr``.
      No ownership is transferred.

    * `ctypes.c_void_p`:

      Takes the pointer address ``pyobj.value`` and writes it to ``self._ptr``.
      No ownership is transferred.

    * `object` that implements the `CUDA Array Interface <https://numba.readthedocs.io/en/stable/cuda/cuda_array_interface.html>`_ protocol:

      Takes the integer-valued pointer address, i.e. the first entry of the `data` tuple
      from `pyobj`'s member ``__cuda_array_interface__``  and writes it to ``self._ptr``.

    * `object` that implements the Python buffer protocol:

      If the object represents a simple contiguous array,
      writes the `Py_buffer` associated with ``pyobj`` to `self._py_buffer`,
      sets the `self._py_buffer_acquired` flag to `True`, and
      writes `self._py_buffer.buf` to the data pointer `self._ptr`.

    * `hip._util.types.Pointer`:

      Takes the pointer address ``pyobj._ptr`` and writes it to ``self._ptr``.
      No ownership is transferred.

    Type checks are performed in the above order.

    C Attributes:
        _ptr (C type ``void *``, protected):
            Stores a pointer to the data of the original Python object.
        _is_ptr_owner (C type ``bint``, protected):
            If this wrapper is the owner of the underlying data.
        _py_buffer (C type ``Py_buffer`, protected):
            Stores a pointer to the data of the original Python object.
        _py_buffer_acquired (C type ``bint``, protected):
            Stores a pointer to the data of the original Python object.
    """
    # C members declared in pxd file

    def __cinit__(self):
        self._ptr = NULL
        self._is_ptr_owner = False
        self._py_buffer_acquired = False

    cdef chip.hipArrayMapInfo_union_1_struct_1* getElementPtr(self):
        return <chip.hipArrayMapInfo_union_1_struct_1*>self._ptr

    @staticmethod
    cdef hipArrayMapInfo_union_1_struct_1 fromPtr(void* ptr, bint owner=False):
        """Factory function to create ``hipArrayMapInfo_union_1_struct_1`` objects from
        given ``chip.hipArrayMapInfo_union_1_struct_1`` pointer.

        Setting ``owner`` flag to ``True`` causes
        the extension type to free the structure pointed to by ``ptr``
        when the wrapper object is deallocated.
        """
        # Fast call to __new__() that bypasses the __init__() constructor.
        cdef hipArrayMapInfo_union_1_struct_1 wrapper = hipArrayMapInfo_union_1_struct_1.__new__(hipArrayMapInfo_union_1_struct_1)
        wrapper._ptr = ptr
        wrapper._is_ptr_owner = owner
        return wrapper

    @staticmethod
    def fromObj(pyobj):
        """Creates a hipArrayMapInfo_union_1_struct_1 from a Python object.

        Derives a hipArrayMapInfo_union_1_struct_1 from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``hipArrayMapInfo_union_1_struct_1`` reference, this method
        returns it directly. No new ``hipArrayMapInfo_union_1_struct_1`` is created in this case.
        """
        return hipArrayMapInfo_union_1_struct_1.fromPyobj(pyobj)

    @staticmethod
    cdef hipArrayMapInfo_union_1_struct_1 fromPyobj(object pyobj):
        """Creates a hipArrayMapInfo_union_1_struct_1 from a Python object.

        Derives a hipArrayMapInfo_union_1_struct_1 from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``hipArrayMapInfo_union_1_struct_1`` reference, this method
        returns it directly. No new ``hipArrayMapInfo_union_1_struct_1`` is created in this case.

        Args:
            pyobj (object): Must be either `None`; a `hip._util.types.Pointer`; a simple, contiguous buffer according to the buffer protocol;
                            or of type `hipArrayMapInfo_union_1_struct_1`; `int`; or `ctypes.c_void_p`.

        Note:
            This routine does not perform a copy but returns the original ``pyobj``
            if ``pyobj`` is an instance of hipArrayMapInfo_union_1_struct_1!
        """
        cdef hipArrayMapInfo_union_1_struct_1 wrapper

        if isinstance(pyobj,hipArrayMapInfo_union_1_struct_1):
            return pyobj
        else:
            wrapper = hipArrayMapInfo_union_1_struct_1.__new__(hipArrayMapInfo_union_1_struct_1)
            wrapper.init_from_pyobj(pyobj)
            return wrapper

    def __dealloc__(self):
        # Release the buffer handle
        if self._py_buffer_acquired is True:
            cpython.buffer.PyBuffer_Release(&self._py_buffer)
        # De-allocate if not null and flag is set
        if self._ptr is not NULL and self._is_ptr_owner is True:
            stdlib.free(self._ptr)
            self._ptr = NULL

    @staticmethod
    cdef __allocate(void** ptr):
        ptr[0] = stdlib.malloc(sizeof(chip.hipArrayMapInfo_union_1_struct_1))
        string.memset(<void*>ptr[0], 0, sizeof(chip.hipArrayMapInfo_union_1_struct_1))

        if ptr[0] is NULL:
            raise MemoryError

    @staticmethod
    cdef hipArrayMapInfo_union_1_struct_1 new():
        """Factory function to create hipArrayMapInfo_union_1_struct_1 objects with
        newly allocated chip.hipArrayMapInfo_union_1_struct_1"""
        cdef void* ptr
        hipArrayMapInfo_union_1_struct_1.__allocate(&ptr)
        return hipArrayMapInfo_union_1_struct_1.fromPtr(ptr, owner=True)

    @staticmethod
    cdef hipArrayMapInfo_union_1_struct_1 fromValue(chip.hipArrayMapInfo_union_1_struct_1 other):
        """Allocate new C type and copy from ``other``.
        """
        wrapper = hipArrayMapInfo_union_1_struct_1.new()
        string.memcpy(wrapper._ptr, &other, sizeof(chip.hipArrayMapInfo_union_1_struct_1))
        return wrapper

    def c_sizeof(self):
        """Returns the size of the underlying C type in bytes.
        Note:
            Implemented as function to not collide with
            autogenerated property names.
        """
        return sizeof(chip.hipArrayMapInfo_union_1_struct_1)

    def __int__(self):
        """Returns the data's address as long integer.
        """
        return cpython.long.PyLong_FromVoidPtr(self._ptr)

    def __repr__(self):
        return f"<hipArrayMapInfo_union_1_struct_1 object, ptr: {int(self)}>"

    def as_c_void_p(self):
        """Returns the data's address as `ctypes.c_void_p`
        Note:
            Implemented as function to not collide with
            autogenerated property names.
        """
        return ctypes.c_void_p(int(self))

    def __init__(self,*args,**kwargs):
        """Constructor type hipArrayMapInfo_union_1_struct_1.

        Constructor for type hipArrayMapInfo_union_1_struct_1.

        Args:
            *args:
                Positional arguments. Initialize all or a subset of the member variables
                according to their order of declaration.
            **kwargs:
                Can be used to initialize member variables at construction,
                Just pass an argument expression of the form <member>=<value>
                per member that you want to initialize.
        """
        hipArrayMapInfo_union_1_struct_1.__allocate(&self._ptr)
        self._is_ptr_owner = True
        attribs = self.PROPERTIES()
        used_attribs = set()
        if len(args) > len(attribs):
            raise ValueError("More positional arguments specified than this type has properties.")
        for i,v in enumerate(args):
            setattr(self,attribs[i],v)
            used_attribs.add(attribs[i])
        valid_names = ", ".join(["'"+p+"'" for p in attribs])
        for k,v in kwargs.items():
            if k in used_attribs:
                raise KeyError(f"argument '{k}' has already been specified as positional argument.")
            elif k not in attribs:
                raise KeyError(f"'{k}' is no valid property name. Valid names: {valid_names}")
            setattr(self,k,v)
    def get_layer(self, i):
        """Get value ``layer`` of ``(<chip.hipArrayMapInfo_union_1_struct_1*>self._ptr)[i]``.
        """
        return (<chip.hipArrayMapInfo_union_1_struct_1*>self._ptr)[i].layer
    def set_layer(self, i, unsigned int value):
        """Set value ``layer`` of ``(<chip.hipArrayMapInfo_union_1_struct_1*>self._ptr)[i]``.
        """
        (<chip.hipArrayMapInfo_union_1_struct_1*>self._ptr)[i].layer = value
    @property
    def layer(self):
        """For layered arrays must be a valid layer index. Otherwise, must be zero"""
        return self.get_layer(0)
    @layer.setter
    def layer(self, unsigned int value):
        self.set_layer(0,value)

    def get_offset(self, i):
        """Get value ``offset`` of ``(<chip.hipArrayMapInfo_union_1_struct_1*>self._ptr)[i]``.
        """
        return (<chip.hipArrayMapInfo_union_1_struct_1*>self._ptr)[i].offset
    def set_offset(self, i, unsigned long long value):
        """Set value ``offset`` of ``(<chip.hipArrayMapInfo_union_1_struct_1*>self._ptr)[i]``.
        """
        (<chip.hipArrayMapInfo_union_1_struct_1*>self._ptr)[i].offset = value
    @property
    def offset(self):
        """Offset within mip tail"""
        return self.get_offset(0)
    @offset.setter
    def offset(self, unsigned long long value):
        self.set_offset(0,value)

    def get_size(self, i):
        """Get value ``size`` of ``(<chip.hipArrayMapInfo_union_1_struct_1*>self._ptr)[i]``.
        """
        return (<chip.hipArrayMapInfo_union_1_struct_1*>self._ptr)[i].size
    def set_size(self, i, unsigned long long value):
        """Set value ``size`` of ``(<chip.hipArrayMapInfo_union_1_struct_1*>self._ptr)[i]``.
        """
        (<chip.hipArrayMapInfo_union_1_struct_1*>self._ptr)[i].size = value
    @property
    def size(self):
        """Extent in bytes"""
        return self.get_size(0)
    @size.setter
    def size(self, unsigned long long value):
        self.set_size(0,value)

    @staticmethod
    def PROPERTIES():
        return ["layer","offset","size"]

    def __contains__(self,item):
        properties = self.PROPERTIES()
        return item in properties

    def __getitem__(self,item):
        properties = self.PROPERTIES()
        if isinstance(item,int):
            if item < 0 or item >= len(properties):
                raise IndexError()
            return getattr(self,properties[item])
        raise ValueError("'item' type must be 'int'")


cdef class hipArrayMapInfo_union_1(hip._util.types.Pointer):
    """Python wrapper for cdef class chip.hipArrayMapInfo_union_1.

    Python wrapper for cdef class chip.hipArrayMapInfo_union_1.

    If this type is initialized via its `__init__` method, it allocates a
    member of the underlying C type and destroys it again if the wrapper
    type is deallocated.

    This type also serves as adapter when appearing as argument type in a
    function signature. In this case, the type can further be initialized
    from a number of Python objects:

    * `None`:

      This will set the ``self._ptr`` attribute to ``NULL``.

    * `int`:

      Interprets the integer value as pointer address and writes it to ``self._ptr``.
      No ownership is transferred.

    * `ctypes.c_void_p`:

      Takes the pointer address ``pyobj.value`` and writes it to ``self._ptr``.
      No ownership is transferred.

    * `object` that implements the `CUDA Array Interface <https://numba.readthedocs.io/en/stable/cuda/cuda_array_interface.html>`_ protocol:

      Takes the integer-valued pointer address, i.e. the first entry of the `data` tuple
      from `pyobj`'s member ``__cuda_array_interface__``  and writes it to ``self._ptr``.

    * `object` that implements the Python buffer protocol:

      If the object represents a simple contiguous array,
      writes the `Py_buffer` associated with ``pyobj`` to `self._py_buffer`,
      sets the `self._py_buffer_acquired` flag to `True`, and
      writes `self._py_buffer.buf` to the data pointer `self._ptr`.

    * `hip._util.types.Pointer`:

      Takes the pointer address ``pyobj._ptr`` and writes it to ``self._ptr``.
      No ownership is transferred.

    Type checks are performed in the above order.

    C Attributes:
        _ptr (C type ``void *``, protected):
            Stores a pointer to the data of the original Python object.
        _is_ptr_owner (C type ``bint``, protected):
            If this wrapper is the owner of the underlying data.
        _py_buffer (C type ``Py_buffer`, protected):
            Stores a pointer to the data of the original Python object.
        _py_buffer_acquired (C type ``bint``, protected):
            Stores a pointer to the data of the original Python object.
    """
    # C members declared in pxd file

    def __cinit__(self):
        self._ptr = NULL
        self._is_ptr_owner = False
        self._py_buffer_acquired = False

    cdef chip.hipArrayMapInfo_union_1* getElementPtr(self):
        return <chip.hipArrayMapInfo_union_1*>self._ptr

    @staticmethod
    cdef hipArrayMapInfo_union_1 fromPtr(void* ptr, bint owner=False):
        """Factory function to create ``hipArrayMapInfo_union_1`` objects from
        given ``chip.hipArrayMapInfo_union_1`` pointer.

        Setting ``owner`` flag to ``True`` causes
        the extension type to free the structure pointed to by ``ptr``
        when the wrapper object is deallocated.
        """
        # Fast call to __new__() that bypasses the __init__() constructor.
        cdef hipArrayMapInfo_union_1 wrapper = hipArrayMapInfo_union_1.__new__(hipArrayMapInfo_union_1)
        wrapper._ptr = ptr
        wrapper._is_ptr_owner = owner
        return wrapper

    @staticmethod
    def fromObj(pyobj):
        """Creates a hipArrayMapInfo_union_1 from a Python object.

        Derives a hipArrayMapInfo_union_1 from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``hipArrayMapInfo_union_1`` reference, this method
        returns it directly. No new ``hipArrayMapInfo_union_1`` is created in this case.
        """
        return hipArrayMapInfo_union_1.fromPyobj(pyobj)

    @staticmethod
    cdef hipArrayMapInfo_union_1 fromPyobj(object pyobj):
        """Creates a hipArrayMapInfo_union_1 from a Python object.

        Derives a hipArrayMapInfo_union_1 from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``hipArrayMapInfo_union_1`` reference, this method
        returns it directly. No new ``hipArrayMapInfo_union_1`` is created in this case.

        Args:
            pyobj (object): Must be either `None`; a `hip._util.types.Pointer`; a simple, contiguous buffer according to the buffer protocol;
                            or of type `hipArrayMapInfo_union_1`; `int`; or `ctypes.c_void_p`.

        Note:
            This routine does not perform a copy but returns the original ``pyobj``
            if ``pyobj`` is an instance of hipArrayMapInfo_union_1!
        """
        cdef hipArrayMapInfo_union_1 wrapper

        if isinstance(pyobj,hipArrayMapInfo_union_1):
            return pyobj
        else:
            wrapper = hipArrayMapInfo_union_1.__new__(hipArrayMapInfo_union_1)
            wrapper.init_from_pyobj(pyobj)
            return wrapper

    def __dealloc__(self):
        # Release the buffer handle
        if self._py_buffer_acquired is True:
            cpython.buffer.PyBuffer_Release(&self._py_buffer)
        # De-allocate if not null and flag is set
        if self._ptr is not NULL and self._is_ptr_owner is True:
            stdlib.free(self._ptr)
            self._ptr = NULL

    @staticmethod
    cdef __allocate(void** ptr):
        ptr[0] = stdlib.malloc(sizeof(chip.hipArrayMapInfo_union_1))
        string.memset(<void*>ptr[0], 0, sizeof(chip.hipArrayMapInfo_union_1))

        if ptr[0] is NULL:
            raise MemoryError

    @staticmethod
    cdef hipArrayMapInfo_union_1 new():
        """Factory function to create hipArrayMapInfo_union_1 objects with
        newly allocated chip.hipArrayMapInfo_union_1"""
        cdef void* ptr
        hipArrayMapInfo_union_1.__allocate(&ptr)
        return hipArrayMapInfo_union_1.fromPtr(ptr, owner=True)

    @staticmethod
    cdef hipArrayMapInfo_union_1 fromValue(chip.hipArrayMapInfo_union_1 other):
        """Allocate new C type and copy from ``other``.
        """
        wrapper = hipArrayMapInfo_union_1.new()
        string.memcpy(wrapper._ptr, &other, sizeof(chip.hipArrayMapInfo_union_1))
        return wrapper

    def c_sizeof(self):
        """Returns the size of the underlying C type in bytes.
        Note:
            Implemented as function to not collide with
            autogenerated property names.
        """
        return sizeof(chip.hipArrayMapInfo_union_1)

    def __int__(self):
        """Returns the data's address as long integer.
        """
        return cpython.long.PyLong_FromVoidPtr(self._ptr)

    def __repr__(self):
        return f"<hipArrayMapInfo_union_1 object, ptr: {int(self)}>"

    def as_c_void_p(self):
        """Returns the data's address as `ctypes.c_void_p`
        Note:
            Implemented as function to not collide with
            autogenerated property names.
        """
        return ctypes.c_void_p(int(self))

    def __init__(self,**kwargs):
        """Constructor type hipArrayMapInfo_union_1.

        Constructor for type hipArrayMapInfo_union_1.

        Args:
            **kwargs:
                Can be used to initialize member variables at construction,
                Just pass an argument expression of the form <member>=<value>
                per member that you want to initialize.
        """
        hipArrayMapInfo_union_1.__allocate(&self._ptr)
        self._is_ptr_owner = True
        attribs = self.PROPERTIES()
        used_attribs = set()
        if len(kwargs) > 1:
            raise ValueError("Not more than one attribute might specified for Python types derived from C union types.")
        valid_names = ", ".join(["'"+p+"'" for p in attribs])
        for k,v in kwargs.items():
            if k in used_attribs:
                raise KeyError(f"argument '{k}' has already been specified as positional argument.")
            elif k not in attribs:
                raise KeyError(f"'{k}' is no valid property name. Valid names: {valid_names}")
            setattr(self,k,v)
    def get_sparseLevel(self, i):
        """Get value of ``sparseLevel`` of ``(<chip.hipArrayMapInfo_union_1*>self._ptr)[i]``.
        """
        return hipArrayMapInfo_union_1_struct_0.fromPtr(&(<chip.hipArrayMapInfo_union_1*>self._ptr)[i].sparseLevel)
    @property
    def sparseLevel(self):
        """(undocumented)"""
        return self.get_sparseLevel(0)

    def get_miptail(self, i):
        """Get value of ``miptail`` of ``(<chip.hipArrayMapInfo_union_1*>self._ptr)[i]``.
        """
        return hipArrayMapInfo_union_1_struct_1.fromPtr(&(<chip.hipArrayMapInfo_union_1*>self._ptr)[i].miptail)
    @property
    def miptail(self):
        """(undocumented)"""
        return self.get_miptail(0)

    @staticmethod
    def PROPERTIES():
        return ["sparseLevel","miptail"]


cdef class hipArrayMapInfo_union_2(hip._util.types.Pointer):
    """Python wrapper for cdef class chip.hipArrayMapInfo_union_2.

    Python wrapper for cdef class chip.hipArrayMapInfo_union_2.

    If this type is initialized via its `__init__` method, it allocates a
    member of the underlying C type and destroys it again if the wrapper
    type is deallocated.

    This type also serves as adapter when appearing as argument type in a
    function signature. In this case, the type can further be initialized
    from a number of Python objects:

    * `None`:

      This will set the ``self._ptr`` attribute to ``NULL``.

    * `int`:

      Interprets the integer value as pointer address and writes it to ``self._ptr``.
      No ownership is transferred.

    * `ctypes.c_void_p`:

      Takes the pointer address ``pyobj.value`` and writes it to ``self._ptr``.
      No ownership is transferred.

    * `object` that implements the `CUDA Array Interface <https://numba.readthedocs.io/en/stable/cuda/cuda_array_interface.html>`_ protocol:

      Takes the integer-valued pointer address, i.e. the first entry of the `data` tuple
      from `pyobj`'s member ``__cuda_array_interface__``  and writes it to ``self._ptr``.

    * `object` that implements the Python buffer protocol:

      If the object represents a simple contiguous array,
      writes the `Py_buffer` associated with ``pyobj`` to `self._py_buffer`,
      sets the `self._py_buffer_acquired` flag to `True`, and
      writes `self._py_buffer.buf` to the data pointer `self._ptr`.

    * `hip._util.types.Pointer`:

      Takes the pointer address ``pyobj._ptr`` and writes it to ``self._ptr``.
      No ownership is transferred.

    Type checks are performed in the above order.

    C Attributes:
        _ptr (C type ``void *``, protected):
            Stores a pointer to the data of the original Python object.
        _is_ptr_owner (C type ``bint``, protected):
            If this wrapper is the owner of the underlying data.
        _py_buffer (C type ``Py_buffer`, protected):
            Stores a pointer to the data of the original Python object.
        _py_buffer_acquired (C type ``bint``, protected):
            Stores a pointer to the data of the original Python object.
    """
    # C members declared in pxd file

    def __cinit__(self):
        self._ptr = NULL
        self._is_ptr_owner = False
        self._py_buffer_acquired = False

    cdef chip.hipArrayMapInfo_union_2* getElementPtr(self):
        return <chip.hipArrayMapInfo_union_2*>self._ptr

    @staticmethod
    cdef hipArrayMapInfo_union_2 fromPtr(void* ptr, bint owner=False):
        """Factory function to create ``hipArrayMapInfo_union_2`` objects from
        given ``chip.hipArrayMapInfo_union_2`` pointer.

        Setting ``owner`` flag to ``True`` causes
        the extension type to free the structure pointed to by ``ptr``
        when the wrapper object is deallocated.
        """
        # Fast call to __new__() that bypasses the __init__() constructor.
        cdef hipArrayMapInfo_union_2 wrapper = hipArrayMapInfo_union_2.__new__(hipArrayMapInfo_union_2)
        wrapper._ptr = ptr
        wrapper._is_ptr_owner = owner
        return wrapper

    @staticmethod
    def fromObj(pyobj):
        """Creates a hipArrayMapInfo_union_2 from a Python object.

        Derives a hipArrayMapInfo_union_2 from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``hipArrayMapInfo_union_2`` reference, this method
        returns it directly. No new ``hipArrayMapInfo_union_2`` is created in this case.
        """
        return hipArrayMapInfo_union_2.fromPyobj(pyobj)

    @staticmethod
    cdef hipArrayMapInfo_union_2 fromPyobj(object pyobj):
        """Creates a hipArrayMapInfo_union_2 from a Python object.

        Derives a hipArrayMapInfo_union_2 from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``hipArrayMapInfo_union_2`` reference, this method
        returns it directly. No new ``hipArrayMapInfo_union_2`` is created in this case.

        Args:
            pyobj (object): Must be either `None`; a `hip._util.types.Pointer`; a simple, contiguous buffer according to the buffer protocol;
                            or of type `hipArrayMapInfo_union_2`; `int`; or `ctypes.c_void_p`.

        Note:
            This routine does not perform a copy but returns the original ``pyobj``
            if ``pyobj`` is an instance of hipArrayMapInfo_union_2!
        """
        cdef hipArrayMapInfo_union_2 wrapper

        if isinstance(pyobj,hipArrayMapInfo_union_2):
            return pyobj
        else:
            wrapper = hipArrayMapInfo_union_2.__new__(hipArrayMapInfo_union_2)
            wrapper.init_from_pyobj(pyobj)
            return wrapper

    def __dealloc__(self):
        # Release the buffer handle
        if self._py_buffer_acquired is True:
            cpython.buffer.PyBuffer_Release(&self._py_buffer)
        # De-allocate if not null and flag is set
        if self._ptr is not NULL and self._is_ptr_owner is True:
            stdlib.free(self._ptr)
            self._ptr = NULL

    @staticmethod
    cdef __allocate(void** ptr):
        ptr[0] = stdlib.malloc(sizeof(chip.hipArrayMapInfo_union_2))
        string.memset(<void*>ptr[0], 0, sizeof(chip.hipArrayMapInfo_union_2))

        if ptr[0] is NULL:
            raise MemoryError

    @staticmethod
    cdef hipArrayMapInfo_union_2 new():
        """Factory function to create hipArrayMapInfo_union_2 objects with
        newly allocated chip.hipArrayMapInfo_union_2"""
        cdef void* ptr
        hipArrayMapInfo_union_2.__allocate(&ptr)
        return hipArrayMapInfo_union_2.fromPtr(ptr, owner=True)

    @staticmethod
    cdef hipArrayMapInfo_union_2 fromValue(chip.hipArrayMapInfo_union_2 other):
        """Allocate new C type and copy from ``other``.
        """
        wrapper = hipArrayMapInfo_union_2.new()
        string.memcpy(wrapper._ptr, &other, sizeof(chip.hipArrayMapInfo_union_2))
        return wrapper

    def c_sizeof(self):
        """Returns the size of the underlying C type in bytes.
        Note:
            Implemented as function to not collide with
            autogenerated property names.
        """
        return sizeof(chip.hipArrayMapInfo_union_2)

    def __int__(self):
        """Returns the data's address as long integer.
        """
        return cpython.long.PyLong_FromVoidPtr(self._ptr)

    def __repr__(self):
        return f"<hipArrayMapInfo_union_2 object, ptr: {int(self)}>"

    def as_c_void_p(self):
        """Returns the data's address as `ctypes.c_void_p`
        Note:
            Implemented as function to not collide with
            autogenerated property names.
        """
        return ctypes.c_void_p(int(self))

    def __init__(self,**kwargs):
        """Constructor type hipArrayMapInfo_union_2.

        Constructor for type hipArrayMapInfo_union_2.

        Args:
            **kwargs:
                Can be used to initialize member variables at construction,
                Just pass an argument expression of the form <member>=<value>
                per member that you want to initialize.
        """
        hipArrayMapInfo_union_2.__allocate(&self._ptr)
        self._is_ptr_owner = True
        attribs = self.PROPERTIES()
        used_attribs = set()
        if len(kwargs) > 1:
            raise ValueError("Not more than one attribute might specified for Python types derived from C union types.")
        valid_names = ", ".join(["'"+p+"'" for p in attribs])
        for k,v in kwargs.items():
            if k in used_attribs:
                raise KeyError(f"argument '{k}' has already been specified as positional argument.")
            elif k not in attribs:
                raise KeyError(f"'{k}' is no valid property name. Valid names: {valid_names}")
            setattr(self,k,v)
    @staticmethod
    def PROPERTIES():
        return []


cdef class hipArrayMapInfo(hip._util.types.Pointer):
    """Python wrapper for cdef class chip.hipArrayMapInfo.

    Python wrapper for cdef class chip.hipArrayMapInfo.

    If this type is initialized via its `__init__` method, it allocates a
    member of the underlying C type and destroys it again if the wrapper
    type is deallocated.

    This type also serves as adapter when appearing as argument type in a
    function signature. In this case, the type can further be initialized
    from a number of Python objects:

    * `None`:

      This will set the ``self._ptr`` attribute to ``NULL``.

    * `int`:

      Interprets the integer value as pointer address and writes it to ``self._ptr``.
      No ownership is transferred.

    * `ctypes.c_void_p`:

      Takes the pointer address ``pyobj.value`` and writes it to ``self._ptr``.
      No ownership is transferred.

    * `object` that implements the `CUDA Array Interface <https://numba.readthedocs.io/en/stable/cuda/cuda_array_interface.html>`_ protocol:

      Takes the integer-valued pointer address, i.e. the first entry of the `data` tuple
      from `pyobj`'s member ``__cuda_array_interface__``  and writes it to ``self._ptr``.

    * `object` that implements the Python buffer protocol:

      If the object represents a simple contiguous array,
      writes the `Py_buffer` associated with ``pyobj`` to `self._py_buffer`,
      sets the `self._py_buffer_acquired` flag to `True`, and
      writes `self._py_buffer.buf` to the data pointer `self._ptr`.

    * `hip._util.types.Pointer`:

      Takes the pointer address ``pyobj._ptr`` and writes it to ``self._ptr``.
      No ownership is transferred.

    Type checks are performed in the above order.

    C Attributes:
        _ptr (C type ``void *``, protected):
            Stores a pointer to the data of the original Python object.
        _is_ptr_owner (C type ``bint``, protected):
            If this wrapper is the owner of the underlying data.
        _py_buffer (C type ``Py_buffer`, protected):
            Stores a pointer to the data of the original Python object.
        _py_buffer_acquired (C type ``bint``, protected):
            Stores a pointer to the data of the original Python object.
    """
    # C members declared in pxd file

    def __cinit__(self):
        self._ptr = NULL
        self._is_ptr_owner = False
        self._py_buffer_acquired = False

    cdef chip.hipArrayMapInfo* getElementPtr(self):
        return <chip.hipArrayMapInfo*>self._ptr

    @staticmethod
    cdef hipArrayMapInfo fromPtr(void* ptr, bint owner=False):
        """Factory function to create ``hipArrayMapInfo`` objects from
        given ``chip.hipArrayMapInfo`` pointer.

        Setting ``owner`` flag to ``True`` causes
        the extension type to free the structure pointed to by ``ptr``
        when the wrapper object is deallocated.
        """
        # Fast call to __new__() that bypasses the __init__() constructor.
        cdef hipArrayMapInfo wrapper = hipArrayMapInfo.__new__(hipArrayMapInfo)
        wrapper._ptr = ptr
        wrapper._is_ptr_owner = owner
        return wrapper

    @staticmethod
    def fromObj(pyobj):
        """Creates a hipArrayMapInfo from a Python object.

        Derives a hipArrayMapInfo from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``hipArrayMapInfo`` reference, this method
        returns it directly. No new ``hipArrayMapInfo`` is created in this case.
        """
        return hipArrayMapInfo.fromPyobj(pyobj)

    @staticmethod
    cdef hipArrayMapInfo fromPyobj(object pyobj):
        """Creates a hipArrayMapInfo from a Python object.

        Derives a hipArrayMapInfo from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``hipArrayMapInfo`` reference, this method
        returns it directly. No new ``hipArrayMapInfo`` is created in this case.

        Args:
            pyobj (object): Must be either `None`; a `hip._util.types.Pointer`; a simple, contiguous buffer according to the buffer protocol;
                            or of type `hipArrayMapInfo`; `int`; or `ctypes.c_void_p`.

        Note:
            This routine does not perform a copy but returns the original ``pyobj``
            if ``pyobj`` is an instance of hipArrayMapInfo!
        """
        cdef hipArrayMapInfo wrapper

        if isinstance(pyobj,hipArrayMapInfo):
            return pyobj
        else:
            wrapper = hipArrayMapInfo.__new__(hipArrayMapInfo)
            wrapper.init_from_pyobj(pyobj)
            return wrapper

    def __dealloc__(self):
        # Release the buffer handle
        if self._py_buffer_acquired is True:
            cpython.buffer.PyBuffer_Release(&self._py_buffer)
        # De-allocate if not null and flag is set
        if self._ptr is not NULL and self._is_ptr_owner is True:
            stdlib.free(self._ptr)
            self._ptr = NULL

    @staticmethod
    cdef __allocate(void** ptr):
        ptr[0] = stdlib.malloc(sizeof(chip.hipArrayMapInfo))
        string.memset(<void*>ptr[0], 0, sizeof(chip.hipArrayMapInfo))

        if ptr[0] is NULL:
            raise MemoryError

    @staticmethod
    cdef hipArrayMapInfo new():
        """Factory function to create hipArrayMapInfo objects with
        newly allocated chip.hipArrayMapInfo"""
        cdef void* ptr
        hipArrayMapInfo.__allocate(&ptr)
        return hipArrayMapInfo.fromPtr(ptr, owner=True)

    @staticmethod
    cdef hipArrayMapInfo fromValue(chip.hipArrayMapInfo other):
        """Allocate new C type and copy from ``other``.
        """
        wrapper = hipArrayMapInfo.new()
        string.memcpy(wrapper._ptr, &other, sizeof(chip.hipArrayMapInfo))
        return wrapper

    def c_sizeof(self):
        """Returns the size of the underlying C type in bytes.
        Note:
            Implemented as function to not collide with
            autogenerated property names.
        """
        return sizeof(chip.hipArrayMapInfo)

    def __int__(self):
        """Returns the data's address as long integer.
        """
        return cpython.long.PyLong_FromVoidPtr(self._ptr)

    def __repr__(self):
        return f"<hipArrayMapInfo object, ptr: {int(self)}>"

    def as_c_void_p(self):
        """Returns the data's address as `ctypes.c_void_p`
        Note:
            Implemented as function to not collide with
            autogenerated property names.
        """
        return ctypes.c_void_p(int(self))

    def __init__(self,*args,**kwargs):
        """Constructor type hipArrayMapInfo.

        Constructor for type hipArrayMapInfo.

        Args:
            *args:
                Positional arguments. Initialize all or a subset of the member variables
                according to their order of declaration.
            **kwargs:
                Can be used to initialize member variables at construction,
                Just pass an argument expression of the form <member>=<value>
                per member that you want to initialize.
        """
        hipArrayMapInfo.__allocate(&self._ptr)
        self._is_ptr_owner = True
        attribs = self.PROPERTIES()
        used_attribs = set()
        if len(args) > len(attribs):
            raise ValueError("More positional arguments specified than this type has properties.")
        for i,v in enumerate(args):
            setattr(self,attribs[i],v)
            used_attribs.add(attribs[i])
        valid_names = ", ".join(["'"+p+"'" for p in attribs])
        for k,v in kwargs.items():
            if k in used_attribs:
                raise KeyError(f"argument '{k}' has already been specified as positional argument.")
            elif k not in attribs:
                raise KeyError(f"'{k}' is no valid property name. Valid names: {valid_names}")
            setattr(self,k,v)
    def get_resourceType(self, i):
        """Get value of ``resourceType`` of ``(<chip.hipArrayMapInfo*>self._ptr)[i]``.
        """
        return hipResourceType((<chip.hipArrayMapInfo*>self._ptr)[i].resourceType)
    def set_resourceType(self, i, value):
        """Set value ``resourceType`` of ``(<chip.hipArrayMapInfo*>self._ptr)[i]``.
        """
        if not isinstance(value, hipResourceType):
            raise TypeError("'value' must be of type 'hipResourceType'")
        (<chip.hipArrayMapInfo*>self._ptr)[i].resourceType = value.value
    @property
    def resourceType(self):
        """Resource type"""
        return self.get_resourceType(0)
    @resourceType.setter
    def resourceType(self, value):
        self.set_resourceType(0,value)

    def get_resource(self, i):
        """Get value of ``resource`` of ``(<chip.hipArrayMapInfo*>self._ptr)[i]``.
        """
        return hipArrayMapInfo_union_0.fromPtr(&(<chip.hipArrayMapInfo*>self._ptr)[i].resource)
    @property
    def resource(self):
        """(undocumented)"""
        return self.get_resource(0)

    def get_subresourceType(self, i):
        """Get value of ``subresourceType`` of ``(<chip.hipArrayMapInfo*>self._ptr)[i]``.
        """
        return hipArraySparseSubresourceType((<chip.hipArrayMapInfo*>self._ptr)[i].subresourceType)
    def set_subresourceType(self, i, value):
        """Set value ``subresourceType`` of ``(<chip.hipArrayMapInfo*>self._ptr)[i]``.
        """
        if not isinstance(value, hipArraySparseSubresourceType):
            raise TypeError("'value' must be of type 'hipArraySparseSubresourceType'")
        (<chip.hipArrayMapInfo*>self._ptr)[i].subresourceType = value.value
    @property
    def subresourceType(self):
        """Sparse subresource type"""
        return self.get_subresourceType(0)
    @subresourceType.setter
    def subresourceType(self, value):
        self.set_subresourceType(0,value)

    def get_subresource(self, i):
        """Get value of ``subresource`` of ``(<chip.hipArrayMapInfo*>self._ptr)[i]``.
        """
        return hipArrayMapInfo_union_1.fromPtr(&(<chip.hipArrayMapInfo*>self._ptr)[i].subresource)
    @property
    def subresource(self):
        """(undocumented)"""
        return self.get_subresource(0)

    def get_memOperationType(self, i):
        """Get value of ``memOperationType`` of ``(<chip.hipArrayMapInfo*>self._ptr)[i]``.
        """
        return hipMemOperationType((<chip.hipArrayMapInfo*>self._ptr)[i].memOperationType)
    def set_memOperationType(self, i, value):
        """Set value ``memOperationType`` of ``(<chip.hipArrayMapInfo*>self._ptr)[i]``.
        """
        if not isinstance(value, hipMemOperationType):
            raise TypeError("'value' must be of type 'hipMemOperationType'")
        (<chip.hipArrayMapInfo*>self._ptr)[i].memOperationType = value.value
    @property
    def memOperationType(self):
        """Memory operation type"""
        return self.get_memOperationType(0)
    @memOperationType.setter
    def memOperationType(self, value):
        self.set_memOperationType(0,value)

    def get_memHandleType(self, i):
        """Get value of ``memHandleType`` of ``(<chip.hipArrayMapInfo*>self._ptr)[i]``.
        """
        return hipMemHandleType((<chip.hipArrayMapInfo*>self._ptr)[i].memHandleType)
    def set_memHandleType(self, i, value):
        """Set value ``memHandleType`` of ``(<chip.hipArrayMapInfo*>self._ptr)[i]``.
        """
        if not isinstance(value, hipMemHandleType):
            raise TypeError("'value' must be of type 'hipMemHandleType'")
        (<chip.hipArrayMapInfo*>self._ptr)[i].memHandleType = value.value
    @property
    def memHandleType(self):
        """Memory handle type"""
        return self.get_memHandleType(0)
    @memHandleType.setter
    def memHandleType(self, value):
        self.set_memHandleType(0,value)

    def get_memHandle(self, i):
        """Get value of ``memHandle`` of ``(<chip.hipArrayMapInfo*>self._ptr)[i]``.
        """
        return hipArrayMapInfo_union_2.fromPtr(&(<chip.hipArrayMapInfo*>self._ptr)[i].memHandle)
    @property
    def memHandle(self):
        """(undocumented)"""
        return self.get_memHandle(0)

    def get_offset(self, i):
        """Get value ``offset`` of ``(<chip.hipArrayMapInfo*>self._ptr)[i]``.
        """
        return (<chip.hipArrayMapInfo*>self._ptr)[i].offset
    def set_offset(self, i, unsigned long long value):
        """Set value ``offset`` of ``(<chip.hipArrayMapInfo*>self._ptr)[i]``.
        """
        (<chip.hipArrayMapInfo*>self._ptr)[i].offset = value
    @property
    def offset(self):
        """Offset within the memory"""
        return self.get_offset(0)
    @offset.setter
    def offset(self, unsigned long long value):
        self.set_offset(0,value)

    def get_deviceBitMask(self, i):
        """Get value ``deviceBitMask`` of ``(<chip.hipArrayMapInfo*>self._ptr)[i]``.
        """
        return (<chip.hipArrayMapInfo*>self._ptr)[i].deviceBitMask
    def set_deviceBitMask(self, i, unsigned int value):
        """Set value ``deviceBitMask`` of ``(<chip.hipArrayMapInfo*>self._ptr)[i]``.
        """
        (<chip.hipArrayMapInfo*>self._ptr)[i].deviceBitMask = value
    @property
    def deviceBitMask(self):
        """Device ordinal bit mask"""
        return self.get_deviceBitMask(0)
    @deviceBitMask.setter
    def deviceBitMask(self, unsigned int value):
        self.set_deviceBitMask(0,value)

    def get_flags(self, i):
        """Get value ``flags`` of ``(<chip.hipArrayMapInfo*>self._ptr)[i]``.
        """
        return (<chip.hipArrayMapInfo*>self._ptr)[i].flags
    def set_flags(self, i, unsigned int value):
        """Set value ``flags`` of ``(<chip.hipArrayMapInfo*>self._ptr)[i]``.
        """
        (<chip.hipArrayMapInfo*>self._ptr)[i].flags = value
    @property
    def flags(self):
        """flags for future use, must be zero now."""
        return self.get_flags(0)
    @flags.setter
    def flags(self, unsigned int value):
        self.set_flags(0,value)

    def get_reserved(self, i):
        """Get value of ``reserved`` of ``(<chip.hipArrayMapInfo*>self._ptr)[i]``.
        """
        return (<chip.hipArrayMapInfo*>self._ptr)[i].reserved
    # TODO add setters
    #def set_reserved(self, i, unsigned int[2] value):
    #    """Set value ``reserved`` of ``(<chip.hipArrayMapInfo*>self._ptr)[i]``.
    #    """
    #    (<chip.hipArrayMapInfo*>self._ptr)[i].reserved = value
    @property
    def reserved(self):
        """Reserved for future use, must be zero now."""
        return self.get_reserved(0)
    # TODO add setters
    #@reserved.setter
    #def reserved(self, unsigned int[2] value):
    #    self.set_reserved(0,value)

    @staticmethod
    def PROPERTIES():
        return ["resourceType","resource","subresourceType","subresource","memOperationType","memHandleType","memHandle","offset","deviceBitMask","flags","reserved"]

    def __contains__(self,item):
        properties = self.PROPERTIES()
        return item in properties

    def __getitem__(self,item):
        properties = self.PROPERTIES()
        if isinstance(item,int):
            if item < 0 or item >= len(properties):
                raise IndexError()
            return getattr(self,properties[item])
        raise ValueError("'item' type must be 'int'")


cdef class hipMemcpyNodeParams(hip._util.types.Pointer):
    """Python wrapper for cdef class chip.hipMemcpyNodeParams.

    Python wrapper for cdef class chip.hipMemcpyNodeParams.

    If this type is initialized via its `__init__` method, it allocates a
    member of the underlying C type and destroys it again if the wrapper
    type is deallocated.

    This type also serves as adapter when appearing as argument type in a
    function signature. In this case, the type can further be initialized
    from a number of Python objects:

    * `None`:

      This will set the ``self._ptr`` attribute to ``NULL``.

    * `int`:

      Interprets the integer value as pointer address and writes it to ``self._ptr``.
      No ownership is transferred.

    * `ctypes.c_void_p`:

      Takes the pointer address ``pyobj.value`` and writes it to ``self._ptr``.
      No ownership is transferred.

    * `object` that implements the `CUDA Array Interface <https://numba.readthedocs.io/en/stable/cuda/cuda_array_interface.html>`_ protocol:

      Takes the integer-valued pointer address, i.e. the first entry of the `data` tuple
      from `pyobj`'s member ``__cuda_array_interface__``  and writes it to ``self._ptr``.

    * `object` that implements the Python buffer protocol:

      If the object represents a simple contiguous array,
      writes the `Py_buffer` associated with ``pyobj`` to `self._py_buffer`,
      sets the `self._py_buffer_acquired` flag to `True`, and
      writes `self._py_buffer.buf` to the data pointer `self._ptr`.

    * `hip._util.types.Pointer`:

      Takes the pointer address ``pyobj._ptr`` and writes it to ``self._ptr``.
      No ownership is transferred.

    Type checks are performed in the above order.

    C Attributes:
        _ptr (C type ``void *``, protected):
            Stores a pointer to the data of the original Python object.
        _is_ptr_owner (C type ``bint``, protected):
            If this wrapper is the owner of the underlying data.
        _py_buffer (C type ``Py_buffer`, protected):
            Stores a pointer to the data of the original Python object.
        _py_buffer_acquired (C type ``bint``, protected):
            Stores a pointer to the data of the original Python object.
    """
    # C members declared in pxd file

    def __cinit__(self):
        self._ptr = NULL
        self._is_ptr_owner = False
        self._py_buffer_acquired = False

    cdef chip.hipMemcpyNodeParams* getElementPtr(self):
        return <chip.hipMemcpyNodeParams*>self._ptr

    @staticmethod
    cdef hipMemcpyNodeParams fromPtr(void* ptr, bint owner=False):
        """Factory function to create ``hipMemcpyNodeParams`` objects from
        given ``chip.hipMemcpyNodeParams`` pointer.

        Setting ``owner`` flag to ``True`` causes
        the extension type to free the structure pointed to by ``ptr``
        when the wrapper object is deallocated.
        """
        # Fast call to __new__() that bypasses the __init__() constructor.
        cdef hipMemcpyNodeParams wrapper = hipMemcpyNodeParams.__new__(hipMemcpyNodeParams)
        wrapper._ptr = ptr
        wrapper._is_ptr_owner = owner
        return wrapper

    @staticmethod
    def fromObj(pyobj):
        """Creates a hipMemcpyNodeParams from a Python object.

        Derives a hipMemcpyNodeParams from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``hipMemcpyNodeParams`` reference, this method
        returns it directly. No new ``hipMemcpyNodeParams`` is created in this case.
        """
        return hipMemcpyNodeParams.fromPyobj(pyobj)

    @staticmethod
    cdef hipMemcpyNodeParams fromPyobj(object pyobj):
        """Creates a hipMemcpyNodeParams from a Python object.

        Derives a hipMemcpyNodeParams from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``hipMemcpyNodeParams`` reference, this method
        returns it directly. No new ``hipMemcpyNodeParams`` is created in this case.

        Args:
            pyobj (object): Must be either `None`; a `hip._util.types.Pointer`; a simple, contiguous buffer according to the buffer protocol;
                            or of type `hipMemcpyNodeParams`; `int`; or `ctypes.c_void_p`.

        Note:
            This routine does not perform a copy but returns the original ``pyobj``
            if ``pyobj`` is an instance of hipMemcpyNodeParams!
        """
        cdef hipMemcpyNodeParams wrapper

        if isinstance(pyobj,hipMemcpyNodeParams):
            return pyobj
        else:
            wrapper = hipMemcpyNodeParams.__new__(hipMemcpyNodeParams)
            wrapper.init_from_pyobj(pyobj)
            return wrapper

    def __dealloc__(self):
        # Release the buffer handle
        if self._py_buffer_acquired is True:
            cpython.buffer.PyBuffer_Release(&self._py_buffer)
        # De-allocate if not null and flag is set
        if self._ptr is not NULL and self._is_ptr_owner is True:
            stdlib.free(self._ptr)
            self._ptr = NULL

    @staticmethod
    cdef __allocate(void** ptr):
        ptr[0] = stdlib.malloc(sizeof(chip.hipMemcpyNodeParams))
        string.memset(<void*>ptr[0], 0, sizeof(chip.hipMemcpyNodeParams))

        if ptr[0] is NULL:
            raise MemoryError

    @staticmethod
    cdef hipMemcpyNodeParams new():
        """Factory function to create hipMemcpyNodeParams objects with
        newly allocated chip.hipMemcpyNodeParams"""
        cdef void* ptr
        hipMemcpyNodeParams.__allocate(&ptr)
        return hipMemcpyNodeParams.fromPtr(ptr, owner=True)

    @staticmethod
    cdef hipMemcpyNodeParams fromValue(chip.hipMemcpyNodeParams other):
        """Allocate new C type and copy from ``other``.
        """
        wrapper = hipMemcpyNodeParams.new()
        string.memcpy(wrapper._ptr, &other, sizeof(chip.hipMemcpyNodeParams))
        return wrapper

    def c_sizeof(self):
        """Returns the size of the underlying C type in bytes.
        Note:
            Implemented as function to not collide with
            autogenerated property names.
        """
        return sizeof(chip.hipMemcpyNodeParams)

    def __int__(self):
        """Returns the data's address as long integer.
        """
        return cpython.long.PyLong_FromVoidPtr(self._ptr)

    def __repr__(self):
        return f"<hipMemcpyNodeParams object, ptr: {int(self)}>"

    def as_c_void_p(self):
        """Returns the data's address as `ctypes.c_void_p`
        Note:
            Implemented as function to not collide with
            autogenerated property names.
        """
        return ctypes.c_void_p(int(self))

    def __init__(self,*args,**kwargs):
        """Constructor type hipMemcpyNodeParams.

        Constructor for type hipMemcpyNodeParams.

        Args:
            *args:
                Positional arguments. Initialize all or a subset of the member variables
                according to their order of declaration.
            **kwargs:
                Can be used to initialize member variables at construction,
                Just pass an argument expression of the form <member>=<value>
                per member that you want to initialize.
        """
        hipMemcpyNodeParams.__allocate(&self._ptr)
        self._is_ptr_owner = True
        attribs = self.PROPERTIES()
        used_attribs = set()
        if len(args) > len(attribs):
            raise ValueError("More positional arguments specified than this type has properties.")
        for i,v in enumerate(args):
            setattr(self,attribs[i],v)
            used_attribs.add(attribs[i])
        valid_names = ", ".join(["'"+p+"'" for p in attribs])
        for k,v in kwargs.items():
            if k in used_attribs:
                raise KeyError(f"argument '{k}' has already been specified as positional argument.")
            elif k not in attribs:
                raise KeyError(f"'{k}' is no valid property name. Valid names: {valid_names}")
            setattr(self,k,v)
    def get_flags(self, i):
        """Get value ``flags`` of ``(<chip.hipMemcpyNodeParams*>self._ptr)[i]``.
        """
        return (<chip.hipMemcpyNodeParams*>self._ptr)[i].flags
    def set_flags(self, i, int value):
        """Set value ``flags`` of ``(<chip.hipMemcpyNodeParams*>self._ptr)[i]``.
        """
        (<chip.hipMemcpyNodeParams*>self._ptr)[i].flags = value
    @property
    def flags(self):
        """Must be zero."""
        return self.get_flags(0)
    @flags.setter
    def flags(self, int value):
        self.set_flags(0,value)

    def get_reserved(self, i):
        """Get value of ``reserved`` of ``(<chip.hipMemcpyNodeParams*>self._ptr)[i]``.
        """
        return (<chip.hipMemcpyNodeParams*>self._ptr)[i].reserved
    # TODO add setters
    #def set_reserved(self, i, int[3] value):
    #    """Set value ``reserved`` of ``(<chip.hipMemcpyNodeParams*>self._ptr)[i]``.
    #    """
    #    (<chip.hipMemcpyNodeParams*>self._ptr)[i].reserved = value
    @property
    def reserved(self):
        """Must be zero."""
        return self.get_reserved(0)
    # TODO add setters
    #@reserved.setter
    #def reserved(self, int[3] value):
    #    self.set_reserved(0,value)

    def get_copyParams(self, i):
        """Get value of ``copyParams`` of ``(<chip.hipMemcpyNodeParams*>self._ptr)[i]``.
        """
        return hipMemcpy3DParms.fromPtr(&(<chip.hipMemcpyNodeParams*>self._ptr)[i].copyParams)
    @property
    def copyParams(self):
        """Params set for the memory copy."""
        return self.get_copyParams(0)

    @staticmethod
    def PROPERTIES():
        return ["flags","reserved","copyParams"]

    def __contains__(self,item):
        properties = self.PROPERTIES()
        return item in properties

    def __getitem__(self,item):
        properties = self.PROPERTIES()
        if isinstance(item,int):
            if item < 0 or item >= len(properties):
                raise IndexError()
            return getattr(self,properties[item])
        raise ValueError("'item' type must be 'int'")


cdef class hipChildGraphNodeParams(hip._util.types.Pointer):
    """Python wrapper for cdef class chip.hipChildGraphNodeParams.

    Python wrapper for cdef class chip.hipChildGraphNodeParams.

    If this type is initialized via its `__init__` method, it allocates a
    member of the underlying C type and destroys it again if the wrapper
    type is deallocated.

    This type also serves as adapter when appearing as argument type in a
    function signature. In this case, the type can further be initialized
    from a number of Python objects:

    * `None`:

      This will set the ``self._ptr`` attribute to ``NULL``.

    * `int`:

      Interprets the integer value as pointer address and writes it to ``self._ptr``.
      No ownership is transferred.

    * `ctypes.c_void_p`:

      Takes the pointer address ``pyobj.value`` and writes it to ``self._ptr``.
      No ownership is transferred.

    * `object` that implements the `CUDA Array Interface <https://numba.readthedocs.io/en/stable/cuda/cuda_array_interface.html>`_ protocol:

      Takes the integer-valued pointer address, i.e. the first entry of the `data` tuple
      from `pyobj`'s member ``__cuda_array_interface__``  and writes it to ``self._ptr``.

    * `object` that implements the Python buffer protocol:

      If the object represents a simple contiguous array,
      writes the `Py_buffer` associated with ``pyobj`` to `self._py_buffer`,
      sets the `self._py_buffer_acquired` flag to `True`, and
      writes `self._py_buffer.buf` to the data pointer `self._ptr`.

    * `hip._util.types.Pointer`:

      Takes the pointer address ``pyobj._ptr`` and writes it to ``self._ptr``.
      No ownership is transferred.

    Type checks are performed in the above order.

    C Attributes:
        _ptr (C type ``void *``, protected):
            Stores a pointer to the data of the original Python object.
        _is_ptr_owner (C type ``bint``, protected):
            If this wrapper is the owner of the underlying data.
        _py_buffer (C type ``Py_buffer`, protected):
            Stores a pointer to the data of the original Python object.
        _py_buffer_acquired (C type ``bint``, protected):
            Stores a pointer to the data of the original Python object.
    """
    # C members declared in pxd file

    def __cinit__(self):
        self._ptr = NULL
        self._is_ptr_owner = False
        self._py_buffer_acquired = False

    cdef chip.hipChildGraphNodeParams* getElementPtr(self):
        return <chip.hipChildGraphNodeParams*>self._ptr

    @staticmethod
    cdef hipChildGraphNodeParams fromPtr(void* ptr, bint owner=False):
        """Factory function to create ``hipChildGraphNodeParams`` objects from
        given ``chip.hipChildGraphNodeParams`` pointer.

        Setting ``owner`` flag to ``True`` causes
        the extension type to free the structure pointed to by ``ptr``
        when the wrapper object is deallocated.
        """
        # Fast call to __new__() that bypasses the __init__() constructor.
        cdef hipChildGraphNodeParams wrapper = hipChildGraphNodeParams.__new__(hipChildGraphNodeParams)
        wrapper._ptr = ptr
        wrapper._is_ptr_owner = owner
        return wrapper

    @staticmethod
    def fromObj(pyobj):
        """Creates a hipChildGraphNodeParams from a Python object.

        Derives a hipChildGraphNodeParams from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``hipChildGraphNodeParams`` reference, this method
        returns it directly. No new ``hipChildGraphNodeParams`` is created in this case.
        """
        return hipChildGraphNodeParams.fromPyobj(pyobj)

    @staticmethod
    cdef hipChildGraphNodeParams fromPyobj(object pyobj):
        """Creates a hipChildGraphNodeParams from a Python object.

        Derives a hipChildGraphNodeParams from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``hipChildGraphNodeParams`` reference, this method
        returns it directly. No new ``hipChildGraphNodeParams`` is created in this case.

        Args:
            pyobj (object): Must be either `None`; a `hip._util.types.Pointer`; a simple, contiguous buffer according to the buffer protocol;
                            or of type `hipChildGraphNodeParams`; `int`; or `ctypes.c_void_p`.

        Note:
            This routine does not perform a copy but returns the original ``pyobj``
            if ``pyobj`` is an instance of hipChildGraphNodeParams!
        """
        cdef hipChildGraphNodeParams wrapper

        if isinstance(pyobj,hipChildGraphNodeParams):
            return pyobj
        else:
            wrapper = hipChildGraphNodeParams.__new__(hipChildGraphNodeParams)
            wrapper.init_from_pyobj(pyobj)
            return wrapper

    def __dealloc__(self):
        # Release the buffer handle
        if self._py_buffer_acquired is True:
            cpython.buffer.PyBuffer_Release(&self._py_buffer)
        # De-allocate if not null and flag is set
        if self._ptr is not NULL and self._is_ptr_owner is True:
            stdlib.free(self._ptr)
            self._ptr = NULL

    @staticmethod
    cdef __allocate(void** ptr):
        ptr[0] = stdlib.malloc(sizeof(chip.hipChildGraphNodeParams))
        string.memset(<void*>ptr[0], 0, sizeof(chip.hipChildGraphNodeParams))

        if ptr[0] is NULL:
            raise MemoryError

    @staticmethod
    cdef hipChildGraphNodeParams new():
        """Factory function to create hipChildGraphNodeParams objects with
        newly allocated chip.hipChildGraphNodeParams"""
        cdef void* ptr
        hipChildGraphNodeParams.__allocate(&ptr)
        return hipChildGraphNodeParams.fromPtr(ptr, owner=True)

    @staticmethod
    cdef hipChildGraphNodeParams fromValue(chip.hipChildGraphNodeParams other):
        """Allocate new C type and copy from ``other``.
        """
        wrapper = hipChildGraphNodeParams.new()
        string.memcpy(wrapper._ptr, &other, sizeof(chip.hipChildGraphNodeParams))
        return wrapper

    def c_sizeof(self):
        """Returns the size of the underlying C type in bytes.
        Note:
            Implemented as function to not collide with
            autogenerated property names.
        """
        return sizeof(chip.hipChildGraphNodeParams)

    def __int__(self):
        """Returns the data's address as long integer.
        """
        return cpython.long.PyLong_FromVoidPtr(self._ptr)

    def __repr__(self):
        return f"<hipChildGraphNodeParams object, ptr: {int(self)}>"

    def as_c_void_p(self):
        """Returns the data's address as `ctypes.c_void_p`
        Note:
            Implemented as function to not collide with
            autogenerated property names.
        """
        return ctypes.c_void_p(int(self))

    def __init__(self,**kwargs):
        """Constructor type hipChildGraphNodeParams.

        Constructor for type hipChildGraphNodeParams.

        Args:
            **kwargs:
                Can be used to initialize member variables at construction,
                Just pass an argument expression of the form <member>=<value>
                per member that you want to initialize.
        """
        hipChildGraphNodeParams.__allocate(&self._ptr)
        self._is_ptr_owner = True
        attribs = self.PROPERTIES()
        used_attribs = set()
        valid_names = ", ".join(["'"+p+"'" for p in attribs])
        for k,v in kwargs.items():
            if k in used_attribs:
                raise KeyError(f"argument '{k}' has already been specified as positional argument.")
            elif k not in attribs:
                raise KeyError(f"'{k}' is no valid property name. Valid names: {valid_names}")
            setattr(self,k,v)
    @staticmethod
    def PROPERTIES():
        return []

    def __contains__(self,item):
        properties = self.PROPERTIES()
        return item in properties

    def __getitem__(self,item):
        properties = self.PROPERTIES()
        if isinstance(item,int):
            if item < 0 or item >= len(properties):
                raise IndexError()
            return getattr(self,properties[item])
        raise ValueError("'item' type must be 'int'")


cdef class hipEventWaitNodeParams(hip._util.types.Pointer):
    """Python wrapper for cdef class chip.hipEventWaitNodeParams.

    Python wrapper for cdef class chip.hipEventWaitNodeParams.

    If this type is initialized via its `__init__` method, it allocates a
    member of the underlying C type and destroys it again if the wrapper
    type is deallocated.

    This type also serves as adapter when appearing as argument type in a
    function signature. In this case, the type can further be initialized
    from a number of Python objects:

    * `None`:

      This will set the ``self._ptr`` attribute to ``NULL``.

    * `int`:

      Interprets the integer value as pointer address and writes it to ``self._ptr``.
      No ownership is transferred.

    * `ctypes.c_void_p`:

      Takes the pointer address ``pyobj.value`` and writes it to ``self._ptr``.
      No ownership is transferred.

    * `object` that implements the `CUDA Array Interface <https://numba.readthedocs.io/en/stable/cuda/cuda_array_interface.html>`_ protocol:

      Takes the integer-valued pointer address, i.e. the first entry of the `data` tuple
      from `pyobj`'s member ``__cuda_array_interface__``  and writes it to ``self._ptr``.

    * `object` that implements the Python buffer protocol:

      If the object represents a simple contiguous array,
      writes the `Py_buffer` associated with ``pyobj`` to `self._py_buffer`,
      sets the `self._py_buffer_acquired` flag to `True`, and
      writes `self._py_buffer.buf` to the data pointer `self._ptr`.

    * `hip._util.types.Pointer`:

      Takes the pointer address ``pyobj._ptr`` and writes it to ``self._ptr``.
      No ownership is transferred.

    Type checks are performed in the above order.

    C Attributes:
        _ptr (C type ``void *``, protected):
            Stores a pointer to the data of the original Python object.
        _is_ptr_owner (C type ``bint``, protected):
            If this wrapper is the owner of the underlying data.
        _py_buffer (C type ``Py_buffer`, protected):
            Stores a pointer to the data of the original Python object.
        _py_buffer_acquired (C type ``bint``, protected):
            Stores a pointer to the data of the original Python object.
    """
    # C members declared in pxd file

    def __cinit__(self):
        self._ptr = NULL
        self._is_ptr_owner = False
        self._py_buffer_acquired = False

    cdef chip.hipEventWaitNodeParams* getElementPtr(self):
        return <chip.hipEventWaitNodeParams*>self._ptr

    @staticmethod
    cdef hipEventWaitNodeParams fromPtr(void* ptr, bint owner=False):
        """Factory function to create ``hipEventWaitNodeParams`` objects from
        given ``chip.hipEventWaitNodeParams`` pointer.

        Setting ``owner`` flag to ``True`` causes
        the extension type to free the structure pointed to by ``ptr``
        when the wrapper object is deallocated.
        """
        # Fast call to __new__() that bypasses the __init__() constructor.
        cdef hipEventWaitNodeParams wrapper = hipEventWaitNodeParams.__new__(hipEventWaitNodeParams)
        wrapper._ptr = ptr
        wrapper._is_ptr_owner = owner
        return wrapper

    @staticmethod
    def fromObj(pyobj):
        """Creates a hipEventWaitNodeParams from a Python object.

        Derives a hipEventWaitNodeParams from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``hipEventWaitNodeParams`` reference, this method
        returns it directly. No new ``hipEventWaitNodeParams`` is created in this case.
        """
        return hipEventWaitNodeParams.fromPyobj(pyobj)

    @staticmethod
    cdef hipEventWaitNodeParams fromPyobj(object pyobj):
        """Creates a hipEventWaitNodeParams from a Python object.

        Derives a hipEventWaitNodeParams from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``hipEventWaitNodeParams`` reference, this method
        returns it directly. No new ``hipEventWaitNodeParams`` is created in this case.

        Args:
            pyobj (object): Must be either `None`; a `hip._util.types.Pointer`; a simple, contiguous buffer according to the buffer protocol;
                            or of type `hipEventWaitNodeParams`; `int`; or `ctypes.c_void_p`.

        Note:
            This routine does not perform a copy but returns the original ``pyobj``
            if ``pyobj`` is an instance of hipEventWaitNodeParams!
        """
        cdef hipEventWaitNodeParams wrapper

        if isinstance(pyobj,hipEventWaitNodeParams):
            return pyobj
        else:
            wrapper = hipEventWaitNodeParams.__new__(hipEventWaitNodeParams)
            wrapper.init_from_pyobj(pyobj)
            return wrapper

    def __dealloc__(self):
        # Release the buffer handle
        if self._py_buffer_acquired is True:
            cpython.buffer.PyBuffer_Release(&self._py_buffer)
        # De-allocate if not null and flag is set
        if self._ptr is not NULL and self._is_ptr_owner is True:
            stdlib.free(self._ptr)
            self._ptr = NULL

    @staticmethod
    cdef __allocate(void** ptr):
        ptr[0] = stdlib.malloc(sizeof(chip.hipEventWaitNodeParams))
        string.memset(<void*>ptr[0], 0, sizeof(chip.hipEventWaitNodeParams))

        if ptr[0] is NULL:
            raise MemoryError

    @staticmethod
    cdef hipEventWaitNodeParams new():
        """Factory function to create hipEventWaitNodeParams objects with
        newly allocated chip.hipEventWaitNodeParams"""
        cdef void* ptr
        hipEventWaitNodeParams.__allocate(&ptr)
        return hipEventWaitNodeParams.fromPtr(ptr, owner=True)

    @staticmethod
    cdef hipEventWaitNodeParams fromValue(chip.hipEventWaitNodeParams other):
        """Allocate new C type and copy from ``other``.
        """
        wrapper = hipEventWaitNodeParams.new()
        string.memcpy(wrapper._ptr, &other, sizeof(chip.hipEventWaitNodeParams))
        return wrapper

    def c_sizeof(self):
        """Returns the size of the underlying C type in bytes.
        Note:
            Implemented as function to not collide with
            autogenerated property names.
        """
        return sizeof(chip.hipEventWaitNodeParams)

    def __int__(self):
        """Returns the data's address as long integer.
        """
        return cpython.long.PyLong_FromVoidPtr(self._ptr)

    def __repr__(self):
        return f"<hipEventWaitNodeParams object, ptr: {int(self)}>"

    def as_c_void_p(self):
        """Returns the data's address as `ctypes.c_void_p`
        Note:
            Implemented as function to not collide with
            autogenerated property names.
        """
        return ctypes.c_void_p(int(self))

    def __init__(self,**kwargs):
        """Constructor type hipEventWaitNodeParams.

        Constructor for type hipEventWaitNodeParams.

        Args:
            **kwargs:
                Can be used to initialize member variables at construction,
                Just pass an argument expression of the form <member>=<value>
                per member that you want to initialize.
        """
        hipEventWaitNodeParams.__allocate(&self._ptr)
        self._is_ptr_owner = True
        attribs = self.PROPERTIES()
        used_attribs = set()
        valid_names = ", ".join(["'"+p+"'" for p in attribs])
        for k,v in kwargs.items():
            if k in used_attribs:
                raise KeyError(f"argument '{k}' has already been specified as positional argument.")
            elif k not in attribs:
                raise KeyError(f"'{k}' is no valid property name. Valid names: {valid_names}")
            setattr(self,k,v)
    @staticmethod
    def PROPERTIES():
        return []

    def __contains__(self,item):
        properties = self.PROPERTIES()
        return item in properties

    def __getitem__(self,item):
        properties = self.PROPERTIES()
        if isinstance(item,int):
            if item < 0 or item >= len(properties):
                raise IndexError()
            return getattr(self,properties[item])
        raise ValueError("'item' type must be 'int'")


cdef class hipEventRecordNodeParams(hip._util.types.Pointer):
    """Python wrapper for cdef class chip.hipEventRecordNodeParams.

    Python wrapper for cdef class chip.hipEventRecordNodeParams.

    If this type is initialized via its `__init__` method, it allocates a
    member of the underlying C type and destroys it again if the wrapper
    type is deallocated.

    This type also serves as adapter when appearing as argument type in a
    function signature. In this case, the type can further be initialized
    from a number of Python objects:

    * `None`:

      This will set the ``self._ptr`` attribute to ``NULL``.

    * `int`:

      Interprets the integer value as pointer address and writes it to ``self._ptr``.
      No ownership is transferred.

    * `ctypes.c_void_p`:

      Takes the pointer address ``pyobj.value`` and writes it to ``self._ptr``.
      No ownership is transferred.

    * `object` that implements the `CUDA Array Interface <https://numba.readthedocs.io/en/stable/cuda/cuda_array_interface.html>`_ protocol:

      Takes the integer-valued pointer address, i.e. the first entry of the `data` tuple
      from `pyobj`'s member ``__cuda_array_interface__``  and writes it to ``self._ptr``.

    * `object` that implements the Python buffer protocol:

      If the object represents a simple contiguous array,
      writes the `Py_buffer` associated with ``pyobj`` to `self._py_buffer`,
      sets the `self._py_buffer_acquired` flag to `True`, and
      writes `self._py_buffer.buf` to the data pointer `self._ptr`.

    * `hip._util.types.Pointer`:

      Takes the pointer address ``pyobj._ptr`` and writes it to ``self._ptr``.
      No ownership is transferred.

    Type checks are performed in the above order.

    C Attributes:
        _ptr (C type ``void *``, protected):
            Stores a pointer to the data of the original Python object.
        _is_ptr_owner (C type ``bint``, protected):
            If this wrapper is the owner of the underlying data.
        _py_buffer (C type ``Py_buffer`, protected):
            Stores a pointer to the data of the original Python object.
        _py_buffer_acquired (C type ``bint``, protected):
            Stores a pointer to the data of the original Python object.
    """
    # C members declared in pxd file

    def __cinit__(self):
        self._ptr = NULL
        self._is_ptr_owner = False
        self._py_buffer_acquired = False

    cdef chip.hipEventRecordNodeParams* getElementPtr(self):
        return <chip.hipEventRecordNodeParams*>self._ptr

    @staticmethod
    cdef hipEventRecordNodeParams fromPtr(void* ptr, bint owner=False):
        """Factory function to create ``hipEventRecordNodeParams`` objects from
        given ``chip.hipEventRecordNodeParams`` pointer.

        Setting ``owner`` flag to ``True`` causes
        the extension type to free the structure pointed to by ``ptr``
        when the wrapper object is deallocated.
        """
        # Fast call to __new__() that bypasses the __init__() constructor.
        cdef hipEventRecordNodeParams wrapper = hipEventRecordNodeParams.__new__(hipEventRecordNodeParams)
        wrapper._ptr = ptr
        wrapper._is_ptr_owner = owner
        return wrapper

    @staticmethod
    def fromObj(pyobj):
        """Creates a hipEventRecordNodeParams from a Python object.

        Derives a hipEventRecordNodeParams from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``hipEventRecordNodeParams`` reference, this method
        returns it directly. No new ``hipEventRecordNodeParams`` is created in this case.
        """
        return hipEventRecordNodeParams.fromPyobj(pyobj)

    @staticmethod
    cdef hipEventRecordNodeParams fromPyobj(object pyobj):
        """Creates a hipEventRecordNodeParams from a Python object.

        Derives a hipEventRecordNodeParams from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``hipEventRecordNodeParams`` reference, this method
        returns it directly. No new ``hipEventRecordNodeParams`` is created in this case.

        Args:
            pyobj (object): Must be either `None`; a `hip._util.types.Pointer`; a simple, contiguous buffer according to the buffer protocol;
                            or of type `hipEventRecordNodeParams`; `int`; or `ctypes.c_void_p`.

        Note:
            This routine does not perform a copy but returns the original ``pyobj``
            if ``pyobj`` is an instance of hipEventRecordNodeParams!
        """
        cdef hipEventRecordNodeParams wrapper

        if isinstance(pyobj,hipEventRecordNodeParams):
            return pyobj
        else:
            wrapper = hipEventRecordNodeParams.__new__(hipEventRecordNodeParams)
            wrapper.init_from_pyobj(pyobj)
            return wrapper

    def __dealloc__(self):
        # Release the buffer handle
        if self._py_buffer_acquired is True:
            cpython.buffer.PyBuffer_Release(&self._py_buffer)
        # De-allocate if not null and flag is set
        if self._ptr is not NULL and self._is_ptr_owner is True:
            stdlib.free(self._ptr)
            self._ptr = NULL

    @staticmethod
    cdef __allocate(void** ptr):
        ptr[0] = stdlib.malloc(sizeof(chip.hipEventRecordNodeParams))
        string.memset(<void*>ptr[0], 0, sizeof(chip.hipEventRecordNodeParams))

        if ptr[0] is NULL:
            raise MemoryError

    @staticmethod
    cdef hipEventRecordNodeParams new():
        """Factory function to create hipEventRecordNodeParams objects with
        newly allocated chip.hipEventRecordNodeParams"""
        cdef void* ptr
        hipEventRecordNodeParams.__allocate(&ptr)
        return hipEventRecordNodeParams.fromPtr(ptr, owner=True)

    @staticmethod
    cdef hipEventRecordNodeParams fromValue(chip.hipEventRecordNodeParams other):
        """Allocate new C type and copy from ``other``.
        """
        wrapper = hipEventRecordNodeParams.new()
        string.memcpy(wrapper._ptr, &other, sizeof(chip.hipEventRecordNodeParams))
        return wrapper

    def c_sizeof(self):
        """Returns the size of the underlying C type in bytes.
        Note:
            Implemented as function to not collide with
            autogenerated property names.
        """
        return sizeof(chip.hipEventRecordNodeParams)

    def __int__(self):
        """Returns the data's address as long integer.
        """
        return cpython.long.PyLong_FromVoidPtr(self._ptr)

    def __repr__(self):
        return f"<hipEventRecordNodeParams object, ptr: {int(self)}>"

    def as_c_void_p(self):
        """Returns the data's address as `ctypes.c_void_p`
        Note:
            Implemented as function to not collide with
            autogenerated property names.
        """
        return ctypes.c_void_p(int(self))

    def __init__(self,**kwargs):
        """Constructor type hipEventRecordNodeParams.

        Constructor for type hipEventRecordNodeParams.

        Args:
            **kwargs:
                Can be used to initialize member variables at construction,
                Just pass an argument expression of the form <member>=<value>
                per member that you want to initialize.
        """
        hipEventRecordNodeParams.__allocate(&self._ptr)
        self._is_ptr_owner = True
        attribs = self.PROPERTIES()
        used_attribs = set()
        valid_names = ", ".join(["'"+p+"'" for p in attribs])
        for k,v in kwargs.items():
            if k in used_attribs:
                raise KeyError(f"argument '{k}' has already been specified as positional argument.")
            elif k not in attribs:
                raise KeyError(f"'{k}' is no valid property name. Valid names: {valid_names}")
            setattr(self,k,v)
    @staticmethod
    def PROPERTIES():
        return []

    def __contains__(self,item):
        properties = self.PROPERTIES()
        return item in properties

    def __getitem__(self,item):
        properties = self.PROPERTIES()
        if isinstance(item,int):
            if item < 0 or item >= len(properties):
                raise IndexError()
            return getattr(self,properties[item])
        raise ValueError("'item' type must be 'int'")


cdef class hipMemFreeNodeParams(hip._util.types.Pointer):
    """Python wrapper for cdef class chip.hipMemFreeNodeParams.

    Python wrapper for cdef class chip.hipMemFreeNodeParams.

    If this type is initialized via its `__init__` method, it allocates a
    member of the underlying C type and destroys it again if the wrapper
    type is deallocated.

    This type also serves as adapter when appearing as argument type in a
    function signature. In this case, the type can further be initialized
    from a number of Python objects:

    * `None`:

      This will set the ``self._ptr`` attribute to ``NULL``.

    * `int`:

      Interprets the integer value as pointer address and writes it to ``self._ptr``.
      No ownership is transferred.

    * `ctypes.c_void_p`:

      Takes the pointer address ``pyobj.value`` and writes it to ``self._ptr``.
      No ownership is transferred.

    * `object` that implements the `CUDA Array Interface <https://numba.readthedocs.io/en/stable/cuda/cuda_array_interface.html>`_ protocol:

      Takes the integer-valued pointer address, i.e. the first entry of the `data` tuple
      from `pyobj`'s member ``__cuda_array_interface__``  and writes it to ``self._ptr``.

    * `object` that implements the Python buffer protocol:

      If the object represents a simple contiguous array,
      writes the `Py_buffer` associated with ``pyobj`` to `self._py_buffer`,
      sets the `self._py_buffer_acquired` flag to `True`, and
      writes `self._py_buffer.buf` to the data pointer `self._ptr`.

    * `hip._util.types.Pointer`:

      Takes the pointer address ``pyobj._ptr`` and writes it to ``self._ptr``.
      No ownership is transferred.

    Type checks are performed in the above order.

    C Attributes:
        _ptr (C type ``void *``, protected):
            Stores a pointer to the data of the original Python object.
        _is_ptr_owner (C type ``bint``, protected):
            If this wrapper is the owner of the underlying data.
        _py_buffer (C type ``Py_buffer`, protected):
            Stores a pointer to the data of the original Python object.
        _py_buffer_acquired (C type ``bint``, protected):
            Stores a pointer to the data of the original Python object.
    """
    # C members declared in pxd file

    def __cinit__(self):
        self._ptr = NULL
        self._is_ptr_owner = False
        self._py_buffer_acquired = False

    cdef chip.hipMemFreeNodeParams* getElementPtr(self):
        return <chip.hipMemFreeNodeParams*>self._ptr

    @staticmethod
    cdef hipMemFreeNodeParams fromPtr(void* ptr, bint owner=False):
        """Factory function to create ``hipMemFreeNodeParams`` objects from
        given ``chip.hipMemFreeNodeParams`` pointer.

        Setting ``owner`` flag to ``True`` causes
        the extension type to free the structure pointed to by ``ptr``
        when the wrapper object is deallocated.
        """
        # Fast call to __new__() that bypasses the __init__() constructor.
        cdef hipMemFreeNodeParams wrapper = hipMemFreeNodeParams.__new__(hipMemFreeNodeParams)
        wrapper._ptr = ptr
        wrapper._is_ptr_owner = owner
        return wrapper

    @staticmethod
    def fromObj(pyobj):
        """Creates a hipMemFreeNodeParams from a Python object.

        Derives a hipMemFreeNodeParams from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``hipMemFreeNodeParams`` reference, this method
        returns it directly. No new ``hipMemFreeNodeParams`` is created in this case.
        """
        return hipMemFreeNodeParams.fromPyobj(pyobj)

    @staticmethod
    cdef hipMemFreeNodeParams fromPyobj(object pyobj):
        """Creates a hipMemFreeNodeParams from a Python object.

        Derives a hipMemFreeNodeParams from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``hipMemFreeNodeParams`` reference, this method
        returns it directly. No new ``hipMemFreeNodeParams`` is created in this case.

        Args:
            pyobj (object): Must be either `None`; a `hip._util.types.Pointer`; a simple, contiguous buffer according to the buffer protocol;
                            or of type `hipMemFreeNodeParams`; `int`; or `ctypes.c_void_p`.

        Note:
            This routine does not perform a copy but returns the original ``pyobj``
            if ``pyobj`` is an instance of hipMemFreeNodeParams!
        """
        cdef hipMemFreeNodeParams wrapper

        if isinstance(pyobj,hipMemFreeNodeParams):
            return pyobj
        else:
            wrapper = hipMemFreeNodeParams.__new__(hipMemFreeNodeParams)
            wrapper.init_from_pyobj(pyobj)
            return wrapper

    def __dealloc__(self):
        # Release the buffer handle
        if self._py_buffer_acquired is True:
            cpython.buffer.PyBuffer_Release(&self._py_buffer)
        # De-allocate if not null and flag is set
        if self._ptr is not NULL and self._is_ptr_owner is True:
            stdlib.free(self._ptr)
            self._ptr = NULL

    @staticmethod
    cdef __allocate(void** ptr):
        ptr[0] = stdlib.malloc(sizeof(chip.hipMemFreeNodeParams))
        string.memset(<void*>ptr[0], 0, sizeof(chip.hipMemFreeNodeParams))

        if ptr[0] is NULL:
            raise MemoryError

    @staticmethod
    cdef hipMemFreeNodeParams new():
        """Factory function to create hipMemFreeNodeParams objects with
        newly allocated chip.hipMemFreeNodeParams"""
        cdef void* ptr
        hipMemFreeNodeParams.__allocate(&ptr)
        return hipMemFreeNodeParams.fromPtr(ptr, owner=True)

    @staticmethod
    cdef hipMemFreeNodeParams fromValue(chip.hipMemFreeNodeParams other):
        """Allocate new C type and copy from ``other``.
        """
        wrapper = hipMemFreeNodeParams.new()
        string.memcpy(wrapper._ptr, &other, sizeof(chip.hipMemFreeNodeParams))
        return wrapper

    def c_sizeof(self):
        """Returns the size of the underlying C type in bytes.
        Note:
            Implemented as function to not collide with
            autogenerated property names.
        """
        return sizeof(chip.hipMemFreeNodeParams)

    def __int__(self):
        """Returns the data's address as long integer.
        """
        return cpython.long.PyLong_FromVoidPtr(self._ptr)

    def __repr__(self):
        return f"<hipMemFreeNodeParams object, ptr: {int(self)}>"

    def as_c_void_p(self):
        """Returns the data's address as `ctypes.c_void_p`
        Note:
            Implemented as function to not collide with
            autogenerated property names.
        """
        return ctypes.c_void_p(int(self))

    def __init__(self,*args,**kwargs):
        """Constructor type hipMemFreeNodeParams.

        Constructor for type hipMemFreeNodeParams.

        Args:
            *args:
                Positional arguments. Initialize all or a subset of the member variables
                according to their order of declaration.
            **kwargs:
                Can be used to initialize member variables at construction,
                Just pass an argument expression of the form <member>=<value>
                per member that you want to initialize.
        """
        hipMemFreeNodeParams.__allocate(&self._ptr)
        self._is_ptr_owner = True
        attribs = self.PROPERTIES()
        used_attribs = set()
        if len(args) > len(attribs):
            raise ValueError("More positional arguments specified than this type has properties.")
        for i,v in enumerate(args):
            setattr(self,attribs[i],v)
            used_attribs.add(attribs[i])
        valid_names = ", ".join(["'"+p+"'" for p in attribs])
        for k,v in kwargs.items():
            if k in used_attribs:
                raise KeyError(f"argument '{k}' has already been specified as positional argument.")
            elif k not in attribs:
                raise KeyError(f"'{k}' is no valid property name. Valid names: {valid_names}")
            setattr(self,k,v)
    def get_dptr(self, i):
        """Get value ``dptr`` of ``(<chip.hipMemFreeNodeParams*>self._ptr)[i]``.
        """
        return hip._util.types.Pointer.fromPtr((<chip.hipMemFreeNodeParams*>self._ptr)[i].dptr)
    def set_dptr(self, i, object value):
        """Set value ``dptr`` of ``(<chip.hipMemFreeNodeParams*>self._ptr)[i]``.

        Note:
            This can be dangerous if the pointer is from a python object
            that is later on garbage collected.
        """
        (<chip.hipMemFreeNodeParams*>self._ptr)[i].dptr = <void *>cpython.long.PyLong_AsVoidPtr(int(hip._util.types.Pointer.fromPyobj(value)))
    @property
    def dptr(self):
        """the pointer to be freed
        Note:
            Setting this dptr can be dangerous if the underlying pointer is from a python object that
            is later on garbage collected.
        """
        return self.get_dptr(0)
    @dptr.setter
    def dptr(self, object value):
        self.set_dptr(0,value)

    @staticmethod
    def PROPERTIES():
        return ["dptr"]

    def __contains__(self,item):
        properties = self.PROPERTIES()
        return item in properties

    def __getitem__(self,item):
        properties = self.PROPERTIES()
        if isinstance(item,int):
            if item < 0 or item >= len(properties):
                raise IndexError()
            return getattr(self,properties[item])
        raise ValueError("'item' type must be 'int'")


cdef class hipGraphNodeParams_union_0(hip._util.types.Pointer):
    """Python wrapper for cdef class chip.hipGraphNodeParams_union_0.

    Python wrapper for cdef class chip.hipGraphNodeParams_union_0.

    If this type is initialized via its `__init__` method, it allocates a
    member of the underlying C type and destroys it again if the wrapper
    type is deallocated.

    This type also serves as adapter when appearing as argument type in a
    function signature. In this case, the type can further be initialized
    from a number of Python objects:

    * `None`:

      This will set the ``self._ptr`` attribute to ``NULL``.

    * `int`:

      Interprets the integer value as pointer address and writes it to ``self._ptr``.
      No ownership is transferred.

    * `ctypes.c_void_p`:

      Takes the pointer address ``pyobj.value`` and writes it to ``self._ptr``.
      No ownership is transferred.

    * `object` that implements the `CUDA Array Interface <https://numba.readthedocs.io/en/stable/cuda/cuda_array_interface.html>`_ protocol:

      Takes the integer-valued pointer address, i.e. the first entry of the `data` tuple
      from `pyobj`'s member ``__cuda_array_interface__``  and writes it to ``self._ptr``.

    * `object` that implements the Python buffer protocol:

      If the object represents a simple contiguous array,
      writes the `Py_buffer` associated with ``pyobj`` to `self._py_buffer`,
      sets the `self._py_buffer_acquired` flag to `True`, and
      writes `self._py_buffer.buf` to the data pointer `self._ptr`.

    * `hip._util.types.Pointer`:

      Takes the pointer address ``pyobj._ptr`` and writes it to ``self._ptr``.
      No ownership is transferred.

    Type checks are performed in the above order.

    C Attributes:
        _ptr (C type ``void *``, protected):
            Stores a pointer to the data of the original Python object.
        _is_ptr_owner (C type ``bint``, protected):
            If this wrapper is the owner of the underlying data.
        _py_buffer (C type ``Py_buffer`, protected):
            Stores a pointer to the data of the original Python object.
        _py_buffer_acquired (C type ``bint``, protected):
            Stores a pointer to the data of the original Python object.
    """
    # C members declared in pxd file

    def __cinit__(self):
        self._ptr = NULL
        self._is_ptr_owner = False
        self._py_buffer_acquired = False

    cdef chip.hipGraphNodeParams_union_0* getElementPtr(self):
        return <chip.hipGraphNodeParams_union_0*>self._ptr

    @staticmethod
    cdef hipGraphNodeParams_union_0 fromPtr(void* ptr, bint owner=False):
        """Factory function to create ``hipGraphNodeParams_union_0`` objects from
        given ``chip.hipGraphNodeParams_union_0`` pointer.

        Setting ``owner`` flag to ``True`` causes
        the extension type to free the structure pointed to by ``ptr``
        when the wrapper object is deallocated.
        """
        # Fast call to __new__() that bypasses the __init__() constructor.
        cdef hipGraphNodeParams_union_0 wrapper = hipGraphNodeParams_union_0.__new__(hipGraphNodeParams_union_0)
        wrapper._ptr = ptr
        wrapper._is_ptr_owner = owner
        return wrapper

    @staticmethod
    def fromObj(pyobj):
        """Creates a hipGraphNodeParams_union_0 from a Python object.

        Derives a hipGraphNodeParams_union_0 from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``hipGraphNodeParams_union_0`` reference, this method
        returns it directly. No new ``hipGraphNodeParams_union_0`` is created in this case.
        """
        return hipGraphNodeParams_union_0.fromPyobj(pyobj)

    @staticmethod
    cdef hipGraphNodeParams_union_0 fromPyobj(object pyobj):
        """Creates a hipGraphNodeParams_union_0 from a Python object.

        Derives a hipGraphNodeParams_union_0 from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``hipGraphNodeParams_union_0`` reference, this method
        returns it directly. No new ``hipGraphNodeParams_union_0`` is created in this case.

        Args:
            pyobj (object): Must be either `None`; a `hip._util.types.Pointer`; a simple, contiguous buffer according to the buffer protocol;
                            or of type `hipGraphNodeParams_union_0`; `int`; or `ctypes.c_void_p`.

        Note:
            This routine does not perform a copy but returns the original ``pyobj``
            if ``pyobj`` is an instance of hipGraphNodeParams_union_0!
        """
        cdef hipGraphNodeParams_union_0 wrapper

        if isinstance(pyobj,hipGraphNodeParams_union_0):
            return pyobj
        else:
            wrapper = hipGraphNodeParams_union_0.__new__(hipGraphNodeParams_union_0)
            wrapper.init_from_pyobj(pyobj)
            return wrapper

    def __dealloc__(self):
        # Release the buffer handle
        if self._py_buffer_acquired is True:
            cpython.buffer.PyBuffer_Release(&self._py_buffer)
        # De-allocate if not null and flag is set
        if self._ptr is not NULL and self._is_ptr_owner is True:
            stdlib.free(self._ptr)
            self._ptr = NULL

    @staticmethod
    cdef __allocate(void** ptr):
        ptr[0] = stdlib.malloc(sizeof(chip.hipGraphNodeParams_union_0))
        string.memset(<void*>ptr[0], 0, sizeof(chip.hipGraphNodeParams_union_0))

        if ptr[0] is NULL:
            raise MemoryError

    @staticmethod
    cdef hipGraphNodeParams_union_0 new():
        """Factory function to create hipGraphNodeParams_union_0 objects with
        newly allocated chip.hipGraphNodeParams_union_0"""
        cdef void* ptr
        hipGraphNodeParams_union_0.__allocate(&ptr)
        return hipGraphNodeParams_union_0.fromPtr(ptr, owner=True)

    @staticmethod
    cdef hipGraphNodeParams_union_0 fromValue(chip.hipGraphNodeParams_union_0 other):
        """Allocate new C type and copy from ``other``.
        """
        wrapper = hipGraphNodeParams_union_0.new()
        string.memcpy(wrapper._ptr, &other, sizeof(chip.hipGraphNodeParams_union_0))
        return wrapper

    def c_sizeof(self):
        """Returns the size of the underlying C type in bytes.
        Note:
            Implemented as function to not collide with
            autogenerated property names.
        """
        return sizeof(chip.hipGraphNodeParams_union_0)

    def __int__(self):
        """Returns the data's address as long integer.
        """
        return cpython.long.PyLong_FromVoidPtr(self._ptr)

    def __repr__(self):
        return f"<hipGraphNodeParams_union_0 object, ptr: {int(self)}>"

    def as_c_void_p(self):
        """Returns the data's address as `ctypes.c_void_p`
        Note:
            Implemented as function to not collide with
            autogenerated property names.
        """
        return ctypes.c_void_p(int(self))

    def __init__(self,**kwargs):
        """Constructor type hipGraphNodeParams_union_0.

        Constructor for type hipGraphNodeParams_union_0.

        Args:
            **kwargs:
                Can be used to initialize member variables at construction,
                Just pass an argument expression of the form <member>=<value>
                per member that you want to initialize.
        """
        hipGraphNodeParams_union_0.__allocate(&self._ptr)
        self._is_ptr_owner = True
        attribs = self.PROPERTIES()
        used_attribs = set()
        if len(kwargs) > 1:
            raise ValueError("Not more than one attribute might specified for Python types derived from C union types.")
        valid_names = ", ".join(["'"+p+"'" for p in attribs])
        for k,v in kwargs.items():
            if k in used_attribs:
                raise KeyError(f"argument '{k}' has already been specified as positional argument.")
            elif k not in attribs:
                raise KeyError(f"'{k}' is no valid property name. Valid names: {valid_names}")
            setattr(self,k,v)
    def get_reserved1(self, i):
        """Get value of ``reserved1`` of ``(<chip.hipGraphNodeParams_union_0*>self._ptr)[i]``.
        """
        return (<chip.hipGraphNodeParams_union_0*>self._ptr)[i].reserved1
    # TODO add setters
    #def set_reserved1(self, i, long long[29] value):
    #    """Set value ``reserved1`` of ``(<chip.hipGraphNodeParams_union_0*>self._ptr)[i]``.
    #    """
    #    (<chip.hipGraphNodeParams_union_0*>self._ptr)[i].reserved1 = value
    @property
    def reserved1(self):
        """(undocumented)"""
        return self.get_reserved1(0)
    # TODO add setters
    #@reserved1.setter
    #def reserved1(self, long long[29] value):
    #    self.set_reserved1(0,value)

    def get_kernel(self, i):
        """Get value of ``kernel`` of ``(<chip.hipGraphNodeParams_union_0*>self._ptr)[i]``.
        """
        return hipKernelNodeParams.fromPtr(&(<chip.hipGraphNodeParams_union_0*>self._ptr)[i].kernel)
    @property
    def kernel(self):
        """(undocumented)"""
        return self.get_kernel(0)

    def get_memcpy(self, i):
        """Get value of ``memcpy`` of ``(<chip.hipGraphNodeParams_union_0*>self._ptr)[i]``.
        """
        return hipMemcpyNodeParams.fromPtr(&(<chip.hipGraphNodeParams_union_0*>self._ptr)[i].memcpy)
    @property
    def memcpy(self):
        """(undocumented)"""
        return self.get_memcpy(0)

    def get_memset(self, i):
        """Get value of ``memset`` of ``(<chip.hipGraphNodeParams_union_0*>self._ptr)[i]``.
        """
        return hipMemsetParams.fromPtr(&(<chip.hipGraphNodeParams_union_0*>self._ptr)[i].memset)
    @property
    def memset(self):
        """(undocumented)"""
        return self.get_memset(0)

    def get_host(self, i):
        """Get value of ``host`` of ``(<chip.hipGraphNodeParams_union_0*>self._ptr)[i]``.
        """
        return hipHostNodeParams.fromPtr(&(<chip.hipGraphNodeParams_union_0*>self._ptr)[i].host)
    @property
    def host(self):
        """(undocumented)"""
        return self.get_host(0)

    def get_graph(self, i):
        """Get value of ``graph`` of ``(<chip.hipGraphNodeParams_union_0*>self._ptr)[i]``.
        """
        return hipChildGraphNodeParams.fromPtr(&(<chip.hipGraphNodeParams_union_0*>self._ptr)[i].graph)
    @property
    def graph(self):
        """(undocumented)"""
        return self.get_graph(0)

    def get_eventWait(self, i):
        """Get value of ``eventWait`` of ``(<chip.hipGraphNodeParams_union_0*>self._ptr)[i]``.
        """
        return hipEventWaitNodeParams.fromPtr(&(<chip.hipGraphNodeParams_union_0*>self._ptr)[i].eventWait)
    @property
    def eventWait(self):
        """(undocumented)"""
        return self.get_eventWait(0)

    def get_eventRecord(self, i):
        """Get value of ``eventRecord`` of ``(<chip.hipGraphNodeParams_union_0*>self._ptr)[i]``.
        """
        return hipEventRecordNodeParams.fromPtr(&(<chip.hipGraphNodeParams_union_0*>self._ptr)[i].eventRecord)
    @property
    def eventRecord(self):
        """(undocumented)"""
        return self.get_eventRecord(0)

    def get_extSemSignal(self, i):
        """Get value of ``extSemSignal`` of ``(<chip.hipGraphNodeParams_union_0*>self._ptr)[i]``.
        """
        return hipExternalSemaphoreSignalNodeParams.fromPtr(&(<chip.hipGraphNodeParams_union_0*>self._ptr)[i].extSemSignal)
    @property
    def extSemSignal(self):
        """(undocumented)"""
        return self.get_extSemSignal(0)

    def get_extSemWait(self, i):
        """Get value of ``extSemWait`` of ``(<chip.hipGraphNodeParams_union_0*>self._ptr)[i]``.
        """
        return hipExternalSemaphoreWaitNodeParams.fromPtr(&(<chip.hipGraphNodeParams_union_0*>self._ptr)[i].extSemWait)
    @property
    def extSemWait(self):
        """(undocumented)"""
        return self.get_extSemWait(0)

    def get_alloc(self, i):
        """Get value of ``alloc`` of ``(<chip.hipGraphNodeParams_union_0*>self._ptr)[i]``.
        """
        return hipMemAllocNodeParams.fromPtr(&(<chip.hipGraphNodeParams_union_0*>self._ptr)[i].alloc)
    @property
    def alloc(self):
        """(undocumented)"""
        return self.get_alloc(0)

    def get_free(self, i):
        """Get value of ``free`` of ``(<chip.hipGraphNodeParams_union_0*>self._ptr)[i]``.
        """
        return hipMemFreeNodeParams.fromPtr(&(<chip.hipGraphNodeParams_union_0*>self._ptr)[i].free)
    @property
    def free(self):
        """(undocumented)"""
        return self.get_free(0)

    @staticmethod
    def PROPERTIES():
        return ["reserved1","kernel","memcpy","memset","host","graph","eventWait","eventRecord","extSemSignal","extSemWait","alloc","free"]


cdef class hipGraphNodeParams(hip._util.types.Pointer):
    """Python wrapper for cdef class chip.hipGraphNodeParams.

    Python wrapper for cdef class chip.hipGraphNodeParams.

    If this type is initialized via its `__init__` method, it allocates a
    member of the underlying C type and destroys it again if the wrapper
    type is deallocated.

    This type also serves as adapter when appearing as argument type in a
    function signature. In this case, the type can further be initialized
    from a number of Python objects:

    * `None`:

      This will set the ``self._ptr`` attribute to ``NULL``.

    * `int`:

      Interprets the integer value as pointer address and writes it to ``self._ptr``.
      No ownership is transferred.

    * `ctypes.c_void_p`:

      Takes the pointer address ``pyobj.value`` and writes it to ``self._ptr``.
      No ownership is transferred.

    * `object` that implements the `CUDA Array Interface <https://numba.readthedocs.io/en/stable/cuda/cuda_array_interface.html>`_ protocol:

      Takes the integer-valued pointer address, i.e. the first entry of the `data` tuple
      from `pyobj`'s member ``__cuda_array_interface__``  and writes it to ``self._ptr``.

    * `object` that implements the Python buffer protocol:

      If the object represents a simple contiguous array,
      writes the `Py_buffer` associated with ``pyobj`` to `self._py_buffer`,
      sets the `self._py_buffer_acquired` flag to `True`, and
      writes `self._py_buffer.buf` to the data pointer `self._ptr`.

    * `hip._util.types.Pointer`:

      Takes the pointer address ``pyobj._ptr`` and writes it to ``self._ptr``.
      No ownership is transferred.

    Type checks are performed in the above order.

    C Attributes:
        _ptr (C type ``void *``, protected):
            Stores a pointer to the data of the original Python object.
        _is_ptr_owner (C type ``bint``, protected):
            If this wrapper is the owner of the underlying data.
        _py_buffer (C type ``Py_buffer`, protected):
            Stores a pointer to the data of the original Python object.
        _py_buffer_acquired (C type ``bint``, protected):
            Stores a pointer to the data of the original Python object.
    """
    # C members declared in pxd file

    def __cinit__(self):
        self._ptr = NULL
        self._is_ptr_owner = False
        self._py_buffer_acquired = False

    cdef chip.hipGraphNodeParams* getElementPtr(self):
        return <chip.hipGraphNodeParams*>self._ptr

    @staticmethod
    cdef hipGraphNodeParams fromPtr(void* ptr, bint owner=False):
        """Factory function to create ``hipGraphNodeParams`` objects from
        given ``chip.hipGraphNodeParams`` pointer.

        Setting ``owner`` flag to ``True`` causes
        the extension type to free the structure pointed to by ``ptr``
        when the wrapper object is deallocated.
        """
        # Fast call to __new__() that bypasses the __init__() constructor.
        cdef hipGraphNodeParams wrapper = hipGraphNodeParams.__new__(hipGraphNodeParams)
        wrapper._ptr = ptr
        wrapper._is_ptr_owner = owner
        return wrapper

    @staticmethod
    def fromObj(pyobj):
        """Creates a hipGraphNodeParams from a Python object.

        Derives a hipGraphNodeParams from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``hipGraphNodeParams`` reference, this method
        returns it directly. No new ``hipGraphNodeParams`` is created in this case.
        """
        return hipGraphNodeParams.fromPyobj(pyobj)

    @staticmethod
    cdef hipGraphNodeParams fromPyobj(object pyobj):
        """Creates a hipGraphNodeParams from a Python object.

        Derives a hipGraphNodeParams from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``hipGraphNodeParams`` reference, this method
        returns it directly. No new ``hipGraphNodeParams`` is created in this case.

        Args:
            pyobj (object): Must be either `None`; a `hip._util.types.Pointer`; a simple, contiguous buffer according to the buffer protocol;
                            or of type `hipGraphNodeParams`; `int`; or `ctypes.c_void_p`.

        Note:
            This routine does not perform a copy but returns the original ``pyobj``
            if ``pyobj`` is an instance of hipGraphNodeParams!
        """
        cdef hipGraphNodeParams wrapper

        if isinstance(pyobj,hipGraphNodeParams):
            return pyobj
        else:
            wrapper = hipGraphNodeParams.__new__(hipGraphNodeParams)
            wrapper.init_from_pyobj(pyobj)
            return wrapper

    def __dealloc__(self):
        # Release the buffer handle
        if self._py_buffer_acquired is True:
            cpython.buffer.PyBuffer_Release(&self._py_buffer)
        # De-allocate if not null and flag is set
        if self._ptr is not NULL and self._is_ptr_owner is True:
            stdlib.free(self._ptr)
            self._ptr = NULL

    @staticmethod
    cdef __allocate(void** ptr):
        ptr[0] = stdlib.malloc(sizeof(chip.hipGraphNodeParams))
        string.memset(<void*>ptr[0], 0, sizeof(chip.hipGraphNodeParams))

        if ptr[0] is NULL:
            raise MemoryError

    @staticmethod
    cdef hipGraphNodeParams new():
        """Factory function to create hipGraphNodeParams objects with
        newly allocated chip.hipGraphNodeParams"""
        cdef void* ptr
        hipGraphNodeParams.__allocate(&ptr)
        return hipGraphNodeParams.fromPtr(ptr, owner=True)

    @staticmethod
    cdef hipGraphNodeParams fromValue(chip.hipGraphNodeParams other):
        """Allocate new C type and copy from ``other``.
        """
        wrapper = hipGraphNodeParams.new()
        string.memcpy(wrapper._ptr, &other, sizeof(chip.hipGraphNodeParams))
        return wrapper

    def c_sizeof(self):
        """Returns the size of the underlying C type in bytes.
        Note:
            Implemented as function to not collide with
            autogenerated property names.
        """
        return sizeof(chip.hipGraphNodeParams)

    def __int__(self):
        """Returns the data's address as long integer.
        """
        return cpython.long.PyLong_FromVoidPtr(self._ptr)

    def __repr__(self):
        return f"<hipGraphNodeParams object, ptr: {int(self)}>"

    def as_c_void_p(self):
        """Returns the data's address as `ctypes.c_void_p`
        Note:
            Implemented as function to not collide with
            autogenerated property names.
        """
        return ctypes.c_void_p(int(self))

    def __init__(self,*args,**kwargs):
        """Constructor type hipGraphNodeParams.

        Constructor for type hipGraphNodeParams.

        Args:
            *args:
                Positional arguments. Initialize all or a subset of the member variables
                according to their order of declaration.
            **kwargs:
                Can be used to initialize member variables at construction,
                Just pass an argument expression of the form <member>=<value>
                per member that you want to initialize.
        """
        hipGraphNodeParams.__allocate(&self._ptr)
        self._is_ptr_owner = True
        attribs = self.PROPERTIES()
        used_attribs = set()
        if len(args) > len(attribs):
            raise ValueError("More positional arguments specified than this type has properties.")
        for i,v in enumerate(args):
            setattr(self,attribs[i],v)
            used_attribs.add(attribs[i])
        valid_names = ", ".join(["'"+p+"'" for p in attribs])
        for k,v in kwargs.items():
            if k in used_attribs:
                raise KeyError(f"argument '{k}' has already been specified as positional argument.")
            elif k not in attribs:
                raise KeyError(f"'{k}' is no valid property name. Valid names: {valid_names}")
            setattr(self,k,v)
    def get_type(self, i):
        """Get value of ``type`` of ``(<chip.hipGraphNodeParams*>self._ptr)[i]``.
        """
        return hipGraphNodeType((<chip.hipGraphNodeParams*>self._ptr)[i].type)
    def set_type(self, i, value):
        """Set value ``type`` of ``(<chip.hipGraphNodeParams*>self._ptr)[i]``.
        """
        if not isinstance(value, hipGraphNodeType):
            raise TypeError("'value' must be of type 'hipGraphNodeType'")
        (<chip.hipGraphNodeParams*>self._ptr)[i].type = value.value
    @property
    def type(self):
        """(undocumented)"""
        return self.get_type(0)
    @type.setter
    def type(self, value):
        self.set_type(0,value)

    def get_reserved0(self, i):
        """Get value of ``reserved0`` of ``(<chip.hipGraphNodeParams*>self._ptr)[i]``.
        """
        return (<chip.hipGraphNodeParams*>self._ptr)[i].reserved0
    # TODO add setters
    #def set_reserved0(self, i, int[3] value):
    #    """Set value ``reserved0`` of ``(<chip.hipGraphNodeParams*>self._ptr)[i]``.
    #    """
    #    (<chip.hipGraphNodeParams*>self._ptr)[i].reserved0 = value
    @property
    def reserved0(self):
        """(undocumented)"""
        return self.get_reserved0(0)
    # TODO add setters
    #@reserved0.setter
    #def reserved0(self, int[3] value):
    #    self.set_reserved0(0,value)

    def get_reserved2(self, i):
        """Get value ``reserved2`` of ``(<chip.hipGraphNodeParams*>self._ptr)[i]``.
        """
        return (<chip.hipGraphNodeParams*>self._ptr)[i].reserved2
    def set_reserved2(self, i, long long value):
        """Set value ``reserved2`` of ``(<chip.hipGraphNodeParams*>self._ptr)[i]``.
        """
        (<chip.hipGraphNodeParams*>self._ptr)[i].reserved2 = value
    @property
    def reserved2(self):
        """(undocumented)"""
        return self.get_reserved2(0)
    @reserved2.setter
    def reserved2(self, long long value):
        self.set_reserved2(0,value)

    @staticmethod
    def PROPERTIES():
        return ["type","reserved0","reserved2"]

    def __contains__(self,item):
        properties = self.PROPERTIES()
        return item in properties

    def __getitem__(self,item):
        properties = self.PROPERTIES()
        if isinstance(item,int):
            if item < 0 or item >= len(properties):
                raise IndexError()
            return getattr(self,properties[item])
        raise ValueError("'item' type must be 'int'")


class _hipGraphDependencyType__Base(enum.IntEnum):
    """Empty enum base class that allows subclassing.
    """
    pass
class hipGraphDependencyType(_hipGraphDependencyType__Base):
    """hipGraphDependencyType

    Attributes:
        hipGraphDependencyTypeDefault:
            (undocumented)
        hipGraphDependencyTypeProgrammatic:
            (undocumented)
    """
    hipGraphDependencyTypeDefault = chip.hipGraphDependencyTypeDefault
    hipGraphDependencyTypeProgrammatic = chip.hipGraphDependencyTypeProgrammatic
    @staticmethod
    def ctypes_type():
        """The type of the enum constants as ctypes type."""
        return ctypes.c_uint


cdef class hipGraphEdgeData(hip._util.types.Pointer):
    """Python wrapper for cdef class chip.hipGraphEdgeData.

    Python wrapper for cdef class chip.hipGraphEdgeData.

    If this type is initialized via its `__init__` method, it allocates a
    member of the underlying C type and destroys it again if the wrapper
    type is deallocated.

    This type also serves as adapter when appearing as argument type in a
    function signature. In this case, the type can further be initialized
    from a number of Python objects:

    * `None`:

      This will set the ``self._ptr`` attribute to ``NULL``.

    * `int`:

      Interprets the integer value as pointer address and writes it to ``self._ptr``.
      No ownership is transferred.

    * `ctypes.c_void_p`:

      Takes the pointer address ``pyobj.value`` and writes it to ``self._ptr``.
      No ownership is transferred.

    * `object` that implements the `CUDA Array Interface <https://numba.readthedocs.io/en/stable/cuda/cuda_array_interface.html>`_ protocol:

      Takes the integer-valued pointer address, i.e. the first entry of the `data` tuple
      from `pyobj`'s member ``__cuda_array_interface__``  and writes it to ``self._ptr``.

    * `object` that implements the Python buffer protocol:

      If the object represents a simple contiguous array,
      writes the `Py_buffer` associated with ``pyobj`` to `self._py_buffer`,
      sets the `self._py_buffer_acquired` flag to `True`, and
      writes `self._py_buffer.buf` to the data pointer `self._ptr`.

    * `hip._util.types.Pointer`:

      Takes the pointer address ``pyobj._ptr`` and writes it to ``self._ptr``.
      No ownership is transferred.

    Type checks are performed in the above order.

    C Attributes:
        _ptr (C type ``void *``, protected):
            Stores a pointer to the data of the original Python object.
        _is_ptr_owner (C type ``bint``, protected):
            If this wrapper is the owner of the underlying data.
        _py_buffer (C type ``Py_buffer`, protected):
            Stores a pointer to the data of the original Python object.
        _py_buffer_acquired (C type ``bint``, protected):
            Stores a pointer to the data of the original Python object.
    """
    # C members declared in pxd file

    def __cinit__(self):
        self._ptr = NULL
        self._is_ptr_owner = False
        self._py_buffer_acquired = False

    cdef chip.hipGraphEdgeData* getElementPtr(self):
        return <chip.hipGraphEdgeData*>self._ptr

    @staticmethod
    cdef hipGraphEdgeData fromPtr(void* ptr, bint owner=False):
        """Factory function to create ``hipGraphEdgeData`` objects from
        given ``chip.hipGraphEdgeData`` pointer.

        Setting ``owner`` flag to ``True`` causes
        the extension type to free the structure pointed to by ``ptr``
        when the wrapper object is deallocated.
        """
        # Fast call to __new__() that bypasses the __init__() constructor.
        cdef hipGraphEdgeData wrapper = hipGraphEdgeData.__new__(hipGraphEdgeData)
        wrapper._ptr = ptr
        wrapper._is_ptr_owner = owner
        return wrapper

    @staticmethod
    def fromObj(pyobj):
        """Creates a hipGraphEdgeData from a Python object.

        Derives a hipGraphEdgeData from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``hipGraphEdgeData`` reference, this method
        returns it directly. No new ``hipGraphEdgeData`` is created in this case.
        """
        return hipGraphEdgeData.fromPyobj(pyobj)

    @staticmethod
    cdef hipGraphEdgeData fromPyobj(object pyobj):
        """Creates a hipGraphEdgeData from a Python object.

        Derives a hipGraphEdgeData from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``hipGraphEdgeData`` reference, this method
        returns it directly. No new ``hipGraphEdgeData`` is created in this case.

        Args:
            pyobj (object): Must be either `None`; a `hip._util.types.Pointer`; a simple, contiguous buffer according to the buffer protocol;
                            or of type `hipGraphEdgeData`; `int`; or `ctypes.c_void_p`.

        Note:
            This routine does not perform a copy but returns the original ``pyobj``
            if ``pyobj`` is an instance of hipGraphEdgeData!
        """
        cdef hipGraphEdgeData wrapper

        if isinstance(pyobj,hipGraphEdgeData):
            return pyobj
        else:
            wrapper = hipGraphEdgeData.__new__(hipGraphEdgeData)
            wrapper.init_from_pyobj(pyobj)
            return wrapper

    def __dealloc__(self):
        # Release the buffer handle
        if self._py_buffer_acquired is True:
            cpython.buffer.PyBuffer_Release(&self._py_buffer)
        # De-allocate if not null and flag is set
        if self._ptr is not NULL and self._is_ptr_owner is True:
            stdlib.free(self._ptr)
            self._ptr = NULL

    @staticmethod
    cdef __allocate(void** ptr):
        ptr[0] = stdlib.malloc(sizeof(chip.hipGraphEdgeData))
        string.memset(<void*>ptr[0], 0, sizeof(chip.hipGraphEdgeData))

        if ptr[0] is NULL:
            raise MemoryError

    @staticmethod
    cdef hipGraphEdgeData new():
        """Factory function to create hipGraphEdgeData objects with
        newly allocated chip.hipGraphEdgeData"""
        cdef void* ptr
        hipGraphEdgeData.__allocate(&ptr)
        return hipGraphEdgeData.fromPtr(ptr, owner=True)

    @staticmethod
    cdef hipGraphEdgeData fromValue(chip.hipGraphEdgeData other):
        """Allocate new C type and copy from ``other``.
        """
        wrapper = hipGraphEdgeData.new()
        string.memcpy(wrapper._ptr, &other, sizeof(chip.hipGraphEdgeData))
        return wrapper

    def c_sizeof(self):
        """Returns the size of the underlying C type in bytes.
        Note:
            Implemented as function to not collide with
            autogenerated property names.
        """
        return sizeof(chip.hipGraphEdgeData)

    def __int__(self):
        """Returns the data's address as long integer.
        """
        return cpython.long.PyLong_FromVoidPtr(self._ptr)

    def __repr__(self):
        return f"<hipGraphEdgeData object, ptr: {int(self)}>"

    def as_c_void_p(self):
        """Returns the data's address as `ctypes.c_void_p`
        Note:
            Implemented as function to not collide with
            autogenerated property names.
        """
        return ctypes.c_void_p(int(self))

    def __init__(self,*args,**kwargs):
        """Constructor type hipGraphEdgeData.

        Constructor for type hipGraphEdgeData.

        Args:
            *args:
                Positional arguments. Initialize all or a subset of the member variables
                according to their order of declaration.
            **kwargs:
                Can be used to initialize member variables at construction,
                Just pass an argument expression of the form <member>=<value>
                per member that you want to initialize.
        """
        hipGraphEdgeData.__allocate(&self._ptr)
        self._is_ptr_owner = True
        attribs = self.PROPERTIES()
        used_attribs = set()
        if len(args) > len(attribs):
            raise ValueError("More positional arguments specified than this type has properties.")
        for i,v in enumerate(args):
            setattr(self,attribs[i],v)
            used_attribs.add(attribs[i])
        valid_names = ", ".join(["'"+p+"'" for p in attribs])
        for k,v in kwargs.items():
            if k in used_attribs:
                raise KeyError(f"argument '{k}' has already been specified as positional argument.")
            elif k not in attribs:
                raise KeyError(f"'{k}' is no valid property name. Valid names: {valid_names}")
            setattr(self,k,v)
    def get_from_port(self, i):
        """Get value ``from_port`` of ``(<chip.hipGraphEdgeData*>self._ptr)[i]``.
        """
        return (<chip.hipGraphEdgeData*>self._ptr)[i].from_port
    def set_from_port(self, i, unsigned char value):
        """Set value ``from_port`` of ``(<chip.hipGraphEdgeData*>self._ptr)[i]``.
        """
        (<chip.hipGraphEdgeData*>self._ptr)[i].from_port = value
    @property
    def from_port(self):
        """This indicates when the dependency is triggered from the upstream node on the edge. The meaning is specfic to the node type. A value of 0 in all cases means full completion of the upstream node, with memory visibility to the downstream node or portion thereof (indicated by to_port). Only kernel nodes define non-zero ports. A kernel node can use the following output port types: hipGraphKernelNodePortDefault, hipGraphKernelNodePortProgrammatic, or hipGraphKernelNodePortLaunchCompletion."""
        return self.get_from_port(0)
    @from_port.setter
    def from_port(self, unsigned char value):
        self.set_from_port(0,value)

    def get_reserved(self, i):
        """Get value of ``reserved`` of ``(<chip.hipGraphEdgeData*>self._ptr)[i]``.
        """
        return (<chip.hipGraphEdgeData*>self._ptr)[i].reserved
    # TODO add setters
    #def set_reserved(self, i, unsigned char[5] value):
    #    """Set value ``reserved`` of ``(<chip.hipGraphEdgeData*>self._ptr)[i]``.
    #    """
    #    (<chip.hipGraphEdgeData*>self._ptr)[i].reserved = value
    @property
    def reserved(self):
        """These bytes are unused and must be zeroed"""
        return self.get_reserved(0)
    # TODO add setters
    #@reserved.setter
    #def reserved(self, unsigned char[5] value):
    #    self.set_reserved(0,value)

    def get_to_port(self, i):
        """Get value ``to_port`` of ``(<chip.hipGraphEdgeData*>self._ptr)[i]``.
        """
        return (<chip.hipGraphEdgeData*>self._ptr)[i].to_port
    def set_to_port(self, i, unsigned char value):
        """Set value ``to_port`` of ``(<chip.hipGraphEdgeData*>self._ptr)[i]``.
        """
        (<chip.hipGraphEdgeData*>self._ptr)[i].to_port = value
    @property
    def to_port(self):
        """Currently no node types define non-zero ports. This field must be set to zero."""
        return self.get_to_port(0)
    @to_port.setter
    def to_port(self, unsigned char value):
        self.set_to_port(0,value)

    def get_type(self, i):
        """Get value ``type`` of ``(<chip.hipGraphEdgeData*>self._ptr)[i]``.
        """
        return (<chip.hipGraphEdgeData*>self._ptr)[i].type
    def set_type(self, i, unsigned char value):
        """Set value ``type`` of ``(<chip.hipGraphEdgeData*>self._ptr)[i]``.
        """
        (<chip.hipGraphEdgeData*>self._ptr)[i].type = value
    @property
    def type(self):
        """This should be populated with a value from hipGraphDependencyType"""
        return self.get_type(0)
    @type.setter
    def type(self, unsigned char value):
        self.set_type(0,value)

    @staticmethod
    def PROPERTIES():
        return ["from_port","reserved","to_port","type"]

    def __contains__(self,item):
        properties = self.PROPERTIES()
        return item in properties

    def __getitem__(self,item):
        properties = self.PROPERTIES()
        if isinstance(item,int):
            if item < 0 or item >= len(properties):
                raise IndexError()
            return getattr(self,properties[item])
        raise ValueError("'item' type must be 'int'")


@cython.embedsignature(True)
def hipInit(unsigned int flags):
    r"""Explicitly initializes the HIP runtime.

    Defines the HIP API.  See the individual sections for more information.

    This section describes the initializtion and version functions of HIP runtime API.

    Most HIP APIs implicitly initialize the HIP runtime.
    This API provides control over the timing of the initialization.

    Args:
        flags (`~.int`) -- *IN*:
            Initialization flag, should be zero.

    Returns:
        A `~.tuple` of size 1 that contains (in that order):

        * `~.hipError_t`: `~.hipSuccess`, `~.hipErrorInvalidValue`
    """
    _hipInit__retval = hipError_t(chip.hipInit(flags))
    return (_hipInit__retval,)


@cython.embedsignature(True)
def hipDriverGetVersion():
    r"""Returns the approximate HIP driver version.

    Warning:
        The HIP feature set does not correspond to an exact CUDA SDK driver revision.
        This function always set *driverVersion to 4 as an approximation though HIP supports
        some features which were introduced in later CUDA SDK revisions.
        HIP apps code should not rely on the driver revision number here and should
        use arch feature flags to test device capabilities or conditional compilation.

    See:
        `~.hipRuntimeGetVersion`

    Returns:
        A `~.tuple` of size 2 that contains (in that order):

        * `~.hipError_t`: `~.hipSuccess`, `~.hipErrorInvalidValue`
        * `~.int`:
                driver version
    """
    cdef int driverVersion
    _hipDriverGetVersion__retval = hipError_t(chip.hipDriverGetVersion(&driverVersion))
    return (_hipDriverGetVersion__retval,driverVersion)


@cython.embedsignature(True)
def hipRuntimeGetVersion():
    r"""Returns the approximate HIP Runtime version.

    Warning:
        The version definition of HIP runtime is different from CUDA.
        On AMD platform, the function returns HIP runtime version,
        while on NVIDIA platform, it returns CUDA runtime version.
        And there is no mapping/correlation between HIP version and CUDA version.

    See:
        `~.hipDriverGetVersion`

    Returns:
        A `~.tuple` of size 2 that contains (in that order):

        * `~.hipError_t`: `~.hipSuccess`, `~.hipErrorInvalidValue`
        * `~.int`:
                HIP runtime version
    """
    cdef int runtimeVersion
    _hipRuntimeGetVersion__retval = hipError_t(chip.hipRuntimeGetVersion(&runtimeVersion))
    return (_hipRuntimeGetVersion__retval,runtimeVersion)


@cython.embedsignature(True)
def hipDeviceGet(int ordinal):
    r"""Returns a handle to a compute device

    Args:
        ordinal (`~.int`) -- *IN*:
            Device ordinal

    Returns:
        A `~.tuple` of size 2 that contains (in that order):

        * `~.hipError_t`: `~.hipSuccess`, `~.hipErrorInvalidDevice`
        * `~.int`:
                Handle of device
    """
    cdef int device
    _hipDeviceGet__retval = hipError_t(chip.hipDeviceGet(&device,ordinal))
    return (_hipDeviceGet__retval,device)


@cython.embedsignature(True)
def hipDeviceComputeCapability(int device):
    r"""Returns the compute capability of the device

    Args:
        device (`~.int`) -- *IN*:
            Device ordinal

    Returns:
        A `~.tuple` of size 3 that contains (in that order):

        * `~.hipError_t`: `~.hipSuccess`, `~.hipErrorInvalidDevice`
        * `~.int`:
                Major compute capability version number
        * `~.int`:
                Minor compute capability version number
    """
    cdef int major
    cdef int minor
    _hipDeviceComputeCapability__retval = hipError_t(chip.hipDeviceComputeCapability(&major,&minor,device))
    return (_hipDeviceComputeCapability__retval,major,minor)


@cython.embedsignature(True)
def hipDeviceGetName(int len, int device):
    r"""Returns an identifer string for the device.

    Args:
        len (`~.int`) -- *IN*:
            Maximum length of string to store in device name

        device (`~.int`) -- *IN*:
            Device ordinal

    Returns:
        A `~.tuple` of size 2 that contains (in that order):

        * `~.hipError_t`: `~.hipSuccess`, `~.hipErrorInvalidDevice`
        * `~.hip._util.types.CStr`/`~.object`:
                String of the device name
    """
    name = hip._util.types.CStr.fromPtr(NULL)
    name.malloc(len)
    _hipDeviceGetName__retval = hipError_t(chip.hipDeviceGetName(
        <char *>name._ptr,len,device))
    return (_hipDeviceGetName__retval,None if name._ptr == NULL else name)


@cython.embedsignature(True)
def hipDeviceGetUuid(int device):
    r"""Returns an UUID for the device.[BETA]

    Warning:
        This API is marked as beta, meaning, while this is feature complete,
        it is still open to changes and may have outstanding issues.

    Args:
        device (`~.int`) -- *IN*:
            device ordinal

    Returns:
        A `~.tuple` of size 2 that contains (in that order):

        * `~.hipError_t`: `~.hipSuccess`, `~.hipErrorInvalidDevice`, `~.hipErrorInvalidValue`, `~.hipErrorNotInitialized`,
            `~.hipErrorDeinitialized`
        * `~.hipUUID_t`:
                UUID for the device
    """
    uuid = hipUUID_t.new()
    _hipDeviceGetUuid__retval = hipError_t(chip.hipDeviceGetUuid(<chip.hipUUID_t*>uuid._ptr,device))
    return (_hipDeviceGetUuid__retval,uuid)


@cython.embedsignature(True)
def hipDeviceGetP2PAttribute(object attr, int srcDevice, int dstDevice):
    r"""Returns a value for attribute of link between two devices

    Args:
        attr (`~.hipDeviceP2PAttr`) -- *IN*:
            enum of hipDeviceP2PAttr to query

        srcDevice (`~.int`) -- *IN*:
            The source device of the link

        dstDevice (`~.int`) -- *IN*:
            The destination device of the link

    Returns:
        A `~.tuple` of size 2 that contains (in that order):

        * `~.hipError_t`: `~.hipSuccess`, `~.hipErrorInvalidDevice`
        * `~.int`:
                Pointer of the value for the attrubute
    """
    cdef int value
    if not isinstance(attr,_hipDeviceP2PAttr__Base):
        raise TypeError("argument 'attr' must be of type '_hipDeviceP2PAttr__Base'")
    _hipDeviceGetP2PAttribute__retval = hipError_t(chip.hipDeviceGetP2PAttribute(&value,attr.value,srcDevice,dstDevice))
    return (_hipDeviceGetP2PAttribute__retval,value)


@cython.embedsignature(True)
def hipDeviceGetPCIBusId(int len, int device):
    r"""Returns a PCI Bus Id string for the device, overloaded to take int device ID.

    Args:
        len (`~.int`) -- *IN*:
            Maximum length of string

        device (`~.int`) -- *IN*:
            The device ordinal

    Returns:
        A `~.tuple` of size 2 that contains (in that order):

        * `~.hipError_t`: `~.hipSuccess`, `~.hipErrorInvalidDevice`
        * `~.hip._util.types.CStr`/`~.object`:
                The string of PCI Bus Id format for the device
    """
    pciBusId = hip._util.types.CStr.fromPtr(NULL)
    pciBusId.malloc(len)
    _hipDeviceGetPCIBusId__retval = hipError_t(chip.hipDeviceGetPCIBusId(
        <char *>pciBusId._ptr,len,device))
    return (_hipDeviceGetPCIBusId__retval,None if pciBusId._ptr == NULL else pciBusId)


@cython.embedsignature(True)
def hipDeviceGetByPCIBusId(object pciBusId):
    r"""Returns a handle to a compute device.

    Args:
        pciBusId (`~.hip._util.types.CStr`/`~.object`) -- *IN*:
            The string of PCI Bus Id for the device

    Returns:
        A `~.tuple` of size 2 that contains (in that order):

        * `~.hipError_t`: `~.hipSuccess`, `~.hipErrorInvalidDevice`, `~.hipErrorInvalidValue`
        * `~.int`:
                The handle of the device
    """
    cdef int device
    _hipDeviceGetByPCIBusId__retval = hipError_t(chip.hipDeviceGetByPCIBusId(&device,
        <const char *>hip._util.types.CStr.fromPyobj(pciBusId)._ptr))
    return (_hipDeviceGetByPCIBusId__retval,device)


@cython.embedsignature(True)
def hipDeviceTotalMem(int device):
    r"""Returns the total amount of memory on the device.

    Args:
        device (`~.int`) -- *IN*:
            The ordinal of the device

    Returns:
        A `~.tuple` of size 2 that contains (in that order):

        * `~.hipError_t`: `~.hipSuccess`, `~.hipErrorInvalidDevice`
        * `~.int`:
                The size of memory in bytes, on the device
    """
    cdef unsigned long bytes
    _hipDeviceTotalMem__retval = hipError_t(chip.hipDeviceTotalMem(&bytes,device))
    return (_hipDeviceTotalMem__retval,bytes)


@cython.embedsignature(True)
def hipDeviceSynchronize():
    r"""Waits on all active streams on current device

    This section describes the device management functions of HIP runtime API.

    When this command is invoked, the host thread gets blocked until all the commands associated
    with streams associated with the device. HIP does not support multiple blocking modes (yet!).

    See:
        `~.hipSetDevice`, `~.hipDeviceReset`

    Returns:
        A `~.tuple` of size 1 that contains (in that order):

        * `~.hipError_t`: `~.hipSuccess`
    """
    _hipDeviceSynchronize__retval = hipError_t(chip.hipDeviceSynchronize())
    return (_hipDeviceSynchronize__retval,)


@cython.embedsignature(True)
def hipDeviceReset():
    r"""The state of current device is discarded and updated to a fresh state.

    Calling this function deletes all streams created, memory allocated, kernels running, events
    created. Make sure that no other thread is using the device or streams, memory, kernels, events
    associated with the current device.

    See:
        `~.hipDeviceSynchronize`

    Returns:
        A `~.tuple` of size 1 that contains (in that order):

        * `~.hipError_t`: `~.hipSuccess`
    """
    _hipDeviceReset__retval = hipError_t(chip.hipDeviceReset())
    return (_hipDeviceReset__retval,)


@cython.embedsignature(True)
def hipSetDevice(int deviceId):
    r"""Set default device to be used for subsequent hip API calls from this thread.

    Sets ``device`` as the default device for the calling host thread.  Valid device id's are 0...
    (hipGetDeviceCount()-1).

    Many HIP APIs implicitly use the "default device" :

    - Any device memory subsequently allocated from this host thread (using hipMalloc) will be
    allocated on device.
    - Any streams or events created from this host thread will be associated with device.
    - Any kernels launched from this host thread (using hipLaunchKernel) will be executed on device
    (unless a specific stream is specified, in which case the device associated with that stream will
    be used).

    This function may be called from any host thread.  Multiple host threads may use the same device.
    This function does no synchronization with the previous or new device, and has very little
    runtime overhead. Applications can use hipSetDevice to quickly switch the default device before
    making a HIP runtime call which uses the default device.

    The default device is stored in thread-local-storage for each thread.
    Thread-pool implementations may inherit the default device of the previous thread.  A good
    practice is to always call hipSetDevice at the start of HIP coding sequency to establish a known
    standard device.

    See:
        `~.`~.hipGetDevice``, `~.`~.hipGetDeviceCount``

    Args:
        deviceId (`~.int`) -- *IN*:
            Valid device in range 0...hipGetDeviceCount().

    Returns:
        A `~.tuple` of size 1 that contains (in that order):

        * `~.hipError_t`: `~.hipSuccess`, `~.hipErrorInvalidDevice`, `~.hipErrorNoDevice`
    """
    _hipSetDevice__retval = hipError_t(chip.hipSetDevice(deviceId))
    return (_hipSetDevice__retval,)


@cython.embedsignature(True)
def hipSetValidDevices(int len):
    r"""Set a list of devices that can be used.

    See:
        `~.`~.hipGetDevice``, `~.`~.hipGetDeviceCount``. `~.`~.hipSetDevice``. `~.`~.hipGetDeviceProperties``. `~.`~.hipSetDeviceFlags``. `~.`~.hipChooseDevice``

    Args:
        len (`~.int`) -- *IN*:
            Number of devices in specified list

    Returns:
        A `~.tuple` of size 2 that contains (in that order):

        * `~.hipError_t`: `~.hipSuccess`, `~.hipErrorInvalidDevice`, `~.hipErrorInvalidValue`
        * `~.int`:
                List of devices to try
    """
    cdef int device_arr
    _hipSetValidDevices__retval = hipError_t(chip.hipSetValidDevices(&device_arr,len))
    return (_hipSetValidDevices__retval,device_arr)


@cython.embedsignature(True)
def hipGetDevice():
    r"""Return the default device id for the calling host thread.

    HIP maintains an default device for each thread using thread-local-storage.
    This device is used implicitly for HIP runtime APIs called by this thread.
    hipGetDevice returns in * ``device`` the default device for the calling host thread.

    See:
        `~.hipSetDevice`, `~.hipGetDevicesizeBytes`

    Returns:
        A `~.tuple` of size 2 that contains (in that order):

        * `~.hipError_t`: `~.hipSuccess`, `~.hipErrorInvalidDevice`, `~.hipErrorInvalidValue`
        * `~.int`:
                *device is written with the default device
    """
    cdef int deviceId
    _hipGetDevice__retval = hipError_t(chip.hipGetDevice(&deviceId))
    return (_hipGetDevice__retval,deviceId)


@cython.embedsignature(True)
def hipGetDeviceCount():
    r"""Return number of compute-capable devices.

    Returns in ``*count`` the number of devices that have ability to run compute commands.  If there
    are no such devices, then ``hipGetDeviceCount`` will return `~.hipErrorNoDevice`. If 1 or more
    devices can be found, then hipGetDeviceCount returns `~.hipSuccess`.

    Returns:
        A `~.tuple` of size 2 that contains (in that order):

        * `~.hipError_t`: `~.hipSuccess`, `~.hipErrorNoDevice`
        * `~.int`:
                Returns number of compute-capable devices.
    """
    cdef int count
    _hipGetDeviceCount__retval = hipError_t(chip.hipGetDeviceCount(&count))
    return (_hipGetDeviceCount__retval,count)


@cython.embedsignature(True)
def hipDeviceGetAttribute(object attr, int deviceId):
    r"""Query for a specific device attribute.

    Args:
        attr (`~.hipDeviceAttribute_t`) -- *IN*:
            attribute to query

        deviceId (`~.int`) -- *IN*:
            which device to query for information

    Returns:
        A `~.tuple` of size 2 that contains (in that order):

        * `~.hipError_t`: `~.hipSuccess`, `~.hipErrorInvalidDevice`, `~.hipErrorInvalidValue`
        * `~.int`:
                pointer to value to return
    """
    cdef int pi
    if not isinstance(attr,_hipDeviceAttribute_t__Base):
        raise TypeError("argument 'attr' must be of type '_hipDeviceAttribute_t__Base'")
    _hipDeviceGetAttribute__retval = hipError_t(chip.hipDeviceGetAttribute(&pi,attr.value,deviceId))
    return (_hipDeviceGetAttribute__retval,pi)


@cython.embedsignature(True)
def hipDeviceGetDefaultMemPool(int device):
    r"""Returns the default memory pool of the specified device

    See:
        `~.hipDeviceGetDefaultMemPool`, `~.hipMallocAsync`, `~.hipMemPoolTrimTo`, `~.hipMemPoolGetAttribute`,
        `~.hipDeviceSetMemPool`, `~.hipMemPoolSetAttribute`, `~.hipMemPoolSetAccess`, `~.hipMemPoolGetAccess`

    Warning:
        This API is marked as beta, meaning, while this is feature complete,
        it is still open to changes and may have outstanding issues.

    Args:
        device (`~.int`) -- *IN*:
            Device index for query the default memory pool

    Returns:
        A `~.tuple` of size 2 that contains (in that order):

        * `~.hipError_t`: `~.hipSuccess`, `~.hipErrorInvalidDevice`, `~.hipErrorInvalidValue`, `~.hipErrorNotSupported`
        * `~.ihipMemPoolHandle_t`:
                Default memory pool to return
    """
    mem_pool = ihipMemPoolHandle_t.fromPtr(NULL)
    _hipDeviceGetDefaultMemPool__retval = hipError_t(chip.hipDeviceGetDefaultMemPool(<chip.ihipMemPoolHandle_t**>&mem_pool._ptr,device))
    return (_hipDeviceGetDefaultMemPool__retval,None if mem_pool._ptr == NULL else mem_pool)


@cython.embedsignature(True)
def hipDeviceSetMemPool(int device, object mem_pool):
    r"""Sets the current memory pool of a device

    The memory pool must be local to the specified device.
    ``hipMallocAsync`` allocates from the current mempool of the provided stream's device.
    By default, a device's current memory pool is its default memory pool.

    Note:
        Use ``hipMallocFromPoolAsync`` for asynchronous memory allocations from a device
        different than the one the stream runs on.

    See:
        `~.hipDeviceGetDefaultMemPool`, `~.hipMallocAsync`, `~.hipMemPoolTrimTo`, `~.hipMemPoolGetAttribute`,
        `~.hipDeviceSetMemPool`, `~.hipMemPoolSetAttribute`, `~.hipMemPoolSetAccess`, `~.hipMemPoolGetAccess`

    Warning:
        This API is marked as beta, meaning, while this is feature complete,
        it is still open to changes and may have outstanding issues.

    Args:
        device (`~.int`) -- *IN*:
            Device index for the update

        mem_pool (`~.ihipMemPoolHandle_t`/`~.object`) -- *IN*:
            Memory pool for update as the current on the specified device

    Returns:
        A `~.tuple` of size 1 that contains (in that order):

        * `~.hipError_t`: `~.hipSuccess`, `~.hipErrorInvalidValue`, `~.hipErrorInvalidDevice`, `~.hipErrorNotSupported`
    """
    _hipDeviceSetMemPool__retval = hipError_t(chip.hipDeviceSetMemPool(device,
        ihipMemPoolHandle_t.fromPyobj(mem_pool).getElementPtr()))
    return (_hipDeviceSetMemPool__retval,)


@cython.embedsignature(True)
def hipDeviceGetMemPool(int device):
    r"""Gets the current memory pool for the specified device

    Returns the last pool provided to ``hipDeviceSetMemPool`` for this device
    or the device's default memory pool if ``hipDeviceSetMemPool`` has never been called.
    By default the current mempool is the default mempool for a device,
    otherwise the returned pool must have been set with ``hipDeviceSetMemPool.``

    See:
        `~.hipDeviceGetDefaultMemPool`, `~.hipMallocAsync`, `~.hipMemPoolTrimTo`, `~.hipMemPoolGetAttribute`,
        `~.hipDeviceSetMemPool`, `~.hipMemPoolSetAttribute`, `~.hipMemPoolSetAccess`, `~.hipMemPoolGetAccess`

    Warning:
        This API is marked as beta, meaning, while this is feature complete,
        it is still open to changes and may have outstanding issues.

    Args:
        device (`~.int`) -- *IN*:
            Device index to query the current memory pool

    Returns:
        A `~.tuple` of size 2 that contains (in that order):

        * `~.hipError_t`: `~.hipSuccess`, `~.hipErrorInvalidValue`, `~.hipErrorNotSupported`
        * `~.ihipMemPoolHandle_t`:
                Current memory pool on the specified device
    """
    mem_pool = ihipMemPoolHandle_t.fromPtr(NULL)
    _hipDeviceGetMemPool__retval = hipError_t(chip.hipDeviceGetMemPool(<chip.ihipMemPoolHandle_t**>&mem_pool._ptr,device))
    return (_hipDeviceGetMemPool__retval,None if mem_pool._ptr == NULL else mem_pool)


@cython.embedsignature(True)
def hipGetDeviceProperties(object prop, int deviceId):
    r"""(No short description, might be part of a group.)

    Args:
        prop (`~.hipDeviceProp_t`/`~.object`):
            (undocumented)

        deviceId (`~.int`):
            (undocumented)
    """
    _hipGetDeviceProperties__retval = hipError_t(chip.hipGetDeviceProperties(
        hipDeviceProp_t.fromPyobj(prop).getElementPtr(),deviceId))
    return (_hipGetDeviceProperties__retval,)


@cython.embedsignature(True)
def hipDeviceSetCacheConfig(object cacheConfig):
    r"""Set L1/Shared cache partition.

    Note: AMD devices do not support reconfigurable cache. This API is not implemented
    on AMD platform. If the function is called, it will return hipErrorNotSupported.

    Args:
        cacheConfig (`~.hipFuncCache_t`) -- *IN*:
            Cache configuration

    Returns:
        A `~.tuple` of size 1 that contains (in that order):

        * `~.hipError_t`: `~.hipSuccess`, `~.hipErrorNotInitialized`, `~.hipErrorNotSupported`
    """
    if not isinstance(cacheConfig,_hipFuncCache_t__Base):
        raise TypeError("argument 'cacheConfig' must be of type '_hipFuncCache_t__Base'")
    _hipDeviceSetCacheConfig__retval = hipError_t(chip.hipDeviceSetCacheConfig(cacheConfig.value))
    return (_hipDeviceSetCacheConfig__retval,)


@cython.embedsignature(True)
def hipDeviceGetCacheConfig():
    r"""Get Cache configuration for a specific Device

    Returns:
        A `~.tuple` of size 2 that contains (in that order):

        * `~.hipError_t`: `~.hipSuccess`, `~.hipErrorNotInitialized`
            Note: AMD devices do not support reconfigurable cache. This hint is ignored
            on these architectures.
        * `~.hipFuncCache_t`:
                Pointer of cache configuration
    """
    cdef chip.hipFuncCache_t cacheConfig
    _hipDeviceGetCacheConfig__retval = hipError_t(chip.hipDeviceGetCacheConfig(&cacheConfig))
    return (_hipDeviceGetCacheConfig__retval,hipFuncCache_t(cacheConfig))


@cython.embedsignature(True)
def hipDeviceGetLimit(object limit):
    r"""Gets resource limits of current device

    The function queries the size of limit value, as required by the input enum value hipLimit_t,
    which can be either `~.hipLimitStackSize`, or `~.hipLimitMallocHeapSize`. Any other input as
    default, the function will return `~.hipErrorUnsupportedLimit`.

    Args:
        limit (`~.hipLimit_t`) -- *IN*:
            The limit to query

    Returns:
        A `~.tuple` of size 2 that contains (in that order):

        * `~.hipError_t`: `~.hipSuccess`, `~.hipErrorUnsupportedLimit`, `~.hipErrorInvalidValue`
        * `~.int`:
                Returns the size of the limit in bytes
    """
    cdef unsigned long pValue
    if not isinstance(limit,_hipLimit_t__Base):
        raise TypeError("argument 'limit' must be of type '_hipLimit_t__Base'")
    _hipDeviceGetLimit__retval = hipError_t(chip.hipDeviceGetLimit(&pValue,limit.value))
    return (_hipDeviceGetLimit__retval,pValue)


@cython.embedsignature(True)
def hipDeviceSetLimit(object limit, unsigned long value):
    r"""Sets resource limits of current device.

    As the input enum limit,
    `~.hipLimitStackSize` sets the limit value of the stack size on the current GPU device, per thread.
    The limit size can get via hipDeviceGetLimit. The size is in units of 256 dwords, up to the limit
    (128K - 16).

    `~.hipLimitMallocHeapSize` sets the limit value of the heap used by the malloc()/free()
    calls. For limit size, use the `~.hipDeviceGetLimit` API.

    Any other input as default, the funtion will return hipErrorUnsupportedLimit.

    Args:
        limit (`~.hipLimit_t`) -- *IN*:
            Enum of hipLimit_t to set

        value (`~.int`) -- *IN*:
            The size of limit value in bytes

    Returns:
        A `~.tuple` of size 1 that contains (in that order):

        * `~.hipError_t`: `~.hipSuccess`, `~.hipErrorUnsupportedLimit`, `~.hipErrorInvalidValue`
    """
    if not isinstance(limit,_hipLimit_t__Base):
        raise TypeError("argument 'limit' must be of type '_hipLimit_t__Base'")
    _hipDeviceSetLimit__retval = hipError_t(chip.hipDeviceSetLimit(limit.value,value))
    return (_hipDeviceSetLimit__retval,)


@cython.embedsignature(True)
def hipDeviceGetSharedMemConfig():
    r"""Returns bank width of shared memory for current device

    Note: AMD devices and some Nvidia GPUS do not support shared cache banking, and the hint is
    ignored on those architectures.

    Returns:
        A `~.tuple` of size 2 that contains (in that order):

        * `~.hipError_t`: `~.hipSuccess`, `~.hipErrorInvalidValue`, `~.hipErrorNotInitialized`
        * `~.hipSharedMemConfig`:
                The pointer of the bank width for shared memory
    """
    cdef chip.hipSharedMemConfig pConfig
    _hipDeviceGetSharedMemConfig__retval = hipError_t(chip.hipDeviceGetSharedMemConfig(&pConfig))
    return (_hipDeviceGetSharedMemConfig__retval,hipSharedMemConfig(pConfig))


@cython.embedsignature(True)
def hipGetDeviceFlags():
    r"""Gets the flags set for current device

    Returns:
        A `~.tuple` of size 2 that contains (in that order):

        * `~.hipError_t`: `~.hipSuccess`, `~.hipErrorInvalidDevice`, `~.hipErrorInvalidValue`
        * `~.int`:
                Pointer of the flags
    """
    cdef unsigned int flags
    _hipGetDeviceFlags__retval = hipError_t(chip.hipGetDeviceFlags(&flags))
    return (_hipGetDeviceFlags__retval,flags)


@cython.embedsignature(True)
def hipDeviceSetSharedMemConfig(object config):
    r"""The bank width of shared memory on current device is set

    Note: AMD devices and some Nvidia GPUS do not support shared cache banking, and the hint is
    ignored on those architectures.

    Args:
        config (`~.hipSharedMemConfig`) -- *IN*:
            Configuration for the bank width of shared memory

    Returns:
        A `~.tuple` of size 1 that contains (in that order):

        * `~.hipError_t`: `~.hipSuccess`, `~.hipErrorInvalidValue`, `~.hipErrorNotInitialized`
    """
    if not isinstance(config,_hipSharedMemConfig__Base):
        raise TypeError("argument 'config' must be of type '_hipSharedMemConfig__Base'")
    _hipDeviceSetSharedMemConfig__retval = hipError_t(chip.hipDeviceSetSharedMemConfig(config.value))
    return (_hipDeviceSetSharedMemConfig__retval,)


@cython.embedsignature(True)
def hipSetDeviceFlags(unsigned int flags):
    r"""The current device behavior is changed according the flags passed.

    The schedule flags impact how HIP waits for the completion of a command running on a device.
    hipDeviceScheduleSpin         : HIP runtime will actively spin in the thread which submitted the
    work until the command completes.  This offers the lowest latency, but will consume a CPU core
    and may increase power. hipDeviceScheduleYield        : The HIP runtime will yield the CPU to
    system so that other tasks can use it.  This may increase latency to detect the completion but
    will consume less power and is friendlier to other tasks in the system.
    hipDeviceScheduleBlockingSync : On ROCm platform, this is a synonym for hipDeviceScheduleYield.
    hipDeviceScheduleAuto         : Use a hueristic to select between Spin and Yield modes.  If the
    number of HIP contexts is greater than the number of logical processors in the system, use Spin
    scheduling.  Else use Yield scheduling.

    hipDeviceMapHost              : Allow mapping host memory.  On ROCM, this is always allowed and
    the flag is ignored. hipDeviceLmemResizeToMax      :

    Warning:
        ROCm silently ignores this flag.

    Args:
        flags (`~.int`) -- *IN*:
            Flag to set on the current device

    Returns:
        A `~.tuple` of size 1 that contains (in that order):

        * `~.hipError_t`: `~.hipSuccess`, `~.hipErrorInvalidDevice`, `~.hipErrorSetOnActiveProcess`
    """
    _hipSetDeviceFlags__retval = hipError_t(chip.hipSetDeviceFlags(flags))
    return (_hipSetDeviceFlags__retval,)


@cython.embedsignature(True)
def hipChooseDevice(object prop):
    r"""(No short description, might be part of a group.)

    Args:
        prop (`~.hipDeviceProp_t`/`~.object`):
            (undocumented)

    Returns:
        A `~.tuple` of size 1 that contains (in that order):

        * device (`~.int`):
            (undocumented)
    """
    cdef int device
    _hipChooseDevice__retval = hipError_t(chip.hipChooseDevice(&device,
        hipDeviceProp_t.fromPyobj(prop).getElementPtr()))
    return (_hipChooseDevice__retval,device)


@cython.embedsignature(True)
def hipExtGetLinkTypeAndHopCount(int device1, int device2):
    r"""Returns the link type and hop count between two devices

    Queries and returns the HSA link type and the hop count between the two specified devices.

    Args:
        device1 (`~.int`) -- *IN*:
            Ordinal for device1

        device2 (`~.int`) -- *IN*:
            Ordinal for device2

    Returns:
        A `~.tuple` of size 3 that contains (in that order):

        * `~.hipError_t`: `~.hipSuccess`, `~.hipErrorInvalidValue`
        * `~.int`:
                Returns the link type (See hsa_amd_link_info_type_t) between the two devices
        * `~.int`:
                Returns the hop count between the two devices
    """
    cdef unsigned int linktype
    cdef unsigned int hopcount
    _hipExtGetLinkTypeAndHopCount__retval = hipError_t(chip.hipExtGetLinkTypeAndHopCount(device1,device2,&linktype,&hopcount))
    return (_hipExtGetLinkTypeAndHopCount__retval,linktype,hopcount)


@cython.embedsignature(True)
def hipIpcGetMemHandle(object devPtr):
    r"""Gets an interprocess memory handle for an existing device memory
             allocation

    Takes a pointer to the base of an existing device memory allocation created
    with hipMalloc and exports it for use in another process. This is a
    lightweight operation and may be called multiple times on an allocation
    without adverse effects.

    If a region of memory is freed with hipFree and a subsequent call
    to hipMalloc returns memory with the same device address,
    hipIpcGetMemHandle will return a unique handle for the
    new memory.

    Note:
        This IPC memory related feature API on Windows may behave differently from Linux.

    Args:
        devPtr (`~.hip._util.types.Pointer`/`~.object`):
            - Base pointer to previously allocated device memory

    Returns:
        A `~.tuple` of size 2 that contains (in that order):

        * `~.hipError_t`: `~.hipSuccess`, `~.hipErrorInvalidHandle`, `~.hipErrorOutOfMemory`, `~.hipErrorMapFailed`
        * `~.hipIpcMemHandle_st`:
                - Pointer to user allocated hipIpcMemHandle to return
                the handle in.
    """
    handle = hipIpcMemHandle_st.new()
    _hipIpcGetMemHandle__retval = hipError_t(chip.hipIpcGetMemHandle(<chip.hipIpcMemHandle_st*>handle._ptr,
        <void *>hip._util.types.Pointer.fromPyobj(devPtr)._ptr))
    return (_hipIpcGetMemHandle__retval,handle)


@cython.embedsignature(True)
def hipIpcOpenMemHandle(object handle, unsigned int flags):
    r"""Opens an interprocess memory handle exported from another process
             and returns a device pointer usable in the local process.

    Maps memory exported from another process with hipIpcGetMemHandle into
    the current device address space. For contexts on different devices
    hipIpcOpenMemHandle can attempt to enable peer access between the
    devices as if the user called hipDeviceEnablePeerAccess. This behavior is
    controlled by the hipIpcMemLazyEnablePeerAccess flag.
    hipDeviceCanAccessPeer can determine if a mapping is possible.

    Contexts that may open hipIpcMemHandles are restricted in the following way.
    hipIpcMemHandles from each device in a given process may only be opened
    by one context per device per other process.

    Memory returned from hipIpcOpenMemHandle must be freed with
    hipIpcCloseMemHandle.

    Calling hipFree on an exported memory region before calling
    hipIpcCloseMemHandle in the importing context will result in undefined
    behavior.

    Note:
        During multiple processes, using the same memory handle opened by the current context,
        there is no guarantee that the same device poiter will be returned in ``*devPtr.``
        This is diffrent from CUDA.

    Note:
        This IPC memory related feature API on Windows may behave differently from Linux.

    Args:
        handle (`~.hipIpcMemHandle_st`):
            - hipIpcMemHandle to open

        flags (`~.int`):
            - Flags for this operation. Must be specified as hipIpcMemLazyEnablePeerAccess

    Returns:
        A `~.tuple` of size 2 that contains (in that order):

        * `~.hipError_t`: `~.hipSuccess`, `~.hipErrorInvalidValue`, `~.hipErrorInvalidContext`,
            `~.hipErrorInvalidDevicePointer`
        * `~.hip._util.types.Pointer`/`~.object`:
                - Returned device pointer
    """
    devPtr = hip._util.types.Pointer.fromPtr(NULL)
    _hipIpcOpenMemHandle__retval = hipError_t(chip.hipIpcOpenMemHandle(
        <void **>&devPtr._ptr,
        hipIpcMemHandle_st.fromPyobj(handle).getElementPtr()[0],flags))
    return (_hipIpcOpenMemHandle__retval,None if devPtr._ptr == NULL else devPtr)


@cython.embedsignature(True)
def hipIpcCloseMemHandle(object devPtr):
    r"""Close memory mapped with hipIpcOpenMemHandle

    Unmaps memory returnd by hipIpcOpenMemHandle. The original allocation
    in the exporting process as well as imported mappings in other processes
    will be unaffected.

    Any resources used to enable peer access will be freed if this is the
    last mapping using them.

    Note:
        This IPC memory related feature API on Windows may behave differently from Linux.

    Args:
        devPtr (`~.hip._util.types.Pointer`/`~.object`):
            - Device pointer returned by hipIpcOpenMemHandle

    Returns:
        A `~.tuple` of size 1 that contains (in that order):

        * `~.hipError_t`: `~.hipSuccess`, `~.hipErrorMapFailed`, `~.hipErrorInvalidHandle`
    """
    _hipIpcCloseMemHandle__retval = hipError_t(chip.hipIpcCloseMemHandle(
        <void *>hip._util.types.Pointer.fromPyobj(devPtr)._ptr))
    return (_hipIpcCloseMemHandle__retval,)


@cython.embedsignature(True)
def hipIpcGetEventHandle(object handle, object event):
    r"""Gets an opaque interprocess handle for an event.

    This opaque handle may be copied into other processes and opened with hipIpcOpenEventHandle.
    Then hipEventRecord, hipEventSynchronize, hipStreamWaitEvent and hipEventQuery may be used in
    either process. Operations on the imported event after the exported event has been freed with hipEventDestroy
    will result in undefined behavior.

    Note:
        This IPC event related feature API is currently applicable on Linux.

    Args:
        handle (`~.hipIpcEventHandle_st`/`~.object`) -- *OUT*:
            Pointer to hipIpcEventHandle to return the opaque event handle

        event (`~.ihipEvent_t`/`~.object`) -- *IN*:
            Event allocated with hipEventInterprocess and hipEventDisableTiming flags

    Returns:
        A `~.tuple` of size 1 that contains (in that order):

        * `~.hipError_t`: `~.hipSuccess`, `~.hipErrorInvalidConfiguration`, `~.hipErrorInvalidValue`
    """
    _hipIpcGetEventHandle__retval = hipError_t(chip.hipIpcGetEventHandle(
        hipIpcEventHandle_st.fromPyobj(handle).getElementPtr(),
        ihipEvent_t.fromPyobj(event).getElementPtr()))
    return (_hipIpcGetEventHandle__retval,)


@cython.embedsignature(True)
def hipIpcOpenEventHandle(object handle):
    r"""Opens an interprocess event handles.

    Opens an interprocess event handle exported from another process with hipIpcGetEventHandle. The returned
    hipEvent_t behaves like a locally created event with the hipEventDisableTiming flag specified. This event
    need be freed with hipEventDestroy. Operations on the imported event after the exported event has been freed
    with hipEventDestroy will result in undefined behavior. If the function is called within the same process where
    handle is returned by hipIpcGetEventHandle, it will return hipErrorInvalidContext.

    Note:
        This IPC event related feature API is currently applicable on Linux.

    Args:
        handle (`~.hipIpcEventHandle_st`) -- *IN*:
            The opaque interprocess handle to open

    Returns:
        A `~.tuple` of size 2 that contains (in that order):

        * `~.hipError_t`: `~.hipSuccess`, `~.hipErrorInvalidValue`, `~.hipErrorInvalidContext`
        * `~.ihipEvent_t`:
                Pointer to hipEvent_t to return the event
    """
    event = ihipEvent_t.fromPtr(NULL)
    _hipIpcOpenEventHandle__retval = hipError_t(chip.hipIpcOpenEventHandle(<chip.ihipEvent_t**>&event._ptr,
        hipIpcEventHandle_st.fromPyobj(handle).getElementPtr()[0]))
    return (_hipIpcOpenEventHandle__retval,None if event._ptr == NULL else event)


@cython.embedsignature(True)
def hipFuncSetAttribute(object func, object attr, int value):
    r"""Set attribute for a specific function

    This section describes the execution control functions of HIP runtime API.

    Note: AMD devices and some Nvidia GPUS do not support shared cache banking, and the hint is
    ignored on those architectures.

    Args:
        func (`~.hip._util.types.Pointer`/`~.object`) -- *IN*:
            Pointer of the function

        attr (`~.hipFuncAttribute`) -- *IN*:
            Attribute to set

        value (`~.int`) -- *IN*:
            Value to set

    Returns:
        A `~.tuple` of size 1 that contains (in that order):

        * `~.hipError_t`: `~.hipSuccess`, `~.hipErrorInvalidDeviceFunction`, `~.hipErrorInvalidValue`
    """
    if not isinstance(attr,_hipFuncAttribute__Base):
        raise TypeError("argument 'attr' must be of type '_hipFuncAttribute__Base'")
    _hipFuncSetAttribute__retval = hipError_t(chip.hipFuncSetAttribute(
        <const void *>hip._util.types.Pointer.fromPyobj(func)._ptr,attr.value,value))
    return (_hipFuncSetAttribute__retval,)


@cython.embedsignature(True)
def hipFuncSetCacheConfig(object func, object config):
    r"""Set Cache configuration for a specific function

    Args:
        func (`~.hip._util.types.Pointer`/`~.object`) -- *IN*:
            Pointer of the function.

        config (`~.hipFuncCache_t`) -- *IN*:
            Configuration to set.

    Returns:
        A `~.tuple` of size 1 that contains (in that order):

        * `~.hipError_t`: `~.hipSuccess`, `~.hipErrorNotInitialized`
            Note: AMD devices and some Nvidia GPUS do not support reconfigurable cache.  This hint is ignored
            on those architectures.
    """
    if not isinstance(config,_hipFuncCache_t__Base):
        raise TypeError("argument 'config' must be of type '_hipFuncCache_t__Base'")
    _hipFuncSetCacheConfig__retval = hipError_t(chip.hipFuncSetCacheConfig(
        <const void *>hip._util.types.Pointer.fromPyobj(func)._ptr,config.value))
    return (_hipFuncSetCacheConfig__retval,)


@cython.embedsignature(True)
def hipFuncSetSharedMemConfig(object func, object config):
    r"""Set shared memory configuation for a specific function

    Note: AMD devices and some Nvidia GPUS do not support shared cache banking, and the hint is
    ignored on those architectures.

    Args:
        func (`~.hip._util.types.Pointer`/`~.object`) -- *IN*:
            Pointer of the function

        config (`~.hipSharedMemConfig`) -- *IN*:
            Configuration

    Returns:
        A `~.tuple` of size 1 that contains (in that order):

        * `~.hipError_t`: `~.hipSuccess`, `~.hipErrorInvalidDeviceFunction`, `~.hipErrorInvalidValue`
    """
    if not isinstance(config,_hipSharedMemConfig__Base):
        raise TypeError("argument 'config' must be of type '_hipSharedMemConfig__Base'")
    _hipFuncSetSharedMemConfig__retval = hipError_t(chip.hipFuncSetSharedMemConfig(
        <const void *>hip._util.types.Pointer.fromPyobj(func)._ptr,config.value))
    return (_hipFuncSetSharedMemConfig__retval,)


@cython.embedsignature(True)
def hipGetLastError():
    r"""Return last error returned by any HIP runtime API call and resets the stored error code to
    `~.hipSuccess`

    This section describes the error handling functions of HIP runtime API.

    Returns the last error that has been returned by any of the runtime calls in the same host
    thread, and then resets the saved error to `~.hipSuccess`.

    See:
        `~.hipGetErrorString`, `~.hipGetLastError`, `~.hipPeakAtLastError`, `~.hipError_t`

    Returns:
        A `~.tuple` of size 1 that contains (in that order):

        * `~.hipError_t`: return code from last HIP called from the active host thread
    """
    _hipGetLastError__retval = hipError_t(chip.hipGetLastError())
    return (_hipGetLastError__retval,)


@cython.embedsignature(True)
def hipExtGetLastError():
    r"""Return last error returned by any HIP runtime API call and resets the stored error code to
    `~.hipSuccess`

    Returns the last error that has been returned by any of the runtime calls in the same host
    thread, and then resets the saved error to `~.hipSuccess`.

    See:
        `~.hipGetErrorString`, `~.hipGetLastError`, `~.hipPeakAtLastError`, `~.hipError_t`

    Returns:
        A `~.tuple` of size 1 that contains (in that order):

        * `~.hipError_t`: return code from last HIP called from the active host thread
    """
    _hipExtGetLastError__retval = hipError_t(chip.hipExtGetLastError())
    return (_hipExtGetLastError__retval,)


@cython.embedsignature(True)
def hipPeekAtLastError():
    r"""Return last error returned by any HIP runtime API call.

    Returns the last error that has been returned by any of the runtime calls in the same host
    thread. Unlike hipGetLastError, this function does not reset the saved error code.

    See:
        `~.hipGetErrorString`, `~.hipGetLastError`, `~.hipPeakAtLastError`, `~.hipError_t`

    Returns:
        A `~.tuple` of size 1 that contains (in that order):

        * `~.hipError_t`: `~.hipSuccess`
    """
    _hipPeekAtLastError__retval = hipError_t(chip.hipPeekAtLastError())
    return (_hipPeekAtLastError__retval,)


@cython.embedsignature(True)
def hipGetErrorName(object hip_error):
    r"""Return hip error as text string form.

    See:
        `~.hipGetErrorString`, `~.hipGetLastError`, `~.hipPeakAtLastError`, `~.hipError_t`

    Args:
        hip_error (`~.hipError_t`):
            Error code to convert to name.

    Returns:
        A `~.tuple` of size 2 that contains (in that order):

        * `~.hipError_t`:
                Always returns `~.hipError_t.hipSuccess`.
        * `~.bytes`: const char pointer to the NULL-terminated error name
    """
    if not isinstance(hip_error,_hipError_t__Base):
        raise TypeError("argument 'hip_error' must be of type '_hipError_t__Base'")
    _hipGetErrorName__retval = hip._util.types.CStr.fromPtr(<void*>chip.hipGetErrorName(hip_error.value))
    return (hipError_t.hipSuccess,None if _hipGetErrorName__retval._ptr == NULL else _hipGetErrorName__retval)


@cython.embedsignature(True)
def hipGetErrorString(object hipError):
    r"""Return handy text string message to explain the error which occurred

    See:
        `~.hipGetErrorName`, `~.hipGetLastError`, `~.hipPeakAtLastError`, `~.hipError_t`

    Args:
        hipError (`~.hipError_t`):
            Error code to convert to string.

    Returns:
        A `~.tuple` of size 2 that contains (in that order):

        * `~.hipError_t`:
                Always returns `~.hipError_t.hipSuccess`.
        * `~.bytes`: const char pointer to the NULL-terminated error string
    """
    if not isinstance(hipError,_hipError_t__Base):
        raise TypeError("argument 'hipError' must be of type '_hipError_t__Base'")
    _hipGetErrorString__retval = hip._util.types.CStr.fromPtr(<void*>chip.hipGetErrorString(hipError.value))
    return (hipError_t.hipSuccess,None if _hipGetErrorString__retval._ptr == NULL else _hipGetErrorString__retval)


@cython.embedsignature(True)
def hipDrvGetErrorName(object hipError):
    r"""Return hip error as text string form.

    See:
        `~.hipGetErrorName`, `~.hipGetLastError`, `~.hipPeakAtLastError`, `~.hipError_t`

    Args:
        hipError (`~.hipError_t`) -- *IN*:
            Error code to convert to string.

    Returns:
        A `~.tuple` of size 2 that contains (in that order):

        * `~.hipError_t`: `~.hipSuccess`, `~.hipErrorInvalidValue`
        * `~.hip._util.types.CStr`/`~.object`:
                char pointer to the NULL-terminated error string
    """
    if not isinstance(hipError,_hipError_t__Base):
        raise TypeError("argument 'hipError' must be of type '_hipError_t__Base'")                    
    errorString = hip._util.types.CStr.fromPtr(NULL)
    _hipDrvGetErrorName__retval = hipError_t(chip.hipDrvGetErrorName(hipError.value,
        <const char **>&errorString._ptr))
    return (_hipDrvGetErrorName__retval,None if errorString._ptr == NULL else errorString)


@cython.embedsignature(True)
def hipDrvGetErrorString(object hipError):
    r"""Return handy text string message to explain the error which occurred

    See:
        `~.hipGetErrorName`, `~.hipGetLastError`, `~.hipPeakAtLastError`, `~.hipError_t`

    Args:
        hipError (`~.hipError_t`) -- *IN*:
            Error code to convert to string.

    Returns:
        A `~.tuple` of size 2 that contains (in that order):

        * `~.hipError_t`: `~.hipSuccess`, `~.hipErrorInvalidValue`
        * `~.hip._util.types.CStr`/`~.object`:
                char pointer to the NULL-terminated error string
    """
    if not isinstance(hipError,_hipError_t__Base):
        raise TypeError("argument 'hipError' must be of type '_hipError_t__Base'")                    
    errorString = hip._util.types.CStr.fromPtr(NULL)
    _hipDrvGetErrorString__retval = hipError_t(chip.hipDrvGetErrorString(hipError.value,
        <const char **>&errorString._ptr))
    return (_hipDrvGetErrorString__retval,None if errorString._ptr == NULL else errorString)


@cython.embedsignature(True)
def hipStreamCreate():
    r"""Create an asynchronous stream.

    Create a new asynchronous stream.  ``stream`` returns an opaque handle that can be used to
    reference the newly created stream in subsequent hipStream* commands.  The stream is allocated on
    the heap and will remain allocated even if the handle goes out-of-scope.  To release the memory
    used by the stream, application must call hipStreamDestroy.

    See:
        `~.hipStreamCreateWithFlags`, `~.hipStreamCreateWithPriority`, `~.hipStreamSynchronize`, `~.hipStreamWaitEvent`, `~.hipStreamDestroy`

    Returns:
        A `~.tuple` of size 2 that contains (in that order):

        * `~.hipError_t`: One of:
                -        `~.hipSuccess`, `~.hipErrorInvalidValue`

                - `~.hipSuccess`, `~.hipErrorInvalidValue`
        * `~.ihipStream_t`:
                Valid pointer to hipStream_t.  This function writes the memory with the
                newly created stream.
    """
    stream = ihipStream_t.fromPtr(NULL)
    _hipStreamCreate__retval = hipError_t(chip.hipStreamCreate(<chip.ihipStream_t**>&stream._ptr))
    return (_hipStreamCreate__retval,None if stream._ptr == NULL else stream)


@cython.embedsignature(True)
def hipStreamCreateWithFlags(unsigned int flags):
    r"""Create an asynchronous stream.

    Create a new asynchronous stream.  ``stream`` returns an opaque handle that can be used to
    reference the newly created stream in subsequent hipStream* commands.  The stream is allocated on
    the heap and will remain allocated even if the handle goes out-of-scope.  To release the memory
    used by the stream, application must call hipStreamDestroy. Flags controls behavior of the
    stream.  See `~.hipStreamDefault`, `~.hipStreamNonBlocking`.

    See:
        `~.hipStreamCreate`, `~.hipStreamCreateWithPriority`, `~.hipStreamSynchronize`, `~.hipStreamWaitEvent`, `~.hipStreamDestroy`

    Args:
        flags (`~.int`) -- *IN*:
            to control stream creation.

    Returns:
        A `~.tuple` of size 2 that contains (in that order):

        * `~.hipError_t`: `~.hipSuccess`, `~.hipErrorInvalidValue`
        * `~.ihipStream_t`:
                Pointer to new stream
    """
    stream = ihipStream_t.fromPtr(NULL)
    _hipStreamCreateWithFlags__retval = hipError_t(chip.hipStreamCreateWithFlags(<chip.ihipStream_t**>&stream._ptr,flags))
    return (_hipStreamCreateWithFlags__retval,None if stream._ptr == NULL else stream)


@cython.embedsignature(True)
def hipStreamCreateWithPriority(unsigned int flags, int priority):
    r"""Create an asynchronous stream with the specified priority.

    Create a new asynchronous stream with the specified priority.  ``stream`` returns an opaque handle
    that can be used to reference the newly created stream in subsequent hipStream* commands.  The
    stream is allocated on the heap and will remain allocated even if the handle goes out-of-scope.
    To release the memory used by the stream, application must call hipStreamDestroy. Flags controls
    behavior of the stream.  See `~.hipStreamDefault`, `~.hipStreamNonBlocking`.

    See:
        `~.hipStreamCreate`, `~.hipStreamSynchronize`, `~.hipStreamWaitEvent`, `~.hipStreamDestroy`

    Args:
        flags (`~.int`) -- *IN*:
            to control stream creation.

        priority (`~.int`) -- *IN*:
            of the stream. Lower numbers represent higher priorities.

    Returns:
        A `~.tuple` of size 2 that contains (in that order):

        * `~.hipError_t`: `~.hipSuccess`, `~.hipErrorInvalidValue`
        * `~.ihipStream_t`:
                Pointer to new stream
    """
    stream = ihipStream_t.fromPtr(NULL)
    _hipStreamCreateWithPriority__retval = hipError_t(chip.hipStreamCreateWithPriority(<chip.ihipStream_t**>&stream._ptr,flags,priority))
    return (_hipStreamCreateWithPriority__retval,None if stream._ptr == NULL else stream)


@cython.embedsignature(True)
def hipDeviceGetStreamPriorityRange():
    r"""Returns numerical values that correspond to the least and greatest stream priority.

    Returns in *leastPriority and *greatestPriority the numerical values that correspond to the least
    and greatest stream priority respectively. Stream priorities follow a convention where lower numbers
    imply greater priorities. The range of meaningful stream priorities is given by
    [*greatestPriority, *leastPriority]. If the user attempts to create a stream with a priority value
    that is outside the meaningful range as specified by this API, the priority is automatically
    clamped to within the valid range.

    Returns:
        A `~.tuple` of size 3 that contains (in that order):

        * `~.hipError_t`: `~.hipSuccess`
        * `~.int`:
                pointer in which value corresponding to least priority is returned.
        * `~.int`:
                pointer in which value corresponding to greatest priority is returned.
    """
    cdef int leastPriority
    cdef int greatestPriority
    _hipDeviceGetStreamPriorityRange__retval = hipError_t(chip.hipDeviceGetStreamPriorityRange(&leastPriority,&greatestPriority))
    return (_hipDeviceGetStreamPriorityRange__retval,leastPriority,greatestPriority)


@cython.embedsignature(True)
def hipStreamDestroy(object stream):
    r"""Destroys the specified stream.

    Destroys the specified stream.

    If commands are still executing on the specified stream, some may complete execution before the
    queue is deleted.

    The queue may be destroyed while some commands are still inflight, or may wait for all commands
    queued to the stream before destroying it.

    See:
        `~.hipStreamCreate`, `~.hipStreamCreateWithFlags`, `~.hipStreamCreateWithPriority`, `~.hipStreamQuery`,
        `~.hipStreamWaitEvent`, `~.hipStreamSynchronize`

    Args:
        stream (`~.ihipStream_t`/`~.object`) -- *IN*:
            stream identifier.

    Returns:
        A `~.tuple` of size 1 that contains (in that order):

        * `~.hipError_t`: `~.hipSuccess` `~.hipErrorInvalidHandle`
    """
    _hipStreamDestroy__retval = hipError_t(chip.hipStreamDestroy(
        ihipStream_t.fromPyobj(stream).getElementPtr()))
    return (_hipStreamDestroy__retval,)


@cython.embedsignature(True)
def hipStreamQuery(object stream):
    r"""Return `~.hipSuccess` if all of the operations in the specified ``stream`` have completed, or
    `~.hipErrorNotReady` if not.

    This is thread-safe and returns a snapshot of the current state of the queue.  However, if other
    host threads are sending work to the stream, the status may change immediately after the function
    is called.  It is typically used for debug.

    See:
        `~.hipStreamCreate`, `~.hipStreamCreateWithFlags`, `~.hipStreamCreateWithPriority`, `~.hipStreamWaitEvent`,
        `~.hipStreamSynchronize`, `~.hipStreamDestroy`

    Args:
        stream (`~.ihipStream_t`/`~.object`) -- *IN*:
            stream to query

    Returns:
        A `~.tuple` of size 1 that contains (in that order):

        * `~.hipError_t`: `~.hipSuccess`, `~.hipErrorNotReady`, `~.hipErrorInvalidHandle`
    """
    _hipStreamQuery__retval = hipError_t(chip.hipStreamQuery(
        ihipStream_t.fromPyobj(stream).getElementPtr()))
    return (_hipStreamQuery__retval,)


@cython.embedsignature(True)
def hipStreamSynchronize(object stream):
    r"""Wait for all commands in stream to complete.

    This command is host-synchronous : the host will block until the specified stream is empty.

    This command follows standard null-stream semantics.  Specifically, specifying the null stream
    will cause the command to wait for other streams on the same device to complete all pending
    operations.

    This command honors the hipDeviceLaunchBlocking flag, which controls whether the wait is active
    or blocking.

    See:
        `~.hipStreamCreate`, `~.hipStreamCreateWithFlags`, `~.hipStreamCreateWithPriority`, `~.hipStreamWaitEvent`,
        `~.hipStreamDestroy`

    Args:
        stream (`~.ihipStream_t`/`~.object`) -- *IN*:
            stream identifier.

    Returns:
        A `~.tuple` of size 1 that contains (in that order):

        * `~.hipError_t`: `~.hipSuccess`, `~.hipErrorInvalidHandle`
    """
    _hipStreamSynchronize__retval = hipError_t(chip.hipStreamSynchronize(
        ihipStream_t.fromPyobj(stream).getElementPtr()))
    return (_hipStreamSynchronize__retval,)


@cython.embedsignature(True)
def hipStreamWaitEvent(object stream, object event, unsigned int flags):
    r"""Make the specified compute stream wait for an event

    This function inserts a wait operation into the specified stream.
    All future work submitted to ``stream`` will wait until ``event`` reports completion before
    beginning execution.

    This function only waits for commands in the current stream to complete.  Notably, this function
    does not implicitly wait for commands in the default stream to complete, even if the specified
    stream is created with hipStreamNonBlocking = 0.

    See:
        `~.hipStreamCreate`, `~.hipStreamCreateWithFlags`, `~.hipStreamCreateWithPriority`, `~.hipStreamSynchronize`, `~.hipStreamDestroy`

    Args:
        stream (`~.ihipStream_t`/`~.object`) -- *IN*:
            stream to make wait.

        event (`~.ihipEvent_t`/`~.object`) -- *IN*:
            event to wait on

        flags (`~.int`) -- *IN*:
            control operation [must be 0]

    Returns:
        A `~.tuple` of size 1 that contains (in that order):

        * `~.hipError_t`: `~.hipSuccess`, `~.hipErrorInvalidHandle`
    """
    _hipStreamWaitEvent__retval = hipError_t(chip.hipStreamWaitEvent(
        ihipStream_t.fromPyobj(stream).getElementPtr(),
        ihipEvent_t.fromPyobj(event).getElementPtr(),flags))
    return (_hipStreamWaitEvent__retval,)


@cython.embedsignature(True)
def hipStreamGetFlags(object stream):
    r"""Return flags associated with this stream.

    Return flags associated with this stream in *``flags.``

    See:
        `~.hipStreamCreateWithFlags`

    Args:
        stream (`~.ihipStream_t`/`~.object`) -- *IN*:
            stream to be queried

    Returns:
        A `~.tuple` of size 2 that contains (in that order):

        * `~.hipError_t`: One of:
                -        `~.hipSuccess`, `~.hipErrorInvalidValue`, `~.hipErrorInvalidHandle`

                - `~.hipSuccess` `~.hipErrorInvalidValue` `~.hipErrorInvalidHandle`
        * `~.int`:
                Pointer to an unsigned integer in which the stream's flags are returned
    """
    cdef unsigned int flags
    _hipStreamGetFlags__retval = hipError_t(chip.hipStreamGetFlags(
        ihipStream_t.fromPyobj(stream).getElementPtr(),&flags))
    return (_hipStreamGetFlags__retval,flags)


@cython.embedsignature(True)
def hipStreamGetPriority(object stream):
    r"""Query the priority of a stream.

    Query the priority of a stream. The priority is returned in in priority.

    See:
        `~.hipStreamCreateWithFlags`

    Args:
        stream (`~.ihipStream_t`/`~.object`) -- *IN*:
            stream to be queried

    Returns:
        A `~.tuple` of size 2 that contains (in that order):

        * `~.hipError_t`: One of:
                -        `~.hipSuccess`, `~.hipErrorInvalidValue`, `~.hipErrorInvalidHandle`

                - `~.hipSuccess` `~.hipErrorInvalidValue` `~.hipErrorInvalidHandle`
        * `~.int`:
                Pointer to an unsigned integer in which the stream's priority is returned
    """
    cdef int priority
    _hipStreamGetPriority__retval = hipError_t(chip.hipStreamGetPriority(
        ihipStream_t.fromPyobj(stream).getElementPtr(),&priority))
    return (_hipStreamGetPriority__retval,priority)


@cython.embedsignature(True)
def hipStreamGetDevice(object stream):
    r"""Get the device assocaited with the stream

    See:
        `~.hipStreamCreate`, `~.hipStreamDestroy`, `~.hipDeviceGetStreamPriorityRange`

    Args:
        stream (`~.ihipStream_t`/`~.object`) -- *IN*:
            stream to be queried

    Returns:
        A `~.tuple` of size 2 that contains (in that order):

        * `~.hipError_t`: `~.hipSuccess`, `~.hipErrorInvalidValue`, `~.hipErrorContextIsDestroyed`, `~.hipErrorInvalidHandle`,
            `~.hipErrorNotInitialized`, `~.hipErrorDeinitialized`, `~.hipErrorInvalidContext`
        * `~.int`:
                device associated with the stream
    """
    cdef int device
    _hipStreamGetDevice__retval = hipError_t(chip.hipStreamGetDevice(
        ihipStream_t.fromPyobj(stream).getElementPtr(),&device))
    return (_hipStreamGetDevice__retval,device)


@cython.embedsignature(True)
def hipExtStreamCreateWithCUMask(unsigned int cuMaskSize):
    r"""Create an asynchronous stream with the specified CU mask.

    Create a new asynchronous stream with the specified CU mask.  ``stream`` returns an opaque handle
    that can be used to reference the newly created stream in subsequent hipStream* commands.  The
    stream is allocated on the heap and will remain allocated even if the handle goes out-of-scope.
    To release the memory used by the stream, application must call hipStreamDestroy.

    See:
        `~.hipStreamCreate`, `~.hipStreamSynchronize`, `~.hipStreamWaitEvent`, `~.hipStreamDestroy`

    Args:
        cuMaskSize (`~.int`) -- *IN*:
            Size of CU mask bit array passed in.

    Returns:
        A `~.tuple` of size 3 that contains (in that order):

        * `~.hipError_t`: `~.hipSuccess`, `~.hipErrorInvalidHandle`, `~.hipErrorInvalidValue`
        * `~.ihipStream_t`:
                Pointer to new stream
        * `~.int`:
                Bit-vector representing the CU mask. Each active bit represents using one CU.
                The first 32 bits represent the first 32 CUs, and so on. If its size is greater than physical
                CU number (i.e., multiProcessorCount member of hipDeviceProp_t), the extra elements are ignored.
                It is user's responsibility to make sure the input is meaningful.
    """
    stream = ihipStream_t.fromPtr(NULL)
    cdef const unsigned int cuMask
    _hipExtStreamCreateWithCUMask__retval = hipError_t(chip.hipExtStreamCreateWithCUMask(<chip.ihipStream_t**>&stream._ptr,cuMaskSize,&cuMask))
    return (_hipExtStreamCreateWithCUMask__retval,None if stream._ptr == NULL else stream,cuMask)


@cython.embedsignature(True)
def hipExtStreamGetCUMask(object stream, unsigned int cuMaskSize):
    r"""Get CU mask associated with an asynchronous stream

    See:
        `~.hipStreamCreate`, `~.hipStreamSynchronize`, `~.hipStreamWaitEvent`, `~.hipStreamDestroy`

    Args:
        stream (`~.ihipStream_t`/`~.object`) -- *IN*:
            stream to be queried

        cuMaskSize (`~.int`) -- *IN*:
            number of the block of memories (uint32_t *) allocated by user

    Returns:
        A `~.tuple` of size 2 that contains (in that order):

        * `~.hipError_t`: `~.hipSuccess`, `~.hipErrorInvalidHandle`, `~.hipErrorInvalidValue`
        * `~.int`:
                Pointer to a pre-allocated block of memories (uint32_t *) in which
                the stream's CU mask is returned. The CU mask is returned in a chunck of 32 bits where
                each active bit represents one active CU
    """
    cdef unsigned int cuMask
    _hipExtStreamGetCUMask__retval = hipError_t(chip.hipExtStreamGetCUMask(
        ihipStream_t.fromPyobj(stream).getElementPtr(),cuMaskSize,&cuMask))
    return (_hipExtStreamGetCUMask__retval,cuMask)


cdef class hipStreamCallback_t(hip._util.types.Pointer):
    """Python wrapper for cdef class chip.hipStreamCallback_t.

    Python wrapper for cdef class chip.hipStreamCallback_t.

    If this type is initialized via its `__init__` method, it allocates a
    member of the underlying C type and destroys it again if the wrapper
    type is deallocated.

    This type also serves as adapter when appearing as argument type in a
    function signature. In this case, the type can further be initialized
    from a number of Python objects:

    * `None`:

      This will set the ``self._ptr`` attribute to ``NULL``.

    * `int`:

      Interprets the integer value as pointer address and writes it to ``self._ptr``.
      No ownership is transferred.

    * `ctypes.c_void_p`:

      Takes the pointer address ``pyobj.value`` and writes it to ``self._ptr``.
      No ownership is transferred.

    * `object` that implements the `CUDA Array Interface <https://numba.readthedocs.io/en/stable/cuda/cuda_array_interface.html>`_ protocol:

      Takes the integer-valued pointer address, i.e. the first entry of the `data` tuple
      from `pyobj`'s member ``__cuda_array_interface__``  and writes it to ``self._ptr``.

    * `object` that implements the Python buffer protocol:

      If the object represents a simple contiguous array,
      writes the `Py_buffer` associated with ``pyobj`` to `self._py_buffer`,
      sets the `self._py_buffer_acquired` flag to `True`, and
      writes `self._py_buffer.buf` to the data pointer `self._ptr`.

    * `hip._util.types.Pointer`:

      Takes the pointer address ``pyobj._ptr`` and writes it to ``self._ptr``.
      No ownership is transferred.

    Type checks are performed in the above order.

    C Attributes:
        _ptr (C type ``void *``, protected):
            Stores a pointer to the data of the original Python object.
        _is_ptr_owner (C type ``bint``, protected):
            If this wrapper is the owner of the underlying data.
        _py_buffer (C type ``Py_buffer`, protected):
            Stores a pointer to the data of the original Python object.
        _py_buffer_acquired (C type ``bint``, protected):
            Stores a pointer to the data of the original Python object.
    """
    # C members declared in pxd file

    def __cinit__(self):
        self._ptr = NULL
        self._is_ptr_owner = False
        self._py_buffer_acquired = False

    cdef chip.hipStreamCallback_t getElementPtr(self):
        return <chip.hipStreamCallback_t>self._ptr

    @staticmethod
    cdef hipStreamCallback_t fromPtr(void* ptr, bint owner=False):
        """Factory function to create ``hipStreamCallback_t`` objects from
        given ``chip.hipStreamCallback_t`` pointer.
        """
        # Fast call to __new__() that bypasses the __init__() constructor.
        cdef hipStreamCallback_t wrapper = hipStreamCallback_t.__new__(hipStreamCallback_t)
        wrapper._ptr = ptr
        wrapper._is_ptr_owner = owner
        return wrapper

    @staticmethod
    def fromObj(pyobj):
        """Creates a hipStreamCallback_t from a Python object.

        Derives a hipStreamCallback_t from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``hipStreamCallback_t`` reference, this method
        returns it directly. No new ``hipStreamCallback_t`` is created in this case.
        """
        return hipStreamCallback_t.fromPyobj(pyobj)

    @staticmethod
    cdef hipStreamCallback_t fromPyobj(object pyobj):
        """Creates a hipStreamCallback_t from a Python object.

        Derives a hipStreamCallback_t from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``hipStreamCallback_t`` reference, this method
        returns it directly. No new ``hipStreamCallback_t`` is created in this case.

        Args:
            pyobj (object): Must be either `None`; a `hip._util.types.Pointer`; a simple, contiguous buffer according to the buffer protocol;
                            or of type `hipStreamCallback_t`; `int`; or `ctypes.c_void_p`.

        Note:
            This routine does not perform a copy but returns the original ``pyobj``
            if ``pyobj`` is an instance of hipStreamCallback_t!
        """
        cdef hipStreamCallback_t wrapper

        if isinstance(pyobj,hipStreamCallback_t):
            return pyobj
        else:
            wrapper = hipStreamCallback_t.__new__(hipStreamCallback_t)
            wrapper.init_from_pyobj(pyobj)
            return wrapper

    def __dealloc__(self):
        # Release the buffer handle
        if self._py_buffer_acquired is True:
            cpython.buffer.PyBuffer_Release(&self._py_buffer)

    def __int__(self):
        """Returns the data's address as long integer.
        """
        return cpython.long.PyLong_FromVoidPtr(self._ptr)

    def __repr__(self):
        return f"<hipStreamCallback_t object, ptr: {int(self)}>"

    def as_c_void_p(self):
        """Returns the data's address as `ctypes.c_void_p`
        Note:
            Implemented as function to not collide with
            autogenerated property names.
        """
        return ctypes.c_void_p(int(self))


@cython.embedsignature(True)
def hipStreamAddCallback(object stream, object callback, object userData, unsigned int flags):
    r"""Adds a callback to be called on the host after all currently enqueued
    items in the stream have completed.  For each
    hipStreamAddCallback call, a callback will be executed exactly once.
    The callback will block later work in the stream until it is finished.

    See:
        `~.hipStreamCreate`, `~.hipStreamCreateWithFlags`, `~.hipStreamQuery`, `~.hipStreamSynchronize`,
        `~.hipStreamWaitEvent`, `~.hipStreamDestroy`, `~.hipStreamCreateWithPriority`

    Args:
        stream (`~.ihipStream_t`/`~.object`) -- *IN*:
            - Stream to add callback to

        callback (`~.hipStreamCallback_t`/`~.object`) -- *IN*:
            - The function to call once preceding stream operations are complete

        userData (`~.hip._util.types.Pointer`/`~.object`) -- *IN*:
            - User specified data to be passed to the callback function

        flags (`~.int`) -- *IN*:
            - Reserved for future use, must be 0

    Returns:
        A `~.tuple` of size 1 that contains (in that order):

        * `~.hipError_t`: `~.hipSuccess`, `~.hipErrorInvalidHandle`, `~.hipErrorNotSupported`
    """
    _hipStreamAddCallback__retval = hipError_t(chip.hipStreamAddCallback(
        ihipStream_t.fromPyobj(stream).getElementPtr(),
        hipStreamCallback_t.fromPyobj(callback).getElementPtr(),
        <void *>hip._util.types.Pointer.fromPyobj(userData)._ptr,flags))
    return (_hipStreamAddCallback__retval,)


@cython.embedsignature(True)
def hipStreamWaitValue32(object stream, object ptr, unsigned int value, unsigned int flags, unsigned int mask):
    r"""Enqueues a wait command to the stream.[BETA]

    This section describes Stream Memory Wait and Write functions of HIP runtime API.

    Enqueues a wait command to the stream, all operations enqueued  on this stream after this, will
    not execute until the defined wait condition is true.

    hipStreamWaitValueGte: waits until *ptr&mask >= value
    hipStreamWaitValueEq : waits until *ptr&mask == value
    hipStreamWaitValueAnd: waits until ((*ptr&mask) & value) != 0
    hipStreamWaitValueNor: waits until ~((*ptr&mask) | (value&mask)) != 0

    Note:
        when using 'hipStreamWaitValueNor', mask is applied on both 'value' and '*ptr'.

    Note:
        Support for hipStreamWaitValue32 can be queried using 'hipDeviceGetAttribute()' and
        'hipDeviceAttributeCanUseStreamWaitValue' flag.

    Warning:
        This API is marked as beta, meaning, while this is feature complete,
        it is still open to changes and may have outstanding issues.

    See:
        `~.hipExtMallocWithFlags`, `~.hipFree`, `~.hipStreamWaitValue64`, `~.hipStreamWriteValue64`,
        `~.hipStreamWriteValue32`, `~.hipDeviceGetAttribute`

    Args:
        stream (`~.ihipStream_t`/`~.object`) -- *IN*:
            - Stream identifier

        ptr (`~.hip._util.types.Pointer`/`~.object`) -- *IN*:
            - Pointer to memory object allocated using 'hipMallocSignalMemory' flag

        value (`~.int`) -- *IN*:
            - Value to be used in compare operation

        flags (`~.int`) -- *IN*:
            - Defines the compare operation, supported values are hipStreamWaitValueGte
            hipStreamWaitValueEq, hipStreamWaitValueAnd and hipStreamWaitValueNor

        mask (`~.int`) -- *IN*:
            - Mask to be applied on value at memory before it is compared with value,
            default value is set to enable every bit

    Returns:
        A `~.tuple` of size 1 that contains (in that order):

        * `~.hipError_t`: `~.hipSuccess`, `~.hipErrorInvalidValue`
    """
    _hipStreamWaitValue32__retval = hipError_t(chip.hipStreamWaitValue32(
        ihipStream_t.fromPyobj(stream).getElementPtr(),
        <void *>hip._util.types.Pointer.fromPyobj(ptr)._ptr,value,flags,mask))
    return (_hipStreamWaitValue32__retval,)


@cython.embedsignature(True)
def hipStreamWaitValue64(object stream, object ptr, unsigned long value, unsigned int flags, unsigned long mask):
    r"""Enqueues a wait command to the stream.[BETA]

    Enqueues a wait command to the stream, all operations enqueued  on this stream after this, will
    not execute until the defined wait condition is true.

    hipStreamWaitValueGte: waits until *ptr&mask >= value
    hipStreamWaitValueEq : waits until *ptr&mask == value
    hipStreamWaitValueAnd: waits until ((*ptr&mask) & value) != 0
    hipStreamWaitValueNor: waits until ~((*ptr&mask) | (value&mask)) != 0

    Note:
        when using 'hipStreamWaitValueNor', mask is applied on both 'value' and '*ptr'.

    Note:
        Support for hipStreamWaitValue64 can be queried using 'hipDeviceGetAttribute()' and
        'hipDeviceAttributeCanUseStreamWaitValue' flag.

    Warning:
        This API is marked as beta, meaning, while this is feature complete,
        it is still open to changes and may have outstanding issues.

    See:
        `~.hipExtMallocWithFlags`, `~.hipFree`, `~.hipStreamWaitValue32`, `~.hipStreamWriteValue64`,
        `~.hipStreamWriteValue32`, `~.hipDeviceGetAttribute`

    Args:
        stream (`~.ihipStream_t`/`~.object`) -- *IN*:
            - Stream identifier

        ptr (`~.hip._util.types.Pointer`/`~.object`) -- *IN*:
            - Pointer to memory object allocated using 'hipMallocSignalMemory' flag

        value (`~.int`) -- *IN*:
            - Value to be used in compare operation

        flags (`~.int`) -- *IN*:
            - Defines the compare operation, supported values are hipStreamWaitValueGte
            hipStreamWaitValueEq, hipStreamWaitValueAnd and hipStreamWaitValueNor.

        mask (`~.int`) -- *IN*:
            - Mask to be applied on value at memory before it is compared with value
            default value is set to enable every bit

    Returns:
        A `~.tuple` of size 1 that contains (in that order):

        * `~.hipError_t`: `~.hipSuccess`, `~.hipErrorInvalidValue`
    """
    _hipStreamWaitValue64__retval = hipError_t(chip.hipStreamWaitValue64(
        ihipStream_t.fromPyobj(stream).getElementPtr(),
        <void *>hip._util.types.Pointer.fromPyobj(ptr)._ptr,value,flags,mask))
    return (_hipStreamWaitValue64__retval,)


@cython.embedsignature(True)
def hipStreamWriteValue32(object stream, object ptr, unsigned int value, unsigned int flags):
    r"""Enqueues a write command to the stream.[BETA]

    Enqueues a write command to the stream, write operation is performed after all earlier commands
    on this stream have completed the execution.

    Warning:
        This API is marked as beta, meaning, while this is feature complete,
        it is still open to changes and may have outstanding issues.

    See:
        `~.hipExtMallocWithFlags`, `~.hipFree`, `~.hipStreamWriteValue32`, `~.hipStreamWaitValue32`,
        `~.hipStreamWaitValue64`

    Args:
        stream (`~.ihipStream_t`/`~.object`) -- *IN*:
            - Stream identifier

        ptr (`~.hip._util.types.Pointer`/`~.object`) -- *IN*:
            - Pointer to a GPU accessible memory object

        value (`~.int`) -- *IN*:
            - Value to be written

        flags (`~.int`) -- *IN*:
            - reserved, ignored for now, will be used in future releases

    Returns:
        A `~.tuple` of size 1 that contains (in that order):

        * `~.hipError_t`: `~.hipSuccess`, `~.hipErrorInvalidValue`
    """
    _hipStreamWriteValue32__retval = hipError_t(chip.hipStreamWriteValue32(
        ihipStream_t.fromPyobj(stream).getElementPtr(),
        <void *>hip._util.types.Pointer.fromPyobj(ptr)._ptr,value,flags))
    return (_hipStreamWriteValue32__retval,)


@cython.embedsignature(True)
def hipStreamWriteValue64(object stream, object ptr, unsigned long value, unsigned int flags):
    r"""Enqueues a write command to the stream.[BETA]

    Enqueues a write command to the stream, write operation is performed after all earlier commands
    on this stream have completed the execution.

    Warning:
        This API is marked as beta, meaning, while this is feature complete,
        it is still open to changes and may have outstanding issues.

    See:
        `~.hipExtMallocWithFlags`, `~.hipFree`, `~.hipStreamWriteValue32`, `~.hipStreamWaitValue32`,
        `~.hipStreamWaitValue64`

    Args:
        stream (`~.ihipStream_t`/`~.object`) -- *IN*:
            - Stream identifier

        ptr (`~.hip._util.types.Pointer`/`~.object`) -- *IN*:
            - Pointer to a GPU accessible memory object

        value (`~.int`) -- *IN*:
            - Value to be written

        flags (`~.int`) -- *IN*:
            - reserved, ignored for now, will be used in future releases

    Returns:
        A `~.tuple` of size 1 that contains (in that order):

        * `~.hipError_t`: `~.hipSuccess`, `~.hipErrorInvalidValue`
    """
    _hipStreamWriteValue64__retval = hipError_t(chip.hipStreamWriteValue64(
        ihipStream_t.fromPyobj(stream).getElementPtr(),
        <void *>hip._util.types.Pointer.fromPyobj(ptr)._ptr,value,flags))
    return (_hipStreamWriteValue64__retval,)


@cython.embedsignature(True)
def hipEventCreateWithFlags(unsigned int flags):
    r"""Create an event with the specified flags

    See:
        `~.hipEventCreate`, `~.hipEventSynchronize`, `~.hipEventDestroy`, `~.hipEventElapsedTime`

    Args:
        flags (`~.int`) -- *IN*:
            Flags to control event behavior.  Valid values are `~.hipEventDefault`,
            `~.hipEventBlockingSync`, `~.hipEventDisableTiming`, `~.hipEventInterprocess`
              `~.hipEventDefault` : Default flag.  The event will use active synchronization and will support
            timing.  Blocking synchronization provides lowest possible latency at the expense of dedicating a
            CPU to poll on the event.
              `~.hipEventBlockingSync` : The event will use blocking synchronization : if hipEventSynchronize is
            called on this event, the thread will block until the event completes.  This can increase latency
            for the synchroniation but can result in lower power and more resources for other CPU threads.
              `~.hipEventDisableTiming` : Disable recording of timing information. Events created with this flag
            would not record profiling data and provide best performance if used for synchronization.
              `~.hipEventInterprocess` : The event can be used as an interprocess event. hipEventDisableTiming
            flag also must be set when hipEventInterprocess flag is set.
              `~.hipEventDisableSystemFence` : Disable acquire and release system scope fence. This may
            improve performance but device memory may not be visible to the host and other devices
            if this flag is set.

    Returns:
        A `~.tuple` of size 2 that contains (in that order):

        * `~.hipError_t`: `~.hipSuccess`, `~.hipErrorNotInitialized`, `~.hipErrorInvalidValue`,
            `~.hipErrorLaunchFailure`, `~.hipErrorOutOfMemory`
        * `~.ihipEvent_t`:
                Returns the newly created event.
    """
    event = ihipEvent_t.fromPtr(NULL)
    _hipEventCreateWithFlags__retval = hipError_t(chip.hipEventCreateWithFlags(<chip.ihipEvent_t**>&event._ptr,flags))
    return (_hipEventCreateWithFlags__retval,None if event._ptr == NULL else event)


@cython.embedsignature(True)
def hipEventCreate():
    r"""(No short description, might be part of a group.)

    Create an event

    See:
        `~.hipEventCreateWithFlags`, `~.hipEventRecord`, `~.hipEventQuery`, `~.hipEventSynchronize`,
        `~.hipEventDestroy`, `~.hipEventElapsedTime`

    Returns:
        A `~.tuple` of size 2 that contains (in that order):

        * `~.hipError_t`: `~.hipSuccess`, `~.hipErrorNotInitialized`, `~.hipErrorInvalidValue`,
            `~.hipErrorLaunchFailure`, `~.hipErrorOutOfMemory`
        * `~.ihipEvent_t`:
                Returns the newly created event.
    """
    event = ihipEvent_t.fromPtr(NULL)
    _hipEventCreate__retval = hipError_t(chip.hipEventCreate(<chip.ihipEvent_t**>&event._ptr))
    return (_hipEventCreate__retval,None if event._ptr == NULL else event)


@cython.embedsignature(True)
def hipEventRecord(object event, object stream):
    r"""(No short description, might be part of a group.)

    Args:
        event (`~.ihipEvent_t`/`~.object`):
            (undocumented)

        stream (`~.ihipStream_t`/`~.object`):
            (undocumented)
    """
    _hipEventRecord__retval = hipError_t(chip.hipEventRecord(
        ihipEvent_t.fromPyobj(event).getElementPtr(),
        ihipStream_t.fromPyobj(stream).getElementPtr()))
    return (_hipEventRecord__retval,)


@cython.embedsignature(True)
def hipEventDestroy(object event):
    r"""Destroy the specified event.

    Releases memory associated with the event.  If the event is recording but has not completed
    recording when hipEventDestroy() is called, the function will return immediately and the
    completion_future resources will be released later, when the hipDevice is synchronized.

    See:
        `~.hipEventCreate`, `~.hipEventCreateWithFlags`, `~.hipEventQuery`, `~.hipEventSynchronize`, `~.hipEventRecord`,
        `~.hipEventElapsedTime`

    Args:
        event (`~.ihipEvent_t`/`~.object`) -- *IN*:
            Event to destroy.

    Returns:
        A `~.tuple` of size 1 that contains (in that order):

        * `~.hipError_t`: One of:
                -        `~.hipSuccess`, `~.hipErrorNotInitialized`, `~.hipErrorInvalidValue`,
                    `~.hipErrorLaunchFailure`

                - `~.hipSuccess`
    """
    _hipEventDestroy__retval = hipError_t(chip.hipEventDestroy(
        ihipEvent_t.fromPyobj(event).getElementPtr()))
    return (_hipEventDestroy__retval,)


@cython.embedsignature(True)
def hipEventSynchronize(object event):
    r"""Wait for an event to complete.

    This function will block until the event is ready, waiting for all previous work in the stream
    specified when event was recorded with hipEventRecord().

     If hipEventRecord() has not been called on ``event,`` this function returns `~.hipSuccess` when no
     event is captured.

    See:
        `~.hipEventCreate`, `~.hipEventCreateWithFlags`, `~.hipEventQuery`, `~.hipEventDestroy`, `~.hipEventRecord`,
        `~.hipEventElapsedTime`

    Args:
        event (`~.ihipEvent_t`/`~.object`) -- *IN*:
            Event on which to wait.

    Returns:
        A `~.tuple` of size 1 that contains (in that order):

        * `~.hipError_t`: `~.hipSuccess`, `~.hipErrorInvalidValue`, `~.hipErrorNotInitialized`,
            `~.hipErrorInvalidHandle`, `~.hipErrorLaunchFailure`
    """
    _hipEventSynchronize__retval = hipError_t(chip.hipEventSynchronize(
        ihipEvent_t.fromPyobj(event).getElementPtr()))
    return (_hipEventSynchronize__retval,)


@cython.embedsignature(True)
def hipEventElapsedTime(object start, object stop):
    r"""Return the elapsed time between two events.

    Computes the elapsed time between two events. Time is computed in ms, with
    a resolution of approximately 1 us.

    Events which are recorded in a NULL stream will block until all commands
    on all other streams complete execution, and then record the timestamp.

    Events which are recorded in a non-NULL stream will record their timestamp
    when they reach the head of the specified stream, after all previous
    commands in that stream have completed executing.  Thus the time that
    the event recorded may be significantly after the host calls hipEventRecord().

    If hipEventRecord() has not been called on either event, then `~.hipErrorInvalidHandle` is
    returned. If hipEventRecord() has been called on both events, but the timestamp has not yet been
    recorded on one or both events (that is, hipEventQuery() would return `~.hipErrorNotReady` on at
    least one of the events), then `~.hipErrorNotReady` is returned.

    See:
        `~.hipEventCreate`, `~.hipEventCreateWithFlags`, `~.hipEventQuery`, `~.hipEventDestroy`, `~.hipEventRecord`,
        `~.hipEventSynchronize`

    Args:
        start (`~.ihipEvent_t`/`~.object`) -- *IN*:
            Start event.

        stop (`~.ihipEvent_t`/`~.object`) -- *IN*:
            Stop event.

    Returns:
        A `~.tuple` of size 2 that contains (in that order):

        * `~.hipError_t`: `~.hipSuccess`, `~.hipErrorInvalidValue`, `~.hipErrorNotReady`, `~.hipErrorInvalidHandle`,
            `~.hipErrorNotInitialized`, `~.hipErrorLaunchFailure`
        * `~.float`:
                Return time between start and stop in ms.
    """
    cdef float ms
    _hipEventElapsedTime__retval = hipError_t(chip.hipEventElapsedTime(&ms,
        ihipEvent_t.fromPyobj(start).getElementPtr(),
        ihipEvent_t.fromPyobj(stop).getElementPtr()))
    return (_hipEventElapsedTime__retval,ms)


@cython.embedsignature(True)
def hipEventQuery(object event):
    r"""Query event status

    Query the status of the specified event.  This function will return `~.hipSuccess` if all
    commands in the appropriate stream (specified to hipEventRecord()) have completed.  If any execution
    has not completed, then `~.hipErrorNotReady` is returned.

    Note:
        This API returns `~.hipSuccess`, if hipEventRecord() is not called before this API.

    See:
        `~.hipEventCreate`, `~.hipEventCreateWithFlags`, `~.hipEventRecord`, `~.hipEventDestroy`,
        `~.hipEventSynchronize`, `~.hipEventElapsedTime`

    Args:
        event (`~.ihipEvent_t`/`~.object`) -- *IN*:
            Event to query.

    Returns:
        A `~.tuple` of size 1 that contains (in that order):

        * `~.hipError_t`: `~.hipSuccess`, `~.hipErrorNotReady`, `~.hipErrorInvalidHandle`, `~.hipErrorInvalidValue`,
            `~.hipErrorNotInitialized`, `~.hipErrorLaunchFailure`
    """
    _hipEventQuery__retval = hipError_t(chip.hipEventQuery(
        ihipEvent_t.fromPyobj(event).getElementPtr()))
    return (_hipEventQuery__retval,)


@cython.embedsignature(True)
def hipPointerSetAttribute(object value, object attribute, object ptr):
    r"""Sets information on the specified pointer.[BETA]

    Warning:
        This API is marked as beta, meaning, while this is feature complete,
        it is still open to changes and may have outstanding issues.

    Args:
        value (`~.hip._util.types.Pointer`/`~.object`) -- *IN*:
            Sets pointer attribute value

        attribute (`~.hipPointer_attribute`) -- *IN*:
            Attribute to set

        ptr (`~.hip._util.types.Pointer`/`~.object`) -- *IN*:
            Pointer to set attributes for

    Returns:
        A `~.tuple` of size 1 that contains (in that order):

        * `~.hipError_t`: `~.hipSuccess`, `~.hipErrorInvalidDevice`, `~.hipErrorInvalidValue`
    """
    if not isinstance(attribute,_hipPointer_attribute__Base):
        raise TypeError("argument 'attribute' must be of type '_hipPointer_attribute__Base'")
    _hipPointerSetAttribute__retval = hipError_t(chip.hipPointerSetAttribute(
        <const void *>hip._util.types.Pointer.fromPyobj(value)._ptr,attribute.value,
        <void *>hip._util.types.Pointer.fromPyobj(ptr)._ptr))
    return (_hipPointerSetAttribute__retval,)


@cython.embedsignature(True)
def hipPointerGetAttributes(object attributes, object ptr):
    r"""Returns attributes for the specified pointer

    The output parameter 'attributes' has a member named 'type' that describes what memory the
    pointer is associated with, such as device memory, host memory, managed memory, and others.
    Otherwise, the API cannot handle the pointer and returns `~.hipErrorInvalidValue`.

    Note:
        The unrecognized memory type is unsupported to keep the HIP functionality backward
        compatibility due to `~.hipMemoryType` enum values.

    Note:
        The current behavior of this HIP API corresponds to the CUDA API before version 11.0.

    See:
        `~.hipPointerGetAttribute`

    Args:
        attributes (`~.hipPointerAttribute_t`/`~.object`) -- *OUT*:
            attributes for the specified pointer

        ptr (`~.hip._util.types.Pointer`/`~.object`) -- *IN*:
            pointer to get attributes for

    Returns:
        A `~.tuple` of size 1 that contains (in that order):

        * `~.hipError_t`: `~.hipSuccess`, `~.hipErrorInvalidDevice`, `~.hipErrorInvalidValue`
    """
    _hipPointerGetAttributes__retval = hipError_t(chip.hipPointerGetAttributes(
        hipPointerAttribute_t.fromPyobj(attributes).getElementPtr(),
        <const void *>hip._util.types.Pointer.fromPyobj(ptr)._ptr))
    return (_hipPointerGetAttributes__retval,)


@cython.embedsignature(True)
def hipPointerGetAttribute(object data, object attribute, object ptr):
    r"""Returns information about the specified pointer.[BETA]

    Warning:
        This API is marked as beta, meaning, while this is feature complete,
        it is still open to changes and may have outstanding issues.

    See:
        `~.hipPointerGetAttributes`

    Args:
        data (`~.hip._util.types.Pointer`/`~.object`) -- *IN,OUT*:
            Returned pointer attribute value

        attribute (`~.hipPointer_attribute`) -- *IN*:
            Attribute to query for

        ptr (`~.hip._util.types.Pointer`/`~.object`) -- *IN*:
            Pointer to get attributes for

    Returns:
        A `~.tuple` of size 1 that contains (in that order):

        * `~.hipError_t`: `~.hipSuccess`, `~.hipErrorInvalidDevice`, `~.hipErrorInvalidValue`
    """
    if not isinstance(attribute,_hipPointer_attribute__Base):
        raise TypeError("argument 'attribute' must be of type '_hipPointer_attribute__Base'")
    _hipPointerGetAttribute__retval = hipError_t(chip.hipPointerGetAttribute(
        <void *>hip._util.types.Pointer.fromPyobj(data)._ptr,attribute.value,
        <void *>hip._util.types.Pointer.fromPyobj(ptr)._ptr))
    return (_hipPointerGetAttribute__retval,)


@cython.embedsignature(True)
def hipDrvPointerGetAttributes(unsigned int numAttributes, object attributes, object ptr):
    r"""Returns information about the specified pointer.[BETA]

    Warning:
        This API is marked as beta, meaning, while this is feature complete,
        it is still open to changes and may have outstanding issues.

    See:
        `~.hipPointerGetAttribute`

    Args:
        numAttributes (`~.int`) -- *IN*:
            number of attributes to query for

        attributes (`~.hip._util.types.Pointer`/`~.object`) -- *IN*:
            attributes to query for

        ptr (`~.hip._util.types.Pointer`/`~.object`) -- *IN*:
            pointer to get attributes for

    Returns:
        A `~.tuple` of size 2 that contains (in that order):

        * `~.hipError_t`: `~.hipSuccess`, `~.hipErrorInvalidDevice`, `~.hipErrorInvalidValue`
        * `~.hip._util.types.Pointer`/`~.object`:
                a two-dimensional containing pointers to memory locations
                where the result of each attribute query will be written to
    """
    data = hip._util.types.Pointer.fromPtr(NULL)
    _hipDrvPointerGetAttributes__retval = hipError_t(chip.hipDrvPointerGetAttributes(numAttributes,
        <chip.hipPointer_attribute *>hip._util.types.Pointer.fromPyobj(attributes)._ptr,
        <void **>&data._ptr,
        <void *>hip._util.types.Pointer.fromPyobj(ptr)._ptr))
    return (_hipDrvPointerGetAttributes__retval,None if data._ptr == NULL else data)


@cython.embedsignature(True)
def hipImportExternalSemaphore(object extSem_out, object semHandleDesc):
    r"""Imports an external semaphore.

    This section describes the external resource interoperability functions of HIP runtime API.

    See:

    Args:
        extSem_out (`~.hip._util.types.Pointer`/`~.object`) -- *OUT*:
            External semaphores to be waited on

        semHandleDesc (`~.hipExternalSemaphoreHandleDesc_st`/`~.object`) -- *IN*:
            Semaphore import handle descriptor

    Returns:
        A `~.tuple` of size 1 that contains (in that order):

        * `~.hipError_t`: `~.hipSuccess`, `~.hipErrorInvalidDevice`, `~.hipErrorInvalidValue`
    """
    _hipImportExternalSemaphore__retval = hipError_t(chip.hipImportExternalSemaphore(
        <void **>hip._util.types.Pointer.fromPyobj(extSem_out)._ptr,
        hipExternalSemaphoreHandleDesc_st.fromPyobj(semHandleDesc).getElementPtr()))
    return (_hipImportExternalSemaphore__retval,)


@cython.embedsignature(True)
def hipSignalExternalSemaphoresAsync(object extSemArray, object paramsArray, unsigned int numExtSems, object stream):
    r"""Signals a set of external semaphore objects.

    See:

    Args:
        extSemArray (`~.hip._util.types.Pointer`/`~.object`) -- *IN*:
            External semaphores to be waited on

        paramsArray (`~.hipExternalSemaphoreSignalParams_st`/`~.object`) -- *IN*:
            Array of semaphore parameters

        numExtSems (`~.int`) -- *IN*:
            Number of semaphores to wait on

        stream (`~.ihipStream_t`/`~.object`) -- *IN*:
            Stream to enqueue the wait operations in

    Returns:
        A `~.tuple` of size 1 that contains (in that order):

        * `~.hipError_t`: `~.hipSuccess`, `~.hipErrorInvalidDevice`, `~.hipErrorInvalidValue`
    """
    _hipSignalExternalSemaphoresAsync__retval = hipError_t(chip.hipSignalExternalSemaphoresAsync(
        <void *const *>hip._util.types.Pointer.fromPyobj(extSemArray)._ptr,
        hipExternalSemaphoreSignalParams_st.fromPyobj(paramsArray).getElementPtr(),numExtSems,
        ihipStream_t.fromPyobj(stream).getElementPtr()))
    return (_hipSignalExternalSemaphoresAsync__retval,)


@cython.embedsignature(True)
def hipWaitExternalSemaphoresAsync(object extSemArray, object paramsArray, unsigned int numExtSems, object stream):
    r"""Waits on a set of external semaphore objects

    See:

    Args:
        extSemArray (`~.hip._util.types.Pointer`/`~.object`) -- *IN*:
            External semaphores to be waited on

        paramsArray (`~.hipExternalSemaphoreWaitParams_st`/`~.object`) -- *IN*:
            Array of semaphore parameters

        numExtSems (`~.int`) -- *IN*:
            Number of semaphores to wait on

        stream (`~.ihipStream_t`/`~.object`) -- *IN*:
            Stream to enqueue the wait operations in

    Returns:
        A `~.tuple` of size 1 that contains (in that order):

        * `~.hipError_t`: `~.hipSuccess`, `~.hipErrorInvalidDevice`, `~.hipErrorInvalidValue`
    """
    _hipWaitExternalSemaphoresAsync__retval = hipError_t(chip.hipWaitExternalSemaphoresAsync(
        <void *const *>hip._util.types.Pointer.fromPyobj(extSemArray)._ptr,
        hipExternalSemaphoreWaitParams_st.fromPyobj(paramsArray).getElementPtr(),numExtSems,
        ihipStream_t.fromPyobj(stream).getElementPtr()))
    return (_hipWaitExternalSemaphoresAsync__retval,)


@cython.embedsignature(True)
def hipDestroyExternalSemaphore(object extSem):
    r"""Destroys an external semaphore object and releases any references to the underlying resource. Any outstanding signals or waits must have completed before the semaphore is destroyed.

    See:

    Args:
        extSem (`~.hip._util.types.Pointer`/`~.object`) -- *IN*:
            handle to an external memory object

    Returns:
        A `~.tuple` of size 1 that contains (in that order):

        * `~.hipError_t`: `~.hipSuccess`, `~.hipErrorInvalidDevice`, `~.hipErrorInvalidValue`
    """
    _hipDestroyExternalSemaphore__retval = hipError_t(chip.hipDestroyExternalSemaphore(
        <void *>hip._util.types.Pointer.fromPyobj(extSem)._ptr))
    return (_hipDestroyExternalSemaphore__retval,)


@cython.embedsignature(True)
def hipImportExternalMemory(object extMem_out, object memHandleDesc):
    r"""Imports an external memory object.

    See:

    Args:
        extMem_out (`~.hip._util.types.Pointer`/`~.object`) -- *OUT*:
            Returned handle to an external memory object

        memHandleDesc (`~.hipExternalMemoryHandleDesc_st`/`~.object`) -- *IN*:
            Memory import handle descriptor

    Returns:
        A `~.tuple` of size 1 that contains (in that order):

        * `~.hipError_t`: `~.hipSuccess`, `~.hipErrorInvalidDevice`, `~.hipErrorInvalidValue`
    """
    _hipImportExternalMemory__retval = hipError_t(chip.hipImportExternalMemory(
        <void **>hip._util.types.Pointer.fromPyobj(extMem_out)._ptr,
        hipExternalMemoryHandleDesc_st.fromPyobj(memHandleDesc).getElementPtr()))
    return (_hipImportExternalMemory__retval,)


@cython.embedsignature(True)
def hipExternalMemoryGetMappedBuffer(object extMem, object bufferDesc):
    r"""Maps a buffer onto an imported memory object.

    See:

    Args:
        extMem (`~.hip._util.types.Pointer`/`~.object`) -- *IN*:
            Handle to external memory object

        bufferDesc (`~.hipExternalMemoryBufferDesc_st`/`~.object`) -- *IN*:
            Buffer descriptor

    Returns:
        A `~.tuple` of size 2 that contains (in that order):

        * `~.hipError_t`: `~.hipSuccess`, `~.hipErrorInvalidDevice`, `~.hipErrorInvalidValue`
        * `~.hip._util.types.Pointer`/`~.object`:
                Returned device pointer to buffer
    """
    devPtr = hip._util.types.Pointer.fromPtr(NULL)
    _hipExternalMemoryGetMappedBuffer__retval = hipError_t(chip.hipExternalMemoryGetMappedBuffer(
        <void **>&devPtr._ptr,
        <void *>hip._util.types.Pointer.fromPyobj(extMem)._ptr,
        hipExternalMemoryBufferDesc_st.fromPyobj(bufferDesc).getElementPtr()))
    return (_hipExternalMemoryGetMappedBuffer__retval,None if devPtr._ptr == NULL else devPtr)


@cython.embedsignature(True)
def hipDestroyExternalMemory(object extMem):
    r"""Destroys an external memory object.

    See:

    Args:
        extMem (`~.hip._util.types.Pointer`/`~.object`) -- *IN*:
            External memory object to be destroyed

    Returns:
        A `~.tuple` of size 1 that contains (in that order):

        * `~.hipError_t`: `~.hipSuccess`, `~.hipErrorInvalidDevice`, `~.hipErrorInvalidValue`
    """
    _hipDestroyExternalMemory__retval = hipError_t(chip.hipDestroyExternalMemory(
        <void *>hip._util.types.Pointer.fromPyobj(extMem)._ptr))
    return (_hipDestroyExternalMemory__retval,)


@cython.embedsignature(True)
def hipExternalMemoryGetMappedMipmappedArray(object extMem, object mipmapDesc):
    r"""Maps a mipmapped array onto an external memory object.

    Returned mipmapped array must be freed using hipFreeMipmappedArray.

    See:
        `~.hipImportExternalMemory`, `~.hipDestroyExternalMemory`, `~.hipExternalMemoryGetMappedBuffer`, `~.hipFreeMipmappedArray`

    Args:
        extMem (`~.hip._util.types.Pointer`/`~.object`) -- *IN*:
            external memory object handle

        mipmapDesc (`~.hipExternalMemoryMipmappedArrayDesc_st`/`~.object`) -- *IN*:
            external mipmapped array descriptor

    Returns:
        A `~.tuple` of size 2 that contains (in that order):

        * `~.hipError_t`: `~.hipSuccess`, `~.hipErrorInvalidValue`, `~.hipErrorInvalidResourceHandle`
        * `~.hipMipmappedArray`:
                mipmapped array to return
    """
    mipmap = hipMipmappedArray.fromPtr(NULL)
    _hipExternalMemoryGetMappedMipmappedArray__retval = hipError_t(chip.hipExternalMemoryGetMappedMipmappedArray(<chip.hipMipmappedArray**>&mipmap._ptr,
        <void *>hip._util.types.Pointer.fromPyobj(extMem)._ptr,
        hipExternalMemoryMipmappedArrayDesc_st.fromPyobj(mipmapDesc).getElementPtr()))
    return (_hipExternalMemoryGetMappedMipmappedArray__retval,None if mipmap._ptr == NULL else mipmap)


@cython.embedsignature(True)
def hipMalloc(unsigned long size):
    r"""Allocate memory on the default accelerator

    If size is 0, no memory is allocated, *ptr returns nullptr, and hipSuccess is returned.

    See:
        `~.hipMallocPitch`, `~.hipFree`, `~.hipMallocArray`, `~.hipFreeArray`, `~.hipMalloc3D`, `~.hipMalloc3DArray`,
        `~.hipHostFree`, `~.hipHostMalloc`

    Args:
        size (`~.int`) -- *IN*:
            Requested memory size

    Returns:
        A `~.tuple` of size 2 that contains (in that order):

        * `~.hipError_t`: `~.hipSuccess`, `~.hipErrorOutOfMemory`, `~.hipErrorInvalidValue` (bad context, null *ptr)
        * `~.hip._util.types.DeviceArray`/`~.object`:
                Pointer to the allocated memory
    """
    ptr = hip._util.types.DeviceArray.fromPtr(NULL)
    _hipMalloc__retval = hipError_t(chip.hipMalloc(
        <void **>&ptr._ptr,size))
    ptr.configure(_force=True,shape=(cpython.long.PyLong_FromUnsignedLong(size),))
    return (_hipMalloc__retval,None if ptr._ptr == NULL else ptr)


@cython.embedsignature(True)
def hipExtMallocWithFlags(unsigned long sizeBytes, unsigned int flags):
    r"""Allocate memory on the default accelerator

    If requested memory size is 0, no memory is allocated, *ptr returns nullptr, and `~.hipSuccess`
    is returned.

    The memory allocation flag should be either `~.hipDeviceMallocDefault`,
    `~.hipDeviceMallocFinegrained`, `~.hipDeviceMallocUncached`, or `~.hipMallocSignalMemory`.
    If the flag is any other value, the API returns `~.hipErrorInvalidValue`.

    See:
        `~.hipMallocPitch`, `~.hipFree`, `~.hipMallocArray`, `~.hipFreeArray`, `~.hipMalloc3D`, `~.hipMalloc3DArray`,
        `~.hipHostFree`, `~.hipHostMalloc`

    Args:
        sizeBytes (`~.int`) -- *IN*:
            Requested memory size

        flags (`~.int`) -- *IN*:
            Type of memory allocation

    Returns:
        A `~.tuple` of size 2 that contains (in that order):

        * `~.hipError_t`: `~.hipSuccess`, `~.hipErrorOutOfMemory`, `~.hipErrorInvalidValue` (bad context, null *ptr)
        * `~.hip._util.types.DeviceArray`/`~.object`:
                Pointer to the allocated memory
    """
    ptr = hip._util.types.DeviceArray.fromPtr(NULL)
    _hipExtMallocWithFlags__retval = hipError_t(chip.hipExtMallocWithFlags(
        <void **>&ptr._ptr,sizeBytes,flags))
    ptr.configure(_force=True,shape=(cpython.long.PyLong_FromUnsignedLong(sizeBytes),))
    return (_hipExtMallocWithFlags__retval,None if ptr._ptr == NULL else ptr)


@cython.embedsignature(True)
def hipMallocHost(unsigned long size):
    r"""Allocate pinned host memory [Deprecated]

    If size is 0, no memory is allocated, *ptr returns nullptr, and hipSuccess is returned.

    Warning:
        This API is deprecated, use hipHostMalloc() instead

    Args:
        size (`~.int`) -- *IN*:
            Requested memory size

    Returns:
        A `~.tuple` of size 2 that contains (in that order):

        * `~.hipError_t`: `~.hipSuccess`, `~.hipErrorOutOfMemory`
        * `~.hip._util.types.Pointer`/`~.object`:
                Pointer to the allocated host pinned memory
    """
    ptr = hip._util.types.Pointer.fromPtr(NULL)
    _hipMallocHost__retval = hipError_t(chip.hipMallocHost(
        <void **>&ptr._ptr,size))
    return (_hipMallocHost__retval,None if ptr._ptr == NULL else ptr)


@cython.embedsignature(True)
def hipMemAllocHost(unsigned long size):
    r"""Allocate pinned host memory [Deprecated]

    If size is 0, no memory is allocated, *ptr returns nullptr, and hipSuccess is returned.

    Warning:
        This API is deprecated, use hipHostMalloc() instead

    Args:
        size (`~.int`) -- *IN*:
            Requested memory size

    Returns:
        A `~.tuple` of size 2 that contains (in that order):

        * `~.hipError_t`: `~.hipSuccess`, `~.hipErrorOutOfMemory`
        * `~.hip._util.types.Pointer`/`~.object`:
                Pointer to the allocated host pinned memory
    """
    ptr = hip._util.types.Pointer.fromPtr(NULL)
    _hipMemAllocHost__retval = hipError_t(chip.hipMemAllocHost(
        <void **>&ptr._ptr,size))
    return (_hipMemAllocHost__retval,None if ptr._ptr == NULL else ptr)


@cython.embedsignature(True)
def hipHostMalloc(unsigned long size, unsigned int flags):
    r"""Allocates device accessible page locked (pinned) host memory

    This API allocates pinned host memory which is mapped into the address space of all GPUs
    in the system, the memory can be accessed directly by the GPU device, and can be read or
    written with much higher bandwidth than pageable memory obtained with functions such as
    malloc().

    Using the pinned host memory, applications can implement faster data transfers for HostToDevice
    and DeviceToHost. The runtime tracks the hipHostMalloc allocations and can avoid some of the
    setup required for regular unpinned memory.

    When the memory accesses are infrequent, zero-copy memory can be a good choice, for coherent
    allocation. GPU can directly access the host memory over the CPU/GPU interconnect, without need
    to copy the data.

    Currently the allocation granularity is 4KB for the API.

    Developers need to choose proper allocation flag with consideration of synchronization.

    If no input for flags, it will be the default pinned memory allocation on the host.

    See:
        `~.hipSetDeviceFlags`, `~.hipHostFree`

    Args:
        size (`~.int`) -- *IN*:
            Requested memory size in bytes
            If size is 0, no memory is allocated, *ptr returns nullptr, and hipSuccess is returned.

        flags (`~.int`) -- *IN*:
            Type of host memory allocation

    Returns:
        A `~.tuple` of size 2 that contains (in that order):

        * `~.hipError_t`: `~.hipSuccess`, `~.hipErrorOutOfMemory`
        * `~.hip._util.types.Pointer`/`~.object`:
                Pointer to the allocated host pinned memory
    """
    ptr = hip._util.types.Pointer.fromPtr(NULL)
    _hipHostMalloc__retval = hipError_t(chip.hipHostMalloc(
        <void **>&ptr._ptr,size,flags))
    return (_hipHostMalloc__retval,None if ptr._ptr == NULL else ptr)


@cython.embedsignature(True)
def hipMallocManaged(unsigned long size, unsigned int flags):
    r"""Allocates memory that will be automatically managed by HIP.

    This section describes the managed memory management functions of HIP runtime API.

    Note:
        The managed memory management APIs are implemented on Linux, under developement
        on Windows.

    This API is used for managed memory, allows data be shared and accessible to both CPU and
    GPU using a single pointer.

    The API returns the allocation pointer, managed by HMM, can be used further to execute kernels
    on device and fetch data between the host and device as needed.

    Note:
        It is recommend to do the capability check before call this API.

    Args:
        size (`~.int`) -- *IN*:
            - requested allocation size in bytes, it should be granularity of 4KB

        flags (`~.int`) -- *IN*:
            - must be either hipMemAttachGlobal or hipMemAttachHost
            (defaults to hipMemAttachGlobal)

    Returns:
        A `~.tuple` of size 2 that contains (in that order):

        * `~.hipError_t`: `~.hipSuccess`, `~.hipErrorMemoryAllocation`, `~.hipErrorNotSupported`, `~.hipErrorInvalidValue`
        * `~.hip._util.types.DeviceArray`/`~.object`:
                - pointer to allocated device memory
    """
    dev_ptr = hip._util.types.DeviceArray.fromPtr(NULL)
    _hipMallocManaged__retval = hipError_t(chip.hipMallocManaged(
        <void **>&dev_ptr._ptr,size,flags))
    dev_ptr.configure(_force=True,shape=(cpython.long.PyLong_FromUnsignedLong(size),))
    return (_hipMallocManaged__retval,None if dev_ptr._ptr == NULL else dev_ptr)


@cython.embedsignature(True)
def hipMemPrefetchAsync(object dev_ptr, unsigned long count, int device, object stream):
    r"""Prefetches memory to the specified destination device using HIP.

    Note:
        This API is implemented on Linux, under development on Windows.

    Args:
        dev_ptr (`~.hip._util.types.Pointer`/`~.object`) -- *IN*:
            pointer to be prefetched

        count (`~.int`) -- *IN*:
            size in bytes for prefetching

        device (`~.int`) -- *IN*:
            destination device to prefetch to

        stream (`~.ihipStream_t`/`~.object`) -- *IN*:
            stream to enqueue prefetch operation

    Returns:
        A `~.tuple` of size 1 that contains (in that order):

        * `~.hipError_t`: `~.hipSuccess`, `~.hipErrorInvalidValue`
    """
    _hipMemPrefetchAsync__retval = hipError_t(chip.hipMemPrefetchAsync(
        <const void *>hip._util.types.Pointer.fromPyobj(dev_ptr)._ptr,count,device,
        ihipStream_t.fromPyobj(stream).getElementPtr()))
    return (_hipMemPrefetchAsync__retval,)


@cython.embedsignature(True)
def hipMemAdvise(object dev_ptr, unsigned long count, object advice, int device):
    r"""Advise about the usage of a given memory range to HIP.

    This HIP API advises about the usage to be applied on unified memory allocation in the
    range starting from the pointer address devPtr, with the size of count bytes.
    The memory range must refer to managed memory allocated via the API hipMallocManaged, and the
    range will be handled with proper round down and round up respectively in the driver to
    be aligned to CPU page size, the same way as corresponding CUDA API behaves in CUDA version 8.0
    and afterwards.

    Note:
        This API is implemented on Linux and is under development on Windows.

    Args:
        dev_ptr (`~.hip._util.types.Pointer`/`~.object`) -- *IN*:
            pointer to memory to set the advice for

        count (`~.int`) -- *IN*:
            size in bytes of the memory range, it should be CPU page size alligned.

        advice (`~.hipMemoryAdvise`) -- *IN*:
            advice to be applied for the specified memory range

        device (`~.int`) -- *IN*:
            device to apply the advice for

    Returns:
        A `~.tuple` of size 1 that contains (in that order):

        * `~.hipError_t`: `~.hipSuccess`, `~.hipErrorInvalidValue`
    """
    if not isinstance(advice,_hipMemoryAdvise__Base):
        raise TypeError("argument 'advice' must be of type '_hipMemoryAdvise__Base'")
    _hipMemAdvise__retval = hipError_t(chip.hipMemAdvise(
        <const void *>hip._util.types.Pointer.fromPyobj(dev_ptr)._ptr,count,advice.value,device))
    return (_hipMemAdvise__retval,)


@cython.embedsignature(True)
def hipMemRangeGetAttribute(object data, unsigned long data_size, object attribute, object dev_ptr, unsigned long count):
    r"""Query an attribute of a given memory range in HIP.

    Note:
        This API is implemented on Linux, under development on Windows.

    Args:
        data (`~.hip._util.types.Pointer`/`~.object`) -- *IN,OUT*:
            a pointer to a memory location where the result of each
            attribute query will be written to

        data_size (`~.int`) -- *IN*:
            the size of data

        attribute (`~.hipMemRangeAttribute`) -- *IN*:
            the attribute to query

        dev_ptr (`~.hip._util.types.Pointer`/`~.object`) -- *IN*:
            start of the range to query

        count (`~.int`) -- *IN*:
            size of the range to query

    Returns:
        A `~.tuple` of size 1 that contains (in that order):

        * `~.hipError_t`: `~.hipSuccess`, `~.hipErrorInvalidValue`
    """
    if not isinstance(attribute,_hipMemRangeAttribute__Base):
        raise TypeError("argument 'attribute' must be of type '_hipMemRangeAttribute__Base'")
    _hipMemRangeGetAttribute__retval = hipError_t(chip.hipMemRangeGetAttribute(
        <void *>hip._util.types.Pointer.fromPyobj(data)._ptr,data_size,attribute.value,
        <const void *>hip._util.types.Pointer.fromPyobj(dev_ptr)._ptr,count))
    return (_hipMemRangeGetAttribute__retval,)


@cython.embedsignature(True)
def hipMemRangeGetAttributes(object attributes, unsigned long num_attributes, object dev_ptr, unsigned long count):
    r"""Query attributes of a given memory range in HIP.

    Note:
        This API is implemented on Linux, under development on Windows.

    Args:
        attributes (`~.hip._util.types.Pointer`/`~.object`) -- *IN*:
            the attribute to query

        num_attributes (`~.int`) -- *IN*:
            an array of attributes to query (numAttributes and the number
            of attributes in this array should match)

        dev_ptr (`~.hip._util.types.Pointer`/`~.object`) -- *IN*:
            start of the range to query

        count (`~.int`) -- *IN*:
            size of the range to query

    Returns:
        A `~.tuple` of size 3 that contains (in that order):

        * `~.hipError_t`: `~.hipSuccess`, `~.hipErrorInvalidValue`
        * `~.hip._util.types.Pointer`/`~.object`:
                a two-dimensional array containing pointers to memory locations
                where the result of each attribute query will be written to
        * `~.int`:
                an array, containing the sizes of each result
    """
    data = hip._util.types.Pointer.fromPtr(NULL)
    cdef unsigned long data_sizes
    _hipMemRangeGetAttributes__retval = hipError_t(chip.hipMemRangeGetAttributes(
        <void **>&data._ptr,&data_sizes,
        <chip.hipMemRangeAttribute *>hip._util.types.Pointer.fromPyobj(attributes)._ptr,num_attributes,
        <const void *>hip._util.types.Pointer.fromPyobj(dev_ptr)._ptr,count))
    return (_hipMemRangeGetAttributes__retval,None if data._ptr == NULL else data,data_sizes)


@cython.embedsignature(True)
def hipStreamAttachMemAsync(object stream, object dev_ptr, unsigned long length, unsigned int flags):
    r"""Attach memory to a stream asynchronously in HIP.

    Note:
        This API is implemented on Linux, under development on Windows.

    Args:
        stream (`~.ihipStream_t`/`~.object`) -- *IN*:
            - stream in which to enqueue the attach operation

        dev_ptr (`~.hip._util.types.Pointer`/`~.object`) -- *IN*:
            - pointer to memory (must be a pointer to managed memory or
            to a valid host-accessible region of system-allocated memory)

        length (`~.int`) -- *IN*:
            - length of memory (defaults to zero)

        flags (`~.int`) -- *IN*:
            - must be one of hipMemAttachGlobal, hipMemAttachHost or
            hipMemAttachSingle (defaults to hipMemAttachSingle)

    Returns:
        A `~.tuple` of size 1 that contains (in that order):

        * `~.hipError_t`: `~.hipSuccess`, `~.hipErrorInvalidValue`
    """
    _hipStreamAttachMemAsync__retval = hipError_t(chip.hipStreamAttachMemAsync(
        ihipStream_t.fromPyobj(stream).getElementPtr(),
        <void *>hip._util.types.Pointer.fromPyobj(dev_ptr)._ptr,length,flags))
    return (_hipStreamAttachMemAsync__retval,)


@cython.embedsignature(True)
def hipMallocAsync(unsigned long size, object stream):
    r"""Allocates memory with stream ordered semantics

    Inserts a memory allocation operation into ``stream.``
    A pointer to the allocated memory is returned immediately in *dptr.
    The allocation must not be accessed until the allocation operation completes.
    The allocation comes from the memory pool associated with the stream's device.

    Note:
        The default memory pool of a device contains device memory from that device.

    Note:
        Basic stream ordering allows future work submitted into the same stream to use the
        allocation. Stream query, stream synchronize, and HIP events can be used to guarantee that
        the allocation operation completes before work submitted in a separate stream runs.

    Note:
        During stream capture, this function results in the creation of an allocation node.
        In this case, the allocation is owned by the graph instead of the memory pool. The memory
        pool's properties are used to set the node's creation parameters.

    See:
        `~.hipMallocFromPoolAsync`, `~.hipFreeAsync`, `~.hipMemPoolTrimTo`, `~.hipMemPoolGetAttribute`,
        `~.hipDeviceSetMemPool`, `~.hipMemPoolSetAttribute`, `~.hipMemPoolSetAccess`, `~.hipMemPoolGetAccess`

    Warning:
        This API is marked as beta, meaning, while this is feature complete,
        it is still open to changes and may have outstanding issues.

    Note:
        This API is implemented on Linux, under development on Windows.

    Args:
        size (`~.int`) -- *IN*:
            Number of bytes to allocate

        stream (`~.ihipStream_t`/`~.object`) -- *IN*:
            The stream establishing the stream ordering contract and
            the memory pool to allocate from

    Returns:
        A `~.tuple` of size 2 that contains (in that order):

        * `~.hipError_t`: `~.hipSuccess`, `~.hipErrorInvalidValue`, `~.hipErrorNotSupported`, `~.hipErrorOutOfMemory`
        * `~.hip._util.types.DeviceArray`/`~.object`:
                Returned device pointer of memory allocation
    """
    dev_ptr = hip._util.types.DeviceArray.fromPtr(NULL)
    _hipMallocAsync__retval = hipError_t(chip.hipMallocAsync(
        <void **>&dev_ptr._ptr,size,
        ihipStream_t.fromPyobj(stream).getElementPtr()))
    dev_ptr.configure(_force=True,shape=(cpython.long.PyLong_FromUnsignedLong(size),))
    return (_hipMallocAsync__retval,None if dev_ptr._ptr == NULL else dev_ptr)


@cython.embedsignature(True)
def hipFreeAsync(object dev_ptr, object stream):
    r"""Frees memory with stream ordered semantics

    Inserts a free operation into ``stream.``
    The allocation must not be used after stream execution reaches the free.
    After this API returns, accessing the memory from any subsequent work launched on the GPU
    or querying its pointer attributes results in undefined behavior.

    Note:
        During stream capture, this function results in the creation of a free node and
        must therefore be passed the address of a graph allocation.

    See:
        `~.hipMallocFromPoolAsync`, `~.hipMallocAsync`, `~.hipMemPoolTrimTo`, `~.hipMemPoolGetAttribute`,
        `~.hipDeviceSetMemPool`, `~.hipMemPoolSetAttribute`, `~.hipMemPoolSetAccess`, `~.hipMemPoolGetAccess`

    Warning:
        This API is marked as beta, meaning, while this is feature complete,
        it is still open to changes and may have outstanding issues.

    Note:
        This API is implemented on Linux, under development on Windows.

    Args:
        dev_ptr (`~.hip._util.types.Pointer`/`~.object`) -- *IN*:
            Pointer to device memory to free

        stream (`~.ihipStream_t`/`~.object`) -- *IN*:
            The stream, where the destruciton will occur according to the execution order

    Returns:
        A `~.tuple` of size 1 that contains (in that order):

        * `~.hipError_t`: `~.hipSuccess`, `~.hipErrorInvalidValue`, `~.hipErrorNotSupported`
    """
    _hipFreeAsync__retval = hipError_t(chip.hipFreeAsync(
        <void *>hip._util.types.Pointer.fromPyobj(dev_ptr)._ptr,
        ihipStream_t.fromPyobj(stream).getElementPtr()))
    return (_hipFreeAsync__retval,)


@cython.embedsignature(True)
def hipMemPoolTrimTo(object mem_pool, unsigned long min_bytes_to_hold):
    r"""Releases freed memory back to the OS

    Releases memory back to the OS until the pool contains fewer than ``min_bytes_to_keep``
    reserved bytes, or there is no more memory that the allocator can safely release.
    The allocator cannot release OS allocations that back outstanding asynchronous allocations.
    The OS allocations may happen at different granularity from the user allocations.

    Note:
        Allocations that have not been freed count as outstanding.

    Note:
        Allocations that have been asynchronously freed but whose completion has
        not been observed on the host (eg. by a synchronize) can count as outstanding.

    See:
        `~.hipMallocFromPoolAsync`, `~.hipMallocAsync`, `~.hipFreeAsync`, `~.hipMemPoolGetAttribute`,
        `~.hipDeviceSetMemPool`, `~.hipMemPoolSetAttribute`, `~.hipMemPoolSetAccess`, `~.hipMemPoolGetAccess`

    Warning:
        This API is marked as beta, meaning, while this is feature complete,
        it is still open to changes and may have outstanding issues.

    Note:
        This API is implemented on Linux, under development on Windows.

    Args:
        mem_pool (`~.ihipMemPoolHandle_t`/`~.object`) -- *IN*:
            The memory pool to trim allocations

        min_bytes_to_hold (`~.int`) -- *IN*:
            If the pool has less than min_bytes_to_hold reserved,
            then the TrimTo operation is a no-op.  Otherwise the memory pool will contain
            at least min_bytes_to_hold bytes reserved after the operation.

    Returns:
        A `~.tuple` of size 1 that contains (in that order):

        * `~.hipError_t`: `~.hipSuccess`, `~.hipErrorInvalidValue`
    """
    _hipMemPoolTrimTo__retval = hipError_t(chip.hipMemPoolTrimTo(
        ihipMemPoolHandle_t.fromPyobj(mem_pool).getElementPtr(),min_bytes_to_hold))
    return (_hipMemPoolTrimTo__retval,)


@cython.embedsignature(True)
def hipMemPoolSetAttribute(object mem_pool, object attr, object value):
    r"""Sets attributes of a memory pool

    Supported attributes are:
    - ``hipMemPoolAttrReleaseThreshold:`` (value type = cuuint64_t)
                                     Amount of reserved memory in bytes to hold onto before trying
                                     to release memory back to the OS. When more than the release
                                     threshold bytes of memory are held by the memory pool, the
                                     allocator will try to release memory back to the OS on the
                                     next call to stream, event or context synchronize. (default 0)
    - ``hipMemPoolReuseFollowEventDependencies:`` (value type = int)
                                     Allow ``hipMallocAsync`` to use memory asynchronously freed
                                     in another stream as long as a stream ordering dependency
                                     of the allocating stream on the free action exists.
                                     HIP events and null stream interactions can create the required
                                     stream ordered dependencies. (default enabled)
    - ``hipMemPoolReuseAllowOpportunistic:`` (value type = int)
                                     Allow reuse of already completed frees when there is no dependency
                                     between the free and allocation. (default enabled)
    - ``hipMemPoolReuseAllowInternalDependencies:`` (value type = int)
                                     Allow ``hipMallocAsync`` to insert new stream dependencies
                                     in order to establish the stream ordering required to reuse
                                     a piece of memory released by ``hipFreeAsync`` (default enabled).

    See:
        `~.hipMallocFromPoolAsync`, `~.hipMallocAsync`, `~.hipFreeAsync`, `~.hipMemPoolGetAttribute`,
        `~.hipMemPoolTrimTo`, `~.hipDeviceSetMemPool`, `~.hipMemPoolSetAccess`, `~.hipMemPoolGetAccess`

    Warning:
        This API is marked as beta, meaning, while this is feature complete,
        it is still open to changes and may have outstanding issues.

    Note:
        This API is implemented on Linux, under development on Windows.

    Args:
        mem_pool (`~.ihipMemPoolHandle_t`/`~.object`) -- *IN*:
            The memory pool to modify

        attr (`~.hipMemPoolAttr`) -- *IN*:
            The attribute to modify

        value (`~.hip._util.types.Pointer`/`~.object`) -- *IN*:
            Pointer to the value to assign

    Returns:
        A `~.tuple` of size 1 that contains (in that order):

        * `~.hipError_t`: `~.hipSuccess`, `~.hipErrorInvalidValue`
    """
    if not isinstance(attr,_hipMemPoolAttr__Base):
        raise TypeError("argument 'attr' must be of type '_hipMemPoolAttr__Base'")
    _hipMemPoolSetAttribute__retval = hipError_t(chip.hipMemPoolSetAttribute(
        ihipMemPoolHandle_t.fromPyobj(mem_pool).getElementPtr(),attr.value,
        <void *>hip._util.types.Pointer.fromPyobj(value)._ptr))
    return (_hipMemPoolSetAttribute__retval,)


@cython.embedsignature(True)
def hipMemPoolGetAttribute(object mem_pool, object attr, object value):
    r"""Gets attributes of a memory pool

    Supported attributes are:
    - ``hipMemPoolAttrReleaseThreshold:`` (value type = cuuint64_t)
                                     Amount of reserved memory in bytes to hold onto before trying
                                     to release memory back to the OS. When more than the release
                                     threshold bytes of memory are held by the memory pool, the
                                     allocator will try to release memory back to the OS on the
                                     next call to stream, event or context synchronize. (default 0)
    - ``hipMemPoolReuseFollowEventDependencies:`` (value type = int)
                                     Allow ``hipMallocAsync`` to use memory asynchronously freed
                                     in another stream as long as a stream ordering dependency
                                     of the allocating stream on the free action exists.
                                     HIP events and null stream interactions can create the required
                                     stream ordered dependencies. (default enabled)
    - ``hipMemPoolReuseAllowOpportunistic:`` (value type = int)
                                     Allow reuse of already completed frees when there is no dependency
                                     between the free and allocation. (default enabled)
    - ``hipMemPoolReuseAllowInternalDependencies:`` (value type = int)
                                     Allow ``hipMallocAsync`` to insert new stream dependencies
                                     in order to establish the stream ordering required to reuse
                                     a piece of memory released by ``hipFreeAsync`` (default enabled).

    See:
        `~.hipMallocFromPoolAsync`, `~.hipMallocAsync`, `~.hipFreeAsync`,
        `~.hipMemPoolTrimTo`, `~.hipDeviceSetMemPool`, `~.hipMemPoolSetAttribute`, `~.hipMemPoolSetAccess`, `~.hipMemPoolGetAccess`

    Warning:
        This API is marked as beta, meaning, while this is feature complete,
        it is still open to changes and may have outstanding issues.

    Note:
        This API is implemented on Linux, under development on Windows.

    Args:
        mem_pool (`~.ihipMemPoolHandle_t`/`~.object`) -- *IN*:
            The memory pool to get attributes of

        attr (`~.hipMemPoolAttr`) -- *IN*:
            The attribute to get

        value (`~.hip._util.types.Pointer`/`~.object`) -- *IN*:
            Retrieved value

    Returns:
        A `~.tuple` of size 1 that contains (in that order):

        * `~.hipError_t`: `~.hipSuccess`, `~.hipErrorInvalidValue`
    """
    if not isinstance(attr,_hipMemPoolAttr__Base):
        raise TypeError("argument 'attr' must be of type '_hipMemPoolAttr__Base'")
    _hipMemPoolGetAttribute__retval = hipError_t(chip.hipMemPoolGetAttribute(
        ihipMemPoolHandle_t.fromPyobj(mem_pool).getElementPtr(),attr.value,
        <void *>hip._util.types.Pointer.fromPyobj(value)._ptr))
    return (_hipMemPoolGetAttribute__retval,)


@cython.embedsignature(True)
def hipMemPoolSetAccess(object mem_pool, object desc_list, unsigned long count):
    r"""Controls visibility of the specified pool between devices

    See:
        `~.hipMallocFromPoolAsync`, `~.hipMallocAsync`, `~.hipFreeAsync`, `~.hipMemPoolGetAttribute`,
        `~.hipMemPoolTrimTo`, `~.hipDeviceSetMemPool`, `~.hipMemPoolSetAttribute`, `~.hipMemPoolGetAccess`

    Warning:
        This API is marked as beta, meaning, while this is feature complete,
        it is still open to changes and may have outstanding issues.

    Note:
        This API is implemented on Linux, under development on Windows.

    Args:
        mem_pool (`~.ihipMemPoolHandle_t`/`~.object`) -- *IN*:
            Memory pool for acccess change

        desc_list (`~.hipMemAccessDesc`/`~.object`) -- *IN*:
            Array of access descriptors. Each descriptor instructs the access to enable for a single gpu

        count (`~.int`) -- *IN*:
            Number of descriptors in the map array.

    Returns:
        A `~.tuple` of size 1 that contains (in that order):

        * `~.hipError_t`: `~.hipSuccess`, `~.hipErrorInvalidValue`
    """
    _hipMemPoolSetAccess__retval = hipError_t(chip.hipMemPoolSetAccess(
        ihipMemPoolHandle_t.fromPyobj(mem_pool).getElementPtr(),
        hipMemAccessDesc.fromPyobj(desc_list).getElementPtr(),count))
    return (_hipMemPoolSetAccess__retval,)


@cython.embedsignature(True)
def hipMemPoolGetAccess(object flags, object mem_pool, object location):
    r"""Returns the accessibility of a pool from a device

    Returns the accessibility of the pool's memory from the specified location.

    See:
        `~.hipMallocFromPoolAsync`, `~.hipMallocAsync`, `~.hipFreeAsync`, `~.hipMemPoolGetAttribute`,
        `~.hipMemPoolTrimTo`, `~.hipDeviceSetMemPool`, `~.hipMemPoolSetAttribute`, `~.hipMemPoolSetAccess`

    Warning:
        This API is marked as beta, meaning, while this is feature complete,
        it is still open to changes and may have outstanding issues.

    Note:
        This API is implemented on Linux, under development on Windows.

    Args:
        flags (`~.hip._util.types.Pointer`/`~.object`) -- *OUT*:
            Accessibility of the memory pool from the specified location/device

        mem_pool (`~.ihipMemPoolHandle_t`/`~.object`) -- *IN*:
            Memory pool being queried

        location (`~.hipMemLocation`/`~.object`) -- *IN*:
            Location/device for memory pool access

    Returns:
        A `~.tuple` of size 1 that contains (in that order):

        * `~.hipError_t`: `~.hipSuccess`, `~.hipErrorInvalidValue`
    """
    _hipMemPoolGetAccess__retval = hipError_t(chip.hipMemPoolGetAccess(
        <chip.hipMemAccessFlags *>hip._util.types.Pointer.fromPyobj(flags)._ptr,
        ihipMemPoolHandle_t.fromPyobj(mem_pool).getElementPtr(),
        hipMemLocation.fromPyobj(location).getElementPtr()))
    return (_hipMemPoolGetAccess__retval,)


@cython.embedsignature(True)
def hipMemPoolCreate(object pool_props):
    r"""Creates a memory pool

    Creates a HIP memory pool and returns the handle in ``mem_pool.`` The ``pool_props`` determines
    the properties of the pool such as the backing device and IPC capabilities.

    By default, the memory pool will be accessible from the device it is allocated on.

    Note:
        Specifying hipMemHandleTypeNone creates a memory pool that will not support IPC.

    See:
        `~.hipMallocFromPoolAsync`, `~.hipMallocAsync`, `~.hipFreeAsync`, `~.hipMemPoolGetAttribute`, `~.hipMemPoolDestroy`,
        `~.hipMemPoolTrimTo`, `~.hipDeviceSetMemPool`, `~.hipMemPoolSetAttribute`, `~.hipMemPoolSetAccess`, `~.hipMemPoolGetAccess`

    Warning:
        This API is marked as beta, meaning, while this is feature complete,
        it is still open to changes and may have outstanding issues.

    Note:
        This API is implemented on Linux, under development on Windows.

    Args:
        pool_props (`~.hipMemPoolProps`/`~.object`) -- *IN*:
            Memory pool properties

    Returns:
        A `~.tuple` of size 2 that contains (in that order):

        * `~.hipError_t`: `~.hipSuccess`, `~.hipErrorInvalidValue`, `~.hipErrorNotSupported`
        * `~.ihipMemPoolHandle_t`:
                Contains createed memory pool
    """
    mem_pool = ihipMemPoolHandle_t.fromPtr(NULL)
    _hipMemPoolCreate__retval = hipError_t(chip.hipMemPoolCreate(<chip.ihipMemPoolHandle_t**>&mem_pool._ptr,
        hipMemPoolProps.fromPyobj(pool_props).getElementPtr()))
    return (_hipMemPoolCreate__retval,None if mem_pool._ptr == NULL else mem_pool)


@cython.embedsignature(True)
def hipMemPoolDestroy(object mem_pool):
    r"""Destroys the specified memory pool

    If any pointers obtained from this pool haven't been freed or
    the pool has free operations that haven't completed
    when ``hipMemPoolDestroy`` is invoked, the function will return immediately and the
    resources associated with the pool will be released automatically
    once there are no more outstanding allocations.

    Destroying the current mempool of a device sets the default mempool of
    that device as the current mempool for that device.

    Note:
        A device's default memory pool cannot be destroyed.

    See:
        `~.hipMallocFromPoolAsync`, `~.hipMallocAsync`, `~.hipFreeAsync`, `~.hipMemPoolGetAttribute`, `~.hipMemPoolCreate`
        `~.hipMemPoolTrimTo`, `~.hipDeviceSetMemPool`, `~.hipMemPoolSetAttribute`, `~.hipMemPoolSetAccess`, `~.hipMemPoolGetAccess`

    Warning:
        This API is marked as beta, meaning, while this is feature complete,
        it is still open to changes and may have outstanding issues.

    Note:
        This API is implemented on Linux, under development on Windows.

    Args:
        mem_pool (`~.ihipMemPoolHandle_t`/`~.object`) -- *IN*:
            Memory pool for destruction

    Returns:
        A `~.tuple` of size 1 that contains (in that order):

        * `~.hipError_t`: `~.hipSuccess`, `~.hipErrorInvalidValue`
    """
    _hipMemPoolDestroy__retval = hipError_t(chip.hipMemPoolDestroy(
        ihipMemPoolHandle_t.fromPyobj(mem_pool).getElementPtr()))
    return (_hipMemPoolDestroy__retval,)


@cython.embedsignature(True)
def hipMallocFromPoolAsync(unsigned long size, object mem_pool, object stream):
    r"""Allocates memory from a specified pool with stream ordered semantics.

    Inserts an allocation operation into ``stream.``
    A pointer to the allocated memory is returned immediately in ``dev_ptr.``
    The allocation must not be accessed until the allocation operation completes.
    The allocation comes from the specified memory pool.

    Note:
        The specified memory pool may be from a device different than that of the specified ``stream.``

    Basic stream ordering allows future work submitted into the same stream to use the allocation.
    Stream query, stream synchronize, and HIP events can be used to guarantee that the allocation
    operation completes before work submitted in a separate stream runs.

    Note:
        During stream capture, this function results in the creation of an allocation node. In this case,
        the allocation is owned by the graph instead of the memory pool. The memory pool's properties
        are used to set the node's creation parameters.

    See:
        `~.hipMallocAsync`, `~.hipFreeAsync`, `~.hipMemPoolGetAttribute`, `~.hipMemPoolCreate`
        `~.hipMemPoolTrimTo`, `~.hipDeviceSetMemPool`, `~.hipMemPoolSetAttribute`, `~.hipMemPoolSetAccess`, `~.hipMemPoolGetAccess`,

    Warning:
        This API is marked as beta, meaning, while this is feature complete,
        it is still open to changes and may have outstanding issues.

    Note:
        This API is implemented on Linux, under development on Windows.

    Args:
        size (`~.int`) -- *IN*:
            Number of bytes to allocate

        mem_pool (`~.ihipMemPoolHandle_t`/`~.object`) -- *IN*:
            The pool to allocate from

        stream (`~.ihipStream_t`/`~.object`) -- *IN*:
            The stream establishing the stream ordering semantic

    Returns:
        A `~.tuple` of size 2 that contains (in that order):

        * `~.hipError_t`: `~.hipSuccess`, `~.hipErrorInvalidValue`, `~.hipErrorNotSupported`, `~.hipErrorOutOfMemory`
        * `~.hip._util.types.DeviceArray`/`~.object`:
                Returned device pointer
    """
    dev_ptr = hip._util.types.DeviceArray.fromPtr(NULL)
    _hipMallocFromPoolAsync__retval = hipError_t(chip.hipMallocFromPoolAsync(
        <void **>&dev_ptr._ptr,size,
        ihipMemPoolHandle_t.fromPyobj(mem_pool).getElementPtr(),
        ihipStream_t.fromPyobj(stream).getElementPtr()))
    dev_ptr.configure(_force=True,shape=(cpython.long.PyLong_FromUnsignedLong(size),))
    return (_hipMallocFromPoolAsync__retval,None if dev_ptr._ptr == NULL else dev_ptr)


@cython.embedsignature(True)
def hipMemPoolExportToShareableHandle(object shared_handle, object mem_pool, object handle_type, unsigned int flags):
    r"""Exports a memory pool to the requested handle type.

    Given an IPC capable mempool, create an OS handle to share the pool with another process.
    A recipient process can convert the shareable handle into a mempool with ``hipMemPoolImportFromShareableHandle.``
    Individual pointers can then be shared with the ``hipMemPoolExportPointer`` and ``hipMemPoolImportPointer`` APIs.
    The implementation of what the shareable handle is and how it can be transferred is defined by the requested
    handle type.

    Note:
        To create an IPC capable mempool, create a mempool with a ``hipMemAllocationHandleType`` other
        than ``hipMemHandleTypeNone.``

    See:
        `~.hipMemPoolImportFromShareableHandle`

    Warning:
        This API is marked as beta, meaning, while this is feature complete,
        it is still open to changes and may have outstanding issues.

    Note:
        This API is implemented on Linux, under development on Windows.

    Args:
        shared_handle (`~.hip._util.types.Pointer`/`~.object`) -- *OUT*:
            Pointer to the location in which to store the requested handle

        mem_pool (`~.ihipMemPoolHandle_t`/`~.object`) -- *IN*:
            Pool to export

        handle_type (`~.hipMemAllocationHandleType`) -- *IN*:
            The type of handle to create

        flags (`~.int`) -- *IN*:
            Must be 0

    Returns:
        A `~.tuple` of size 1 that contains (in that order):

        * `~.hipError_t`: `~.hipSuccess`, `~.hipErrorInvalidValue`, `~.hipErrorOutOfMemory`
    """
    if not isinstance(handle_type,_hipMemAllocationHandleType__Base):
        raise TypeError("argument 'handle_type' must be of type '_hipMemAllocationHandleType__Base'")
    _hipMemPoolExportToShareableHandle__retval = hipError_t(chip.hipMemPoolExportToShareableHandle(
        <void *>hip._util.types.Pointer.fromPyobj(shared_handle)._ptr,
        ihipMemPoolHandle_t.fromPyobj(mem_pool).getElementPtr(),handle_type.value,flags))
    return (_hipMemPoolExportToShareableHandle__retval,)


@cython.embedsignature(True)
def hipMemPoolImportFromShareableHandle(object shared_handle, object handle_type, unsigned int flags):
    r"""Imports a memory pool from a shared handle.

    Specific allocations can be imported from the imported pool with ``hipMemPoolImportPointer.``

    Note:
        Imported memory pools do not support creating new allocations.
        As such imported memory pools may not be used in ``hipDeviceSetMemPool``
        or ``hipMallocFromPoolAsync`` calls.

    See:
        `~.hipMemPoolExportToShareableHandle`

    Warning:
        This API is marked as beta, meaning, while this is feature complete,
        it is still open to changes and may have outstanding issues.

    Note:
        This API is implemented on Linux, under development on Windows.

    Args:
        shared_handle (`~.hip._util.types.Pointer`/`~.object`) -- *IN*:
            OS handle of the pool to open

        handle_type (`~.hipMemAllocationHandleType`) -- *IN*:
            The type of handle being imported

        flags (`~.int`) -- *IN*:
            Must be 0

    Returns:
        A `~.tuple` of size 2 that contains (in that order):

        * `~.hipError_t`: `~.hipSuccess`, `~.hipErrorInvalidValue`, `~.hipErrorOutOfMemory`
        * `~.ihipMemPoolHandle_t`:
                Returned memory pool
    """
    mem_pool = ihipMemPoolHandle_t.fromPtr(NULL)
    if not isinstance(handle_type,_hipMemAllocationHandleType__Base):
        raise TypeError("argument 'handle_type' must be of type '_hipMemAllocationHandleType__Base'")
    _hipMemPoolImportFromShareableHandle__retval = hipError_t(chip.hipMemPoolImportFromShareableHandle(<chip.ihipMemPoolHandle_t**>&mem_pool._ptr,
        <void *>hip._util.types.Pointer.fromPyobj(shared_handle)._ptr,handle_type.value,flags))
    return (_hipMemPoolImportFromShareableHandle__retval,None if mem_pool._ptr == NULL else mem_pool)


@cython.embedsignature(True)
def hipMemPoolExportPointer(object export_data, object dev_ptr):
    r"""Export data to share a memory pool allocation between processes.

    Constructs ``export_data`` for sharing a specific allocation from an already shared memory pool.
    The recipient process can import the allocation with the ``hipMemPoolImportPointer`` api.
    The data is not a handle and may be shared through any IPC mechanism.

    See:
        `~.hipMemPoolImportPointer`

    Warning:
        This API is marked as beta, meaning, while this is feature complete,
        it is still open to changes and may have outstanding issues.

    Note:
        This API is implemented on Linux, under development on Windows.

    Args:
        export_data (`~.hipMemPoolPtrExportData`/`~.object`) -- *OUT*:
            Returned export data

        dev_ptr (`~.hip._util.types.Pointer`/`~.object`) -- *IN*:
            Pointer to memory being exported

    Returns:
        A `~.tuple` of size 1 that contains (in that order):

        * `~.hipError_t`: `~.hipSuccess`, `~.hipErrorInvalidValue`, `~.hipErrorOutOfMemory`
    """
    _hipMemPoolExportPointer__retval = hipError_t(chip.hipMemPoolExportPointer(
        hipMemPoolPtrExportData.fromPyobj(export_data).getElementPtr(),
        <void *>hip._util.types.Pointer.fromPyobj(dev_ptr)._ptr))
    return (_hipMemPoolExportPointer__retval,)


@cython.embedsignature(True)
def hipMemPoolImportPointer(object mem_pool, object export_data):
    r"""Import a memory pool allocation from another process.

    Returns in ``dev_ptr`` a pointer to the imported memory.
    The imported memory must not be accessed before the allocation operation completes
    in the exporting process. The imported memory must be freed from all importing processes before
    being freed in the exporting process. The pointer may be freed with ``hipFree``
    or ``hipFreeAsync.`` If ``hipFreeAsync`` is used, the free must be completed
    on the importing process before the free operation on the exporting process.

    Note:
        The ``hipFreeAsync`` api may be used in the exporting process before
        the ``hipFreeAsync`` operation completes in its stream as long as the
        ``hipFreeAsync`` in the exporting process specifies a stream with
        a stream dependency on the importing process's ``hipFreeAsync.``

    See:
        `~.hipMemPoolExportPointer`

    Warning:
        This API is marked as beta, meaning, while this is feature complete,
        it is still open to changes and may have outstanding issues.

    Note:
        This API is implemented on Linux, under development on Windows.

    Args:
        mem_pool (`~.ihipMemPoolHandle_t`/`~.object`) -- *IN*:
            Memory pool from which to import a pointer

        export_data (`~.hipMemPoolPtrExportData`/`~.object`) -- *IN*:
            Data specifying the memory to import

    Returns:
        A `~.tuple` of size 2 that contains (in that order):

        * `~.hipError_t`: `~.hipSuccess`, `~.hipErrorInvalidValue`, `~.hipErrorNotInitialized`, `~.hipErrorOutOfMemory`
        * `~.hip._util.types.Pointer`/`~.object`:
                Pointer to imported memory
    """
    dev_ptr = hip._util.types.Pointer.fromPtr(NULL)
    _hipMemPoolImportPointer__retval = hipError_t(chip.hipMemPoolImportPointer(
        <void **>&dev_ptr._ptr,
        ihipMemPoolHandle_t.fromPyobj(mem_pool).getElementPtr(),
        hipMemPoolPtrExportData.fromPyobj(export_data).getElementPtr()))
    return (_hipMemPoolImportPointer__retval,None if dev_ptr._ptr == NULL else dev_ptr)


@cython.embedsignature(True)
def hipHostAlloc(unsigned long size, unsigned int flags):
    r"""Allocate device accessible page locked host memory [Deprecated]

    If size is 0, no memory is allocated, *ptr returns nullptr, and hipSuccess is returned.

    Warning:
        This API is deprecated, use hipHostMalloc() instead

    Args:
        size (`~.int`) -- *IN*:
            Requested memory size in bytes

        flags (`~.int`) -- *IN*:
            Type of host memory allocation

    Returns:
        A `~.tuple` of size 2 that contains (in that order):

        * `~.hipError_t`: `~.hipSuccess`, `~.hipErrorOutOfMemory`
        * `~.hip._util.types.Pointer`/`~.object`:
                Pointer to the allocated host pinned memory
    """
    ptr = hip._util.types.Pointer.fromPtr(NULL)
    _hipHostAlloc__retval = hipError_t(chip.hipHostAlloc(
        <void **>&ptr._ptr,size,flags))
    return (_hipHostAlloc__retval,None if ptr._ptr == NULL else ptr)


@cython.embedsignature(True)
def hipHostGetDevicePointer(object hstPtr, unsigned int flags):
    r"""Get Device pointer from Host Pointer allocated through hipHostMalloc

    See:
        `~.hipSetDeviceFlags`, `~.hipHostMalloc`

    Args:
        hstPtr (`~.hip._util.types.Pointer`/`~.object`) -- *IN*:
            Host Pointer allocated through hipHostMalloc

        flags (`~.int`) -- *IN*:
            Flags to be passed for extension

    Returns:
        A `~.tuple` of size 2 that contains (in that order):

        * `~.hipError_t`: `~.hipSuccess`, `~.hipErrorInvalidValue`, `~.hipErrorOutOfMemory`
        * `~.hip._util.types.Pointer`/`~.object`:
                Device Pointer mapped to passed host pointer
    """
    devPtr = hip._util.types.Pointer.fromPtr(NULL)
    _hipHostGetDevicePointer__retval = hipError_t(chip.hipHostGetDevicePointer(
        <void **>&devPtr._ptr,
        <void *>hip._util.types.Pointer.fromPyobj(hstPtr)._ptr,flags))
    return (_hipHostGetDevicePointer__retval,None if devPtr._ptr == NULL else devPtr)


@cython.embedsignature(True)
def hipHostGetFlags(object hostPtr):
    r"""Return flags associated with host pointer

    See:
        `~.hipHostMalloc`

    Args:
        hostPtr (`~.hip._util.types.Pointer`/`~.object`) -- *IN*:
            Host Pointer allocated through hipHostMalloc

    Returns:
        A `~.tuple` of size 2 that contains (in that order):

        * `~.hipError_t`: `~.hipSuccess`, `~.hipErrorInvalidValue`
        * `~.int`:
                Memory location to store flags
    """
    cdef unsigned int flagsPtr
    _hipHostGetFlags__retval = hipError_t(chip.hipHostGetFlags(&flagsPtr,
        <void *>hip._util.types.Pointer.fromPyobj(hostPtr)._ptr))
    return (_hipHostGetFlags__retval,flagsPtr)


@cython.embedsignature(True)
def hipHostRegister(object hostPtr, unsigned long sizeBytes, unsigned int flags):
    r"""Register host memory so it can be accessed from the current device.

    Flags:
     - `~.hipHostRegisterDefault`   Memory is Mapped and Portable
     - `~.hipHostRegisterPortable`  Memory is considered registered by all contexts.  HIP only supports
    one context so this is always assumed true.
     - `~.hipHostRegisterMapped`    Map the allocation into the address space for the current device.
    The device pointer can be obtained with `~.hipHostGetDevicePointer`.

     After registering the memory, use `~.hipHostGetDevicePointer` to obtain the mapped device pointer.
     On many systems, the mapped device pointer will have a different value than the mapped host
    pointer.  Applications must use the device pointer in device code, and the host pointer in device
    code.

     On some systems, registered memory is pinned.  On some systems, registered memory may not be
    actually be pinned but uses OS or hardware facilities to all GPU access to the host memory.

     Developers are strongly encouraged to register memory blocks which are aligned to the host
    cache-line size. (typically 64-bytes but can be obtains from the CPUID instruction).

     If registering non-aligned pointers, the application must take care when register pointers from
    the same cache line on different devices.  HIP's coarse-grained synchronization model does not
    guarantee correct results if different devices write to different parts of the same cache block -
    typically one of the writes will "win" and overwrite data from the other registered memory
    region.

    See:
        `~.hipHostUnregister`, `~.hipHostGetFlags`, `~.hipHostGetDevicePointer`

    Args:
        hostPtr (`~.hip._util.types.Pointer`/`~.object`) -- *OUT*:
            Pointer to host memory to be registered.

        sizeBytes (`~.int`) -- *IN*:
            Size of the host memory

        flags (`~.int`) -- *IN*:
            See below.

    Returns:
        A `~.tuple` of size 1 that contains (in that order):

        * `~.hipError_t`: `~.hipSuccess`, `~.hipErrorOutOfMemory`
    """
    _hipHostRegister__retval = hipError_t(chip.hipHostRegister(
        <void *>hip._util.types.Pointer.fromPyobj(hostPtr)._ptr,sizeBytes,flags))
    return (_hipHostRegister__retval,)


@cython.embedsignature(True)
def hipHostUnregister(object hostPtr):
    r"""Un-register host pointer

    See:
        `~.hipHostRegister`

    Args:
        hostPtr (`~.hip._util.types.Pointer`/`~.object`) -- *IN*:
            Host pointer previously registered with `~.hipHostRegister`

    Returns:
        A `~.tuple` of size 1 that contains (in that order):

        * `~.hipError_t`: Error code
    """
    _hipHostUnregister__retval = hipError_t(chip.hipHostUnregister(
        <void *>hip._util.types.Pointer.fromPyobj(hostPtr)._ptr))
    return (_hipHostUnregister__retval,)


@cython.embedsignature(True)
def hipMallocPitch(unsigned long width, unsigned long height):
    r"""(No short description, might be part of a group.)

    Allocates at least width (in bytes) * height bytes of linear memory
    Padding may occur to ensure alighnment requirements are met for the given row
    The change in width size due to padding will be returned in *pitch.
    Currently the alignment is set to 128 bytes

    If size is 0, no memory is allocated, *ptr returns nullptr, and hipSuccess is returned.

    See:
        `~.hipMalloc`, `~.hipFree`, `~.hipMallocArray`, `~.hipFreeArray`, `~.hipHostFree`, `~.hipMalloc3D`,
        `~.hipMalloc3DArray`, `~.hipHostMalloc`

    Args:
        width (`~.int`) -- *IN*:
            Requested pitched allocation width (in bytes)

        height (`~.int`) -- *IN*:
            Requested pitched allocation height

    Returns:
        A `~.tuple` of size 3 that contains (in that order):

        * `~.hipError_t`: Error code
        * `~.hip._util.types.Pointer`/`~.object`:
                Pointer to the allocated device memory
        * `~.int`:
                Pitch for allocation (in bytes)
    """
    ptr = hip._util.types.Pointer.fromPtr(NULL)
    cdef unsigned long pitch
    _hipMallocPitch__retval = hipError_t(chip.hipMallocPitch(
        <void **>&ptr._ptr,&pitch,width,height))
    return (_hipMallocPitch__retval,None if ptr._ptr == NULL else ptr,pitch)


@cython.embedsignature(True)
def hipMemAllocPitch(unsigned long widthInBytes, unsigned long height, unsigned int elementSizeBytes):
    r"""(No short description, might be part of a group.)

    Allocates at least width (in bytes) * height bytes of linear memory
    Padding may occur to ensure alighnment requirements are met for the given row
    The change in width size due to padding will be returned in *pitch.
    Currently the alignment is set to 128 bytes

    If size is 0, no memory is allocated, *ptr returns nullptr, and hipSuccess is returned.
    The intended usage of pitch is as a separate parameter of the allocation, used to compute addresses within the 2D array.
    Given the row and column of an array element of type T, the address is computed as:
    T* pElement = (T*)((char*)BaseAddress + Row * Pitch) + Column;

    See:
        `~.hipMalloc`, `~.hipFree`, `~.hipMallocArray`, `~.hipFreeArray`, `~.hipHostFree`, `~.hipMalloc3D`,
        `~.hipMalloc3DArray`, `~.hipHostMalloc`

    Args:
        widthInBytes (`~.int`) -- *IN*:
            Requested pitched allocation width (in bytes)

        height (`~.int`) -- *IN*:
            Requested pitched allocation height

        elementSizeBytes (`~.int`) -- *IN*:
            The size of element bytes, should be 4, 8 or 16

    Returns:
        A `~.tuple` of size 3 that contains (in that order):

        * `~.hipError_t`: Error code
        * `~.hip._util.types.Pointer`/`~.object`:
                Pointer to the allocated device memory
        * `~.int`:
                Pitch for allocation (in bytes)
    """
    dptr = hip._util.types.Pointer.fromPtr(NULL)
    cdef unsigned long pitch
    _hipMemAllocPitch__retval = hipError_t(chip.hipMemAllocPitch(
        <void **>&dptr._ptr,&pitch,widthInBytes,height,elementSizeBytes))
    return (_hipMemAllocPitch__retval,None if dptr._ptr == NULL else dptr,pitch)


@cython.embedsignature(True)
def hipFree(object ptr):
    r"""Free memory allocated by the hcc hip memory allocation API.
     This API performs an implicit hipDeviceSynchronize() call.
     If pointer is NULL, the hip runtime is initialized and hipSuccess is returned.

    See:
        `~.hipMalloc`, `~.hipMallocPitch`, `~.hipMallocArray`, `~.hipFreeArray`, `~.hipHostFree`, `~.hipMalloc3D`,
        `~.hipMalloc3DArray`, `~.hipHostMalloc`

    Args:
        ptr (`~.hip._util.types.Pointer`/`~.object`) -- *IN*:
            Pointer to memory to be freed

    Returns:
        A `~.tuple` of size 1 that contains (in that order):

        * `~.hipError_t`: One of:
                -        `~.hipSuccess`

                - `~.hipErrorInvalidDevicePointer` (if pointer is invalid, including host pointers allocated
                    with hipHostMalloc)
    """
    _hipFree__retval = hipError_t(chip.hipFree(
        <void *>hip._util.types.Pointer.fromPyobj(ptr)._ptr))
    return (_hipFree__retval,)


@cython.embedsignature(True)
def hipFreeHost(object ptr):
    r"""Free memory allocated by the hcc hip host memory allocation API [Deprecated]

    Warning:
        This API is deprecated, use hipHostFree() instead

    Args:
        ptr (`~.hip._util.types.Pointer`/`~.object`) -- *IN*:
            Pointer to memory to be freed

    Returns:
        A `~.tuple` of size 1 that contains (in that order):

        * `~.hipError_t`: `~.hipSuccess`,
                    `~.hipErrorInvalidValue` (if pointer is invalid, including device pointers allocated
            with hipMalloc)
    """
    _hipFreeHost__retval = hipError_t(chip.hipFreeHost(
        <void *>hip._util.types.Pointer.fromPyobj(ptr)._ptr))
    return (_hipFreeHost__retval,)


@cython.embedsignature(True)
def hipHostFree(object ptr):
    r"""Free memory allocated by the hcc hip host memory allocation API
     This API performs an implicit hipDeviceSynchronize() call.
     If pointer is NULL, the hip runtime is initialized and hipSuccess is returned.

    See:
        `~.hipMalloc`, `~.hipMallocPitch`, `~.hipFree`, `~.hipMallocArray`, `~.hipFreeArray`, `~.hipMalloc3D`,
        `~.hipMalloc3DArray`, `~.hipHostMalloc`

    Args:
        ptr (`~.hip._util.types.Pointer`/`~.object`) -- *IN*:
            Pointer to memory to be freed

    Returns:
        A `~.tuple` of size 1 that contains (in that order):

        * `~.hipError_t`: `~.hipSuccess`,
                     `~.hipErrorInvalidValue` (if pointer is invalid, including device pointers allocated with
            hipMalloc)
    """
    _hipHostFree__retval = hipError_t(chip.hipHostFree(
        <void *>hip._util.types.Pointer.fromPyobj(ptr)._ptr))
    return (_hipHostFree__retval,)


@cython.embedsignature(True)
def hipMemcpy(object dst, object src, unsigned long sizeBytes, object kind):
    r"""Copy data from src to dst.

    It supports memory from host to device,
    device to host, device to device and host to host
    The src and dst must not overlap.

    For hipMemcpy, the copy is always performed by the current device (set by hipSetDevice).
    For multi-gpu or peer-to-peer configurations, it is recommended to set the current device to the
    device where the src data is physically located. For optimal peer-to-peer copies, the copy device
    must be able to access the src and dst pointers (by calling hipDeviceEnablePeerAccess with copy
    agent as the current device and src/dest as the peerDevice argument.  if this is not done, the
    hipMemcpy will still work, but will perform the copy using a staging buffer on the host.
    Calling hipMemcpy with dst and src pointers that do not match the hipMemcpyKind results in
    undefined behavior.

    See:
        `~.hipArrayCreate`, `~.hipArrayDestroy`, `~.hipArrayGetDescriptor`, `~.hipMemAlloc`, `~.hipMemAllocHost`,
        `~.hipMemAllocPitch`, `~.hipMemcpy2D`, `~.hipMemcpy2DAsync`, `~.hipMemcpy2DUnaligned`, `~.hipMemcpyAtoA`,
        `~.hipMemcpyAtoD`, `~.hipMemcpyAtoH`, `~.hipMemcpyAtoHAsync`, `~.hipMemcpyDtoA`, `~.hipMemcpyDtoD`,
        `~.hipMemcpyDtoDAsync`, `~.hipMemcpyDtoH`, `~.hipMemcpyDtoHAsync`, `~.hipMemcpyHtoA`, `~.hipMemcpyHtoAAsync`,
        `~.hipMemcpyHtoDAsync`, `~.hipMemFree`, `~.hipMemFreeHost`, `~.hipMemGetAddressRange`, `~.hipMemGetInfo`,
        `~.hipMemHostAlloc`, `~.hipMemHostGetDevicePointer`

    Args:
        dst (`~.hip._util.types.Pointer`/`~.object`) -- *OUT*:
            Data being copy to

        src (`~.hip._util.types.Pointer`/`~.object`) -- *IN*:
            Data being copy from

        sizeBytes (`~.int`) -- *IN*:
            Data size in bytes

        kind (`~.hipMemcpyKind`) -- *IN*:
            Kind of transfer

    Returns:
        A `~.tuple` of size 1 that contains (in that order):

        * `~.hipError_t`: `~.hipSuccess`, `~.hipErrorInvalidValue`, `~.hipErrorUnknown`
    """
    if not isinstance(kind,_hipMemcpyKind__Base):
        raise TypeError("argument 'kind' must be of type '_hipMemcpyKind__Base'")
    _hipMemcpy__retval = hipError_t(chip.hipMemcpy(
        <void *>hip._util.types.Pointer.fromPyobj(dst)._ptr,
        <const void *>hip._util.types.Pointer.fromPyobj(src)._ptr,sizeBytes,kind.value))
    return (_hipMemcpy__retval,)


@cython.embedsignature(True)
def hipMemcpyWithStream(object dst, object src, unsigned long sizeBytes, object kind, object stream):
    r"""Memory copy on the stream.
    It allows single or multiple devices to do memory copy on single or multiple streams.

    See:
        `~.hipMemcpy`, `~.hipStreamCreate`, `~.hipStreamSynchronize`, `~.hipStreamDestroy`, `~.hipSetDevice`, `~.hipLaunchKernelGGL`

    Args:
        dst (`~.hip._util.types.Pointer`/`~.object`) -- *OUT*:
            Data being copy to

        src (`~.hip._util.types.Pointer`/`~.object`) -- *IN*:
            Data being copy from

        sizeBytes (`~.int`) -- *IN*:
            Data size in bytes

        kind (`~.hipMemcpyKind`) -- *IN*:
            Kind of transfer

        stream (`~.ihipStream_t`/`~.object`) -- *IN*:
            Valid stream

    Returns:
        A `~.tuple` of size 1 that contains (in that order):

        * `~.hipError_t`: `~.hipSuccess`, `~.hipErrorInvalidValue`, `~.hipErrorUnknown`, `~.hipErrorContextIsDestroyed`
    """
    if not isinstance(kind,_hipMemcpyKind__Base):
        raise TypeError("argument 'kind' must be of type '_hipMemcpyKind__Base'")
    _hipMemcpyWithStream__retval = hipError_t(chip.hipMemcpyWithStream(
        <void *>hip._util.types.Pointer.fromPyobj(dst)._ptr,
        <const void *>hip._util.types.Pointer.fromPyobj(src)._ptr,sizeBytes,kind.value,
        ihipStream_t.fromPyobj(stream).getElementPtr()))
    return (_hipMemcpyWithStream__retval,)


@cython.embedsignature(True)
def hipMemcpyHtoD(object dst, object src, unsigned long sizeBytes):
    r"""Copy data from Host to Device

    See:
        `~.hipArrayCreate`, `~.hipArrayDestroy`, `~.hipArrayGetDescriptor`, `~.hipMemAlloc`, `~.hipMemAllocHost`,
        `~.hipMemAllocPitch`, `~.hipMemcpy2D`, `~.hipMemcpy2DAsync`, `~.hipMemcpy2DUnaligned`, `~.hipMemcpyAtoA`,
        `~.hipMemcpyAtoD`, `~.hipMemcpyAtoH`, `~.hipMemcpyAtoHAsync`, `~.hipMemcpyDtoA`, `~.hipMemcpyDtoD`,
        `~.hipMemcpyDtoDAsync`, `~.hipMemcpyDtoH`, `~.hipMemcpyDtoHAsync`, `~.hipMemcpyHtoA`, `~.hipMemcpyHtoAAsync`,
        `~.hipMemcpyHtoDAsync`, `~.hipMemFree`, `~.hipMemFreeHost`, `~.hipMemGetAddressRange`, `~.hipMemGetInfo`,
        `~.hipMemHostAlloc`, `~.hipMemHostGetDevicePointer`

    Args:
        dst (`~.hip._util.types.Pointer`/`~.object`) -- *OUT*:
            Data being copy to

        src (`~.hip._util.types.Pointer`/`~.object`) -- *IN*:
            Data being copy from

        sizeBytes (`~.int`) -- *IN*:
            Data size in bytes

    Returns:
        A `~.tuple` of size 1 that contains (in that order):

        * `~.hipError_t`: `~.hipSuccess`, `~.hipErrorDeinitialized`, `~.hipErrorNotInitialized`, `~.hipErrorInvalidContext`,
            `~.hipErrorInvalidValue`
    """
    _hipMemcpyHtoD__retval = hipError_t(chip.hipMemcpyHtoD(
        <void *>hip._util.types.Pointer.fromPyobj(dst)._ptr,
        <void *>hip._util.types.Pointer.fromPyobj(src)._ptr,sizeBytes))
    return (_hipMemcpyHtoD__retval,)


@cython.embedsignature(True)
def hipMemcpyDtoH(object dst, object src, unsigned long sizeBytes):
    r"""Copy data from Device to Host

    See:
        `~.hipArrayCreate`, `~.hipArrayDestroy`, `~.hipArrayGetDescriptor`, `~.hipMemAlloc`, `~.hipMemAllocHost`,
        `~.hipMemAllocPitch`, `~.hipMemcpy2D`, `~.hipMemcpy2DAsync`, `~.hipMemcpy2DUnaligned`, `~.hipMemcpyAtoA`,
        `~.hipMemcpyAtoD`, `~.hipMemcpyAtoH`, `~.hipMemcpyAtoHAsync`, `~.hipMemcpyDtoA`, `~.hipMemcpyDtoD`,
        `~.hipMemcpyDtoDAsync`, `~.hipMemcpyDtoH`, `~.hipMemcpyDtoHAsync`, `~.hipMemcpyHtoA`, `~.hipMemcpyHtoAAsync`,
        `~.hipMemcpyHtoDAsync`, `~.hipMemFree`, `~.hipMemFreeHost`, `~.hipMemGetAddressRange`, `~.hipMemGetInfo`,
        `~.hipMemHostAlloc`, `~.hipMemHostGetDevicePointer`

    Args:
        dst (`~.hip._util.types.Pointer`/`~.object`) -- *OUT*:
            Data being copy to

        src (`~.hip._util.types.Pointer`/`~.object`) -- *IN*:
            Data being copy from

        sizeBytes (`~.int`) -- *IN*:
            Data size in bytes

    Returns:
        A `~.tuple` of size 1 that contains (in that order):

        * `~.hipError_t`: `~.hipSuccess`, `~.hipErrorDeinitialized`, `~.hipErrorNotInitialized`, `~.hipErrorInvalidContext`,
            `~.hipErrorInvalidValue`
    """
    _hipMemcpyDtoH__retval = hipError_t(chip.hipMemcpyDtoH(
        <void *>hip._util.types.Pointer.fromPyobj(dst)._ptr,
        <void *>hip._util.types.Pointer.fromPyobj(src)._ptr,sizeBytes))
    return (_hipMemcpyDtoH__retval,)


@cython.embedsignature(True)
def hipMemcpyDtoD(object dst, object src, unsigned long sizeBytes):
    r"""Copy data from Device to Device

    See:
        `~.hipArrayCreate`, `~.hipArrayDestroy`, `~.hipArrayGetDescriptor`, `~.hipMemAlloc`, `~.hipMemAllocHost`,
        `~.hipMemAllocPitch`, `~.hipMemcpy2D`, `~.hipMemcpy2DAsync`, `~.hipMemcpy2DUnaligned`, `~.hipMemcpyAtoA`,
        `~.hipMemcpyAtoD`, `~.hipMemcpyAtoH`, `~.hipMemcpyAtoHAsync`, `~.hipMemcpyDtoA`, `~.hipMemcpyDtoD`,
        `~.hipMemcpyDtoDAsync`, `~.hipMemcpyDtoH`, `~.hipMemcpyDtoHAsync`, `~.hipMemcpyHtoA`, `~.hipMemcpyHtoAAsync`,
        `~.hipMemcpyHtoDAsync`, `~.hipMemFree`, `~.hipMemFreeHost`, `~.hipMemGetAddressRange`, `~.hipMemGetInfo`,
        `~.hipMemHostAlloc`, `~.hipMemHostGetDevicePointer`

    Args:
        dst (`~.hip._util.types.Pointer`/`~.object`) -- *OUT*:
            Data being copy to

        src (`~.hip._util.types.Pointer`/`~.object`) -- *IN*:
            Data being copy from

        sizeBytes (`~.int`) -- *IN*:
            Data size in bytes

    Returns:
        A `~.tuple` of size 1 that contains (in that order):

        * `~.hipError_t`: `~.hipSuccess`, `~.hipErrorDeinitialized`, `~.hipErrorNotInitialized`, `~.hipErrorInvalidContext`,
            `~.hipErrorInvalidValue`
    """
    _hipMemcpyDtoD__retval = hipError_t(chip.hipMemcpyDtoD(
        <void *>hip._util.types.Pointer.fromPyobj(dst)._ptr,
        <void *>hip._util.types.Pointer.fromPyobj(src)._ptr,sizeBytes))
    return (_hipMemcpyDtoD__retval,)


@cython.embedsignature(True)
def hipMemcpyAtoD(object dstDevice, object srcArray, unsigned long srcOffset, unsigned long ByteCount):
    r"""Copies from one 1D array to device memory.

    See:
        `~.hipArrayCreate`, `~.hipArrayDestroy`, `~.hipArrayGetDescriptor`, `~.hipMemAlloc`, `~.hipMemAllocHost`,
        `~.hipMemAllocPitch`, `~.hipMemcpy2D`, `~.hipMemcpy2DAsync`, `~.hipMemcpy2DUnaligned`, `~.hipMemcpyAtoA`,
        `~.hipMemcpyAtoD`, `~.hipMemcpyAtoH`, `~.hipMemcpyAtoHAsync`, `~.hipMemcpyDtoA`, `~.hipMemcpyDtoD`,
        `~.hipMemcpyDtoDAsync`, `~.hipMemcpyDtoH`, `~.hipMemcpyDtoHAsync`, `~.hipMemcpyHtoA`, `~.hipMemcpyHtoAAsync`,
        `~.hipMemcpyHtoDAsync`, `~.hipMemFree`, `~.hipMemFreeHost`, `~.hipMemGetAddressRange`, `~.hipMemGetInfo`,
        `~.hipMemHostAlloc`, `~.hipMemHostGetDevicePointer`

    Args:
        dstDevice (`~.hip._util.types.Pointer`/`~.object`) -- *OUT*:
            Destination device pointer

        srcArray (`~.hipArray`/`~.object`) -- *IN*:
            Source array

        srcOffset (`~.int`) -- *IN*:
            Offset in bytes of source array

        ByteCount (`~.int`) -- *IN*:
            Size of memory copy in bytes

    Returns:
        A `~.tuple` of size 1 that contains (in that order):

        * `~.hipError_t`: `~.hipSuccess`, `~.hipErrorDeinitialized`, `~.hipErrorNotInitialized`, `~.hipErrorInvalidContext`,
            `~.hipErrorInvalidValue`
    """
    _hipMemcpyAtoD__retval = hipError_t(chip.hipMemcpyAtoD(
        <void *>hip._util.types.Pointer.fromPyobj(dstDevice)._ptr,
        hipArray.fromPyobj(srcArray).getElementPtr(),srcOffset,ByteCount))
    return (_hipMemcpyAtoD__retval,)


@cython.embedsignature(True)
def hipMemcpyDtoA(object dstArray, unsigned long dstOffset, object srcDevice, unsigned long ByteCount):
    r"""Copies from device memory to a 1D array.

    See:
        `~.hipArrayCreate`, `~.hipArrayDestroy`, `~.hipArrayGetDescriptor`, `~.hipMemAlloc`, `~.hipMemAllocHost`,
        `~.hipMemAllocPitch`, `~.hipMemcpy2D`, `~.hipMemcpy2DAsync`, `~.hipMemcpy2DUnaligned`, `~.hipMemcpyAtoA`,
        `~.hipMemcpyAtoD`, `~.hipMemcpyAtoH`, `~.hipMemcpyAtoHAsync`, `~.hipMemcpyDtoA`, `~.hipMemcpyDtoD`,
        `~.hipMemcpyDtoDAsync`, `~.hipMemcpyDtoH`, `~.hipMemcpyDtoHAsync`, `~.hipMemcpyHtoA`, `~.hipMemcpyHtoAAsync`,
        `~.hipMemcpyHtoDAsync`, `~.hipMemFree`, `~.hipMemFreeHost`, `~.hipMemGetAddressRange`, `~.hipMemGetInfo`,
        `~.hipMemHostAlloc`, `~.hipMemHostGetDevicePointer`

    Args:
        dstArray (`~.hipArray`/`~.object`) -- *OUT*:
            Destination array

        dstOffset (`~.int`) -- *IN*:
            Offset in bytes of destination array

        srcDevice (`~.hip._util.types.Pointer`/`~.object`) -- *IN*:
            Source device pointer

        ByteCount (`~.int`) -- *IN*:
            Size of memory copy in bytes

    Returns:
        A `~.tuple` of size 1 that contains (in that order):

        * `~.hipError_t`: `~.hipSuccess`, `~.hipErrorDeinitialized`, `~.hipErrorNotInitialized`, `~.hipErrorInvalidContext`,
            `~.hipErrorInvalidValue`
    """
    _hipMemcpyDtoA__retval = hipError_t(chip.hipMemcpyDtoA(
        hipArray.fromPyobj(dstArray).getElementPtr(),dstOffset,
        <void *>hip._util.types.Pointer.fromPyobj(srcDevice)._ptr,ByteCount))
    return (_hipMemcpyDtoA__retval,)


@cython.embedsignature(True)
def hipMemcpyAtoA(object dstArray, unsigned long dstOffset, object srcArray, unsigned long srcOffset, unsigned long ByteCount):
    r"""Copies from one 1D array to another.

    See:
        `~.hipArrayCreate`, `~.hipArrayDestroy`, `~.hipArrayGetDescriptor`, `~.hipMemAlloc`, `~.hipMemAllocHost`,
        `~.hipMemAllocPitch`, `~.hipMemcpy2D`, `~.hipMemcpy2DAsync`, `~.hipMemcpy2DUnaligned`, `~.hipMemcpyAtoA`,
        `~.hipMemcpyAtoD`, `~.hipMemcpyAtoH`, `~.hipMemcpyAtoHAsync`, `~.hipMemcpyDtoA`, `~.hipMemcpyDtoD`,
        `~.hipMemcpyDtoDAsync`, `~.hipMemcpyDtoH`, `~.hipMemcpyDtoHAsync`, `~.hipMemcpyHtoA`, `~.hipMemcpyHtoAAsync`,
        `~.hipMemcpyHtoDAsync`, `~.hipMemFree`, `~.hipMemFreeHost`, `~.hipMemGetAddressRange`, `~.hipMemGetInfo`,
        `~.hipMemHostAlloc`, `~.hipMemHostGetDevicePointer`

    Args:
        dstArray (`~.hipArray`/`~.object`) -- *OUT*:
            Destination array

        dstOffset (`~.int`) -- *IN*:
            Offset in bytes of destination array

        srcArray (`~.hipArray`/`~.object`) -- *IN*:
            Source array

        srcOffset (`~.int`) -- *IN*:
            Offset in bytes of source array

        ByteCount (`~.int`) -- *IN*:
            Size of memory copy in bytes

    Returns:
        A `~.tuple` of size 1 that contains (in that order):

        * `~.hipError_t`: `~.hipSuccess`, `~.hipErrorDeinitialized`, `~.hipErrorNotInitialized`, `~.hipErrorInvalidContext`,
            `~.hipErrorInvalidValue`
    """
    _hipMemcpyAtoA__retval = hipError_t(chip.hipMemcpyAtoA(
        hipArray.fromPyobj(dstArray).getElementPtr(),dstOffset,
        hipArray.fromPyobj(srcArray).getElementPtr(),srcOffset,ByteCount))
    return (_hipMemcpyAtoA__retval,)


@cython.embedsignature(True)
def hipMemcpyHtoDAsync(object dst, object src, unsigned long sizeBytes, object stream):
    r"""Copy data from Host to Device asynchronously

    See:
        `~.hipArrayCreate`, `~.hipArrayDestroy`, `~.hipArrayGetDescriptor`, `~.hipMemAlloc`, `~.hipMemAllocHost`,
        `~.hipMemAllocPitch`, `~.hipMemcpy2D`, `~.hipMemcpy2DAsync`, `~.hipMemcpy2DUnaligned`, `~.hipMemcpyAtoA`,
        `~.hipMemcpyAtoD`, `~.hipMemcpyAtoH`, `~.hipMemcpyAtoHAsync`, `~.hipMemcpyDtoA`, `~.hipMemcpyDtoD`,
        `~.hipMemcpyDtoDAsync`, `~.hipMemcpyDtoH`, `~.hipMemcpyDtoHAsync`, `~.hipMemcpyHtoA`, `~.hipMemcpyHtoAAsync`,
        `~.hipMemcpyHtoDAsync`, `~.hipMemFree`, `~.hipMemFreeHost`, `~.hipMemGetAddressRange`, `~.hipMemGetInfo`,
        `~.hipMemHostAlloc`, `~.hipMemHostGetDevicePointer`

    Args:
        dst (`~.hip._util.types.Pointer`/`~.object`) -- *OUT*:
            Data being copy to

        src (`~.hip._util.types.Pointer`/`~.object`) -- *IN*:
            Data being copy from

        sizeBytes (`~.int`) -- *IN*:
            Data size in bytes

        stream (`~.ihipStream_t`/`~.object`) -- *IN*:
            Stream identifier

    Returns:
        A `~.tuple` of size 1 that contains (in that order):

        * `~.hipError_t`: `~.hipSuccess`, `~.hipErrorDeinitialized`, `~.hipErrorNotInitialized`, `~.hipErrorInvalidContext`,
            `~.hipErrorInvalidValue`
    """
    _hipMemcpyHtoDAsync__retval = hipError_t(chip.hipMemcpyHtoDAsync(
        <void *>hip._util.types.Pointer.fromPyobj(dst)._ptr,
        <void *>hip._util.types.Pointer.fromPyobj(src)._ptr,sizeBytes,
        ihipStream_t.fromPyobj(stream).getElementPtr()))
    return (_hipMemcpyHtoDAsync__retval,)


@cython.embedsignature(True)
def hipMemcpyDtoHAsync(object dst, object src, unsigned long sizeBytes, object stream):
    r"""Copy data from Device to Host asynchronously

    See:
        `~.hipArrayCreate`, `~.hipArrayDestroy`, `~.hipArrayGetDescriptor`, `~.hipMemAlloc`, `~.hipMemAllocHost`,
        `~.hipMemAllocPitch`, `~.hipMemcpy2D`, `~.hipMemcpy2DAsync`, `~.hipMemcpy2DUnaligned`, `~.hipMemcpyAtoA`,
        `~.hipMemcpyAtoD`, `~.hipMemcpyAtoH`, `~.hipMemcpyAtoHAsync`, `~.hipMemcpyDtoA`, `~.hipMemcpyDtoD`,
        `~.hipMemcpyDtoDAsync`, `~.hipMemcpyDtoH`, `~.hipMemcpyDtoHAsync`, `~.hipMemcpyHtoA`, `~.hipMemcpyHtoAAsync`,
        `~.hipMemcpyHtoDAsync`, `~.hipMemFree`, `~.hipMemFreeHost`, `~.hipMemGetAddressRange`, `~.hipMemGetInfo`,
        `~.hipMemHostAlloc`, `~.hipMemHostGetDevicePointer`

    Args:
        dst (`~.hip._util.types.Pointer`/`~.object`) -- *OUT*:
            Data being copy to

        src (`~.hip._util.types.Pointer`/`~.object`) -- *IN*:
            Data being copy from

        sizeBytes (`~.int`) -- *IN*:
            Data size in bytes

        stream (`~.ihipStream_t`/`~.object`) -- *IN*:
            Stream identifier

    Returns:
        A `~.tuple` of size 1 that contains (in that order):

        * `~.hipError_t`: `~.hipSuccess`, `~.hipErrorDeinitialized`, `~.hipErrorNotInitialized`, `~.hipErrorInvalidContext`,
            `~.hipErrorInvalidValue`
    """
    _hipMemcpyDtoHAsync__retval = hipError_t(chip.hipMemcpyDtoHAsync(
        <void *>hip._util.types.Pointer.fromPyobj(dst)._ptr,
        <void *>hip._util.types.Pointer.fromPyobj(src)._ptr,sizeBytes,
        ihipStream_t.fromPyobj(stream).getElementPtr()))
    return (_hipMemcpyDtoHAsync__retval,)


@cython.embedsignature(True)
def hipMemcpyDtoDAsync(object dst, object src, unsigned long sizeBytes, object stream):
    r"""Copy data from Device to Device asynchronously

    See:
        `~.hipArrayCreate`, `~.hipArrayDestroy`, `~.hipArrayGetDescriptor`, `~.hipMemAlloc`, `~.hipMemAllocHost`,
        `~.hipMemAllocPitch`, `~.hipMemcpy2D`, `~.hipMemcpy2DAsync`, `~.hipMemcpy2DUnaligned`, `~.hipMemcpyAtoA`,
        `~.hipMemcpyAtoD`, `~.hipMemcpyAtoH`, `~.hipMemcpyAtoHAsync`, `~.hipMemcpyDtoA`, `~.hipMemcpyDtoD`,
        `~.hipMemcpyDtoDAsync`, `~.hipMemcpyDtoH`, `~.hipMemcpyDtoHAsync`, `~.hipMemcpyHtoA`, `~.hipMemcpyHtoAAsync`,
        `~.hipMemcpyHtoDAsync`, `~.hipMemFree`, `~.hipMemFreeHost`, `~.hipMemGetAddressRange`, `~.hipMemGetInfo`,
        `~.hipMemHostAlloc`, `~.hipMemHostGetDevicePointer`

    Args:
        dst (`~.hip._util.types.Pointer`/`~.object`) -- *OUT*:
            Data being copy to

        src (`~.hip._util.types.Pointer`/`~.object`) -- *IN*:
            Data being copy from

        sizeBytes (`~.int`) -- *IN*:
            Data size in bytes

        stream (`~.ihipStream_t`/`~.object`) -- *IN*:
            Stream identifier

    Returns:
        A `~.tuple` of size 1 that contains (in that order):

        * `~.hipError_t`: `~.hipSuccess`, `~.hipErrorDeinitialized`, `~.hipErrorNotInitialized`, `~.hipErrorInvalidContext`,
            `~.hipErrorInvalidValue`
    """
    _hipMemcpyDtoDAsync__retval = hipError_t(chip.hipMemcpyDtoDAsync(
        <void *>hip._util.types.Pointer.fromPyobj(dst)._ptr,
        <void *>hip._util.types.Pointer.fromPyobj(src)._ptr,sizeBytes,
        ihipStream_t.fromPyobj(stream).getElementPtr()))
    return (_hipMemcpyDtoDAsync__retval,)


@cython.embedsignature(True)
def hipMemcpyAtoHAsync(object dstHost, object srcArray, unsigned long srcOffset, unsigned long ByteCount, object stream):
    r"""Copies from one 1D array to host memory.

    See:
        `~.hipArrayCreate`, `~.hipArrayDestroy`, `~.hipArrayGetDescriptor`, `~.hipMemAlloc`, `~.hipMemAllocHost`,
        `~.hipMemAllocPitch`, `~.hipMemcpy2D`, `~.hipMemcpy2DAsync`, `~.hipMemcpy2DUnaligned`, `~.hipMemcpyAtoA`,
        `~.hipMemcpyAtoD`, `~.hipMemcpyAtoH`, `~.hipMemcpyAtoHAsync`, `~.hipMemcpyDtoA`, `~.hipMemcpyDtoD`,
        `~.hipMemcpyDtoDAsync`, `~.hipMemcpyDtoH`, `~.hipMemcpyDtoHAsync`, `~.hipMemcpyHtoA`, `~.hipMemcpyHtoAAsync`,
        `~.hipMemcpyHtoDAsync`, `~.hipMemFree`, `~.hipMemFreeHost`, `~.hipMemGetAddressRange`, `~.hipMemGetInfo`,
        `~.hipMemHostAlloc`, `~.hipMemHostGetDevicePointer`

    Args:
        dstHost (`~.hip._util.types.Pointer`/`~.object`) -- *OUT*:
            Destination pointer

        srcArray (`~.hipArray`/`~.object`) -- *IN*:
            Source array

        srcOffset (`~.int`) -- *IN*:
            Offset in bytes of source array

        ByteCount (`~.int`) -- *IN*:
            Size of memory copy in bytes

        stream (`~.ihipStream_t`/`~.object`) -- *IN*:
            Stream identifier

    Returns:
        A `~.tuple` of size 1 that contains (in that order):

        * `~.hipError_t`: `~.hipSuccess`, `~.hipErrorDeinitialized`, `~.hipErrorNotInitialized`, `~.hipErrorInvalidContext`,
            `~.hipErrorInvalidValue`
    """
    _hipMemcpyAtoHAsync__retval = hipError_t(chip.hipMemcpyAtoHAsync(
        <void *>hip._util.types.Pointer.fromPyobj(dstHost)._ptr,
        hipArray.fromPyobj(srcArray).getElementPtr(),srcOffset,ByteCount,
        ihipStream_t.fromPyobj(stream).getElementPtr()))
    return (_hipMemcpyAtoHAsync__retval,)


@cython.embedsignature(True)
def hipMemcpyHtoAAsync(object dstArray, unsigned long dstOffset, object srcHost, unsigned long ByteCount, object stream):
    r"""Copies from host memory to a 1D array.

    See:
        `~.hipArrayCreate`, `~.hipArrayDestroy`, `~.hipArrayGetDescriptor`, `~.hipMemAlloc`, `~.hipMemAllocHost`,
        `~.hipMemAllocPitch`, `~.hipMemcpy2D`, `~.hipMemcpy2DAsync`, `~.hipMemcpy2DUnaligned`, `~.hipMemcpyAtoA`,
        `~.hipMemcpyAtoD`, `~.hipMemcpyAtoH`, `~.hipMemcpyAtoHAsync`, `~.hipMemcpyDtoA`, `~.hipMemcpyDtoD`,
        `~.hipMemcpyDtoDAsync`, `~.hipMemcpyDtoH`, `~.hipMemcpyDtoHAsync`, `~.hipMemcpyHtoA`, `~.hipMemcpyHtoAAsync`,
        `~.hipMemcpyHtoDAsync`, `~.hipMemFree`, `~.hipMemFreeHost`, `~.hipMemGetAddressRange`, `~.hipMemGetInfo`,
        `~.hipMemHostAlloc`, `~.hipMemHostGetDevicePointer`

    Args:
        dstArray (`~.hipArray`/`~.object`) -- *OUT*:
            Destination array

        dstOffset (`~.int`) -- *IN*:
            Offset in bytes of destination array

        srcHost (`~.hip._util.types.Pointer`/`~.object`) -- *IN*:
            Source host pointer

        ByteCount (`~.int`) -- *IN*:
            Size of memory copy in bytes

        stream (`~.ihipStream_t`/`~.object`) -- *IN*:
            Stream identifier

    Returns:
        A `~.tuple` of size 1 that contains (in that order):

        * `~.hipError_t`: `~.hipSuccess`, `~.hipErrorDeinitialized`, `~.hipErrorNotInitialized`, `~.hipErrorInvalidContext`,
            `~.hipErrorInvalidValue`
    """
    _hipMemcpyHtoAAsync__retval = hipError_t(chip.hipMemcpyHtoAAsync(
        hipArray.fromPyobj(dstArray).getElementPtr(),dstOffset,
        <const void *>hip._util.types.Pointer.fromPyobj(srcHost)._ptr,ByteCount,
        ihipStream_t.fromPyobj(stream).getElementPtr()))
    return (_hipMemcpyHtoAAsync__retval,)


@cython.embedsignature(True)
def hipModuleGetGlobal(object hmod, object name):
    r"""Returns a global pointer from a module.
    Returns in *dptr and *bytes the pointer and size of the global of name name located in module hmod.
    If no variable of that name exists, it returns hipErrorNotFound. Both parameters dptr and bytes are optional.
    If one of them is NULL, it is ignored and hipSuccess is returned.

    Args:
        hmod (`~.ihipModule_t`/`~.object`) -- *IN*:
            Module to retrieve global from

        name (`~.hip._util.types.CStr`/`~.object`) -- *IN*:
            Name of global to retrieve

    Returns:
        A `~.tuple` of size 3 that contains (in that order):

        * `~.hipError_t`: `~.hipSuccess`, `~.hipErrorInvalidValue`, `~.hipErrorNotFound`, `~.hipErrorInvalidContext`
        * `~.hip._util.types.Pointer`/`~.object`:
                Returns global device pointer
        * `~.int`:
                Returns global size in bytes
    """
    dptr = hip._util.types.Pointer.fromPtr(NULL)
    cdef unsigned long bytes
    _hipModuleGetGlobal__retval = hipError_t(chip.hipModuleGetGlobal(
        <void **>&dptr._ptr,&bytes,
        ihipModule_t.fromPyobj(hmod).getElementPtr(),
        <const char *>hip._util.types.CStr.fromPyobj(name)._ptr))
    return (_hipModuleGetGlobal__retval,None if dptr._ptr == NULL else dptr,bytes)


@cython.embedsignature(True)
def hipGetSymbolAddress(object symbol):
    r"""Gets device pointer associated with symbol on the device.

    Args:
        symbol (`~.hip._util.types.Pointer`/`~.object`) -- *IN*:
            pointer to the symbole of the device

    Returns:
        A `~.tuple` of size 2 that contains (in that order):

        * `~.hipError_t`: `~.hipSuccess`, `~.hipErrorInvalidValue`
        * `~.hip._util.types.Pointer`/`~.object`:
                pointer to the device associated the symbole
    """
    devPtr = hip._util.types.Pointer.fromPtr(NULL)
    _hipGetSymbolAddress__retval = hipError_t(chip.hipGetSymbolAddress(
        <void **>&devPtr._ptr,
        <const void *>hip._util.types.Pointer.fromPyobj(symbol)._ptr))
    return (_hipGetSymbolAddress__retval,None if devPtr._ptr == NULL else devPtr)


@cython.embedsignature(True)
def hipGetSymbolSize(object symbol):
    r"""Gets the size of the given symbol on the device.

    Args:
        symbol (`~.hip._util.types.Pointer`/`~.object`) -- *IN*:
            pointer to the device symbole

    Returns:
        A `~.tuple` of size 2 that contains (in that order):

        * `~.hipError_t`: `~.hipSuccess`, `~.hipErrorInvalidValue`
        * `~.int`:
                pointer to the size
    """
    cdef unsigned long size
    _hipGetSymbolSize__retval = hipError_t(chip.hipGetSymbolSize(&size,
        <const void *>hip._util.types.Pointer.fromPyobj(symbol)._ptr))
    return (_hipGetSymbolSize__retval,size)


@cython.embedsignature(True)
def hipGetProcAddress(object symbol, object pfn, int hipVersion, unsigned long flags):
    r"""Gets the pointer of requested HIP driver function.

    Returns hipSuccess if the returned pfn is addressed to the pointer of found driver function.

    Args:
        symbol (`~.hip._util.types.CStr`/`~.object`) -- *IN*:
            The Symbol name of the driver function to request.

        pfn (`~.hip._util.types.Pointer`/`~.object`) -- *OUT*:
            Output pointer to the requested driver function.

        hipVersion (`~.int`) -- *IN*:
            The HIP version for the requested driver function symbol.
            HIP version is defined as 100*version_major + version_minor. For example, in HIP 6.1, the
            hipversion is 601, for the symbol function "hipGetDeviceProperties", the specified hipVersion 601
            is greater or equal to the version 600, the symbol function will be handle properly as backend
            compatible function.

        flags (`~.int`) -- *IN*:
            Currently only default flag is suppported.

    Returns:
        A `~.tuple` of size 2 that contains (in that order):

        * `~.hipError_t`: `~.hipSuccess`, `~.hipErrorInvalidValue`.
        * `~.hipDriverProcAddressQueryResult`:
                Optional enumeration for returned status of searching for symbol driver
                function based on the input hipVersion.
    """
    cdef chip.hipDriverProcAddressQueryResult symbolStatus
    _hipGetProcAddress__retval = hipError_t(chip.hipGetProcAddress(
        <const char *>hip._util.types.CStr.fromPyobj(symbol)._ptr,
        <void **>hip._util.types.Pointer.fromPyobj(pfn)._ptr,hipVersion,flags,&symbolStatus))
    return (_hipGetProcAddress__retval,hipDriverProcAddressQueryResult(symbolStatus))


@cython.embedsignature(True)
def hipMemcpyToSymbol(object symbol, object src, unsigned long sizeBytes, unsigned long offset, object kind):
    r"""Copies data to the given symbol on the device.
    Symbol HIP APIs allow a kernel to define a device-side data symbol which can be accessed on
    the host side. The symbol can be in __constant or device space.
    Note that the symbol name needs to be encased in the HIP_SYMBOL macro.
    This also applies to hipMemcpyFromSymbol, hipGetSymbolAddress, and hipGetSymbolSize.
    For detailed usage, see the
    <a href="https://rocm.docs.amd.com/projects/HIP/en/latest/how-to/hip_porting_guide.html`~.memcpytosymbol`">memcpyToSymbol example</a>
    in the HIP Porting Guide.

    Args:
        symbol (`~.hip._util.types.Pointer`/`~.object`) -- *OUT*:
            pointer to the device symbole

        src (`~.hip._util.types.Pointer`/`~.object`) -- *IN*:
            pointer to the source address

        sizeBytes (`~.int`) -- *IN*:
            size in bytes to copy

        offset (`~.int`) -- *IN*:
            offset in bytes from start of symbole

        kind (`~.hipMemcpyKind`) -- *IN*:
            type of memory transfer

    Returns:
        A `~.tuple` of size 1 that contains (in that order):

        * `~.hipError_t`: `~.hipSuccess`, `~.hipErrorInvalidValue`
    """
    if not isinstance(kind,_hipMemcpyKind__Base):
        raise TypeError("argument 'kind' must be of type '_hipMemcpyKind__Base'")
    _hipMemcpyToSymbol__retval = hipError_t(chip.hipMemcpyToSymbol(
        <const void *>hip._util.types.Pointer.fromPyobj(symbol)._ptr,
        <const void *>hip._util.types.Pointer.fromPyobj(src)._ptr,sizeBytes,offset,kind.value))
    return (_hipMemcpyToSymbol__retval,)


@cython.embedsignature(True)
def hipMemcpyToSymbolAsync(object symbol, object src, unsigned long sizeBytes, unsigned long offset, object kind, object stream):
    r"""Copies data to the given symbol on the device asynchronously.

    Args:
        symbol (`~.hip._util.types.Pointer`/`~.object`) -- *OUT*:
            pointer to the device symbole

        src (`~.hip._util.types.Pointer`/`~.object`) -- *IN*:
            pointer to the source address

        sizeBytes (`~.int`) -- *IN*:
            size in bytes to copy

        offset (`~.int`) -- *IN*:
            offset in bytes from start of symbole

        kind (`~.hipMemcpyKind`) -- *IN*:
            type of memory transfer

        stream (`~.ihipStream_t`/`~.object`) -- *IN*:
            stream identifier

    Returns:
        A `~.tuple` of size 1 that contains (in that order):

        * `~.hipError_t`: `~.hipSuccess`, `~.hipErrorInvalidValue`
    """
    if not isinstance(kind,_hipMemcpyKind__Base):
        raise TypeError("argument 'kind' must be of type '_hipMemcpyKind__Base'")
    _hipMemcpyToSymbolAsync__retval = hipError_t(chip.hipMemcpyToSymbolAsync(
        <const void *>hip._util.types.Pointer.fromPyobj(symbol)._ptr,
        <const void *>hip._util.types.Pointer.fromPyobj(src)._ptr,sizeBytes,offset,kind.value,
        ihipStream_t.fromPyobj(stream).getElementPtr()))
    return (_hipMemcpyToSymbolAsync__retval,)


@cython.embedsignature(True)
def hipMemcpyFromSymbol(object dst, object symbol, unsigned long sizeBytes, unsigned long offset, object kind):
    r"""Copies data from the given symbol on the device.

    Args:
        dst (`~.hip._util.types.Pointer`/`~.object`) -- *OUT*:
            Returns pointer to destinition memory address

        symbol (`~.hip._util.types.Pointer`/`~.object`) -- *IN*:
            Pointer to the symbole address on the device

        sizeBytes (`~.int`) -- *IN*:
            Size in bytes to copy

        offset (`~.int`) -- *IN*:
            Offset in bytes from the start of symbole

        kind (`~.hipMemcpyKind`) -- *IN*:
            Type of memory transfer

    Returns:
        A `~.tuple` of size 1 that contains (in that order):

        * `~.hipError_t`: `~.hipSuccess`, `~.hipErrorInvalidValue`
    """
    if not isinstance(kind,_hipMemcpyKind__Base):
        raise TypeError("argument 'kind' must be of type '_hipMemcpyKind__Base'")
    _hipMemcpyFromSymbol__retval = hipError_t(chip.hipMemcpyFromSymbol(
        <void *>hip._util.types.Pointer.fromPyobj(dst)._ptr,
        <const void *>hip._util.types.Pointer.fromPyobj(symbol)._ptr,sizeBytes,offset,kind.value))
    return (_hipMemcpyFromSymbol__retval,)


@cython.embedsignature(True)
def hipMemcpyFromSymbolAsync(object dst, object symbol, unsigned long sizeBytes, unsigned long offset, object kind, object stream):
    r"""Copies data from the given symbol on the device asynchronously.

    Args:
        dst (`~.hip._util.types.Pointer`/`~.object`) -- *OUT*:
            Returns pointer to destinition memory address

        symbol (`~.hip._util.types.Pointer`/`~.object`) -- *IN*:
            pointer to the symbole address on the device

        sizeBytes (`~.int`) -- *IN*:
            size in bytes to copy

        offset (`~.int`) -- *IN*:
            offset in bytes from the start of symbole

        kind (`~.hipMemcpyKind`) -- *IN*:
            type of memory transfer

        stream (`~.ihipStream_t`/`~.object`) -- *IN*:
            stream identifier

    Returns:
        A `~.tuple` of size 1 that contains (in that order):

        * `~.hipError_t`: `~.hipSuccess`, `~.hipErrorInvalidValue`
    """
    if not isinstance(kind,_hipMemcpyKind__Base):
        raise TypeError("argument 'kind' must be of type '_hipMemcpyKind__Base'")
    _hipMemcpyFromSymbolAsync__retval = hipError_t(chip.hipMemcpyFromSymbolAsync(
        <void *>hip._util.types.Pointer.fromPyobj(dst)._ptr,
        <const void *>hip._util.types.Pointer.fromPyobj(symbol)._ptr,sizeBytes,offset,kind.value,
        ihipStream_t.fromPyobj(stream).getElementPtr()))
    return (_hipMemcpyFromSymbolAsync__retval,)


@cython.embedsignature(True)
def hipMemcpyAsync(object dst, object src, unsigned long sizeBytes, object kind, object stream):
    r"""Copy data from src to dst asynchronously.

    Warning:
        If host or dest are not pinned, the memory copy will be performed synchronously.  For
        best performance, use hipHostMalloc to allocate host memory that is transferred asynchronously.

    Warning:
        on HCC hipMemcpyAsync does not support overlapped H2D and D2H copies.
        For hipMemcpy, the copy is always performed by the device associated with the specified stream.

    For multi-gpu or peer-to-peer configurations, it is recommended to use a stream which is a
    attached to the device where the src data is physically located. For optimal peer-to-peer copies,
    the copy device must be able to access the src and dst pointers (by calling
    hipDeviceEnablePeerAccess with copy agent as the current device and src/dest as the peerDevice
    argument.  if this is not done, the hipMemcpy will still work, but will perform the copy using a
    staging buffer on the host.

    See:
        `~.hipMemcpy`, `~.hipMemcpy2D`, `~.hipMemcpyToArray`, `~.hipMemcpy2DToArray`, `~.hipMemcpyFromArray`,
        `~.hipMemcpy2DFromArray`, `~.hipMemcpyArrayToArray`, `~.hipMemcpy2DArrayToArray`, `~.hipMemcpyToSymbol`,
        `~.hipMemcpyFromSymbol`, `~.hipMemcpy2DAsync`, `~.hipMemcpyToArrayAsync`, `~.hipMemcpy2DToArrayAsync`,
        `~.hipMemcpyFromArrayAsync`, `~.hipMemcpy2DFromArrayAsync`, `~.hipMemcpyToSymbolAsync`,
        `~.hipMemcpyFromSymbolAsync`

    Args:
        dst (`~.hip._util.types.Pointer`/`~.object`) -- *OUT*:
            Data being copy to

        src (`~.hip._util.types.Pointer`/`~.object`) -- *IN*:
            Data being copy from

        sizeBytes (`~.int`) -- *IN*:
            Data size in bytes

        kind (`~.hipMemcpyKind`) -- *IN*:
            Type of memory transfer

        stream (`~.ihipStream_t`/`~.object`) -- *IN*:
            Stream identifier

    Returns:
        A `~.tuple` of size 1 that contains (in that order):

        * `~.hipError_t`: `~.hipSuccess`, `~.hipErrorInvalidValue`, `~.hipErrorUnknown`
    """
    if not isinstance(kind,_hipMemcpyKind__Base):
        raise TypeError("argument 'kind' must be of type '_hipMemcpyKind__Base'")
    _hipMemcpyAsync__retval = hipError_t(chip.hipMemcpyAsync(
        <void *>hip._util.types.Pointer.fromPyobj(dst)._ptr,
        <const void *>hip._util.types.Pointer.fromPyobj(src)._ptr,sizeBytes,kind.value,
        ihipStream_t.fromPyobj(stream).getElementPtr()))
    return (_hipMemcpyAsync__retval,)


@cython.embedsignature(True)
def hipMemset(object dst, int value, unsigned long sizeBytes):
    r"""Fills the first sizeBytes bytes of the memory area pointed to by dest with the constant
    byte value value.

    Args:
        dst (`~.hip._util.types.Pointer`/`~.object`) -- *OUT*:
            Data being filled

        value (`~.int`) -- *IN*:
            Value to be set

        sizeBytes (`~.int`) -- *IN*:
            Data size in bytes

    Returns:
        A `~.tuple` of size 1 that contains (in that order):

        * `~.hipError_t`: `~.hipSuccess`, `~.hipErrorInvalidValue`, `~.hipErrorNotInitialized`
    """
    _hipMemset__retval = hipError_t(chip.hipMemset(
        <void *>hip._util.types.Pointer.fromPyobj(dst)._ptr,value,sizeBytes))
    return (_hipMemset__retval,)


@cython.embedsignature(True)
def hipMemsetD8(object dest, unsigned char value, unsigned long count):
    r"""Fills the first sizeBytes bytes of the memory area pointed to by dest with the constant
    byte value value.

    Args:
        dest (`~.hip._util.types.Pointer`/`~.object`) -- *OUT*:
            Data ptr to be filled

        value (`~.int`) -- *IN*:
            Value to be set

        count (`~.int`) -- *IN*:
            Number of values to be set

    Returns:
        A `~.tuple` of size 1 that contains (in that order):

        * `~.hipError_t`: `~.hipSuccess`, `~.hipErrorInvalidValue`, `~.hipErrorNotInitialized`
    """
    _hipMemsetD8__retval = hipError_t(chip.hipMemsetD8(
        <void *>hip._util.types.Pointer.fromPyobj(dest)._ptr,value,count))
    return (_hipMemsetD8__retval,)


@cython.embedsignature(True)
def hipMemsetD8Async(object dest, unsigned char value, unsigned long count, object stream):
    r"""Fills the first sizeBytes bytes of the memory area pointed to by dest with the constant
    byte value value.

    hipMemsetD8Async() is asynchronous with respect to the host, so the call may return before the
    memset is complete. The operation can optionally be associated to a stream by passing a non-zero
    stream argument. If stream is non-zero, the operation may overlap with operations in other
    streams.

    Args:
        dest (`~.hip._util.types.Pointer`/`~.object`) -- *OUT*:
            Data ptr to be filled

        value (`~.int`) -- *IN*:
            Constant value to be set

        count (`~.int`) -- *IN*:
            Number of values to be set

        stream (`~.ihipStream_t`/`~.object`) -- *IN*:
            Stream identifier

    Returns:
        A `~.tuple` of size 1 that contains (in that order):

        * `~.hipError_t`: `~.hipSuccess`, `~.hipErrorInvalidValue`, `~.hipErrorNotInitialized`
    """
    _hipMemsetD8Async__retval = hipError_t(chip.hipMemsetD8Async(
        <void *>hip._util.types.Pointer.fromPyobj(dest)._ptr,value,count,
        ihipStream_t.fromPyobj(stream).getElementPtr()))
    return (_hipMemsetD8Async__retval,)


@cython.embedsignature(True)
def hipMemsetD16(object dest, unsigned short value, unsigned long count):
    r"""Fills the first sizeBytes bytes of the memory area pointed to by dest with the constant
    short value value.

    Args:
        dest (`~.hip._util.types.Pointer`/`~.object`) -- *OUT*:
            Data ptr to be filled

        value (`~.int`) -- *IN*:
            Constant value to be set

        count (`~.int`) -- *IN*:
            Number of values to be set

    Returns:
        A `~.tuple` of size 1 that contains (in that order):

        * `~.hipError_t`: `~.hipSuccess`, `~.hipErrorInvalidValue`, `~.hipErrorNotInitialized`
    """
    _hipMemsetD16__retval = hipError_t(chip.hipMemsetD16(
        <void *>hip._util.types.Pointer.fromPyobj(dest)._ptr,value,count))
    return (_hipMemsetD16__retval,)


@cython.embedsignature(True)
def hipMemsetD16Async(object dest, unsigned short value, unsigned long count, object stream):
    r"""Fills the first sizeBytes bytes of the memory area pointed to by dest with the constant
    short value value.

    hipMemsetD16Async() is asynchronous with respect to the host, so the call may return before the
    memset is complete. The operation can optionally be associated to a stream by passing a non-zero
    stream argument. If stream is non-zero, the operation may overlap with operations in other
    streams.

    Args:
        dest (`~.hip._util.types.Pointer`/`~.object`) -- *OUT*:
            Data ptr to be filled

        value (`~.int`) -- *IN*:
            Constant value to be set

        count (`~.int`) -- *IN*:
            Number of values to be set

        stream (`~.ihipStream_t`/`~.object`) -- *IN*:
            Stream identifier

    Returns:
        A `~.tuple` of size 1 that contains (in that order):

        * `~.hipError_t`: `~.hipSuccess`, `~.hipErrorInvalidValue`, `~.hipErrorNotInitialized`
    """
    _hipMemsetD16Async__retval = hipError_t(chip.hipMemsetD16Async(
        <void *>hip._util.types.Pointer.fromPyobj(dest)._ptr,value,count,
        ihipStream_t.fromPyobj(stream).getElementPtr()))
    return (_hipMemsetD16Async__retval,)


@cython.embedsignature(True)
def hipMemsetD32(object dest, int value, unsigned long count):
    r"""Fills the memory area pointed to by dest with the constant integer
    value for specified number of times.

    Args:
        dest (`~.hip._util.types.Pointer`/`~.object`) -- *OUT*:
            Data being filled

        value (`~.int`) -- *IN*:
            Constant value to be set

        count (`~.int`) -- *IN*:
            Number of values to be set

    Returns:
        A `~.tuple` of size 1 that contains (in that order):

        * `~.hipError_t`: `~.hipSuccess`, `~.hipErrorInvalidValue`, `~.hipErrorNotInitialized`
    """
    _hipMemsetD32__retval = hipError_t(chip.hipMemsetD32(
        <void *>hip._util.types.Pointer.fromPyobj(dest)._ptr,value,count))
    return (_hipMemsetD32__retval,)


@cython.embedsignature(True)
def hipMemsetAsync(object dst, int value, unsigned long sizeBytes, object stream):
    r"""Fills the first sizeBytes bytes of the memory area pointed to by dev with the constant
    byte value value.

    hipMemsetAsync() is asynchronous with respect to the host, so the call may return before the
    memset is complete. The operation can optionally be associated to a stream by passing a non-zero
    stream argument. If stream is non-zero, the operation may overlap with operations in other
    streams.

    Args:
        dst (`~.hip._util.types.Pointer`/`~.object`) -- *OUT*:
            Pointer to device memory

        value (`~.int`) -- *IN*:
            Value to set for each byte of specified memory

        sizeBytes (`~.int`) -- *IN*:
            Size in bytes to set

        stream (`~.ihipStream_t`/`~.object`) -- *IN*:
            Stream identifier

    Returns:
        A `~.tuple` of size 1 that contains (in that order):

        * `~.hipError_t`: `~.hipSuccess`, `~.hipErrorInvalidValue`
    """
    _hipMemsetAsync__retval = hipError_t(chip.hipMemsetAsync(
        <void *>hip._util.types.Pointer.fromPyobj(dst)._ptr,value,sizeBytes,
        ihipStream_t.fromPyobj(stream).getElementPtr()))
    return (_hipMemsetAsync__retval,)


@cython.embedsignature(True)
def hipMemsetD32Async(object dst, int value, unsigned long count, object stream):
    r"""Fills the memory area pointed to by dev with the constant integer
    value for specified number of times.

    hipMemsetD32Async() is asynchronous with respect to the host, so the call may return before the
    memset is complete. The operation can optionally be associated to a stream by passing a non-zero
    stream argument. If stream is non-zero, the operation may overlap with operations in other
    streams.

    Args:
        dst (`~.hip._util.types.Pointer`/`~.object`) -- *OUT*:
            Pointer to device memory

        value (`~.int`) -- *IN*:
            Value to set for each byte of specified memory

        count (`~.int`) -- *IN*:
            Number of values to be set

        stream (`~.ihipStream_t`/`~.object`) -- *IN*:
            Stream identifier

    Returns:
        A `~.tuple` of size 1 that contains (in that order):

        * `~.hipError_t`: `~.hipSuccess`, `~.hipErrorInvalidValue`
    """
    _hipMemsetD32Async__retval = hipError_t(chip.hipMemsetD32Async(
        <void *>hip._util.types.Pointer.fromPyobj(dst)._ptr,value,count,
        ihipStream_t.fromPyobj(stream).getElementPtr()))
    return (_hipMemsetD32Async__retval,)


@cython.embedsignature(True)
def hipMemset2D(object dst, unsigned long pitch, int value, unsigned long width, unsigned long height):
    r"""Fills the memory area pointed to by dst with the constant value.

    Args:
        dst (`~.hip._util.types.Pointer`/`~.object`) -- *OUT*:
            Pointer to device memory

        pitch (`~.int`) -- *IN*:
            Data size in bytes

        value (`~.int`) -- *IN*:
            Constant value to be set

        width (`~.int`) -- *IN*:

        height (`~.int`) -- *IN*:

    Returns:
        A `~.tuple` of size 1 that contains (in that order):

        * `~.hipError_t`: `~.hipSuccess`, `~.hipErrorInvalidValue`
    """
    _hipMemset2D__retval = hipError_t(chip.hipMemset2D(
        <void *>hip._util.types.Pointer.fromPyobj(dst)._ptr,pitch,value,width,height))
    return (_hipMemset2D__retval,)


@cython.embedsignature(True)
def hipMemset2DAsync(object dst, unsigned long pitch, int value, unsigned long width, unsigned long height, object stream):
    r"""Fills asynchronously the memory area pointed to by dst with the constant value.

    Args:
        dst (`~.hip._util.types.Pointer`/`~.object`) -- *IN*:
            Pointer to 2D device memory

        pitch (`~.int`) -- *IN*:
            Pitch size in bytes

        value (`~.int`) -- *IN*:
            Value to be set for each byte of specified memory

        width (`~.int`) -- *IN*:
            Width of matrix set columns in bytes

        height (`~.int`) -- *IN*:
            Height of matrix set rows in bytes

        stream (`~.ihipStream_t`/`~.object`) -- *IN*:
            Stream identifier

    Returns:
        A `~.tuple` of size 1 that contains (in that order):

        * `~.hipError_t`: `~.hipSuccess`, `~.hipErrorInvalidValue`
    """
    _hipMemset2DAsync__retval = hipError_t(chip.hipMemset2DAsync(
        <void *>hip._util.types.Pointer.fromPyobj(dst)._ptr,pitch,value,width,height,
        ihipStream_t.fromPyobj(stream).getElementPtr()))
    return (_hipMemset2DAsync__retval,)


@cython.embedsignature(True)
def hipMemset3D(object pitchedDevPtr, int value, object extent):
    r"""Fills synchronously the memory area pointed to by pitchedDevPtr with the constant value.

    Args:
        pitchedDevPtr (`~.hipPitchedPtr`) -- *IN*:
            Pointer to pitched device memory

        value (`~.int`) -- *IN*:
            Value to set for each byte of specified memory

        extent (`~.hipExtent`) -- *IN*:
            Size parameters for width field in bytes in device memory

    Returns:
        A `~.tuple` of size 1 that contains (in that order):

        * `~.hipError_t`: `~.hipSuccess`, `~.hipErrorInvalidValue`
    """
    _hipMemset3D__retval = hipError_t(chip.hipMemset3D(
        hipPitchedPtr.fromPyobj(pitchedDevPtr).getElementPtr()[0],value,
        hipExtent.fromPyobj(extent).getElementPtr()[0]))
    return (_hipMemset3D__retval,)


@cython.embedsignature(True)
def hipMemset3DAsync(object pitchedDevPtr, int value, object extent, object stream):
    r"""Fills asynchronously the memory area pointed to by pitchedDevPtr with the constant value.

    Args:
        pitchedDevPtr (`~.hipPitchedPtr`) -- *IN*:
            Pointer to pitched device memory

        value (`~.int`) -- *IN*:
            Value to set for each byte of specified memory

        extent (`~.hipExtent`) -- *IN*:
            Size parameters for width field in bytes in device memory

        stream (`~.ihipStream_t`/`~.object`) -- *IN*:
            Stream identifier

    Returns:
        A `~.tuple` of size 1 that contains (in that order):

        * `~.hipError_t`: `~.hipSuccess`, `~.hipErrorInvalidValue`
    """
    _hipMemset3DAsync__retval = hipError_t(chip.hipMemset3DAsync(
        hipPitchedPtr.fromPyobj(pitchedDevPtr).getElementPtr()[0],value,
        hipExtent.fromPyobj(extent).getElementPtr()[0],
        ihipStream_t.fromPyobj(stream).getElementPtr()))
    return (_hipMemset3DAsync__retval,)


@cython.embedsignature(True)
def hipMemGetInfo():
    r"""Query memory info.

    On ROCM, this function gets the actual free memory left on the current device, so supports
    the cases while running multi-workload (such as multiple processes, multiple threads, and
    multiple GPUs).

    Warning:
        On Windows, the free memory only accounts for memory allocated by this process and may
        be optimistic.

    Returns:
        A `~.tuple` of size 3 that contains (in that order):

        * `~.hipError_t`: `~.hipSuccess`, `~.hipErrorInvalidDevice`, `~.hipErrorInvalidValue`
        * `~.int`:
                Returns free memory on the current device in bytes
        * `~.int`:
                Returns total allocatable memory on the current device in bytes
    """
    cdef unsigned long free
    cdef unsigned long total
    _hipMemGetInfo__retval = hipError_t(chip.hipMemGetInfo(&free,&total))
    return (_hipMemGetInfo__retval,free,total)


@cython.embedsignature(True)
def hipMemPtrGetInfo(object ptr):
    r"""Get allocated memory size via memory pointer.

    This function gets the allocated shared virtual memory size from memory pointer.

    Args:
        ptr (`~.hip._util.types.Pointer`/`~.object`) -- *IN*:
            Pointer to allocated memory

    Returns:
        A `~.tuple` of size 2 that contains (in that order):

        * `~.hipError_t`: `~.hipSuccess`, `~.hipErrorInvalidValue`
        * `~.int`:
                Returns the allocated memory size in bytes
    """
    cdef unsigned long size
    _hipMemPtrGetInfo__retval = hipError_t(chip.hipMemPtrGetInfo(
        <void *>hip._util.types.Pointer.fromPyobj(ptr)._ptr,&size))
    return (_hipMemPtrGetInfo__retval,size)


@cython.embedsignature(True)
def hipMallocArray(object desc, unsigned long width, unsigned long height, unsigned int flags):
    r"""Allocate an array on the device.

    See:
        `~.hipMalloc`, `~.hipMallocPitch`, `~.hipFree`, `~.hipFreeArray`, `~.hipHostMalloc`, `~.hipHostFree`

    Args:
        desc (`~.hipChannelFormatDesc`/`~.object`) -- *IN*:
            Requested channel format

        width (`~.int`) -- *IN*:
            Requested array allocation width

        height (`~.int`) -- *IN*:
            Requested array allocation height

        flags (`~.int`) -- *IN*:
            Requested properties of allocated array

    Returns:
        A `~.tuple` of size 2 that contains (in that order):

        * `~.hipError_t`: `~.hipSuccess`, `~.hipErrorOutOfMemory`
        * `~.hipArray`:
                Pointer to allocated array in device memory
    """
    array = hipArray.fromPtr(NULL)
    _hipMallocArray__retval = hipError_t(chip.hipMallocArray(<chip.hipArray**>&array._ptr,
        hipChannelFormatDesc.fromPyobj(desc).getElementPtr(),width,height,flags))
    return (_hipMallocArray__retval,None if array._ptr == NULL else array)


@cython.embedsignature(True)
def hipArrayCreate(object pAllocateArray):
    r"""Create an array memory pointer on the device.

    See:
        `~.hipMallocArray`, `~.hipArrayDestroy`, `~.hipFreeArray`

    Args:
        pAllocateArray (`~.HIP_ARRAY_DESCRIPTOR`/`~.object`) -- *IN*:
            Requested array desciptor

    Returns:
        A `~.tuple` of size 2 that contains (in that order):

        * `~.hipError_t`: `~.hipSuccess`, `~.hipErrorInvalidValue`, `~.hipErrorNotSupported`
        * `~.hipArray`:
                Pointer to the array memory
    """
    pHandle = hipArray.fromPtr(NULL)
    _hipArrayCreate__retval = hipError_t(chip.hipArrayCreate(<chip.hipArray**>&pHandle._ptr,
        HIP_ARRAY_DESCRIPTOR.fromPyobj(pAllocateArray).getElementPtr()))
    return (_hipArrayCreate__retval,None if pHandle._ptr == NULL else pHandle)


@cython.embedsignature(True)
def hipArrayDestroy(object array):
    r"""Destroy an array memory pointer on the device.

    See:
        `~.hipArrayCreate`, `~.hipArrayDestroy`, `~.hipFreeArray`

    Args:
        array (`~.hipArray`/`~.object`) -- *IN*:
            Pointer to the array memory

    Returns:
        A `~.tuple` of size 1 that contains (in that order):

        * `~.hipError_t`: `~.hipSuccess`, `~.hipErrorInvalidValue`
    """
    _hipArrayDestroy__retval = hipError_t(chip.hipArrayDestroy(
        hipArray.fromPyobj(array).getElementPtr()))
    return (_hipArrayDestroy__retval,)


@cython.embedsignature(True)
def hipArray3DCreate(object pAllocateArray):
    r"""Create a 3D array memory pointer on the device.

    See:
        `~.hipMallocArray`, `~.hipArrayDestroy`, `~.hipFreeArray`

    Args:
        pAllocateArray (`~.HIP_ARRAY3D_DESCRIPTOR`/`~.object`) -- *IN*:
            Requested array desciptor

    Returns:
        A `~.tuple` of size 2 that contains (in that order):

        * `~.hipError_t`: `~.hipSuccess`, `~.hipErrorInvalidValue`, `~.hipErrorNotSupported`
        * `~.hipArray`:
                Pointer to the 3D array memory
    """
    array = hipArray.fromPtr(NULL)
    _hipArray3DCreate__retval = hipError_t(chip.hipArray3DCreate(<chip.hipArray**>&array._ptr,
        HIP_ARRAY3D_DESCRIPTOR.fromPyobj(pAllocateArray).getElementPtr()))
    return (_hipArray3DCreate__retval,None if array._ptr == NULL else array)


@cython.embedsignature(True)
def hipMalloc3D(object pitchedDevPtr, object extent):
    r"""Create a 3D memory pointer on the device.

    See:
        `~.hipMallocPitch`, `~.hipMemGetInfo`, `~.hipFree`

    Args:
        pitchedDevPtr (`~.hipPitchedPtr`/`~.object`) -- *OUT*:
            Pointer to the 3D memory

        extent (`~.hipExtent`) -- *IN*:
            Requested extent

    Returns:
        A `~.tuple` of size 1 that contains (in that order):

        * `~.hipError_t`: `~.hipSuccess`, `~.hipErrorInvalidValue`, `~.hipErrorNotSupported`
    """
    _hipMalloc3D__retval = hipError_t(chip.hipMalloc3D(
        hipPitchedPtr.fromPyobj(pitchedDevPtr).getElementPtr(),
        hipExtent.fromPyobj(extent).getElementPtr()[0]))
    return (_hipMalloc3D__retval,)


@cython.embedsignature(True)
def hipFreeArray(object array):
    r"""Frees an array on the device.

    See:
        `~.hipMalloc`, `~.hipMallocPitch`, `~.hipFree`, `~.hipMallocArray`, `~.hipHostMalloc`, `~.hipHostFree`

    Args:
        array (`~.hipArray`/`~.object`) -- *IN*:
            Pointer to array to free

    Returns:
        A `~.tuple` of size 1 that contains (in that order):

        * `~.hipError_t`: `~.hipSuccess`, `~.hipErrorInvalidValue`, `~.hipErrorNotInitialized`
    """
    _hipFreeArray__retval = hipError_t(chip.hipFreeArray(
        hipArray.fromPyobj(array).getElementPtr()))
    return (_hipFreeArray__retval,)


@cython.embedsignature(True)
def hipMalloc3DArray(object desc, object extent, unsigned int flags):
    r"""Allocate an array on the device.

    See:
        `~.hipMalloc`, `~.hipMallocPitch`, `~.hipFree`, `~.hipFreeArray`, `~.hipHostMalloc`, `~.hipHostFree`

    Args:
        desc (`~.hipChannelFormatDesc`/`~.object`) -- *IN*:
            Requested channel format

        extent (`~.hipExtent`) -- *IN*:
            Requested array allocation width, height and depth

        flags (`~.int`) -- *IN*:
            Requested properties of allocated array

    Returns:
        A `~.tuple` of size 2 that contains (in that order):

        * `~.hipError_t`: `~.hipSuccess`, `~.hipErrorOutOfMemory`
        * `~.hipArray`:
                Pointer to allocated array in device memory
    """
    array = hipArray.fromPtr(NULL)
    _hipMalloc3DArray__retval = hipError_t(chip.hipMalloc3DArray(<chip.hipArray**>&array._ptr,
        hipChannelFormatDesc.fromPyobj(desc).getElementPtr(),
        hipExtent.fromPyobj(extent).getElementPtr()[0],flags))
    return (_hipMalloc3DArray__retval,None if array._ptr == NULL else array)


@cython.embedsignature(True)
def hipArrayGetInfo(object desc, object extent, object array):
    r"""Gets info about the specified array

    See:
        `~.hipArrayGetDescriptor`, `~.hipArray3DGetDescriptor`

    Args:
        desc (`~.hipChannelFormatDesc`/`~.object`) -- *OUT*:
            - Returned array type

        extent (`~.hipExtent`/`~.object`) -- *OUT*:
            - Returned array shape. 2D arrays will have depth of zero

        array (`~.hipArray`/`~.object`) -- *IN*:
            - The HIP array to get info for

    Returns:
        A `~.tuple` of size 2 that contains (in that order):

        * `~.hipError_t`: `~.hipSuccess`, `~.hipErrorInvalidValue` `~.hipErrorInvalidHandle`
        * `~.int`:
                - Returned array flags
    """
    cdef unsigned int flags
    _hipArrayGetInfo__retval = hipError_t(chip.hipArrayGetInfo(
        hipChannelFormatDesc.fromPyobj(desc).getElementPtr(),
        hipExtent.fromPyobj(extent).getElementPtr(),&flags,
        hipArray.fromPyobj(array).getElementPtr()))
    return (_hipArrayGetInfo__retval,flags)


@cython.embedsignature(True)
def hipArrayGetDescriptor(object pArrayDescriptor, object array):
    r"""Gets a 1D or 2D array descriptor

    See:
        `~.hipArray3DCreate`, `~.hipArray3DGetDescriptor`, `~.hipArrayCreate`, `~.hipArrayDestroy`, `~.hipMemAlloc`,
        `~.hipMemAllocHost`, `~.hipMemAllocPitch`, `~.hipMemcpy2D`, `~.hipMemcpy2DAsync`, `~.hipMemcpy2DUnaligned`,
        `~.hipMemcpy3D`, `~.hipMemcpy3DAsync`, `~.hipMemcpyAtoA`, `~.hipMemcpyAtoD`, `~.hipMemcpyAtoH`, `~.hipMemcpyAtoHAsync`,
        `~.hipMemcpyDtoA`, `~.hipMemcpyDtoD`, `~.hipMemcpyDtoDAsync`, `~.hipMemcpyDtoH`, `~.hipMemcpyDtoHAsync`,
        `~.hipMemcpyHtoA`, `~.hipMemcpyHtoAAsync`, `~.hipMemcpyHtoD`, `~.hipMemcpyHtoDAsync`, `~.hipMemFree`,
        `~.hipMemFreeHost`, `~.hipMemGetAddressRange`, `~.hipMemGetInfo`, `~.hipMemHostAlloc`,
        `~.hipMemHostGetDevicePointer`, `~.hipMemsetD8`, `~.hipMemsetD16`, `~.hipMemsetD32`, `~.hipArrayGetInfo`

    Args:
        pArrayDescriptor (`~.HIP_ARRAY_DESCRIPTOR`/`~.object`) -- *OUT*:
            - Returned array descriptor

        array (`~.hipArray`/`~.object`) -- *IN*:
            - Array to get descriptor of

    Returns:
        A `~.tuple` of size 1 that contains (in that order):

        * `~.hipError_t`: `~.hipSuccess`, `~.hipErrorDeinitialized`, `~.hipErrorNotInitialized`, `~.hipErrorInvalidContext`,
            `~.hipErrorInvalidValue` `~.hipErrorInvalidHandle`
    """
    _hipArrayGetDescriptor__retval = hipError_t(chip.hipArrayGetDescriptor(
        HIP_ARRAY_DESCRIPTOR.fromPyobj(pArrayDescriptor).getElementPtr(),
        hipArray.fromPyobj(array).getElementPtr()))
    return (_hipArrayGetDescriptor__retval,)


@cython.embedsignature(True)
def hipArray3DGetDescriptor(object pArrayDescriptor, object array):
    r"""Gets a 3D array descriptor

    See:
        `~.hipArray3DCreate`, `~.hipArrayCreate`, `~.hipArrayDestroy`, `~.hipArrayGetDescriptor`, `~.hipMemAlloc`,
        `~.hipMemAllocHost`, `~.hipMemAllocPitch`, `~.hipMemcpy2D`, `~.hipMemcpy2DAsync`, `~.hipMemcpy2DUnaligned`,
        `~.hipMemcpy3D`, `~.hipMemcpy3DAsync`, `~.hipMemcpyAtoA`, `~.hipMemcpyAtoD`, `~.hipMemcpyAtoH`, `~.hipMemcpyAtoHAsync`,
        `~.hipMemcpyDtoA`, `~.hipMemcpyDtoD`, `~.hipMemcpyDtoDAsync`, `~.hipMemcpyDtoH`, `~.hipMemcpyDtoHAsync`,
        `~.hipMemcpyHtoA`, `~.hipMemcpyHtoAAsync`, `~.hipMemcpyHtoD`, `~.hipMemcpyHtoDAsync`, `~.hipMemFree`,
        `~.hipMemFreeHost`, `~.hipMemGetAddressRange`, `~.hipMemGetInfo`, `~.hipMemHostAlloc`,
        `~.hipMemHostGetDevicePointer`, `~.hipMemsetD8`, `~.hipMemsetD16`, `~.hipMemsetD32`, `~.hipArrayGetInfo`

    Args:
        pArrayDescriptor (`~.HIP_ARRAY3D_DESCRIPTOR`/`~.object`) -- *OUT*:
            - Returned 3D array descriptor

        array (`~.hipArray`/`~.object`) -- *IN*:
            - 3D array to get descriptor of

    Returns:
        A `~.tuple` of size 1 that contains (in that order):

        * `~.hipError_t`: `~.hipSuccess`, `~.hipErrorDeinitialized`, `~.hipErrorNotInitialized`, `~.hipErrorInvalidContext`,
            `~.hipErrorInvalidValue` `~.hipErrorInvalidHandle`, `~.hipErrorContextIsDestroyed`
    """
    _hipArray3DGetDescriptor__retval = hipError_t(chip.hipArray3DGetDescriptor(
        HIP_ARRAY3D_DESCRIPTOR.fromPyobj(pArrayDescriptor).getElementPtr(),
        hipArray.fromPyobj(array).getElementPtr()))
    return (_hipArray3DGetDescriptor__retval,)


@cython.embedsignature(True)
def hipMemcpy2D(object dst, unsigned long dpitch, object src, unsigned long spitch, unsigned long width, unsigned long height, object kind):
    r"""Copies data between host and device.

    See:
        `~.hipMemcpy`, `~.hipMemcpyToArray`, `~.hipMemcpy2DToArray`, `~.hipMemcpyFromArray`, `~.hipMemcpyToSymbol`,
        `~.hipMemcpyAsync`

    Args:
        dst (`~.hip._util.types.Pointer`/`~.object`) -- *IN*:
            Destination memory address

        dpitch (`~.int`) -- *IN*:
            Pitch of destination memory

        src (`~.hip._util.types.Pointer`/`~.object`) -- *IN*:
            Source memory address

        spitch (`~.int`) -- *IN*:
            Pitch of source memory

        width (`~.int`) -- *IN*:
            Width of matrix transfer (columns in bytes)

        height (`~.int`) -- *IN*:
            Height of matrix transfer (rows)

        kind (`~.hipMemcpyKind`) -- *IN*:
            Type of transfer

    Returns:
        A `~.tuple` of size 1 that contains (in that order):

        * `~.hipError_t`: `~.hipSuccess`, `~.hipErrorInvalidValue`, `~.hipErrorInvalidPitchValue`,
            `~.hipErrorInvalidDevicePointer`, `~.hipErrorInvalidMemcpyDirection`
    """
    if not isinstance(kind,_hipMemcpyKind__Base):
        raise TypeError("argument 'kind' must be of type '_hipMemcpyKind__Base'")
    _hipMemcpy2D__retval = hipError_t(chip.hipMemcpy2D(
        <void *>hip._util.types.Pointer.fromPyobj(dst)._ptr,dpitch,
        <const void *>hip._util.types.Pointer.fromPyobj(src)._ptr,spitch,width,height,kind.value))
    return (_hipMemcpy2D__retval,)


@cython.embedsignature(True)
def hipMemcpyParam2D(object pCopy):
    r"""Copies memory for 2D arrays.

    See:
        `~.hipMemcpy`, `~.hipMemcpy2D`, `~.hipMemcpyToArray`, `~.hipMemcpy2DToArray`, `~.hipMemcpyFromArray`,
        `~.hipMemcpyToSymbol`, `~.hipMemcpyAsync`

    Args:
        pCopy (`~.hip_Memcpy2D`/`~.object`) -- *IN*:
            Parameters for the memory copy

    Returns:
        A `~.tuple` of size 1 that contains (in that order):

        * `~.hipError_t`: `~.hipSuccess`, `~.hipErrorInvalidValue`, `~.hipErrorInvalidPitchValue`,
            `~.hipErrorInvalidDevicePointer`, `~.hipErrorInvalidMemcpyDirection`
    """
    _hipMemcpyParam2D__retval = hipError_t(chip.hipMemcpyParam2D(
        hip_Memcpy2D.fromPyobj(pCopy).getElementPtr()))
    return (_hipMemcpyParam2D__retval,)


@cython.embedsignature(True)
def hipMemcpyParam2DAsync(object pCopy, object stream):
    r"""Copies memory for 2D arrays.

    See:
        `~.hipMemcpy`, `~.hipMemcpy2D`, `~.hipMemcpyToArray`, `~.hipMemcpy2DToArray`, `~.hipMemcpyFromArray`,
        `~.hipMemcpyToSymbol`, `~.hipMemcpyAsync`

    Args:
        pCopy (`~.hip_Memcpy2D`/`~.object`) -- *IN*:
            Parameters for the memory copy

        stream (`~.ihipStream_t`/`~.object`) -- *IN*:
            Stream to use

    Returns:
        A `~.tuple` of size 1 that contains (in that order):

        * `~.hipError_t`: `~.hipSuccess`, `~.hipErrorInvalidValue`, `~.hipErrorInvalidPitchValue`,
            `~.hipErrorInvalidDevicePointer`, `~.hipErrorInvalidMemcpyDirection`
    """
    _hipMemcpyParam2DAsync__retval = hipError_t(chip.hipMemcpyParam2DAsync(
        hip_Memcpy2D.fromPyobj(pCopy).getElementPtr(),
        ihipStream_t.fromPyobj(stream).getElementPtr()))
    return (_hipMemcpyParam2DAsync__retval,)


@cython.embedsignature(True)
def hipMemcpy2DAsync(object dst, unsigned long dpitch, object src, unsigned long spitch, unsigned long width, unsigned long height, object kind, object stream):
    r"""Copies data between host and device.

    See:
        `~.hipMemcpy`, `~.hipMemcpyToArray`, `~.hipMemcpy2DToArray`, `~.hipMemcpyFromArray`, `~.hipMemcpyToSymbol`,
        `~.hipMemcpyAsync`

    Args:
        dst (`~.hip._util.types.Pointer`/`~.object`) -- *IN*:
            Destination memory address

        dpitch (`~.int`) -- *IN*:
            Pitch of destination memory

        src (`~.hip._util.types.Pointer`/`~.object`) -- *IN*:
            Source memory address

        spitch (`~.int`) -- *IN*:
            Pitch of source memory

        width (`~.int`) -- *IN*:
            Width of matrix transfer (columns in bytes)

        height (`~.int`) -- *IN*:
            Height of matrix transfer (rows)

        kind (`~.hipMemcpyKind`) -- *IN*:
            Type of transfer

        stream (`~.ihipStream_t`/`~.object`) -- *IN*:
            Stream to use

    Returns:
        A `~.tuple` of size 1 that contains (in that order):

        * `~.hipError_t`: `~.hipSuccess`, `~.hipErrorInvalidValue`, `~.hipErrorInvalidPitchValue`,
            `~.hipErrorInvalidDevicePointer`, `~.hipErrorInvalidMemcpyDirection`
    """
    if not isinstance(kind,_hipMemcpyKind__Base):
        raise TypeError("argument 'kind' must be of type '_hipMemcpyKind__Base'")
    _hipMemcpy2DAsync__retval = hipError_t(chip.hipMemcpy2DAsync(
        <void *>hip._util.types.Pointer.fromPyobj(dst)._ptr,dpitch,
        <const void *>hip._util.types.Pointer.fromPyobj(src)._ptr,spitch,width,height,kind.value,
        ihipStream_t.fromPyobj(stream).getElementPtr()))
    return (_hipMemcpy2DAsync__retval,)


@cython.embedsignature(True)
def hipMemcpy2DToArray(object dst, unsigned long wOffset, unsigned long hOffset, object src, unsigned long spitch, unsigned long width, unsigned long height, object kind):
    r"""Copies data between host and device.

    See:
        `~.hipMemcpy`, `~.hipMemcpyToArray`, `~.hipMemcpy2D`, `~.hipMemcpyFromArray`, `~.hipMemcpyToSymbol`,
        `~.hipMemcpyAsync`

    Args:
        dst (`~.hipArray`/`~.object`) -- *IN*:
            Destination memory address

        wOffset (`~.int`) -- *IN*:
            Destination starting X offset

        hOffset (`~.int`) -- *IN*:
            Destination starting Y offset

        src (`~.hip._util.types.Pointer`/`~.object`) -- *IN*:
            Source memory address

        spitch (`~.int`) -- *IN*:
            Pitch of source memory

        width (`~.int`) -- *IN*:
            Width of matrix transfer (columns in bytes)

        height (`~.int`) -- *IN*:
            Height of matrix transfer (rows)

        kind (`~.hipMemcpyKind`) -- *IN*:
            Type of transfer

    Returns:
        A `~.tuple` of size 1 that contains (in that order):

        * `~.hipError_t`: `~.hipSuccess`, `~.hipErrorInvalidValue`, `~.hipErrorInvalidPitchValue`,
            `~.hipErrorInvalidDevicePointer`, `~.hipErrorInvalidMemcpyDirection`
    """
    if not isinstance(kind,_hipMemcpyKind__Base):
        raise TypeError("argument 'kind' must be of type '_hipMemcpyKind__Base'")
    _hipMemcpy2DToArray__retval = hipError_t(chip.hipMemcpy2DToArray(
        hipArray.fromPyobj(dst).getElementPtr(),wOffset,hOffset,
        <const void *>hip._util.types.Pointer.fromPyobj(src)._ptr,spitch,width,height,kind.value))
    return (_hipMemcpy2DToArray__retval,)


@cython.embedsignature(True)
def hipMemcpy2DToArrayAsync(object dst, unsigned long wOffset, unsigned long hOffset, object src, unsigned long spitch, unsigned long width, unsigned long height, object kind, object stream):
    r"""Copies data between host and device.

    See:
        `~.hipMemcpy`, `~.hipMemcpyToArray`, `~.hipMemcpy2D`, `~.hipMemcpyFromArray`, `~.hipMemcpyToSymbol`,
        `~.hipMemcpyAsync`

    Args:
        dst (`~.hipArray`/`~.object`) -- *IN*:
            Destination memory address

        wOffset (`~.int`) -- *IN*:
            Destination starting X offset

        hOffset (`~.int`) -- *IN*:
            Destination starting Y offset

        src (`~.hip._util.types.Pointer`/`~.object`) -- *IN*:
            Source memory address

        spitch (`~.int`) -- *IN*:
            Pitch of source memory

        width (`~.int`) -- *IN*:
            Width of matrix transfer (columns in bytes)

        height (`~.int`) -- *IN*:
            Height of matrix transfer (rows)

        kind (`~.hipMemcpyKind`) -- *IN*:
            Type of transfer

        stream (`~.ihipStream_t`/`~.object`) -- *IN*:
            Accelerator view which the copy is being enqueued

    Returns:
        A `~.tuple` of size 1 that contains (in that order):

        * `~.hipError_t`: `~.hipSuccess`, `~.hipErrorInvalidValue`, `~.hipErrorInvalidPitchValue`,
            `~.hipErrorInvalidDevicePointer`, `~.hipErrorInvalidMemcpyDirection`
    """
    if not isinstance(kind,_hipMemcpyKind__Base):
        raise TypeError("argument 'kind' must be of type '_hipMemcpyKind__Base'")
    _hipMemcpy2DToArrayAsync__retval = hipError_t(chip.hipMemcpy2DToArrayAsync(
        hipArray.fromPyobj(dst).getElementPtr(),wOffset,hOffset,
        <const void *>hip._util.types.Pointer.fromPyobj(src)._ptr,spitch,width,height,kind.value,
        ihipStream_t.fromPyobj(stream).getElementPtr()))
    return (_hipMemcpy2DToArrayAsync__retval,)


@cython.embedsignature(True)
def hipMemcpy2DArrayToArray(object dst, unsigned long wOffsetDst, unsigned long hOffsetDst, object src, unsigned long wOffsetSrc, unsigned long hOffsetSrc, unsigned long width, unsigned long height, object kind):
    r"""Copies data between host and device.

    See:
        `~.hipMemcpy`, `~.hipMemcpyToArray`, `~.hipMemcpy2D`, `~.hipMemcpyFromArray`, `~.hipMemcpyToSymbol`,
        `~.hipMemcpyAsync`

    Args:
        dst (`~.hipArray`/`~.object`) -- *IN*:
            Destination memory address

        wOffsetDst (`~.int`) -- *IN*:
            Destination starting X offset

        hOffsetDst (`~.int`) -- *IN*:
            Destination starting Y offset

        src (`~.hipArray`/`~.object`) -- *IN*:
            Source memory address

        wOffsetSrc (`~.int`) -- *IN*:
            Source starting X offset

        hOffsetSrc (`~.int`) -- *IN*:
            Source starting Y offset (columns in bytes)

        width (`~.int`) -- *IN*:
            Width of matrix transfer (columns in bytes)

        height (`~.int`) -- *IN*:
            Height of matrix transfer (rows)

        kind (`~.hipMemcpyKind`) -- *IN*:
            Type of transfer

    Returns:
        A `~.tuple` of size 1 that contains (in that order):

        * `~.hipError_t`: `~.hipSuccess`, `~.hipErrorInvalidValue`, `~.hipErrorInvalidMemcpyDirection`
    """
    if not isinstance(kind,_hipMemcpyKind__Base):
        raise TypeError("argument 'kind' must be of type '_hipMemcpyKind__Base'")
    _hipMemcpy2DArrayToArray__retval = hipError_t(chip.hipMemcpy2DArrayToArray(
        hipArray.fromPyobj(dst).getElementPtr(),wOffsetDst,hOffsetDst,
        hipArray.fromPyobj(src).getElementPtr(),wOffsetSrc,hOffsetSrc,width,height,kind.value))
    return (_hipMemcpy2DArrayToArray__retval,)


@cython.embedsignature(True)
def hipMemcpyToArray(object dst, unsigned long wOffset, unsigned long hOffset, object src, unsigned long count, object kind):
    r"""Copies data between host and device.

    See:
        `~.hipMemcpy`, `~.hipMemcpy2DToArray`, `~.hipMemcpy2D`, `~.hipMemcpyFromArray`, `~.hipMemcpyToSymbol`,
        `~.hipMemcpyAsync`

    Warning:
        This API is deprecated.

    Args:
        dst (`~.hipArray`/`~.object`) -- *IN*:
            Destination memory address

        wOffset (`~.int`) -- *IN*:
            Destination starting X offset

        hOffset (`~.int`) -- *IN*:
            Destination starting Y offset

        src (`~.hip._util.types.Pointer`/`~.object`) -- *IN*:
            Source memory address

        count (`~.int`) -- *IN*:
            size in bytes to copy

        kind (`~.hipMemcpyKind`) -- *IN*:
            Type of transfer

    Returns:
        A `~.tuple` of size 1 that contains (in that order):

        * `~.hipError_t`: `~.hipSuccess`, `~.hipErrorInvalidValue`, `~.hipErrorInvalidPitchValue`,
            `~.hipErrorInvalidDevicePointer`, `~.hipErrorInvalidMemcpyDirection`
    """
    if not isinstance(kind,_hipMemcpyKind__Base):
        raise TypeError("argument 'kind' must be of type '_hipMemcpyKind__Base'")
    _hipMemcpyToArray__retval = hipError_t(chip.hipMemcpyToArray(
        hipArray.fromPyobj(dst).getElementPtr(),wOffset,hOffset,
        <const void *>hip._util.types.Pointer.fromPyobj(src)._ptr,count,kind.value))
    return (_hipMemcpyToArray__retval,)


@cython.embedsignature(True)
def hipMemcpyFromArray(object dst, object srcArray, unsigned long wOffset, unsigned long hOffset, unsigned long count, object kind):
    r"""Copies data between host and device.

    See:
        `~.hipMemcpy`, `~.hipMemcpy2DToArray`, `~.hipMemcpy2D`, `~.hipMemcpyFromArray`, `~.hipMemcpyToSymbol`,
        `~.hipMemcpyAsync`

    Warning:
        This API is deprecated.

    Args:
        dst (`~.hip._util.types.Pointer`/`~.object`) -- *IN*:
            Destination memory address

        srcArray (`~.hipArray`/`~.object`) -- *IN*:
            Source memory address

        wOffset (`~.int`) -- *IN*:
            Source starting X offset

        hOffset (`~.int`) -- *IN*:
            Source starting Y offset

        count (`~.int`) -- *IN*:
            Size in bytes to copy

        kind (`~.hipMemcpyKind`) -- *IN*:
            Type of transfer

    Returns:
        A `~.tuple` of size 1 that contains (in that order):

        * `~.hipError_t`: `~.hipSuccess`, `~.hipErrorInvalidValue`, `~.hipErrorInvalidPitchValue`,
            `~.hipErrorInvalidDevicePointer`, `~.hipErrorInvalidMemcpyDirection`
    """
    if not isinstance(kind,_hipMemcpyKind__Base):
        raise TypeError("argument 'kind' must be of type '_hipMemcpyKind__Base'")
    _hipMemcpyFromArray__retval = hipError_t(chip.hipMemcpyFromArray(
        <void *>hip._util.types.Pointer.fromPyobj(dst)._ptr,
        hipArray.fromPyobj(srcArray).getElementPtr(),wOffset,hOffset,count,kind.value))
    return (_hipMemcpyFromArray__retval,)


@cython.embedsignature(True)
def hipMemcpy2DFromArray(object dst, unsigned long dpitch, object src, unsigned long wOffset, unsigned long hOffset, unsigned long width, unsigned long height, object kind):
    r"""Copies data between host and device.

    See:
        `~.hipMemcpy`, `~.hipMemcpy2DToArray`, `~.hipMemcpy2D`, `~.hipMemcpyFromArray`, `~.hipMemcpyToSymbol`,
        `~.hipMemcpyAsync`

    Args:
        dst (`~.hip._util.types.Pointer`/`~.object`) -- *IN*:
            Destination memory address

        dpitch (`~.int`) -- *IN*:
            Pitch of destination memory

        src (`~.hipArray`/`~.object`) -- *IN*:
            Source memory address

        wOffset (`~.int`) -- *IN*:
            Source starting X offset

        hOffset (`~.int`) -- *IN*:
            Source starting Y offset

        width (`~.int`) -- *IN*:
            Width of matrix transfer (columns in bytes)

        height (`~.int`) -- *IN*:
            Height of matrix transfer (rows)

        kind (`~.hipMemcpyKind`) -- *IN*:
            Type of transfer

    Returns:
        A `~.tuple` of size 1 that contains (in that order):

        * `~.hipError_t`: `~.hipSuccess`, `~.hipErrorInvalidValue`, `~.hipErrorInvalidPitchValue`,
            `~.hipErrorInvalidDevicePointer`, `~.hipErrorInvalidMemcpyDirection`
    """
    if not isinstance(kind,_hipMemcpyKind__Base):
        raise TypeError("argument 'kind' must be of type '_hipMemcpyKind__Base'")
    _hipMemcpy2DFromArray__retval = hipError_t(chip.hipMemcpy2DFromArray(
        <void *>hip._util.types.Pointer.fromPyobj(dst)._ptr,dpitch,
        hipArray.fromPyobj(src).getElementPtr(),wOffset,hOffset,width,height,kind.value))
    return (_hipMemcpy2DFromArray__retval,)


@cython.embedsignature(True)
def hipMemcpy2DFromArrayAsync(object dst, unsigned long dpitch, object src, unsigned long wOffset, unsigned long hOffset, unsigned long width, unsigned long height, object kind, object stream):
    r"""Copies data between host and device asynchronously.

    See:
        `~.hipMemcpy`, `~.hipMemcpy2DToArray`, `~.hipMemcpy2D`, `~.hipMemcpyFromArray`, `~.hipMemcpyToSymbol`,
        `~.hipMemcpyAsync`

    Args:
        dst (`~.hip._util.types.Pointer`/`~.object`) -- *IN*:
            Destination memory address

        dpitch (`~.int`) -- *IN*:
            Pitch of destination memory

        src (`~.hipArray`/`~.object`) -- *IN*:
            Source memory address

        wOffset (`~.int`) -- *IN*:
            Source starting X offset

        hOffset (`~.int`) -- *IN*:
            Source starting Y offset

        width (`~.int`) -- *IN*:
            Width of matrix transfer (columns in bytes)

        height (`~.int`) -- *IN*:
            Height of matrix transfer (rows)

        kind (`~.hipMemcpyKind`) -- *IN*:
            Type of transfer

        stream (`~.ihipStream_t`/`~.object`) -- *IN*:
            Accelerator view which the copy is being enqueued

    Returns:
        A `~.tuple` of size 1 that contains (in that order):

        * `~.hipError_t`: `~.hipSuccess`, `~.hipErrorInvalidValue`, `~.hipErrorInvalidPitchValue`,
            `~.hipErrorInvalidDevicePointer`, `~.hipErrorInvalidMemcpyDirection`
    """
    if not isinstance(kind,_hipMemcpyKind__Base):
        raise TypeError("argument 'kind' must be of type '_hipMemcpyKind__Base'")
    _hipMemcpy2DFromArrayAsync__retval = hipError_t(chip.hipMemcpy2DFromArrayAsync(
        <void *>hip._util.types.Pointer.fromPyobj(dst)._ptr,dpitch,
        hipArray.fromPyobj(src).getElementPtr(),wOffset,hOffset,width,height,kind.value,
        ihipStream_t.fromPyobj(stream).getElementPtr()))
    return (_hipMemcpy2DFromArrayAsync__retval,)


@cython.embedsignature(True)
def hipMemcpyAtoH(object dst, object srcArray, unsigned long srcOffset, unsigned long count):
    r"""Copies data between host and device.

    See:
        `~.hipMemcpy`, `~.hipMemcpy2DToArray`, `~.hipMemcpy2D`, `~.hipMemcpyFromArray`, `~.hipMemcpyToSymbol`,
        `~.hipMemcpyAsync`

    Args:
        dst (`~.hip._util.types.Pointer`/`~.object`) -- *IN*:
            Destination memory address

        srcArray (`~.hipArray`/`~.object`) -- *IN*:
            Source array

        srcOffset (`~.int`) -- *IN*:
            Offset in bytes of source array

        count (`~.int`) -- *IN*:
            Size of memory copy in bytes

    Returns:
        A `~.tuple` of size 1 that contains (in that order):

        * `~.hipError_t`: `~.hipSuccess`, `~.hipErrorInvalidValue`, `~.hipErrorInvalidPitchValue`,
            `~.hipErrorInvalidDevicePointer`, `~.hipErrorInvalidMemcpyDirection`
    """
    _hipMemcpyAtoH__retval = hipError_t(chip.hipMemcpyAtoH(
        <void *>hip._util.types.Pointer.fromPyobj(dst)._ptr,
        hipArray.fromPyobj(srcArray).getElementPtr(),srcOffset,count))
    return (_hipMemcpyAtoH__retval,)


@cython.embedsignature(True)
def hipMemcpyHtoA(object dstArray, unsigned long dstOffset, object srcHost, unsigned long count):
    r"""Copies data between host and device.

    See:
        `~.hipMemcpy`, `~.hipMemcpy2DToArray`, `~.hipMemcpy2D`, `~.hipMemcpyFromArray`, `~.hipMemcpyToSymbol`,
        `~.hipMemcpyAsync`

    Args:
        dstArray (`~.hipArray`/`~.object`) -- *IN*:
            Destination memory address

        dstOffset (`~.int`) -- *IN*:
            Offset in bytes of destination array

        srcHost (`~.hip._util.types.Pointer`/`~.object`) -- *IN*:
            Source host pointer

        count (`~.int`) -- *IN*:
            Size of memory copy in bytes

    Returns:
        A `~.tuple` of size 1 that contains (in that order):

        * `~.hipError_t`: `~.hipSuccess`, `~.hipErrorInvalidValue`, `~.hipErrorInvalidPitchValue`,
            `~.hipErrorInvalidDevicePointer`, `~.hipErrorInvalidMemcpyDirection`
    """
    _hipMemcpyHtoA__retval = hipError_t(chip.hipMemcpyHtoA(
        hipArray.fromPyobj(dstArray).getElementPtr(),dstOffset,
        <const void *>hip._util.types.Pointer.fromPyobj(srcHost)._ptr,count))
    return (_hipMemcpyHtoA__retval,)


@cython.embedsignature(True)
def hipMemcpy3D(object p):
    r"""Copies data between host and device.

    See:
        `~.hipMemcpy`, `~.hipMemcpy2DToArray`, `~.hipMemcpy2D`, `~.hipMemcpyFromArray`, `~.hipMemcpyToSymbol`,
        `~.hipMemcpyAsync`

    Args:
        p (`~.hipMemcpy3DParms`/`~.object`) -- *IN*:
            3D memory copy parameters

    Returns:
        A `~.tuple` of size 1 that contains (in that order):

        * `~.hipError_t`: `~.hipSuccess`, `~.hipErrorInvalidValue`, `~.hipErrorInvalidPitchValue`,
            `~.hipErrorInvalidDevicePointer`, `~.hipErrorInvalidMemcpyDirection`
    """
    _hipMemcpy3D__retval = hipError_t(chip.hipMemcpy3D(
        hipMemcpy3DParms.fromPyobj(p).getElementPtr()))
    return (_hipMemcpy3D__retval,)


@cython.embedsignature(True)
def hipMemcpy3DAsync(object p, object stream):
    r"""Copies data between host and device asynchronously.

    See:
        `~.hipMemcpy`, `~.hipMemcpy2DToArray`, `~.hipMemcpy2D`, `~.hipMemcpyFromArray`, `~.hipMemcpyToSymbol`,
        `~.hipMemcpyAsync`

    Args:
        p (`~.hipMemcpy3DParms`/`~.object`) -- *IN*:
            3D memory copy parameters

        stream (`~.ihipStream_t`/`~.object`) -- *IN*:
            Stream to use

    Returns:
        A `~.tuple` of size 1 that contains (in that order):

        * `~.hipError_t`: `~.hipSuccess`, `~.hipErrorInvalidValue`, `~.hipErrorInvalidPitchValue`,
            `~.hipErrorInvalidDevicePointer`, `~.hipErrorInvalidMemcpyDirection`
    """
    _hipMemcpy3DAsync__retval = hipError_t(chip.hipMemcpy3DAsync(
        hipMemcpy3DParms.fromPyobj(p).getElementPtr(),
        ihipStream_t.fromPyobj(stream).getElementPtr()))
    return (_hipMemcpy3DAsync__retval,)


@cython.embedsignature(True)
def hipDrvMemcpy3D(object pCopy):
    r"""Copies data between host and device.

    See:
        `~.hipMemcpy`, `~.hipMemcpy2DToArray`, `~.hipMemcpy2D`, `~.hipMemcpyFromArray`, `~.hipMemcpyToSymbol`,
        `~.hipMemcpyAsync`

    Args:
        pCopy (`~.HIP_MEMCPY3D`/`~.object`) -- *IN*:
            3D memory copy parameters

    Returns:
        A `~.tuple` of size 1 that contains (in that order):

        * `~.hipError_t`: `~.hipSuccess`, `~.hipErrorInvalidValue`, `~.hipErrorInvalidPitchValue`,
            `~.hipErrorInvalidDevicePointer`, `~.hipErrorInvalidMemcpyDirection`
    """
    _hipDrvMemcpy3D__retval = hipError_t(chip.hipDrvMemcpy3D(
        HIP_MEMCPY3D.fromPyobj(pCopy).getElementPtr()))
    return (_hipDrvMemcpy3D__retval,)


@cython.embedsignature(True)
def hipDrvMemcpy3DAsync(object pCopy, object stream):
    r"""Copies data between host and device asynchronously.

    See:
        `~.hipMemcpy`, `~.hipMemcpy2DToArray`, `~.hipMemcpy2D`, `~.hipMemcpyFromArray`, `~.hipMemcpyToSymbol`,
        `~.hipMemcpyAsync`

    Args:
        pCopy (`~.HIP_MEMCPY3D`/`~.object`) -- *IN*:
            3D memory copy parameters

        stream (`~.ihipStream_t`/`~.object`) -- *IN*:
            Stream to use

    Returns:
        A `~.tuple` of size 1 that contains (in that order):

        * `~.hipError_t`: `~.hipSuccess`, `~.hipErrorInvalidValue`, `~.hipErrorInvalidPitchValue`,
            `~.hipErrorInvalidDevicePointer`, `~.hipErrorInvalidMemcpyDirection`
    """
    _hipDrvMemcpy3DAsync__retval = hipError_t(chip.hipDrvMemcpy3DAsync(
        HIP_MEMCPY3D.fromPyobj(pCopy).getElementPtr(),
        ihipStream_t.fromPyobj(stream).getElementPtr()))
    return (_hipDrvMemcpy3DAsync__retval,)


@cython.embedsignature(True)
def hipDeviceCanAccessPeer(int deviceId, int peerDeviceId):
    r"""Determine if a device can access a peer's memory.

    Warning:
        PeerToPeer support is experimental.
        This section describes the PeerToPeer device memory access functions of HIP runtime API.

    Returns "1" in ``canAccessPeer`` if the specified ``device`` is capable
    of directly accessing memory physically located on peerDevice , or "0" if not.

    Returns "0" in ``canAccessPeer`` if deviceId == peerDeviceId, and both are valid devices : a
    device is not a peer of itself.

    Args:
        deviceId (`~.int`) -- *IN*:
            - device from where memory may be accessed.

        peerDeviceId (`~.int`) -- *IN*:
            - device where memory is physically located

    Returns:
        A `~.tuple` of size 2 that contains (in that order):

        * `~.hipError_t`: One of:
                -        `~.hipSuccess`,

                - `~.hipErrorInvalidDevice` if deviceId or peerDeviceId are not valid devices
        * `~.int`:
                Returns the peer access capability (0 or 1)
    """
    cdef int canAccessPeer
    _hipDeviceCanAccessPeer__retval = hipError_t(chip.hipDeviceCanAccessPeer(&canAccessPeer,deviceId,peerDeviceId))
    return (_hipDeviceCanAccessPeer__retval,canAccessPeer)


@cython.embedsignature(True)
def hipDeviceEnablePeerAccess(int peerDeviceId, unsigned int flags):
    r"""Enable direct access from current device's virtual address space to memory allocations
    physically located on a peer device.

    Memory which already allocated on peer device will be mapped into the address space of the
    current device.  In addition, all future memory allocations on peerDeviceId will be mapped into
    the address space of the current device when the memory is allocated. The peer memory remains
    accessible from the current device until a call to hipDeviceDisablePeerAccess or hipDeviceReset.

    Returns `~.hipSuccess`, `~.hipErrorInvalidDevice`, `~.hipErrorInvalidValue`,

    Args:
        peerDeviceId (`~.int`) -- *IN*:
            Peer device to enable direct access to from the current device

        flags (`~.int`) -- *IN*:
            Reserved for future use, must be zero

    Returns:
        A `~.tuple` of size 1 that contains (in that order):

        * `~.hipError_t`: `~.hipErrorPeerAccessAlreadyEnabled` if peer access is already enabled for this device.
    """
    _hipDeviceEnablePeerAccess__retval = hipError_t(chip.hipDeviceEnablePeerAccess(peerDeviceId,flags))
    return (_hipDeviceEnablePeerAccess__retval,)


@cython.embedsignature(True)
def hipDeviceDisablePeerAccess(int peerDeviceId):
    r"""Disable direct access from current device's virtual address space to memory allocations
    physically located on a peer device.

    Returns hipErrorPeerAccessNotEnabled if direct access to memory on peerDevice has not yet been
    enabled from the current device.

    Args:
        peerDeviceId (`~.int`) -- *IN*:
            Peer device to disable direct access to

    Returns:
        A `~.tuple` of size 1 that contains (in that order):

        * `~.hipError_t`: `~.hipSuccess`, `~.hipErrorPeerAccessNotEnabled`
    """
    _hipDeviceDisablePeerAccess__retval = hipError_t(chip.hipDeviceDisablePeerAccess(peerDeviceId))
    return (_hipDeviceDisablePeerAccess__retval,)


@cython.embedsignature(True)
def hipMemGetAddressRange(object dptr):
    r"""Get information on memory allocations.

    See:
        `~.hipCtxCreate`, `~.hipCtxDestroy`, `~.hipCtxGetFlags`, `~.hipCtxPopCurrent`, `~.hipCtxGetCurrent`,
        `~.hipCtxSetCurrent`, `~.hipCtxPushCurrent`, `~.hipCtxSetCacheConfig`, `~.hipCtxSynchronize`, `~.hipCtxGetDevice`

    Args:
        dptr (`~.hip._util.types.Pointer`/`~.object`) -- *IN*:
            - Device Pointer

    Returns:
        A `~.tuple` of size 3 that contains (in that order):

        * `~.hipError_t`: `~.hipSuccess`, `~.hipErrorNotFound`
        * `~.hip._util.types.Pointer`/`~.object`:
                - BAse pointer address
        * `~.int`:
                - Size of allocation
    """
    pbase = hip._util.types.Pointer.fromPtr(NULL)
    cdef unsigned long psize
    _hipMemGetAddressRange__retval = hipError_t(chip.hipMemGetAddressRange(
        <void **>&pbase._ptr,&psize,
        <void *>hip._util.types.Pointer.fromPyobj(dptr)._ptr))
    return (_hipMemGetAddressRange__retval,None if pbase._ptr == NULL else pbase,psize)


@cython.embedsignature(True)
def hipMemcpyPeer(object dst, int dstDeviceId, object src, int srcDeviceId, unsigned long sizeBytes):
    r"""Copies memory from one device to memory on another device.

    Args:
        dst (`~.hip._util.types.Pointer`/`~.object`) -- *OUT*:
            - Destination device pointer.

        dstDeviceId (`~.int`) -- *IN*:
            - Destination device

        src (`~.hip._util.types.Pointer`/`~.object`) -- *IN*:
            - Source device pointer

        srcDeviceId (`~.int`) -- *IN*:
            - Source device

        sizeBytes (`~.int`) -- *IN*:
            - Size of memory copy in bytes

    Returns:
        A `~.tuple` of size 1 that contains (in that order):

        * `~.hipError_t`: `~.hipSuccess`, `~.hipErrorInvalidValue`, `~.hipErrorInvalidDevice`
    """
    _hipMemcpyPeer__retval = hipError_t(chip.hipMemcpyPeer(
        <void *>hip._util.types.Pointer.fromPyobj(dst)._ptr,dstDeviceId,
        <const void *>hip._util.types.Pointer.fromPyobj(src)._ptr,srcDeviceId,sizeBytes))
    return (_hipMemcpyPeer__retval,)


@cython.embedsignature(True)
def hipMemcpyPeerAsync(object dst, int dstDeviceId, object src, int srcDevice, unsigned long sizeBytes, object stream):
    r"""Copies memory from one device to memory on another device.

    Args:
        dst (`~.hip._util.types.Pointer`/`~.object`) -- *OUT*:
            - Destination device pointer.

        dstDeviceId (`~.int`) -- *IN*:
            - Destination device

        src (`~.hip._util.types.Pointer`/`~.object`) -- *IN*:
            - Source device pointer

        srcDevice (`~.int`) -- *IN*:
            - Source device

        sizeBytes (`~.int`) -- *IN*:
            - Size of memory copy in bytes

        stream (`~.ihipStream_t`/`~.object`) -- *IN*:
            - Stream identifier

    Returns:
        A `~.tuple` of size 1 that contains (in that order):

        * `~.hipError_t`: `~.hipSuccess`, `~.hipErrorInvalidValue`, `~.hipErrorInvalidDevice`
    """
    _hipMemcpyPeerAsync__retval = hipError_t(chip.hipMemcpyPeerAsync(
        <void *>hip._util.types.Pointer.fromPyobj(dst)._ptr,dstDeviceId,
        <const void *>hip._util.types.Pointer.fromPyobj(src)._ptr,srcDevice,sizeBytes,
        ihipStream_t.fromPyobj(stream).getElementPtr()))
    return (_hipMemcpyPeerAsync__retval,)


@cython.embedsignature(True)
def hipCtxCreate(unsigned int flags, int device):
    r"""Create a context and set it as current/default context

    See:
        `~.hipCtxDestroy`, `~.hipCtxGetFlags`, `~.hipCtxPopCurrent`, `~.hipCtxGetCurrent`, `~.hipCtxPushCurrent`,
        `~.hipCtxSetCacheConfig`, `~.hipCtxSynchronize`, `~.hipCtxGetDevice`

    Warning:
        This API is deprecated on the AMD platform, only for equivalent cuCtx driver API on the
        NVIDIA platform.

    Args:
        flags (`~.int`) -- *IN*:
            Context creation flags

        device (`~.int`) -- *IN*:
            device handle

    Returns:
        A `~.tuple` of size 2 that contains (in that order):

        * `~.hipError_t`: `~.hipSuccess`
        * `~.ihipCtx_t`:
                Context to create
    """
    ctx = ihipCtx_t.fromPtr(NULL)
    _hipCtxCreate__retval = hipError_t(chip.hipCtxCreate(<chip.ihipCtx_t**>&ctx._ptr,flags,device))
    return (_hipCtxCreate__retval,None if ctx._ptr == NULL else ctx)


@cython.embedsignature(True)
def hipCtxDestroy(object ctx):
    r"""Destroy a HIP context.

    See:
        `~.hipCtxCreate`, `~.hipCtxGetFlags`, `~.hipCtxPopCurrent`, `~.hipCtxGetCurrent`,`~.hipCtxSetCurrent`,
        `~.hipCtxPushCurrent`, `~.hipCtxSetCacheConfig`, `~.hipCtxSynchronize` , `~.hipCtxGetDevice`

    Warning:
        This API is deprecated on the AMD platform, only for equivalent cuCtx driver API on the
        NVIDIA platform.

    Args:
        ctx (`~.ihipCtx_t`/`~.object`) -- *IN*:
            Context to destroy

    Returns:
        A `~.tuple` of size 1 that contains (in that order):

        * `~.hipError_t`: `~.hipSuccess`, `~.hipErrorInvalidValue`
    """
    _hipCtxDestroy__retval = hipError_t(chip.hipCtxDestroy(
        ihipCtx_t.fromPyobj(ctx).getElementPtr()))
    return (_hipCtxDestroy__retval,)


@cython.embedsignature(True)
def hipCtxPopCurrent():
    r"""Pop the current/default context and return the popped context.

    See:
        `~.hipCtxCreate`, `~.hipCtxDestroy`, `~.hipCtxGetFlags`, `~.hipCtxSetCurrent`, `~.hipCtxGetCurrent`,
        `~.hipCtxPushCurrent`, `~.hipCtxSetCacheConfig`, `~.hipCtxSynchronize`, `~.hipCtxGetDevice`

    Warning:
        This API is deprecated on the AMD platform, only for equivalent cuCtx driver API on the
        NVIDIA platform.

    Returns:
        A `~.tuple` of size 2 that contains (in that order):

        * `~.hipError_t`: `~.hipSuccess`, `~.hipErrorInvalidContext`
        * `~.ihipCtx_t`:
                The current context to pop
    """
    ctx = ihipCtx_t.fromPtr(NULL)
    _hipCtxPopCurrent__retval = hipError_t(chip.hipCtxPopCurrent(<chip.ihipCtx_t**>&ctx._ptr))
    return (_hipCtxPopCurrent__retval,None if ctx._ptr == NULL else ctx)


@cython.embedsignature(True)
def hipCtxPushCurrent(object ctx):
    r"""Push the context to be set as current/ default context

    See:
        `~.hipCtxCreate`, `~.hipCtxDestroy`, `~.hipCtxGetFlags`, `~.hipCtxPopCurrent`, `~.hipCtxGetCurrent`,
        `~.hipCtxPushCurrent`, `~.hipCtxSetCacheConfig`, `~.hipCtxSynchronize` , `~.hipCtxGetDevice`

    Warning:
        This API is deprecated on the AMD platform, only for equivalent cuCtx driver API on the
        NVIDIA platform.

    Args:
        ctx (`~.ihipCtx_t`/`~.object`) -- *IN*:
            The current context to push

    Returns:
        A `~.tuple` of size 1 that contains (in that order):

        * `~.hipError_t`: `~.hipSuccess`, `~.hipErrorInvalidContext`
    """
    _hipCtxPushCurrent__retval = hipError_t(chip.hipCtxPushCurrent(
        ihipCtx_t.fromPyobj(ctx).getElementPtr()))
    return (_hipCtxPushCurrent__retval,)


@cython.embedsignature(True)
def hipCtxSetCurrent(object ctx):
    r"""Set the passed context as current/default

    See:
        `~.hipCtxCreate`, `~.hipCtxDestroy`, `~.hipCtxGetFlags`, `~.hipCtxPopCurrent`, `~.hipCtxGetCurrent`,
        `~.hipCtxPushCurrent`, `~.hipCtxSetCacheConfig`, `~.hipCtxSynchronize` , `~.hipCtxGetDevice`

    Warning:
        This API is deprecated on the AMD platform, only for equivalent cuCtx driver API on the
        NVIDIA platform.

    Args:
        ctx (`~.ihipCtx_t`/`~.object`) -- *IN*:
            The context to set as current

    Returns:
        A `~.tuple` of size 1 that contains (in that order):

        * `~.hipError_t`: `~.hipSuccess`, `~.hipErrorInvalidContext`
    """
    _hipCtxSetCurrent__retval = hipError_t(chip.hipCtxSetCurrent(
        ihipCtx_t.fromPyobj(ctx).getElementPtr()))
    return (_hipCtxSetCurrent__retval,)


@cython.embedsignature(True)
def hipCtxGetCurrent():
    r"""Get the handle of the current/ default context

    See:
        `~.hipCtxCreate`, `~.hipCtxDestroy`, `~.hipCtxGetDevice`, `~.hipCtxGetFlags`, `~.hipCtxPopCurrent`,
        `~.hipCtxPushCurrent`, `~.hipCtxSetCacheConfig`, `~.hipCtxSynchronize`, `~.hipCtxGetDevice`

    Warning:
        This API is deprecated on the AMD platform, only for equivalent cuCtx driver API on the
        NVIDIA platform.

    Returns:
        A `~.tuple` of size 2 that contains (in that order):

        * `~.hipError_t`: `~.hipSuccess`, `~.hipErrorInvalidContext`
        * `~.ihipCtx_t`:
                The context to get as current
    """
    ctx = ihipCtx_t.fromPtr(NULL)
    _hipCtxGetCurrent__retval = hipError_t(chip.hipCtxGetCurrent(<chip.ihipCtx_t**>&ctx._ptr))
    return (_hipCtxGetCurrent__retval,None if ctx._ptr == NULL else ctx)


@cython.embedsignature(True)
def hipCtxGetDevice():
    r"""Get the handle of the device associated with current/default context

    See:
        `~.hipCtxCreate`, `~.hipCtxDestroy`, `~.hipCtxGetFlags`, `~.hipCtxPopCurrent`, `~.hipCtxGetCurrent`,
        `~.hipCtxPushCurrent`, `~.hipCtxSetCacheConfig`, `~.hipCtxSynchronize`

    Warning:
        This API is deprecated on the AMD platform, only for equivalent cuCtx driver API on the
        NVIDIA platform.

    Returns:
        A `~.tuple` of size 2 that contains (in that order):

        * `~.hipError_t`: `~.hipSuccess`, `~.hipErrorInvalidContext`
        * `~.int`:
                The device from the current context
    """
    cdef int device
    _hipCtxGetDevice__retval = hipError_t(chip.hipCtxGetDevice(&device))
    return (_hipCtxGetDevice__retval,device)


@cython.embedsignature(True)
def hipCtxGetApiVersion(object ctx):
    r"""Returns the approximate HIP api version.

    Warning:
        The HIP feature set does not correspond to an exact CUDA SDK api revision.
        This function always set *apiVersion to 4 as an approximation though HIP supports
        some features which were introduced in later CUDA SDK revisions.
        HIP apps code should not rely on the api revision number here and should
        use arch feature flags to test device capabilities or conditional compilation.

    See:
        `~.hipCtxCreate`, `~.hipCtxDestroy`, `~.hipCtxGetDevice`, `~.hipCtxGetFlags`, `~.hipCtxPopCurrent`,
        `~.hipCtxPushCurrent`, `~.hipCtxSetCacheConfig`, `~.hipCtxSynchronize`, `~.hipCtxGetDevice`

    Warning:
        This API is deprecated on the AMD platform, only for equivalent cuCtx driver API on the
        NVIDIA platform.

    Args:
        ctx (`~.ihipCtx_t`/`~.object`) -- *IN*:
            Context to check

    Returns:
        A `~.tuple` of size 2 that contains (in that order):

        * `~.hipError_t`: `~.hipSuccess`
        * `~.int`:
                API version to get
    """
    cdef int apiVersion
    _hipCtxGetApiVersion__retval = hipError_t(chip.hipCtxGetApiVersion(
        ihipCtx_t.fromPyobj(ctx).getElementPtr(),&apiVersion))
    return (_hipCtxGetApiVersion__retval,apiVersion)


@cython.embedsignature(True)
def hipCtxGetCacheConfig():
    r"""Get Cache configuration for a specific function

    Warning:
        AMD devices and some Nvidia GPUS do not support reconfigurable cache.  This hint is
        ignored on those architectures.

    See:
        `~.hipCtxCreate`, `~.hipCtxDestroy`, `~.hipCtxGetFlags`, `~.hipCtxPopCurrent`, `~.hipCtxGetCurrent`,
        `~.hipCtxSetCurrent`, `~.hipCtxPushCurrent`, `~.hipCtxSetCacheConfig`, `~.hipCtxSynchronize`, `~.hipCtxGetDevice`

    Warning:
        This API is deprecated on the AMD platform, only for equivalent cuCtx driver API on the
        NVIDIA platform.

    Returns:
        A `~.tuple` of size 2 that contains (in that order):

        * `~.hipError_t`: `~.hipSuccess`
        * `~.hipFuncCache_t`:
                Cache configuration
    """
    cdef chip.hipFuncCache_t cacheConfig
    _hipCtxGetCacheConfig__retval = hipError_t(chip.hipCtxGetCacheConfig(&cacheConfig))
    return (_hipCtxGetCacheConfig__retval,hipFuncCache_t(cacheConfig))


@cython.embedsignature(True)
def hipCtxSetCacheConfig(object cacheConfig):
    r"""Set L1/Shared cache partition.

    Warning:
        AMD devices and some Nvidia GPUS do not support reconfigurable cache.  This hint is
        ignored on those architectures.

    See:
        `~.hipCtxCreate`, `~.hipCtxDestroy`, `~.hipCtxGetFlags`, `~.hipCtxPopCurrent`, `~.hipCtxGetCurrent`,
        `~.hipCtxSetCurrent`, `~.hipCtxPushCurrent`, `~.hipCtxSetCacheConfig`, `~.hipCtxSynchronize`, `~.hipCtxGetDevice`

    Warning:
        This API is deprecated on the AMD platform, only for equivalent cuCtx driver API on the
        NVIDIA platform.

    Args:
        cacheConfig (`~.hipFuncCache_t`) -- *IN*:
            Cache configuration to set

    Returns:
        A `~.tuple` of size 1 that contains (in that order):

        * `~.hipError_t`: `~.hipSuccess`
    """
    if not isinstance(cacheConfig,_hipFuncCache_t__Base):
        raise TypeError("argument 'cacheConfig' must be of type '_hipFuncCache_t__Base'")
    _hipCtxSetCacheConfig__retval = hipError_t(chip.hipCtxSetCacheConfig(cacheConfig.value))
    return (_hipCtxSetCacheConfig__retval,)


@cython.embedsignature(True)
def hipCtxSetSharedMemConfig(object config):
    r"""Set Shared memory bank configuration.

    Warning:
        AMD devices and some Nvidia GPUS do not support shared cache banking, and the hint is
        ignored on those architectures.

    See:
        `~.hipCtxCreate`, `~.hipCtxDestroy`, `~.hipCtxGetFlags`, `~.hipCtxPopCurrent`, `~.hipCtxGetCurrent`,
        `~.hipCtxSetCurrent`, `~.hipCtxPushCurrent`, `~.hipCtxSetCacheConfig`, `~.hipCtxSynchronize`, `~.hipCtxGetDevice`

    Warning:
        This API is deprecated on the AMD platform, only for equivalent cuCtx driver API on the
        NVIDIA platform.

    Args:
        config (`~.hipSharedMemConfig`) -- *IN*:
            Shared memory configuration to set

    Returns:
        A `~.tuple` of size 1 that contains (in that order):

        * `~.hipError_t`: `~.hipSuccess`
    """
    if not isinstance(config,_hipSharedMemConfig__Base):
        raise TypeError("argument 'config' must be of type '_hipSharedMemConfig__Base'")
    _hipCtxSetSharedMemConfig__retval = hipError_t(chip.hipCtxSetSharedMemConfig(config.value))
    return (_hipCtxSetSharedMemConfig__retval,)


@cython.embedsignature(True)
def hipCtxGetSharedMemConfig():
    r"""Get Shared memory bank configuration.

    Warning:
        AMD devices and some Nvidia GPUS do not support shared cache banking, and the hint is
        ignored on those architectures.

    See:
        `~.hipCtxCreate`, `~.hipCtxDestroy`, `~.hipCtxGetFlags`, `~.hipCtxPopCurrent`, `~.hipCtxGetCurrent`,
        `~.hipCtxSetCurrent`, `~.hipCtxPushCurrent`, `~.hipCtxSetCacheConfig`, `~.hipCtxSynchronize`, `~.hipCtxGetDevice`

    Warning:
        This API is deprecated on the AMD platform, only for equivalent cuCtx driver API on the
        NVIDIA platform.

    Returns:
        A `~.tuple` of size 2 that contains (in that order):

        * `~.hipError_t`: `~.hipSuccess`
        * `~.hipSharedMemConfig`:
                Pointer of shared memory configuration
    """
    cdef chip.hipSharedMemConfig pConfig
    _hipCtxGetSharedMemConfig__retval = hipError_t(chip.hipCtxGetSharedMemConfig(&pConfig))
    return (_hipCtxGetSharedMemConfig__retval,hipSharedMemConfig(pConfig))


@cython.embedsignature(True)
def hipCtxSynchronize():
    r"""Blocks until the default context has completed all preceding requested tasks.

    Warning:
        This function waits for all streams on the default context to complete execution, and
        then returns.

    See:
        `~.hipCtxCreate`, `~.hipCtxDestroy`, `~.hipCtxGetFlags`, `~.hipCtxPopCurrent`, `~.hipCtxGetCurrent`,
        `~.hipCtxSetCurrent`, `~.hipCtxPushCurrent`, `~.hipCtxSetCacheConfig`, `~.hipCtxGetDevice`

    Warning:
        This API is deprecated on the AMD platform, only for equivalent cuCtx driver API on the
        NVIDIA platform.

    Returns:
        A `~.tuple` of size 1 that contains (in that order):

        * `~.hipError_t`: `~.hipSuccess`
    """
    _hipCtxSynchronize__retval = hipError_t(chip.hipCtxSynchronize())
    return (_hipCtxSynchronize__retval,)


@cython.embedsignature(True)
def hipCtxGetFlags():
    r"""Return flags used for creating default context.

    See:
        `~.hipCtxCreate`, `~.hipCtxDestroy`, `~.hipCtxPopCurrent`, `~.hipCtxGetCurrent`, `~.hipCtxGetCurrent`,
        `~.hipCtxSetCurrent`, `~.hipCtxPushCurrent`, `~.hipCtxSetCacheConfig`, `~.hipCtxSynchronize`, `~.hipCtxGetDevice`

    Warning:
        This API is deprecated on the AMD platform, only for equivalent cuCtx driver API on the
        NVIDIA platform.

    Returns:
        A `~.tuple` of size 2 that contains (in that order):

        * `~.hipError_t`: `~.hipSuccess`
        * `~.int`:
                Pointer of flags
    """
    cdef unsigned int flags
    _hipCtxGetFlags__retval = hipError_t(chip.hipCtxGetFlags(&flags))
    return (_hipCtxGetFlags__retval,flags)


@cython.embedsignature(True)
def hipCtxEnablePeerAccess(object peerCtx, unsigned int flags):
    r"""Enables direct access to memory allocations in a peer context.

    Memory which already allocated on peer device will be mapped into the address space of the
    current device.  In addition, all future memory allocations on peerDeviceId will be mapped into
    the address space of the current device when the memory is allocated. The peer memory remains
    accessible from the current device until a call to hipDeviceDisablePeerAccess or hipDeviceReset.

    See:
        `~.hipCtxCreate`, `~.hipCtxDestroy`, `~.hipCtxGetFlags`, `~.hipCtxPopCurrent`, `~.hipCtxGetCurrent`,
        `~.hipCtxSetCurrent`, `~.hipCtxPushCurrent`, `~.hipCtxSetCacheConfig`, `~.hipCtxSynchronize`, `~.hipCtxGetDevice`

    Warning:
        PeerToPeer support is experimental.

    Warning:
        This API is deprecated on the AMD platform, only for equivalent cuCtx driver API on the
        NVIDIA platform.

    Args:
        peerCtx (`~.ihipCtx_t`/`~.object`) -- *IN*:
            Peer context

        flags (`~.int`) -- *IN*:
            flags, need to set as 0

    Returns:
        A `~.tuple` of size 1 that contains (in that order):

        * `~.hipError_t`: `~.hipSuccess`, `~.hipErrorInvalidDevice`, `~.hipErrorInvalidValue`,
            `~.hipErrorPeerAccessAlreadyEnabled`
    """
    _hipCtxEnablePeerAccess__retval = hipError_t(chip.hipCtxEnablePeerAccess(
        ihipCtx_t.fromPyobj(peerCtx).getElementPtr(),flags))
    return (_hipCtxEnablePeerAccess__retval,)


@cython.embedsignature(True)
def hipCtxDisablePeerAccess(object peerCtx):
    r"""Disable direct access from current context's virtual address space to memory allocations
    physically located on a peer context.Disables direct access to memory allocations in a peer
    context and unregisters any registered allocations.

    Returns `~.hipErrorPeerAccessNotEnabled` if direct access to memory on peerDevice has not yet been
    enabled from the current device.

    See:
        `~.hipCtxCreate`, `~.hipCtxDestroy`, `~.hipCtxGetFlags`, `~.hipCtxPopCurrent`, `~.hipCtxGetCurrent`,
        `~.hipCtxSetCurrent`, `~.hipCtxPushCurrent`, `~.hipCtxSetCacheConfig`, `~.hipCtxSynchronize`, `~.hipCtxGetDevice`

    Warning:
        PeerToPeer support is experimental.

    Warning:
        This API is deprecated on the AMD platform, only for equivalent cuCtx driver API on the
        NVIDIA platform.

    Args:
        peerCtx (`~.ihipCtx_t`/`~.object`) -- *IN*:
            Peer context to be disabled

    Returns:
        A `~.tuple` of size 1 that contains (in that order):

        * `~.hipError_t`: `~.hipSuccess`, `~.hipErrorPeerAccessNotEnabled`
    """
    _hipCtxDisablePeerAccess__retval = hipError_t(chip.hipCtxDisablePeerAccess(
        ihipCtx_t.fromPyobj(peerCtx).getElementPtr()))
    return (_hipCtxDisablePeerAccess__retval,)


@cython.embedsignature(True)
def hipDevicePrimaryCtxGetState(int dev):
    r"""Get the state of the primary context.

    See:
        `~.hipCtxCreate`, `~.hipCtxDestroy`, `~.hipCtxGetFlags`, `~.hipCtxPopCurrent`, `~.hipCtxGetCurrent`,
        `~.hipCtxSetCurrent`, `~.hipCtxPushCurrent`, `~.hipCtxSetCacheConfig`, `~.hipCtxSynchronize`, `~.hipCtxGetDevice`

    Warning:
        This API is deprecated on the AMD platform, only for equivalent driver API on the
        NVIDIA platform.

    Args:
        dev (`~.int`) -- *IN*:
            Device to get primary context flags for

    Returns:
        A `~.tuple` of size 3 that contains (in that order):

        * `~.hipError_t`: `~.hipSuccess`
        * `~.int`:
                Pointer to store flags
        * `~.int`:
                Pointer to store context state; 0 = inactive, 1 = active
    """
    cdef unsigned int flags
    cdef int active
    _hipDevicePrimaryCtxGetState__retval = hipError_t(chip.hipDevicePrimaryCtxGetState(dev,&flags,&active))
    return (_hipDevicePrimaryCtxGetState__retval,flags,active)


@cython.embedsignature(True)
def hipDevicePrimaryCtxRelease(int dev):
    r"""Release the primary context on the GPU.

    See:
        `~.hipCtxCreate`, `~.hipCtxDestroy`, `~.hipCtxGetFlags`, `~.hipCtxPopCurrent`, `~.hipCtxGetCurrent`,
        `~.hipCtxSetCurrent`, `~.hipCtxPushCurrent`, `~.hipCtxSetCacheConfig`, `~.hipCtxSynchronize`, `~.hipCtxGetDevice`

    Warning:
        This function return `~.hipSuccess` though doesn't release the primaryCtx by design on
        HIP/HCC path.

    Warning:
        This API is deprecated on the AMD platform, only for equivalent driver API on the NVIDIA
        platform.

    Args:
        dev (`~.int`) -- *IN*:
            Device which primary context is released

    Returns:
        A `~.tuple` of size 1 that contains (in that order):

        * `~.hipError_t`: `~.hipSuccess`
    """
    _hipDevicePrimaryCtxRelease__retval = hipError_t(chip.hipDevicePrimaryCtxRelease(dev))
    return (_hipDevicePrimaryCtxRelease__retval,)


@cython.embedsignature(True)
def hipDevicePrimaryCtxRetain(int dev):
    r"""Retain the primary context on the GPU.

    See:
        `~.hipCtxCreate`, `~.hipCtxDestroy`, `~.hipCtxGetFlags`, `~.hipCtxPopCurrent`, `~.hipCtxGetCurrent`,
        `~.hipCtxSetCurrent`, `~.hipCtxPushCurrent`, `~.hipCtxSetCacheConfig`, `~.hipCtxSynchronize`, `~.hipCtxGetDevice`

    Warning:
        This API is deprecated on the AMD platform, only for equivalent driver API on the NVIDIA
        platform.

    Args:
        dev (`~.int`) -- *IN*:
            Device which primary context is released

    Returns:
        A `~.tuple` of size 2 that contains (in that order):

        * `~.hipError_t`: `~.hipSuccess`
        * `~.ihipCtx_t`:
                Returned context handle of the new context
    """
    pctx = ihipCtx_t.fromPtr(NULL)
    _hipDevicePrimaryCtxRetain__retval = hipError_t(chip.hipDevicePrimaryCtxRetain(<chip.ihipCtx_t**>&pctx._ptr,dev))
    return (_hipDevicePrimaryCtxRetain__retval,None if pctx._ptr == NULL else pctx)


@cython.embedsignature(True)
def hipDevicePrimaryCtxReset(int dev):
    r"""Resets the primary context on the GPU.

    See:
        `~.hipCtxCreate`, `~.hipCtxDestroy`, `~.hipCtxGetFlags`, `~.hipCtxPopCurrent`, `~.hipCtxGetCurrent`,
        `~.hipCtxSetCurrent`, `~.hipCtxPushCurrent`, `~.hipCtxSetCacheConfig`, `~.hipCtxSynchronize`, `~.hipCtxGetDevice`

    Warning:
        This API is deprecated on the AMD platform, only for equivalent driver API on the NVIDIA
        platform.

    Args:
        dev (`~.int`) -- *IN*:
            Device which primary context is reset

    Returns:
        A `~.tuple` of size 1 that contains (in that order):

        * `~.hipError_t`: `~.hipSuccess`
    """
    _hipDevicePrimaryCtxReset__retval = hipError_t(chip.hipDevicePrimaryCtxReset(dev))
    return (_hipDevicePrimaryCtxReset__retval,)


@cython.embedsignature(True)
def hipDevicePrimaryCtxSetFlags(int dev, unsigned int flags):
    r"""Set flags for the primary context.

    See:
        `~.hipCtxCreate`, `~.hipCtxDestroy`, `~.hipCtxGetFlags`, `~.hipCtxPopCurrent`, `~.hipCtxGetCurrent`,
        `~.hipCtxSetCurrent`, `~.hipCtxPushCurrent`, `~.hipCtxSetCacheConfig`, `~.hipCtxSynchronize`, `~.hipCtxGetDevice`

    Warning:
        This API is deprecated on the AMD platform, only for equivalent driver API on the NVIDIA
        platform.

    Args:
        dev (`~.int`) -- *IN*:
            Device for which the primary context flags are set

        flags (`~.int`) -- *IN*:
            New flags for the device

    Returns:
        A `~.tuple` of size 1 that contains (in that order):

        * `~.hipError_t`: `~.hipSuccess`, `~.hipErrorContextAlreadyInUse`
    """
    _hipDevicePrimaryCtxSetFlags__retval = hipError_t(chip.hipDevicePrimaryCtxSetFlags(dev,flags))
    return (_hipDevicePrimaryCtxSetFlags__retval,)


@cython.embedsignature(True)
def hipModuleLoad(object fname):
    r"""Loads code object from file into a module the currrent context.

    This section describes the module management functions of HIP runtime API.

    Warning:
        File/memory resources allocated in this function are released only in hipModuleUnload.

    Args:
        fname (`~.hip._util.types.CStr`/`~.object`) -- *IN*:
            Filename of code object to load

    Returns:
        A `~.tuple` of size 2 that contains (in that order):

        * `~.hipError_t`: `~.hipSuccess`, `~.hipErrorInvalidValue`, `~.hipErrorInvalidContext`, `~.hipErrorFileNotFound`,
            `~.hipErrorOutOfMemory`, `~.hipErrorSharedObjectInitFailed`, `~.hipErrorNotInitialized`
        * `~.ihipModule_t`:
                Module
    """
    module = ihipModule_t.fromPtr(NULL)
    _hipModuleLoad__retval = hipError_t(chip.hipModuleLoad(<chip.ihipModule_t**>&module._ptr,
        <const char *>hip._util.types.CStr.fromPyobj(fname)._ptr))
    return (_hipModuleLoad__retval,None if module._ptr == NULL else module)


@cython.embedsignature(True)
def hipModuleUnload(object module):
    r"""Frees the module

    The module is freed, and the code objects associated with it are destroyed.

    Args:
        module (`~.ihipModule_t`/`~.object`) -- *IN*:
            Module to free

    Returns:
        A `~.tuple` of size 1 that contains (in that order):

        * `~.hipError_t`: `~.hipSuccess`, `~.hipErrorInvalidResourceHandle`
    """
    _hipModuleUnload__retval = hipError_t(chip.hipModuleUnload(
        ihipModule_t.fromPyobj(module).getElementPtr()))
    return (_hipModuleUnload__retval,)


@cython.embedsignature(True)
def hipModuleGetFunction(object module, object kname):
    r"""Function with kname will be extracted if present in module

    Args:
        module (`~.ihipModule_t`/`~.object`) -- *IN*:
            Module to get function from

        kname (`~.hip._util.types.CStr`/`~.object`) -- *IN*:
            Pointer to the name of function

    Returns:
        A `~.tuple` of size 2 that contains (in that order):

        * `~.hipError_t`: `~.hipSuccess`, `~.hipErrorInvalidValue`, `~.hipErrorInvalidContext`, `~.hipErrorNotInitialized`,
            `~.hipErrorNotFound`,
        * `~.ihipModuleSymbol_t`:
                Pointer to function handle
    """
    function = ihipModuleSymbol_t.fromPtr(NULL)
    _hipModuleGetFunction__retval = hipError_t(chip.hipModuleGetFunction(<chip.ihipModuleSymbol_t**>&function._ptr,
        ihipModule_t.fromPyobj(module).getElementPtr(),
        <const char *>hip._util.types.CStr.fromPyobj(kname)._ptr))
    return (_hipModuleGetFunction__retval,None if function._ptr == NULL else function)


@cython.embedsignature(True)
def hipFuncGetAttributes(object attr, object func):
    r"""Find out attributes for a given function.

    Args:
        attr (`~.hipFuncAttributes`/`~.object`) -- *OUT*:
            Attributes of funtion

        func (`~.hip._util.types.Pointer`/`~.object`) -- *IN*:
            Pointer to the function handle

    Returns:
        A `~.tuple` of size 1 that contains (in that order):

        * `~.hipError_t`: `~.hipSuccess`, `~.hipErrorInvalidValue`, `~.hipErrorInvalidDeviceFunction`
    """
    _hipFuncGetAttributes__retval = hipError_t(chip.hipFuncGetAttributes(
        hipFuncAttributes.fromPyobj(attr).getElementPtr(),
        <const void *>hip._util.types.Pointer.fromPyobj(func)._ptr))
    return (_hipFuncGetAttributes__retval,)


@cython.embedsignature(True)
def hipFuncGetAttribute(object attrib, object hfunc):
    r"""Find out a specific attribute for a given function.

    Args:
        attrib (`~.hipFunction_attribute`) -- *IN*:
            Attributes of the given funtion

        hfunc (`~.ihipModuleSymbol_t`/`~.object`) -- *IN*:
            Function to get attributes from

    Returns:
        A `~.tuple` of size 2 that contains (in that order):

        * `~.hipError_t`: `~.hipSuccess`, `~.hipErrorInvalidValue`, `~.hipErrorInvalidDeviceFunction`
        * `~.int`:
                Pointer to the value
    """
    cdef int value
    if not isinstance(attrib,_hipFunction_attribute__Base):
        raise TypeError("argument 'attrib' must be of type '_hipFunction_attribute__Base'")
    _hipFuncGetAttribute__retval = hipError_t(chip.hipFuncGetAttribute(&value,attrib.value,
        ihipModuleSymbol_t.fromPyobj(hfunc).getElementPtr()))
    return (_hipFuncGetAttribute__retval,value)


@cython.embedsignature(True)
def hipGetFuncBySymbol(object symbolPtr):
    r"""Gets pointer to device entry function that matches entry function symbolPtr.

    Args:
        symbolPtr (`~.hip._util.types.Pointer`/`~.object`) -- *IN*:
            Pointer to device entry function to search for

    Returns:
        A `~.tuple` of size 2 that contains (in that order):

        * `~.hipError_t`: `~.hipSuccess`, `~.hipErrorInvalidDeviceFunction`
        * `~.ihipModuleSymbol_t`:
                Device entry function
    """
    functionPtr = ihipModuleSymbol_t.fromPtr(NULL)
    _hipGetFuncBySymbol__retval = hipError_t(chip.hipGetFuncBySymbol(<chip.ihipModuleSymbol_t**>&functionPtr._ptr,
        <const void *>hip._util.types.Pointer.fromPyobj(symbolPtr)._ptr))
    return (_hipGetFuncBySymbol__retval,None if functionPtr._ptr == NULL else functionPtr)


@cython.embedsignature(True)
def hipModuleGetTexRef(object hmod, object name):
    r"""returns the handle of the texture reference with the name from the module.

    Args:
        hmod (`~.ihipModule_t`/`~.object`) -- *IN*:
            Module

        name (`~.hip._util.types.CStr`/`~.object`) -- *IN*:
            Pointer of name of texture reference

    Returns:
        A `~.tuple` of size 2 that contains (in that order):

        * `~.hipError_t`: `~.hipSuccess`, `~.hipErrorNotInitialized`, `~.hipErrorNotFound`, `~.hipErrorInvalidValue`
        * `~.textureReference`:
                Pointer of texture reference
    """
    texRef = textureReference.fromPtr(NULL)
    _hipModuleGetTexRef__retval = hipError_t(chip.hipModuleGetTexRef(<chip.textureReference**>&texRef._ptr,
        ihipModule_t.fromPyobj(hmod).getElementPtr(),
        <const char *>hip._util.types.CStr.fromPyobj(name)._ptr))
    return (_hipModuleGetTexRef__retval,None if texRef._ptr == NULL else texRef)


@cython.embedsignature(True)
def hipModuleLoadData(object image):
    r"""builds module from code object which resides in host memory. Image is pointer to that
    location.

    Args:
        image (`~.hip._util.types.Pointer`/`~.object`) -- *IN*:
            The pointer to the location of data

    Returns:
        A `~.tuple` of size 2 that contains (in that order):

        * `~.hipError_t`: hipSuccess, hipErrorNotInitialized, hipErrorOutOfMemory, hipErrorNotInitialized
        * `~.ihipModule_t`:
                Retuned module
    """
    module = ihipModule_t.fromPtr(NULL)
    _hipModuleLoadData__retval = hipError_t(chip.hipModuleLoadData(<chip.ihipModule_t**>&module._ptr,
        <const void *>hip._util.types.Pointer.fromPyobj(image)._ptr))
    return (_hipModuleLoadData__retval,None if module._ptr == NULL else module)


@cython.embedsignature(True)
def hipModuleLoadDataEx(object image, unsigned int numOptions, object options, object optionValues):
    r"""builds module from code object which resides in host memory. Image is pointer to that
    location. Options are not used. hipModuleLoadData is called.

    Args:
        image (`~.hip._util.types.Pointer`/`~.object`) -- *IN*:
            The pointer to the location of data

        numOptions (`~.int`) -- *IN*:
            Number of options

        options (`~.hip._util.types.Pointer`/`~.object`) -- *IN*:
            Options for JIT

        optionValues (`~.hip._util.types.Pointer`/`~.object`) -- *IN*:
            Option values for JIT

    Returns:
        A `~.tuple` of size 2 that contains (in that order):

        * `~.hipError_t`: hipSuccess, hipErrorNotInitialized, hipErrorOutOfMemory, hipErrorNotInitialized
        * `~.ihipModule_t`:
                Retuned module
    """
    module = ihipModule_t.fromPtr(NULL)
    _hipModuleLoadDataEx__retval = hipError_t(chip.hipModuleLoadDataEx(<chip.ihipModule_t**>&module._ptr,
        <const void *>hip._util.types.Pointer.fromPyobj(image)._ptr,numOptions,
        <chip.hipJitOption *>hip._util.types.Pointer.fromPyobj(options)._ptr,
        <void **>hip._util.types.Pointer.fromPyobj(optionValues)._ptr))
    return (_hipModuleLoadDataEx__retval,None if module._ptr == NULL else module)


@cython.embedsignature(True)
def hipModuleLaunchKernel(object f, unsigned int gridDimX, unsigned int gridDimY, unsigned int gridDimZ, unsigned int blockDimX, unsigned int blockDimY, unsigned int blockDimZ, unsigned int sharedMemBytes, object stream, object kernelParams, object extra):
    r"""launches kernel f with launch parameters and shared memory on stream with arguments passed
    to kernelparams or extra

    Please note, HIP does not support kernel launch with total work items defined in dimension with
    size gridDim x blockDim >= 2^32. So gridDim.x * blockDim.x, gridDim.y * blockDim.y
    and gridDim.z * blockDim.z are always less than 2^32.

    Args:
        f (`~.ihipModuleSymbol_t`/`~.object`) -- *IN*:
            Kernel to launch.

        gridDimX (`~.int`) -- *IN*:
            X grid dimension specified as multiple of blockDimX.

        gridDimY (`~.int`) -- *IN*:
            Y grid dimension specified as multiple of blockDimY.

        gridDimZ (`~.int`) -- *IN*:
            Z grid dimension specified as multiple of blockDimZ.

        blockDimX (`~.int`) -- *IN*:
            X block dimensions specified in work-items

        blockDimY (`~.int`) -- *IN*:
            Y grid dimension specified in work-items

        blockDimZ (`~.int`) -- *IN*:
            Z grid dimension specified in work-items

        sharedMemBytes (`~.int`) -- *IN*:
            Amount of dynamic shared memory to allocate for this kernel. The
            HIP-Clang compiler provides support for extern shared declarations.

        stream (`~.ihipStream_t`/`~.object`) -- *IN*:
            Stream where the kernel should be dispatched.  May be 0, in which case th
            default stream is used with associated synchronization rules.

        kernelParams (`~.hip._util.types.Pointer`/`~.object`) -- *IN*:
            Kernel parameters to launch

        extra (`~.hip._hip_helpers.HipModuleLaunchKernel_extra`/`~.object`) -- *IN*:
            Pointer to kernel arguments.   These are passed directly to the kernel and
            must be in the memory layout and alignment expected by the kernel.
            All passed arguments must be naturally aligned according to their type. The memory address of each
            argument should be a multiple of its size in bytes. Please refer to hip_porting_driver_api.md
            for sample usage.

    Returns:
        A `~.tuple` of size 1 that contains (in that order):

        * `~.hipError_t`: `~.hipSuccess`, `~.hipErrorNotInitialized`, `~.hipErrorInvalidValue`
    """
    _hipModuleLaunchKernel__retval = hipError_t(chip.hipModuleLaunchKernel(
        ihipModuleSymbol_t.fromPyobj(f).getElementPtr(),gridDimX,gridDimY,gridDimZ,blockDimX,blockDimY,blockDimZ,sharedMemBytes,
        ihipStream_t.fromPyobj(stream).getElementPtr(),
        <void **>hip._util.types.Pointer.fromPyobj(kernelParams)._ptr,
        <void **>hip._hip_helpers.HipModuleLaunchKernel_extra.fromPyobj(extra)._ptr))
    return (_hipModuleLaunchKernel__retval,)


@cython.embedsignature(True)
def hipModuleLaunchCooperativeKernel(object f, unsigned int gridDimX, unsigned int gridDimY, unsigned int gridDimZ, unsigned int blockDimX, unsigned int blockDimY, unsigned int blockDimZ, unsigned int sharedMemBytes, object stream, object kernelParams):
    r"""launches kernel f with launch parameters and shared memory on stream with arguments passed
    to kernelParams, where thread blocks can cooperate and synchronize as they execute

    Please note, HIP does not support kernel launch with total work items defined in dimension with
    size gridDim x blockDim >= 2^32.

    Args:
        f (`~.ihipModuleSymbol_t`/`~.object`) -- *IN*:
            Kernel to launch.

        gridDimX (`~.int`) -- *IN*:
            X grid dimension specified as multiple of blockDimX.

        gridDimY (`~.int`) -- *IN*:
            Y grid dimension specified as multiple of blockDimY.

        gridDimZ (`~.int`) -- *IN*:
            Z grid dimension specified as multiple of blockDimZ.

        blockDimX (`~.int`) -- *IN*:
            X block dimension specified in work-items.

        blockDimY (`~.int`) -- *IN*:
            Y block dimension specified in work-items.

        blockDimZ (`~.int`) -- *IN*:
            Z block dimension specified in work-items.

        sharedMemBytes (`~.int`) -- *IN*:
            Amount of dynamic shared memory to allocate for this kernel. The
            HIP-Clang compiler provides support for extern shared declarations.

        stream (`~.ihipStream_t`/`~.object`) -- *IN*:
            Stream where the kernel should be dispatched. May be 0,
            in which case the default stream is used with associated synchronization rules.

        kernelParams (`~.hip._util.types.Pointer`/`~.object`) -- *IN*:
            A list of kernel arguments.

    Returns:
        A `~.tuple` of size 1 that contains (in that order):

        * `~.hipError_t`: `~.hipSuccess`, `~.hipErrorDeinitialized`, `~.hipErrorNotInitialized`, `~.hipErrorInvalidContext`,
            `~.hipErrorInvalidHandle`, `~.hipErrorInvalidImage`, `~.hipErrorInvalidValue`,
            `~.hipErrorInvalidConfiguration`, `~.hipErrorLaunchFailure`, `~.hipErrorLaunchOutOfResources`,
            `~.hipErrorLaunchTimeOut`, `~.hipErrorCooperativeLaunchTooLarge`, `~.hipErrorSharedObjectInitFailed`
    """
    _hipModuleLaunchCooperativeKernel__retval = hipError_t(chip.hipModuleLaunchCooperativeKernel(
        ihipModuleSymbol_t.fromPyobj(f).getElementPtr(),gridDimX,gridDimY,gridDimZ,blockDimX,blockDimY,blockDimZ,sharedMemBytes,
        ihipStream_t.fromPyobj(stream).getElementPtr(),
        <void **>hip._util.types.Pointer.fromPyobj(kernelParams)._ptr))
    return (_hipModuleLaunchCooperativeKernel__retval,)


@cython.embedsignature(True)
def hipModuleLaunchCooperativeKernelMultiDevice(object launchParamsList, unsigned int numDevices, unsigned int flags):
    r"""Launches kernels on multiple devices where thread blocks can cooperate and
    synchronize as they execute.

    Args:
        launchParamsList (`~.hipFunctionLaunchParams_t`/`~.object`) -- *IN*:
            List of launch parameters, one per device.

        numDevices (`~.int`) -- *IN*:
            Size of the launchParamsList array.

        flags (`~.int`) -- *IN*:
            Flags to control launch behavior.

    Returns:
        A `~.tuple` of size 1 that contains (in that order):

        * `~.hipError_t`: `~.hipSuccess`, `~.hipErrorDeinitialized`, `~.hipErrorNotInitialized`, `~.hipErrorInvalidContext`,
            `~.hipErrorInvalidHandle`, `~.hipErrorInvalidImage`, `~.hipErrorInvalidValue`,
            `~.hipErrorInvalidConfiguration`, `~.hipErrorInvalidResourceHandle`, `~.hipErrorLaunchFailure`,
            `~.hipErrorLaunchOutOfResources`, `~.hipErrorLaunchTimeOut`, `~.hipErrorCooperativeLaunchTooLarge`,
            `~.hipErrorSharedObjectInitFailed`
    """
    _hipModuleLaunchCooperativeKernelMultiDevice__retval = hipError_t(chip.hipModuleLaunchCooperativeKernelMultiDevice(
        hipFunctionLaunchParams_t.fromPyobj(launchParamsList).getElementPtr(),numDevices,flags))
    return (_hipModuleLaunchCooperativeKernelMultiDevice__retval,)


@cython.embedsignature(True)
def hipLaunchCooperativeKernel(object f, object gridDim, object blockDimX, object kernelParams, unsigned int sharedMemBytes, object stream):
    r"""launches kernel f with launch parameters and shared memory on stream with arguments passed
    to kernelparams or extra, where thread blocks can cooperate and synchronize as they execute

    Please note, HIP does not support kernel launch with total work items defined in dimension with
    size gridDim x blockDim >= 2^32.

    Args:
        f (`~.hip._util.types.Pointer`/`~.object`) -- *IN*:
            Kernel to launch.

        gridDim (`~.dim3`) -- *IN*:
            Grid dimensions specified as multiple of blockDim.

        blockDimX (`~.dim3`) -- *IN*:
            Block dimensions specified in work-items

        kernelParams (`~.hip._util.types.Pointer`/`~.object`) -- *IN*:
            A list of kernel arguments

        sharedMemBytes (`~.int`) -- *IN*:
            Amount of dynamic shared memory to allocate for this kernel. The
            HIP-Clang compiler provides support for extern shared declarations.

        stream (`~.ihipStream_t`/`~.object`) -- *IN*:
            Stream where the kernel should be dispatched.  May be 0, in which case th
            default stream is used with associated synchronization rules.

    Returns:
        A `~.tuple` of size 1 that contains (in that order):

        * `~.hipError_t`: `~.hipSuccess`, `~.hipErrorNotInitialized`, `~.hipErrorInvalidValue`, `~.hipErrorCooperativeLaunchTooLarge`
    """
    _hipLaunchCooperativeKernel__retval = hipError_t(chip.hipLaunchCooperativeKernel(
        <const void *>hip._util.types.Pointer.fromPyobj(f)._ptr,
        dim3.fromPyobj(gridDim).getElementPtr()[0],
        dim3.fromPyobj(blockDimX).getElementPtr()[0],
        <void **>hip._util.types.Pointer.fromPyobj(kernelParams)._ptr,sharedMemBytes,
        ihipStream_t.fromPyobj(stream).getElementPtr()))
    return (_hipLaunchCooperativeKernel__retval,)


@cython.embedsignature(True)
def hipLaunchCooperativeKernelMultiDevice(object launchParamsList, int numDevices, unsigned int flags):
    r"""Launches kernels on multiple devices where thread blocks can cooperate and
    synchronize as they execute.

    Args:
        launchParamsList (`~.hipLaunchParams_t`/`~.object`) -- *IN*:
            List of launch parameters, one per device.

        numDevices (`~.int`) -- *IN*:
            Size of the launchParamsList array.

        flags (`~.int`) -- *IN*:
            Flags to control launch behavior.

    Returns:
        A `~.tuple` of size 1 that contains (in that order):

        * `~.hipError_t`: `~.hipSuccess`, `~.hipErrorNotInitialized`, `~.hipErrorInvalidValue`,
            `~.hipErrorCooperativeLaunchTooLarge`
    """
    _hipLaunchCooperativeKernelMultiDevice__retval = hipError_t(chip.hipLaunchCooperativeKernelMultiDevice(
        hipLaunchParams_t.fromPyobj(launchParamsList).getElementPtr(),numDevices,flags))
    return (_hipLaunchCooperativeKernelMultiDevice__retval,)


@cython.embedsignature(True)
def hipExtLaunchMultiKernelMultiDevice(object launchParamsList, int numDevices, unsigned int flags):
    r"""Launches kernels on multiple devices and guarantees all specified kernels are dispatched
    on respective streams before enqueuing any other work on the specified streams from any other threads

    Args:
        launchParamsList (`~.hipLaunchParams_t`/`~.object`) -- *IN*:
            List of launch parameters, one per device.

        numDevices (`~.int`) -- *IN*:
            Size of the launchParamsList array.

        flags (`~.int`) -- *IN*:
            Flags to control launch behavior.

    Returns:
        A `~.tuple` of size 1 that contains (in that order):

        * `~.hipError_t`: `~.hipSuccess`, `~.hipErrorNotInitialized`, `~.hipErrorInvalidValue`
    """
    _hipExtLaunchMultiKernelMultiDevice__retval = hipError_t(chip.hipExtLaunchMultiKernelMultiDevice(
        hipLaunchParams_t.fromPyobj(launchParamsList).getElementPtr(),numDevices,flags))
    return (_hipExtLaunchMultiKernelMultiDevice__retval,)


@cython.embedsignature(True)
def hipModuleOccupancyMaxPotentialBlockSize(object f, unsigned long dynSharedMemPerBlk, int blockSizeLimit):
    r"""determine the grid and block sizes to achieves maximum occupancy for a kernel

    This section describes the occupancy functions of HIP runtime API.

    Please note, HIP does not support kernel launch with total work items defined in dimension with
    size gridDim x blockDim >= 2^32.

    Args:
        f (`~.ihipModuleSymbol_t`/`~.object`) -- *IN*:
            kernel function for which occupancy is calulated

        dynSharedMemPerBlk (`~.int`) -- *IN*:
            dynamic shared memory usage (in bytes) intended for each block

        blockSizeLimit (`~.int`) -- *IN*:
            the maximum block size for the kernel, use 0 for no limit

    Returns:
        A `~.tuple` of size 3 that contains (in that order):

        * `~.hipError_t`: `~.hipSuccess`, `~.hipErrorInvalidValue`
        * `~.int`:
                minimum grid size for maximum potential occupancy
        * `~.int`:
                block size for maximum potential occupancy
    """
    cdef int gridSize
    cdef int blockSize
    _hipModuleOccupancyMaxPotentialBlockSize__retval = hipError_t(chip.hipModuleOccupancyMaxPotentialBlockSize(&gridSize,&blockSize,
        ihipModuleSymbol_t.fromPyobj(f).getElementPtr(),dynSharedMemPerBlk,blockSizeLimit))
    return (_hipModuleOccupancyMaxPotentialBlockSize__retval,gridSize,blockSize)


@cython.embedsignature(True)
def hipModuleOccupancyMaxPotentialBlockSizeWithFlags(object f, unsigned long dynSharedMemPerBlk, int blockSizeLimit, unsigned int flags):
    r"""determine the grid and block sizes to achieves maximum occupancy for a kernel

    Please note, HIP does not support kernel launch with total work items defined in dimension with
    size gridDim x blockDim >= 2^32.

    Args:
        f (`~.ihipModuleSymbol_t`/`~.object`) -- *IN*:
            kernel function for which occupancy is calulated

        dynSharedMemPerBlk (`~.int`) -- *IN*:
            dynamic shared memory usage (in bytes) intended for each block

        blockSizeLimit (`~.int`) -- *IN*:
            the maximum block size for the kernel, use 0 for no limit

        flags (`~.int`) -- *IN*:
            Extra flags for occupancy calculation (only default supported)

    Returns:
        A `~.tuple` of size 3 that contains (in that order):

        * `~.hipError_t`: `~.hipSuccess`, `~.hipErrorInvalidValue`
        * `~.int`:
                minimum grid size for maximum potential occupancy
        * `~.int`:
                block size for maximum potential occupancy
    """
    cdef int gridSize
    cdef int blockSize
    _hipModuleOccupancyMaxPotentialBlockSizeWithFlags__retval = hipError_t(chip.hipModuleOccupancyMaxPotentialBlockSizeWithFlags(&gridSize,&blockSize,
        ihipModuleSymbol_t.fromPyobj(f).getElementPtr(),dynSharedMemPerBlk,blockSizeLimit,flags))
    return (_hipModuleOccupancyMaxPotentialBlockSizeWithFlags__retval,gridSize,blockSize)


@cython.embedsignature(True)
def hipModuleOccupancyMaxActiveBlocksPerMultiprocessor(object f, int blockSize, unsigned long dynSharedMemPerBlk):
    r"""Returns occupancy for a device function.

    Args:
        f (`~.ihipModuleSymbol_t`/`~.object`) -- *IN*:
            Kernel function (hipFunction) for which occupancy is calulated

        blockSize (`~.int`) -- *IN*:
            Block size the kernel is intended to be launched with

        dynSharedMemPerBlk (`~.int`) -- *IN*:
            Dynamic shared memory usage (in bytes) intended for each block

    Returns:
        A `~.tuple` of size 2 that contains (in that order):

        * `~.hipError_t`: `~.hipSuccess`, `~.hipErrorInvalidValue`
        * `~.int`:
                Returned occupancy
    """
    cdef int numBlocks
    _hipModuleOccupancyMaxActiveBlocksPerMultiprocessor__retval = hipError_t(chip.hipModuleOccupancyMaxActiveBlocksPerMultiprocessor(&numBlocks,
        ihipModuleSymbol_t.fromPyobj(f).getElementPtr(),blockSize,dynSharedMemPerBlk))
    return (_hipModuleOccupancyMaxActiveBlocksPerMultiprocessor__retval,numBlocks)


@cython.embedsignature(True)
def hipModuleOccupancyMaxActiveBlocksPerMultiprocessorWithFlags(object f, int blockSize, unsigned long dynSharedMemPerBlk, unsigned int flags):
    r"""Returns occupancy for a device function.

    Args:
        f (`~.ihipModuleSymbol_t`/`~.object`) -- *IN*:
            Kernel function(hipFunction_t) for which occupancy is calulated

        blockSize (`~.int`) -- *IN*:
            Block size the kernel is intended to be launched with

        dynSharedMemPerBlk (`~.int`) -- *IN*:
            Dynamic shared memory usage (in bytes) intended for each block

        flags (`~.int`) -- *IN*:
            Extra flags for occupancy calculation (only default supported)

    Returns:
        A `~.tuple` of size 2 that contains (in that order):

        * `~.hipError_t`: `~.hipSuccess`, `~.hipErrorInvalidValue`
        * `~.int`:
                Returned occupancy
    """
    cdef int numBlocks
    _hipModuleOccupancyMaxActiveBlocksPerMultiprocessorWithFlags__retval = hipError_t(chip.hipModuleOccupancyMaxActiveBlocksPerMultiprocessorWithFlags(&numBlocks,
        ihipModuleSymbol_t.fromPyobj(f).getElementPtr(),blockSize,dynSharedMemPerBlk,flags))
    return (_hipModuleOccupancyMaxActiveBlocksPerMultiprocessorWithFlags__retval,numBlocks)


@cython.embedsignature(True)
def hipOccupancyMaxActiveBlocksPerMultiprocessor(object f, int blockSize, unsigned long dynSharedMemPerBlk):
    r"""Returns occupancy for a device function.

    Args:
        f (`~.hip._util.types.Pointer`/`~.object`) -- *IN*:
            Kernel function for which occupancy is calulated

        blockSize (`~.int`) -- *IN*:
            Block size the kernel is intended to be launched with

        dynSharedMemPerBlk (`~.int`) -- *IN*:
            Dynamic shared memory usage (in bytes) intended for each block

    Returns:
        A `~.tuple` of size 2 that contains (in that order):

        * `~.hipError_t`: `~.hipSuccess`, `~.hipErrorInvalidDeviceFunction`, `~.hipErrorInvalidValue`
        * `~.int`:
                Returned occupancy
    """
    cdef int numBlocks
    _hipOccupancyMaxActiveBlocksPerMultiprocessor__retval = hipError_t(chip.hipOccupancyMaxActiveBlocksPerMultiprocessor(&numBlocks,
        <const void *>hip._util.types.Pointer.fromPyobj(f)._ptr,blockSize,dynSharedMemPerBlk))
    return (_hipOccupancyMaxActiveBlocksPerMultiprocessor__retval,numBlocks)


@cython.embedsignature(True)
def hipOccupancyMaxActiveBlocksPerMultiprocessorWithFlags(object f, int blockSize, unsigned long dynSharedMemPerBlk, unsigned int flags):
    r"""Returns occupancy for a device function.

    Args:
        f (`~.hip._util.types.Pointer`/`~.object`) -- *IN*:
            Kernel function for which occupancy is calulated

        blockSize (`~.int`) -- *IN*:
            Block size the kernel is intended to be launched with

        dynSharedMemPerBlk (`~.int`) -- *IN*:
            Dynamic shared memory usage (in bytes) intended for each block

        flags (`~.int`) -- *IN*:
            Extra flags for occupancy calculation (currently ignored)

    Returns:
        A `~.tuple` of size 2 that contains (in that order):

        * `~.hipError_t`: `~.hipSuccess`, `~.hipErrorInvalidDeviceFunction`, `~.hipErrorInvalidValue`
        * `~.int`:
                Returned occupancy
    """
    cdef int numBlocks
    _hipOccupancyMaxActiveBlocksPerMultiprocessorWithFlags__retval = hipError_t(chip.hipOccupancyMaxActiveBlocksPerMultiprocessorWithFlags(&numBlocks,
        <const void *>hip._util.types.Pointer.fromPyobj(f)._ptr,blockSize,dynSharedMemPerBlk,flags))
    return (_hipOccupancyMaxActiveBlocksPerMultiprocessorWithFlags__retval,numBlocks)


@cython.embedsignature(True)
def hipOccupancyMaxPotentialBlockSize(object f, unsigned long dynSharedMemPerBlk, int blockSizeLimit):
    r"""determine the grid and block sizes to achieves maximum occupancy for a kernel

    Please note, HIP does not support kernel launch with total work items defined in dimension with
    size gridDim x blockDim >= 2^32.

    Args:
        f (`~.hip._util.types.Pointer`/`~.object`) -- *IN*:
            kernel function for which occupancy is calulated

        dynSharedMemPerBlk (`~.int`) -- *IN*:
            dynamic shared memory usage (in bytes) intended for each block

        blockSizeLimit (`~.int`) -- *IN*:
            the maximum block size for the kernel, use 0 for no limit

    Returns:
        A `~.tuple` of size 3 that contains (in that order):

        * `~.hipError_t`: `~.hipSuccess`, `~.hipErrorInvalidValue`
        * `~.int`:
                minimum grid size for maximum potential occupancy
        * `~.int`:
                block size for maximum potential occupancy
    """
    cdef int gridSize
    cdef int blockSize
    _hipOccupancyMaxPotentialBlockSize__retval = hipError_t(chip.hipOccupancyMaxPotentialBlockSize(&gridSize,&blockSize,
        <const void *>hip._util.types.Pointer.fromPyobj(f)._ptr,dynSharedMemPerBlk,blockSizeLimit))
    return (_hipOccupancyMaxPotentialBlockSize__retval,gridSize,blockSize)


@cython.embedsignature(True)
def hipProfilerStart():
    r"""Start recording of profiling information
    When using this API, start the profiler with profiling disabled.  (--startdisabled)

    Warning:
        hipProfilerStart API is deprecated, use roctracer/rocTX instead.

    Returns:
        A `~.tuple` of size 1 that contains (in that order):

        * `~.hipError_t`: `~.hipErrorNotSupported`
    """
    _hipProfilerStart__retval = hipError_t(chip.hipProfilerStart())
    return (_hipProfilerStart__retval,)


@cython.embedsignature(True)
def hipProfilerStop():
    r"""Stop recording of profiling information.
    When using this API, start the profiler with profiling disabled.  (--startdisabled)

    Warning:
        hipProfilerStart API is deprecated, use roctracer/rocTX instead.

    Returns:
        A `~.tuple` of size 1 that contains (in that order):

        * `~.hipError_t`: `~.hipErrorNotSupported`
    """
    _hipProfilerStop__retval = hipError_t(chip.hipProfilerStop())
    return (_hipProfilerStop__retval,)


@cython.embedsignature(True)
def hipConfigureCall(object gridDim, object blockDim, unsigned long sharedMem, object stream):
    r"""Configure a kernel launch.

    This section describes the API to support the triple-chevron syntax.

    Please note, HIP does not support kernel launch with total work items defined in dimension with
    size gridDim x blockDim >= 2^32.

    Args:
        gridDim (`~.dim3`) -- *IN*:
            grid dimension specified as multiple of blockDim.

        blockDim (`~.dim3`) -- *IN*:
            block dimensions specified in work-items

        sharedMem (`~.int`) -- *IN*:
            Amount of dynamic shared memory to allocate for this kernel. The
            HIP-Clang compiler provides support for extern shared declarations.

        stream (`~.ihipStream_t`/`~.object`) -- *IN*:
            Stream where the kernel should be dispatched.  May be 0, in which case the
            default stream is used with associated synchronization rules.

    Returns:
        A `~.tuple` of size 1 that contains (in that order):

        * `~.hipError_t`: `~.hipSuccess`, `~.hipErrorNotInitialized`, `~.hipErrorInvalidValue`
    """
    _hipConfigureCall__retval = hipError_t(chip.hipConfigureCall(
        dim3.fromPyobj(gridDim).getElementPtr()[0],
        dim3.fromPyobj(blockDim).getElementPtr()[0],sharedMem,
        ihipStream_t.fromPyobj(stream).getElementPtr()))
    return (_hipConfigureCall__retval,)


@cython.embedsignature(True)
def hipSetupArgument(object arg, unsigned long size, unsigned long offset):
    r"""Set a kernel argument.

    Args:
        arg (`~.hip._util.types.Pointer`/`~.object`) -- *IN*:
            Pointer the argument in host memory.

        size (`~.int`) -- *IN*:
            Size of the argument.

        offset (`~.int`) -- *IN*:
            Offset of the argument on the argument stack.

    Returns:
        A `~.tuple` of size 1 that contains (in that order):

        * `~.hipError_t`: `~.hipSuccess`, `~.hipErrorNotInitialized`, `~.hipErrorInvalidValue`
    """
    _hipSetupArgument__retval = hipError_t(chip.hipSetupArgument(
        <const void *>hip._util.types.Pointer.fromPyobj(arg)._ptr,size,offset))
    return (_hipSetupArgument__retval,)


@cython.embedsignature(True)
def hipLaunchByPtr(object func):
    r"""Launch a kernel.

    Args:
        func (`~.hip._util.types.Pointer`/`~.object`) -- *IN*:
            Kernel to launch.

    Returns:
        A `~.tuple` of size 1 that contains (in that order):

        * `~.hipError_t`: `~.hipSuccess`, `~.hipErrorNotInitialized`, `~.hipErrorInvalidValue`
    """
    _hipLaunchByPtr__retval = hipError_t(chip.hipLaunchByPtr(
        <const void *>hip._util.types.Pointer.fromPyobj(func)._ptr))
    return (_hipLaunchByPtr__retval,)


@cython.embedsignature(True)
def hipLaunchKernel(object function_address, object numBlocks, object dimBlocks, object args, unsigned long sharedMemBytes, object stream):
    r"""C compliant kernel launch API

    Args:
        function_address (`~.hip._util.types.Pointer`/`~.object`) -- *IN*:
            - kernel stub function pointer.

        numBlocks (`~.dim3`) -- *IN*:
            - number of blocks

        dimBlocks (`~.dim3`) -- *IN*:
            - dimension of a block

        args (`~.hip._util.types.Pointer`/`~.object`) -- *IN*:
            - kernel arguments

        sharedMemBytes (`~.int`) -- *IN*:
            - Amount of dynamic shared memory to allocate for this kernel. The
            HIP-Clang compiler provides support for extern shared declarations.

        stream (`~.ihipStream_t`/`~.object`) -- *IN*:
            - Stream where the kernel should be dispatched.  May be 0, in which case th
            default stream is used with associated synchronization rules.

    Returns:
        A `~.tuple` of size 1 that contains (in that order):

        * `~.hipError_t`: `~.hipSuccess`, `~.hipErrorInvalidValue`
    """
    _hipLaunchKernel__retval = hipError_t(chip.hipLaunchKernel(
        <const void *>hip._util.types.Pointer.fromPyobj(function_address)._ptr,
        dim3.fromPyobj(numBlocks).getElementPtr()[0],
        dim3.fromPyobj(dimBlocks).getElementPtr()[0],
        <void **>hip._util.types.Pointer.fromPyobj(args)._ptr,sharedMemBytes,
        ihipStream_t.fromPyobj(stream).getElementPtr()))
    return (_hipLaunchKernel__retval,)


@cython.embedsignature(True)
def hipLaunchHostFunc(object stream, object fn, object userData):
    r"""Enqueues a host function call in a stream.

    The host function to call in this API will be executed after the preceding operations in
    the stream are complete. The function is a blocking operation that blocks operations in the
    stream that follow it, until the function is returned.
    Event synchronization and internal callback functions make sure enqueued operations will
    execute in order, in the stream.

    The host function must not make any HIP API calls. The host function is non-reentrant. It must
    not perform sychronization with any operation that may depend on other processing execution
    but is not enqueued to run earlier in the stream.

    Host functions that are enqueued respectively in different non-blocking streams can run concurrently.

    Warning:
        This API is marked as beta, meaning, while this is feature complete,
        it is still open to changes and may have outstanding issues.

    Args:
        stream (`~.ihipStream_t`/`~.object`) -- *IN*:
            - The stream to enqueue work in.

        fn (`~.hipHostFn_t`/`~.object`) -- *IN*:
            - The function to call once enqueued preceeding operations are complete.

        userData (`~.hip._util.types.Pointer`/`~.object`) -- *IN*:
            - User-specified data to be passed to the function.

    Returns:
        A `~.tuple` of size 1 that contains (in that order):

        * `~.hipError_t`: `~.hipSuccess`, `~.hipErrorInvalidResourceHandle`, `~.hipErrorInvalidValue`,
            `~.hipErrorNotSupported`
    """
    _hipLaunchHostFunc__retval = hipError_t(chip.hipLaunchHostFunc(
        ihipStream_t.fromPyobj(stream).getElementPtr(),
        hipHostFn_t.fromPyobj(fn).getElementPtr(),
        <void *>hip._util.types.Pointer.fromPyobj(userData)._ptr))
    return (_hipLaunchHostFunc__retval,)


@cython.embedsignature(True)
def hipDrvMemcpy2DUnaligned(object pCopy):
    r"""(No short description, might be part of a group.)

    Copies memory for 2D arrays.

    Args:
        pCopy (`~.hip_Memcpy2D`/`~.object`):
            - Parameters for the memory copy

    Returns:
        A `~.tuple` of size 1 that contains (in that order):

        * `~.hipError_t`: `~.hipSuccess`, `~.hipErrorInvalidValue`
    """
    _hipDrvMemcpy2DUnaligned__retval = hipError_t(chip.hipDrvMemcpy2DUnaligned(
        hip_Memcpy2D.fromPyobj(pCopy).getElementPtr()))
    return (_hipDrvMemcpy2DUnaligned__retval,)


@cython.embedsignature(True)
def hipExtLaunchKernel(object function_address, object numBlocks, object dimBlocks, object args, unsigned long sharedMemBytes, object stream, object startEvent, object stopEvent, int flags):
    r"""Launches kernel from the pointer address, with arguments and shared memory on stream.

    Args:
        function_address (`~.hip._util.types.Pointer`/`~.object`) -- *IN*:
            pointer to the Kernel to launch.

        numBlocks (`~.dim3`) -- *IN*:
            number of blocks.

        dimBlocks (`~.dim3`) -- *IN*:
            dimension of a block.

        args (`~.hip._util.types.Pointer`/`~.object`) -- *IN*:
            pointer to kernel arguments.

        sharedMemBytes (`~.int`) -- *IN*:
            Amount of dynamic shared memory to allocate for this kernel.
            HIP-Clang compiler provides support for extern shared declarations.

        stream (`~.ihipStream_t`/`~.object`) -- *IN*:
            Stream where the kernel should be dispatched.
            May be 0, in which case the default stream is used with associated synchronization rules.

        startEvent (`~.ihipEvent_t`/`~.object`) -- *IN*:
            If non-null, specified event will be updated to track the start time of
            the kernel launch. The event must be created before calling this API.

        stopEvent (`~.ihipEvent_t`/`~.object`) -- *IN*:
            If non-null, specified event will be updated to track the stop time of
            the kernel launch. The event must be created before calling this API.

        flags (`~.int`) -- *IN*:
            The value of hipExtAnyOrderLaunch, signifies if kernel can be
            launched in any order.

    Returns:
        A `~.tuple` of size 1 that contains (in that order):

        * `~.hipError_t`: `~.hipSuccess`, `~.hipErrorNotInitialized`, `~.hipErrorInvalidValue`.
    """
    _hipExtLaunchKernel__retval = hipError_t(chip.hipExtLaunchKernel(
        <const void *>hip._util.types.Pointer.fromPyobj(function_address)._ptr,
        dim3.fromPyobj(numBlocks).getElementPtr()[0],
        dim3.fromPyobj(dimBlocks).getElementPtr()[0],
        <void **>hip._util.types.Pointer.fromPyobj(args)._ptr,sharedMemBytes,
        ihipStream_t.fromPyobj(stream).getElementPtr(),
        ihipEvent_t.fromPyobj(startEvent).getElementPtr(),
        ihipEvent_t.fromPyobj(stopEvent).getElementPtr(),flags))
    return (_hipExtLaunchKernel__retval,)


@cython.embedsignature(True)
def hipCreateTextureObject(object pResDesc, object pTexDesc, object pResViewDesc):
    r"""Creates a texture object.

    Note:
        3D liner filter isn't supported on GFX90A boards, on which the API ``hipCreateTextureObject`` will
        return hipErrorNotSupported.

    Args:
        pResDesc (`~.hipResourceDesc`/`~.object`) -- *IN*:
            pointer to resource descriptor

        pTexDesc (`~.hipTextureDesc`/`~.object`) -- *IN*:
            pointer to texture descriptor

        pResViewDesc (`~.hipResourceViewDesc`/`~.object`) -- *IN*:
            pointer to resource view descriptor

    Returns:
        A `~.tuple` of size 2 that contains (in that order):

        * `~.hipError_t`: `~.hipSuccess`, `~.hipErrorInvalidValue`, `~.hipErrorNotSupported`, `~.hipErrorOutOfMemory`
        * `~.__hip_texture`:
                pointer to the texture object to create
    """
    pTexObject = __hip_texture.fromPtr(NULL)
    _hipCreateTextureObject__retval = hipError_t(chip.hipCreateTextureObject(<chip.__hip_texture**>&pTexObject._ptr,
        hipResourceDesc.fromPyobj(pResDesc).getElementPtr(),
        hipTextureDesc.fromPyobj(pTexDesc).getElementPtr(),
        hipResourceViewDesc.fromPyobj(pResViewDesc).getElementPtr()))
    return (_hipCreateTextureObject__retval,None if pTexObject._ptr == NULL else pTexObject)


@cython.embedsignature(True)
def hipDestroyTextureObject(object textureObject):
    r"""Destroys a texture object.

    Args:
        textureObject (`~.__hip_texture`/`~.object`) -- *IN*:
            texture object to destroy

    Returns:
        A `~.tuple` of size 1 that contains (in that order):

        * `~.hipError_t`: `~.hipSuccess`, `~.hipErrorInvalidValue`
    """
    _hipDestroyTextureObject__retval = hipError_t(chip.hipDestroyTextureObject(
        __hip_texture.fromPyobj(textureObject).getElementPtr()))
    return (_hipDestroyTextureObject__retval,)


@cython.embedsignature(True)
def hipGetChannelDesc(object desc, object array):
    r"""Gets the channel descriptor in an array.

    Args:
        desc (`~.hipChannelFormatDesc`/`~.object`) -- *IN*:
            pointer to channel format descriptor

        array (`~.hipArray`/`~.object`) -- *OUT*:
            memory array on the device

    Returns:
        A `~.tuple` of size 1 that contains (in that order):

        * `~.hipError_t`: `~.hipSuccess`, `~.hipErrorInvalidValue`
    """
    _hipGetChannelDesc__retval = hipError_t(chip.hipGetChannelDesc(
        hipChannelFormatDesc.fromPyobj(desc).getElementPtr(),
        hipArray.fromPyobj(array).getElementPtr()))
    return (_hipGetChannelDesc__retval,)


@cython.embedsignature(True)
def hipGetTextureObjectResourceDesc(object pResDesc, object textureObject):
    r"""Gets resource descriptor for the texture object.

    Args:
        pResDesc (`~.hipResourceDesc`/`~.object`) -- *OUT*:
            pointer to resource descriptor

        textureObject (`~.__hip_texture`/`~.object`) -- *IN*:
            texture object

    Returns:
        A `~.tuple` of size 1 that contains (in that order):

        * `~.hipError_t`: `~.hipSuccess`, `~.hipErrorInvalidValue`
    """
    _hipGetTextureObjectResourceDesc__retval = hipError_t(chip.hipGetTextureObjectResourceDesc(
        hipResourceDesc.fromPyobj(pResDesc).getElementPtr(),
        __hip_texture.fromPyobj(textureObject).getElementPtr()))
    return (_hipGetTextureObjectResourceDesc__retval,)


@cython.embedsignature(True)
def hipGetTextureObjectResourceViewDesc(object pResViewDesc, object textureObject):
    r"""Gets resource view descriptor for the texture object.

    Args:
        pResViewDesc (`~.hipResourceViewDesc`/`~.object`) -- *OUT*:
            pointer to resource view descriptor

        textureObject (`~.__hip_texture`/`~.object`) -- *IN*:
            texture object

    Returns:
        A `~.tuple` of size 1 that contains (in that order):

        * `~.hipError_t`: `~.hipSuccess`, `~.hipErrorInvalidValue`
    """
    _hipGetTextureObjectResourceViewDesc__retval = hipError_t(chip.hipGetTextureObjectResourceViewDesc(
        hipResourceViewDesc.fromPyobj(pResViewDesc).getElementPtr(),
        __hip_texture.fromPyobj(textureObject).getElementPtr()))
    return (_hipGetTextureObjectResourceViewDesc__retval,)


@cython.embedsignature(True)
def hipGetTextureObjectTextureDesc(object pTexDesc, object textureObject):
    r"""Gets texture descriptor for the texture object.

    Args:
        pTexDesc (`~.hipTextureDesc`/`~.object`) -- *OUT*:
            pointer to texture descriptor

        textureObject (`~.__hip_texture`/`~.object`) -- *IN*:
            texture object

    Returns:
        A `~.tuple` of size 1 that contains (in that order):

        * `~.hipError_t`: `~.hipSuccess`, `~.hipErrorInvalidValue`
    """
    _hipGetTextureObjectTextureDesc__retval = hipError_t(chip.hipGetTextureObjectTextureDesc(
        hipTextureDesc.fromPyobj(pTexDesc).getElementPtr(),
        __hip_texture.fromPyobj(textureObject).getElementPtr()))
    return (_hipGetTextureObjectTextureDesc__retval,)


@cython.embedsignature(True)
def hipTexObjectCreate(object pResDesc, object pTexDesc, object pResViewDesc):
    r"""Creates a texture object.

    Args:
        pResDesc (`~.HIP_RESOURCE_DESC_st`/`~.object`) -- *IN*:
            pointer to resource descriptor

        pTexDesc (`~.HIP_TEXTURE_DESC_st`/`~.object`) -- *IN*:
            pointer to texture descriptor

        pResViewDesc (`~.HIP_RESOURCE_VIEW_DESC_st`/`~.object`) -- *IN*:
            pointer to resource view descriptor

    Returns:
        A `~.tuple` of size 2 that contains (in that order):

        * `~.hipError_t`: `~.hipSuccess`, `~.hipErrorInvalidValue`
        * `~.__hip_texture`:
                pointer to texture object to create
    """
    pTexObject = __hip_texture.fromPtr(NULL)
    _hipTexObjectCreate__retval = hipError_t(chip.hipTexObjectCreate(<chip.__hip_texture**>&pTexObject._ptr,
        HIP_RESOURCE_DESC_st.fromPyobj(pResDesc).getElementPtr(),
        HIP_TEXTURE_DESC_st.fromPyobj(pTexDesc).getElementPtr(),
        HIP_RESOURCE_VIEW_DESC_st.fromPyobj(pResViewDesc).getElementPtr()))
    return (_hipTexObjectCreate__retval,None if pTexObject._ptr == NULL else pTexObject)


@cython.embedsignature(True)
def hipTexObjectDestroy(object texObject):
    r"""Destroys a texture object.

    Args:
        texObject (`~.__hip_texture`/`~.object`) -- *IN*:
            texture object to destroy

    Returns:
        A `~.tuple` of size 1 that contains (in that order):

        * `~.hipError_t`: `~.hipSuccess`, `~.hipErrorInvalidValue`
    """
    _hipTexObjectDestroy__retval = hipError_t(chip.hipTexObjectDestroy(
        __hip_texture.fromPyobj(texObject).getElementPtr()))
    return (_hipTexObjectDestroy__retval,)


@cython.embedsignature(True)
def hipTexObjectGetResourceDesc(object pResDesc, object texObject):
    r"""Gets resource descriptor of a texture object.

    Args:
        pResDesc (`~.HIP_RESOURCE_DESC_st`/`~.object`) -- *OUT*:
            pointer to resource descriptor

        texObject (`~.__hip_texture`/`~.object`) -- *IN*:
            texture object

    Returns:
        A `~.tuple` of size 1 that contains (in that order):

        * `~.hipError_t`: `~.hipSuccess`, `~.hipErrorNotSupported`, `~.hipErrorInvalidValue`
    """
    _hipTexObjectGetResourceDesc__retval = hipError_t(chip.hipTexObjectGetResourceDesc(
        HIP_RESOURCE_DESC_st.fromPyobj(pResDesc).getElementPtr(),
        __hip_texture.fromPyobj(texObject).getElementPtr()))
    return (_hipTexObjectGetResourceDesc__retval,)


@cython.embedsignature(True)
def hipTexObjectGetResourceViewDesc(object pResViewDesc, object texObject):
    r"""Gets resource view descriptor of a texture object.

    Args:
        pResViewDesc (`~.HIP_RESOURCE_VIEW_DESC_st`/`~.object`) -- *OUT*:
            pointer to resource view descriptor

        texObject (`~.__hip_texture`/`~.object`) -- *IN*:
            texture object

    Returns:
        A `~.tuple` of size 1 that contains (in that order):

        * `~.hipError_t`: `~.hipSuccess`, `~.hipErrorNotSupported`, `~.hipErrorInvalidValue`
    """
    _hipTexObjectGetResourceViewDesc__retval = hipError_t(chip.hipTexObjectGetResourceViewDesc(
        HIP_RESOURCE_VIEW_DESC_st.fromPyobj(pResViewDesc).getElementPtr(),
        __hip_texture.fromPyobj(texObject).getElementPtr()))
    return (_hipTexObjectGetResourceViewDesc__retval,)


@cython.embedsignature(True)
def hipTexObjectGetTextureDesc(object pTexDesc, object texObject):
    r"""Gets texture descriptor of a texture object.

    Args:
        pTexDesc (`~.HIP_TEXTURE_DESC_st`/`~.object`) -- *OUT*:
            pointer to texture descriptor

        texObject (`~.__hip_texture`/`~.object`) -- *IN*:
            texture object

    Returns:
        A `~.tuple` of size 1 that contains (in that order):

        * `~.hipError_t`: `~.hipSuccess`, `~.hipErrorNotSupported`, `~.hipErrorInvalidValue`
    """
    _hipTexObjectGetTextureDesc__retval = hipError_t(chip.hipTexObjectGetTextureDesc(
        HIP_TEXTURE_DESC_st.fromPyobj(pTexDesc).getElementPtr(),
        __hip_texture.fromPyobj(texObject).getElementPtr()))
    return (_hipTexObjectGetTextureDesc__retval,)


@cython.embedsignature(True)
def hipMallocMipmappedArray(object desc, object extent, unsigned int numLevels, unsigned int flags):
    r"""Allocate a mipmapped array on the device.

    Note:
        This API is implemented on Windows, under development on Linux.

    Args:
        desc (`~.hipChannelFormatDesc`/`~.object`) -- *IN*:
            - Requested channel format

        extent (`~.hipExtent`) -- *IN*:
            - Requested allocation size (width field in elements)

        numLevels (`~.int`) -- *IN*:
            - Number of mipmap levels to allocate

        flags (`~.int`) -- *IN*:
            - Flags for extensions

    Returns:
        A `~.tuple` of size 2 that contains (in that order):

        * `~.hipError_t`: `~.hipSuccess`, `~.hipErrorInvalidValue`, `~.hipErrorMemoryAllocation`
        * `~.hipMipmappedArray`:
                - Pointer to allocated mipmapped array in device memory
    """
    mipmappedArray = hipMipmappedArray.fromPtr(NULL)
    _hipMallocMipmappedArray__retval = hipError_t(chip.hipMallocMipmappedArray(<chip.hipMipmappedArray**>&mipmappedArray._ptr,
        hipChannelFormatDesc.fromPyobj(desc).getElementPtr(),
        hipExtent.fromPyobj(extent).getElementPtr()[0],numLevels,flags))
    return (_hipMallocMipmappedArray__retval,None if mipmappedArray._ptr == NULL else mipmappedArray)


@cython.embedsignature(True)
def hipFreeMipmappedArray(object mipmappedArray):
    r"""Frees a mipmapped array on the device.

    Note:
        This API is implemented on Windows, under development on Linux.

    Args:
        mipmappedArray (`~.hipMipmappedArray`/`~.object`) -- *IN*:
            - Pointer to mipmapped array to free

    Returns:
        A `~.tuple` of size 1 that contains (in that order):

        * `~.hipError_t`: `~.hipSuccess`, `~.hipErrorInvalidValue`
    """
    _hipFreeMipmappedArray__retval = hipError_t(chip.hipFreeMipmappedArray(
        hipMipmappedArray.fromPyobj(mipmappedArray).getElementPtr()))
    return (_hipFreeMipmappedArray__retval,)


@cython.embedsignature(True)
def hipGetMipmappedArrayLevel(object mipmappedArray, unsigned int level):
    r"""Gets a mipmap level of a HIP mipmapped array.

    Note:
        This API is implemented on Windows, under development on Linux.

    Args:
        mipmappedArray (`~.hipMipmappedArray`/`~.object`) -- *IN*:
            - HIP mipmapped array

        level (`~.int`) -- *IN*:
            - Mipmap level

    Returns:
        A `~.tuple` of size 2 that contains (in that order):

        * `~.hipError_t`: `~.hipSuccess`, `~.hipErrorInvalidValue`
        * `~.hipArray`:
                - Returned mipmap level HIP array
    """
    levelArray = hipArray.fromPtr(NULL)
    _hipGetMipmappedArrayLevel__retval = hipError_t(chip.hipGetMipmappedArrayLevel(<chip.hipArray**>&levelArray._ptr,
        hipMipmappedArray.fromPyobj(mipmappedArray).getElementPtr(),level))
    return (_hipGetMipmappedArrayLevel__retval,None if levelArray._ptr == NULL else levelArray)


@cython.embedsignature(True)
def hipMipmappedArrayCreate(object pMipmappedArrayDesc, unsigned int numMipmapLevels):
    r"""Create a mipmapped array.

    Note:
        This API is implemented on Windows, under development on Linux.

    Args:
        pMipmappedArrayDesc (`~.HIP_ARRAY3D_DESCRIPTOR`/`~.object`) -- *IN*:
            mipmapped array descriptor

        numMipmapLevels (`~.int`) -- *IN*:
            mipmap level

    Returns:
        A `~.tuple` of size 2 that contains (in that order):

        * `~.hipError_t`: `~.hipSuccess`, `~.hipErrorNotSupported`, `~.hipErrorInvalidValue`
        * `~.hipMipmappedArray`:
                pointer to mipmapped array
    """
    pHandle = hipMipmappedArray.fromPtr(NULL)
    _hipMipmappedArrayCreate__retval = hipError_t(chip.hipMipmappedArrayCreate(<chip.hipMipmappedArray**>&pHandle._ptr,
        HIP_ARRAY3D_DESCRIPTOR.fromPyobj(pMipmappedArrayDesc).getElementPtr(),numMipmapLevels))
    return (_hipMipmappedArrayCreate__retval,None if pHandle._ptr == NULL else pHandle)


@cython.embedsignature(True)
def hipMipmappedArrayDestroy(object hMipmappedArray):
    r"""Destroy a mipmapped array.

    Note:
        This API is implemented on Windows, under development on Linux.

    Args:
        hMipmappedArray (`~.hipMipmappedArray`/`~.object`) -- *OUT*:
            pointer to mipmapped array to destroy

    Returns:
        A `~.tuple` of size 1 that contains (in that order):

        * `~.hipError_t`: `~.hipSuccess`, `~.hipErrorInvalidValue`
    """
    _hipMipmappedArrayDestroy__retval = hipError_t(chip.hipMipmappedArrayDestroy(
        hipMipmappedArray.fromPyobj(hMipmappedArray).getElementPtr()))
    return (_hipMipmappedArrayDestroy__retval,)


@cython.embedsignature(True)
def hipMipmappedArrayGetLevel(object hMipMappedArray, unsigned int level):
    r"""Get a mipmapped array on a mipmapped level.

    Note:
        This API is implemented on Windows, under development on Linux.

    Args:
        hMipMappedArray (`~.hipMipmappedArray`/`~.object`) -- *OUT*:
            Pointer of mipmapped array on the requested mipmap level

        level (`~.int`) -- *OUT*:
            Mipmap level

    Returns:
        A `~.tuple` of size 2 that contains (in that order):

        * `~.hipError_t`: `~.hipSuccess`, `~.hipErrorInvalidValue`
        * `~.hipArray`:
                Pointer of array
    """
    pLevelArray = hipArray.fromPtr(NULL)
    _hipMipmappedArrayGetLevel__retval = hipError_t(chip.hipMipmappedArrayGetLevel(<chip.hipArray**>&pLevelArray._ptr,
        hipMipmappedArray.fromPyobj(hMipMappedArray).getElementPtr(),level))
    return (_hipMipmappedArrayGetLevel__retval,None if pLevelArray._ptr == NULL else pLevelArray)


@cython.embedsignature(True)
def hipBindTextureToMipmappedArray(object tex, object mipmappedArray, object desc):
    r"""Binds a mipmapped array to a texture.

    Args:
        tex (`~.textureReference`/`~.object`) -- *IN*:
            pointer to the texture reference to bind

        mipmappedArray (`~.hipMipmappedArray`/`~.object`) -- *IN*:
            memory mipmapped array on the device

        desc (`~.hipChannelFormatDesc`/`~.object`) -- *IN*:
            opointer to the channel format

    Returns:
        A `~.tuple` of size 1 that contains (in that order):

        * `~.hipError_t`: `~.hipSuccess`, `~.hipErrorInvalidValue`
    """
    _hipBindTextureToMipmappedArray__retval = hipError_t(chip.hipBindTextureToMipmappedArray(
        textureReference.fromPyobj(tex).getElementPtr(),
        hipMipmappedArray.fromPyobj(mipmappedArray).getElementPtr(),
        hipChannelFormatDesc.fromPyobj(desc).getElementPtr()))
    return (_hipBindTextureToMipmappedArray__retval,)


@cython.embedsignature(True)
def hipGetTextureReference(object symbol):
    r"""Gets the texture reference related with the symbol.

    Warning:
        This API is deprecated.

    Args:
        symbol (`~.hip._util.types.Pointer`/`~.object`) -- *IN*:
            pointer to the symbol related with the texture for the reference

    Returns:
        A `~.tuple` of size 2 that contains (in that order):

        * `~.hipError_t`: `~.hipSuccess`, `~.hipErrorInvalidValue`
        * `~.textureReference`:
                texture reference
    """
    texref = textureReference.fromPtr(NULL)
    _hipGetTextureReference__retval = hipError_t(chip.hipGetTextureReference(<chip.textureReference**>&texref._ptr,
        <const void *>hip._util.types.Pointer.fromPyobj(symbol)._ptr))
    return (_hipGetTextureReference__retval,None if texref._ptr == NULL else texref)


@cython.embedsignature(True)
def hipTexRefGetBorderColor(object texRef):
    r"""Gets the border color used by a texture reference.

    Warning:
        This API is deprecated.

    Args:
        texRef (`~.textureReference`/`~.object`) -- *IN*:
            Texture reference.

    Returns:
        A `~.tuple` of size 2 that contains (in that order):

        * `~.hipError_t`: `~.hipSuccess`, `~.hipErrorInvalidValue`
        * `~.float`:
                Returned Type and Value of RGBA color.
    """
    cdef float pBorderColor
    _hipTexRefGetBorderColor__retval = hipError_t(chip.hipTexRefGetBorderColor(&pBorderColor,
        textureReference.fromPyobj(texRef).getElementPtr()))
    return (_hipTexRefGetBorderColor__retval,pBorderColor)


@cython.embedsignature(True)
def hipTexRefGetArray(object texRef):
    r"""Gets the array bound to a texture reference.

    Warning:
        This API is deprecated.

    Args:
        texRef (`~.textureReference`/`~.object`) -- *IN*:
            texture reference.

    Returns:
        A `~.tuple` of size 2 that contains (in that order):

        * `~.hipError_t`: `~.hipSuccess`, `~.hipErrorInvalidValue`
        * `~.hipArray`:
                Returned array.
    """
    pArray = hipArray.fromPtr(NULL)
    _hipTexRefGetArray__retval = hipError_t(chip.hipTexRefGetArray(<chip.hipArray**>&pArray._ptr,
        textureReference.fromPyobj(texRef).getElementPtr()))
    return (_hipTexRefGetArray__retval,None if pArray._ptr == NULL else pArray)


@cython.embedsignature(True)
def hipTexRefSetAddressMode(object texRef, int dim, object am):
    r"""Sets address mode for a texture reference.

    Warning:
        This API is deprecated.

    Args:
        texRef (`~.textureReference`/`~.object`) -- *IN*:
            texture reference.

        dim (`~.int`) -- *IN*:
            Dimension of the texture.

        am (`~.hipTextureAddressMode`) -- *IN*:
            Value of the texture address mode.

    Returns:
        A `~.tuple` of size 1 that contains (in that order):

        * `~.hipError_t`: `~.hipSuccess`, `~.hipErrorInvalidValue`
    """
    if not isinstance(am,_hipTextureAddressMode__Base):
        raise TypeError("argument 'am' must be of type '_hipTextureAddressMode__Base'")
    _hipTexRefSetAddressMode__retval = hipError_t(chip.hipTexRefSetAddressMode(
        textureReference.fromPyobj(texRef).getElementPtr(),dim,am.value))
    return (_hipTexRefSetAddressMode__retval,)


@cython.embedsignature(True)
def hipTexRefSetArray(object tex, object array, unsigned int flags):
    r"""Binds an array as a texture reference.

    Warning:
        This API is deprecated.

    Args:
        tex (`~.textureReference`/`~.object`) -- *IN*:
            Pointer texture reference.

        array (`~.hipArray`/`~.object`) -- *IN*:
            Array to bind.

        flags (`~.int`) -- *IN*:
            Flags should be set as HIP_TRSA_OVERRIDE_FORMAT, as a valid value.

    Returns:
        A `~.tuple` of size 1 that contains (in that order):

        * `~.hipError_t`: `~.hipSuccess`, `~.hipErrorInvalidValue`
    """
    _hipTexRefSetArray__retval = hipError_t(chip.hipTexRefSetArray(
        textureReference.fromPyobj(tex).getElementPtr(),
        hipArray.fromPyobj(array).getElementPtr(),flags))
    return (_hipTexRefSetArray__retval,)


@cython.embedsignature(True)
def hipTexRefSetFilterMode(object texRef, object fm):
    r"""Set filter mode for a texture reference.

    Warning:
        This API is deprecated.

    Args:
        texRef (`~.textureReference`/`~.object`) -- *IN*:
            Pointer texture reference.

        fm (`~.hipTextureFilterMode`) -- *IN*:
            Value of texture filter mode.

    Returns:
        A `~.tuple` of size 1 that contains (in that order):

        * `~.hipError_t`: `~.hipSuccess`, `~.hipErrorInvalidValue`
    """
    if not isinstance(fm,_hipTextureFilterMode__Base):
        raise TypeError("argument 'fm' must be of type '_hipTextureFilterMode__Base'")
    _hipTexRefSetFilterMode__retval = hipError_t(chip.hipTexRefSetFilterMode(
        textureReference.fromPyobj(texRef).getElementPtr(),fm.value))
    return (_hipTexRefSetFilterMode__retval,)


@cython.embedsignature(True)
def hipTexRefSetFlags(object texRef, unsigned int Flags):
    r"""Set flags for a texture reference.

    Warning:
        This API is deprecated.

    Args:
        texRef (`~.textureReference`/`~.object`) -- *IN*:
            Pointer texture reference.

        Flags (`~.int`) -- *IN*:
            Value of flags.

    Returns:
        A `~.tuple` of size 1 that contains (in that order):

        * `~.hipError_t`: `~.hipSuccess`, `~.hipErrorInvalidValue`
    """
    _hipTexRefSetFlags__retval = hipError_t(chip.hipTexRefSetFlags(
        textureReference.fromPyobj(texRef).getElementPtr(),Flags))
    return (_hipTexRefSetFlags__retval,)


@cython.embedsignature(True)
def hipTexRefSetFormat(object texRef, object fmt, int NumPackedComponents):
    r"""Set format for a texture reference.

    Warning:
        This API is deprecated.

    Args:
        texRef (`~.textureReference`/`~.object`) -- *IN*:
            Pointer texture reference.

        fmt (`~.hipArray_Format`) -- *IN*:
            Value of format.

        NumPackedComponents (`~.int`) -- *IN*:
            Number of components per array.

    Returns:
        A `~.tuple` of size 1 that contains (in that order):

        * `~.hipError_t`: `~.hipSuccess`, `~.hipErrorInvalidValue`
    """
    if not isinstance(fmt,_hipArray_Format__Base):
        raise TypeError("argument 'fmt' must be of type '_hipArray_Format__Base'")
    _hipTexRefSetFormat__retval = hipError_t(chip.hipTexRefSetFormat(
        textureReference.fromPyobj(texRef).getElementPtr(),fmt.value,NumPackedComponents))
    return (_hipTexRefSetFormat__retval,)


@cython.embedsignature(True)
def hipBindTexture(object tex, object devPtr, object desc, unsigned long size):
    r"""Binds a memory area to a texture.

    Warning:
        This API is deprecated.

    Args:
        tex (`~.textureReference`/`~.object`) -- *IN*:
            Texture to bind.

        devPtr (`~.hip._util.types.Pointer`/`~.object`) -- *IN*:
            Pointer of memory on the device.

        desc (`~.hipChannelFormatDesc`/`~.object`) -- *IN*:
            Pointer of channel format descriptor.

        size (`~.int`) -- *IN*:
            Size of memory in bites.

    Returns:
        A `~.tuple` of size 2 that contains (in that order):

        * `~.hipError_t`: `~.hipSuccess`, `~.hipErrorInvalidValue`, `~.hipErrorNotSupported`
        * `~.int`:
                Offset in bytes.
    """
    cdef unsigned long offset
    _hipBindTexture__retval = hipError_t(chip.hipBindTexture(&offset,
        textureReference.fromPyobj(tex).getElementPtr(),
        <const void *>hip._util.types.Pointer.fromPyobj(devPtr)._ptr,
        hipChannelFormatDesc.fromPyobj(desc).getElementPtr(),size))
    return (_hipBindTexture__retval,offset)


@cython.embedsignature(True)
def hipBindTexture2D(object tex, object devPtr, object desc, unsigned long width, unsigned long height, unsigned long pitch):
    r"""Binds a 2D memory area to a texture.

    Warning:
        This API is deprecated.

    Args:
        tex (`~.textureReference`/`~.object`) -- *IN*:
            Texture to bind.

        devPtr (`~.hip._util.types.Pointer`/`~.object`) -- *IN*:
            Pointer of 2D memory area on the device.

        desc (`~.hipChannelFormatDesc`/`~.object`) -- *IN*:
            Pointer of channel format descriptor.

        width (`~.int`) -- *IN*:
            Width in texel units.

        height (`~.int`) -- *IN*:
            Height in texel units.

        pitch (`~.int`) -- *IN*:
            Pitch in bytes.

    Returns:
        A `~.tuple` of size 2 that contains (in that order):

        * `~.hipError_t`: `~.hipSuccess`, `~.hipErrorInvalidValue`, `~.hipErrorNotSupported`
        * `~.int`:
                Offset in bytes.
    """
    cdef unsigned long offset
    _hipBindTexture2D__retval = hipError_t(chip.hipBindTexture2D(&offset,
        textureReference.fromPyobj(tex).getElementPtr(),
        <const void *>hip._util.types.Pointer.fromPyobj(devPtr)._ptr,
        hipChannelFormatDesc.fromPyobj(desc).getElementPtr(),width,height,pitch))
    return (_hipBindTexture2D__retval,offset)


@cython.embedsignature(True)
def hipBindTextureToArray(object tex, object array, object desc):
    r"""Binds a memory area to a texture.

    Warning:
        This API is deprecated.

    Args:
        tex (`~.textureReference`/`~.object`) -- *IN*:
            Pointer of texture reference.

        array (`~.hipArray`/`~.object`) -- *IN*:
            Array to bind.

        desc (`~.hipChannelFormatDesc`/`~.object`) -- *IN*:
            Pointer of channel format descriptor.

    Returns:
        A `~.tuple` of size 1 that contains (in that order):

        * `~.hipError_t`: `~.hipSuccess`, `~.hipErrorInvalidValue`, `~.hipErrorNotSupported`
    """
    _hipBindTextureToArray__retval = hipError_t(chip.hipBindTextureToArray(
        textureReference.fromPyobj(tex).getElementPtr(),
        hipArray.fromPyobj(array).getElementPtr(),
        hipChannelFormatDesc.fromPyobj(desc).getElementPtr()))
    return (_hipBindTextureToArray__retval,)


@cython.embedsignature(True)
def hipGetTextureAlignmentOffset(object texref):
    r"""Get the offset of the alignment in a texture.

    Warning:
        This API is deprecated.

    Args:
        texref (`~.textureReference`/`~.object`) -- *IN*:
            Pointer of texture reference.

    Returns:
        A `~.tuple` of size 2 that contains (in that order):

        * `~.hipError_t`: `~.hipSuccess`, `~.hipErrorInvalidValue`, `~.hipErrorNotSupported`
        * `~.int`:
                Offset in bytes.
    """
    cdef unsigned long offset
    _hipGetTextureAlignmentOffset__retval = hipError_t(chip.hipGetTextureAlignmentOffset(&offset,
        textureReference.fromPyobj(texref).getElementPtr()))
    return (_hipGetTextureAlignmentOffset__retval,offset)


@cython.embedsignature(True)
def hipUnbindTexture(object tex):
    r"""Unbinds a texture.

    Warning:
        This API is deprecated.

    Args:
        tex (`~.textureReference`/`~.object`) -- *IN*:
            Texture to unbind.

    Returns:
        A `~.tuple` of size 1 that contains (in that order):

        * `~.hipError_t`: `~.hipSuccess`, `~.hipErrorInvalidValue`, `~.hipErrorNotSupported`
    """
    _hipUnbindTexture__retval = hipError_t(chip.hipUnbindTexture(
        textureReference.fromPyobj(tex).getElementPtr()))
    return (_hipUnbindTexture__retval,)


@cython.embedsignature(True)
def hipTexRefGetAddress(object texRef):
    r"""Gets the address for a texture reference.

    Warning:
        This API is deprecated.

    Args:
        texRef (`~.textureReference`/`~.object`) -- *IN*:
            Pointer of texture reference.

    Returns:
        A `~.tuple` of size 2 that contains (in that order):

        * `~.hipError_t`: `~.hipSuccess`, `~.hipErrorInvalidValue`, `~.hipErrorNotSupported`
        * `~.hip._util.types.Pointer`/`~.object`:
                Pointer of device address.
    """
    dev_ptr = hip._util.types.Pointer.fromPtr(NULL)
    _hipTexRefGetAddress__retval = hipError_t(chip.hipTexRefGetAddress(
        <void **>&dev_ptr._ptr,
        textureReference.fromPyobj(texRef).getElementPtr()))
    return (_hipTexRefGetAddress__retval,None if dev_ptr._ptr == NULL else dev_ptr)


@cython.embedsignature(True)
def hipTexRefGetAddressMode(object texRef, int dim):
    r"""Gets the address mode for a texture reference.

    Warning:
        This API is deprecated.

    Args:
        texRef (`~.textureReference`/`~.object`) -- *IN*:
            Pointer of texture reference.

        dim (`~.int`) -- *IN*:
            Dimension.

    Returns:
        A `~.tuple` of size 2 that contains (in that order):

        * `~.hipError_t`: `~.hipSuccess`, `~.hipErrorInvalidValue`, `~.hipErrorNotSupported`
        * `~.hipTextureAddressMode`:
                Pointer of address mode.
    """
    cdef chip.hipTextureAddressMode pam
    _hipTexRefGetAddressMode__retval = hipError_t(chip.hipTexRefGetAddressMode(&pam,
        textureReference.fromPyobj(texRef).getElementPtr(),dim))
    return (_hipTexRefGetAddressMode__retval,hipTextureAddressMode(pam))


@cython.embedsignature(True)
def hipTexRefGetFilterMode(object texRef):
    r"""Gets filter mode for a texture reference.

    Warning:
        This API is deprecated.

    Args:
        texRef (`~.textureReference`/`~.object`) -- *IN*:
            Pointer of texture reference.

    Returns:
        A `~.tuple` of size 2 that contains (in that order):

        * `~.hipError_t`: `~.hipSuccess`, `~.hipErrorInvalidValue`, `~.hipErrorNotSupported`
        * `~.hipTextureFilterMode`:
                Pointer of filter mode.
    """
    cdef chip.hipTextureFilterMode pfm
    _hipTexRefGetFilterMode__retval = hipError_t(chip.hipTexRefGetFilterMode(&pfm,
        textureReference.fromPyobj(texRef).getElementPtr()))
    return (_hipTexRefGetFilterMode__retval,hipTextureFilterMode(pfm))


@cython.embedsignature(True)
def hipTexRefGetFlags(object texRef):
    r"""Gets flags for a texture reference.

    Warning:
        This API is deprecated.

    Args:
        texRef (`~.textureReference`/`~.object`) -- *IN*:
            Pointer of texture reference.

    Returns:
        A `~.tuple` of size 2 that contains (in that order):

        * `~.hipError_t`: `~.hipSuccess`, `~.hipErrorInvalidValue`, `~.hipErrorNotSupported`
        * `~.int`:
                Pointer of flags.
    """
    cdef unsigned int pFlags
    _hipTexRefGetFlags__retval = hipError_t(chip.hipTexRefGetFlags(&pFlags,
        textureReference.fromPyobj(texRef).getElementPtr()))
    return (_hipTexRefGetFlags__retval,pFlags)


@cython.embedsignature(True)
def hipTexRefGetFormat(object texRef):
    r"""Gets texture format for a texture reference.

    Warning:
        This API is deprecated.

    Args:
        texRef (`~.textureReference`/`~.object`) -- *IN*:
            Pointer of texture reference.

    Returns:
        A `~.tuple` of size 3 that contains (in that order):

        * `~.hipError_t`: `~.hipSuccess`, `~.hipErrorInvalidValue`, `~.hipErrorNotSupported`
        * `~.hipArray_Format`:
                Pointer of the format.
        * `~.int`:
                Pointer of number of channels.
    """
    cdef chip.hipArray_Format pFormat
    cdef int pNumChannels
    _hipTexRefGetFormat__retval = hipError_t(chip.hipTexRefGetFormat(&pFormat,&pNumChannels,
        textureReference.fromPyobj(texRef).getElementPtr()))
    return (_hipTexRefGetFormat__retval,hipArray_Format(pFormat),pNumChannels)


@cython.embedsignature(True)
def hipTexRefGetMaxAnisotropy(object texRef):
    r"""Gets the maximum anisotropy for a texture reference.

    Warning:
        This API is deprecated.

    Args:
        texRef (`~.textureReference`/`~.object`) -- *IN*:
            Pointer of texture reference.

    Returns:
        A `~.tuple` of size 2 that contains (in that order):

        * `~.hipError_t`: `~.hipErrorInvalidValue`, `~.hipErrorNotSupported`
        * `~.int`:
                Pointer of the maximum anisotropy.
    """
    cdef int pmaxAnsio
    _hipTexRefGetMaxAnisotropy__retval = hipError_t(chip.hipTexRefGetMaxAnisotropy(&pmaxAnsio,
        textureReference.fromPyobj(texRef).getElementPtr()))
    return (_hipTexRefGetMaxAnisotropy__retval,pmaxAnsio)


@cython.embedsignature(True)
def hipTexRefGetMipmapFilterMode(object texRef):
    r"""Gets the mipmap filter mode for a texture reference.

    Warning:
        This API is deprecated.

    Args:
        texRef (`~.textureReference`/`~.object`) -- *IN*:
            Pointer of texture reference.

    Returns:
        A `~.tuple` of size 2 that contains (in that order):

        * `~.hipError_t`: `~.hipErrorInvalidValue`, `~.hipErrorNotSupported`
        * `~.hipTextureFilterMode`:
                Pointer of the mipmap filter mode.
    """
    cdef chip.hipTextureFilterMode pfm
    _hipTexRefGetMipmapFilterMode__retval = hipError_t(chip.hipTexRefGetMipmapFilterMode(&pfm,
        textureReference.fromPyobj(texRef).getElementPtr()))
    return (_hipTexRefGetMipmapFilterMode__retval,hipTextureFilterMode(pfm))


@cython.embedsignature(True)
def hipTexRefGetMipmapLevelBias(object texRef):
    r"""Gets the mipmap level bias for a texture reference.

    Warning:
        This API is deprecated.

    Args:
        texRef (`~.textureReference`/`~.object`) -- *IN*:
            Pointer of texture reference.

    Returns:
        A `~.tuple` of size 2 that contains (in that order):

        * `~.hipError_t`: `~.hipErrorInvalidValue`, `~.hipErrorNotSupported`
        * `~.float`:
                Pointer of the mipmap level bias.
    """
    cdef float pbias
    _hipTexRefGetMipmapLevelBias__retval = hipError_t(chip.hipTexRefGetMipmapLevelBias(&pbias,
        textureReference.fromPyobj(texRef).getElementPtr()))
    return (_hipTexRefGetMipmapLevelBias__retval,pbias)


@cython.embedsignature(True)
def hipTexRefGetMipmapLevelClamp(object texRef):
    r"""Gets the minimum and maximum mipmap level clamps for a texture reference.

    Warning:
        This API is deprecated.

    Args:
        texRef (`~.textureReference`/`~.object`) -- *IN*:
            Pointer of texture reference.

    Returns:
        A `~.tuple` of size 3 that contains (in that order):

        * `~.hipError_t`: `~.hipErrorInvalidValue`, `~.hipErrorNotSupported`
        * `~.float`:
                Pointer of the minimum mipmap level clamp.
        * `~.float`:
                Pointer of the maximum mipmap level clamp.
    """
    cdef float pminMipmapLevelClamp
    cdef float pmaxMipmapLevelClamp
    _hipTexRefGetMipmapLevelClamp__retval = hipError_t(chip.hipTexRefGetMipmapLevelClamp(&pminMipmapLevelClamp,&pmaxMipmapLevelClamp,
        textureReference.fromPyobj(texRef).getElementPtr()))
    return (_hipTexRefGetMipmapLevelClamp__retval,pminMipmapLevelClamp,pmaxMipmapLevelClamp)


@cython.embedsignature(True)
def hipTexRefGetMipMappedArray(object texRef):
    r"""Gets the mipmapped array bound to a texture reference.

    Warning:
        This API is deprecated.

    Args:
        texRef (`~.textureReference`/`~.object`) -- *IN*:
            Pointer of texture reference.

    Returns:
        A `~.tuple` of size 2 that contains (in that order):

        * `~.hipError_t`: `~.hipSuccess`, `~.hipErrorInvalidValue`, `~.hipErrorNotSupported`
        * `~.hipMipmappedArray`:
                Pointer of the mipmapped array.
    """
    pArray = hipMipmappedArray.fromPtr(NULL)
    _hipTexRefGetMipMappedArray__retval = hipError_t(chip.hipTexRefGetMipMappedArray(<chip.hipMipmappedArray**>&pArray._ptr,
        textureReference.fromPyobj(texRef).getElementPtr()))
    return (_hipTexRefGetMipMappedArray__retval,None if pArray._ptr == NULL else pArray)


@cython.embedsignature(True)
def hipTexRefSetAddress(object texRef, object dptr, unsigned long bytes):
    r"""Sets an bound address for a texture reference.

    Warning:
        This API is deprecated.

    Args:
        texRef (`~.textureReference`/`~.object`) -- *IN*:
            Pointer of texture reference.

        dptr (`~.hip._util.types.Pointer`/`~.object`) -- *IN*:
            Pointer of device address to bind.

        bytes (`~.int`) -- *IN*:
            Size in bytes.

    Returns:
        A `~.tuple` of size 2 that contains (in that order):

        * `~.hipError_t`: `~.hipSuccess`, `~.hipErrorInvalidValue`
        * `~.int`:
                Pointer of the offset in bytes.
    """
    cdef unsigned long ByteOffset
    _hipTexRefSetAddress__retval = hipError_t(chip.hipTexRefSetAddress(&ByteOffset,
        textureReference.fromPyobj(texRef).getElementPtr(),
        <void *>hip._util.types.Pointer.fromPyobj(dptr)._ptr,bytes))
    return (_hipTexRefSetAddress__retval,ByteOffset)


@cython.embedsignature(True)
def hipTexRefSetAddress2D(object texRef, object desc, object dptr, unsigned long Pitch):
    r"""Set a bind an address as a 2D texture reference.

    Warning:
        This API is deprecated.

    Args:
        texRef (`~.textureReference`/`~.object`) -- *IN*:
            Pointer of texture reference.

        desc (`~.HIP_ARRAY_DESCRIPTOR`/`~.object`) -- *IN*:
            Pointer of array descriptor.

        dptr (`~.hip._util.types.Pointer`/`~.object`) -- *IN*:
            Pointer of device address to bind.

        Pitch (`~.int`) -- *IN*:
            Pitch in bytes.

    Returns:
        A `~.tuple` of size 1 that contains (in that order):

        * `~.hipError_t`: `~.hipSuccess`, `~.hipErrorInvalidValue`, `~.hipErrorNotSupported`
    """
    _hipTexRefSetAddress2D__retval = hipError_t(chip.hipTexRefSetAddress2D(
        textureReference.fromPyobj(texRef).getElementPtr(),
        HIP_ARRAY_DESCRIPTOR.fromPyobj(desc).getElementPtr(),
        <void *>hip._util.types.Pointer.fromPyobj(dptr)._ptr,Pitch))
    return (_hipTexRefSetAddress2D__retval,)


@cython.embedsignature(True)
def hipTexRefSetMaxAnisotropy(object texRef, unsigned int maxAniso):
    r"""Sets the maximum anisotropy for a texture reference.

    Warning:
        This API is deprecated.

    Args:
        texRef (`~.textureReference`/`~.object`) -- *IN*:
            Pointer of texture reference.

        maxAniso (`~.int`) -- *OUT*:
            Value of the maximum anisotropy.

    Returns:
        A `~.tuple` of size 1 that contains (in that order):

        * `~.hipError_t`: `~.hipSuccess`, `~.hipErrorInvalidValue`, `~.hipErrorNotSupported`
    """
    _hipTexRefSetMaxAnisotropy__retval = hipError_t(chip.hipTexRefSetMaxAnisotropy(
        textureReference.fromPyobj(texRef).getElementPtr(),maxAniso))
    return (_hipTexRefSetMaxAnisotropy__retval,)


@cython.embedsignature(True)
def hipTexRefSetBorderColor(object texRef):
    r"""Sets border color for a texture reference.

    Warning:
        This API is deprecated.

    Args:
        texRef (`~.textureReference`/`~.object`) -- *IN*:
            Pointer of texture reference.

    Returns:
        A `~.tuple` of size 2 that contains (in that order):

        * `~.hipError_t`: `~.hipSuccess`, `~.hipErrorInvalidValue`, `~.hipErrorNotSupported`
        * `~.float`:
                Pointer of border color.
    """
    cdef float pBorderColor
    _hipTexRefSetBorderColor__retval = hipError_t(chip.hipTexRefSetBorderColor(
        textureReference.fromPyobj(texRef).getElementPtr(),&pBorderColor))
    return (_hipTexRefSetBorderColor__retval,pBorderColor)


@cython.embedsignature(True)
def hipTexRefSetMipmapFilterMode(object texRef, object fm):
    r"""Sets mipmap filter mode for a texture reference.

    Warning:
        This API is deprecated.

    Args:
        texRef (`~.textureReference`/`~.object`) -- *IN*:
            Pointer of texture reference.

        fm (`~.hipTextureFilterMode`) -- *IN*:
            Value of filter mode.

    Returns:
        A `~.tuple` of size 1 that contains (in that order):

        * `~.hipError_t`: `~.hipSuccess`, `~.hipErrorInvalidValue`, `~.hipErrorNotSupported`
    """
    if not isinstance(fm,_hipTextureFilterMode__Base):
        raise TypeError("argument 'fm' must be of type '_hipTextureFilterMode__Base'")
    _hipTexRefSetMipmapFilterMode__retval = hipError_t(chip.hipTexRefSetMipmapFilterMode(
        textureReference.fromPyobj(texRef).getElementPtr(),fm.value))
    return (_hipTexRefSetMipmapFilterMode__retval,)


@cython.embedsignature(True)
def hipTexRefSetMipmapLevelBias(object texRef, float bias):
    r"""Sets mipmap level bias for a texture reference.

    Warning:
        This API is deprecated.

    Args:
        texRef (`~.textureReference`/`~.object`) -- *IN*:
            Pointer of texture reference.

        bias (`~.float`/`~.int`) -- *IN*:
            Value of mipmap bias.

    Returns:
        A `~.tuple` of size 1 that contains (in that order):

        * `~.hipError_t`: `~.hipSuccess`, `~.hipErrorInvalidValue`, `~.hipErrorNotSupported`
    """
    _hipTexRefSetMipmapLevelBias__retval = hipError_t(chip.hipTexRefSetMipmapLevelBias(
        textureReference.fromPyobj(texRef).getElementPtr(),bias))
    return (_hipTexRefSetMipmapLevelBias__retval,)


@cython.embedsignature(True)
def hipTexRefSetMipmapLevelClamp(object texRef, float minMipMapLevelClamp, float maxMipMapLevelClamp):
    r"""Sets mipmap level clamp for a texture reference.

    Warning:
        This API is deprecated.

    Args:
        texRef (`~.textureReference`/`~.object`) -- *IN*:
            Pointer of texture reference.

        minMipMapLevelClamp (`~.float`/`~.int`) -- *IN*:
            Value of minimum mipmap level clamp.

        maxMipMapLevelClamp (`~.float`/`~.int`) -- *IN*:
            Value of maximum mipmap level clamp.

    Returns:
        A `~.tuple` of size 1 that contains (in that order):

        * `~.hipError_t`: `~.hipSuccess`, `~.hipErrorInvalidValue`, `~.hipErrorNotSupported`
    """
    _hipTexRefSetMipmapLevelClamp__retval = hipError_t(chip.hipTexRefSetMipmapLevelClamp(
        textureReference.fromPyobj(texRef).getElementPtr(),minMipMapLevelClamp,maxMipMapLevelClamp))
    return (_hipTexRefSetMipmapLevelClamp__retval,)


@cython.embedsignature(True)
def hipTexRefSetMipmappedArray(object texRef, object mipmappedArray, unsigned int Flags):
    r"""Binds mipmapped array to a texture reference.

    Warning:
        This API is deprecated.

    Args:
        texRef (`~.textureReference`/`~.object`) -- *IN*:
            Pointer of texture reference to bind.

        mipmappedArray (`~.hipMipmappedArray`/`~.object`) -- *IN*:
            Pointer of mipmapped array to bind.

        Flags (`~.int`) -- *IN*:
            Flags should be set as HIP_TRSA_OVERRIDE_FORMAT, as a valid value.

    Returns:
        A `~.tuple` of size 1 that contains (in that order):

        * `~.hipError_t`: `~.hipSuccess`, `~.hipErrorInvalidValue`
    """
    _hipTexRefSetMipmappedArray__retval = hipError_t(chip.hipTexRefSetMipmappedArray(
        textureReference.fromPyobj(texRef).getElementPtr(),
        hipMipmappedArray.fromPyobj(mipmappedArray).getElementPtr(),Flags))
    return (_hipTexRefSetMipmappedArray__retval,)


@cython.embedsignature(True)
def hipApiName(unsigned int id):
    r"""Returns HIP API name by ID.

    This section describes the callback/Activity of HIP runtime API.

    Args:
        id (`~.int`) -- *IN*:
            ID of HIP API

    Returns:
        A `~.tuple` of size 2 that contains (in that order):

        * `~.hipError_t`:
                Always returns `~.hipError_t.hipSuccess`.
        * `~.bytes`: `~.hipSuccess`, `~.hipErrorInvalidValue`
    """
    _hipApiName__retval = hip._util.types.CStr.fromPtr(<void*>chip.hipApiName(id))
    return (hipError_t.hipSuccess,None if _hipApiName__retval._ptr == NULL else _hipApiName__retval)


@cython.embedsignature(True)
def hipKernelNameRef(object f):
    r"""Returns kernel name reference by function name.

    Args:
        f (`~.ihipModuleSymbol_t`/`~.object`) -- *IN*:
            Name of function

    Returns:
        A `~.tuple` of size 2 that contains (in that order):

        * `~.hipError_t`:
                Always returns `~.hipError_t.hipSuccess`.
        * `~.bytes`: `~.hipSuccess`, `~.hipErrorInvalidValue`
    """
    _hipKernelNameRef__retval = hip._util.types.CStr.fromPtr(<void*>chip.hipKernelNameRef(
        ihipModuleSymbol_t.fromPyobj(f).getElementPtr()))
    return (hipError_t.hipSuccess,None if _hipKernelNameRef__retval._ptr == NULL else _hipKernelNameRef__retval)


@cython.embedsignature(True)
def hipKernelNameRefByPtr(object hostFunction, object stream):
    r"""Retrives kernel for a given host pointer, unless stated otherwise.

    Args:
        hostFunction (`~.hip._util.types.Pointer`/`~.object`) -- *IN*:
            Pointer of host function.

        stream (`~.ihipStream_t`/`~.object`) -- *IN*:
            Stream the kernel is executed on.

    Returns:
        A `~.tuple` of size 2 that contains (in that order):

        * `~.hipError_t`:
                Always returns `~.hipError_t.hipSuccess`.
        * `~.bytes`: `~.hipSuccess`, `~.hipErrorInvalidValue`
    """
    _hipKernelNameRefByPtr__retval = hip._util.types.CStr.fromPtr(<void*>chip.hipKernelNameRefByPtr(
        <const void *>hip._util.types.Pointer.fromPyobj(hostFunction)._ptr,
        ihipStream_t.fromPyobj(stream).getElementPtr()))
    return (hipError_t.hipSuccess,None if _hipKernelNameRefByPtr__retval._ptr == NULL else _hipKernelNameRefByPtr__retval)


@cython.embedsignature(True)
def hipGetStreamDeviceId(object stream):
    r"""Returns device ID on the stream.

    Args:
        stream (`~.ihipStream_t`/`~.object`) -- *IN*:
            Stream of device executed on.

    Returns:
        A `~.tuple` of size 2 that contains (in that order):

        * `~.hipError_t`:
                Always returns `~.hipError_t.hipSuccess`.
        * `~.int`: `~.hipSuccess`, `~.hipErrorInvalidValue`
    """
    cdef int _hipGetStreamDeviceId__retval = chip.hipGetStreamDeviceId(
        ihipStream_t.fromPyobj(stream).getElementPtr())
    return (hipError_t.hipSuccess,_hipGetStreamDeviceId__retval)


@cython.embedsignature(True)
def hipStreamBeginCapture(object stream, object mode):
    r"""Begins graph capture on a stream.

    Warning:
        This API is marked as beta, meaning, while this is feature complete,
        it is still open to changes and may have outstanding issues.

    Args:
        stream (`~.ihipStream_t`/`~.object`) -- *IN*:
            - Stream to initiate capture.

        mode (`~.hipStreamCaptureMode`) -- *IN*:
            - Controls the interaction of this capture sequence with other API calls that
            are not safe.

    Returns:
        A `~.tuple` of size 1 that contains (in that order):

        * `~.hipError_t`: `~.hipSuccess`, `~.hipErrorInvalidValue`
    """
    if not isinstance(mode,_hipStreamCaptureMode__Base):
        raise TypeError("argument 'mode' must be of type '_hipStreamCaptureMode__Base'")
    _hipStreamBeginCapture__retval = hipError_t(chip.hipStreamBeginCapture(
        ihipStream_t.fromPyobj(stream).getElementPtr(),mode.value))
    return (_hipStreamBeginCapture__retval,)


@cython.embedsignature(True)
def hipStreamBeginCaptureToGraph(object stream, object graph, object dependencyData, unsigned long numDependencies, object mode):
    r"""Begins graph capture on a stream to an existing graph.

    Warning:
        param "const hipGraphEdgeData* dependencyData" is currently not supported and has to
        passed as nullptr. This API is marked as beta, meaning, while this is feature complete, it is still
        open to changes and may have outstanding issues.

    Args:
        stream (`~.ihipStream_t`/`~.object`) -- *IN*:
            - Stream to initiate capture.

        graph (`~.ihipGraph`/`~.object`) -- *IN*:
            - Graph to capture into.

        dependencyData (`~.hipGraphEdgeData`/`~.object`) -- *IN*:
            - Optional array of data associated with each dependency.

        numDependencies (`~.int`) -- *IN*:
            - Number of dependencies.

        mode (`~.hipStreamCaptureMode`) -- *IN*:
            - Controls the interaction of this capture sequence with other API calls that
            are not safe.

    Returns:
        A `~.tuple` of size 2 that contains (in that order):

        * `~.hipError_t`: `~.hipSuccess`, `~.hipErrorInvalidValue`
        * `~.hipGraphNode`:
                - Dependencies of the first node captured in the stream. Can be NULL if
                numDependencies is 0.
    """
    dependencies = hipGraphNode.fromPtr(NULL)
    if not isinstance(mode,_hipStreamCaptureMode__Base):
        raise TypeError("argument 'mode' must be of type '_hipStreamCaptureMode__Base'")
    _hipStreamBeginCaptureToGraph__retval = hipError_t(chip.hipStreamBeginCaptureToGraph(
        ihipStream_t.fromPyobj(stream).getElementPtr(),
        ihipGraph.fromPyobj(graph).getElementPtr(),<chip.hipGraphNode**>&dependencies._ptr,
        hipGraphEdgeData.fromPyobj(dependencyData).getElementPtr(),numDependencies,mode.value))
    return (_hipStreamBeginCaptureToGraph__retval,None if dependencies._ptr == NULL else dependencies)


@cython.embedsignature(True)
def hipStreamEndCapture(object stream):
    r"""Ends capture on a stream, returning the captured graph.

    Warning:
        This API is marked as beta, meaning, while this is feature complete,
        it is still open to changes and may have outstanding issues.

    Args:
        stream (`~.ihipStream_t`/`~.object`) -- *IN*:
            - Stream to end capture.

    Returns:
        A `~.tuple` of size 2 that contains (in that order):

        * `~.hipError_t`: `~.hipSuccess`, `~.hipErrorInvalidValue`
        * `~.ihipGraph`:
                - returns the graph captured.
    """
    pGraph = ihipGraph.fromPtr(NULL)
    _hipStreamEndCapture__retval = hipError_t(chip.hipStreamEndCapture(
        ihipStream_t.fromPyobj(stream).getElementPtr(),<chip.ihipGraph**>&pGraph._ptr))
    return (_hipStreamEndCapture__retval,None if pGraph._ptr == NULL else pGraph)


@cython.embedsignature(True)
def hipStreamGetCaptureInfo(object stream):
    r"""Get capture status of a stream.

    Warning:
        This API is marked as beta, meaning, while this is feature complete,
        it is still open to changes and may have outstanding issues.

    Args:
        stream (`~.ihipStream_t`/`~.object`) -- *IN*:
            - Stream under capture.

    Returns:
        A `~.tuple` of size 3 that contains (in that order):

        * `~.hipError_t`: `~.hipSuccess`, `~.hipErrorStreamCaptureImplicit`
        * `~.hipStreamCaptureStatus`:
                - returns current status of the capture.
        * `~.int`:
                - unique ID of the capture.
    """
    cdef chip.hipStreamCaptureStatus pCaptureStatus
    cdef unsigned long long pId
    _hipStreamGetCaptureInfo__retval = hipError_t(chip.hipStreamGetCaptureInfo(
        ihipStream_t.fromPyobj(stream).getElementPtr(),&pCaptureStatus,&pId))
    return (_hipStreamGetCaptureInfo__retval,hipStreamCaptureStatus(pCaptureStatus),pId)


@cython.embedsignature(True)
def hipStreamGetCaptureInfo_v2(object stream, object dependencies_out):
    r"""Get stream's capture state

    Warning:
        This API is marked as beta, meaning, while this is feature complete,
        it is still open to changes and may have outstanding issues.

    Args:
        stream (`~.ihipStream_t`/`~.object`) -- *IN*:
            - Stream under capture.

        dependencies_out (`~.hip._util.types.Pointer`/`~.object`) -- *OUT*:
            - returns pointer to an array of nodes.

    Returns:
        A `~.tuple` of size 5 that contains (in that order):

        * `~.hipError_t`: `~.hipSuccess`, `~.hipErrorInvalidValue`, `~.hipErrorStreamCaptureImplicit`
        * `~.hipStreamCaptureStatus`:
                - returns current status of the capture.
        * `~.int`:
                - unique ID of the capture.
        * `~.ihipGraph`:
                - returns the graph being captured into.
        * `~.int`:
                - returns size of the array returned in dependencies_out.
    """
    cdef chip.hipStreamCaptureStatus captureStatus_out
    cdef unsigned long long id_out
    graph_out = ihipGraph.fromPtr(NULL)
    cdef unsigned long numDependencies_out
    _hipStreamGetCaptureInfo_v2__retval = hipError_t(chip.hipStreamGetCaptureInfo_v2(
        ihipStream_t.fromPyobj(stream).getElementPtr(),&captureStatus_out,&id_out,<chip.ihipGraph**>&graph_out._ptr,
        <chip.hipGraphNode_t **>hip._util.types.Pointer.fromPyobj(dependencies_out)._ptr,&numDependencies_out))
    return (_hipStreamGetCaptureInfo_v2__retval,hipStreamCaptureStatus(captureStatus_out),id_out,None if graph_out._ptr == NULL else graph_out,numDependencies_out)


@cython.embedsignature(True)
def hipStreamIsCapturing(object stream):
    r"""Get stream's capture state

    Warning:
        This API is marked as beta, meaning, while this is feature complete,
        it is still open to changes and may have outstanding issues.

    Args:
        stream (`~.ihipStream_t`/`~.object`) -- *IN*:
            - Stream under capture.

    Returns:
        A `~.tuple` of size 2 that contains (in that order):

        * `~.hipError_t`: `~.hipSuccess`, `~.hipErrorInvalidValue`, `~.hipErrorStreamCaptureImplicit`
        * `~.hipStreamCaptureStatus`:
                - returns current status of the capture.
    """
    cdef chip.hipStreamCaptureStatus pCaptureStatus
    _hipStreamIsCapturing__retval = hipError_t(chip.hipStreamIsCapturing(
        ihipStream_t.fromPyobj(stream).getElementPtr(),&pCaptureStatus))
    return (_hipStreamIsCapturing__retval,hipStreamCaptureStatus(pCaptureStatus))


@cython.embedsignature(True)
def hipStreamUpdateCaptureDependencies(object stream, unsigned long numDependencies, unsigned int flags):
    r"""Update the set of dependencies in a capturing stream

    Warning:
        This API is marked as beta, meaning, while this is feature complete,
        it is still open to changes and may have outstanding issues.

    Args:
        stream (`~.ihipStream_t`/`~.object`) -- *IN*:
            Stream under capture.

        numDependencies (`~.int`) -- *IN*:
            size of the array in dependencies.

        flags (`~.int`) -- *IN*:
            Flag how to update dependency set. Should be one of value in enum
            `~.hipStreamUpdateCaptureDependenciesFlags`

    Returns:
        A `~.tuple` of size 2 that contains (in that order):

        * `~.hipError_t`: `~.hipSuccess`, `~.hipErrorInvalidValue`, `~.hipErrorIllegalState`
        * `~.hipGraphNode`:
                pointer to an array of nodes to Add/Replace.
    """
    dependencies = hipGraphNode.fromPtr(NULL)
    _hipStreamUpdateCaptureDependencies__retval = hipError_t(chip.hipStreamUpdateCaptureDependencies(
        ihipStream_t.fromPyobj(stream).getElementPtr(),<chip.hipGraphNode**>&dependencies._ptr,numDependencies,flags))
    return (_hipStreamUpdateCaptureDependencies__retval,None if dependencies._ptr == NULL else dependencies)


@cython.embedsignature(True)
def hipThreadExchangeStreamCaptureMode(object mode):
    r"""Swaps the stream capture mode of a thread.

    Warning:
        This API is marked as beta, meaning, while this is feature complete,
        it is still open to changes and may have outstanding issues.

    Args:
        mode (`~.hip._util.types.Pointer`/`~.object`) -- *IN*:
            - Pointer to mode value to swap with the current mode

    Returns:
        A `~.tuple` of size 1 that contains (in that order):

        * `~.hipError_t`: `~.hipSuccess`, `~.hipErrorInvalidValue`
    """
    _hipThreadExchangeStreamCaptureMode__retval = hipError_t(chip.hipThreadExchangeStreamCaptureMode(
        <chip.hipStreamCaptureMode *>hip._util.types.Pointer.fromPyobj(mode)._ptr))
    return (_hipThreadExchangeStreamCaptureMode__retval,)


@cython.embedsignature(True)
def hipGraphCreate(unsigned int flags):
    r"""Creates a graph

    Warning:
        This API is marked as beta, meaning, while this is feature complete,
        it is still open to changes and may have outstanding issues.

    Args:
        flags (`~.int`) -- *IN*:
            - flags for graph creation, must be 0.

    Returns:
        A `~.tuple` of size 2 that contains (in that order):

        * `~.hipError_t`: `~.hipSuccess`, `~.hipErrorInvalidValue`, `~.hipErrorMemoryAllocation`
        * `~.ihipGraph`:
                - pointer to graph to create.
    """
    pGraph = ihipGraph.fromPtr(NULL)
    _hipGraphCreate__retval = hipError_t(chip.hipGraphCreate(<chip.ihipGraph**>&pGraph._ptr,flags))
    return (_hipGraphCreate__retval,None if pGraph._ptr == NULL else pGraph)


@cython.embedsignature(True)
def hipGraphDestroy(object graph):
    r"""Destroys a graph

    Warning:
        This API is marked as beta, meaning, while this is feature complete,
        it is still open to changes and may have outstanding issues.

    Args:
        graph (`~.ihipGraph`/`~.object`) -- *IN*:
            - instance of graph to destroy.

    Returns:
        A `~.tuple` of size 1 that contains (in that order):

        * `~.hipError_t`: `~.hipSuccess`, `~.hipErrorInvalidValue`
    """
    _hipGraphDestroy__retval = hipError_t(chip.hipGraphDestroy(
        ihipGraph.fromPyobj(graph).getElementPtr()))
    return (_hipGraphDestroy__retval,)


@cython.embedsignature(True)
def hipGraphAddDependencies(object graph, unsigned long numDependencies):
    r"""Adds dependency edges to a graph.

    Warning:
        This API is marked as beta, meaning, while this is feature complete,
        it is still open to changes and may have outstanding issues.

    Args:
        graph (`~.ihipGraph`/`~.object`) -- *IN*:
            - instance of the graph to add dependencies.

        numDependencies (`~.int`) -- *IN*:
            - the number of dependencies to add.

    Returns:
        A `~.tuple` of size 3 that contains (in that order):

        * `~.hipError_t`: `~.hipSuccess`, `~.hipErrorInvalidValue`
        * `~.hipGraphNode`:
                - pointer to the graph nodes with dependenties to add from.
        * `~.hipGraphNode`:
                - pointer to the graph nodes to add dependenties to.
    """
    from_ = hipGraphNode.fromPtr(NULL)
    to = hipGraphNode.fromPtr(NULL)
    _hipGraphAddDependencies__retval = hipError_t(chip.hipGraphAddDependencies(
        ihipGraph.fromPyobj(graph).getElementPtr(),<chip.hipGraphNode**>&from_._ptr,<chip.hipGraphNode**>&to._ptr,numDependencies))
    return (_hipGraphAddDependencies__retval,None if from_._ptr == NULL else from_,None if to._ptr == NULL else to)


@cython.embedsignature(True)
def hipGraphRemoveDependencies(object graph, unsigned long numDependencies):
    r"""Removes dependency edges from a graph.

    Warning:
        This API is marked as beta, meaning, while this is feature complete,
        it is still open to changes and may have outstanding issues.

    Args:
        graph (`~.ihipGraph`/`~.object`) -- *IN*:
            - instance of the graph to remove dependencies.

        numDependencies (`~.int`) -- *IN*:
            - the number of dependencies to remove.

    Returns:
        A `~.tuple` of size 3 that contains (in that order):

        * `~.hipError_t`: `~.hipSuccess`, `~.hipErrorInvalidValue`
        * `~.hipGraphNode`:
                - Array of nodes that provide the dependencies.
        * `~.hipGraphNode`:
                - Array of dependent nodes.
    """
    from_ = hipGraphNode.fromPtr(NULL)
    to = hipGraphNode.fromPtr(NULL)
    _hipGraphRemoveDependencies__retval = hipError_t(chip.hipGraphRemoveDependencies(
        ihipGraph.fromPyobj(graph).getElementPtr(),<chip.hipGraphNode**>&from_._ptr,<chip.hipGraphNode**>&to._ptr,numDependencies))
    return (_hipGraphRemoveDependencies__retval,None if from_._ptr == NULL else from_,None if to._ptr == NULL else to)


@cython.embedsignature(True)
def hipGraphGetEdges(object graph):
    r"""Returns a graph's dependency edges.

    from and to may both be NULL, in which case this function only returns the number of edges in
    numEdges. Otherwise, numEdges entries will be filled in. If numEdges is higher than the actual
    number of edges, the remaining entries in from and to will be set to NULL, and the number of
    edges actually returned will be written to numEdges

    Warning:
        This API is marked as beta, meaning, while this is feature complete,
        it is still open to changes and may have outstanding issues.

    Args:
        graph (`~.ihipGraph`/`~.object`) -- *IN*:
            - instance of the graph to get the edges from.

    Returns:
        A `~.tuple` of size 4 that contains (in that order):

        * `~.hipError_t`: `~.hipSuccess`, `~.hipErrorInvalidValue`
        * `~.hipGraphNode`:
                - pointer to the graph nodes to return edge endpoints.
        * `~.hipGraphNode`:
                - pointer to the graph nodes to return edge endpoints.
        * `~.int`:
                - returns number of edges.
    """
    from_ = hipGraphNode.fromPtr(NULL)
    to = hipGraphNode.fromPtr(NULL)
    cdef unsigned long numEdges
    _hipGraphGetEdges__retval = hipError_t(chip.hipGraphGetEdges(
        ihipGraph.fromPyobj(graph).getElementPtr(),<chip.hipGraphNode**>&from_._ptr,<chip.hipGraphNode**>&to._ptr,&numEdges))
    return (_hipGraphGetEdges__retval,None if from_._ptr == NULL else from_,None if to._ptr == NULL else to,numEdges)


@cython.embedsignature(True)
def hipGraphGetNodes(object graph):
    r"""Returns graph nodes.

    nodes may be NULL, in which case this function will return the number of nodes in numNodes.
    Otherwise, numNodes entries will be filled in. If numNodes is higher than the actual number of
    nodes, the remaining entries in nodes will be set to NULL, and the number of nodes actually
    obtained will be returned in numNodes.

    Warning:
        This API is marked as beta, meaning, while this is feature complete,
        it is still open to changes and may have outstanding issues.

    Args:
        graph (`~.ihipGraph`/`~.object`) -- *IN*:
            - instance of graph to get the nodes.

    Returns:
        A `~.tuple` of size 3 that contains (in that order):

        * `~.hipError_t`: `~.hipSuccess`, `~.hipErrorInvalidValue`
        * `~.hipGraphNode`:
                - pointer to return the  graph nodes.
        * `~.int`:
                - returns number of graph nodes.
    """
    nodes = hipGraphNode.fromPtr(NULL)
    cdef unsigned long numNodes
    _hipGraphGetNodes__retval = hipError_t(chip.hipGraphGetNodes(
        ihipGraph.fromPyobj(graph).getElementPtr(),<chip.hipGraphNode**>&nodes._ptr,&numNodes))
    return (_hipGraphGetNodes__retval,None if nodes._ptr == NULL else nodes,numNodes)


@cython.embedsignature(True)
def hipGraphGetRootNodes(object graph):
    r"""Returns graph's root nodes.

    pRootNodes may be NULL, in which case this function will return the number of root nodes in
    pNumRootNodes. Otherwise, pNumRootNodes entries will be filled in. If pNumRootNodes is higher
    than the actual number of root nodes, the remaining entries in pRootNodes will be set to NULL,
    and the number of nodes actually obtained will be returned in pNumRootNodes.

    Warning:
        This API is marked as beta, meaning, while this is feature complete,
        it is still open to changes and may have outstanding issues.

    Args:
        graph (`~.ihipGraph`/`~.object`) -- *IN*:
            - instance of the graph to get the nodes.

    Returns:
        A `~.tuple` of size 3 that contains (in that order):

        * `~.hipError_t`: `~.hipSuccess`, `~.hipErrorInvalidValue`
        * `~.hipGraphNode`:
                - pointer to return the graph's root nodes.
        * `~.int`:
                - returns the number of graph's root nodes.
    """
    pRootNodes = hipGraphNode.fromPtr(NULL)
    cdef unsigned long pNumRootNodes
    _hipGraphGetRootNodes__retval = hipError_t(chip.hipGraphGetRootNodes(
        ihipGraph.fromPyobj(graph).getElementPtr(),<chip.hipGraphNode**>&pRootNodes._ptr,&pNumRootNodes))
    return (_hipGraphGetRootNodes__retval,None if pRootNodes._ptr == NULL else pRootNodes,pNumRootNodes)


@cython.embedsignature(True)
def hipGraphNodeGetDependencies(object node):
    r"""Returns a node's dependencies.

    pDependencies may be NULL, in which case this function will return the number of dependencies in
    pNumDependencies. Otherwise, pNumDependencies entries will be filled in. If pNumDependencies is
    higher than the actual number of dependencies, the remaining entries in pDependencies will be set
    to NULL, and the number of nodes actually obtained will be returned in pNumDependencies.

    Warning:
        This API is marked as beta, meaning, while this is feature complete,
        it is still open to changes and may have outstanding issues.

    Args:
        node (`~.hipGraphNode`/`~.object`) -- *IN*:
            - graph node to get the dependencies from.

    Returns:
        A `~.tuple` of size 3 that contains (in that order):

        * `~.hipError_t`: `~.hipSuccess`, `~.hipErrorInvalidValue`
        * `~.hipGraphNode`:
                - pointer to to return the dependencies.
        * `~.int`:
                -  returns the number of graph node dependencies.
    """
    pDependencies = hipGraphNode.fromPtr(NULL)
    cdef unsigned long pNumDependencies
    _hipGraphNodeGetDependencies__retval = hipError_t(chip.hipGraphNodeGetDependencies(
        hipGraphNode.fromPyobj(node).getElementPtr(),<chip.hipGraphNode**>&pDependencies._ptr,&pNumDependencies))
    return (_hipGraphNodeGetDependencies__retval,None if pDependencies._ptr == NULL else pDependencies,pNumDependencies)


@cython.embedsignature(True)
def hipGraphNodeGetDependentNodes(object node):
    r"""Returns a node's dependent nodes.

    DependentNodes may be NULL, in which case this function will return the number of dependent nodes
    in pNumDependentNodes. Otherwise, pNumDependentNodes entries will be filled in. If
    pNumDependentNodes is higher than the actual number of dependent nodes, the remaining entries in
    pDependentNodes will be set to NULL, and the number of nodes actually obtained will be returned
    in pNumDependentNodes.

    Warning:
        This API is marked as beta, meaning, while this is feature complete,
        it is still open to changes and may have outstanding issues.

    Args:
        node (`~.hipGraphNode`/`~.object`) -- *IN*:
            - graph node to get the Dependent nodes from.

    Returns:
        A `~.tuple` of size 3 that contains (in that order):

        * `~.hipError_t`: `~.hipSuccess`, `~.hipErrorInvalidValue`
        * `~.hipGraphNode`:
                - pointer to return the graph dependent nodes.
        * `~.int`:
                - returns the number of graph node dependent nodes.
    """
    pDependentNodes = hipGraphNode.fromPtr(NULL)
    cdef unsigned long pNumDependentNodes
    _hipGraphNodeGetDependentNodes__retval = hipError_t(chip.hipGraphNodeGetDependentNodes(
        hipGraphNode.fromPyobj(node).getElementPtr(),<chip.hipGraphNode**>&pDependentNodes._ptr,&pNumDependentNodes))
    return (_hipGraphNodeGetDependentNodes__retval,None if pDependentNodes._ptr == NULL else pDependentNodes,pNumDependentNodes)


@cython.embedsignature(True)
def hipGraphNodeGetType(object node):
    r"""Returns a node's type.

    Warning:
        This API is marked as beta, meaning, while this is feature complete,
        it is still open to changes and may have outstanding issues.

    Args:
        node (`~.hipGraphNode`/`~.object`) -- *IN*:
            - instance of the graph to add dependencies.

    Returns:
        A `~.tuple` of size 2 that contains (in that order):

        * `~.hipError_t`: `~.hipSuccess`, `~.hipErrorInvalidValue`
        * `~.hipGraphNodeType`:
                - pointer to the return the type
    """
    cdef chip.hipGraphNodeType pType
    _hipGraphNodeGetType__retval = hipError_t(chip.hipGraphNodeGetType(
        hipGraphNode.fromPyobj(node).getElementPtr(),&pType))
    return (_hipGraphNodeGetType__retval,hipGraphNodeType(pType))


@cython.embedsignature(True)
def hipGraphDestroyNode(object node):
    r"""Remove a node from the graph.

    Warning:
        This API is marked as beta, meaning, while this is feature complete,
        it is still open to changes and may have outstanding issues.

    Args:
        node (`~.hipGraphNode`/`~.object`) -- *IN*:
            - graph node to remove

    Returns:
        A `~.tuple` of size 1 that contains (in that order):

        * `~.hipError_t`: `~.hipSuccess`, `~.hipErrorInvalidValue`
    """
    _hipGraphDestroyNode__retval = hipError_t(chip.hipGraphDestroyNode(
        hipGraphNode.fromPyobj(node).getElementPtr()))
    return (_hipGraphDestroyNode__retval,)


@cython.embedsignature(True)
def hipGraphClone(object originalGraph):
    r"""Clones a graph.

    Warning:
        This API is marked as beta, meaning, while this is feature complete,
        it is still open to changes and may have outstanding issues.

    Args:
        originalGraph (`~.ihipGraph`/`~.object`) -- *IN*:
            - original graph to clone from.

    Returns:
        A `~.tuple` of size 2 that contains (in that order):

        * `~.hipError_t`: `~.hipSuccess`, `~.hipErrorInvalidValue`, `~.hipErrorMemoryAllocation`
        * `~.ihipGraph`:
                - Returns newly created cloned graph.
    """
    pGraphClone = ihipGraph.fromPtr(NULL)
    _hipGraphClone__retval = hipError_t(chip.hipGraphClone(<chip.ihipGraph**>&pGraphClone._ptr,
        ihipGraph.fromPyobj(originalGraph).getElementPtr()))
    return (_hipGraphClone__retval,None if pGraphClone._ptr == NULL else pGraphClone)


@cython.embedsignature(True)
def hipGraphNodeFindInClone(object originalNode, object clonedGraph):
    r"""Finds a cloned version of a node.

    Warning:
        This API is marked as beta, meaning, while this is feature complete,
        it is still open to changes and may have outstanding issues.

    Args:
        originalNode (`~.hipGraphNode`/`~.object`) -- *IN*:
            - original node handle.

        clonedGraph (`~.ihipGraph`/`~.object`) -- *IN*:
            - Cloned graph to query.

    Returns:
        A `~.tuple` of size 2 that contains (in that order):

        * `~.hipError_t`: `~.hipSuccess`, `~.hipErrorInvalidValue`
        * `~.hipGraphNode`:
                - Returns the cloned node.
    """
    pNode = hipGraphNode.fromPtr(NULL)
    _hipGraphNodeFindInClone__retval = hipError_t(chip.hipGraphNodeFindInClone(<chip.hipGraphNode**>&pNode._ptr,
        hipGraphNode.fromPyobj(originalNode).getElementPtr(),
        ihipGraph.fromPyobj(clonedGraph).getElementPtr()))
    return (_hipGraphNodeFindInClone__retval,None if pNode._ptr == NULL else pNode)


@cython.embedsignature(True)
def hipGraphInstantiate(object graph, object pLogBuffer, unsigned long bufferSize):
    r"""Creates an executable graph from a graph

    Warning:
        This API is marked as beta, meaning, while this is feature complete,
        it is still open to changes and may have outstanding issues.

    Args:
        graph (`~.ihipGraph`/`~.object`) -- *IN*:
            - instance of graph to instantiate.

        pLogBuffer (`~.hip._util.types.CStr`/`~.object`) -- *OUT*:
            - pointer to log buffer.

        bufferSize (`~.int`) -- *OUT*:
            - the size of log buffer.

    Returns:
        A `~.tuple` of size 3 that contains (in that order):

        * `~.hipError_t`: `~.hipSuccess`, `~.hipErrorOutOfMemory`
        * `~.hipGraphExec`:
                - pointer to instantiated executable graph that is created.
        * `~.hipGraphNode`:
                - pointer to error node in case error occured in graph instantiation,
                it could modify the correponding node.
    """
    pGraphExec = hipGraphExec.fromPtr(NULL)
    pErrorNode = hipGraphNode.fromPtr(NULL)
    _hipGraphInstantiate__retval = hipError_t(chip.hipGraphInstantiate(<chip.hipGraphExec**>&pGraphExec._ptr,
        ihipGraph.fromPyobj(graph).getElementPtr(),<chip.hipGraphNode**>&pErrorNode._ptr,
        <char *>hip._util.types.CStr.fromPyobj(pLogBuffer)._ptr,bufferSize))
    return (_hipGraphInstantiate__retval,None if pGraphExec._ptr == NULL else pGraphExec,None if pErrorNode._ptr == NULL else pErrorNode)


@cython.embedsignature(True)
def hipGraphInstantiateWithFlags(object graph, unsigned long long flags):
    r"""Creates an executable graph from a graph.

    Warning:
        This API is marked as beta, meaning, while this is feature complete,
        it is still open to changes and may have outstanding issues.It does not support
        any of flag and is behaving as hipGraphInstantiate.

    Args:
        graph (`~.ihipGraph`/`~.object`) -- *IN*:
            - instance of graph to instantiate.

        flags (`~.int`) -- *IN*:
            - Flags to control instantiation.

    Returns:
        A `~.tuple` of size 2 that contains (in that order):

        * `~.hipError_t`: `~.hipSuccess`, `~.hipErrorInvalidValue`
        * `~.hipGraphExec`:
                - pointer to instantiated executable graph that is created.
    """
    pGraphExec = hipGraphExec.fromPtr(NULL)
    _hipGraphInstantiateWithFlags__retval = hipError_t(chip.hipGraphInstantiateWithFlags(<chip.hipGraphExec**>&pGraphExec._ptr,
        ihipGraph.fromPyobj(graph).getElementPtr(),flags))
    return (_hipGraphInstantiateWithFlags__retval,None if pGraphExec._ptr == NULL else pGraphExec)


@cython.embedsignature(True)
def hipGraphInstantiateWithParams(object graph, object instantiateParams):
    r"""Creates an executable graph from a graph.

    Warning:
        This API is marked as beta, meaning, while this is feature complete,
        it is still open to changes and may have outstanding issues.

    Args:
        graph (`~.ihipGraph`/`~.object`) -- *IN*:
            - instance of graph to instantiate.

        instantiateParams (`~.hipGraphInstantiateParams`/`~.object`) -- *IN*:
            - Graph Instantiate Params

    Returns:
        A `~.tuple` of size 2 that contains (in that order):

        * `~.hipError_t`: `~.hipSuccess`, `~.hipErrorInvalidValue`
        * `~.hipGraphExec`:
                - pointer to instantiated executable graph that is created.
    """
    pGraphExec = hipGraphExec.fromPtr(NULL)
    _hipGraphInstantiateWithParams__retval = hipError_t(chip.hipGraphInstantiateWithParams(<chip.hipGraphExec**>&pGraphExec._ptr,
        ihipGraph.fromPyobj(graph).getElementPtr(),
        hipGraphInstantiateParams.fromPyobj(instantiateParams).getElementPtr()))
    return (_hipGraphInstantiateWithParams__retval,None if pGraphExec._ptr == NULL else pGraphExec)


@cython.embedsignature(True)
def hipGraphLaunch(object graphExec, object stream):
    r"""launches an executable graph in a stream

    Warning:
        This API is marked as beta, meaning, while this is feature complete,
        it is still open to changes and may have outstanding issues.

    Args:
        graphExec (`~.hipGraphExec`/`~.object`) -- *IN*:
            - instance of executable graph to launch.

        stream (`~.ihipStream_t`/`~.object`) -- *IN*:
            - instance of stream in which to launch executable graph.

    Returns:
        A `~.tuple` of size 1 that contains (in that order):

        * `~.hipError_t`: `~.hipSuccess`, `~.hipErrorInvalidValue`
    """
    _hipGraphLaunch__retval = hipError_t(chip.hipGraphLaunch(
        hipGraphExec.fromPyobj(graphExec).getElementPtr(),
        ihipStream_t.fromPyobj(stream).getElementPtr()))
    return (_hipGraphLaunch__retval,)


@cython.embedsignature(True)
def hipGraphUpload(object graphExec, object stream):
    r"""uploads an executable graph in a stream

    Warning:
        This API is marked as beta, meaning, while this is feature complete,
        it is still open to changes and may have outstanding issues.

    Args:
        graphExec (`~.hipGraphExec`/`~.object`) -- *IN*:
            - instance of executable graph to launch.

        stream (`~.ihipStream_t`/`~.object`) -- *IN*:
            - instance of stream in which to launch executable graph.

    Returns:
        A `~.tuple` of size 1 that contains (in that order):

        * `~.hipError_t`: `~.hipSuccess`, `~.hipErrorInvalidValue`
    """
    _hipGraphUpload__retval = hipError_t(chip.hipGraphUpload(
        hipGraphExec.fromPyobj(graphExec).getElementPtr(),
        ihipStream_t.fromPyobj(stream).getElementPtr()))
    return (_hipGraphUpload__retval,)


@cython.embedsignature(True)
def hipGraphAddNode(object graph, unsigned long numDependencies, object nodeParams):
    r"""Creates a kernel execution node and adds it to a graph.

    Warning:
        This API is marked as beta, meaning, while this is feature complete,
        it is still open to changes and may have outstanding issues.

    Args:
        graph (`~.ihipGraph`/`~.object`) -- *IN*:
            - instance of graph to add the created node.

        numDependencies (`~.int`) -- *IN*:
            - the number of the dependencies.

        nodeParams (`~.hipGraphNodeParams`/`~.object`) -- *IN*:
            - pointer to the parameters for the node.

    Returns:
        A `~.tuple` of size 3 that contains (in that order):

        * `~.hipError_t`: `~.hipSuccess`, `~.hipErrorInvalidValue`.
        * `~.hipGraphNode`:
                - pointer to graph node to create.
        * `~.hipGraphNode`:
                - pointer to the dependencies on the kernel execution node.
    """
    pGraphNode = hipGraphNode.fromPtr(NULL)
    pDependencies = hipGraphNode.fromPtr(NULL)
    _hipGraphAddNode__retval = hipError_t(chip.hipGraphAddNode(<chip.hipGraphNode**>&pGraphNode._ptr,
        ihipGraph.fromPyobj(graph).getElementPtr(),<chip.hipGraphNode**>&pDependencies._ptr,numDependencies,
        hipGraphNodeParams.fromPyobj(nodeParams).getElementPtr()))
    return (_hipGraphAddNode__retval,None if pGraphNode._ptr == NULL else pGraphNode,None if pDependencies._ptr == NULL else pDependencies)


@cython.embedsignature(True)
def hipGraphExecDestroy(object graphExec):
    r"""Destroys an executable graph

    Warning:
        This API is marked as beta, meaning, while this is feature complete,
        it is still open to changes and may have outstanding issues.

    Args:
        graphExec (`~.hipGraphExec`/`~.object`) -- *IN*:
            - instance of executable graph to destry.

    Returns:
        A `~.tuple` of size 1 that contains (in that order):

        * `~.hipError_t`: `~.hipSuccess`.
    """
    _hipGraphExecDestroy__retval = hipError_t(chip.hipGraphExecDestroy(
        hipGraphExec.fromPyobj(graphExec).getElementPtr()))
    return (_hipGraphExecDestroy__retval,)


@cython.embedsignature(True)
def hipGraphExecUpdate(object hGraphExec, object hGraph):
    r"""Check whether an executable graph can be updated with a graph and perform the update if  *
    possible.

    Warning:
        This API is marked as beta, meaning, while this is feature complete,
        it is still open to changes and may have outstanding issues.

    Args:
        hGraphExec (`~.hipGraphExec`/`~.object`) -- *IN*:
            - instance of executable graph to update.

        hGraph (`~.ihipGraph`/`~.object`) -- *IN*:
            - graph that contains the updated parameters.

    Returns:
        A `~.tuple` of size 3 that contains (in that order):

        * `~.hipError_t`: `~.hipSuccess`, `~.hipErrorGraphExecUpdateFailure`
        * `~.hipGraphNode`:
                -  node which caused the permissibility check to forbid the update.
        * `~.hipGraphExecUpdateResult`:
                - Whether the graph update was permitted.
    """
    hErrorNode_out = hipGraphNode.fromPtr(NULL)
    cdef chip.hipGraphExecUpdateResult updateResult_out
    _hipGraphExecUpdate__retval = hipError_t(chip.hipGraphExecUpdate(
        hipGraphExec.fromPyobj(hGraphExec).getElementPtr(),
        ihipGraph.fromPyobj(hGraph).getElementPtr(),<chip.hipGraphNode**>&hErrorNode_out._ptr,&updateResult_out))
    return (_hipGraphExecUpdate__retval,None if hErrorNode_out._ptr == NULL else hErrorNode_out,hipGraphExecUpdateResult(updateResult_out))


@cython.embedsignature(True)
def hipGraphAddKernelNode(object graph, unsigned long numDependencies, object pNodeParams):
    r"""Creates a kernel execution node and adds it to a graph.

    Warning:
        This API is marked as beta, meaning, while this is feature complete,
        it is still open to changes and may have outstanding issues.

    Args:
        graph (`~.ihipGraph`/`~.object`) -- *IN*:
            - instance of graph to add the created node.

        numDependencies (`~.int`) -- *IN*:
            - the number of the dependencies.

        pNodeParams (`~.hipKernelNodeParams`/`~.object`) -- *IN*:
            - pointer to the parameters to the kernel execution node on the GPU.

    Returns:
        A `~.tuple` of size 3 that contains (in that order):

        * `~.hipError_t`: `~.hipSuccess`, `~.hipErrorInvalidValue`, `~.hipErrorInvalidDeviceFunction`
        * `~.hipGraphNode`:
                - pointer to graph node to create.
        * `~.hipGraphNode`:
                - pointer to the dependencies on the kernel execution node.
    """
    pGraphNode = hipGraphNode.fromPtr(NULL)
    pDependencies = hipGraphNode.fromPtr(NULL)
    _hipGraphAddKernelNode__retval = hipError_t(chip.hipGraphAddKernelNode(<chip.hipGraphNode**>&pGraphNode._ptr,
        ihipGraph.fromPyobj(graph).getElementPtr(),<chip.hipGraphNode**>&pDependencies._ptr,numDependencies,
        hipKernelNodeParams.fromPyobj(pNodeParams).getElementPtr()))
    return (_hipGraphAddKernelNode__retval,None if pGraphNode._ptr == NULL else pGraphNode,None if pDependencies._ptr == NULL else pDependencies)


@cython.embedsignature(True)
def hipGraphKernelNodeGetParams(object node, object pNodeParams):
    r"""Gets kernel node's parameters.

    Warning:
        This API is marked as beta, meaning, while this is feature complete,
        it is still open to changes and may have outstanding issues.

    Args:
        node (`~.hipGraphNode`/`~.object`) -- *IN*:
            - instance of the node to get parameters from.

        pNodeParams (`~.hipKernelNodeParams`/`~.object`) -- *OUT*:
            - pointer to the parameters

    Returns:
        A `~.tuple` of size 1 that contains (in that order):

        * `~.hipError_t`: `~.hipSuccess`, `~.hipErrorInvalidValue`
    """
    _hipGraphKernelNodeGetParams__retval = hipError_t(chip.hipGraphKernelNodeGetParams(
        hipGraphNode.fromPyobj(node).getElementPtr(),
        hipKernelNodeParams.fromPyobj(pNodeParams).getElementPtr()))
    return (_hipGraphKernelNodeGetParams__retval,)


@cython.embedsignature(True)
def hipGraphKernelNodeSetParams(object node, object pNodeParams):
    r"""Sets a kernel node's parameters.

    Warning:
        This API is marked as beta, meaning, while this is feature complete,
        it is still open to changes and may have outstanding issues.

    Args:
        node (`~.hipGraphNode`/`~.object`) -- *IN*:
            - instance of the node to set parameters to.

        pNodeParams (`~.hipKernelNodeParams`/`~.object`) -- *IN*:
            - const pointer to the parameters.

    Returns:
        A `~.tuple` of size 1 that contains (in that order):

        * `~.hipError_t`: `~.hipSuccess`, `~.hipErrorInvalidValue`
    """
    _hipGraphKernelNodeSetParams__retval = hipError_t(chip.hipGraphKernelNodeSetParams(
        hipGraphNode.fromPyobj(node).getElementPtr(),
        hipKernelNodeParams.fromPyobj(pNodeParams).getElementPtr()))
    return (_hipGraphKernelNodeSetParams__retval,)


@cython.embedsignature(True)
def hipGraphExecKernelNodeSetParams(object hGraphExec, object node, object pNodeParams):
    r"""Sets the parameters for a kernel node in the given graphExec.

    Warning:
        This API is marked as beta, meaning, while this is feature complete,
        it is still open to changes and may have outstanding issues.

    Args:
        hGraphExec (`~.hipGraphExec`/`~.object`) -- *IN*:
            - instance of the executable graph with the node.

        node (`~.hipGraphNode`/`~.object`) -- *IN*:
            - instance of the node to set parameters to.

        pNodeParams (`~.hipKernelNodeParams`/`~.object`) -- *IN*:
            - const pointer to the kernel node parameters.

    Returns:
        A `~.tuple` of size 1 that contains (in that order):

        * `~.hipError_t`: `~.hipSuccess`, `~.hipErrorInvalidValue`
    """
    _hipGraphExecKernelNodeSetParams__retval = hipError_t(chip.hipGraphExecKernelNodeSetParams(
        hipGraphExec.fromPyobj(hGraphExec).getElementPtr(),
        hipGraphNode.fromPyobj(node).getElementPtr(),
        hipKernelNodeParams.fromPyobj(pNodeParams).getElementPtr()))
    return (_hipGraphExecKernelNodeSetParams__retval,)


@cython.embedsignature(True)
def hipDrvGraphAddMemcpyNode(object hGraph, unsigned long numDependencies, object copyParams, object ctx):
    r"""Creates a memcpy node and adds it to a graph.

    Warning:
        This API is marked as beta, meaning, while this is feature complete,
        it is still open to changes and may have outstanding issues.

    Args:
        hGraph (`~.ihipGraph`/`~.object`) -- *IN*:
            - instance of graph to add the created node.

        numDependencies (`~.int`) -- *IN*:
            - the number of the dependencies.

        copyParams (`~.HIP_MEMCPY3D`/`~.object`) -- *IN*:
            - const pointer to the parameters for the memory copy.

        ctx (`~.ihipCtx_t`/`~.object`) -- *IN*:
            - cotext related to current device.

    Returns:
        A `~.tuple` of size 3 that contains (in that order):

        * `~.hipError_t`: `~.hipSuccess`, `~.hipErrorInvalidValue`
        * `~.hipGraphNode`:
                - pointer to graph node to create.
        * `~.hipGraphNode`:
                - const pointer to the dependencies on the memcpy execution node.
    """
    phGraphNode = hipGraphNode.fromPtr(NULL)
    dependencies = hipGraphNode.fromPtr(NULL)
    _hipDrvGraphAddMemcpyNode__retval = hipError_t(chip.hipDrvGraphAddMemcpyNode(<chip.hipGraphNode**>&phGraphNode._ptr,
        ihipGraph.fromPyobj(hGraph).getElementPtr(),<chip.hipGraphNode**>&dependencies._ptr,numDependencies,
        HIP_MEMCPY3D.fromPyobj(copyParams).getElementPtr(),
        ihipCtx_t.fromPyobj(ctx).getElementPtr()))
    return (_hipDrvGraphAddMemcpyNode__retval,None if phGraphNode._ptr == NULL else phGraphNode,None if dependencies._ptr == NULL else dependencies)


@cython.embedsignature(True)
def hipGraphAddMemcpyNode(object graph, unsigned long numDependencies, object pCopyParams):
    r"""Creates a memcpy node and adds it to a graph.

    Warning:
        This API is marked as beta, meaning, while this is feature complete,
        it is still open to changes and may have outstanding issues.

    Args:
        graph (`~.ihipGraph`/`~.object`) -- *IN*:
            - instance of graph to add the created node.

        numDependencies (`~.int`) -- *IN*:
            - the number of the dependencies.

        pCopyParams (`~.hipMemcpy3DParms`/`~.object`) -- *IN*:
            - const pointer to the parameters for the memory copy.

    Returns:
        A `~.tuple` of size 3 that contains (in that order):

        * `~.hipError_t`: `~.hipSuccess`, `~.hipErrorInvalidValue`
        * `~.hipGraphNode`:
                - pointer to graph node to create.
        * `~.hipGraphNode`:
                - const pointer to the dependencies on the memcpy execution node.
    """
    pGraphNode = hipGraphNode.fromPtr(NULL)
    pDependencies = hipGraphNode.fromPtr(NULL)
    _hipGraphAddMemcpyNode__retval = hipError_t(chip.hipGraphAddMemcpyNode(<chip.hipGraphNode**>&pGraphNode._ptr,
        ihipGraph.fromPyobj(graph).getElementPtr(),<chip.hipGraphNode**>&pDependencies._ptr,numDependencies,
        hipMemcpy3DParms.fromPyobj(pCopyParams).getElementPtr()))
    return (_hipGraphAddMemcpyNode__retval,None if pGraphNode._ptr == NULL else pGraphNode,None if pDependencies._ptr == NULL else pDependencies)


@cython.embedsignature(True)
def hipGraphMemcpyNodeGetParams(object node, object pNodeParams):
    r"""Gets a memcpy node's parameters.

    Warning:
        This API is marked as beta, meaning, while this is feature complete,
        it is still open to changes and may have outstanding issues.

    Args:
        node (`~.hipGraphNode`/`~.object`) -- *IN*:
            - instance of the node to get parameters from.

        pNodeParams (`~.hipMemcpy3DParms`/`~.object`) -- *OUT*:
            - pointer to the parameters.

    Returns:
        A `~.tuple` of size 1 that contains (in that order):

        * `~.hipError_t`: `~.hipSuccess`, `~.hipErrorInvalidValue`
    """
    _hipGraphMemcpyNodeGetParams__retval = hipError_t(chip.hipGraphMemcpyNodeGetParams(
        hipGraphNode.fromPyobj(node).getElementPtr(),
        hipMemcpy3DParms.fromPyobj(pNodeParams).getElementPtr()))
    return (_hipGraphMemcpyNodeGetParams__retval,)


@cython.embedsignature(True)
def hipGraphMemcpyNodeSetParams(object node, object pNodeParams):
    r"""Sets a memcpy node's parameters.

    Warning:
        This API is marked as beta, meaning, while this is feature complete,
        it is still open to changes and may have outstanding issues.

    Args:
        node (`~.hipGraphNode`/`~.object`) -- *IN*:
            - instance of the node to set parameters to.

        pNodeParams (`~.hipMemcpy3DParms`/`~.object`) -- *IN*:
            - const pointer to the parameters.

    Returns:
        A `~.tuple` of size 1 that contains (in that order):

        * `~.hipError_t`: `~.hipSuccess`, `~.hipErrorInvalidValue`
    """
    _hipGraphMemcpyNodeSetParams__retval = hipError_t(chip.hipGraphMemcpyNodeSetParams(
        hipGraphNode.fromPyobj(node).getElementPtr(),
        hipMemcpy3DParms.fromPyobj(pNodeParams).getElementPtr()))
    return (_hipGraphMemcpyNodeSetParams__retval,)


@cython.embedsignature(True)
def hipGraphKernelNodeSetAttribute(object hNode, object attr, object value):
    r"""Sets a node attribute.

    Warning:
        This API is marked as beta, meaning, while this is feature complete,
        it is still open to changes and may have outstanding issues.

    Args:
        hNode (`~.hipGraphNode`/`~.object`) -- *IN*:
            - instance of the node to set parameters to.

        attr (`~.hipLaunchAttributeID`) -- *IN*:
            - the attribute node is set to.

        value (`~.hipLaunchAttributeValue`/`~.object`) -- *IN*:
            - const pointer to the parameters.

    Returns:
        A `~.tuple` of size 1 that contains (in that order):

        * `~.hipError_t`: `~.hipSuccess`, `~.hipErrorInvalidValue`
    """
    if not isinstance(attr,_hipLaunchAttributeID__Base):
        raise TypeError("argument 'attr' must be of type '_hipLaunchAttributeID__Base'")
    _hipGraphKernelNodeSetAttribute__retval = hipError_t(chip.hipGraphKernelNodeSetAttribute(
        hipGraphNode.fromPyobj(hNode).getElementPtr(),attr.value,
        hipLaunchAttributeValue.fromPyobj(value).getElementPtr()))
    return (_hipGraphKernelNodeSetAttribute__retval,)


@cython.embedsignature(True)
def hipGraphKernelNodeGetAttribute(object hNode, object attr, object value):
    r"""Gets a node attribute.

    Warning:
        This API is marked as beta, meaning, while this is feature complete,
        it is still open to changes and may have outstanding issues.

    Args:
        hNode (`~.hipGraphNode`/`~.object`) -- *IN*:
            - instance of the node to set parameters to.

        attr (`~.hipLaunchAttributeID`) -- *IN*:
            - the attribute node is set to.

        value (`~.hipLaunchAttributeValue`/`~.object`) -- *IN*:
            - const pointer to the parameters.

    Returns:
        A `~.tuple` of size 1 that contains (in that order):

        * `~.hipError_t`: `~.hipSuccess`, `~.hipErrorInvalidValue`
    """
    if not isinstance(attr,_hipLaunchAttributeID__Base):
        raise TypeError("argument 'attr' must be of type '_hipLaunchAttributeID__Base'")
    _hipGraphKernelNodeGetAttribute__retval = hipError_t(chip.hipGraphKernelNodeGetAttribute(
        hipGraphNode.fromPyobj(hNode).getElementPtr(),attr.value,
        hipLaunchAttributeValue.fromPyobj(value).getElementPtr()))
    return (_hipGraphKernelNodeGetAttribute__retval,)


@cython.embedsignature(True)
def hipGraphExecMemcpyNodeSetParams(object hGraphExec, object node, object pNodeParams):
    r"""Sets the parameters for a memcpy node in the given graphExec.

    Warning:
        This API is marked as beta, meaning, while this is feature complete,
        it is still open to changes and may have outstanding issues.

    Args:
        hGraphExec (`~.hipGraphExec`/`~.object`) -- *IN*:
            - instance of the executable graph with the node.

        node (`~.hipGraphNode`/`~.object`) -- *IN*:
            - instance of the node to set parameters to.

        pNodeParams (`~.hipMemcpy3DParms`/`~.object`) -- *IN*:
            - const pointer to the kernel node parameters.

    Returns:
        A `~.tuple` of size 1 that contains (in that order):

        * `~.hipError_t`: `~.hipSuccess`, `~.hipErrorInvalidValue`
    """
    _hipGraphExecMemcpyNodeSetParams__retval = hipError_t(chip.hipGraphExecMemcpyNodeSetParams(
        hipGraphExec.fromPyobj(hGraphExec).getElementPtr(),
        hipGraphNode.fromPyobj(node).getElementPtr(),
        hipMemcpy3DParms.fromPyobj(pNodeParams).getElementPtr()))
    return (_hipGraphExecMemcpyNodeSetParams__retval,)


@cython.embedsignature(True)
def hipGraphAddMemcpyNode1D(object graph, unsigned long numDependencies, object dst, object src, unsigned long count, object kind):
    r"""Creates a 1D memcpy node and adds it to a graph.

    Warning:
        This API is marked as beta, meaning, while this is feature complete,
        it is still open to changes and may have outstanding issues.

    Args:
        graph (`~.ihipGraph`/`~.object`) -- *IN*:
            - instance of graph to add the created node.

        numDependencies (`~.int`) -- *IN*:
            - the number of the dependencies.

        dst (`~.hip._util.types.Pointer`/`~.object`) -- *IN*:
            - pointer to memory address to the destination.

        src (`~.hip._util.types.Pointer`/`~.object`) -- *IN*:
            - pointer to memory address to the source.

        count (`~.int`) -- *IN*:
            - the size of the memory to copy.

        kind (`~.hipMemcpyKind`) -- *IN*:
            - the type of memory copy.

    Returns:
        A `~.tuple` of size 3 that contains (in that order):

        * `~.hipError_t`: `~.hipSuccess`, `~.hipErrorInvalidValue`
        * `~.hipGraphNode`:
                - pointer to graph node to create.
        * `~.hipGraphNode`:
                - const pointer to the dependencies on the memcpy execution node.
    """
    pGraphNode = hipGraphNode.fromPtr(NULL)
    pDependencies = hipGraphNode.fromPtr(NULL)
    if not isinstance(kind,_hipMemcpyKind__Base):
        raise TypeError("argument 'kind' must be of type '_hipMemcpyKind__Base'")
    _hipGraphAddMemcpyNode1D__retval = hipError_t(chip.hipGraphAddMemcpyNode1D(<chip.hipGraphNode**>&pGraphNode._ptr,
        ihipGraph.fromPyobj(graph).getElementPtr(),<chip.hipGraphNode**>&pDependencies._ptr,numDependencies,
        <void *>hip._util.types.Pointer.fromPyobj(dst)._ptr,
        <const void *>hip._util.types.Pointer.fromPyobj(src)._ptr,count,kind.value))
    return (_hipGraphAddMemcpyNode1D__retval,None if pGraphNode._ptr == NULL else pGraphNode,None if pDependencies._ptr == NULL else pDependencies)


@cython.embedsignature(True)
def hipGraphMemcpyNodeSetParams1D(object node, object dst, object src, unsigned long count, object kind):
    r"""Sets a memcpy node's parameters to perform a 1-dimensional copy.

    Warning:
        This API is marked as beta, meaning, while this is feature complete,
        it is still open to changes and may have outstanding issues.

    Args:
        node (`~.hipGraphNode`/`~.object`) -- *IN*:
            - instance of the node to set parameters to.

        dst (`~.hip._util.types.Pointer`/`~.object`) -- *IN*:
            - pointer to memory address to the destination.

        src (`~.hip._util.types.Pointer`/`~.object`) -- *IN*:
            - pointer to memory address to the source.

        count (`~.int`) -- *IN*:
            - the size of the memory to copy.

        kind (`~.hipMemcpyKind`) -- *IN*:
            - the type of memory copy.

    Returns:
        A `~.tuple` of size 1 that contains (in that order):

        * `~.hipError_t`: `~.hipSuccess`, `~.hipErrorInvalidValue`
    """
    if not isinstance(kind,_hipMemcpyKind__Base):
        raise TypeError("argument 'kind' must be of type '_hipMemcpyKind__Base'")
    _hipGraphMemcpyNodeSetParams1D__retval = hipError_t(chip.hipGraphMemcpyNodeSetParams1D(
        hipGraphNode.fromPyobj(node).getElementPtr(),
        <void *>hip._util.types.Pointer.fromPyobj(dst)._ptr,
        <const void *>hip._util.types.Pointer.fromPyobj(src)._ptr,count,kind.value))
    return (_hipGraphMemcpyNodeSetParams1D__retval,)


@cython.embedsignature(True)
def hipGraphExecMemcpyNodeSetParams1D(object hGraphExec, object node, object dst, object src, unsigned long count, object kind):
    r"""Sets the parameters for a memcpy node in the given graphExec to perform a 1-dimensional
    copy.

    Warning:
        This API is marked as beta, meaning, while this is feature complete,
        it is still open to changes and may have outstanding issues.

    Args:
        hGraphExec (`~.hipGraphExec`/`~.object`) -- *IN*:
            - instance of the executable graph with the node.

        node (`~.hipGraphNode`/`~.object`) -- *IN*:
            - instance of the node to set parameters to.

        dst (`~.hip._util.types.Pointer`/`~.object`) -- *IN*:
            - pointer to memory address to the destination.

        src (`~.hip._util.types.Pointer`/`~.object`) -- *IN*:
            - pointer to memory address to the source.

        count (`~.int`) -- *IN*:
            - the size of the memory to copy.

        kind (`~.hipMemcpyKind`) -- *IN*:
            - the type of memory copy.

    Returns:
        A `~.tuple` of size 1 that contains (in that order):

        * `~.hipError_t`: `~.hipSuccess`, `~.hipErrorInvalidValue`
    """
    if not isinstance(kind,_hipMemcpyKind__Base):
        raise TypeError("argument 'kind' must be of type '_hipMemcpyKind__Base'")
    _hipGraphExecMemcpyNodeSetParams1D__retval = hipError_t(chip.hipGraphExecMemcpyNodeSetParams1D(
        hipGraphExec.fromPyobj(hGraphExec).getElementPtr(),
        hipGraphNode.fromPyobj(node).getElementPtr(),
        <void *>hip._util.types.Pointer.fromPyobj(dst)._ptr,
        <const void *>hip._util.types.Pointer.fromPyobj(src)._ptr,count,kind.value))
    return (_hipGraphExecMemcpyNodeSetParams1D__retval,)


@cython.embedsignature(True)
def hipGraphAddMemcpyNodeFromSymbol(object graph, unsigned long numDependencies, object dst, object symbol, unsigned long count, unsigned long offset, object kind):
    r"""Creates a memcpy node to copy from a symbol on the device and adds it to a graph.

    Warning:
        This API is marked as beta, meaning, while this is feature complete,
        it is still open to changes and may have outstanding issues.

    Args:
        graph (`~.ihipGraph`/`~.object`) -- *IN*:
            - instance of graph to add the created node.

        numDependencies (`~.int`) -- *IN*:
            - the number of the dependencies.

        dst (`~.hip._util.types.Pointer`/`~.object`) -- *IN*:
            - pointer to memory address to the destination.

        symbol (`~.hip._util.types.Pointer`/`~.object`) -- *IN*:
            - Device symbol address.

        count (`~.int`) -- *IN*:
            - the size of the memory to copy.

        offset (`~.int`) -- *IN*:
            - Offset from start of symbol in bytes.

        kind (`~.hipMemcpyKind`) -- *IN*:
            - the type of memory copy.

    Returns:
        A `~.tuple` of size 3 that contains (in that order):

        * `~.hipError_t`: `~.hipSuccess`, `~.hipErrorInvalidValue`
        * `~.hipGraphNode`:
                - pointer to graph node to create.
        * `~.hipGraphNode`:
                - const pointer to the dependencies on the memcpy execution node.
    """
    pGraphNode = hipGraphNode.fromPtr(NULL)
    pDependencies = hipGraphNode.fromPtr(NULL)
    if not isinstance(kind,_hipMemcpyKind__Base):
        raise TypeError("argument 'kind' must be of type '_hipMemcpyKind__Base'")
    _hipGraphAddMemcpyNodeFromSymbol__retval = hipError_t(chip.hipGraphAddMemcpyNodeFromSymbol(<chip.hipGraphNode**>&pGraphNode._ptr,
        ihipGraph.fromPyobj(graph).getElementPtr(),<chip.hipGraphNode**>&pDependencies._ptr,numDependencies,
        <void *>hip._util.types.Pointer.fromPyobj(dst)._ptr,
        <const void *>hip._util.types.Pointer.fromPyobj(symbol)._ptr,count,offset,kind.value))
    return (_hipGraphAddMemcpyNodeFromSymbol__retval,None if pGraphNode._ptr == NULL else pGraphNode,None if pDependencies._ptr == NULL else pDependencies)


@cython.embedsignature(True)
def hipGraphMemcpyNodeSetParamsFromSymbol(object node, object dst, object symbol, unsigned long count, unsigned long offset, object kind):
    r"""Sets a memcpy node's parameters to copy from a symbol on the device.

    Warning:
        This API is marked as beta, meaning, while this is feature complete,
        it is still open to changes and may have outstanding issues.

    Args:
        node (`~.hipGraphNode`/`~.object`) -- *IN*:
            - instance of the node to set parameters to.

        dst (`~.hip._util.types.Pointer`/`~.object`) -- *IN*:
            - pointer to memory address to the destination.

        symbol (`~.hip._util.types.Pointer`/`~.object`) -- *IN*:
            - Device symbol address.

        count (`~.int`) -- *IN*:
            - the size of the memory to copy.

        offset (`~.int`) -- *IN*:
            - Offset from start of symbol in bytes.

        kind (`~.hipMemcpyKind`) -- *IN*:
            - the type of memory copy.

    Returns:
        A `~.tuple` of size 1 that contains (in that order):

        * `~.hipError_t`: `~.hipSuccess`, `~.hipErrorInvalidValue`
    """
    if not isinstance(kind,_hipMemcpyKind__Base):
        raise TypeError("argument 'kind' must be of type '_hipMemcpyKind__Base'")
    _hipGraphMemcpyNodeSetParamsFromSymbol__retval = hipError_t(chip.hipGraphMemcpyNodeSetParamsFromSymbol(
        hipGraphNode.fromPyobj(node).getElementPtr(),
        <void *>hip._util.types.Pointer.fromPyobj(dst)._ptr,
        <const void *>hip._util.types.Pointer.fromPyobj(symbol)._ptr,count,offset,kind.value))
    return (_hipGraphMemcpyNodeSetParamsFromSymbol__retval,)


@cython.embedsignature(True)
def hipGraphExecMemcpyNodeSetParamsFromSymbol(object hGraphExec, object node, object dst, object symbol, unsigned long count, unsigned long offset, object kind):
    r"""Sets the parameters for a memcpy node in the given graphExec to copy from a symbol on the
    * device.

    Warning:
        This API is marked as beta, meaning, while this is feature complete,
        it is still open to changes and may have outstanding issues.

    Args:
        hGraphExec (`~.hipGraphExec`/`~.object`) -- *IN*:
            - instance of the executable graph with the node.

        node (`~.hipGraphNode`/`~.object`) -- *IN*:
            - instance of the node to set parameters to.

        dst (`~.hip._util.types.Pointer`/`~.object`) -- *IN*:
            - pointer to memory address to the destination.

        symbol (`~.hip._util.types.Pointer`/`~.object`) -- *IN*:
            - Device symbol address.

        count (`~.int`) -- *IN*:
            - the size of the memory to copy.

        offset (`~.int`) -- *IN*:
            - Offset from start of symbol in bytes.

        kind (`~.hipMemcpyKind`) -- *IN*:
            - the type of memory copy.

    Returns:
        A `~.tuple` of size 1 that contains (in that order):

        * `~.hipError_t`: `~.hipSuccess`, `~.hipErrorInvalidValue`
    """
    if not isinstance(kind,_hipMemcpyKind__Base):
        raise TypeError("argument 'kind' must be of type '_hipMemcpyKind__Base'")
    _hipGraphExecMemcpyNodeSetParamsFromSymbol__retval = hipError_t(chip.hipGraphExecMemcpyNodeSetParamsFromSymbol(
        hipGraphExec.fromPyobj(hGraphExec).getElementPtr(),
        hipGraphNode.fromPyobj(node).getElementPtr(),
        <void *>hip._util.types.Pointer.fromPyobj(dst)._ptr,
        <const void *>hip._util.types.Pointer.fromPyobj(symbol)._ptr,count,offset,kind.value))
    return (_hipGraphExecMemcpyNodeSetParamsFromSymbol__retval,)


@cython.embedsignature(True)
def hipGraphAddMemcpyNodeToSymbol(object graph, unsigned long numDependencies, object symbol, object src, unsigned long count, unsigned long offset, object kind):
    r"""Creates a memcpy node to copy to a symbol on the device and adds it to a graph.

    Warning:
        This API is marked as beta, meaning, while this is feature complete,
        it is still open to changes and may have outstanding issues.

    Args:
        graph (`~.ihipGraph`/`~.object`) -- *IN*:
            - instance of graph to add the created node.

        numDependencies (`~.int`) -- *IN*:
            - the number of the dependencies.

        symbol (`~.hip._util.types.Pointer`/`~.object`) -- *IN*:
            - Device symbol address.

        src (`~.hip._util.types.Pointer`/`~.object`) -- *IN*:
            - pointer to memory address of the src.

        count (`~.int`) -- *IN*:
            - the size of the memory to copy.

        offset (`~.int`) -- *IN*:
            - Offset from start of symbol in bytes.

        kind (`~.hipMemcpyKind`) -- *IN*:
            - the type of memory copy.

    Returns:
        A `~.tuple` of size 3 that contains (in that order):

        * `~.hipError_t`: `~.hipSuccess`, `~.hipErrorInvalidValue`
        * `~.hipGraphNode`:
                - pointer to graph node to create.
        * `~.hipGraphNode`:
                - const pointer to the dependencies on the memcpy execution node.
    """
    pGraphNode = hipGraphNode.fromPtr(NULL)
    pDependencies = hipGraphNode.fromPtr(NULL)
    if not isinstance(kind,_hipMemcpyKind__Base):
        raise TypeError("argument 'kind' must be of type '_hipMemcpyKind__Base'")
    _hipGraphAddMemcpyNodeToSymbol__retval = hipError_t(chip.hipGraphAddMemcpyNodeToSymbol(<chip.hipGraphNode**>&pGraphNode._ptr,
        ihipGraph.fromPyobj(graph).getElementPtr(),<chip.hipGraphNode**>&pDependencies._ptr,numDependencies,
        <const void *>hip._util.types.Pointer.fromPyobj(symbol)._ptr,
        <const void *>hip._util.types.Pointer.fromPyobj(src)._ptr,count,offset,kind.value))
    return (_hipGraphAddMemcpyNodeToSymbol__retval,None if pGraphNode._ptr == NULL else pGraphNode,None if pDependencies._ptr == NULL else pDependencies)


@cython.embedsignature(True)
def hipGraphMemcpyNodeSetParamsToSymbol(object node, object symbol, object src, unsigned long count, unsigned long offset, object kind):
    r"""Sets a memcpy node's parameters to copy to a symbol on the device.

    Warning:
        This API is marked as beta, meaning, while this is feature complete,
        it is still open to changes and may have outstanding issues.

    Args:
        node (`~.hipGraphNode`/`~.object`) -- *IN*:
            - instance of the node to set parameters to.

        symbol (`~.hip._util.types.Pointer`/`~.object`) -- *IN*:
            - Device symbol address.

        src (`~.hip._util.types.Pointer`/`~.object`) -- *IN*:
            - pointer to memory address of the src.

        count (`~.int`) -- *IN*:
            - the size of the memory to copy.

        offset (`~.int`) -- *IN*:
            - Offset from start of symbol in bytes.

        kind (`~.hipMemcpyKind`) -- *IN*:
            - the type of memory copy.

    Returns:
        A `~.tuple` of size 1 that contains (in that order):

        * `~.hipError_t`: `~.hipSuccess`, `~.hipErrorInvalidValue`
    """
    if not isinstance(kind,_hipMemcpyKind__Base):
        raise TypeError("argument 'kind' must be of type '_hipMemcpyKind__Base'")
    _hipGraphMemcpyNodeSetParamsToSymbol__retval = hipError_t(chip.hipGraphMemcpyNodeSetParamsToSymbol(
        hipGraphNode.fromPyobj(node).getElementPtr(),
        <const void *>hip._util.types.Pointer.fromPyobj(symbol)._ptr,
        <const void *>hip._util.types.Pointer.fromPyobj(src)._ptr,count,offset,kind.value))
    return (_hipGraphMemcpyNodeSetParamsToSymbol__retval,)


@cython.embedsignature(True)
def hipGraphExecMemcpyNodeSetParamsToSymbol(object hGraphExec, object node, object symbol, object src, unsigned long count, unsigned long offset, object kind):
    r"""Sets the parameters for a memcpy node in the given graphExec to copy to a symbol on the
    device.

    Warning:
        This API is marked as beta, meaning, while this is feature complete,
        it is still open to changes and may have outstanding issues.

    Args:
        hGraphExec (`~.hipGraphExec`/`~.object`) -- *IN*:
            - instance of the executable graph with the node.

        node (`~.hipGraphNode`/`~.object`) -- *IN*:
            - instance of the node to set parameters to.

        symbol (`~.hip._util.types.Pointer`/`~.object`) -- *IN*:
            - Device symbol address.

        src (`~.hip._util.types.Pointer`/`~.object`) -- *IN*:
            - pointer to memory address of the src.

        count (`~.int`) -- *IN*:
            - the size of the memory to copy.

        offset (`~.int`) -- *IN*:
            - Offset from start of symbol in bytes.

        kind (`~.hipMemcpyKind`) -- *IN*:
            - the type of memory copy.

    Returns:
        A `~.tuple` of size 1 that contains (in that order):

        * `~.hipError_t`: `~.hipSuccess`, `~.hipErrorInvalidValue`
    """
    if not isinstance(kind,_hipMemcpyKind__Base):
        raise TypeError("argument 'kind' must be of type '_hipMemcpyKind__Base'")
    _hipGraphExecMemcpyNodeSetParamsToSymbol__retval = hipError_t(chip.hipGraphExecMemcpyNodeSetParamsToSymbol(
        hipGraphExec.fromPyobj(hGraphExec).getElementPtr(),
        hipGraphNode.fromPyobj(node).getElementPtr(),
        <const void *>hip._util.types.Pointer.fromPyobj(symbol)._ptr,
        <const void *>hip._util.types.Pointer.fromPyobj(src)._ptr,count,offset,kind.value))
    return (_hipGraphExecMemcpyNodeSetParamsToSymbol__retval,)


@cython.embedsignature(True)
def hipGraphAddMemsetNode(object graph, unsigned long numDependencies, object pMemsetParams):
    r"""Creates a memset node and adds it to a graph.

    Warning:
        This API is marked as beta, meaning, while this is feature complete,
        it is still open to changes and may have outstanding issues.

    Args:
        graph (`~.ihipGraph`/`~.object`) -- *IN*:
            - instance of the graph to add the created node.

        numDependencies (`~.int`) -- *IN*:
            - the number of the dependencies.

        pMemsetParams (`~.hipMemsetParams`/`~.object`) -- *IN*:
            - const pointer to the parameters for the memory set.

    Returns:
        A `~.tuple` of size 3 that contains (in that order):

        * `~.hipError_t`: `~.hipSuccess`, `~.hipErrorInvalidValue`
        * `~.hipGraphNode`:
                - pointer to the graph node to create.
        * `~.hipGraphNode`:
                - const pointer to the dependencies on the memset execution node.
    """
    pGraphNode = hipGraphNode.fromPtr(NULL)
    pDependencies = hipGraphNode.fromPtr(NULL)
    _hipGraphAddMemsetNode__retval = hipError_t(chip.hipGraphAddMemsetNode(<chip.hipGraphNode**>&pGraphNode._ptr,
        ihipGraph.fromPyobj(graph).getElementPtr(),<chip.hipGraphNode**>&pDependencies._ptr,numDependencies,
        hipMemsetParams.fromPyobj(pMemsetParams).getElementPtr()))
    return (_hipGraphAddMemsetNode__retval,None if pGraphNode._ptr == NULL else pGraphNode,None if pDependencies._ptr == NULL else pDependencies)


@cython.embedsignature(True)
def hipGraphMemsetNodeGetParams(object node, object pNodeParams):
    r"""Gets a memset node's parameters.

    Warning:
        This API is marked as beta, meaning, while this is feature complete,
        it is still open to changes and may have outstanding issues.

    Args:
        node (`~.hipGraphNode`/`~.object`) -- *IN*:
            - instane of the node to get parameters from.

        pNodeParams (`~.hipMemsetParams`/`~.object`) -- *OUT*:
            - pointer to the parameters.

    Returns:
        A `~.tuple` of size 1 that contains (in that order):

        * `~.hipError_t`: `~.hipSuccess`, `~.hipErrorInvalidValue`
    """
    _hipGraphMemsetNodeGetParams__retval = hipError_t(chip.hipGraphMemsetNodeGetParams(
        hipGraphNode.fromPyobj(node).getElementPtr(),
        hipMemsetParams.fromPyobj(pNodeParams).getElementPtr()))
    return (_hipGraphMemsetNodeGetParams__retval,)


@cython.embedsignature(True)
def hipGraphMemsetNodeSetParams(object node, object pNodeParams):
    r"""Sets a memset node's parameters.

    Warning:
        This API is marked as beta, meaning, while this is feature complete,
        it is still open to changes and may have outstanding issues.

    Args:
        node (`~.hipGraphNode`/`~.object`) -- *IN*:
            - instance of the node to set parameters to.

        pNodeParams (`~.hipMemsetParams`/`~.object`) -- *IN*:
            - pointer to the parameters.

    Returns:
        A `~.tuple` of size 1 that contains (in that order):

        * `~.hipError_t`: `~.hipSuccess`, `~.hipErrorInvalidValue`
    """
    _hipGraphMemsetNodeSetParams__retval = hipError_t(chip.hipGraphMemsetNodeSetParams(
        hipGraphNode.fromPyobj(node).getElementPtr(),
        hipMemsetParams.fromPyobj(pNodeParams).getElementPtr()))
    return (_hipGraphMemsetNodeSetParams__retval,)


@cython.embedsignature(True)
def hipGraphExecMemsetNodeSetParams(object hGraphExec, object node, object pNodeParams):
    r"""Sets the parameters for a memset node in the given graphExec.

    Warning:
        This API is marked as beta, meaning, while this is feature complete,
        it is still open to changes and may have outstanding issues.

    Args:
        hGraphExec (`~.hipGraphExec`/`~.object`) -- *IN*:
            - instance of the executable graph with the node.

        node (`~.hipGraphNode`/`~.object`) -- *IN*:
            - instance of the node to set parameters to.

        pNodeParams (`~.hipMemsetParams`/`~.object`) -- *IN*:
            - pointer to the parameters.

    Returns:
        A `~.tuple` of size 1 that contains (in that order):

        * `~.hipError_t`: `~.hipSuccess`, `~.hipErrorInvalidValue`
    """
    _hipGraphExecMemsetNodeSetParams__retval = hipError_t(chip.hipGraphExecMemsetNodeSetParams(
        hipGraphExec.fromPyobj(hGraphExec).getElementPtr(),
        hipGraphNode.fromPyobj(node).getElementPtr(),
        hipMemsetParams.fromPyobj(pNodeParams).getElementPtr()))
    return (_hipGraphExecMemsetNodeSetParams__retval,)


@cython.embedsignature(True)
def hipGraphAddHostNode(object graph, unsigned long numDependencies, object pNodeParams):
    r"""Creates a host execution node and adds it to a graph.

    Warning:
        This API is marked as beta, meaning, while this is feature complete,
        it is still open to changes and may have outstanding issues.

    Args:
        graph (`~.ihipGraph`/`~.object`) -- *IN*:
            - instance of the graph to add the created node.

        numDependencies (`~.int`) -- *IN*:
            - the number of the dependencies.

        pNodeParams (`~.hipHostNodeParams`/`~.object`) -- *IN*:
            -pointer to the parameters.

    Returns:
        A `~.tuple` of size 3 that contains (in that order):

        * `~.hipError_t`: `~.hipSuccess`, `~.hipErrorInvalidValue`
        * `~.hipGraphNode`:
                - pointer to the graph node to create.
        * `~.hipGraphNode`:
                - const pointer to the dependencies on the memset execution node.
    """
    pGraphNode = hipGraphNode.fromPtr(NULL)
    pDependencies = hipGraphNode.fromPtr(NULL)
    _hipGraphAddHostNode__retval = hipError_t(chip.hipGraphAddHostNode(<chip.hipGraphNode**>&pGraphNode._ptr,
        ihipGraph.fromPyobj(graph).getElementPtr(),<chip.hipGraphNode**>&pDependencies._ptr,numDependencies,
        hipHostNodeParams.fromPyobj(pNodeParams).getElementPtr()))
    return (_hipGraphAddHostNode__retval,None if pGraphNode._ptr == NULL else pGraphNode,None if pDependencies._ptr == NULL else pDependencies)


@cython.embedsignature(True)
def hipGraphHostNodeGetParams(object node, object pNodeParams):
    r"""Returns a host node's parameters.

    Warning:
        This API is marked as beta, meaning, while this is feature complete,
        it is still open to changes and may have outstanding issues.

    Args:
        node (`~.hipGraphNode`/`~.object`) -- *IN*:
            - instane of the node to get parameters from.

        pNodeParams (`~.hipHostNodeParams`/`~.object`) -- *OUT*:
            - pointer to the parameters.

    Returns:
        A `~.tuple` of size 1 that contains (in that order):

        * `~.hipError_t`: `~.hipSuccess`, `~.hipErrorInvalidValue`
    """
    _hipGraphHostNodeGetParams__retval = hipError_t(chip.hipGraphHostNodeGetParams(
        hipGraphNode.fromPyobj(node).getElementPtr(),
        hipHostNodeParams.fromPyobj(pNodeParams).getElementPtr()))
    return (_hipGraphHostNodeGetParams__retval,)


@cython.embedsignature(True)
def hipGraphHostNodeSetParams(object node, object pNodeParams):
    r"""Sets a host node's parameters.

    Warning:
        This API is marked as beta, meaning, while this is feature complete,
        it is still open to changes and may have outstanding issues.

    Args:
        node (`~.hipGraphNode`/`~.object`) -- *IN*:
            - instance of the node to set parameters to.

        pNodeParams (`~.hipHostNodeParams`/`~.object`) -- *IN*:
            - pointer to the parameters.

    Returns:
        A `~.tuple` of size 1 that contains (in that order):

        * `~.hipError_t`: `~.hipSuccess`, `~.hipErrorInvalidValue`
    """
    _hipGraphHostNodeSetParams__retval = hipError_t(chip.hipGraphHostNodeSetParams(
        hipGraphNode.fromPyobj(node).getElementPtr(),
        hipHostNodeParams.fromPyobj(pNodeParams).getElementPtr()))
    return (_hipGraphHostNodeSetParams__retval,)


@cython.embedsignature(True)
def hipGraphExecHostNodeSetParams(object hGraphExec, object node, object pNodeParams):
    r"""Sets the parameters for a host node in the given graphExec.

    Warning:
        This API is marked as beta, meaning, while this is feature complete,
        it is still open to changes and may have outstanding issues.

    Args:
        hGraphExec (`~.hipGraphExec`/`~.object`) -- *IN*:
            - instance of the executable graph with the node.

        node (`~.hipGraphNode`/`~.object`) -- *IN*:
            - instance of the node to set parameters to.

        pNodeParams (`~.hipHostNodeParams`/`~.object`) -- *IN*:
            - pointer to the parameters.

    Returns:
        A `~.tuple` of size 1 that contains (in that order):

        * `~.hipError_t`: `~.hipSuccess`, `~.hipErrorInvalidValue`
    """
    _hipGraphExecHostNodeSetParams__retval = hipError_t(chip.hipGraphExecHostNodeSetParams(
        hipGraphExec.fromPyobj(hGraphExec).getElementPtr(),
        hipGraphNode.fromPyobj(node).getElementPtr(),
        hipHostNodeParams.fromPyobj(pNodeParams).getElementPtr()))
    return (_hipGraphExecHostNodeSetParams__retval,)


@cython.embedsignature(True)
def hipGraphAddChildGraphNode(object graph, unsigned long numDependencies, object childGraph):
    r"""Creates a child graph node and adds it to a graph.

    Warning:
        This API is marked as beta, meaning, while this is feature complete,
        it is still open to changes and may have outstanding issues.

    Args:
        graph (`~.ihipGraph`/`~.object`) -- *IN*:
            - instance of the graph to add the created node.

        numDependencies (`~.int`) -- *IN*:
            - the number of the dependencies.

        childGraph (`~.ihipGraph`/`~.object`) -- *IN*:
            - the graph to clone into this node

    Returns:
        A `~.tuple` of size 3 that contains (in that order):

        * `~.hipError_t`: `~.hipSuccess`, `~.hipErrorInvalidValue`
        * `~.hipGraphNode`:
                - pointer to the graph node to create.
        * `~.hipGraphNode`:
                - const pointer to the dependencies on the memset execution node.
    """
    pGraphNode = hipGraphNode.fromPtr(NULL)
    pDependencies = hipGraphNode.fromPtr(NULL)
    _hipGraphAddChildGraphNode__retval = hipError_t(chip.hipGraphAddChildGraphNode(<chip.hipGraphNode**>&pGraphNode._ptr,
        ihipGraph.fromPyobj(graph).getElementPtr(),<chip.hipGraphNode**>&pDependencies._ptr,numDependencies,
        ihipGraph.fromPyobj(childGraph).getElementPtr()))
    return (_hipGraphAddChildGraphNode__retval,None if pGraphNode._ptr == NULL else pGraphNode,None if pDependencies._ptr == NULL else pDependencies)


@cython.embedsignature(True)
def hipGraphChildGraphNodeGetGraph(object node):
    r"""Gets a handle to the embedded graph of a child graph node.

    Warning:
        This API is marked as beta, meaning, while this is feature complete,
        it is still open to changes and may have outstanding issues.

    Args:
        node (`~.hipGraphNode`/`~.object`) -- *IN*:
            - instane of the node to get child graph.

    Returns:
        A `~.tuple` of size 2 that contains (in that order):

        * `~.hipError_t`: `~.hipSuccess`, `~.hipErrorInvalidValue`
        * `~.ihipGraph`:
                - pointer to get the graph.
    """
    pGraph = ihipGraph.fromPtr(NULL)
    _hipGraphChildGraphNodeGetGraph__retval = hipError_t(chip.hipGraphChildGraphNodeGetGraph(
        hipGraphNode.fromPyobj(node).getElementPtr(),<chip.ihipGraph**>&pGraph._ptr))
    return (_hipGraphChildGraphNodeGetGraph__retval,None if pGraph._ptr == NULL else pGraph)


@cython.embedsignature(True)
def hipGraphExecChildGraphNodeSetParams(object hGraphExec, object node, object childGraph):
    r"""Updates node parameters in the child graph node in the given graphExec.

    Warning:
        This API is marked as beta, meaning, while this is feature complete,
        it is still open to changes and may have outstanding issues.

    Args:
        hGraphExec (`~.hipGraphExec`/`~.object`) -- *IN*:
            - instance of the executable graph with the node.

        node (`~.hipGraphNode`/`~.object`) -- *IN*:
            - node from the graph which was used to instantiate graphExec.

        childGraph (`~.ihipGraph`/`~.object`) -- *IN*:
            - child graph with updated parameters.

    Returns:
        A `~.tuple` of size 1 that contains (in that order):

        * `~.hipError_t`: `~.hipSuccess`, `~.hipErrorInvalidValue`
    """
    _hipGraphExecChildGraphNodeSetParams__retval = hipError_t(chip.hipGraphExecChildGraphNodeSetParams(
        hipGraphExec.fromPyobj(hGraphExec).getElementPtr(),
        hipGraphNode.fromPyobj(node).getElementPtr(),
        ihipGraph.fromPyobj(childGraph).getElementPtr()))
    return (_hipGraphExecChildGraphNodeSetParams__retval,)


@cython.embedsignature(True)
def hipGraphAddEmptyNode(object graph, unsigned long numDependencies):
    r"""Creates an empty node and adds it to a graph.

    Warning:
        This API is marked as beta, meaning, while this is feature complete,
        it is still open to changes and may have outstanding issues.

    Args:
        graph (`~.ihipGraph`/`~.object`) -- *IN*:
            - instane of the graph the node is add to.

        numDependencies (`~.int`) -- *IN*:
            - the number of dependencies.

    Returns:
        A `~.tuple` of size 3 that contains (in that order):

        * `~.hipError_t`: `~.hipSuccess`, `~.hipErrorInvalidValue`
        * `~.hipGraphNode`:
                - pointer to the graph node to create and add to the graph.
        * `~.hipGraphNode`:
                - const pointer to the node dependenties.
    """
    pGraphNode = hipGraphNode.fromPtr(NULL)
    pDependencies = hipGraphNode.fromPtr(NULL)
    _hipGraphAddEmptyNode__retval = hipError_t(chip.hipGraphAddEmptyNode(<chip.hipGraphNode**>&pGraphNode._ptr,
        ihipGraph.fromPyobj(graph).getElementPtr(),<chip.hipGraphNode**>&pDependencies._ptr,numDependencies))
    return (_hipGraphAddEmptyNode__retval,None if pGraphNode._ptr == NULL else pGraphNode,None if pDependencies._ptr == NULL else pDependencies)


@cython.embedsignature(True)
def hipGraphAddEventRecordNode(object graph, unsigned long numDependencies, object event):
    r"""Creates an event record node and adds it to a graph.

    Warning:
        This API is marked as beta, meaning, while this is feature complete,
        it is still open to changes and may have outstanding issues.

    Args:
        graph (`~.ihipGraph`/`~.object`) -- *IN*:
            - instane of the graph the node to be added.

        numDependencies (`~.int`) -- *IN*:
            - the number of dependencies.

        event (`~.ihipEvent_t`/`~.object`) -- *IN*:
            - Event for the node.

    Returns:
        A `~.tuple` of size 3 that contains (in that order):

        * `~.hipError_t`: `~.hipSuccess`, `~.hipErrorInvalidValue`
        * `~.hipGraphNode`:
                - pointer to the graph node to create and add to the graph.
        * `~.hipGraphNode`:
                - const pointer to the node dependenties.
    """
    pGraphNode = hipGraphNode.fromPtr(NULL)
    pDependencies = hipGraphNode.fromPtr(NULL)
    _hipGraphAddEventRecordNode__retval = hipError_t(chip.hipGraphAddEventRecordNode(<chip.hipGraphNode**>&pGraphNode._ptr,
        ihipGraph.fromPyobj(graph).getElementPtr(),<chip.hipGraphNode**>&pDependencies._ptr,numDependencies,
        ihipEvent_t.fromPyobj(event).getElementPtr()))
    return (_hipGraphAddEventRecordNode__retval,None if pGraphNode._ptr == NULL else pGraphNode,None if pDependencies._ptr == NULL else pDependencies)


@cython.embedsignature(True)
def hipGraphEventRecordNodeGetEvent(object node):
    r"""Returns the event associated with an event record node.

    Warning:
        This API is marked as beta, meaning, while this is feature complete,
        it is still open to changes and may have outstanding issues.

    Args:
        node (`~.hipGraphNode`/`~.object`) -- *IN*:
            -  instane of the node to get event from.

    Returns:
        A `~.tuple` of size 2 that contains (in that order):

        * `~.hipError_t`: `~.hipSuccess`, `~.hipErrorInvalidValue`
        * `~.ihipEvent_t`:
                - Pointer to return the event.
    """
    event_out = ihipEvent_t.fromPtr(NULL)
    _hipGraphEventRecordNodeGetEvent__retval = hipError_t(chip.hipGraphEventRecordNodeGetEvent(
        hipGraphNode.fromPyobj(node).getElementPtr(),<chip.ihipEvent_t**>&event_out._ptr))
    return (_hipGraphEventRecordNodeGetEvent__retval,None if event_out._ptr == NULL else event_out)


@cython.embedsignature(True)
def hipGraphEventRecordNodeSetEvent(object node, object event):
    r"""Sets an event record node's event.

    Warning:
        This API is marked as beta, meaning, while this is feature complete,
        it is still open to changes and may have outstanding issues.

    Args:
        node (`~.hipGraphNode`/`~.object`) -- *IN*:
            - instane of the node to set event to.

        event (`~.ihipEvent_t`/`~.object`) -- *IN*:
            - pointer to the event.

    Returns:
        A `~.tuple` of size 1 that contains (in that order):

        * `~.hipError_t`: `~.hipSuccess`, `~.hipErrorInvalidValue`
    """
    _hipGraphEventRecordNodeSetEvent__retval = hipError_t(chip.hipGraphEventRecordNodeSetEvent(
        hipGraphNode.fromPyobj(node).getElementPtr(),
        ihipEvent_t.fromPyobj(event).getElementPtr()))
    return (_hipGraphEventRecordNodeSetEvent__retval,)


@cython.embedsignature(True)
def hipGraphExecEventRecordNodeSetEvent(object hGraphExec, object hNode, object event):
    r"""Sets the event for an event record node in the given graphExec.

    Warning:
        This API is marked as beta, meaning, while this is feature complete,
        it is still open to changes and may have outstanding issues.

    Args:
        hGraphExec (`~.hipGraphExec`/`~.object`) -- *IN*:
            - instance of the executable graph with the node.

        hNode (`~.hipGraphNode`/`~.object`) -- *IN*:
            - node from the graph which was used to instantiate graphExec.

        event (`~.ihipEvent_t`/`~.object`) -- *IN*:
            - pointer to the event.

    Returns:
        A `~.tuple` of size 1 that contains (in that order):

        * `~.hipError_t`: `~.hipSuccess`, `~.hipErrorInvalidValue`
    """
    _hipGraphExecEventRecordNodeSetEvent__retval = hipError_t(chip.hipGraphExecEventRecordNodeSetEvent(
        hipGraphExec.fromPyobj(hGraphExec).getElementPtr(),
        hipGraphNode.fromPyobj(hNode).getElementPtr(),
        ihipEvent_t.fromPyobj(event).getElementPtr()))
    return (_hipGraphExecEventRecordNodeSetEvent__retval,)


@cython.embedsignature(True)
def hipGraphAddEventWaitNode(object graph, unsigned long numDependencies, object event):
    r"""Creates an event wait node and adds it to a graph.

    Warning:
        This API is marked as beta, meaning, while this is feature complete,
        it is still open to changes and may have outstanding issues.

    Args:
        graph (`~.ihipGraph`/`~.object`) -- *IN*:
            - instane of the graph the node to be added.

        numDependencies (`~.int`) -- *IN*:
            - the number of dependencies.

        event (`~.ihipEvent_t`/`~.object`) -- *IN*:
            - Event for the node.

    Returns:
        A `~.tuple` of size 3 that contains (in that order):

        * `~.hipError_t`: `~.hipSuccess`, `~.hipErrorInvalidValue`
        * `~.hipGraphNode`:
                - pointer to the graph node to create and add to the graph.
        * `~.hipGraphNode`:
                - const pointer to the node dependenties.
    """
    pGraphNode = hipGraphNode.fromPtr(NULL)
    pDependencies = hipGraphNode.fromPtr(NULL)
    _hipGraphAddEventWaitNode__retval = hipError_t(chip.hipGraphAddEventWaitNode(<chip.hipGraphNode**>&pGraphNode._ptr,
        ihipGraph.fromPyobj(graph).getElementPtr(),<chip.hipGraphNode**>&pDependencies._ptr,numDependencies,
        ihipEvent_t.fromPyobj(event).getElementPtr()))
    return (_hipGraphAddEventWaitNode__retval,None if pGraphNode._ptr == NULL else pGraphNode,None if pDependencies._ptr == NULL else pDependencies)


@cython.embedsignature(True)
def hipGraphEventWaitNodeGetEvent(object node):
    r"""Returns the event associated with an event wait node.

    Warning:
        This API is marked as beta, meaning, while this is feature complete,
        it is still open to changes and may have outstanding issues.

    Args:
        node (`~.hipGraphNode`/`~.object`) -- *IN*:
            -  instane of the node to get event from.

    Returns:
        A `~.tuple` of size 2 that contains (in that order):

        * `~.hipError_t`: `~.hipSuccess`, `~.hipErrorInvalidValue`
        * `~.ihipEvent_t`:
                - Pointer to return the event.
    """
    event_out = ihipEvent_t.fromPtr(NULL)
    _hipGraphEventWaitNodeGetEvent__retval = hipError_t(chip.hipGraphEventWaitNodeGetEvent(
        hipGraphNode.fromPyobj(node).getElementPtr(),<chip.ihipEvent_t**>&event_out._ptr))
    return (_hipGraphEventWaitNodeGetEvent__retval,None if event_out._ptr == NULL else event_out)


@cython.embedsignature(True)
def hipGraphEventWaitNodeSetEvent(object node, object event):
    r"""Sets an event wait node's event.

    Warning:
        This API is marked as beta, meaning, while this is feature complete,
        it is still open to changes and may have outstanding issues.

    Args:
        node (`~.hipGraphNode`/`~.object`) -- *IN*:
            - instane of the node to set event to.

        event (`~.ihipEvent_t`/`~.object`) -- *IN*:
            - pointer to the event.

    Returns:
        A `~.tuple` of size 1 that contains (in that order):

        * `~.hipError_t`: `~.hipSuccess`, `~.hipErrorInvalidValue`
    """
    _hipGraphEventWaitNodeSetEvent__retval = hipError_t(chip.hipGraphEventWaitNodeSetEvent(
        hipGraphNode.fromPyobj(node).getElementPtr(),
        ihipEvent_t.fromPyobj(event).getElementPtr()))
    return (_hipGraphEventWaitNodeSetEvent__retval,)


@cython.embedsignature(True)
def hipGraphExecEventWaitNodeSetEvent(object hGraphExec, object hNode, object event):
    r"""Sets the event for an event record node in the given graphExec.

    Warning:
        This API is marked as beta, meaning, while this is feature complete,
        it is still open to changes and may have outstanding issues.

    Args:
        hGraphExec (`~.hipGraphExec`/`~.object`) -- *IN*:
            - instance of the executable graph with the node.

        hNode (`~.hipGraphNode`/`~.object`) -- *IN*:
            - node from the graph which was used to instantiate graphExec.

        event (`~.ihipEvent_t`/`~.object`) -- *IN*:
            - pointer to the event.

    Returns:
        A `~.tuple` of size 1 that contains (in that order):

        * `~.hipError_t`: `~.hipSuccess`, `~.hipErrorInvalidValue`
    """
    _hipGraphExecEventWaitNodeSetEvent__retval = hipError_t(chip.hipGraphExecEventWaitNodeSetEvent(
        hipGraphExec.fromPyobj(hGraphExec).getElementPtr(),
        hipGraphNode.fromPyobj(hNode).getElementPtr(),
        ihipEvent_t.fromPyobj(event).getElementPtr()))
    return (_hipGraphExecEventWaitNodeSetEvent__retval,)


@cython.embedsignature(True)
def hipGraphAddMemAllocNode(object graph, unsigned long numDependencies, object pNodeParams):
    r"""Creates a memory allocation node and adds it to a graph

    Warning:
        This API is marked as beta, meaning, while this is feature complete,
        it is still open to changes and may have outstanding issues.

    Args:
        graph (`~.ihipGraph`/`~.object`) -- *IN*:
            - Instane of the graph the node to be added

        numDependencies (`~.int`) -- *IN*:
            - The number of dependencies

        pNodeParams (`~.hipMemAllocNodeParams`/`~.object`) -- *IN*:
            - Node parameters for memory allocation

    Returns:
        A `~.tuple` of size 3 that contains (in that order):

        * `~.hipError_t`: `~.hipSuccess`, `~.hipErrorInvalidValue`
        * `~.hipGraphNode`:
                - Pointer to the graph node to create and add to the graph
        * `~.hipGraphNode`:
                - Const pointer to the node dependenties
    """
    pGraphNode = hipGraphNode.fromPtr(NULL)
    pDependencies = hipGraphNode.fromPtr(NULL)
    _hipGraphAddMemAllocNode__retval = hipError_t(chip.hipGraphAddMemAllocNode(<chip.hipGraphNode**>&pGraphNode._ptr,
        ihipGraph.fromPyobj(graph).getElementPtr(),<chip.hipGraphNode**>&pDependencies._ptr,numDependencies,
        hipMemAllocNodeParams.fromPyobj(pNodeParams).getElementPtr()))
    return (_hipGraphAddMemAllocNode__retval,None if pGraphNode._ptr == NULL else pGraphNode,None if pDependencies._ptr == NULL else pDependencies)


@cython.embedsignature(True)
def hipGraphMemAllocNodeGetParams(object node, object pNodeParams):
    r"""Returns parameters for memory allocation node

    Warning:
        This API is marked as beta, meaning, while this is feature complete,
        it is still open to changes and may have outstanding issues.

    Args:
        node (`~.hipGraphNode`/`~.object`) -- *IN*:
            - Memory allocation node for a query

        pNodeParams (`~.hipMemAllocNodeParams`/`~.object`) -- *OUT*:
            - Parameters for the specified memory allocation node

    Returns:
        A `~.tuple` of size 1 that contains (in that order):

        * `~.hipError_t`: `~.hipSuccess`, `~.hipErrorInvalidValue`
    """
    _hipGraphMemAllocNodeGetParams__retval = hipError_t(chip.hipGraphMemAllocNodeGetParams(
        hipGraphNode.fromPyobj(node).getElementPtr(),
        hipMemAllocNodeParams.fromPyobj(pNodeParams).getElementPtr()))
    return (_hipGraphMemAllocNodeGetParams__retval,)


@cython.embedsignature(True)
def hipGraphAddMemFreeNode(object graph, unsigned long numDependencies, object dev_ptr):
    r"""Creates a memory free node and adds it to a graph

    Warning:
        This API is marked as beta, meaning, while this is feature complete,
        it is still open to changes and may have outstanding issues.

    Args:
        graph (`~.ihipGraph`/`~.object`) -- *IN*:
            - Instane of the graph the node to be added

        numDependencies (`~.int`) -- *IN*:
            - The number of dependencies

        dev_ptr (`~.hip._util.types.Pointer`/`~.object`) -- *IN*:
            - Pointer to the memory to be freed

    Returns:
        A `~.tuple` of size 3 that contains (in that order):

        * `~.hipError_t`: `~.hipSuccess`, `~.hipErrorInvalidValue`
        * `~.hipGraphNode`:
                - Pointer to the graph node to create and add to the graph
        * `~.hipGraphNode`:
                - Const pointer to the node dependenties
    """
    pGraphNode = hipGraphNode.fromPtr(NULL)
    pDependencies = hipGraphNode.fromPtr(NULL)
    _hipGraphAddMemFreeNode__retval = hipError_t(chip.hipGraphAddMemFreeNode(<chip.hipGraphNode**>&pGraphNode._ptr,
        ihipGraph.fromPyobj(graph).getElementPtr(),<chip.hipGraphNode**>&pDependencies._ptr,numDependencies,
        <void *>hip._util.types.Pointer.fromPyobj(dev_ptr)._ptr))
    return (_hipGraphAddMemFreeNode__retval,None if pGraphNode._ptr == NULL else pGraphNode,None if pDependencies._ptr == NULL else pDependencies)


@cython.embedsignature(True)
def hipGraphMemFreeNodeGetParams(object node, object dev_ptr):
    r"""Returns parameters for memory free node

    Warning:
        This API is marked as beta, meaning, while this is feature complete,
        it is still open to changes and may have outstanding issues.

    Args:
        node (`~.hipGraphNode`/`~.object`) -- *IN*:
            - Memory free node for a query

        dev_ptr (`~.hip._util.types.Pointer`/`~.object`) -- *OUT*:
            - Device pointer for the specified memory free node

    Returns:
        A `~.tuple` of size 1 that contains (in that order):

        * `~.hipError_t`: `~.hipSuccess`, `~.hipErrorInvalidValue`
    """
    _hipGraphMemFreeNodeGetParams__retval = hipError_t(chip.hipGraphMemFreeNodeGetParams(
        hipGraphNode.fromPyobj(node).getElementPtr(),
        <void *>hip._util.types.Pointer.fromPyobj(dev_ptr)._ptr))
    return (_hipGraphMemFreeNodeGetParams__retval,)


@cython.embedsignature(True)
def hipDeviceGetGraphMemAttribute(int device, object attr, object value):
    r"""Get the mem attribute for graphs.

    Warning:
        This API is marked as beta, meaning, while this is feature complete,
        it is still open to changes and may have outstanding issues.

    Args:
        device (`~.int`) -- *IN*:
            - device the attr is get for.

        attr (`~.hipGraphMemAttributeType`) -- *IN*:
            - attr to get.

        value (`~.hip._util.types.Pointer`/`~.object`) -- *OUT*:
            - value for specific attr.

    Returns:
        A `~.tuple` of size 1 that contains (in that order):

        * `~.hipError_t`: `~.hipSuccess`, `~.hipErrorInvalidDevice`
    """
    if not isinstance(attr,_hipGraphMemAttributeType__Base):
        raise TypeError("argument 'attr' must be of type '_hipGraphMemAttributeType__Base'")
    _hipDeviceGetGraphMemAttribute__retval = hipError_t(chip.hipDeviceGetGraphMemAttribute(device,attr.value,
        <void *>hip._util.types.Pointer.fromPyobj(value)._ptr))
    return (_hipDeviceGetGraphMemAttribute__retval,)


@cython.embedsignature(True)
def hipDeviceSetGraphMemAttribute(int device, object attr, object value):
    r"""Set the mem attribute for graphs.

    Warning:
        This API is marked as beta, meaning, while this is feature complete,
        it is still open to changes and may have outstanding issues.

    Args:
        device (`~.int`) -- *IN*:
            - device the attr is set for.

        attr (`~.hipGraphMemAttributeType`) -- *IN*:
            - attr to set.

        value (`~.hip._util.types.Pointer`/`~.object`) -- *IN*:
            - value for specific attr.

    Returns:
        A `~.tuple` of size 1 that contains (in that order):

        * `~.hipError_t`: `~.hipSuccess`, `~.hipErrorInvalidDevice`
    """
    if not isinstance(attr,_hipGraphMemAttributeType__Base):
        raise TypeError("argument 'attr' must be of type '_hipGraphMemAttributeType__Base'")
    _hipDeviceSetGraphMemAttribute__retval = hipError_t(chip.hipDeviceSetGraphMemAttribute(device,attr.value,
        <void *>hip._util.types.Pointer.fromPyobj(value)._ptr))
    return (_hipDeviceSetGraphMemAttribute__retval,)


@cython.embedsignature(True)
def hipDeviceGraphMemTrim(int device):
    r"""Free unused memory on specific device used for graph back to OS.

    Warning:
        This API is marked as beta, meaning, while this is feature complete,
        it is still open to changes and may have outstanding issues.

    Args:
        device (`~.int`) -- *IN*:
            - device the memory is used for graphs

    Returns:
        A `~.tuple` of size 1 that contains (in that order):

        * `~.hipError_t`: `~.hipSuccess`, `~.hipErrorInvalidDevice`
    """
    _hipDeviceGraphMemTrim__retval = hipError_t(chip.hipDeviceGraphMemTrim(device))
    return (_hipDeviceGraphMemTrim__retval,)


@cython.embedsignature(True)
def hipUserObjectCreate(object ptr, object destroy, unsigned int initialRefcount, unsigned int flags):
    r"""Create an instance of userObject to manage lifetime of a resource.

    Warning:
        This API is marked as beta, meaning, while this is feature complete,
        it is still open to changes and may have outstanding issues.

    Args:
        ptr (`~.hip._util.types.Pointer`/`~.object`) -- *IN*:
            - pointer to pass to destroy function.

        destroy (`~.hipHostFn_t`/`~.object`) -- *IN*:
            - destroy callback to remove resource.

        initialRefcount (`~.int`) -- *IN*:
            - reference to resource.

        flags (`~.int`) -- *IN*:
            - flags passed to API.

    Returns:
        A `~.tuple` of size 2 that contains (in that order):

        * `~.hipError_t`: `~.hipSuccess`, `~.hipErrorInvalidValue`
        * `~.hipUserObject`:
                - pointer to instace of userobj.
    """
    object_out = hipUserObject.fromPtr(NULL)
    _hipUserObjectCreate__retval = hipError_t(chip.hipUserObjectCreate(<chip.hipUserObject**>&object_out._ptr,
        <void *>hip._util.types.Pointer.fromPyobj(ptr)._ptr,
        hipHostFn_t.fromPyobj(destroy).getElementPtr(),initialRefcount,flags))
    return (_hipUserObjectCreate__retval,None if object_out._ptr == NULL else object_out)


@cython.embedsignature(True)
def hipUserObjectRelease(object object, unsigned int count):
    r"""Release number of references to resource.

    Warning:
        This API is marked as beta, meaning, while this is feature complete,
        it is still open to changes and may have outstanding issues.

    Args:
        object (`~.hipUserObject`/`~.object`) -- *IN*:
            - pointer to instace of userobj.

        count (`~.int`) -- *IN*:
            - reference to resource to be retained.

    Returns:
        A `~.tuple` of size 1 that contains (in that order):

        * `~.hipError_t`: `~.hipSuccess`, `~.hipErrorInvalidValue`
    """
    _hipUserObjectRelease__retval = hipError_t(chip.hipUserObjectRelease(
        hipUserObject.fromPyobj(object).getElementPtr(),count))
    return (_hipUserObjectRelease__retval,)


@cython.embedsignature(True)
def hipUserObjectRetain(object object, unsigned int count):
    r"""Retain number of references to resource.

    Warning:
        This API is marked as beta, meaning, while this is feature complete,
        it is still open to changes and may have outstanding issues.

    Args:
        object (`~.hipUserObject`/`~.object`) -- *IN*:
            - pointer to instace of userobj.

        count (`~.int`) -- *IN*:
            - reference to resource to be retained.

    Returns:
        A `~.tuple` of size 1 that contains (in that order):

        * `~.hipError_t`: `~.hipSuccess`, `~.hipErrorInvalidValue`
    """
    _hipUserObjectRetain__retval = hipError_t(chip.hipUserObjectRetain(
        hipUserObject.fromPyobj(object).getElementPtr(),count))
    return (_hipUserObjectRetain__retval,)


@cython.embedsignature(True)
def hipGraphRetainUserObject(object graph, object object, unsigned int count, unsigned int flags):
    r"""Retain user object for graphs.

    Warning:
        This API is marked as beta, meaning, while this is feature complete,
        it is still open to changes and may have outstanding issues.

    Args:
        graph (`~.ihipGraph`/`~.object`) -- *IN*:
            - pointer to graph to retain the user object for.

        object (`~.hipUserObject`/`~.object`) -- *IN*:
            - pointer to instace of userobj.

        count (`~.int`) -- *IN*:
            - reference to resource to be retained.

        flags (`~.int`) -- *IN*:
            - flags passed to API.

    Returns:
        A `~.tuple` of size 1 that contains (in that order):

        * `~.hipError_t`: `~.hipSuccess`, `~.hipErrorInvalidValue`
    """
    _hipGraphRetainUserObject__retval = hipError_t(chip.hipGraphRetainUserObject(
        ihipGraph.fromPyobj(graph).getElementPtr(),
        hipUserObject.fromPyobj(object).getElementPtr(),count,flags))
    return (_hipGraphRetainUserObject__retval,)


@cython.embedsignature(True)
def hipGraphReleaseUserObject(object graph, object object, unsigned int count):
    r"""Release user object from graphs.

    Warning:
        This API is marked as beta, meaning, while this is feature complete,
        it is still open to changes and may have outstanding issues.

    Args:
        graph (`~.ihipGraph`/`~.object`) -- *IN*:
            - pointer to graph to retain the user object for.

        object (`~.hipUserObject`/`~.object`) -- *IN*:
            - pointer to instace of userobj.

        count (`~.int`) -- *IN*:
            - reference to resource to be retained.

    Returns:
        A `~.tuple` of size 1 that contains (in that order):

        * `~.hipError_t`: `~.hipSuccess`, `~.hipErrorInvalidValue`
    """
    _hipGraphReleaseUserObject__retval = hipError_t(chip.hipGraphReleaseUserObject(
        ihipGraph.fromPyobj(graph).getElementPtr(),
        hipUserObject.fromPyobj(object).getElementPtr(),count))
    return (_hipGraphReleaseUserObject__retval,)


@cython.embedsignature(True)
def hipGraphDebugDotPrint(object graph, object path, unsigned int flags):
    r"""Write a DOT file describing graph structure.

    Warning:
        This API is marked as beta, meaning, while this is feature complete,
        it is still open to changes and may have outstanding issues.

    Args:
        graph (`~.ihipGraph`/`~.object`) -- *IN*:
            - graph object for which DOT file has to be generated.

        path (`~.hip._util.types.CStr`/`~.object`) -- *IN*:
            - path to write the DOT file.

        flags (`~.int`) -- *IN*:
            - Flags from hipGraphDebugDotFlags to get additional node information.

    Returns:
        A `~.tuple` of size 1 that contains (in that order):

        * `~.hipError_t`: `~.hipSuccess`, `~.hipErrorInvalidValue`, `~.hipErrorOperatingSystem`
    """
    _hipGraphDebugDotPrint__retval = hipError_t(chip.hipGraphDebugDotPrint(
        ihipGraph.fromPyobj(graph).getElementPtr(),
        <const char *>hip._util.types.CStr.fromPyobj(path)._ptr,flags))
    return (_hipGraphDebugDotPrint__retval,)


@cython.embedsignature(True)
def hipGraphKernelNodeCopyAttributes(object hSrc, object hDst):
    r"""Copies attributes from source node to destination node.

    Copies attributes from source node to destination node.
    Both node must have the same context.

    Warning:
        This API is marked as beta, meaning, while this is feature complete,
        it is still open to changes and may have outstanding issues.

    Args:
        hSrc (`~.hipGraphNode`/`~.object`) -- *IN*:
            - Source node.
            For list of attributes see `~.hipKernelNodeAttrID`.

        hDst (`~.hipGraphNode`/`~.object`) -- *OUT*:
            - Destination node.

    Returns:
        A `~.tuple` of size 1 that contains (in that order):

        * `~.hipError_t`: `~.hipSuccess`, `~.hipErrorInvalidContext`
    """
    _hipGraphKernelNodeCopyAttributes__retval = hipError_t(chip.hipGraphKernelNodeCopyAttributes(
        hipGraphNode.fromPyobj(hSrc).getElementPtr(),
        hipGraphNode.fromPyobj(hDst).getElementPtr()))
    return (_hipGraphKernelNodeCopyAttributes__retval,)


@cython.embedsignature(True)
def hipGraphNodeSetEnabled(object hGraphExec, object hNode, unsigned int isEnabled):
    r"""Enables or disables the specified node in the given graphExec

    Sets hNode to be either enabled or disabled. Disabled nodes are functionally equivalent
    to empty nodes until they are reenabled. Existing node parameters are not affected by
    disabling/enabling the node.

    The node is identified by the corresponding hNode in the non-executable graph, from which the
    executable graph was instantiated.

    hNode must not have been removed from the original graph.

    Note:
        Currently only kernel, memset and memcpy nodes are supported.

    Warning:
        This API is marked as beta, meaning, while this is feature complete,
        it is still open to changes and may have outstanding issues.

    Args:
        hGraphExec (`~.hipGraphExec`/`~.object`) -- *IN*:
            - The executable graph in which to set the specified node.

        hNode (`~.hipGraphNode`/`~.object`) -- *IN*:
            - Node from the graph from which graphExec was instantiated.

        isEnabled (`~.int`) -- *IN*:
            - Node is enabled if != 0, otherwise the node is disabled.

    Returns:
        A `~.tuple` of size 1 that contains (in that order):

        * `~.hipError_t`: `~.hipSuccess`, `~.hipErrorInvalidValue`,
    """
    _hipGraphNodeSetEnabled__retval = hipError_t(chip.hipGraphNodeSetEnabled(
        hipGraphExec.fromPyobj(hGraphExec).getElementPtr(),
        hipGraphNode.fromPyobj(hNode).getElementPtr(),isEnabled))
    return (_hipGraphNodeSetEnabled__retval,)


@cython.embedsignature(True)
def hipGraphNodeGetEnabled(object hGraphExec, object hNode):
    r"""Query whether a node in the given graphExec is enabled

    Sets isEnabled to 1 if hNode is enabled, or 0 if it is disabled.

    The node is identified by the corresponding node in the non-executable graph, from which the
    executable graph was instantiated.

    hNode must not have been removed from the original graph.

    Note:
        Currently only kernel, memset and memcpy nodes are supported.

    Warning:
        This API is marked as beta, meaning, while this is feature complete,
        it is still open to changes and may have outstanding issues.

    Args:
        hGraphExec (`~.hipGraphExec`/`~.object`) -- *IN*:
            - The executable graph in which to set the specified node.

        hNode (`~.hipGraphNode`/`~.object`) -- *IN*:
            - Node from the graph from which graphExec was instantiated.

    Returns:
        A `~.tuple` of size 2 that contains (in that order):

        * `~.hipError_t`: `~.hipSuccess`, `~.hipErrorInvalidValue`
        * `~.int`:
                - Location to return the enabled status of the node.
    """
    cdef unsigned int isEnabled
    _hipGraphNodeGetEnabled__retval = hipError_t(chip.hipGraphNodeGetEnabled(
        hipGraphExec.fromPyobj(hGraphExec).getElementPtr(),
        hipGraphNode.fromPyobj(hNode).getElementPtr(),&isEnabled))
    return (_hipGraphNodeGetEnabled__retval,isEnabled)


@cython.embedsignature(True)
def hipGraphAddExternalSemaphoresWaitNode(object graph, unsigned long numDependencies, object nodeParams):
    r"""Creates a external semaphor wait node and adds it to a graph.

    Warning:
        This API is marked as beta, meaning, while this is feature complete,
        it is still open to changes and may have outstanding issues.

    Args:
        graph (`~.ihipGraph`/`~.object`) -- *IN*:
            - instance of the graph to add the created node.

        numDependencies (`~.int`) -- *IN*:
            - the number of the dependencies.

        nodeParams (`~.hipExternalSemaphoreWaitNodeParams`/`~.object`) -- *IN*:
            -pointer to the parameters.

    Returns:
        A `~.tuple` of size 3 that contains (in that order):

        * `~.hipError_t`: `~.hipSuccess`, `~.hipErrorInvalidValue`
        * `~.hipGraphNode`:
                - pointer to the graph node to create.
        * `~.hipGraphNode`:
                - const pointer to the dependencies on the memset execution node.
    """
    pGraphNode = hipGraphNode.fromPtr(NULL)
    pDependencies = hipGraphNode.fromPtr(NULL)
    _hipGraphAddExternalSemaphoresWaitNode__retval = hipError_t(chip.hipGraphAddExternalSemaphoresWaitNode(<chip.hipGraphNode**>&pGraphNode._ptr,
        ihipGraph.fromPyobj(graph).getElementPtr(),<chip.hipGraphNode**>&pDependencies._ptr,numDependencies,
        hipExternalSemaphoreWaitNodeParams.fromPyobj(nodeParams).getElementPtr()))
    return (_hipGraphAddExternalSemaphoresWaitNode__retval,None if pGraphNode._ptr == NULL else pGraphNode,None if pDependencies._ptr == NULL else pDependencies)


@cython.embedsignature(True)
def hipGraphAddExternalSemaphoresSignalNode(object graph, unsigned long numDependencies, object nodeParams):
    r"""Creates a external semaphor signal node and adds it to a graph.

    Warning:
        This API is marked as beta, meaning, while this is feature complete,
        it is still open to changes and may have outstanding issues.

    Args:
        graph (`~.ihipGraph`/`~.object`) -- *IN*:
            - instance of the graph to add the created node.

        numDependencies (`~.int`) -- *IN*:
            - the number of the dependencies.

        nodeParams (`~.hipExternalSemaphoreSignalNodeParams`/`~.object`) -- *IN*:
            -pointer to the parameters.

    Returns:
        A `~.tuple` of size 3 that contains (in that order):

        * `~.hipError_t`: `~.hipSuccess`, `~.hipErrorInvalidValue`
        * `~.hipGraphNode`:
                - pointer to the graph node to create.
        * `~.hipGraphNode`:
                - const pointer to the dependencies on the memset execution node.
    """
    pGraphNode = hipGraphNode.fromPtr(NULL)
    pDependencies = hipGraphNode.fromPtr(NULL)
    _hipGraphAddExternalSemaphoresSignalNode__retval = hipError_t(chip.hipGraphAddExternalSemaphoresSignalNode(<chip.hipGraphNode**>&pGraphNode._ptr,
        ihipGraph.fromPyobj(graph).getElementPtr(),<chip.hipGraphNode**>&pDependencies._ptr,numDependencies,
        hipExternalSemaphoreSignalNodeParams.fromPyobj(nodeParams).getElementPtr()))
    return (_hipGraphAddExternalSemaphoresSignalNode__retval,None if pGraphNode._ptr == NULL else pGraphNode,None if pDependencies._ptr == NULL else pDependencies)


@cython.embedsignature(True)
def hipGraphExternalSemaphoresSignalNodeSetParams(object hNode, object nodeParams):
    r"""Updates node parameters in the external semaphore signal node.

    Warning:
        This API is marked as beta, meaning, while this is feature complete,
        it is still open to changes and may have outstanding issues.

    Args:
        hNode (`~.hipGraphNode`/`~.object`) -- *IN*:
            - Node from the graph from which graphExec was instantiated.

        nodeParams (`~.hipExternalSemaphoreSignalNodeParams`/`~.object`) -- *IN*:
            - Pointer to the params to be set.

    Returns:
        A `~.tuple` of size 1 that contains (in that order):

        * `~.hipError_t`: `~.hipSuccess`, `~.hipErrorInvalidValue`
    """
    _hipGraphExternalSemaphoresSignalNodeSetParams__retval = hipError_t(chip.hipGraphExternalSemaphoresSignalNodeSetParams(
        hipGraphNode.fromPyobj(hNode).getElementPtr(),
        hipExternalSemaphoreSignalNodeParams.fromPyobj(nodeParams).getElementPtr()))
    return (_hipGraphExternalSemaphoresSignalNodeSetParams__retval,)


@cython.embedsignature(True)
def hipGraphExternalSemaphoresWaitNodeSetParams(object hNode, object nodeParams):
    r"""Updates node parameters in the external semaphore wait node.

    Warning:
        This API is marked as beta, meaning, while this is feature complete,
        it is still open to changes and may have outstanding issues.

    Args:
        hNode (`~.hipGraphNode`/`~.object`) -- *IN*:
            - Node from the graph from which graphExec was instantiated.

        nodeParams (`~.hipExternalSemaphoreWaitNodeParams`/`~.object`) -- *IN*:
            - Pointer to the params to be set.

    Returns:
        A `~.tuple` of size 1 that contains (in that order):

        * `~.hipError_t`: `~.hipSuccess`, `~.hipErrorInvalidValue`
    """
    _hipGraphExternalSemaphoresWaitNodeSetParams__retval = hipError_t(chip.hipGraphExternalSemaphoresWaitNodeSetParams(
        hipGraphNode.fromPyobj(hNode).getElementPtr(),
        hipExternalSemaphoreWaitNodeParams.fromPyobj(nodeParams).getElementPtr()))
    return (_hipGraphExternalSemaphoresWaitNodeSetParams__retval,)


@cython.embedsignature(True)
def hipGraphExternalSemaphoresSignalNodeGetParams(object hNode, object params_out):
    r"""Returns external semaphore signal node params.

    Warning:
        This API is marked as beta, meaning, while this is feature complete,
        it is still open to changes and may have outstanding issues.

    Args:
        hNode (`~.hipGraphNode`/`~.object`) -- *IN*:
            - Node from the graph from which graphExec was instantiated.

        params_out (`~.hipExternalSemaphoreSignalNodeParams`/`~.object`) -- *OUT*:
            - Pointer to params.

    Returns:
        A `~.tuple` of size 1 that contains (in that order):

        * `~.hipError_t`: `~.hipSuccess`, `~.hipErrorInvalidValue`
    """
    _hipGraphExternalSemaphoresSignalNodeGetParams__retval = hipError_t(chip.hipGraphExternalSemaphoresSignalNodeGetParams(
        hipGraphNode.fromPyobj(hNode).getElementPtr(),
        hipExternalSemaphoreSignalNodeParams.fromPyobj(params_out).getElementPtr()))
    return (_hipGraphExternalSemaphoresSignalNodeGetParams__retval,)


@cython.embedsignature(True)
def hipGraphExternalSemaphoresWaitNodeGetParams(object hNode, object params_out):
    r"""Returns external semaphore wait node params.

    Warning:
        This API is marked as beta, meaning, while this is feature complete,
        it is still open to changes and may have outstanding issues.

    Args:
        hNode (`~.hipGraphNode`/`~.object`) -- *IN*:
            - Node from the graph from which graphExec was instantiated.

        params_out (`~.hipExternalSemaphoreWaitNodeParams`/`~.object`) -- *OUT*:
            - Pointer to params.

    Returns:
        A `~.tuple` of size 1 that contains (in that order):

        * `~.hipError_t`: `~.hipSuccess`, `~.hipErrorInvalidValue`
    """
    _hipGraphExternalSemaphoresWaitNodeGetParams__retval = hipError_t(chip.hipGraphExternalSemaphoresWaitNodeGetParams(
        hipGraphNode.fromPyobj(hNode).getElementPtr(),
        hipExternalSemaphoreWaitNodeParams.fromPyobj(params_out).getElementPtr()))
    return (_hipGraphExternalSemaphoresWaitNodeGetParams__retval,)


@cython.embedsignature(True)
def hipGraphExecExternalSemaphoresSignalNodeSetParams(object hGraphExec, object hNode, object nodeParams):
    r"""Updates node parameters in the external semaphore signal node in the given graphExec.

    Warning:
        This API is marked as beta, meaning, while this is feature complete,
        it is still open to changes and may have outstanding issues.

    Args:
        hGraphExec (`~.hipGraphExec`/`~.object`) -- *IN*:
            - The executable graph in which to set the specified node.

        hNode (`~.hipGraphNode`/`~.object`) -- *IN*:
            - Node from the graph from which graphExec was instantiated.

        nodeParams (`~.hipExternalSemaphoreSignalNodeParams`/`~.object`) -- *IN*:
            - Pointer to the params to be set.

    Returns:
        A `~.tuple` of size 1 that contains (in that order):

        * `~.hipError_t`: `~.hipSuccess`, `~.hipErrorInvalidValue`
    """
    _hipGraphExecExternalSemaphoresSignalNodeSetParams__retval = hipError_t(chip.hipGraphExecExternalSemaphoresSignalNodeSetParams(
        hipGraphExec.fromPyobj(hGraphExec).getElementPtr(),
        hipGraphNode.fromPyobj(hNode).getElementPtr(),
        hipExternalSemaphoreSignalNodeParams.fromPyobj(nodeParams).getElementPtr()))
    return (_hipGraphExecExternalSemaphoresSignalNodeSetParams__retval,)


@cython.embedsignature(True)
def hipGraphExecExternalSemaphoresWaitNodeSetParams(object hGraphExec, object hNode, object nodeParams):
    r"""Updates node parameters in the external semaphore wait node in the given graphExec.

    Warning:
        This API is marked as beta, meaning, while this is feature complete,
        it is still open to changes and may have outstanding issues.

    Args:
        hGraphExec (`~.hipGraphExec`/`~.object`) -- *IN*:
            - The executable graph in which to set the specified node.

        hNode (`~.hipGraphNode`/`~.object`) -- *IN*:
            - Node from the graph from which graphExec was instantiated.

        nodeParams (`~.hipExternalSemaphoreWaitNodeParams`/`~.object`) -- *IN*:
            - Pointer to the params to be set.

    Returns:
        A `~.tuple` of size 1 that contains (in that order):

        * `~.hipError_t`: `~.hipSuccess`, `~.hipErrorInvalidValue`
    """
    _hipGraphExecExternalSemaphoresWaitNodeSetParams__retval = hipError_t(chip.hipGraphExecExternalSemaphoresWaitNodeSetParams(
        hipGraphExec.fromPyobj(hGraphExec).getElementPtr(),
        hipGraphNode.fromPyobj(hNode).getElementPtr(),
        hipExternalSemaphoreWaitNodeParams.fromPyobj(nodeParams).getElementPtr()))
    return (_hipGraphExecExternalSemaphoresWaitNodeSetParams__retval,)


@cython.embedsignature(True)
def hipDrvGraphAddMemsetNode(object hGraph, unsigned long numDependencies, object memsetParams, object ctx):
    r"""Creates a memset node and adds it to a graph.

    Warning:
        This API is marked as beta, meaning, while this is feature complete,
        it is still open to changes and may have outstanding issues.

    Args:
        hGraph (`~.ihipGraph`/`~.object`) -- *IN*:
            - instance of graph to add the created node to.

        numDependencies (`~.int`) -- *IN*:
            - number of the dependencies.

        memsetParams (`~.HIP_MEMSET_NODE_PARAMS`/`~.object`) -- *IN*:
            - const pointer to the parameters for the memory set.

        ctx (`~.ihipCtx_t`/`~.object`) -- *IN*:
            - cotext related to current device.

    Returns:
        A `~.tuple` of size 3 that contains (in that order):

        * `~.hipError_t`: `~.hipSuccess`, `~.hipErrorInvalidValue`
        * `~.hipGraphNode`:
                - pointer to graph node to create.
        * `~.hipGraphNode`:
                - const pointer to the dependencies on the memset execution node.
    """
    phGraphNode = hipGraphNode.fromPtr(NULL)
    dependencies = hipGraphNode.fromPtr(NULL)
    _hipDrvGraphAddMemsetNode__retval = hipError_t(chip.hipDrvGraphAddMemsetNode(<chip.hipGraphNode**>&phGraphNode._ptr,
        ihipGraph.fromPyobj(hGraph).getElementPtr(),<chip.hipGraphNode**>&dependencies._ptr,numDependencies,
        HIP_MEMSET_NODE_PARAMS.fromPyobj(memsetParams).getElementPtr(),
        ihipCtx_t.fromPyobj(ctx).getElementPtr()))
    return (_hipDrvGraphAddMemsetNode__retval,None if phGraphNode._ptr == NULL else phGraphNode,None if dependencies._ptr == NULL else dependencies)


@cython.embedsignature(True)
def hipMemAddressFree(object devPtr, unsigned long size):
    r"""Frees an address range reservation made via hipMemAddressReserve

    Warning:
        This API is marked as beta, meaning, while this is feature complete,
        it is still open to changes and may have outstanding issues.

    Note:
        This API is implemented on Linux, under development on Windows.

    Args:
        devPtr (`~.hip._util.types.Pointer`/`~.object`) -- *IN*:
            - starting address of the range.

        size (`~.int`) -- *IN*:
            - size of the range.

    Returns:
        A `~.tuple` of size 1 that contains (in that order):

        * `~.hipError_t`: `~.hipSuccess`, `~.hipErrorInvalidValue`, `~.hipErrorNotSupported`
    """
    _hipMemAddressFree__retval = hipError_t(chip.hipMemAddressFree(
        <void *>hip._util.types.Pointer.fromPyobj(devPtr)._ptr,size))
    return (_hipMemAddressFree__retval,)


@cython.embedsignature(True)
def hipMemAddressReserve(unsigned long size, unsigned long alignment, object addr, unsigned long long flags):
    r"""Reserves an address range

    Warning:
        This API is marked as beta, meaning, while this is feature complete,
        it is still open to changes and may have outstanding issues.

    Note:
        This API is implemented on Linux, under development on Windows.

    Args:
        size (`~.int`) -- *IN*:
            - size of the reservation.

        alignment (`~.int`) -- *IN*:
            - alignment of the address.

        addr (`~.hip._util.types.Pointer`/`~.object`) -- *IN*:
            - requested starting address of the range.

        flags (`~.int`) -- *IN*:
            - currently unused, must be zero.

    Returns:
        A `~.tuple` of size 2 that contains (in that order):

        * `~.hipError_t`: `~.hipSuccess`, `~.hipErrorInvalidValue`, `~.hipErrorNotSupported`
        * `~.hip._util.types.Pointer`/`~.object`:
                - starting address of the reserved range.
    """
    ptr = hip._util.types.Pointer.fromPtr(NULL)
    _hipMemAddressReserve__retval = hipError_t(chip.hipMemAddressReserve(
        <void **>&ptr._ptr,size,alignment,
        <void *>hip._util.types.Pointer.fromPyobj(addr)._ptr,flags))
    return (_hipMemAddressReserve__retval,None if ptr._ptr == NULL else ptr)


@cython.embedsignature(True)
def hipMemCreate(unsigned long size, object prop, unsigned long long flags):
    r"""Creates a memory allocation described by the properties and size

    Warning:
        This API is marked as beta, meaning, while this is feature complete,
        it is still open to changes and may have outstanding issues.

    Note:
        This API is implemented on Linux, under development on Windows.

    Args:
        size (`~.int`) -- *IN*:
            - size of the allocation.

        prop (`~.hipMemAllocationProp`/`~.object`) -- *IN*:
            - properties of the allocation.

        flags (`~.int`) -- *IN*:
            - currently unused, must be zero.

    Returns:
        A `~.tuple` of size 2 that contains (in that order):

        * `~.hipError_t`: `~.hipSuccess`, `~.hipErrorInvalidValue`, `~.hipErrorNotSupported`
        * `~.ihipMemGenericAllocationHandle`:
                - value of the returned handle.
    """
    handle = ihipMemGenericAllocationHandle.fromPtr(NULL)
    _hipMemCreate__retval = hipError_t(chip.hipMemCreate(<chip.ihipMemGenericAllocationHandle**>&handle._ptr,size,
        hipMemAllocationProp.fromPyobj(prop).getElementPtr(),flags))
    return (_hipMemCreate__retval,None if handle._ptr == NULL else handle)


@cython.embedsignature(True)
def hipMemExportToShareableHandle(object shareableHandle, object handle, object handleType, unsigned long long flags):
    r"""Exports an allocation to a requested shareable handle type.

    Warning:
        This API is marked as beta, meaning, while this is feature complete,
        it is still open to changes and may have outstanding issues.

    Note:
        This API is implemented on Linux, under development on Windows.

    Args:
        shareableHandle (`~.hip._util.types.Pointer`/`~.object`) -- *OUT*:
            - value of the returned handle.

        handle (`~.ihipMemGenericAllocationHandle`/`~.object`) -- *IN*:
            - handle to share.

        handleType (`~.hipMemAllocationHandleType`) -- *IN*:
            - type of the shareable handle.

        flags (`~.int`) -- *IN*:
            - currently unused, must be zero.

    Returns:
        A `~.tuple` of size 1 that contains (in that order):

        * `~.hipError_t`: `~.hipSuccess`, `~.hipErrorInvalidValue`, `~.hipErrorNotSupported`
    """
    if not isinstance(handleType,_hipMemAllocationHandleType__Base):
        raise TypeError("argument 'handleType' must be of type '_hipMemAllocationHandleType__Base'")
    _hipMemExportToShareableHandle__retval = hipError_t(chip.hipMemExportToShareableHandle(
        <void *>hip._util.types.Pointer.fromPyobj(shareableHandle)._ptr,
        ihipMemGenericAllocationHandle.fromPyobj(handle).getElementPtr(),handleType.value,flags))
    return (_hipMemExportToShareableHandle__retval,)


@cython.embedsignature(True)
def hipMemGetAccess(object location, object ptr):
    r"""Get the access flags set for the given location and ptr.

    Warning:
        This API is marked as beta, meaning, while this is feature complete,
        it is still open to changes and may have outstanding issues.

    Note:
        This API is implemented on Linux, under development on Windows.

    Args:
        location (`~.hipMemLocation`/`~.object`) -- *IN*:
            - target location.

        ptr (`~.hip._util.types.Pointer`/`~.object`) -- *IN*:
            - address to check the access flags.

    Returns:
        A `~.tuple` of size 2 that contains (in that order):

        * `~.hipError_t`: `~.hipSuccess`, `~.hipErrorInvalidValue`, `~.hipErrorNotSupported`
        * `~.int`:
                - flags for this location.
    """
    cdef unsigned long long flags
    _hipMemGetAccess__retval = hipError_t(chip.hipMemGetAccess(&flags,
        hipMemLocation.fromPyobj(location).getElementPtr(),
        <void *>hip._util.types.Pointer.fromPyobj(ptr)._ptr))
    return (_hipMemGetAccess__retval,flags)


@cython.embedsignature(True)
def hipMemGetAllocationGranularity(object prop, object option):
    r"""Calculates either the minimal or recommended granularity.

    Warning:
        This API is marked as beta, meaning, while this is feature complete,
        it is still open to changes and may have outstanding issues.

    Note:
        This API is implemented on Linux, under development on Windows.

    Args:
        prop (`~.hipMemAllocationProp`/`~.object`) -- *IN*:
            - location properties.

        option (`~.hipMemAllocationGranularity_flags`) -- *IN*:
            - determines which granularity to return.

    Returns:
        A `~.tuple` of size 2 that contains (in that order):

        * `~.hipError_t`: `~.hipSuccess`, `~.hipErrorInvalidValue`, `~.hipErrorNotSupported`
        * `~.int`:
                - returned granularity.
    """
    cdef unsigned long granularity
    if not isinstance(option,_hipMemAllocationGranularity_flags__Base):
        raise TypeError("argument 'option' must be of type '_hipMemAllocationGranularity_flags__Base'")
    _hipMemGetAllocationGranularity__retval = hipError_t(chip.hipMemGetAllocationGranularity(&granularity,
        hipMemAllocationProp.fromPyobj(prop).getElementPtr(),option.value))
    return (_hipMemGetAllocationGranularity__retval,granularity)


@cython.embedsignature(True)
def hipMemGetAllocationPropertiesFromHandle(object prop, object handle):
    r"""Retrieve the property structure of the given handle.

    Warning:
        This API is marked as beta, meaning, while this is feature complete,
        it is still open to changes and may have outstanding issues.

    Note:
        This API is implemented on Linux under development on Windows.

    Args:
        prop (`~.hipMemAllocationProp`/`~.object`) -- *OUT*:
            - properties of the given handle.

        handle (`~.ihipMemGenericAllocationHandle`/`~.object`) -- *IN*:
            - handle to perform the query on.

    Returns:
        A `~.tuple` of size 1 that contains (in that order):

        * `~.hipError_t`: `~.hipSuccess`, `~.hipErrorInvalidValue`, `~.hipErrorNotSupported`
    """
    _hipMemGetAllocationPropertiesFromHandle__retval = hipError_t(chip.hipMemGetAllocationPropertiesFromHandle(
        hipMemAllocationProp.fromPyobj(prop).getElementPtr(),
        ihipMemGenericAllocationHandle.fromPyobj(handle).getElementPtr()))
    return (_hipMemGetAllocationPropertiesFromHandle__retval,)


@cython.embedsignature(True)
def hipMemImportFromShareableHandle(object osHandle, object shHandleType):
    r"""Imports an allocation from a requested shareable handle type.

    Warning:
        This API is marked as beta, meaning, while this is feature complete,
        it is still open to changes and may have outstanding issues.

    Note:
        This API is implemented on Linux, under development on Windows.

    Args:
        osHandle (`~.hip._util.types.Pointer`/`~.object`) -- *IN*:
            - shareable handle representing the memory allocation.

        shHandleType (`~.hipMemAllocationHandleType`) -- *IN*:
            - handle type.

    Returns:
        A `~.tuple` of size 2 that contains (in that order):

        * `~.hipError_t`: `~.hipSuccess`, `~.hipErrorInvalidValue`, `~.hipErrorNotSupported`
        * `~.ihipMemGenericAllocationHandle`:
                - returned value.
    """
    handle = ihipMemGenericAllocationHandle.fromPtr(NULL)
    if not isinstance(shHandleType,_hipMemAllocationHandleType__Base):
        raise TypeError("argument 'shHandleType' must be of type '_hipMemAllocationHandleType__Base'")
    _hipMemImportFromShareableHandle__retval = hipError_t(chip.hipMemImportFromShareableHandle(<chip.ihipMemGenericAllocationHandle**>&handle._ptr,
        <void *>hip._util.types.Pointer.fromPyobj(osHandle)._ptr,shHandleType.value))
    return (_hipMemImportFromShareableHandle__retval,None if handle._ptr == NULL else handle)


@cython.embedsignature(True)
def hipMemMap(object ptr, unsigned long size, unsigned long offset, object handle, unsigned long long flags):
    r"""Maps an allocation handle to a reserved virtual address range.

    Warning:
        This API is marked as beta, meaning, while this is feature complete,
        it is still open to changes and may have outstanding issues.

    Note:
        This API is implemented on Linux, under development on Windows.

    Args:
        ptr (`~.hip._util.types.Pointer`/`~.object`) -- *IN*:
            - address where the memory will be mapped.

        size (`~.int`) -- *IN*:
            - size of the mapping.

        offset (`~.int`) -- *IN*:
            - offset into the memory, currently must be zero.

        handle (`~.ihipMemGenericAllocationHandle`/`~.object`) -- *IN*:
            - memory allocation to be mapped.

        flags (`~.int`) -- *IN*:
            - currently unused, must be zero.

    Returns:
        A `~.tuple` of size 1 that contains (in that order):

        * `~.hipError_t`: `~.hipSuccess`, `~.hipErrorInvalidValue`, `~.hipErrorNotSupported`
    """
    _hipMemMap__retval = hipError_t(chip.hipMemMap(
        <void *>hip._util.types.Pointer.fromPyobj(ptr)._ptr,size,offset,
        ihipMemGenericAllocationHandle.fromPyobj(handle).getElementPtr(),flags))
    return (_hipMemMap__retval,)


@cython.embedsignature(True)
def hipMemMapArrayAsync(object mapInfoList, unsigned int count, object stream):
    r"""Maps or unmaps subregions of sparse HIP arrays and sparse HIP mipmapped arrays.

    Warning:
        This API is marked as beta, meaning, while this is feature complete,
        it is still open to changes and may have outstanding issues.

    Note:
        This API is implemented on Linux, under development on Windows.

    Args:
        mapInfoList (`~.hipArrayMapInfo`/`~.object`) -- *IN*:
            - list of hipArrayMapInfo.

        count (`~.int`) -- *IN*:
            - number of hipArrayMapInfo in mapInfoList.

        stream (`~.ihipStream_t`/`~.object`) -- *IN*:
            - stream identifier for the stream to use for map or unmap operations.

    Returns:
        A `~.tuple` of size 1 that contains (in that order):

        * `~.hipError_t`: `~.hipSuccess`, `~.hipErrorInvalidValue`, `~.hipErrorNotSupported`
    """
    _hipMemMapArrayAsync__retval = hipError_t(chip.hipMemMapArrayAsync(
        hipArrayMapInfo.fromPyobj(mapInfoList).getElementPtr(),count,
        ihipStream_t.fromPyobj(stream).getElementPtr()))
    return (_hipMemMapArrayAsync__retval,)


@cython.embedsignature(True)
def hipMemRelease(object handle):
    r"""Release a memory handle representing a memory allocation which was previously allocated through hipMemCreate.

    Warning:
        This API is marked as beta, meaning, while this is feature complete,
        it is still open to changes and may have outstanding issues.

    Note:
        This API is implemented on Linux, under development on Windows.

    Args:
        handle (`~.ihipMemGenericAllocationHandle`/`~.object`) -- *IN*:
            - handle of the memory allocation.

    Returns:
        A `~.tuple` of size 1 that contains (in that order):

        * `~.hipError_t`: `~.hipSuccess`, `~.hipErrorInvalidValue`, `~.hipErrorNotSupported`
    """
    _hipMemRelease__retval = hipError_t(chip.hipMemRelease(
        ihipMemGenericAllocationHandle.fromPyobj(handle).getElementPtr()))
    return (_hipMemRelease__retval,)


@cython.embedsignature(True)
def hipMemRetainAllocationHandle(object addr):
    r"""Returns the allocation handle of the backing memory allocation given the address.

    Warning:
        This API is marked as beta, meaning, while this is feature complete,
        it is still open to changes and may have outstanding issues.

    Note:
        This API is implemented on Linux, under development on Windows.

    Args:
        addr (`~.hip._util.types.Pointer`/`~.object`) -- *IN*:
            - address to look up.

    Returns:
        A `~.tuple` of size 2 that contains (in that order):

        * `~.hipError_t`: `~.hipSuccess`, `~.hipErrorInvalidValue`, `~.hipErrorNotSupported`
        * `~.ihipMemGenericAllocationHandle`:
                - handle representing addr.
    """
    handle = ihipMemGenericAllocationHandle.fromPtr(NULL)
    _hipMemRetainAllocationHandle__retval = hipError_t(chip.hipMemRetainAllocationHandle(<chip.ihipMemGenericAllocationHandle**>&handle._ptr,
        <void *>hip._util.types.Pointer.fromPyobj(addr)._ptr))
    return (_hipMemRetainAllocationHandle__retval,None if handle._ptr == NULL else handle)


@cython.embedsignature(True)
def hipMemSetAccess(object ptr, unsigned long size, object desc, unsigned long count):
    r"""Set the access flags for each location specified in desc for the given virtual address range.

    Warning:
        This API is marked as beta, meaning, while this is feature complete,
        it is still open to changes and may have outstanding issues.

    Note:
        This API is implemented on Linux, under development on Windows.

    Args:
        ptr (`~.hip._util.types.Pointer`/`~.object`) -- *IN*:
            - starting address of the virtual address range.

        size (`~.int`) -- *IN*:
            - size of the range.

        desc (`~.hipMemAccessDesc`/`~.object`) -- *IN*:
            - array of hipMemAccessDesc.

        count (`~.int`) -- *IN*:
            - number of hipMemAccessDesc in desc.

    Returns:
        A `~.tuple` of size 1 that contains (in that order):

        * `~.hipError_t`: `~.hipSuccess`, `~.hipErrorInvalidValue`, `~.hipErrorNotSupported`
    """
    _hipMemSetAccess__retval = hipError_t(chip.hipMemSetAccess(
        <void *>hip._util.types.Pointer.fromPyobj(ptr)._ptr,size,
        hipMemAccessDesc.fromPyobj(desc).getElementPtr(),count))
    return (_hipMemSetAccess__retval,)


@cython.embedsignature(True)
def hipMemUnmap(object ptr, unsigned long size):
    r"""Unmap memory allocation of a given address range.

    Warning:
        This API is marked as beta, meaning, while this is feature complete,
        it is still open to changes and may have outstanding issues.

    Note:
        This API is implemented on Linux, under development on Windows.

    Args:
        ptr (`~.hip._util.types.Pointer`/`~.object`) -- *IN*:
            - starting address of the range to unmap.

        size (`~.int`) -- *IN*:
            - size of the virtual address range.

    Returns:
        A `~.tuple` of size 1 that contains (in that order):

        * `~.hipError_t`: `~.hipSuccess`, `~.hipErrorInvalidValue`, `~.hipErrorNotSupported`
    """
    _hipMemUnmap__retval = hipError_t(chip.hipMemUnmap(
        <void *>hip._util.types.Pointer.fromPyobj(ptr)._ptr,size))
    return (_hipMemUnmap__retval,)


@cython.embedsignature(True)
def hipGraphicsMapResources(int count, object stream):
    r"""Maps a graphics resource for access.

    Args:
        count (`~.int`) -- *IN*:
            - Number of resources to map.

        stream (`~.ihipStream_t`/`~.object`) -- *IN*:
            - Stream for synchronization.

    Returns:
        A `~.tuple` of size 2 that contains (in that order):

        * `~.hipError_t`: `~.hipSuccess`, `~.hipErrorInvalidValue`, `~.hipErrorUnknown`, `~.hipErrorInvalidResourceHandle`
        * `~._hipGraphicsResource`:
                - Pointer of resources to map.
    """
    resources = _hipGraphicsResource.fromPtr(NULL)
    _hipGraphicsMapResources__retval = hipError_t(chip.hipGraphicsMapResources(count,<chip._hipGraphicsResource**>&resources._ptr,
        ihipStream_t.fromPyobj(stream).getElementPtr()))
    return (_hipGraphicsMapResources__retval,None if resources._ptr == NULL else resources)


@cython.embedsignature(True)
def hipGraphicsSubResourceGetMappedArray(object resource, unsigned int arrayIndex, unsigned int mipLevel):
    r"""Get an array through which to access a subresource of a mapped graphics resource.

    Note:
        In this API, the value of arrayIndex higher than zero is currently not supported.

    Args:
        resource (`~._hipGraphicsResource`/`~.object`) -- *IN*:
            - Mapped resource to access.

        arrayIndex (`~.int`) -- *IN*:
            - Array index for the subresource to access.

        mipLevel (`~.int`) -- *IN*:
            - Mipmap level for the subresource to access.

    Returns:
        A `~.tuple` of size 2 that contains (in that order):

        * `~.hipError_t`: `~.hipSuccess`, `~.hipErrorInvalidValue`
        * `~.hipArray`:
                - Pointer of array through which a subresource of resource may be accessed.
    """
    array = hipArray.fromPtr(NULL)
    _hipGraphicsSubResourceGetMappedArray__retval = hipError_t(chip.hipGraphicsSubResourceGetMappedArray(<chip.hipArray**>&array._ptr,
        _hipGraphicsResource.fromPyobj(resource).getElementPtr(),arrayIndex,mipLevel))
    return (_hipGraphicsSubResourceGetMappedArray__retval,None if array._ptr == NULL else array)


@cython.embedsignature(True)
def hipGraphicsResourceGetMappedPointer(object resource):
    r"""Gets device accessible address of a graphics resource.

    Args:
        resource (`~._hipGraphicsResource`/`~.object`) -- *IN*:
            - Mapped resource to access.

    Returns:
        A `~.tuple` of size 3 that contains (in that order):

        * `~.hipError_t`: `~.hipSuccess`, `~.hipErrorInvalidValue`
        * `~.hip._util.types.Pointer`/`~.object`:
                - Pointer of device through which graphic resource may be accessed.
        * `~.int`:
                - Size of the buffer accessible from devPtr.
    """
    devPtr = hip._util.types.Pointer.fromPtr(NULL)
    cdef unsigned long size
    _hipGraphicsResourceGetMappedPointer__retval = hipError_t(chip.hipGraphicsResourceGetMappedPointer(
        <void **>&devPtr._ptr,&size,
        _hipGraphicsResource.fromPyobj(resource).getElementPtr()))
    return (_hipGraphicsResourceGetMappedPointer__retval,None if devPtr._ptr == NULL else devPtr,size)


@cython.embedsignature(True)
def hipGraphicsUnmapResources(int count, object stream):
    r"""Unmaps graphics resources.

    Args:
        count (`~.int`) -- *IN*:
            - Number of resources to unmap.

        stream (`~.ihipStream_t`/`~.object`) -- *IN*:
            - Stream for synchronization.

    Returns:
        A `~.tuple` of size 2 that contains (in that order):

        * `~.hipError_t`: `~.hipSuccess`, `~.hipErrorInvalidValue`, `~.hipErrorUnknown`, `~.hipErrorContextIsDestroyed`
        * `~._hipGraphicsResource`:
                - Pointer of resources to unmap.
    """
    resources = _hipGraphicsResource.fromPtr(NULL)
    _hipGraphicsUnmapResources__retval = hipError_t(chip.hipGraphicsUnmapResources(count,<chip._hipGraphicsResource**>&resources._ptr,
        ihipStream_t.fromPyobj(stream).getElementPtr()))
    return (_hipGraphicsUnmapResources__retval,None if resources._ptr == NULL else resources)


@cython.embedsignature(True)
def hipGraphicsUnregisterResource(object resource):
    r"""Unregisters a graphics resource.

    Args:
        resource (`~._hipGraphicsResource`/`~.object`) -- *IN*:
            - Graphics resources to unregister.

    Returns:
        A `~.tuple` of size 1 that contains (in that order):

        * `~.hipError_t`: `~.hipSuccess`
    """
    _hipGraphicsUnregisterResource__retval = hipError_t(chip.hipGraphicsUnregisterResource(
        _hipGraphicsResource.fromPyobj(resource).getElementPtr()))
    return (_hipGraphicsUnregisterResource__retval,)


@cython.embedsignature(True)
def hipCreateSurfaceObject(object pResDesc):
    r"""Create a surface object.

    Args:
        pResDesc (`~.hipResourceDesc`/`~.object`) -- *IN*:
            Pointer of suface object descriptor.

    Returns:
        A `~.tuple` of size 2 that contains (in that order):

        * `~.hipError_t`: `~.hipSuccess`, `~.hipErrorInvalidValue`
        * `~.__hip_surface`:
                Pointer of surface object to be created.
    """
    pSurfObject = __hip_surface.fromPtr(NULL)
    _hipCreateSurfaceObject__retval = hipError_t(chip.hipCreateSurfaceObject(<chip.__hip_surface**>&pSurfObject._ptr,
        hipResourceDesc.fromPyobj(pResDesc).getElementPtr()))
    return (_hipCreateSurfaceObject__retval,None if pSurfObject._ptr == NULL else pSurfObject)


@cython.embedsignature(True)
def hipDestroySurfaceObject(object surfaceObject):
    r"""Destroy a surface object.

    Args:
        surfaceObject (`~.__hip_surface`/`~.object`) -- *IN*:
            Surface object to be destroyed.

    Returns:
        A `~.tuple` of size 1 that contains (in that order):

        * `~.hipError_t`: `~.hipSuccess`, `~.hipErrorInvalidValue`
    """
    _hipDestroySurfaceObject__retval = hipError_t(chip.hipDestroySurfaceObject(
        __hip_surface.fromPyobj(surfaceObject).getElementPtr()))
    return (_hipDestroySurfaceObject__retval,)


@cython.embedsignature(True)
def hipMemcpy_spt(object dst, object src, unsigned long sizeBytes, object kind):
    r"""(No short description, might be part of a group.)

    Args:
        dst (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        src (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        sizeBytes (`~.int`):
            (undocumented)

        kind (`~.hipMemcpyKind`):
            (undocumented)
    """
    if not isinstance(kind,_hipMemcpyKind__Base):
        raise TypeError("argument 'kind' must be of type '_hipMemcpyKind__Base'")
    _hipMemcpy_spt__retval = hipError_t(chip.hipMemcpy_spt(
        <void *>hip._util.types.Pointer.fromPyobj(dst)._ptr,
        <const void *>hip._util.types.Pointer.fromPyobj(src)._ptr,sizeBytes,kind.value))
    return (_hipMemcpy_spt__retval,)


@cython.embedsignature(True)
def hipMemcpyToSymbol_spt(object symbol, object src, unsigned long sizeBytes, unsigned long offset, object kind):
    r"""(No short description, might be part of a group.)

    Args:
        symbol (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        src (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        sizeBytes (`~.int`):
            (undocumented)

        offset (`~.int`):
            (undocumented)

        kind (`~.hipMemcpyKind`):
            (undocumented)
    """
    if not isinstance(kind,_hipMemcpyKind__Base):
        raise TypeError("argument 'kind' must be of type '_hipMemcpyKind__Base'")
    _hipMemcpyToSymbol_spt__retval = hipError_t(chip.hipMemcpyToSymbol_spt(
        <const void *>hip._util.types.Pointer.fromPyobj(symbol)._ptr,
        <const void *>hip._util.types.Pointer.fromPyobj(src)._ptr,sizeBytes,offset,kind.value))
    return (_hipMemcpyToSymbol_spt__retval,)


@cython.embedsignature(True)
def hipMemcpyFromSymbol_spt(object dst, object symbol, unsigned long sizeBytes, unsigned long offset, object kind):
    r"""(No short description, might be part of a group.)

    Args:
        dst (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        symbol (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        sizeBytes (`~.int`):
            (undocumented)

        offset (`~.int`):
            (undocumented)

        kind (`~.hipMemcpyKind`):
            (undocumented)
    """
    if not isinstance(kind,_hipMemcpyKind__Base):
        raise TypeError("argument 'kind' must be of type '_hipMemcpyKind__Base'")
    _hipMemcpyFromSymbol_spt__retval = hipError_t(chip.hipMemcpyFromSymbol_spt(
        <void *>hip._util.types.Pointer.fromPyobj(dst)._ptr,
        <const void *>hip._util.types.Pointer.fromPyobj(symbol)._ptr,sizeBytes,offset,kind.value))
    return (_hipMemcpyFromSymbol_spt__retval,)


@cython.embedsignature(True)
def hipMemcpy2D_spt(object dst, unsigned long dpitch, object src, unsigned long spitch, unsigned long width, unsigned long height, object kind):
    r"""(No short description, might be part of a group.)

    Args:
        dst (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        dpitch (`~.int`):
            (undocumented)

        src (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        spitch (`~.int`):
            (undocumented)

        width (`~.int`):
            (undocumented)

        height (`~.int`):
            (undocumented)

        kind (`~.hipMemcpyKind`):
            (undocumented)
    """
    if not isinstance(kind,_hipMemcpyKind__Base):
        raise TypeError("argument 'kind' must be of type '_hipMemcpyKind__Base'")
    _hipMemcpy2D_spt__retval = hipError_t(chip.hipMemcpy2D_spt(
        <void *>hip._util.types.Pointer.fromPyobj(dst)._ptr,dpitch,
        <const void *>hip._util.types.Pointer.fromPyobj(src)._ptr,spitch,width,height,kind.value))
    return (_hipMemcpy2D_spt__retval,)


@cython.embedsignature(True)
def hipMemcpy2DFromArray_spt(object dst, unsigned long dpitch, object src, unsigned long wOffset, unsigned long hOffset, unsigned long width, unsigned long height, object kind):
    r"""(No short description, might be part of a group.)

    Args:
        dst (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        dpitch (`~.int`):
            (undocumented)

        src (`~.hipArray`/`~.object`):
            (undocumented)

        wOffset (`~.int`):
            (undocumented)

        hOffset (`~.int`):
            (undocumented)

        width (`~.int`):
            (undocumented)

        height (`~.int`):
            (undocumented)

        kind (`~.hipMemcpyKind`):
            (undocumented)
    """
    if not isinstance(kind,_hipMemcpyKind__Base):
        raise TypeError("argument 'kind' must be of type '_hipMemcpyKind__Base'")
    _hipMemcpy2DFromArray_spt__retval = hipError_t(chip.hipMemcpy2DFromArray_spt(
        <void *>hip._util.types.Pointer.fromPyobj(dst)._ptr,dpitch,
        hipArray.fromPyobj(src).getElementPtr(),wOffset,hOffset,width,height,kind.value))
    return (_hipMemcpy2DFromArray_spt__retval,)


@cython.embedsignature(True)
def hipMemcpy3D_spt(object p):
    r"""(No short description, might be part of a group.)

    Args:
        p (`~.hipMemcpy3DParms`/`~.object`):
            (undocumented)
    """
    _hipMemcpy3D_spt__retval = hipError_t(chip.hipMemcpy3D_spt(
        hipMemcpy3DParms.fromPyobj(p).getElementPtr()))
    return (_hipMemcpy3D_spt__retval,)


@cython.embedsignature(True)
def hipMemset_spt(object dst, int value, unsigned long sizeBytes):
    r"""(No short description, might be part of a group.)

    Args:
        dst (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        value (`~.int`):
            (undocumented)

        sizeBytes (`~.int`):
            (undocumented)
    """
    _hipMemset_spt__retval = hipError_t(chip.hipMemset_spt(
        <void *>hip._util.types.Pointer.fromPyobj(dst)._ptr,value,sizeBytes))
    return (_hipMemset_spt__retval,)


@cython.embedsignature(True)
def hipMemsetAsync_spt(object dst, int value, unsigned long sizeBytes, object stream):
    r"""(No short description, might be part of a group.)

    Args:
        dst (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        value (`~.int`):
            (undocumented)

        sizeBytes (`~.int`):
            (undocumented)

        stream (`~.ihipStream_t`/`~.object`):
            (undocumented)
    """
    _hipMemsetAsync_spt__retval = hipError_t(chip.hipMemsetAsync_spt(
        <void *>hip._util.types.Pointer.fromPyobj(dst)._ptr,value,sizeBytes,
        ihipStream_t.fromPyobj(stream).getElementPtr()))
    return (_hipMemsetAsync_spt__retval,)


@cython.embedsignature(True)
def hipMemset2D_spt(object dst, unsigned long pitch, int value, unsigned long width, unsigned long height):
    r"""(No short description, might be part of a group.)

    Args:
        dst (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        pitch (`~.int`):
            (undocumented)

        value (`~.int`):
            (undocumented)

        width (`~.int`):
            (undocumented)

        height (`~.int`):
            (undocumented)
    """
    _hipMemset2D_spt__retval = hipError_t(chip.hipMemset2D_spt(
        <void *>hip._util.types.Pointer.fromPyobj(dst)._ptr,pitch,value,width,height))
    return (_hipMemset2D_spt__retval,)


@cython.embedsignature(True)
def hipMemset2DAsync_spt(object dst, unsigned long pitch, int value, unsigned long width, unsigned long height, object stream):
    r"""(No short description, might be part of a group.)

    Args:
        dst (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        pitch (`~.int`):
            (undocumented)

        value (`~.int`):
            (undocumented)

        width (`~.int`):
            (undocumented)

        height (`~.int`):
            (undocumented)

        stream (`~.ihipStream_t`/`~.object`):
            (undocumented)
    """
    _hipMemset2DAsync_spt__retval = hipError_t(chip.hipMemset2DAsync_spt(
        <void *>hip._util.types.Pointer.fromPyobj(dst)._ptr,pitch,value,width,height,
        ihipStream_t.fromPyobj(stream).getElementPtr()))
    return (_hipMemset2DAsync_spt__retval,)


@cython.embedsignature(True)
def hipMemset3DAsync_spt(object pitchedDevPtr, int value, object extent, object stream):
    r"""(No short description, might be part of a group.)

    Args:
        pitchedDevPtr (`~.hipPitchedPtr`):
            (undocumented)

        value (`~.int`):
            (undocumented)

        extent (`~.hipExtent`):
            (undocumented)

        stream (`~.ihipStream_t`/`~.object`):
            (undocumented)
    """
    _hipMemset3DAsync_spt__retval = hipError_t(chip.hipMemset3DAsync_spt(
        hipPitchedPtr.fromPyobj(pitchedDevPtr).getElementPtr()[0],value,
        hipExtent.fromPyobj(extent).getElementPtr()[0],
        ihipStream_t.fromPyobj(stream).getElementPtr()))
    return (_hipMemset3DAsync_spt__retval,)


@cython.embedsignature(True)
def hipMemset3D_spt(object pitchedDevPtr, int value, object extent):
    r"""(No short description, might be part of a group.)

    Args:
        pitchedDevPtr (`~.hipPitchedPtr`):
            (undocumented)

        value (`~.int`):
            (undocumented)

        extent (`~.hipExtent`):
            (undocumented)
    """
    _hipMemset3D_spt__retval = hipError_t(chip.hipMemset3D_spt(
        hipPitchedPtr.fromPyobj(pitchedDevPtr).getElementPtr()[0],value,
        hipExtent.fromPyobj(extent).getElementPtr()[0]))
    return (_hipMemset3D_spt__retval,)


@cython.embedsignature(True)
def hipMemcpyAsync_spt(object dst, object src, unsigned long sizeBytes, object kind, object stream):
    r"""(No short description, might be part of a group.)

    Args:
        dst (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        src (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        sizeBytes (`~.int`):
            (undocumented)

        kind (`~.hipMemcpyKind`):
            (undocumented)

        stream (`~.ihipStream_t`/`~.object`):
            (undocumented)
    """
    if not isinstance(kind,_hipMemcpyKind__Base):
        raise TypeError("argument 'kind' must be of type '_hipMemcpyKind__Base'")
    _hipMemcpyAsync_spt__retval = hipError_t(chip.hipMemcpyAsync_spt(
        <void *>hip._util.types.Pointer.fromPyobj(dst)._ptr,
        <const void *>hip._util.types.Pointer.fromPyobj(src)._ptr,sizeBytes,kind.value,
        ihipStream_t.fromPyobj(stream).getElementPtr()))
    return (_hipMemcpyAsync_spt__retval,)


@cython.embedsignature(True)
def hipMemcpy3DAsync_spt(object p, object stream):
    r"""(No short description, might be part of a group.)

    Args:
        p (`~.hipMemcpy3DParms`/`~.object`):
            (undocumented)

        stream (`~.ihipStream_t`/`~.object`):
            (undocumented)
    """
    _hipMemcpy3DAsync_spt__retval = hipError_t(chip.hipMemcpy3DAsync_spt(
        hipMemcpy3DParms.fromPyobj(p).getElementPtr(),
        ihipStream_t.fromPyobj(stream).getElementPtr()))
    return (_hipMemcpy3DAsync_spt__retval,)


@cython.embedsignature(True)
def hipMemcpy2DAsync_spt(object dst, unsigned long dpitch, object src, unsigned long spitch, unsigned long width, unsigned long height, object kind, object stream):
    r"""(No short description, might be part of a group.)

    Args:
        dst (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        dpitch (`~.int`):
            (undocumented)

        src (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        spitch (`~.int`):
            (undocumented)

        width (`~.int`):
            (undocumented)

        height (`~.int`):
            (undocumented)

        kind (`~.hipMemcpyKind`):
            (undocumented)

        stream (`~.ihipStream_t`/`~.object`):
            (undocumented)
    """
    if not isinstance(kind,_hipMemcpyKind__Base):
        raise TypeError("argument 'kind' must be of type '_hipMemcpyKind__Base'")
    _hipMemcpy2DAsync_spt__retval = hipError_t(chip.hipMemcpy2DAsync_spt(
        <void *>hip._util.types.Pointer.fromPyobj(dst)._ptr,dpitch,
        <const void *>hip._util.types.Pointer.fromPyobj(src)._ptr,spitch,width,height,kind.value,
        ihipStream_t.fromPyobj(stream).getElementPtr()))
    return (_hipMemcpy2DAsync_spt__retval,)


@cython.embedsignature(True)
def hipMemcpyFromSymbolAsync_spt(object dst, object symbol, unsigned long sizeBytes, unsigned long offset, object kind, object stream):
    r"""(No short description, might be part of a group.)

    Args:
        dst (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        symbol (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        sizeBytes (`~.int`):
            (undocumented)

        offset (`~.int`):
            (undocumented)

        kind (`~.hipMemcpyKind`):
            (undocumented)

        stream (`~.ihipStream_t`/`~.object`):
            (undocumented)
    """
    if not isinstance(kind,_hipMemcpyKind__Base):
        raise TypeError("argument 'kind' must be of type '_hipMemcpyKind__Base'")
    _hipMemcpyFromSymbolAsync_spt__retval = hipError_t(chip.hipMemcpyFromSymbolAsync_spt(
        <void *>hip._util.types.Pointer.fromPyobj(dst)._ptr,
        <const void *>hip._util.types.Pointer.fromPyobj(symbol)._ptr,sizeBytes,offset,kind.value,
        ihipStream_t.fromPyobj(stream).getElementPtr()))
    return (_hipMemcpyFromSymbolAsync_spt__retval,)


@cython.embedsignature(True)
def hipMemcpyToSymbolAsync_spt(object symbol, object src, unsigned long sizeBytes, unsigned long offset, object kind, object stream):
    r"""(No short description, might be part of a group.)

    Args:
        symbol (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        src (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        sizeBytes (`~.int`):
            (undocumented)

        offset (`~.int`):
            (undocumented)

        kind (`~.hipMemcpyKind`):
            (undocumented)

        stream (`~.ihipStream_t`/`~.object`):
            (undocumented)
    """
    if not isinstance(kind,_hipMemcpyKind__Base):
        raise TypeError("argument 'kind' must be of type '_hipMemcpyKind__Base'")
    _hipMemcpyToSymbolAsync_spt__retval = hipError_t(chip.hipMemcpyToSymbolAsync_spt(
        <const void *>hip._util.types.Pointer.fromPyobj(symbol)._ptr,
        <const void *>hip._util.types.Pointer.fromPyobj(src)._ptr,sizeBytes,offset,kind.value,
        ihipStream_t.fromPyobj(stream).getElementPtr()))
    return (_hipMemcpyToSymbolAsync_spt__retval,)


@cython.embedsignature(True)
def hipMemcpyFromArray_spt(object dst, object src, unsigned long wOffsetSrc, unsigned long hOffset, unsigned long count, object kind):
    r"""(No short description, might be part of a group.)

    Args:
        dst (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        src (`~.hipArray`/`~.object`):
            (undocumented)

        wOffsetSrc (`~.int`):
            (undocumented)

        hOffset (`~.int`):
            (undocumented)

        count (`~.int`):
            (undocumented)

        kind (`~.hipMemcpyKind`):
            (undocumented)
    """
    if not isinstance(kind,_hipMemcpyKind__Base):
        raise TypeError("argument 'kind' must be of type '_hipMemcpyKind__Base'")
    _hipMemcpyFromArray_spt__retval = hipError_t(chip.hipMemcpyFromArray_spt(
        <void *>hip._util.types.Pointer.fromPyobj(dst)._ptr,
        hipArray.fromPyobj(src).getElementPtr(),wOffsetSrc,hOffset,count,kind.value))
    return (_hipMemcpyFromArray_spt__retval,)


@cython.embedsignature(True)
def hipMemcpy2DToArray_spt(object dst, unsigned long wOffset, unsigned long hOffset, object src, unsigned long spitch, unsigned long width, unsigned long height, object kind):
    r"""(No short description, might be part of a group.)

    Args:
        dst (`~.hipArray`/`~.object`):
            (undocumented)

        wOffset (`~.int`):
            (undocumented)

        hOffset (`~.int`):
            (undocumented)

        src (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        spitch (`~.int`):
            (undocumented)

        width (`~.int`):
            (undocumented)

        height (`~.int`):
            (undocumented)

        kind (`~.hipMemcpyKind`):
            (undocumented)
    """
    if not isinstance(kind,_hipMemcpyKind__Base):
        raise TypeError("argument 'kind' must be of type '_hipMemcpyKind__Base'")
    _hipMemcpy2DToArray_spt__retval = hipError_t(chip.hipMemcpy2DToArray_spt(
        hipArray.fromPyobj(dst).getElementPtr(),wOffset,hOffset,
        <const void *>hip._util.types.Pointer.fromPyobj(src)._ptr,spitch,width,height,kind.value))
    return (_hipMemcpy2DToArray_spt__retval,)


@cython.embedsignature(True)
def hipMemcpy2DFromArrayAsync_spt(object dst, unsigned long dpitch, object src, unsigned long wOffsetSrc, unsigned long hOffsetSrc, unsigned long width, unsigned long height, object kind, object stream):
    r"""(No short description, might be part of a group.)

    Args:
        dst (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        dpitch (`~.int`):
            (undocumented)

        src (`~.hipArray`/`~.object`):
            (undocumented)

        wOffsetSrc (`~.int`):
            (undocumented)

        hOffsetSrc (`~.int`):
            (undocumented)

        width (`~.int`):
            (undocumented)

        height (`~.int`):
            (undocumented)

        kind (`~.hipMemcpyKind`):
            (undocumented)

        stream (`~.ihipStream_t`/`~.object`):
            (undocumented)
    """
    if not isinstance(kind,_hipMemcpyKind__Base):
        raise TypeError("argument 'kind' must be of type '_hipMemcpyKind__Base'")
    _hipMemcpy2DFromArrayAsync_spt__retval = hipError_t(chip.hipMemcpy2DFromArrayAsync_spt(
        <void *>hip._util.types.Pointer.fromPyobj(dst)._ptr,dpitch,
        hipArray.fromPyobj(src).getElementPtr(),wOffsetSrc,hOffsetSrc,width,height,kind.value,
        ihipStream_t.fromPyobj(stream).getElementPtr()))
    return (_hipMemcpy2DFromArrayAsync_spt__retval,)


@cython.embedsignature(True)
def hipMemcpy2DToArrayAsync_spt(object dst, unsigned long wOffset, unsigned long hOffset, object src, unsigned long spitch, unsigned long width, unsigned long height, object kind, object stream):
    r"""(No short description, might be part of a group.)

    Args:
        dst (`~.hipArray`/`~.object`):
            (undocumented)

        wOffset (`~.int`):
            (undocumented)

        hOffset (`~.int`):
            (undocumented)

        src (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        spitch (`~.int`):
            (undocumented)

        width (`~.int`):
            (undocumented)

        height (`~.int`):
            (undocumented)

        kind (`~.hipMemcpyKind`):
            (undocumented)

        stream (`~.ihipStream_t`/`~.object`):
            (undocumented)
    """
    if not isinstance(kind,_hipMemcpyKind__Base):
        raise TypeError("argument 'kind' must be of type '_hipMemcpyKind__Base'")
    _hipMemcpy2DToArrayAsync_spt__retval = hipError_t(chip.hipMemcpy2DToArrayAsync_spt(
        hipArray.fromPyobj(dst).getElementPtr(),wOffset,hOffset,
        <const void *>hip._util.types.Pointer.fromPyobj(src)._ptr,spitch,width,height,kind.value,
        ihipStream_t.fromPyobj(stream).getElementPtr()))
    return (_hipMemcpy2DToArrayAsync_spt__retval,)


@cython.embedsignature(True)
def hipStreamQuery_spt(object stream):
    r"""(No short description, might be part of a group.)

    Args:
        stream (`~.ihipStream_t`/`~.object`):
            (undocumented)
    """
    _hipStreamQuery_spt__retval = hipError_t(chip.hipStreamQuery_spt(
        ihipStream_t.fromPyobj(stream).getElementPtr()))
    return (_hipStreamQuery_spt__retval,)


@cython.embedsignature(True)
def hipStreamSynchronize_spt(object stream):
    r"""(No short description, might be part of a group.)

    Args:
        stream (`~.ihipStream_t`/`~.object`):
            (undocumented)
    """
    _hipStreamSynchronize_spt__retval = hipError_t(chip.hipStreamSynchronize_spt(
        ihipStream_t.fromPyobj(stream).getElementPtr()))
    return (_hipStreamSynchronize_spt__retval,)


@cython.embedsignature(True)
def hipStreamGetPriority_spt(object stream):
    r"""(No short description, might be part of a group.)

    Args:
        stream (`~.ihipStream_t`/`~.object`):
            (undocumented)

    Returns:
        A `~.tuple` of size 1 that contains (in that order):

        * priority (`~.int`):
            (undocumented)
    """
    cdef int priority
    _hipStreamGetPriority_spt__retval = hipError_t(chip.hipStreamGetPriority_spt(
        ihipStream_t.fromPyobj(stream).getElementPtr(),&priority))
    return (_hipStreamGetPriority_spt__retval,priority)


@cython.embedsignature(True)
def hipStreamWaitEvent_spt(object stream, object event, unsigned int flags):
    r"""(No short description, might be part of a group.)

    Args:
        stream (`~.ihipStream_t`/`~.object`):
            (undocumented)

        event (`~.ihipEvent_t`/`~.object`):
            (undocumented)

        flags (`~.int`):
            (undocumented)
    """
    _hipStreamWaitEvent_spt__retval = hipError_t(chip.hipStreamWaitEvent_spt(
        ihipStream_t.fromPyobj(stream).getElementPtr(),
        ihipEvent_t.fromPyobj(event).getElementPtr(),flags))
    return (_hipStreamWaitEvent_spt__retval,)


@cython.embedsignature(True)
def hipStreamGetFlags_spt(object stream):
    r"""(No short description, might be part of a group.)

    Args:
        stream (`~.ihipStream_t`/`~.object`):
            (undocumented)

    Returns:
        A `~.tuple` of size 1 that contains (in that order):

        * flags (`~.int`):
            (undocumented)
    """
    cdef unsigned int flags
    _hipStreamGetFlags_spt__retval = hipError_t(chip.hipStreamGetFlags_spt(
        ihipStream_t.fromPyobj(stream).getElementPtr(),&flags))
    return (_hipStreamGetFlags_spt__retval,flags)


@cython.embedsignature(True)
def hipStreamAddCallback_spt(object stream, object callback, object userData, unsigned int flags):
    r"""(No short description, might be part of a group.)

    Args:
        stream (`~.ihipStream_t`/`~.object`):
            (undocumented)

        callback (`~.hipStreamCallback_t`/`~.object`):
            (undocumented)

        userData (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        flags (`~.int`):
            (undocumented)
    """
    _hipStreamAddCallback_spt__retval = hipError_t(chip.hipStreamAddCallback_spt(
        ihipStream_t.fromPyobj(stream).getElementPtr(),
        hipStreamCallback_t.fromPyobj(callback).getElementPtr(),
        <void *>hip._util.types.Pointer.fromPyobj(userData)._ptr,flags))
    return (_hipStreamAddCallback_spt__retval,)


@cython.embedsignature(True)
def hipEventRecord_spt(object event, object stream):
    r"""(No short description, might be part of a group.)

    Args:
        event (`~.ihipEvent_t`/`~.object`):
            (undocumented)

        stream (`~.ihipStream_t`/`~.object`):
            (undocumented)
    """
    _hipEventRecord_spt__retval = hipError_t(chip.hipEventRecord_spt(
        ihipEvent_t.fromPyobj(event).getElementPtr(),
        ihipStream_t.fromPyobj(stream).getElementPtr()))
    return (_hipEventRecord_spt__retval,)


@cython.embedsignature(True)
def hipLaunchCooperativeKernel_spt(object f, object gridDim, object blockDim, object kernelParams, unsigned int sharedMemBytes, object hStream):
    r"""(No short description, might be part of a group.)

    Args:
        f (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        gridDim (`~.dim3`):
            (undocumented)

        blockDim (`~.dim3`):
            (undocumented)

        kernelParams (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        sharedMemBytes (`~.int`):
            (undocumented)

        hStream (`~.ihipStream_t`/`~.object`):
            (undocumented)
    """
    _hipLaunchCooperativeKernel_spt__retval = hipError_t(chip.hipLaunchCooperativeKernel_spt(
        <const void *>hip._util.types.Pointer.fromPyobj(f)._ptr,
        dim3.fromPyobj(gridDim).getElementPtr()[0],
        dim3.fromPyobj(blockDim).getElementPtr()[0],
        <void **>hip._util.types.Pointer.fromPyobj(kernelParams)._ptr,sharedMemBytes,
        ihipStream_t.fromPyobj(hStream).getElementPtr()))
    return (_hipLaunchCooperativeKernel_spt__retval,)


@cython.embedsignature(True)
def hipLaunchKernel_spt(object function_address, object numBlocks, object dimBlocks, object args, unsigned long sharedMemBytes, object stream):
    r"""(No short description, might be part of a group.)

    Args:
        function_address (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        numBlocks (`~.dim3`):
            (undocumented)

        dimBlocks (`~.dim3`):
            (undocumented)

        args (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        sharedMemBytes (`~.int`):
            (undocumented)

        stream (`~.ihipStream_t`/`~.object`):
            (undocumented)
    """
    _hipLaunchKernel_spt__retval = hipError_t(chip.hipLaunchKernel_spt(
        <const void *>hip._util.types.Pointer.fromPyobj(function_address)._ptr,
        dim3.fromPyobj(numBlocks).getElementPtr()[0],
        dim3.fromPyobj(dimBlocks).getElementPtr()[0],
        <void **>hip._util.types.Pointer.fromPyobj(args)._ptr,sharedMemBytes,
        ihipStream_t.fromPyobj(stream).getElementPtr()))
    return (_hipLaunchKernel_spt__retval,)


@cython.embedsignature(True)
def hipGraphLaunch_spt(object graphExec, object stream):
    r"""(No short description, might be part of a group.)

    Args:
        graphExec (`~.hipGraphExec`/`~.object`):
            (undocumented)

        stream (`~.ihipStream_t`/`~.object`):
            (undocumented)
    """
    _hipGraphLaunch_spt__retval = hipError_t(chip.hipGraphLaunch_spt(
        hipGraphExec.fromPyobj(graphExec).getElementPtr(),
        ihipStream_t.fromPyobj(stream).getElementPtr()))
    return (_hipGraphLaunch_spt__retval,)


@cython.embedsignature(True)
def hipStreamBeginCapture_spt(object stream, object mode):
    r"""(No short description, might be part of a group.)

    Args:
        stream (`~.ihipStream_t`/`~.object`):
            (undocumented)

        mode (`~.hipStreamCaptureMode`):
            (undocumented)
    """
    if not isinstance(mode,_hipStreamCaptureMode__Base):
        raise TypeError("argument 'mode' must be of type '_hipStreamCaptureMode__Base'")
    _hipStreamBeginCapture_spt__retval = hipError_t(chip.hipStreamBeginCapture_spt(
        ihipStream_t.fromPyobj(stream).getElementPtr(),mode.value))
    return (_hipStreamBeginCapture_spt__retval,)


@cython.embedsignature(True)
def hipStreamEndCapture_spt(object stream):
    r"""(No short description, might be part of a group.)

    Args:
        stream (`~.ihipStream_t`/`~.object`):
            (undocumented)

    Returns:
        A `~.tuple` of size 1 that contains (in that order):

        * pGraph (`~.ihipGraph`):
            (undocumented)
    """
    pGraph = ihipGraph.fromPtr(NULL)
    _hipStreamEndCapture_spt__retval = hipError_t(chip.hipStreamEndCapture_spt(
        ihipStream_t.fromPyobj(stream).getElementPtr(),<chip.ihipGraph**>&pGraph._ptr))
    return (_hipStreamEndCapture_spt__retval,None if pGraph._ptr == NULL else pGraph)


@cython.embedsignature(True)
def hipStreamIsCapturing_spt(object stream):
    r"""(No short description, might be part of a group.)

    Args:
        stream (`~.ihipStream_t`/`~.object`):
            (undocumented)

    Returns:
        A `~.tuple` of size 1 that contains (in that order):

        * pCaptureStatus (`~.hipStreamCaptureStatus`):
            (undocumented)
    """
    cdef chip.hipStreamCaptureStatus pCaptureStatus
    _hipStreamIsCapturing_spt__retval = hipError_t(chip.hipStreamIsCapturing_spt(
        ihipStream_t.fromPyobj(stream).getElementPtr(),&pCaptureStatus))
    return (_hipStreamIsCapturing_spt__retval,hipStreamCaptureStatus(pCaptureStatus))


@cython.embedsignature(True)
def hipStreamGetCaptureInfo_spt(object stream):
    r"""(No short description, might be part of a group.)

    Args:
        stream (`~.ihipStream_t`/`~.object`):
            (undocumented)

    Returns:
        A `~.tuple` of size 2 that contains (in that order):

        * pCaptureStatus (`~.hipStreamCaptureStatus`):
            (undocumented)
        * pId (`~.int`):
            (undocumented)
    """
    cdef chip.hipStreamCaptureStatus pCaptureStatus
    cdef unsigned long long pId
    _hipStreamGetCaptureInfo_spt__retval = hipError_t(chip.hipStreamGetCaptureInfo_spt(
        ihipStream_t.fromPyobj(stream).getElementPtr(),&pCaptureStatus,&pId))
    return (_hipStreamGetCaptureInfo_spt__retval,hipStreamCaptureStatus(pCaptureStatus),pId)


@cython.embedsignature(True)
def hipStreamGetCaptureInfo_v2_spt(object stream, object dependencies_out):
    r"""(No short description, might be part of a group.)

    Args:
        stream (`~.ihipStream_t`/`~.object`):
            (undocumented)

        dependencies_out (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

    Returns:
        A `~.tuple` of size 4 that contains (in that order):

        * captureStatus_out (`~.hipStreamCaptureStatus`):
            (undocumented)
        * id_out (`~.int`):
            (undocumented)
        * graph_out (`~.ihipGraph`):
            (undocumented)
        * numDependencies_out (`~.int`):
            (undocumented)
    """
    cdef chip.hipStreamCaptureStatus captureStatus_out
    cdef unsigned long long id_out
    graph_out = ihipGraph.fromPtr(NULL)
    cdef unsigned long numDependencies_out
    _hipStreamGetCaptureInfo_v2_spt__retval = hipError_t(chip.hipStreamGetCaptureInfo_v2_spt(
        ihipStream_t.fromPyobj(stream).getElementPtr(),&captureStatus_out,&id_out,<chip.ihipGraph**>&graph_out._ptr,
        <chip.hipGraphNode_t **>hip._util.types.Pointer.fromPyobj(dependencies_out)._ptr,&numDependencies_out))
    return (_hipStreamGetCaptureInfo_v2_spt__retval,hipStreamCaptureStatus(captureStatus_out),id_out,None if graph_out._ptr == NULL else graph_out,numDependencies_out)


@cython.embedsignature(True)
def hipLaunchHostFunc_spt(object stream, object fn, object userData):
    r"""(No short description, might be part of a group.)

    Args:
        stream (`~.ihipStream_t`/`~.object`):
            (undocumented)

        fn (`~.hipHostFn_t`/`~.object`):
            (undocumented)

        userData (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)
    """
    _hipLaunchHostFunc_spt__retval = hipError_t(chip.hipLaunchHostFunc_spt(
        ihipStream_t.fromPyobj(stream).getElementPtr(),
        hipHostFn_t.fromPyobj(fn).getElementPtr(),
        <void *>hip._util.types.Pointer.fromPyobj(userData)._ptr))
    return (_hipLaunchHostFunc_spt__retval,)


class _hipDataType__Base(enum.IntEnum):
    """Empty enum base class that allows subclassing.
    """
    pass
class hipDataType(_hipDataType__Base):
    """hipDataType

    Attributes:
        HIP_R_32F:
            (undocumented)
        HIP_R_64F:
            (undocumented)
        HIP_R_16F:
            (undocumented)
        HIP_R_8I:
            (undocumented)
        HIP_C_32F:
            (undocumented)
        HIP_C_64F:
            (undocumented)
        HIP_C_16F:
            (undocumented)
        HIP_C_8I:
            (undocumented)
        HIP_R_8U:
            (undocumented)
        HIP_C_8U:
            (undocumented)
        HIP_R_32I:
            (undocumented)
        HIP_C_32I:
            (undocumented)
        HIP_R_32U:
            (undocumented)
        HIP_C_32U:
            (undocumented)
        HIP_R_16BF:
            (undocumented)
        HIP_C_16BF:
            (undocumented)
        HIP_R_4I:
            (undocumented)
        HIP_C_4I:
            (undocumented)
        HIP_R_4U:
            (undocumented)
        HIP_C_4U:
            (undocumented)
        HIP_R_16I:
            (undocumented)
        HIP_C_16I:
            (undocumented)
        HIP_R_16U:
            (undocumented)
        HIP_C_16U:
            (undocumented)
        HIP_R_64I:
            (undocumented)
        HIP_C_64I:
            (undocumented)
        HIP_R_64U:
            (undocumented)
        HIP_C_64U:
            (undocumented)
        HIP_R_8F_E4M3_FNUZ:
            (undocumented)
        HIP_R_8F_E5M2_FNUZ:
            (undocumented)
    """
    HIP_R_32F = chip.HIP_R_32F
    HIP_R_64F = chip.HIP_R_64F
    HIP_R_16F = chip.HIP_R_16F
    HIP_R_8I = chip.HIP_R_8I
    HIP_C_32F = chip.HIP_C_32F
    HIP_C_64F = chip.HIP_C_64F
    HIP_C_16F = chip.HIP_C_16F
    HIP_C_8I = chip.HIP_C_8I
    HIP_R_8U = chip.HIP_R_8U
    HIP_C_8U = chip.HIP_C_8U
    HIP_R_32I = chip.HIP_R_32I
    HIP_C_32I = chip.HIP_C_32I
    HIP_R_32U = chip.HIP_R_32U
    HIP_C_32U = chip.HIP_C_32U
    HIP_R_16BF = chip.HIP_R_16BF
    HIP_C_16BF = chip.HIP_C_16BF
    HIP_R_4I = chip.HIP_R_4I
    HIP_C_4I = chip.HIP_C_4I
    HIP_R_4U = chip.HIP_R_4U
    HIP_C_4U = chip.HIP_C_4U
    HIP_R_16I = chip.HIP_R_16I
    HIP_C_16I = chip.HIP_C_16I
    HIP_R_16U = chip.HIP_R_16U
    HIP_C_16U = chip.HIP_C_16U
    HIP_R_64I = chip.HIP_R_64I
    HIP_C_64I = chip.HIP_C_64I
    HIP_R_64U = chip.HIP_R_64U
    HIP_C_64U = chip.HIP_C_64U
    HIP_R_8F_E4M3_FNUZ = chip.HIP_R_8F_E4M3_FNUZ
    HIP_R_8F_E5M2_FNUZ = chip.HIP_R_8F_E5M2_FNUZ
    @staticmethod
    def ctypes_type():
        """The type of the enum constants as ctypes type."""
        return ctypes.c_uint


class _hipLibraryPropertyType__Base(enum.IntEnum):
    """Empty enum base class that allows subclassing.
    """
    pass
class hipLibraryPropertyType(_hipLibraryPropertyType__Base):
    """hipLibraryPropertyType

    Attributes:
        HIP_LIBRARY_MAJOR_VERSION:
            (undocumented)
        HIP_LIBRARY_MINOR_VERSION:
            (undocumented)
        HIP_LIBRARY_PATCH_LEVEL:
            (undocumented)
    """
    HIP_LIBRARY_MAJOR_VERSION = chip.HIP_LIBRARY_MAJOR_VERSION
    HIP_LIBRARY_MINOR_VERSION = chip.HIP_LIBRARY_MINOR_VERSION
    HIP_LIBRARY_PATCH_LEVEL = chip.HIP_LIBRARY_PATCH_LEVEL
    @staticmethod
    def ctypes_type():
        """The type of the enum constants as ctypes type."""
        return ctypes.c_uint

__all__ = [
    "HIP_VERSION_MAJOR",
    "HIP_VERSION_MINOR",
    "HIP_VERSION_PATCH",
    "HIP_VERSION_GITHASH",
    "HIP_VERSION_BUILD_ID",
    "HIP_VERSION_BUILD_NAME",
    "HIP_VERSION",
    "HIP_TRSA_OVERRIDE_FORMAT",
    "HIP_TRSF_READ_AS_INTEGER",
    "HIP_TRSF_NORMALIZED_COORDINATES",
    "HIP_TRSF_SRGB",
    "hipTextureType1D",
    "hipTextureType2D",
    "hipTextureType3D",
    "hipTextureTypeCubemap",
    "hipTextureType1DLayered",
    "hipTextureType2DLayered",
    "hipTextureTypeCubemapLayered",
    "HIP_IMAGE_OBJECT_SIZE_DWORD",
    "HIP_SAMPLER_OBJECT_SIZE_DWORD",
    "HIP_SAMPLER_OBJECT_OFFSET_DWORD",
    "HIP_TEXTURE_OBJECT_SIZE_DWORD",
    "HIP_LAUNCH_PARAM_BUFFER_POINTER",
    "HIP_LAUNCH_PARAM_BUFFER_SIZE",
    "HIP_LAUNCH_PARAM_END",
    "hipIpcMemLazyEnablePeerAccess",
    "HIP_IPC_HANDLE_SIZE",
    "hipStreamDefault",
    "hipStreamNonBlocking",
    "hipEventDefault",
    "hipEventBlockingSync",
    "hipEventDisableTiming",
    "hipEventInterprocess",
    "hipEventReleaseToDevice",
    "hipEventReleaseToSystem",
    "hipHostMallocDefault",
    "hipHostMallocPortable",
    "hipHostMallocMapped",
    "hipHostMallocWriteCombined",
    "hipHostMallocNumaUser",
    "hipHostMallocCoherent",
    "hipHostMallocNonCoherent",
    "hipMemAttachGlobal",
    "hipMemAttachHost",
    "hipMemAttachSingle",
    "hipDeviceMallocDefault",
    "hipDeviceMallocFinegrained",
    "hipMallocSignalMemory",
    "hipHostRegisterDefault",
    "hipHostRegisterPortable",
    "hipHostRegisterMapped",
    "hipHostRegisterIoMemory",
    "hipExtHostRegisterCoarseGrained",
    "hipDeviceScheduleAuto",
    "hipDeviceScheduleSpin",
    "hipDeviceScheduleYield",
    "hipDeviceScheduleBlockingSync",
    "hipDeviceScheduleMask",
    "hipDeviceMapHost",
    "hipDeviceLmemResizeToMax",
    "hipArrayDefault",
    "hipArrayLayered",
    "hipArraySurfaceLoadStore",
    "hipArrayCubemap",
    "hipArrayTextureGather",
    "hipOccupancyDefault",
    "hipCooperativeLaunchMultiDeviceNoPreSync",
    "hipCooperativeLaunchMultiDeviceNoPostSync",
    "hipCpuDeviceId",
    "hipInvalidDeviceId",
    "hipExtAnyOrderLaunch",
    "hipStreamWaitValueGte",
    "hipStreamWaitValueEq",
    "hipStreamWaitValueAnd",
    "hipStreamWaitValueNor",
    "hipDeviceArch_t",
    "hipUUID_t",
    "hipUUID",
    "hipDeviceProp_t",
    "_hipMemoryType__Base",
    "hipMemoryType",
    "hipPointerAttribute_t",
    "_hipError_t__Base",
    "hipError_t",
    "_hipDeviceAttribute_t__Base",
    "hipDeviceAttribute_t",
    "_hipDriverProcAddressQueryResult__Base",
    "hipDriverProcAddressQueryResult",
    "_hipComputeMode__Base",
    "hipComputeMode",
    "_hipFlushGPUDirectRDMAWritesOptions__Base",
    "hipFlushGPUDirectRDMAWritesOptions",
    "_hipGPUDirectRDMAWritesOrdering__Base",
    "hipGPUDirectRDMAWritesOrdering",
    "_hipChannelFormatKind__Base",
    "hipChannelFormatKind",
    "hipChannelFormatDesc",
    "hipArray",
    "hipArray_t",
    "hipArray_const_t",
    "_hipArray_Format__Base",
    "hipArray_Format",
    "HIP_ARRAY_DESCRIPTOR",
    "HIP_ARRAY3D_DESCRIPTOR",
    "hip_Memcpy2D",
    "hipMipmappedArray",
    "hipMipmappedArray_t",
    "hipMipmappedArray_const_t",
    "_hipResourceType__Base",
    "hipResourceType",
    "_HIPresourcetype_enum__Base",
    "HIPresourcetype_enum",
    "HIPresourcetype",
    "hipResourcetype",
    "_HIPaddress_mode_enum__Base",
    "HIPaddress_mode_enum",
    "HIPaddress_mode",
    "_HIPfilter_mode_enum__Base",
    "HIPfilter_mode_enum",
    "HIPfilter_mode",
    "HIP_TEXTURE_DESC_st",
    "HIP_TEXTURE_DESC",
    "_hipResourceViewFormat__Base",
    "hipResourceViewFormat",
    "_HIPresourceViewFormat_enum__Base",
    "HIPresourceViewFormat_enum",
    "HIPresourceViewFormat",
    "hipResourceDesc_union_0_struct_0",
    "hipResourceDesc_union_0_struct_1",
    "hipResourceDesc_union_0_struct_2",
    "hipResourceDesc_union_0_struct_3",
    "hipResourceDesc_union_0",
    "hipResourceDesc",
    "HIP_RESOURCE_DESC_st_union_0_struct_0",
    "HIP_RESOURCE_DESC_st_union_0_struct_1",
    "HIP_RESOURCE_DESC_st_union_0_struct_2",
    "HIP_RESOURCE_DESC_st_union_0_struct_3",
    "HIP_RESOURCE_DESC_st_union_0_struct_4",
    "HIP_RESOURCE_DESC_st_union_0",
    "HIP_RESOURCE_DESC_st",
    "HIP_RESOURCE_DESC",
    "hipResourceViewDesc",
    "HIP_RESOURCE_VIEW_DESC_st",
    "HIP_RESOURCE_VIEW_DESC",
    "_hipMemcpyKind__Base",
    "hipMemcpyKind",
    "hipPitchedPtr",
    "hipExtent",
    "hipPos",
    "hipMemcpy3DParms",
    "HIP_MEMCPY3D",
    "_hipFunction_attribute__Base",
    "hipFunction_attribute",
    "_hipPointer_attribute__Base",
    "hipPointer_attribute",
    "uchar1",
    "uchar2",
    "uchar3",
    "uchar4",
    "char1",
    "char2",
    "char3",
    "char4",
    "ushort1",
    "ushort2",
    "ushort3",
    "ushort4",
    "short1",
    "short2",
    "short3",
    "short4",
    "uint1",
    "uint2",
    "uint3",
    "uint4",
    "int1",
    "int2",
    "int3",
    "int4",
    "ulong1",
    "ulong2",
    "ulong3",
    "ulong4",
    "long1",
    "long2",
    "long3",
    "long4",
    "ulonglong1",
    "ulonglong2",
    "ulonglong3",
    "ulonglong4",
    "longlong1",
    "longlong2",
    "longlong3",
    "longlong4",
    "float1",
    "float2",
    "float3",
    "float4",
    "double1",
    "double2",
    "double3",
    "double4",
    "hipCreateChannelDesc",
    "__hip_texture",
    "hipTextureObject_t",
    "_hipTextureAddressMode__Base",
    "hipTextureAddressMode",
    "_hipTextureFilterMode__Base",
    "hipTextureFilterMode",
    "_hipTextureReadMode__Base",
    "hipTextureReadMode",
    "textureReference",
    "hipTextureDesc",
    "__hip_surface",
    "hipSurfaceObject_t",
    "surfaceReference",
    "_hipSurfaceBoundaryMode__Base",
    "hipSurfaceBoundaryMode",
    "ihipCtx_t",
    "hipCtx_t",
    "_hipDeviceP2PAttr__Base",
    "hipDeviceP2PAttr",
    "ihipStream_t",
    "hipStream_t",
    "hipIpcMemHandle_st",
    "hipIpcMemHandle_t",
    "hipIpcEventHandle_st",
    "hipIpcEventHandle_t",
    "ihipModule_t",
    "hipModule_t",
    "ihipModuleSymbol_t",
    "hipFunction_t",
    "ihipMemPoolHandle_t",
    "hipMemPool_t",
    "hipFuncAttributes",
    "ihipEvent_t",
    "hipEvent_t",
    "_hipLimit_t__Base",
    "hipLimit_t",
    "_hipMemoryAdvise__Base",
    "hipMemoryAdvise",
    "_hipMemRangeCoherencyMode__Base",
    "hipMemRangeCoherencyMode",
    "_hipMemRangeAttribute__Base",
    "hipMemRangeAttribute",
    "_hipMemPoolAttr__Base",
    "hipMemPoolAttr",
    "_hipMemLocationType__Base",
    "hipMemLocationType",
    "hipMemLocation",
    "_hipMemAccessFlags__Base",
    "hipMemAccessFlags",
    "hipMemAccessDesc",
    "_hipMemAllocationType__Base",
    "hipMemAllocationType",
    "_hipMemAllocationHandleType__Base",
    "hipMemAllocationHandleType",
    "hipMemPoolProps",
    "hipMemPoolPtrExportData",
    "_hipJitOption__Base",
    "hipJitOption",
    "_hipFuncAttribute__Base",
    "hipFuncAttribute",
    "_hipFuncCache_t__Base",
    "hipFuncCache_t",
    "_hipSharedMemConfig__Base",
    "hipSharedMemConfig",
    "dim3",
    "hipLaunchParams_t",
    "hipLaunchParams",
    "hipFunctionLaunchParams_t",
    "hipFunctionLaunchParams",
    "_hipExternalMemoryHandleType_enum__Base",
    "hipExternalMemoryHandleType_enum",
    "hipExternalMemoryHandleType",
    "hipExternalMemoryHandleDesc_st_union_0_struct_0",
    "hipExternalMemoryHandleDesc_st_union_0",
    "hipExternalMemoryHandleDesc_st",
    "hipExternalMemoryHandleDesc",
    "hipExternalMemoryBufferDesc_st",
    "hipExternalMemoryBufferDesc",
    "hipExternalMemoryMipmappedArrayDesc_st",
    "hipExternalMemoryMipmappedArrayDesc",
    "_hipExternalSemaphoreHandleType_enum__Base",
    "hipExternalSemaphoreHandleType_enum",
    "hipExternalSemaphoreHandleType",
    "hipExternalSemaphoreHandleDesc_st_union_0_struct_0",
    "hipExternalSemaphoreHandleDesc_st_union_0",
    "hipExternalSemaphoreHandleDesc_st",
    "hipExternalSemaphoreHandleDesc",
    "hipExternalSemaphoreSignalParams_st_struct_0_struct_0",
    "hipExternalSemaphoreSignalParams_st_struct_0_union_0",
    "hipExternalSemaphoreSignalParams_st_struct_0_struct_1",
    "hipExternalSemaphoreSignalParams_st_struct_0",
    "hipExternalSemaphoreSignalParams_st",
    "hipExternalSemaphoreSignalParams",
    "hipExternalSemaphoreWaitParams_st_struct_0_struct_0",
    "hipExternalSemaphoreWaitParams_st_struct_0_union_0",
    "hipExternalSemaphoreWaitParams_st_struct_0_struct_1",
    "hipExternalSemaphoreWaitParams_st_struct_0",
    "hipExternalSemaphoreWaitParams_st",
    "hipExternalSemaphoreWaitParams",
    "_hipGraphicsRegisterFlags__Base",
    "hipGraphicsRegisterFlags",
    "_hipGraphicsResource",
    "hipGraphicsResource",
    "hipGraphicsResource_t",
    "ihipGraph",
    "hipGraph_t",
    "hipGraphNode",
    "hipGraphNode_t",
    "hipGraphExec",
    "hipGraphExec_t",
    "hipUserObject",
    "hipUserObject_t",
    "_hipGraphNodeType__Base",
    "hipGraphNodeType",
    "hipHostFn_t",
    "hipHostNodeParams",
    "hipKernelNodeParams",
    "hipMemsetParams",
    "hipMemAllocNodeParams",
    "_hipAccessProperty__Base",
    "hipAccessProperty",
    "hipAccessPolicyWindow",
    "_hipLaunchAttributeID__Base",
    "hipLaunchAttributeID",
    "hipLaunchAttributeValue",
    "HIP_MEMSET_NODE_PARAMS",
    "_hipGraphExecUpdateResult__Base",
    "hipGraphExecUpdateResult",
    "_hipStreamCaptureMode__Base",
    "hipStreamCaptureMode",
    "_hipStreamCaptureStatus__Base",
    "hipStreamCaptureStatus",
    "_hipStreamUpdateCaptureDependenciesFlags__Base",
    "hipStreamUpdateCaptureDependenciesFlags",
    "_hipGraphMemAttributeType__Base",
    "hipGraphMemAttributeType",
    "_hipUserObjectFlags__Base",
    "hipUserObjectFlags",
    "_hipUserObjectRetainFlags__Base",
    "hipUserObjectRetainFlags",
    "_hipGraphInstantiateFlags__Base",
    "hipGraphInstantiateFlags",
    "_hipGraphDebugDotFlags__Base",
    "hipGraphDebugDotFlags",
    "_hipGraphInstantiateResult__Base",
    "hipGraphInstantiateResult",
    "hipGraphInstantiateParams",
    "hipMemAllocationProp_struct_0",
    "hipMemAllocationProp",
    "hipExternalSemaphoreSignalNodeParams",
    "hipExternalSemaphoreWaitNodeParams",
    "ihipMemGenericAllocationHandle",
    "hipMemGenericAllocationHandle_t",
    "_hipMemAllocationGranularity_flags__Base",
    "hipMemAllocationGranularity_flags",
    "_hipMemHandleType__Base",
    "hipMemHandleType",
    "_hipMemOperationType__Base",
    "hipMemOperationType",
    "_hipArraySparseSubresourceType__Base",
    "hipArraySparseSubresourceType",
    "hipArrayMapInfo_union_0",
    "hipArrayMapInfo_union_1_struct_0",
    "hipArrayMapInfo_union_1_struct_1",
    "hipArrayMapInfo_union_1",
    "hipArrayMapInfo_union_2",
    "hipArrayMapInfo",
    "hipMemcpyNodeParams",
    "hipChildGraphNodeParams",
    "hipEventWaitNodeParams",
    "hipEventRecordNodeParams",
    "hipMemFreeNodeParams",
    "hipGraphNodeParams_union_0",
    "hipGraphNodeParams",
    "_hipGraphDependencyType__Base",
    "hipGraphDependencyType",
    "hipGraphEdgeData",
    "hipInit",
    "hipDriverGetVersion",
    "hipRuntimeGetVersion",
    "hipDeviceGet",
    "hipDeviceComputeCapability",
    "hipDeviceGetName",
    "hipDeviceGetUuid",
    "hipDeviceGetP2PAttribute",
    "hipDeviceGetPCIBusId",
    "hipDeviceGetByPCIBusId",
    "hipDeviceTotalMem",
    "hipDeviceSynchronize",
    "hipDeviceReset",
    "hipSetDevice",
    "hipSetValidDevices",
    "hipGetDevice",
    "hipGetDeviceCount",
    "hipDeviceGetAttribute",
    "hipDeviceGetDefaultMemPool",
    "hipDeviceSetMemPool",
    "hipDeviceGetMemPool",
    "hipGetDeviceProperties",
    "hipDeviceSetCacheConfig",
    "hipDeviceGetCacheConfig",
    "hipDeviceGetLimit",
    "hipDeviceSetLimit",
    "hipDeviceGetSharedMemConfig",
    "hipGetDeviceFlags",
    "hipDeviceSetSharedMemConfig",
    "hipSetDeviceFlags",
    "hipChooseDevice",
    "hipExtGetLinkTypeAndHopCount",
    "hipIpcGetMemHandle",
    "hipIpcOpenMemHandle",
    "hipIpcCloseMemHandle",
    "hipIpcGetEventHandle",
    "hipIpcOpenEventHandle",
    "hipFuncSetAttribute",
    "hipFuncSetCacheConfig",
    "hipFuncSetSharedMemConfig",
    "hipGetLastError",
    "hipExtGetLastError",
    "hipPeekAtLastError",
    "hipGetErrorName",
    "hipGetErrorString",
    "hipDrvGetErrorName",
    "hipDrvGetErrorString",
    "hipStreamCreate",
    "hipStreamCreateWithFlags",
    "hipStreamCreateWithPriority",
    "hipDeviceGetStreamPriorityRange",
    "hipStreamDestroy",
    "hipStreamQuery",
    "hipStreamSynchronize",
    "hipStreamWaitEvent",
    "hipStreamGetFlags",
    "hipStreamGetPriority",
    "hipStreamGetDevice",
    "hipExtStreamCreateWithCUMask",
    "hipExtStreamGetCUMask",
    "hipStreamCallback_t",
    "hipStreamAddCallback",
    "hipStreamWaitValue32",
    "hipStreamWaitValue64",
    "hipStreamWriteValue32",
    "hipStreamWriteValue64",
    "hipEventCreateWithFlags",
    "hipEventCreate",
    "hipEventRecord",
    "hipEventDestroy",
    "hipEventSynchronize",
    "hipEventElapsedTime",
    "hipEventQuery",
    "hipPointerSetAttribute",
    "hipPointerGetAttributes",
    "hipPointerGetAttribute",
    "hipDrvPointerGetAttributes",
    "hipImportExternalSemaphore",
    "hipSignalExternalSemaphoresAsync",
    "hipWaitExternalSemaphoresAsync",
    "hipDestroyExternalSemaphore",
    "hipImportExternalMemory",
    "hipExternalMemoryGetMappedBuffer",
    "hipDestroyExternalMemory",
    "hipExternalMemoryGetMappedMipmappedArray",
    "hipMalloc",
    "hipExtMallocWithFlags",
    "hipMallocHost",
    "hipMemAllocHost",
    "hipHostMalloc",
    "hipMallocManaged",
    "hipMemPrefetchAsync",
    "hipMemAdvise",
    "hipMemRangeGetAttribute",
    "hipMemRangeGetAttributes",
    "hipStreamAttachMemAsync",
    "hipMallocAsync",
    "hipFreeAsync",
    "hipMemPoolTrimTo",
    "hipMemPoolSetAttribute",
    "hipMemPoolGetAttribute",
    "hipMemPoolSetAccess",
    "hipMemPoolGetAccess",
    "hipMemPoolCreate",
    "hipMemPoolDestroy",
    "hipMallocFromPoolAsync",
    "hipMemPoolExportToShareableHandle",
    "hipMemPoolImportFromShareableHandle",
    "hipMemPoolExportPointer",
    "hipMemPoolImportPointer",
    "hipHostAlloc",
    "hipHostGetDevicePointer",
    "hipHostGetFlags",
    "hipHostRegister",
    "hipHostUnregister",
    "hipMallocPitch",
    "hipMemAllocPitch",
    "hipFree",
    "hipFreeHost",
    "hipHostFree",
    "hipMemcpy",
    "hipMemcpyWithStream",
    "hipMemcpyHtoD",
    "hipMemcpyDtoH",
    "hipMemcpyDtoD",
    "hipMemcpyAtoD",
    "hipMemcpyDtoA",
    "hipMemcpyAtoA",
    "hipMemcpyHtoDAsync",
    "hipMemcpyDtoHAsync",
    "hipMemcpyDtoDAsync",
    "hipMemcpyAtoHAsync",
    "hipMemcpyHtoAAsync",
    "hipModuleGetGlobal",
    "hipGetSymbolAddress",
    "hipGetSymbolSize",
    "hipGetProcAddress",
    "hipMemcpyToSymbol",
    "hipMemcpyToSymbolAsync",
    "hipMemcpyFromSymbol",
    "hipMemcpyFromSymbolAsync",
    "hipMemcpyAsync",
    "hipMemset",
    "hipMemsetD8",
    "hipMemsetD8Async",
    "hipMemsetD16",
    "hipMemsetD16Async",
    "hipMemsetD32",
    "hipMemsetAsync",
    "hipMemsetD32Async",
    "hipMemset2D",
    "hipMemset2DAsync",
    "hipMemset3D",
    "hipMemset3DAsync",
    "hipMemGetInfo",
    "hipMemPtrGetInfo",
    "hipMallocArray",
    "hipArrayCreate",
    "hipArrayDestroy",
    "hipArray3DCreate",
    "hipMalloc3D",
    "hipFreeArray",
    "hipMalloc3DArray",
    "hipArrayGetInfo",
    "hipArrayGetDescriptor",
    "hipArray3DGetDescriptor",
    "hipMemcpy2D",
    "hipMemcpyParam2D",
    "hipMemcpyParam2DAsync",
    "hipMemcpy2DAsync",
    "hipMemcpy2DToArray",
    "hipMemcpy2DToArrayAsync",
    "hipMemcpy2DArrayToArray",
    "hipMemcpyToArray",
    "hipMemcpyFromArray",
    "hipMemcpy2DFromArray",
    "hipMemcpy2DFromArrayAsync",
    "hipMemcpyAtoH",
    "hipMemcpyHtoA",
    "hipMemcpy3D",
    "hipMemcpy3DAsync",
    "hipDrvMemcpy3D",
    "hipDrvMemcpy3DAsync",
    "hipDeviceCanAccessPeer",
    "hipDeviceEnablePeerAccess",
    "hipDeviceDisablePeerAccess",
    "hipMemGetAddressRange",
    "hipMemcpyPeer",
    "hipMemcpyPeerAsync",
    "hipCtxCreate",
    "hipCtxDestroy",
    "hipCtxPopCurrent",
    "hipCtxPushCurrent",
    "hipCtxSetCurrent",
    "hipCtxGetCurrent",
    "hipCtxGetDevice",
    "hipCtxGetApiVersion",
    "hipCtxGetCacheConfig",
    "hipCtxSetCacheConfig",
    "hipCtxSetSharedMemConfig",
    "hipCtxGetSharedMemConfig",
    "hipCtxSynchronize",
    "hipCtxGetFlags",
    "hipCtxEnablePeerAccess",
    "hipCtxDisablePeerAccess",
    "hipDevicePrimaryCtxGetState",
    "hipDevicePrimaryCtxRelease",
    "hipDevicePrimaryCtxRetain",
    "hipDevicePrimaryCtxReset",
    "hipDevicePrimaryCtxSetFlags",
    "hipModuleLoad",
    "hipModuleUnload",
    "hipModuleGetFunction",
    "hipFuncGetAttributes",
    "hipFuncGetAttribute",
    "hipGetFuncBySymbol",
    "hipModuleGetTexRef",
    "hipModuleLoadData",
    "hipModuleLoadDataEx",
    "hipModuleLaunchKernel",
    "hipModuleLaunchCooperativeKernel",
    "hipModuleLaunchCooperativeKernelMultiDevice",
    "hipLaunchCooperativeKernel",
    "hipLaunchCooperativeKernelMultiDevice",
    "hipExtLaunchMultiKernelMultiDevice",
    "hipModuleOccupancyMaxPotentialBlockSize",
    "hipModuleOccupancyMaxPotentialBlockSizeWithFlags",
    "hipModuleOccupancyMaxActiveBlocksPerMultiprocessor",
    "hipModuleOccupancyMaxActiveBlocksPerMultiprocessorWithFlags",
    "hipOccupancyMaxActiveBlocksPerMultiprocessor",
    "hipOccupancyMaxActiveBlocksPerMultiprocessorWithFlags",
    "hipOccupancyMaxPotentialBlockSize",
    "hipProfilerStart",
    "hipProfilerStop",
    "hipConfigureCall",
    "hipSetupArgument",
    "hipLaunchByPtr",
    "hipLaunchKernel",
    "hipLaunchHostFunc",
    "hipDrvMemcpy2DUnaligned",
    "hipExtLaunchKernel",
    "hipCreateTextureObject",
    "hipDestroyTextureObject",
    "hipGetChannelDesc",
    "hipGetTextureObjectResourceDesc",
    "hipGetTextureObjectResourceViewDesc",
    "hipGetTextureObjectTextureDesc",
    "hipTexObjectCreate",
    "hipTexObjectDestroy",
    "hipTexObjectGetResourceDesc",
    "hipTexObjectGetResourceViewDesc",
    "hipTexObjectGetTextureDesc",
    "hipMallocMipmappedArray",
    "hipFreeMipmappedArray",
    "hipGetMipmappedArrayLevel",
    "hipMipmappedArrayCreate",
    "hipMipmappedArrayDestroy",
    "hipMipmappedArrayGetLevel",
    "hipBindTextureToMipmappedArray",
    "hipGetTextureReference",
    "hipTexRefGetBorderColor",
    "hipTexRefGetArray",
    "hipTexRefSetAddressMode",
    "hipTexRefSetArray",
    "hipTexRefSetFilterMode",
    "hipTexRefSetFlags",
    "hipTexRefSetFormat",
    "hipBindTexture",
    "hipBindTexture2D",
    "hipBindTextureToArray",
    "hipGetTextureAlignmentOffset",
    "hipUnbindTexture",
    "hipTexRefGetAddress",
    "hipTexRefGetAddressMode",
    "hipTexRefGetFilterMode",
    "hipTexRefGetFlags",
    "hipTexRefGetFormat",
    "hipTexRefGetMaxAnisotropy",
    "hipTexRefGetMipmapFilterMode",
    "hipTexRefGetMipmapLevelBias",
    "hipTexRefGetMipmapLevelClamp",
    "hipTexRefGetMipMappedArray",
    "hipTexRefSetAddress",
    "hipTexRefSetAddress2D",
    "hipTexRefSetMaxAnisotropy",
    "hipTexRefSetBorderColor",
    "hipTexRefSetMipmapFilterMode",
    "hipTexRefSetMipmapLevelBias",
    "hipTexRefSetMipmapLevelClamp",
    "hipTexRefSetMipmappedArray",
    "hipApiName",
    "hipKernelNameRef",
    "hipKernelNameRefByPtr",
    "hipGetStreamDeviceId",
    "hipStreamBeginCapture",
    "hipStreamBeginCaptureToGraph",
    "hipStreamEndCapture",
    "hipStreamGetCaptureInfo",
    "hipStreamGetCaptureInfo_v2",
    "hipStreamIsCapturing",
    "hipStreamUpdateCaptureDependencies",
    "hipThreadExchangeStreamCaptureMode",
    "hipGraphCreate",
    "hipGraphDestroy",
    "hipGraphAddDependencies",
    "hipGraphRemoveDependencies",
    "hipGraphGetEdges",
    "hipGraphGetNodes",
    "hipGraphGetRootNodes",
    "hipGraphNodeGetDependencies",
    "hipGraphNodeGetDependentNodes",
    "hipGraphNodeGetType",
    "hipGraphDestroyNode",
    "hipGraphClone",
    "hipGraphNodeFindInClone",
    "hipGraphInstantiate",
    "hipGraphInstantiateWithFlags",
    "hipGraphInstantiateWithParams",
    "hipGraphLaunch",
    "hipGraphUpload",
    "hipGraphAddNode",
    "hipGraphExecDestroy",
    "hipGraphExecUpdate",
    "hipGraphAddKernelNode",
    "hipGraphKernelNodeGetParams",
    "hipGraphKernelNodeSetParams",
    "hipGraphExecKernelNodeSetParams",
    "hipDrvGraphAddMemcpyNode",
    "hipGraphAddMemcpyNode",
    "hipGraphMemcpyNodeGetParams",
    "hipGraphMemcpyNodeSetParams",
    "hipGraphKernelNodeSetAttribute",
    "hipGraphKernelNodeGetAttribute",
    "hipGraphExecMemcpyNodeSetParams",
    "hipGraphAddMemcpyNode1D",
    "hipGraphMemcpyNodeSetParams1D",
    "hipGraphExecMemcpyNodeSetParams1D",
    "hipGraphAddMemcpyNodeFromSymbol",
    "hipGraphMemcpyNodeSetParamsFromSymbol",
    "hipGraphExecMemcpyNodeSetParamsFromSymbol",
    "hipGraphAddMemcpyNodeToSymbol",
    "hipGraphMemcpyNodeSetParamsToSymbol",
    "hipGraphExecMemcpyNodeSetParamsToSymbol",
    "hipGraphAddMemsetNode",
    "hipGraphMemsetNodeGetParams",
    "hipGraphMemsetNodeSetParams",
    "hipGraphExecMemsetNodeSetParams",
    "hipGraphAddHostNode",
    "hipGraphHostNodeGetParams",
    "hipGraphHostNodeSetParams",
    "hipGraphExecHostNodeSetParams",
    "hipGraphAddChildGraphNode",
    "hipGraphChildGraphNodeGetGraph",
    "hipGraphExecChildGraphNodeSetParams",
    "hipGraphAddEmptyNode",
    "hipGraphAddEventRecordNode",
    "hipGraphEventRecordNodeGetEvent",
    "hipGraphEventRecordNodeSetEvent",
    "hipGraphExecEventRecordNodeSetEvent",
    "hipGraphAddEventWaitNode",
    "hipGraphEventWaitNodeGetEvent",
    "hipGraphEventWaitNodeSetEvent",
    "hipGraphExecEventWaitNodeSetEvent",
    "hipGraphAddMemAllocNode",
    "hipGraphMemAllocNodeGetParams",
    "hipGraphAddMemFreeNode",
    "hipGraphMemFreeNodeGetParams",
    "hipDeviceGetGraphMemAttribute",
    "hipDeviceSetGraphMemAttribute",
    "hipDeviceGraphMemTrim",
    "hipUserObjectCreate",
    "hipUserObjectRelease",
    "hipUserObjectRetain",
    "hipGraphRetainUserObject",
    "hipGraphReleaseUserObject",
    "hipGraphDebugDotPrint",
    "hipGraphKernelNodeCopyAttributes",
    "hipGraphNodeSetEnabled",
    "hipGraphNodeGetEnabled",
    "hipGraphAddExternalSemaphoresWaitNode",
    "hipGraphAddExternalSemaphoresSignalNode",
    "hipGraphExternalSemaphoresSignalNodeSetParams",
    "hipGraphExternalSemaphoresWaitNodeSetParams",
    "hipGraphExternalSemaphoresSignalNodeGetParams",
    "hipGraphExternalSemaphoresWaitNodeGetParams",
    "hipGraphExecExternalSemaphoresSignalNodeSetParams",
    "hipGraphExecExternalSemaphoresWaitNodeSetParams",
    "hipDrvGraphAddMemsetNode",
    "hipMemAddressFree",
    "hipMemAddressReserve",
    "hipMemCreate",
    "hipMemExportToShareableHandle",
    "hipMemGetAccess",
    "hipMemGetAllocationGranularity",
    "hipMemGetAllocationPropertiesFromHandle",
    "hipMemImportFromShareableHandle",
    "hipMemMap",
    "hipMemMapArrayAsync",
    "hipMemRelease",
    "hipMemRetainAllocationHandle",
    "hipMemSetAccess",
    "hipMemUnmap",
    "hipGraphicsMapResources",
    "hipGraphicsSubResourceGetMappedArray",
    "hipGraphicsResourceGetMappedPointer",
    "hipGraphicsUnmapResources",
    "hipGraphicsUnregisterResource",
    "hipCreateSurfaceObject",
    "hipDestroySurfaceObject",
    "hipMemcpy_spt",
    "hipMemcpyToSymbol_spt",
    "hipMemcpyFromSymbol_spt",
    "hipMemcpy2D_spt",
    "hipMemcpy2DFromArray_spt",
    "hipMemcpy3D_spt",
    "hipMemset_spt",
    "hipMemsetAsync_spt",
    "hipMemset2D_spt",
    "hipMemset2DAsync_spt",
    "hipMemset3DAsync_spt",
    "hipMemset3D_spt",
    "hipMemcpyAsync_spt",
    "hipMemcpy3DAsync_spt",
    "hipMemcpy2DAsync_spt",
    "hipMemcpyFromSymbolAsync_spt",
    "hipMemcpyToSymbolAsync_spt",
    "hipMemcpyFromArray_spt",
    "hipMemcpy2DToArray_spt",
    "hipMemcpy2DFromArrayAsync_spt",
    "hipMemcpy2DToArrayAsync_spt",
    "hipStreamQuery_spt",
    "hipStreamSynchronize_spt",
    "hipStreamGetPriority_spt",
    "hipStreamWaitEvent_spt",
    "hipStreamGetFlags_spt",
    "hipStreamAddCallback_spt",
    "hipEventRecord_spt",
    "hipLaunchCooperativeKernel_spt",
    "hipLaunchKernel_spt",
    "hipGraphLaunch_spt",
    "hipStreamBeginCapture_spt",
    "hipStreamEndCapture_spt",
    "hipStreamIsCapturing_spt",
    "hipStreamGetCaptureInfo_spt",
    "hipStreamGetCaptureInfo_v2_spt",
    "hipLaunchHostFunc_spt",
    "_hipDataType__Base",
    "hipDataType",
    "_hipLibraryPropertyType__Base",
    "hipLibraryPropertyType",
]