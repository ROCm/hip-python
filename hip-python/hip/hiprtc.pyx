# MIT License
#
# Copyright (c) 2023-2024 Advanced Micro Devices, Inc.
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in all
# copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
# SOFTWARE.

# This file has been autogenerated, do not modify.


"""
(No short description)

Attributes:
    hiprtcLinkState:
        alias of `~.ihiprtcLinkState`

    hiprtcProgram:
        alias of `~._hiprtcProgram`

"""

import cython
import ctypes
import enum
cimport hip._hiprtc_helpers
class _hiprtcResult__Base(enum.IntEnum):
    """Empty enum base class that allows subclassing.
    """
    pass
class hiprtcResult(_hiprtcResult__Base):
    """@{

    Attributes:
        HIPRTC_SUCCESS:
            Success
        HIPRTC_ERROR_OUT_OF_MEMORY:
            Out of memory
        HIPRTC_ERROR_PROGRAM_CREATION_FAILURE:
            Failed to create program
        HIPRTC_ERROR_INVALID_INPUT:
            Invalid input
        HIPRTC_ERROR_INVALID_PROGRAM:
            Invalid program
        HIPRTC_ERROR_INVALID_OPTION:
            Invalid option
        HIPRTC_ERROR_COMPILATION:
            Compilation error
        HIPRTC_ERROR_BUILTIN_OPERATION_FAILURE:
            Failed in builtin operation
        HIPRTC_ERROR_NO_NAME_EXPRESSIONS_AFTER_COMPILATION:
            No name expression after compilation
        HIPRTC_ERROR_NO_LOWERED_NAMES_BEFORE_COMPILATION:
            No lowered names before compilation
        HIPRTC_ERROR_NAME_EXPRESSION_NOT_VALID:
            Invalid name expression
        HIPRTC_ERROR_INTERNAL_ERROR:
            Internal error
        HIPRTC_ERROR_LINKING:
            Error in linking
    """
    HIPRTC_SUCCESS = chiprtc.HIPRTC_SUCCESS
    HIPRTC_ERROR_OUT_OF_MEMORY = chiprtc.HIPRTC_ERROR_OUT_OF_MEMORY
    HIPRTC_ERROR_PROGRAM_CREATION_FAILURE = chiprtc.HIPRTC_ERROR_PROGRAM_CREATION_FAILURE
    HIPRTC_ERROR_INVALID_INPUT = chiprtc.HIPRTC_ERROR_INVALID_INPUT
    HIPRTC_ERROR_INVALID_PROGRAM = chiprtc.HIPRTC_ERROR_INVALID_PROGRAM
    HIPRTC_ERROR_INVALID_OPTION = chiprtc.HIPRTC_ERROR_INVALID_OPTION
    HIPRTC_ERROR_COMPILATION = chiprtc.HIPRTC_ERROR_COMPILATION
    HIPRTC_ERROR_BUILTIN_OPERATION_FAILURE = chiprtc.HIPRTC_ERROR_BUILTIN_OPERATION_FAILURE
    HIPRTC_ERROR_NO_NAME_EXPRESSIONS_AFTER_COMPILATION = chiprtc.HIPRTC_ERROR_NO_NAME_EXPRESSIONS_AFTER_COMPILATION
    HIPRTC_ERROR_NO_LOWERED_NAMES_BEFORE_COMPILATION = chiprtc.HIPRTC_ERROR_NO_LOWERED_NAMES_BEFORE_COMPILATION
    HIPRTC_ERROR_NAME_EXPRESSION_NOT_VALID = chiprtc.HIPRTC_ERROR_NAME_EXPRESSION_NOT_VALID
    HIPRTC_ERROR_INTERNAL_ERROR = chiprtc.HIPRTC_ERROR_INTERNAL_ERROR
    HIPRTC_ERROR_LINKING = chiprtc.HIPRTC_ERROR_LINKING
    @staticmethod
    def ctypes_type():
        """The type of the enum constants as ctypes type."""
        return ctypes.c_uint


class _hiprtcJIT_option__Base(enum.IntEnum):
    """Empty enum base class that allows subclassing.
    """
    pass
class hiprtcJIT_option(_hiprtcJIT_option__Base):
    """hiprtc JIT option

    Attributes:
        HIPRTC_JIT_MAX_REGISTERS:
            CUDA Only Maximum registers may be used in a thread, passed to compiler
        HIPRTC_JIT_THREADS_PER_BLOCK:
            CUDA Only Number of thread per block
        HIPRTC_JIT_WALL_TIME:
            CUDA Only Value for total wall clock time
        HIPRTC_JIT_INFO_LOG_BUFFER:
            CUDA Only Pointer to the buffer with logged information
        HIPRTC_JIT_INFO_LOG_BUFFER_SIZE_BYTES:
            CUDA Only Size of the buffer in bytes for logged info
        HIPRTC_JIT_ERROR_LOG_BUFFER:
            CUDA Only Pointer to the buffer with logged error(s)
        HIPRTC_JIT_ERROR_LOG_BUFFER_SIZE_BYTES:
            CUDA Only Size of the buffer in bytes for logged error(s)
        HIPRTC_JIT_OPTIMIZATION_LEVEL:
            Value of optimization level for generated codes, acceptable options -O0, -O1, -O2, -O3
        HIPRTC_JIT_TARGET_FROM_HIPCONTEXT:
            CUDA Only The target context, which is the default
        HIPRTC_JIT_TARGET:
            CUDA Only JIT target
        HIPRTC_JIT_FALLBACK_STRATEGY:
            CUDA Only Fallback strategy
        HIPRTC_JIT_GENERATE_DEBUG_INFO:
            CUDA Only Generate debug information
        HIPRTC_JIT_LOG_VERBOSE:
            CUDA Only Generate log verbose
        HIPRTC_JIT_GENERATE_LINE_INFO:
            CUDA Only Generate line number information
        HIPRTC_JIT_CACHE_MODE:
            CUDA Only Set cache mode
        HIPRTC_JIT_NEW_SM3X_OPT:

        HIPRTC_JIT_FAST_COMPILE:
            CUDA Only Set fast compile
        HIPRTC_JIT_GLOBAL_SYMBOL_NAMES:
            CUDA Only Array of device symbol names to be relocated to the host
        HIPRTC_JIT_GLOBAL_SYMBOL_ADDRESS:
            CUDA Only Array of host addresses to be relocated to the device
        HIPRTC_JIT_GLOBAL_SYMBOL_COUNT:
            CUDA Only Number of symbol count.
        HIPRTC_JIT_LTO:

        HIPRTC_JIT_FTZ:

        HIPRTC_JIT_PREC_DIV:

        HIPRTC_JIT_PREC_SQRT:

        HIPRTC_JIT_FMA:

        HIPRTC_JIT_NUM_OPTIONS:
            Number of options
        HIPRTC_JIT_IR_TO_ISA_OPT_EXT:
            Linker options to be passed on to compiler
        HIPRTC_JIT_IR_TO_ISA_OPT_COUNT_EXT:
            Count of linker options to be passed on to compiler
    """
    HIPRTC_JIT_MAX_REGISTERS = chiprtc.HIPRTC_JIT_MAX_REGISTERS
    HIPRTC_JIT_THREADS_PER_BLOCK = chiprtc.HIPRTC_JIT_THREADS_PER_BLOCK
    HIPRTC_JIT_WALL_TIME = chiprtc.HIPRTC_JIT_WALL_TIME
    HIPRTC_JIT_INFO_LOG_BUFFER = chiprtc.HIPRTC_JIT_INFO_LOG_BUFFER
    HIPRTC_JIT_INFO_LOG_BUFFER_SIZE_BYTES = chiprtc.HIPRTC_JIT_INFO_LOG_BUFFER_SIZE_BYTES
    HIPRTC_JIT_ERROR_LOG_BUFFER = chiprtc.HIPRTC_JIT_ERROR_LOG_BUFFER
    HIPRTC_JIT_ERROR_LOG_BUFFER_SIZE_BYTES = chiprtc.HIPRTC_JIT_ERROR_LOG_BUFFER_SIZE_BYTES
    HIPRTC_JIT_OPTIMIZATION_LEVEL = chiprtc.HIPRTC_JIT_OPTIMIZATION_LEVEL
    HIPRTC_JIT_TARGET_FROM_HIPCONTEXT = chiprtc.HIPRTC_JIT_TARGET_FROM_HIPCONTEXT
    HIPRTC_JIT_TARGET = chiprtc.HIPRTC_JIT_TARGET
    HIPRTC_JIT_FALLBACK_STRATEGY = chiprtc.HIPRTC_JIT_FALLBACK_STRATEGY
    HIPRTC_JIT_GENERATE_DEBUG_INFO = chiprtc.HIPRTC_JIT_GENERATE_DEBUG_INFO
    HIPRTC_JIT_LOG_VERBOSE = chiprtc.HIPRTC_JIT_LOG_VERBOSE
    HIPRTC_JIT_GENERATE_LINE_INFO = chiprtc.HIPRTC_JIT_GENERATE_LINE_INFO
    HIPRTC_JIT_CACHE_MODE = chiprtc.HIPRTC_JIT_CACHE_MODE
    HIPRTC_JIT_NEW_SM3X_OPT = chiprtc.HIPRTC_JIT_NEW_SM3X_OPT
    HIPRTC_JIT_FAST_COMPILE = chiprtc.HIPRTC_JIT_FAST_COMPILE
    HIPRTC_JIT_GLOBAL_SYMBOL_NAMES = chiprtc.HIPRTC_JIT_GLOBAL_SYMBOL_NAMES
    HIPRTC_JIT_GLOBAL_SYMBOL_ADDRESS = chiprtc.HIPRTC_JIT_GLOBAL_SYMBOL_ADDRESS
    HIPRTC_JIT_GLOBAL_SYMBOL_COUNT = chiprtc.HIPRTC_JIT_GLOBAL_SYMBOL_COUNT
    HIPRTC_JIT_LTO = chiprtc.HIPRTC_JIT_LTO
    HIPRTC_JIT_FTZ = chiprtc.HIPRTC_JIT_FTZ
    HIPRTC_JIT_PREC_DIV = chiprtc.HIPRTC_JIT_PREC_DIV
    HIPRTC_JIT_PREC_SQRT = chiprtc.HIPRTC_JIT_PREC_SQRT
    HIPRTC_JIT_FMA = chiprtc.HIPRTC_JIT_FMA
    HIPRTC_JIT_NUM_OPTIONS = chiprtc.HIPRTC_JIT_NUM_OPTIONS
    HIPRTC_JIT_IR_TO_ISA_OPT_EXT = chiprtc.HIPRTC_JIT_IR_TO_ISA_OPT_EXT
    HIPRTC_JIT_IR_TO_ISA_OPT_COUNT_EXT = chiprtc.HIPRTC_JIT_IR_TO_ISA_OPT_COUNT_EXT
    @staticmethod
    def ctypes_type():
        """The type of the enum constants as ctypes type."""
        return ctypes.c_uint


class _hiprtcJITInputType__Base(enum.IntEnum):
    """Empty enum base class that allows subclassing.
    """
    pass
class hiprtcJITInputType(_hiprtcJITInputType__Base):
    """hiprtc JIT input type

    Attributes:
        HIPRTC_JIT_INPUT_CUBIN:
            Input cubin
        HIPRTC_JIT_INPUT_PTX:
            Input PTX
        HIPRTC_JIT_INPUT_FATBINARY:
            Input fat binary
        HIPRTC_JIT_INPUT_OBJECT:
            Input object
        HIPRTC_JIT_INPUT_LIBRARY:
            Input library
        HIPRTC_JIT_INPUT_NVVM:
            Input NVVM
        HIPRTC_JIT_NUM_LEGACY_INPUT_TYPES:
            Number of legacy input type
        HIPRTC_JIT_INPUT_LLVM_BITCODE:
            LLVM bitcode or IR assembly
        HIPRTC_JIT_INPUT_LLVM_BUNDLED_BITCODE:
            LLVM bundled bitcode
        HIPRTC_JIT_INPUT_LLVM_ARCHIVES_OF_BUNDLED_BITCODE:
            LLVM archives of boundled bitcode
        HIPRTC_JIT_NUM_INPUT_TYPES:
            (undocumented)
    """
    HIPRTC_JIT_INPUT_CUBIN = chiprtc.HIPRTC_JIT_INPUT_CUBIN
    HIPRTC_JIT_INPUT_PTX = chiprtc.HIPRTC_JIT_INPUT_PTX
    HIPRTC_JIT_INPUT_FATBINARY = chiprtc.HIPRTC_JIT_INPUT_FATBINARY
    HIPRTC_JIT_INPUT_OBJECT = chiprtc.HIPRTC_JIT_INPUT_OBJECT
    HIPRTC_JIT_INPUT_LIBRARY = chiprtc.HIPRTC_JIT_INPUT_LIBRARY
    HIPRTC_JIT_INPUT_NVVM = chiprtc.HIPRTC_JIT_INPUT_NVVM
    HIPRTC_JIT_NUM_LEGACY_INPUT_TYPES = chiprtc.HIPRTC_JIT_NUM_LEGACY_INPUT_TYPES
    HIPRTC_JIT_INPUT_LLVM_BITCODE = chiprtc.HIPRTC_JIT_INPUT_LLVM_BITCODE
    HIPRTC_JIT_INPUT_LLVM_BUNDLED_BITCODE = chiprtc.HIPRTC_JIT_INPUT_LLVM_BUNDLED_BITCODE
    HIPRTC_JIT_INPUT_LLVM_ARCHIVES_OF_BUNDLED_BITCODE = chiprtc.HIPRTC_JIT_INPUT_LLVM_ARCHIVES_OF_BUNDLED_BITCODE
    HIPRTC_JIT_NUM_INPUT_TYPES = chiprtc.HIPRTC_JIT_NUM_INPUT_TYPES
    @staticmethod
    def ctypes_type():
        """The type of the enum constants as ctypes type."""
        return ctypes.c_uint


cdef class ihiprtcLinkState(hip._util.types.Pointer):
    """Python wrapper for cdef class chiprtc.ihiprtcLinkState.

    Python wrapper for cdef class chiprtc.ihiprtcLinkState.

    If this type is initialized via its `__init__` method, it allocates a
    member of the underlying C type and destroys it again if the wrapper
    type is deallocated.

    This type also serves as adapter when appearing as argument type in a
    function signature. In this case, the type can further be initialized
    from a number of Python objects:

    * `None`:

      This will set the ``self._ptr`` attribute to ``NULL``.

    * `int`:

      Interprets the integer value as pointer address and writes it to ``self._ptr``.
      No ownership is transferred.

    * `ctypes.c_void_p`:

      Takes the pointer address ``pyobj.value`` and writes it to ``self._ptr``.
      No ownership is transferred.

    * `object` that implements the `CUDA Array Interface <https://numba.readthedocs.io/en/stable/cuda/cuda_array_interface.html>`_ protocol:

      Takes the integer-valued pointer address, i.e. the first entry of the `data` tuple
      from `pyobj`'s member ``__cuda_array_interface__``  and writes it to ``self._ptr``.

    * `object` that implements the Python buffer protocol:

      If the object represents a simple contiguous array,
      writes the `Py_buffer` associated with ``pyobj`` to `self._py_buffer`,
      sets the `self._py_buffer_acquired` flag to `True`, and
      writes `self._py_buffer.buf` to the data pointer `self._ptr`.

    * `hip._util.types.Pointer`:

      Takes the pointer address ``pyobj._ptr`` and writes it to ``self._ptr``.
      No ownership is transferred.

    Type checks are performed in the above order.

    C Attributes:
        _ptr (C type ``void *``, protected):
            Stores a pointer to the data of the original Python object.
        _is_ptr_owner (C type ``bint``, protected):
            If this wrapper is the owner of the underlying data.
        _py_buffer (C type ``Py_buffer`, protected):
            Stores a pointer to the data of the original Python object.
        _py_buffer_acquired (C type ``bint``, protected):
            Stores a pointer to the data of the original Python object.
    """
    # C members declared in pxd file

    def __cinit__(self):
        self._ptr = NULL
        self._is_ptr_owner = False
        self._py_buffer_acquired = False

    cdef chiprtc.ihiprtcLinkState* getElementPtr(self):
        return <chiprtc.ihiprtcLinkState*>self._ptr

    @staticmethod
    cdef ihiprtcLinkState fromPtr(void* ptr, bint owner=False):
        """Factory function to create ``ihiprtcLinkState`` objects from
        given ``chiprtc.ihiprtcLinkState`` pointer.
        """
        # Fast call to __new__() that bypasses the __init__() constructor.
        cdef ihiprtcLinkState wrapper = ihiprtcLinkState.__new__(ihiprtcLinkState)
        wrapper._ptr = ptr
        wrapper._is_ptr_owner = owner
        return wrapper

    @staticmethod
    def fromObj(pyobj):
        """Creates a ihiprtcLinkState from a Python object.

        Derives a ihiprtcLinkState from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``ihiprtcLinkState`` reference, this method
        returns it directly. No new ``ihiprtcLinkState`` is created in this case.
        """
        return ihiprtcLinkState.fromPyobj(pyobj)

    @staticmethod
    cdef ihiprtcLinkState fromPyobj(object pyobj):
        """Creates a ihiprtcLinkState from a Python object.

        Derives a ihiprtcLinkState from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``ihiprtcLinkState`` reference, this method
        returns it directly. No new ``ihiprtcLinkState`` is created in this case.

        Args:
            pyobj (object): Must be either `None`; a `hip._util.types.Pointer`; a simple, contiguous buffer according to the buffer protocol;
                            or of type `ihiprtcLinkState`; `int`; or `ctypes.c_void_p`.

        Note:
            This routine does not perform a copy but returns the original ``pyobj``
            if ``pyobj`` is an instance of ihiprtcLinkState!
        """
        cdef ihiprtcLinkState wrapper

        if isinstance(pyobj,ihiprtcLinkState):
            return pyobj
        else:
            wrapper = ihiprtcLinkState.__new__(ihiprtcLinkState)
            wrapper.init_from_pyobj(pyobj)
            return wrapper

    def __dealloc__(self):
        # Release the buffer handle
        if self._py_buffer_acquired is True:
            cpython.buffer.PyBuffer_Release(&self._py_buffer)

    def __int__(self):
        """Returns the data's address as long integer.
        """
        return cpython.long.PyLong_FromVoidPtr(self._ptr)

    def __repr__(self):
        return f"<ihiprtcLinkState object, ptr: {int(self)}>"

    def as_c_void_p(self):
        """Returns the data's address as `ctypes.c_void_p`
        Note:
            Implemented as function to not collide with
            autogenerated property names.
        """
        return ctypes.c_void_p(int(self))

    @staticmethod
    def PROPERTIES():
        return []

    def __contains__(self,item):
        properties = self.PROPERTIES()
        return item in properties

    def __getitem__(self,item):
        properties = self.PROPERTIES()
        if isinstance(item,int):
            if item < 0 or item >= len(properties):
                raise IndexError()
            return getattr(self,properties[item])
        raise ValueError("'item' type must be 'int'")


hiprtcLinkState = ihiprtcLinkState

@cython.embedsignature(True)
def hiprtcGetErrorString(object result):
    r"""Returns text string message to explain the error which occurred

    Warning:
        In HIP, this function returns the name of the error,
        if the hiprtc result is defined, it will return "Invalid HIPRTC error code"

    See:
        `~.hiprtcResult`

    Args:
        result (`~.hiprtcResult`) -- *IN*:
            code to convert to string.

    Returns:
        A `~.tuple` of size 1 that contains (in that order):

        * `~.bytes`: const char pointer to the NULL-terminated error string
    """
    if not isinstance(result,_hiprtcResult__Base):
        raise TypeError("argument 'result' must be of type '_hiprtcResult__Base'")
    _hiprtcGetErrorString__retval = hip._util.types.CStr.fromPtr(<void*>chiprtc.hiprtcGetErrorString(result.value))
    return (None if _hiprtcGetErrorString__retval._ptr == NULL else _hiprtcGetErrorString__retval,)


@cython.embedsignature(True)
def hiprtcVersion():
    r"""Sets the parameters as major and minor version.

    Returns:
        A `~.tuple` of size 3 that contains (in that order):

        * `~.hiprtcResult`: `~.HIPRTC_ERROR_INVALID_INPUT`, `~.HIPRTC_SUCCESS`
        * `~.int`:
                HIP Runtime Compilation major version.
        * `~.int`:
                HIP Runtime Compilation minor version.
    """
    cdef int major
    cdef int minor
    _hiprtcVersion__retval = hiprtcResult(chiprtc.hiprtcVersion(&major,&minor))
    return (_hiprtcVersion__retval,major,minor)


cdef class _hiprtcProgram(hip._util.types.Pointer):
    """Python wrapper for cdef class chiprtc._hiprtcProgram.

    Python wrapper for cdef class chiprtc._hiprtcProgram.

    If this type is initialized via its `__init__` method, it allocates a
    member of the underlying C type and destroys it again if the wrapper
    type is deallocated.

    This type also serves as adapter when appearing as argument type in a
    function signature. In this case, the type can further be initialized
    from a number of Python objects:

    * `None`:

      This will set the ``self._ptr`` attribute to ``NULL``.

    * `int`:

      Interprets the integer value as pointer address and writes it to ``self._ptr``.
      No ownership is transferred.

    * `ctypes.c_void_p`:

      Takes the pointer address ``pyobj.value`` and writes it to ``self._ptr``.
      No ownership is transferred.

    * `object` that implements the `CUDA Array Interface <https://numba.readthedocs.io/en/stable/cuda/cuda_array_interface.html>`_ protocol:

      Takes the integer-valued pointer address, i.e. the first entry of the `data` tuple
      from `pyobj`'s member ``__cuda_array_interface__``  and writes it to ``self._ptr``.

    * `object` that implements the Python buffer protocol:

      If the object represents a simple contiguous array,
      writes the `Py_buffer` associated with ``pyobj`` to `self._py_buffer`,
      sets the `self._py_buffer_acquired` flag to `True`, and
      writes `self._py_buffer.buf` to the data pointer `self._ptr`.

    * `hip._util.types.Pointer`:

      Takes the pointer address ``pyobj._ptr`` and writes it to ``self._ptr``.
      No ownership is transferred.

    Type checks are performed in the above order.

    C Attributes:
        _ptr (C type ``void *``, protected):
            Stores a pointer to the data of the original Python object.
        _is_ptr_owner (C type ``bint``, protected):
            If this wrapper is the owner of the underlying data.
        _py_buffer (C type ``Py_buffer`, protected):
            Stores a pointer to the data of the original Python object.
        _py_buffer_acquired (C type ``bint``, protected):
            Stores a pointer to the data of the original Python object.
    """
    # C members declared in pxd file

    def __cinit__(self):
        self._ptr = NULL
        self._is_ptr_owner = False
        self._py_buffer_acquired = False

    cdef chiprtc._hiprtcProgram* getElementPtr(self):
        return <chiprtc._hiprtcProgram*>self._ptr

    @staticmethod
    cdef _hiprtcProgram fromPtr(void* ptr, bint owner=False):
        """Factory function to create ``_hiprtcProgram`` objects from
        given ``chiprtc._hiprtcProgram`` pointer.
        """
        # Fast call to __new__() that bypasses the __init__() constructor.
        cdef _hiprtcProgram wrapper = _hiprtcProgram.__new__(_hiprtcProgram)
        wrapper._ptr = ptr
        wrapper._is_ptr_owner = owner
        return wrapper

    @staticmethod
    def fromObj(pyobj):
        """Creates a _hiprtcProgram from a Python object.

        Derives a _hiprtcProgram from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``_hiprtcProgram`` reference, this method
        returns it directly. No new ``_hiprtcProgram`` is created in this case.
        """
        return _hiprtcProgram.fromPyobj(pyobj)

    @staticmethod
    cdef _hiprtcProgram fromPyobj(object pyobj):
        """Creates a _hiprtcProgram from a Python object.

        Derives a _hiprtcProgram from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``_hiprtcProgram`` reference, this method
        returns it directly. No new ``_hiprtcProgram`` is created in this case.

        Args:
            pyobj (object): Must be either `None`; a `hip._util.types.Pointer`; a simple, contiguous buffer according to the buffer protocol;
                            or of type `_hiprtcProgram`; `int`; or `ctypes.c_void_p`.

        Note:
            This routine does not perform a copy but returns the original ``pyobj``
            if ``pyobj`` is an instance of _hiprtcProgram!
        """
        cdef _hiprtcProgram wrapper

        if isinstance(pyobj,_hiprtcProgram):
            return pyobj
        else:
            wrapper = _hiprtcProgram.__new__(_hiprtcProgram)
            wrapper.init_from_pyobj(pyobj)
            return wrapper

    def __dealloc__(self):
        # Release the buffer handle
        if self._py_buffer_acquired is True:
            cpython.buffer.PyBuffer_Release(&self._py_buffer)

    def __int__(self):
        """Returns the data's address as long integer.
        """
        return cpython.long.PyLong_FromVoidPtr(self._ptr)

    def __repr__(self):
        return f"<_hiprtcProgram object, ptr: {int(self)}>"

    def as_c_void_p(self):
        """Returns the data's address as `ctypes.c_void_p`
        Note:
            Implemented as function to not collide with
            autogenerated property names.
        """
        return ctypes.c_void_p(int(self))

    @staticmethod
    def PROPERTIES():
        return []

    def __contains__(self,item):
        properties = self.PROPERTIES()
        return item in properties

    def __getitem__(self,item):
        properties = self.PROPERTIES()
        if isinstance(item,int):
            if item < 0 or item >= len(properties):
                raise IndexError()
            return getattr(self,properties[item])
        raise ValueError("'item' type must be 'int'")


hiprtcProgram = _hiprtcProgram

@cython.embedsignature(True)
def hiprtcAddNameExpression(object prog, object name_expression):
    r"""Adds the given name exprssion to the runtime compilation program.

    If const char pointer is NULL, it will return `~.HIPRTC_ERROR_INVALID_INPUT`.

    See:
        `~.hiprtcResult`

    Args:
        prog (`~._hiprtcProgram`/`~.object`) -- *IN*:
            runtime compilation program instance.

        name_expression (`~.hip._util.types.CStr`/`~.object`) -- *IN*:
            const char pointer to the name expression.

    Returns:
        A `~.tuple` of size 1 that contains (in that order):

        * `~.hiprtcResult`: `~.HIPRTC_SUCCESS`
    """
    _hiprtcAddNameExpression__retval = hiprtcResult(chiprtc.hiprtcAddNameExpression(
        _hiprtcProgram.fromPyobj(prog).getElementPtr(),
        <const char *>hip._util.types.CStr.fromPyobj(name_expression)._ptr))
    return (_hiprtcAddNameExpression__retval,)


@cython.embedsignature(True)
def hiprtcCompileProgram(object prog, int numOptions, object options):
    r"""Compiles the given runtime compilation program.

    If the compiler failed to build the runtime compilation program,
    it will return `~.HIPRTC_ERROR_COMPILATION`.

    See:
        `~.hiprtcResult`

    Args:
        prog (`~._hiprtcProgram`/`~.object`) -- *IN*:
            runtime compilation program instance.

        numOptions (`~.int`) -- *IN*:
            number of compiler options.

        options (`~.hip._util.types.ListOfBytes`/`~.object`) -- *IN*:
            compiler options as const array of strins.

    Returns:
        A `~.tuple` of size 1 that contains (in that order):

        * `~.hiprtcResult`: `~.HIPRTC_SUCCESS`
    """
    _hiprtcCompileProgram__retval = hiprtcResult(chiprtc.hiprtcCompileProgram(
        _hiprtcProgram.fromPyobj(prog).getElementPtr(),numOptions,
        <const char **>hip._util.types.ListOfBytes.fromPyobj(options)._ptr))
    return (_hiprtcCompileProgram__retval,)


@cython.embedsignature(True)
def hiprtcCreateProgram(object src, object name, int numHeaders, object headers, object includeNames):
    r"""Creates an instance of hiprtcProgram with the given input parameters,
    and sets the output hiprtcProgram prog with it.

    Any invalide input parameter, it will return `~.HIPRTC_ERROR_INVALID_INPUT`
    or `~.HIPRTC_ERROR_INVALID_PROGRAM`.

    If failed to create the program, it will return `~.HIPRTC_ERROR_PROGRAM_CREATION_FAILURE`.

    See:
        `~.hiprtcResult`

    Args:
        src (`~.hip._util.types.CStr`/`~.object`) -- *IN*:
            const char pointer to the program source.

        name (`~.hip._util.types.CStr`/`~.object`) -- *IN*:
            const char pointer to the program name.

        numHeaders (`~.int`) -- *IN*:
            number of headers.

        headers (`~.hip._util.types.ListOfBytes`/`~.object`) -- *IN*:
            array of strings pointing to headers.

        includeNames (`~.hip._util.types.ListOfBytes`/`~.object`) -- *IN*:
            array of strings pointing to names included in program source.

    Returns:
        A `~.tuple` of size 2 that contains (in that order):

        * `~.hiprtcResult`: `~.HIPRTC_SUCCESS`
        * `~._hiprtcProgram`:
                runtime compilation program instance.
    """
    prog = _hiprtcProgram.fromPtr(NULL)
    _hiprtcCreateProgram__retval = hiprtcResult(chiprtc.hiprtcCreateProgram(<chiprtc._hiprtcProgram**>&prog._ptr,
        <const char *>hip._util.types.CStr.fromPyobj(src)._ptr,
        <const char *>hip._util.types.CStr.fromPyobj(name)._ptr,numHeaders,
        <const char **>hip._util.types.ListOfBytes.fromPyobj(headers)._ptr,
        <const char **>hip._util.types.ListOfBytes.fromPyobj(includeNames)._ptr))
    return (_hiprtcCreateProgram__retval,None if prog._ptr == NULL else prog)


@cython.embedsignature(True)
def hiprtcDestroyProgram(object prog):
    r"""Destroys an instance of given hiprtcProgram.

    If prog is NULL, it will return `~.HIPRTC_ERROR_INVALID_INPUT`.

    See:
        `~.hiprtcResult`

    Args:
        prog (`~.hip._util.types.Pointer`/`~.object`) -- *IN*:
            runtime compilation program instance.

    Returns:
        A `~.tuple` of size 1 that contains (in that order):

        * `~.hiprtcResult`: `~.HIPRTC_SUCCESS`
    """
    _hiprtcDestroyProgram__retval = hiprtcResult(chiprtc.hiprtcDestroyProgram(
        <chiprtc.hiprtcProgram*>hip._util.types.Pointer.fromPyobj(prog)._ptr))
    return (_hiprtcDestroyProgram__retval,)


@cython.embedsignature(True)
def hiprtcGetLoweredName(object prog, object name_expression):
    r"""Gets the lowered (mangled) name from an instance of hiprtcProgram with the given input parameters,
    and sets the output lowered_name with it.

    If any invalide nullptr input parameters, it will return `~.HIPRTC_ERROR_INVALID_INPUT`

    If name_expression is not found, it will return `~.HIPRTC_ERROR_NAME_EXPRESSION_NOT_VALID`

    If failed to get lowered_name from the program, it will return `~.HIPRTC_ERROR_COMPILATION`.

    See:
        `~.hiprtcResult`

    Args:
        prog (`~._hiprtcProgram`/`~.object`) -- *IN*:
            runtime compilation program instance.

        name_expression (`~.hip._util.types.CStr`/`~.object`) -- *IN*:
            const char pointer to the name expression.

    Returns:
        A `~.tuple` of size 2 that contains (in that order):

        * `~.hiprtcResult`: `~.HIPRTC_SUCCESS`
        * `~.hip._util.types.CStr`/`~.object`:
                const char array to the lowered (mangled) name.
    """
    lowered_name = hip._util.types.CStr.fromPtr(NULL)
    _hiprtcGetLoweredName__retval = hiprtcResult(chiprtc.hiprtcGetLoweredName(
        _hiprtcProgram.fromPyobj(prog).getElementPtr(),
        <const char *>hip._util.types.CStr.fromPyobj(name_expression)._ptr,
        <const char **>&lowered_name._ptr))
    return (_hiprtcGetLoweredName__retval,None if lowered_name._ptr == NULL else lowered_name)


@cython.embedsignature(True)
def hiprtcGetProgramLog(object prog, object log):
    r"""Gets the log generated by the runtime compilation program instance.

    See:
        `~.hiprtcResult`

    Args:
        prog (`~._hiprtcProgram`/`~.object`) -- *IN*:
            runtime compilation program instance.

        log (`~.hip._util.types.CStr`/`~.object`) -- *OUT*:
            memory pointer to the generated log.

    Returns:
        A `~.tuple` of size 1 that contains (in that order):

        * `~.hiprtcResult`: `~.HIPRTC_SUCCESS`
    """
    _hiprtcGetProgramLog__retval = hiprtcResult(chiprtc.hiprtcGetProgramLog(
        _hiprtcProgram.fromPyobj(prog).getElementPtr(),
        <char *>hip._util.types.CStr.fromPyobj(log)._ptr))
    return (_hiprtcGetProgramLog__retval,)


@cython.embedsignature(True)
def hiprtcGetProgramLogSize(object prog):
    r"""Gets the size of log generated by the runtime compilation program instance.

    See:
        `~.hiprtcResult`

    Args:
        prog (`~._hiprtcProgram`/`~.object`) -- *IN*:
            runtime compilation program instance.

    Returns:
        A `~.tuple` of size 2 that contains (in that order):

        * `~.hiprtcResult`: `~.HIPRTC_SUCCESS`
        * `~.int`:
                size of generated log.
    """
    cdef unsigned long logSizeRet
    _hiprtcGetProgramLogSize__retval = hiprtcResult(chiprtc.hiprtcGetProgramLogSize(
        _hiprtcProgram.fromPyobj(prog).getElementPtr(),&logSizeRet))
    return (_hiprtcGetProgramLogSize__retval,logSizeRet)


@cython.embedsignature(True)
def hiprtcGetCode(object prog, object code):
    r"""Gets the pointer of compilation binary by the runtime compilation program instance.

    See:
        `~.hiprtcResult`

    Args:
        prog (`~._hiprtcProgram`/`~.object`) -- *IN*:
            runtime compilation program instance.

        code (`~.hip._util.types.NDBuffer`/`~.object`) -- *OUT*:
            char pointer to binary.

    Returns:
        A `~.tuple` of size 1 that contains (in that order):

        * `~.hiprtcResult`: `~.HIPRTC_SUCCESS`
    """
    _hiprtcGetCode__retval = hiprtcResult(chiprtc.hiprtcGetCode(
        _hiprtcProgram.fromPyobj(prog).getElementPtr(),
        <char *>hip._util.types.NDBuffer.fromPyobj(code)._ptr))
    return (_hiprtcGetCode__retval,)


@cython.embedsignature(True)
def hiprtcGetCodeSize(object prog):
    r"""Gets the size of compilation binary by the runtime compilation program instance.

    See:
        `~.hiprtcResult`

    Args:
        prog (`~._hiprtcProgram`/`~.object`) -- *IN*:
            runtime compilation program instance.

    Returns:
        A `~.tuple` of size 2 that contains (in that order):

        * `~.hiprtcResult`: `~.HIPRTC_SUCCESS`
        * `~.int`:
                the size of binary.
    """
    cdef unsigned long codeSizeRet
    _hiprtcGetCodeSize__retval = hiprtcResult(chiprtc.hiprtcGetCodeSize(
        _hiprtcProgram.fromPyobj(prog).getElementPtr(),&codeSizeRet))
    return (_hiprtcGetCodeSize__retval,codeSizeRet)


@cython.embedsignature(True)
def hiprtcGetBitcode(object prog, object bitcode):
    r"""Gets the pointer of compiled bitcode by the runtime compilation program instance.

    See:
        `~.hiprtcResult`

    Args:
        prog (`~._hiprtcProgram`/`~.object`) -- *IN*:
            runtime compilation program instance.

        bitcode (`~.hip._util.types.NDBuffer`/`~.object`) -- *OUT*:
            char pointer to bitcode.

    Returns:
        A `~.tuple` of size 1 that contains (in that order):

        * `~.hiprtcResult`: HIPRTC_SUCCESS
    """
    _hiprtcGetBitcode__retval = hiprtcResult(chiprtc.hiprtcGetBitcode(
        _hiprtcProgram.fromPyobj(prog).getElementPtr(),
        <char *>hip._util.types.NDBuffer.fromPyobj(bitcode)._ptr))
    return (_hiprtcGetBitcode__retval,)


@cython.embedsignature(True)
def hiprtcGetBitcodeSize(object prog):
    r"""Gets the size of compiled bitcode by the runtime compilation program instance.

    See:
        `~.hiprtcResult`

    Args:
        prog (`~._hiprtcProgram`/`~.object`) -- *IN*:
            runtime compilation program instance.

    Returns:
        A `~.tuple` of size 2 that contains (in that order):

        * `~.hiprtcResult`: `~.HIPRTC_SUCCESS`
        * `~.int`:
                the size of bitcode.
    """
    cdef unsigned long bitcode_size
    _hiprtcGetBitcodeSize__retval = hiprtcResult(chiprtc.hiprtcGetBitcodeSize(
        _hiprtcProgram.fromPyobj(prog).getElementPtr(),&bitcode_size))
    return (_hiprtcGetBitcodeSize__retval,bitcode_size)


@cython.embedsignature(True)
def hiprtcLinkCreate(unsigned int num_options, object option_ptr, object option_vals_pptr):
    r"""Creates the link instance via hiprtc APIs.

    See:
        `~.hiprtcResult`

    Args:
        num_options (`~.int`) -- *IN*:
            Number of options

        option_ptr (`~.hip._hiprtc_helpers.HiprtcLinkCreate_option_ptr`/`~.object`) -- *IN*:
            Array of options

        option_vals_pptr (`~.hip._util.types.ListOfPointer`/`~.object`) -- *IN*:
            Array of option values cast to void*

    Returns:
        A `~.tuple` of size 2 that contains (in that order):

        * `~.hiprtcResult`: `~.HIPRTC_SUCCESS`, `~.HIPRTC_ERROR_INVALID_INPUT`, `~.HIPRTC_ERROR_INVALID_OPTION`
        * `~.ihiprtcLinkState`:
                hiprtc link state created upon success
    """
    hip_link_state_ptr = ihiprtcLinkState.fromPtr(NULL)
    _hiprtcLinkCreate__retval = hiprtcResult(chiprtc.hiprtcLinkCreate(num_options,
        <chiprtc.hiprtcJIT_option *>hip._hiprtc_helpers.HiprtcLinkCreate_option_ptr.fromPyobj(option_ptr)._ptr,
        <void **>hip._util.types.ListOfPointer.fromPyobj(option_vals_pptr)._ptr,<chiprtc.ihiprtcLinkState**>&hip_link_state_ptr._ptr))
    return (_hiprtcLinkCreate__retval,None if hip_link_state_ptr._ptr == NULL else hip_link_state_ptr)


@cython.embedsignature(True)
def hiprtcLinkAddFile(object hip_link_state, object input_type, object file_path, unsigned int num_options, object options_ptr, object option_values):
    r"""Adds a file with bit code to be linked with options

    If input values are invalid, it will

    See:
        `~.hiprtcResult`

    Args:
        hip_link_state (`~.ihiprtcLinkState`/`~.object`) -- *IN*:
            hiprtc link state

        input_type (`~.hiprtcJITInputType`) -- *IN*:
            Type of the input data or bitcode

        file_path (`~.hip._util.types.CStr`/`~.object`) -- *IN*:
            Path to the input file where bitcode is present

        num_options (`~.int`) -- *IN*:
            Size of the options

        options_ptr (`~.hip._util.types.Pointer`/`~.object`) -- *IN*:
            Array of options applied to this input

        option_values (`~.hip._util.types.Pointer`/`~.object`) -- *IN*:
            Array of option values cast to void*

    Returns:
        A `~.tuple` of size 1 that contains (in that order):

        * `~.hiprtcResult`: One of:
                -        `~.HIPRTC_SUCCESS`

                - `~.HIPRTC_ERROR_INVALID_INPUT`
    """
    if not isinstance(input_type,_hiprtcJITInputType__Base):
        raise TypeError("argument 'input_type' must be of type '_hiprtcJITInputType__Base'")
    _hiprtcLinkAddFile__retval = hiprtcResult(chiprtc.hiprtcLinkAddFile(
        ihiprtcLinkState.fromPyobj(hip_link_state).getElementPtr(),input_type.value,
        <const char *>hip._util.types.CStr.fromPyobj(file_path)._ptr,num_options,
        <chiprtc.hiprtcJIT_option *>hip._util.types.Pointer.fromPyobj(options_ptr)._ptr,
        <void **>hip._util.types.Pointer.fromPyobj(option_values)._ptr))
    return (_hiprtcLinkAddFile__retval,)


@cython.embedsignature(True)
def hiprtcLinkAddData(object hip_link_state, object input_type, object image, unsigned long image_size, object name, unsigned int num_options, object options_ptr, object option_values):
    r"""Completes the linking of the given program.

    If adding the file fails, it will

    See:
        `~.hiprtcResult`

    Args:
        hip_link_state (`~.ihiprtcLinkState`/`~.object`) -- *IN*:
            hiprtc link state

        input_type (`~.hiprtcJITInputType`) -- *IN*:
            Type of the input data or bitcode

        image (`~.hip._util.types.Pointer`/`~.object`) -- *IN*:
            Input data which is null terminated

        image_size (`~.int`) -- *IN*:
            Size of the input data

        name (`~.hip._util.types.CStr`/`~.object`) -- *IN*:
            Optional name for this input

        num_options (`~.int`) -- *IN*:
            Size of the options

        options_ptr (`~.hip._util.types.Pointer`/`~.object`) -- *IN*:
            Array of options applied to this input

        option_values (`~.hip._util.types.Pointer`/`~.object`) -- *IN*:
            Array of option values cast to void*

    Returns:
        A `~.tuple` of size 1 that contains (in that order):

        * `~.hiprtcResult`: One of:
                -        `~.HIPRTC_SUCCESS`, `~.HIPRTC_ERROR_INVALID_INPUT`

                - `~.HIPRTC_ERROR_PROGRAM_CREATION_FAILURE`
    """
    if not isinstance(input_type,_hiprtcJITInputType__Base):
        raise TypeError("argument 'input_type' must be of type '_hiprtcJITInputType__Base'")
    _hiprtcLinkAddData__retval = hiprtcResult(chiprtc.hiprtcLinkAddData(
        ihiprtcLinkState.fromPyobj(hip_link_state).getElementPtr(),input_type.value,
        <void *>hip._util.types.Pointer.fromPyobj(image)._ptr,image_size,
        <const char *>hip._util.types.CStr.fromPyobj(name)._ptr,num_options,
        <chiprtc.hiprtcJIT_option *>hip._util.types.Pointer.fromPyobj(options_ptr)._ptr,
        <void **>hip._util.types.Pointer.fromPyobj(option_values)._ptr))
    return (_hiprtcLinkAddData__retval,)


@cython.embedsignature(True)
def hiprtcLinkComplete(object hip_link_state):
    r"""Completes the linking of the given program.

    If adding the data fails, it will

    See:
        `~.hiprtcResult`

    Args:
        hip_link_state (`~.ihiprtcLinkState`/`~.object`) -- *IN*:
            hiprtc link state

    Returns:
        A `~.tuple` of size 3 that contains (in that order):

        * `~.hiprtcResult`: One of:
                -        `~.HIPRTC_SUCCESS`

                - `~.HIPRTC_ERROR_LINKING`
        * `~.hip._util.types.NDBuffer`/`~.object`:
                Upon success, points to the output binary
        * `~.int`:
                Size of the binary is stored (optional)
    """
    bin_out = hip._util.types.NDBuffer.fromPtr(NULL)
    cdef unsigned long size_out
    _hiprtcLinkComplete__retval = hiprtcResult(chiprtc.hiprtcLinkComplete(
        ihiprtcLinkState.fromPyobj(hip_link_state).getElementPtr(),
        <void **>&bin_out._ptr,&size_out))
    return (_hiprtcLinkComplete__retval,None if bin_out._ptr == NULL else bin_out,size_out)


@cython.embedsignature(True)
def hiprtcLinkDestroy(object hip_link_state):
    r"""Deletes the link instance via hiprtc APIs.

    See:
        `~.hiprtcResult`

    Args:
        hip_link_state (`~.ihiprtcLinkState`/`~.object`) -- *IN*:
            link state instance

    Returns:
        A `~.tuple` of size 1 that contains (in that order):

        * `~.hiprtcResult`: `~.HIPRTC_SUCCESS`
    """
    _hiprtcLinkDestroy__retval = hiprtcResult(chiprtc.hiprtcLinkDestroy(
        ihiprtcLinkState.fromPyobj(hip_link_state).getElementPtr()))
    return (_hiprtcLinkDestroy__retval,)

__all__ = [
    "_hiprtcResult__Base",
    "hiprtcResult",
    "_hiprtcJIT_option__Base",
    "hiprtcJIT_option",
    "_hiprtcJITInputType__Base",
    "hiprtcJITInputType",
    "ihiprtcLinkState",
    "hiprtcLinkState",
    "hiprtcGetErrorString",
    "hiprtcVersion",
    "_hiprtcProgram",
    "hiprtcProgram",
    "hiprtcAddNameExpression",
    "hiprtcCompileProgram",
    "hiprtcCreateProgram",
    "hiprtcDestroyProgram",
    "hiprtcGetLoweredName",
    "hiprtcGetProgramLog",
    "hiprtcGetProgramLogSize",
    "hiprtcGetCode",
    "hiprtcGetCodeSize",
    "hiprtcGetBitcode",
    "hiprtcGetBitcodeSize",
    "hiprtcLinkCreate",
    "hiprtcLinkAddFile",
    "hiprtcLinkAddData",
    "hiprtcLinkComplete",
    "hiprtcLinkDestroy",
]